<!DOCTYPE html>
<html lang="en">





<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#005f6b">
  <meta name="description" content="Software Security Researcher">
  <meta name="author" content>
  <meta name="keywords" content>
  <title>2014-AliCTF-EvilAPK_3 - AssassinQ</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">


<!-- 自定义样式保持在最底部 -->


<link rel="alternate" href="/atom.xml" title="AssassinQ" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>AssassinQ</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">Links</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Saturday, February 15th 2020, 7:41 pm
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    6.6k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      37 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <p>接触了一段时间的安卓后复现一下经典的题目，具体审计还有分析的步骤不做记录。</p>
<a id="more"></a>
<h1 id="Analysis（classes-dex）"><a href="#Analysis（classes-dex）" class="headerlink" title="Analysis（classes.dex）"></a>Analysis（classes.dex）</h1><p>这道题目是阿里 14 年出的，先导入 jadx 看看反编译后大概的内容。在 AndroidManifest.xml 中，可以看到先设置了入口点为 com.ali.mobisecenhance.StubApplication，猜测这里可能是阿里加固自己添加的一个入口，用来执行一些初始化的操作，比如解密 dex，反调试，检测模拟器等等之类的。调用完 StubApplication 后，才会调用 MainActivity：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ali.tg.testapp&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt;
    &lt;uses-sdk android:minSdkVersion=&quot;8&quot; android:targetSdkVersion=&quot;9&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    &lt;application android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:name=&quot;com.ali.mobisecenhance.StubApplication&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot;&gt;
        &lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.MainActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
        &lt;activity android:name=&quot;.WebViewActivity&quot; /&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>
<p>在反编译出来的 Java 文件中，只能找到一个 StubApplication 类，其中的函数都是在 Native 层所实现，且加载了一个 mobisec 库。一般程序中是先执行 onCreate 函数，但 attachBaseContext 函数会早于 onCreate 函数执行：</p>
<pre><code class="java">package com.ali.mobisecenhance;

import android.app.Application;
import android.content.Context;

public class StubApplication extends Application {
    private native void b(ClassLoader classLoader, Context context);

    protected native void attachBaseContext(Context context);

    public native void onCreate();

    static {
        System.loadLibrary(&quot;mobisec&quot;);
    }
}
</code></pre>
<p>可以在 lib 文件夹下看到 libmobisec.so 库，同时还可以看到在 assets 文件夹中有两个 jar 文件：</p>
<pre><code class="bash">$ tree .
.
├── AndroidManifest.xml
├── META-INF
│   ├── MANIFEST.MF
│   ├── TEST.RSA
│   └── TEST.SF
├── assets
│   ├── cls.jar
│   └── fak.jar
├── classes.dex
├── lib
│   ├── armeabi
│   │   ├── libhack.so
│   │   ├── libmobisec.so
│   │   └── libtranslate.so
│   ├── armeabi-v7a
│   │   ├── libhack.so
│   │   ├── libmobisec.so
│   │   └── libtranslate.so
│   └── x86
│       ├── libhack.so
│       ├── libmobisec.so
│       └── libtranslate.so
├── res
│   ├── drawable-hdpi
│   │   ├── android.jpg
│   │   └── android1.jpg
│   ├── drawable-mdpi
│   │   └── ic_launcher.png
│   ├── drawable-xhdpi
│   │   └── ic_launcher.png
│   ├── drawable-xxhdpi
│   │   └── ic_launcher.png
│   └── layout
│       ├── activity_main.xml
│       └── webviewlayout.xml
└── resources.arsc

12 directories, 24 files
</code></pre>
<p>file 一下，发现是 cls.jar 是一段不可识别的数据，fak.jar 判断出来是个 zip 文件：</p>
<pre><code class="bash">$ file cls.jar
cls.jar: data

$ file fak.jar
fak.jar: Zip archive data, at least v?[0x314] to extract
</code></pre>
<p>经过以上粗略的审计，可以猜测可能是在 libmobisec.so 实现了 StubApplication 中的函数，并对 assets 文件夹下的两个文件进行操作来还原出 MainActivity 中的函数。</p>
<h1 id="Analysis（libmobisec-so）"><a href="#Analysis（libmobisec-so）" class="headerlink" title="Analysis（libmobisec.so）"></a>Analysis（libmobisec.so）</h1><p>打开 IDA，最先定位到 JNI_OnLoad 函数，查看一下注册了哪些函数：</p>
<pre><code class="cpp">signed int __fastcall JNI_OnLoad(_JavaVM *vm, int a2)
{
  const char *v2; // r2
  jclass v3; // r1
  signed int result; // r0
  bool v5; // zf
  _JNIEnv *env; // [sp+4h] [bp-Ch]

  env = (_JNIEnv *)a2;
  if ( vm-&gt;functions-&gt;GetEnv(&amp;vm-&gt;functions, (void **)&amp;env, 65542) )
  {
    v2 = &quot;Failed to get the environment&quot;;
LABEL_5:
    _android_log_print(6, &quot;debug&quot;, v2);
    return -1;
  }
  v3 = env-&gt;functions-&gt;FindClass(&amp;env-&gt;functions, &quot;com/ali/mobisecenhance/StubApplication&quot;);// locate class
  if ( !v3 )
  {
    v2 = &quot;failed to get class reference&quot;;
    goto LABEL_5;
  }
  v5 = env-&gt;functions-&gt;RegisterNatives(&amp;env-&gt;functions, v3, (const JNINativeMethod *)gMethods, 2) == 0;// register 2 methods
  result = 65542;
  if ( !v5 )
    result = -1;
  return result;
}
</code></pre>
<p>在 RegisterNatives 函数的参数中可以看到注册了两个函数，分别为 attachBaseContext 和 onCreate。在内存中可以找到两个函数对应的指针：</p>
<pre><code>.data:00054010 gMethods        DCD aAttachbasecont_0   ; DATA XREF: JNI_OnLoad+44↑o
.data:00054010                                         ; .text:off_24784↑o
.data:00054010                                         ; &quot;attachBaseContext&quot;
.data:00054014                 DCD aLandroidConten_1   ; &quot;(Landroid/content/Context;)V&quot;
.data:00054018                 DCD sub_24D3C+1
.data:0005401C                 DCD aOncreate           ; &quot;onCreate&quot;
.data:00054020                 DCD aV                  ; &quot;()V&quot;
.data:00054024                 DCD sub_24498+1
</code></pre><p>因为 attachBaseContext 先于 onCreate 函数执行，这里先看一下 attachBaseContext。跟着 log 可以对函数有一个大体的了解，在一处 log 里有“enter new application”的信息，猜测可能是完成了解码进入 MainActivity。在该处上下看看可以发现一个 parse_dex 函数，很有可能是解析出真正的 dex 文件的函数：</p>
<pre><code class="cpp">int __fastcall attachBaseContext(_JNIEnv *a1, jobject *a2, jobject *a3)
{
  jobject *v3; // r8
  jobject *v4; // r10
  _JNIEnv *env; // r4
  _JNIEnv *v6; // r1
  int v7; // r2
  int result; // r0
  ali *v9; // r0
  int v10; // r0
  int v11; // r0
  int v12; // r0
  int v13; // r5
  int v14; // r0
  int v15; // r0
  int v16; // r0
  int v17; // r0
  int v18; // r0
  char *v19; // r0
  int v20; // r0
  int v21; // r0
  void *v22; // r0
  void *v23; // r8
  const char *v24; // r0
  const char *v25; // r5
  size_t v26; // r0
  int v27; // r5
  int v28; // r8
  int v29; // r0
  int v30; // r5
  const char *v31; // r2
  int v32; // r0
  ali *v33; // r0
  int v34; // r4
  unsigned __int64 v35; // r2
  int v36; // [sp+8h] [bp-78h]
  __int64 v37; // [sp+18h] [bp-68h]
  char v38; // [sp+24h] [bp-5Ch]
  char v39; // [sp+3Ch] [bp-44h]
  char *v40; // [sp+4Ch] [bp-34h]
  char *v41; // [sp+50h] [bp-30h]

  v3 = a2;
  v4 = a3;
  env = a1;
  _android_log_print(6, &quot;debug&quot;, &quot;in...&quot;);
  result = ali::init_classes(env, v6, v7);      // init classes
  if ( result )
    return result;
  v9 = (ali *)_JNIEnv::CallNonvirtualVoidMethod(env, v3, ali::ContextWrapper, dword_54128, v4);
  v36 = ali::NanoTime(v9);
  v10 = _JNIEnv::GetObjectClass(env, v3);
  v11 = _JNIEnv::GetMethodID(env, v10, &quot;getFilesDir&quot;, &quot;()Ljava/io/File;&quot;);
  v12 = _JNIEnv::CallObjectMethod(env, v3, v11);
  v13 = v12;
  v14 = _JNIEnv::GetObjectClass(env, v12);
  v15 = _JNIEnv::GetMethodID(env, v14, &quot;getAbsolutePath&quot;, &quot;()Ljava/lang/String;&quot;);
  v16 = _JNIEnv::CallObjectMethod(env, v13, v15);
  sub_247D8(&amp;v39, env, v16);
  if ( &amp;v39 != (char *)&amp;ali::g_filePath )
    std::string::_M_assign((std::string *)&amp;ali::g_filePath, v41, v40);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);
  _android_log_print(3, &quot;debug&quot;, &quot;global files path is %s&quot;, dword_540E8);
  v17 = _JNIEnv::CallObjectMethod(env, v3, dword_541A4);
  if ( ali::sdk_int &lt;= 8 )
  {
    v20 = _JNIEnv::GetObjectField(env, v17, dword_5416C);
    sub_247D8(&amp;v38, env, v20);
    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v39, &amp;v38, &quot;/lib&quot;);
    if ( &amp;v39 != (char *)&amp;ali::g_libPath )
      std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40);
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);
    v19 = &amp;v38;
  }
  else
  {
    v18 = _JNIEnv::GetObjectField(env, v17, dword_54170);
    sub_247D8(&amp;v39, env, v18);
    if ( &amp;v39 != (char *)&amp;ali::g_libPath )
      std::string::_M_assign((std::string *)&amp;ali::g_libPath, v41, v40);
    v19 = &amp;v39;
  }
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v19);
  _android_log_print(3, &quot;debug&quot;, &quot;global native path is %s&quot;, dword_540D0);
  v21 = _JNIEnv::CallObjectMethod(env, v3, dword_541B0);
  sub_247D8(&amp;v39, env, v21);
  if ( &amp;v39 != (char *)&amp;ali::g_apkPath )
    std::string::_M_assign((std::string *)&amp;ali::g_apkPath, v41, v40);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v39);
  setenv(&quot;APKPATH&quot;, (const char *)dword_540B8, 1);
  _android_log_print(3, &quot;debug&quot;, &quot;global apk path is %s&quot;, dword_540B8);
  sub_24A64(env, v3);
  v22 = (void *)_JNIEnv::CallObjectMethod(env, v4, dword_541A0);
  v23 = v22;
  if ( v22 )
  {
    v24 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, v22, 0);
    v25 = v24;
    v26 = strlen(v24);
    std::string::_M_assign((std::string *)&amp;ali::g_pkgName, v25, &amp;v25[v26]);
    env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, v23, v25);
  }
  v37 = 0LL;
  v27 = _JNIEnv::CallObjectMethod(env, v4, dword_541A8);
  parse_dex(env, &amp;v37);                         // parse dex?
  replace_classloader_cookie(env, v27, v37, HIDWORD(v37));
  _android_log_print(3, &quot;debug&quot;, &quot;enter new application&quot;);// enter MainActivity?
  v28 = dword_54120;
  _JNIEnv::NewStringUTF(env, &quot;android.app.Application&quot;);
  v29 = _JNIEnv::CallObjectMethod(env, v27, v28);
  v30 = v29;
  if ( v29 )
  {
    v32 = _JNIEnv::GetMethodID(env, v29, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
    dword_540A0 = _JNIEnv::NewObject(env, v30, v32);
    _JNIEnv::CallVoidMethod(env, dword_540A0, dword_54134, v4);
    _JNIEnv::DeleteLocalRef(env, v30);
    v31 = &quot;exit new application&quot;;
  }
  else
  {
    v31 = &quot;can&#39;t findClass realAppClass&quot;;
  }
  v33 = (ali *)_android_log_print(3, &quot;debug&quot;, v31);
  if ( dword_540A0 )
  {
    v33 = (ali *)env-&gt;functions-&gt;NewGlobalRef(&amp;env-&gt;functions, (jobject)dword_540A0);
    dword_540A0 = (int)v33;
  }
  v34 = ali::NanoTime(v33);
  _android_log_print(3, &quot;debug&quot;, &quot;##### attachBaseContext spent:&quot;);
  ali::PrettyDuration((ali *)(v34 - v36), v35);
  result = _android_log_print(3, &quot;debug&quot;, &quot;exit attachBaseContext&quot;);
  return result;
}
</code></pre>
<p>接下来进入 parse_dex 进行分析。一开始判断了是采用了 Dalvik 模式还是 ART 模式。我的机器是 Android 4.4.4，用的是 Dalvik 模式，那就只分析一下 Dalvik 的部分。接下来对 SDK 的版本进行了判断，是否大于 SDK13。我用的机器是 SDK19，故下面应该是调用了 openWithHeader 函数。之后的部分看到是用 dlopen 打开 libdvm.so，并开始执行程序，所以就不做进一步分析。主要应该就是 openWithHeader 中的内容解析了出了 dex 文件：</p>
<pre><code class="cpp">signed int __fastcall parse_dex(_JNIEnv *a1, __int64 *a2)
{
  int v2; // r7
  const char *v3; // r1
  char *v4; // r0
  char *v5; // r9
  unsigned __int8 *v6; // r3
  int v7; // r2
  int v8; // t1
  int fd; // ST14_4
  int v10; // r8
  int v11; // r7
  int v12; // r5
  int v13; // r0
  int v14; // r5
  int v15; // r0
  int v16; // r7
  int v17; // r1
  int v18; // r5
  int (__fastcall *v19)(int, signed int); // r5
  int v20; // r5
  unsigned __int8 *v21; // r8
  const char *v22; // r3
  char *v23; // r0
  char *v24; // r0
  char *v25; // r6
  ali::EncFile *v26; // r7
  int v27; // r0
  int *v28; // r0
  char *v29; // r0
  int v30; // r10
  void *v31; // r7
  int (__fastcall *v32)(unsigned __int8 *, int, signed int *); // r9
  int (__fastcall *v33)(_DWORD); // r7
  const char *v34; // r2
  int v35; // r9
  signed int v36; // r7
  _DWORD *v37; // r9
  _BYTE *v38; // r5
  unsigned __int8 *v39; // r3
  void *v40; // r0
  JNINativeMethod *v41; // r0
  unsigned __int8 *v42; // r3
  signed int v43; // r3
  _JNIEnv *v45; // [sp+8h] [bp-2A0h]
  __int64 *v46; // [sp+10h] [bp-298h]
  int v47; // [sp+24h] [bp-284h]
  unsigned __int8 *v48; // [sp+28h] [bp-280h]
  unsigned __int8 *v49; // [sp+2Ch] [bp-27Ch]
  void (__cdecl *v50)(const unsigned int *, jvalue *); // [sp+30h] [bp-278h]
  char v51; // [sp+34h] [bp-274h]
  signed int v52[2]; // [sp+38h] [bp-270h]
  char s; // [sp+40h] [bp-268h]
  char v54; // [sp+54h] [bp-254h]
  int v55; // [sp+64h] [bp-244h]
  int v56; // [sp+68h] [bp-240h]
  char v57; // [sp+6Ch] [bp-23Ch]
  const char *v58; // [sp+80h] [bp-228h]
  char v59; // [sp+84h] [bp-224h]
  const char *v60; // [sp+98h] [bp-210h]
  char v61; // [sp+9Ch] [bp-20Ch]
  unsigned int v62; // [sp+B0h] [bp-1F8h]
  char v63; // [sp+B4h] [bp-1F4h]
  char v64; // [sp+CCh] [bp-1DCh]
  int v65; // [sp+E0h] [bp-1C8h]
  char v66; // [sp+E4h] [bp-1C4h]
  char v67; // [sp+FCh] [bp-1ACh]
  const char *v68; // [sp+110h] [bp-198h]
  char v69; // [sp+114h] [bp-194h]
  char v70; // [sp+12Ch] [bp-17Ch]
  const char *v71; // [sp+140h] [bp-168h]
  char v72; // [sp+144h] [bp-164h]
  char *v73; // [sp+154h] [bp-154h]
  char *v74; // [sp+158h] [bp-150h]
  char v75; // [sp+15Ch] [bp-14Ch]
  char v76; // [sp+174h] [bp-134h]
  char v77; // [sp+18Ch] [bp-11Ch]
  char v78; // [sp+1A4h] [bp-104h]
  char v79; // [sp+1BCh] [bp-ECh]
  char v80; // [sp+1D4h] [bp-D4h]
  char v81; // [sp+1ECh] [bp-BCh]
  char v82; // [sp+204h] [bp-A4h]
  char v83; // [sp+21Ch] [bp-8Ch]
  char v84; // [sp+234h] [bp-74h]
  int v85; // [sp+244h] [bp-64h]
  unsigned __int8 *v86; // [sp+248h] [bp-60h]
  char v87; // [sp+24Ch] [bp-5Ch]
  char v88; // [sp+264h] [bp-44h]
  char *v89; // [sp+274h] [bp-34h]
  char *v90; // [sp+278h] [bp-30h]

  v45 = a1;
  v46 = a2;
  _android_log_print(3, &quot;debug&quot;, &quot;enter parse_dex&quot;);
  if ( ali::isDalvik )                          // dalvik or art
  {
    v47 = 0;
    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;ali::g_filePath, &quot;/cls.jar&quot;);// locate cls.jar
    v25 = v90;
    v26 = (ali::EncFile *)operator new(0xCu);
    ali::EncFile::EncFile(v26, v25);
    v48 = 0;
    v49 = 0;
    if ( ali::sdk_int &gt; 13 )                    // sdk version &gt; 13
    {
      v27 = ali::EncFile::openWithHeader(v26, &amp;v48, (unsigned int *)&amp;v47, 0x10u);
      v49 = v48 + 16;
    }
    else                                        // sdk version &lt;= 13 ( android 3.x )
    {
      v27 = ali::EncFile::open(v26, &amp;v49, (unsigned int *)&amp;v47);
    }
    if ( v49 == (unsigned __int8 *)-1 )
    {
      v28 = (int *)_errno(v27);
      v29 = strerror(*v28);
      _android_log_print(3, &quot;debug&quot;, &quot;mmap dex file :%s&quot;, v29);
LABEL_45:
      v24 = &amp;v88;
      goto LABEL_46;
    }
    v30 = *((_DWORD *)v49 + 8);
    if ( ali::sdk_int &gt; 13 )                    // sdk version &gt; 13
    {
      v40 = dlopen(&quot;libdvm.so&quot;, 1);             // open libdvm.so and start execute program
      v41 = (JNINativeMethod *)dlsym(v40, &quot;dvm_dalvik_system_DexFile&quot;);
      v50 = 0;
      lookup(v41, &quot;openDexFile&quot;, &quot;([B)I&quot;, &amp;v50);
      v42 = v48;
      *((_DWORD *)v48 + 2) = v47;
      *(_DWORD *)&amp;v51 = v42;
      ((void (*)(void))v50)();
      v43 = v52[0];
      *v46 = v52[0];
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 32) = *(_DWORD *)(v43 + 16);
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v43 + 8) + 4) + 36) = v47;
      ali::EncFile::~EncFile(v26);
      operator delete((void *)v26);
    }
    else                                        // sdk version &lt;= 13 ( android 3.x )
    {
      v31 = dlopen(&quot;libdvm.so&quot;, 1);
      v32 = (int (__fastcall *)(unsigned __int8 *, int, signed int *))dlsym(v31, &quot;dvmDexFileOpenPartial&quot;);
      v33 = (int (__fastcall *)(_DWORD))dlsym(v31, &quot;dexCreateClassLookup&quot;);
      v52[0] = 0;
      if ( v32(v49, v30, v52) == -1 )
      {
        v34 = &quot;dvmDexFileOpenPartial error&quot;;
LABEL_40:
        _android_log_print(3, &quot;debug&quot;, v34);
        goto LABEL_45;
      }
      v35 = *(_DWORD *)v52[0];
      *(_DWORD *)(v35 + 36) = v33(*(_DWORD *)v52[0]);
      v36 = v52[0];
      if ( !*(_DWORD *)(*(_DWORD *)v52[0] + 36) )
      {
        v34 = &quot;dexCreateClassLookup error&quot;;
        goto LABEL_40;
      }
      v37 = malloc(0x2Cu);
      v38 = malloc(0x14u);
      strdup((const char *)&amp;unk_4CEE9);
      v38[4] = 0;
      v38[5] = 0;
      *((_DWORD *)v38 + 2) = 0;
      v39 = v49;
      *(_DWORD *)v38 = v38;
      *((_DWORD *)v38 + 3) = v37;
      v37[10] = v36;
      *(_DWORD *)(v36 + 32) = v39;
      *(_DWORD *)(v36 + 36) = v47;
      *v46 = (signed int)v38;
    }
    v23 = &amp;v88;
    goto LABEL_44;
  }
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v54, &amp;ali::g_filePath, &quot;/cls.jar&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v57, &amp;ali::g_filePath, &quot;/cls.dex&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v59, &amp;ali::g_filePath, &quot;/fak.jar&quot;);
  _android_log_print(3, &quot;debug&quot;, &quot;before oat gen&quot;);
  if ( !access(v58, 0) )
    goto LABEL_24;
  v2 = android_getCpuFamily();
  std::string::string(&amp;v63, &quot;arm&quot;, &amp;v51);
  switch ( v2 )
  {
    case 1:
      v3 = &quot;arm&quot;;
LABEL_5:
      std::string::operator=(&amp;v63, v3);
      break;
    case 2:
      v3 = &quot;x86&quot;;
      goto LABEL_5;
    case 3:
    case 6:
      v3 = &quot;mips&quot;;
      goto LABEL_5;
    case 4:
      v3 = &quot;arm64&quot;;
      goto LABEL_5;
    case 5:
      v3 = &quot;x86_64&quot;;
      goto LABEL_5;
  }
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v64, &amp;ali::g_libPath, &quot;/libhack.so&quot;);
  v4 = getenv(&quot;LD_PRELOAD&quot;);
  v5 = v4;
  if ( v4 )
  {
    _android_log_print(3, &quot;debug&quot;, &quot;the system already define LD_PRELOAD=%s&quot;, v4);
    std::string::string(&amp;v84, v5, v52);
    v6 = v86;
    v7 = v85;
    while ( v6 != (unsigned __int8 *)v7 )
    {
      v8 = *v6++;
      if ( v8 == 32 )
        *(v6 - 1) = 58;
    }
    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v87, &amp;v84, &quot;:&quot;);
    std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v88, &amp;v87, &amp;v64);
    std::string::_M_assign((std::string *)&amp;v64, v90, v89);
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v88);
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v87);
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84);
  }
  _android_log_print(3, &quot;debug&quot;, &quot;the new LD_PRELOAD is %s&quot;, v65);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v66, &amp;ali::g_filePath, &quot;/juice.data&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v67, &amp;ali::g_filePath, &quot;/fak.jar&quot;);
  fd = open(v68, 0);
  memset(&amp;s, 0, 0x14u);
  sprintf(&amp;s, &quot;%d&quot;, fd);
  std::string::string(&amp;v69, &amp;s, v52);
  v73 = &amp;v72;
  v74 = &amp;v72;
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_allocate_block(&amp;v72, v55 - v56 + 10);
  *v73 = 0;
  std::string::_M_appendT&lt;char const*&gt;(&amp;v72, &quot;DEX_FILE=&quot;, &quot;&quot;, v52);
  std::string::append((std::string *)&amp;v72, (const std::string *)&amp;v54);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v75, &amp;v72, &quot;                     JUICE_FILE=&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v76, &amp;v75, &amp;v66);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v77, &amp;v76, &quot;                     LD_PRELOAD=&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v78, &amp;v77, &amp;v64);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(
    &amp;v79,
    &amp;v78,
    &quot;                     /system/bin/dex2oat \t\t\t\t  \t --runtime-arg -Xms64m \t\t\t\t\t --runtime-arg -Xmx64m \t\t\t\t&quot;
    &quot;\t --boot-image=/system/framework/boot.art                      --zip-fd=&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v80, &amp;v79, &amp;v69);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v81, &amp;v80, &quot;\t\t\t\t\t --zip-location=&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v82, &amp;v81, &amp;v67);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v83, &amp;v82, &quot;\t\t\t\t\t --oat-file=&quot;);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v84, &amp;v83, &amp;v57);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v70, &amp;v84, &quot;                     &quot;);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v84);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v83);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v82);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v81);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v80);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v79);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v78);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v77);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v76);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v75);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v72);
  _android_log_print(3, &quot;debug&quot;, &quot;cmd is %s&quot;, v71);
  system(v71);
  close(fd);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v70);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v69);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v67);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v66);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v64);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v63);
LABEL_24:
  _android_log_print(3, &quot;debug&quot;, &quot;after oat gen&quot;);
  v10 = ali::JDexFile;
  v11 = dword_54140;
  if ( ali::sdk_int &lt;= 19 )                     // sdk version &lt;= 19
  {
    v12 = _JNIEnv::NewStringUTF(v45, v60);
    v13 = _JNIEnv::NewStringUTF(v45, v58);
    v16 = _JNIEnv::CallStaticIntMethod(v45, v10, v11, v12, v13, 0);
    v18 = 0;
  }
  else                                          // sdk version &gt; 19
  {
    v14 = _JNIEnv::NewStringUTF(v45, v60);
    v15 = _JNIEnv::NewStringUTF(v45, v58);
    v16 = _JNIEnv::CallStaticLongMethod(v45, v10, v11, v14, v15, 0);
    v18 = v17;
  }
  _android_log_print(3, &quot;debug&quot;, &quot;cookie is %llx&quot;);
  *(_DWORD *)v46 = v16;
  *((_DWORD *)v46 + 1) = v18;
  v19 = (int (__fastcall *)(int, signed int))dlsym((void *)0xFFFFFFFF, &quot;_ZNK3art7DexFile12FindClassDefEt&quot;);
  _android_log_print(3, &quot;debug&quot;, &quot;DexFile::FindClassDefFn is %p&quot;, v19);
  v20 = v19(v16, 1);
  _android_log_print(3, &quot;debug&quot;, &quot;call FindClassDefFn(%p,%d) =&gt; %p&quot;, v16, 1, v20);
  _android_log_print(3, &quot;debug&quot;, &quot;dex position is %p&quot;, v20 - 572);
  _android_log_print(3, &quot;debug&quot;, &quot;dex head is %08x %08x&quot;, *(_DWORD *)(v20 - 572), *(_DWORD *)(v20 - 568));
  v21 = *(unsigned __int8 **)(v20 - 540);
  _android_log_print(3, &quot;debug&quot;, &quot;dex size is %d&quot;, v21);
  MemEnableWrite((unsigned __int8 *)(v20 - 572), &amp;v21[v20 - 572]);
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v61, &amp;ali::g_filePath, &quot;/juice.data&quot;);
  if ( !ali::dex_juicer_patch((ali *)(v20 - 572), v21, v62, v22) )
  {
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61);
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59);
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57);
    v23 = &amp;v54;
LABEL_44:
    std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v23);
    _android_log_print(3, &quot;debug&quot;, &quot;exit parse_dex&quot;);
    return 0;
  }
  _android_log_print(6, &quot;debug&quot;, &quot;fail to patch dex&quot;);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v61);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v59);
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(&amp;v57);
  v24 = &amp;v54;
LABEL_46:
  std::priv::_String_base&lt;char,std::allocator&lt;char&gt;&gt;::_M_deallocate_block(v24);
  _android_log_print(3, &quot;debug&quot;, &quot;exit parse_dex error&quot;);
  return -1;
}
</code></pre>
<p>在 openWithHeader 中，log 了三次 dex 的 magic number，中间分别进行了 RC4 解密和 LZMA 解压缩。最后得到的结果应该就是最终的 dex 文件：</p>
<pre><code class="cpp">int __fastcall ali::EncFile::openWithHeader(ali::EncFile *this, unsigned __int8 **a2, unsigned int *a3, unsigned int a4)
{
  ali::EncFile *v4; // r5
  unsigned __int8 **v5; // r11
  unsigned int *v6; // r6
  unsigned int v7; // r7
  const char *v8; // r2
  int fd; // r8
  int v10; // r10
  __blksize_t v12; // r3
  unsigned __int8 *v13; // r4
  ali *v14; // r0
  __int64 v15; // r0
  __int64 v16; // ST18_8
  unsigned int *v17; // r3
  ali *v18; // r0
  __int64 v19; // r0
  int v20; // r8
  int v21; // r3
  char v22; // r2
  unsigned __int64 v23; // r0
  ali *v24; // r0
  unsigned __int8 *v25; // r9
  ali *v26; // ST24_4
  __int64 v27; // r0
  __int64 v28; // ST18_8
  ali *v29; // r0
  __int64 v30; // r0
  size_t v31; // [sp+2Ch] [bp-9Ch]
  int v32; // [sp+30h] [bp-98h]
  char v33; // [sp+34h] [bp-94h]
  struct stat buf; // [sp+38h] [bp-90h]

  v4 = this;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( !*((_DWORD *)this + 2) )
  {
    v8 = &quot;file path is null&quot;;
LABEL_5:
    _android_log_print(6, &quot;debug&quot;, v8);
    return 0;
  }
  fd = open(*((const char **)this + 2), 0);
  v10 = fstat(fd, &amp;buf);
  if ( v10 )
  {
    v8 = &quot;fstat failed&quot;;
    goto LABEL_5;
  }
  v12 = buf.st_blksize;
  *v6 = buf.st_blksize;
  *(_DWORD *)v4 = v12;
  v13 = (unsigned __int8 *)mmap(0, *v6, 3, 2, fd, 0);
  *((_DWORD *)v4 + 1) = v13;
  close(fd);
  v14 = (ali *)_android_log_print(
                 3,
                 &quot;debug&quot;,
                 &quot;dex magic %c %c %c %c %c %c %c&quot;,// original dex magic
                 *v13,
                 v13[1],
                 v13[2],
                 v13[3],
                 v13[4],
                 v13[5],
                 v13[6]);
  LODWORD(v15) = ali::NanoTime(v14);
  v16 = v15;
  v18 = (ali *)ali::decryptRc4((ali *)v13, v13, (unsigned __int8 *)v6, v17);// RC4 decrypt
  LODWORD(v19) = ali::NanoTime(v18);
  ali::PrettyDuration((ali *)(v19 - v16), v19 - v16);
  _android_log_print(3, &quot;debug&quot;, &quot;decrypted len:%u&quot;, *v6);
  v20 = 0;
  _android_log_print(
    3,
    &quot;debug&quot;,
    &quot;after decrypt dex magic %c %c %c %c %c %c %c&quot;,// dex magic after RC4
    *v13,
    v13[1],
    v13[2],
    v13[3],
    v13[4],
    v13[5],
    v13[6]);
  v21 = (int)(v13 + 4);
  do
  {
    v22 = 8 * v10++;
    v23 = (unsigned __int64)*(unsigned __int8 *)(v21++ + 1) &lt;&lt; v22;
    v20 += v23;
  }
  while ( v10 != 8 );
  _android_log_print(3, &quot;debug&quot;, &quot;unpackSize: %u&quot;, v20);
  *(_DWORD *)v4 = v7 + v20;
  v24 = (ali *)mmap(0, v7 + v20, 3, 34, -1, 0);
  *((_DWORD *)v4 + 1) = v24;
  v25 = (unsigned __int8 *)v24 + v7;
  v26 = v24;
  LODWORD(v27) = ali::NanoTime(v24);
  v31 = *v6;
  v28 = v27;
  v32 = v20;
  v29 = (ali *)LzmaDecode(v25, &amp;v32, v13 + 13, &amp;v31, v13, 5, 1, &amp;v33, &amp;off_54028);// LZMA uncompress
  LODWORD(v30) = ali::NanoTime(v29);
  ali::PrettyDuration((ali *)(v30 - v28), v30 - v28);
  munmap(v13, buf.st_blksize);
  _android_log_print(
    3,
    &quot;debug&quot;,
    &quot;after uncompressed dex magic %c %c %c %c %c %c %c&quot;,// dex magic after LZMA
    *((unsigned __int8 *)v26 + v7),
    v25[1],
    v25[2],
    v25[3],
    v25[4],
    v25[5],
    v25[6]);
  *v6 = v20;
  if ( v5 )
    *v5 = (unsigned __int8 *)*((_DWORD *)v4 + 1);
  return *((_DWORD *)v4 + 1);
}
</code></pre>
<h1 id="Dump-Dex-File"><a href="#Dump-Dex-File" class="headerlink" title="Dump Dex File"></a>Dump Dex File</h1><p>知道了解析 dex 的流程，接下来就通过动态调试来吧 dex 文件 dump 下来。现在 BL 跳转到 openWithHeader 的语句处设下断点：</p>
<pre><code>.text:00026A7E loc_26A7E                               ; CODE XREF: parse_dex(_JNIEnv *,long long *)+622↑j
.text:00026A7E                 MOV             R1, R9  ; unsigned __int8 **
.text:00026A80                 MOV             R2, R4  ; unsigned int *
.text:00026A82                 MOVS            R3, #0x10 ; unsigned int
.text:00026A84                 BL              _ZN3ali7EncFile14openWithHeaderEPPhPjj ; ali::EncFile::openWithHeader(uchar **,uint *,uint)
.text:00026A88                 LDR.W           R3, [R9]
.text:00026A8C                 ADDS            R3, #0x10
.text:00026A8E                 STR             R3, [R6]
</code></pre><p>运行到断点处，单步步入 openWithHeader 函数，然后单步步过一直到 return，中间可以在 monitor 中用 tag:debug 过滤来查看 log。运行完后看到 log 输出的 magic number 已经是真实 dex 文件的样子了：</p>
<p><img src="/pics/2014-AliCTF-EvilAPK_3/1.png" srcset="/img/loading.gif" alt></p>
<p>根据函数的返回值存放在 R0 中，可以看到 R0 所指向的部分是一个 dex 文件的数据了：</p>
<p><img src="/pics/2014-AliCTF-EvilAPK_3/2.png" srcset="/img/loading.gif" alt></p>
<p>接下来我们可以把 dex 文件给 dump 下来。但文件的大小为多少？根据 dex 的数据结构，可以知道 dex 文件的大小位于偏移 0x20 处：</p>
<p><img src="/pics/2014-AliCTF-EvilAPK_3/3.png" srcset="/img/loading.gif" alt></p>
<p>接下来使用 IDC 脚本来 dump 数据：</p>
<pre><code class="cpp">static main(void) {
    auto fp, begin, end, len, b;
    fp = fopen(&quot;dump.dex&quot;, &quot;wb&quot;);
    begin = 0x7584C010; // 解密后数据在内存中的位置
    len = 0x0941FC; // 文件大小
    end = begin + len;
    for (b = begin; b &lt; end; b++) {
        fputc(Byte(b), fp);
    }
}
</code></pre>
<p>最后将 dump 下来的数据放进 JEB 中，反汇编可以得到真实的 MainActivity 代码：</p>
<p><img src="/pics/2014-AliCTF-EvilAPK_3/4.png" srcset="/img/loading.gif" alt></p>
<h1 id="Fix-Application"><a href="#Fix-Application" class="headerlink" title="Fix Application"></a>Fix Application</h1><p>使用 AndroidKiller 反编译加固后的 apk，找到 AndroidManifest.xml，删除 Application 的 android:name 属性：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ali.tg.testapp&quot; platformBuildVersionCode=&quot;23&quot; platformBuildVersionName=&quot;6.0-2438415&quot;&gt;
    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
    &lt;application android:allowBackup=&quot;true&quot; android:debuggable=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt;
        &lt;activity android:label=&quot;@string/app_name&quot; android:name=&quot;.MainActivity&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
        &lt;activity android:name=&quot;.WebViewActivity&quot;/&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>
<p>回编译后，找到生成的 apk，压缩软件打开，替换我们 dump 出来的 classes.dex，同时删除 assets 文件夹，其他 so 文件不用管。修改完后重新签名打包并安装运行，可以正常使用。</p>
<h1 id="Find-Flag"><a href="#Find-Flag" class="headerlink" title="Find Flag"></a>Find Flag</h1><p>定位到真实的程序后，开始分析具体的内容。先来看 MainActivity，主要是一个点击事件，其中获取了 EditText 中的字符串并作为参数传入并启动 WebViewActivity：</p>
<pre><code class="java">package com.ali.tg.testapp;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;
import android.support.v4.widget.ListViewAutoScrollHelpern;
import android.view.View$OnClickListener;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

public class MainActivity extends Activity {
    class com.ali.tg.testapp.MainActivity$1 implements View$OnClickListener {
        com.ali.tg.testapp.MainActivity$1(MainActivity arg1) {
            MainActivity.this = arg1;
            super();
        }

        public void onClick(View arg6) {
            ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());
            String v1 = MainActivity.this.edit.getText().toString(); // 获取EditText中的字符串
            Intent v0 = new Intent();
            v0.putExtra(ListViewAutoScrollHelpern.decrypt_native(&quot;dV.&quot;, 2), v1); // 将v1的值传给Intent，变量名为“dV.”解密后的值
            v0.setClass(MainActivity.this, WebViewActivity.class); // 设置Intent要跳转的类为WebViewActivity
            MainActivity.this.startActivity(v0); // 启动WebViewActivity
        }
    }

    Button btn_enter;
    View$OnClickListener btn_listener;
    EditText edit;

    public MainActivity() {
        super();
        this.btn_enter = null;
        this.edit = null;
        this.btn_listener = new com.ali.tg.testapp.MainActivity$1(this);
    }

    protected void onCreate(Bundle arg4) {
        ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());
        super.onCreate(arg4);
        this.setContentView(0x7F030000);
        this.edit = this.findViewById(0x7F060001);
        this.btn_enter = this.findViewById(0x7F060002);
        this.btn_enter.setOnClickListener(this.btn_listener);
    }
}
</code></pre>
<p>然后来看看 WebViewActivity，主要就是新建了一个 JavaScriptInterface 对象，对象的名称同样被加密了。然后加载输入的 url，目标是最后能够成功调用对象 JavaScriptInterface 里的 showToast 方法。接下来需要根据密文解出对象名，并构造出相应的网页来弹出 Toast。不过这里好像 flag 就是“祥龙”，但还是继续往下尝试构造出能够弹 Toast 的方法：</p>
<pre><code class="java">package com.ali.tg.testapp;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.support.v4.app.ActionBarDrawerToggleJellybeanMR2n;
import android.support.v4.widget.ListViewAutoScrollHelpern;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.widget.Toast;

public class WebViewActivity extends Activity {
    public class JavaScriptInterface {
        Context mContext;

        JavaScriptInterface(WebViewActivity arg1, Context arg2) {
            WebViewActivity.this = arg1;
            super();
            this.mContext = arg2;
        }

        public void showToast() { // 构造出一个页面能够调用这个函数就成功了
            ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());
            Toast.makeText(this.mContext, &quot;祥龙！&quot;, 0).show();
        }
    }

    WebView wView;

    public WebViewActivity() {
        super();
        this.wView = null;
    }

    protected void onCreate(Bundle arg7) {
        ActionBarDrawerToggleJellybeanMR2n.b(ActionBarDrawerToggleJellybeanMR2n.a());
        super.onCreate(arg7);
        this.setContentView(0x7F030001);
        this.wView = this.findViewById(0x7F060004);
        WebSettings v2 = this.wView.getSettings();
        v2.setJavaScriptEnabled(true);
        v2.setJavaScriptCanOpenWindowsAutomatically(true);
        this.wView.addJavascriptInterface(new JavaScriptInterface(this, ((Context)this)), ListViewAutoScrollHelpern.decrypt_native(&quot;BQ1$*[w6G_&quot;, 2)); // 添加一个JavascriptInterface对象，对象的变量名为“BQ1$*[w6G_”解密后的值
        this.wView.loadUrl(this.getIntent().getStringExtra(ListViewAutoScrollHelpern.decrypt_native(&quot;dV.&quot;, 2))); // 把在MainActivity中获取的变量作为url来加载
    }
}
</code></pre>
<h1 id="Crack"><a href="#Crack" class="headerlink" title="Crack"></a>Crack</h1><p>接下来再看看 ListViewAutoScrollHelpern 中的 decrypt_native 方法，发现是在 Native 层中的 translate 库实现的：</p>
<pre><code class="java">package android.support.v4.widget;

import android.util.Log;

public class ListViewAutoScrollHelpern {
    static {
        System.loadLibrary(&quot;translate&quot;);
    }

    public ListViewAutoScrollHelpern() {
        super();
    }

    public static native String decrypt_native(String arg0, int arg1) {
    }

    public static void testLogv(String arg1) {
        Log.v(&quot;cheatecore&quot;, arg1);
    }

    public static void testLogw(String arg1) {
        Log.w(&quot;cheatecore&quot;, arg1);
    }
}
</code></pre>
<p>然后将 libtranslat.so 载入 IDA。先看看 JNI_OnLoad，其中有两个函数 register_Algorithm 和 register_translate：</p>
<pre><code class="cpp">int __fastcall JNI_OnLoad(_JavaVM *a1)
{
  int v1; // r1
  jint v2; // r2
  _JNIEnv *v3; // r4
  jint v4; // r0
  bool v5; // cf
  int result; // r0
  _JNIEnv *env; // [sp+4h] [bp-Ch]

  env = 0;
  if ( a1-&gt;functions-&gt;GetEnv(&amp;a1-&gt;functions, (void **)&amp;env, 65540) )
    return -1;
  v3 = env;
  register_Algorithm(env, v1, v2);
  v4 = register_translate(v3);
  v5 = v4 &lt; 0;
  result = v4 &amp; (v4 &gt;&gt; 32);
  if ( !v5 )
    result = 65540;
  return result;
}
</code></pre>
<p>在 register_Algorithm 中发现了目标函数：</p>
<pre><code class="cpp">int __fastcall register_Algorithm(_JNIEnv *a1, int a2, jint a3)
{
  _JNIEnv *v3; // r4
  jclass v4; // r0
  jclass v5; // r0

  v3 = a1;
  v4 = a1-&gt;functions-&gt;FindClass(&amp;a1-&gt;functions, &quot;android/support/v4/widget/ListViewAutoScrollHelpern&quot;);
  v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v4, (const JNINativeMethod *)off_607C, 1);
  v5 = v3-&gt;functions-&gt;FindClass(&amp;v3-&gt;functions, &quot;android/support/v4/view/PagerTitleStripIcsn&quot;);
  v3-&gt;functions-&gt;RegisterNatives(&amp;v3-&gt;functions, v5, (const JNINativeMethod *)off_607C, 1);
  return 0;
}
</code></pre>
<p>定位到目标函数，发现其中调用了一个 vigenere_decrypt：</p>
<pre><code class="cpp">jstring __fastcall decrypt_native(_JNIEnv *a1, jobject a2, jstring a3, jint a4)
{
  jstring data; // r6
  jint num; // r9
  _JNIEnv *env; // r4
  const char *v7; // r0
  const char *v8; // r8
  jstring v9; // r7
  int v11; // [sp+4h] [bp+0h]

  data = a3;
  num = a4;
  env = a1;
  memset(&amp;v11, 0, 0x1000u);
  v7 = env-&gt;functions-&gt;GetStringUTFChars(&amp;env-&gt;functions, data, 0);
  v8 = v7;
  if ( num == 2 )
  {
    vigenere_decrypt(v7, (char *)&amp;v11);
    v9 = env-&gt;functions-&gt;NewStringUTF(&amp;env-&gt;functions, (const char *)&amp;v11);
  }
  else
  {
    v9 = data;
  }
  env-&gt;functions-&gt;ReleaseStringUTFChars(&amp;env-&gt;functions, data, v8);
  return v9;
}
</code></pre>
<p>在 vigenere_decrypt 函数中，对输入的数据进行了解密：</p>
<pre><code class="cpp">signed int __fastcall vigenere_decrypt(const char *ciphertext, char *plaintext)
{
  const char *ciphertext_1; // r8
  char *plaintext_1; // r6
  size_t len; // r0
  char *v5; // r2
  const char *table; // r3
  signed int v7; // r7
  int v8; // r0
  int v9; // r1
  int v10; // r5
  int v11; // r0
  int v12; // r10
  char v13; // r3
  signed int i; // r5
  signed int result; // r0
  signed int v16; // r9
  int ch; // r3
  char s; // [sp+4h] [bp-64h]
  char v19; // [sp+48h] [bp-20h]

  ciphertext_1 = ciphertext;
  plaintext_1 = plaintext;
  len = strlen(ciphertext);
  v5 = &amp;s;
  table = &quot;ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU&quot;;
  v7 = len;
  do
  {
    v8 = *(_DWORD *)table;
    table += 8;
    v9 = *((_DWORD *)table - 1);
    *(_DWORD *)v5 = v8;
    *((_DWORD *)v5 + 1) = v9;
    v10 = (int)(v5 + 8);
    v5 += 8;
  }
  while ( table != &quot;tCQU&quot; );
  v11 = *(_DWORD *)table;
  v12 = 0;
  v13 = table[4];
  *(_DWORD *)v10 = v11;
  *(_BYTE *)(v10 + 4) = v13;
  i = 0;
  result = strlen(&amp;s);
  v16 = result;
  while ( i &lt; v7 )
  {
    ch = (unsigned __int8)ciphertext_1[i];
    if ( ch - 32 &lt;= (unsigned int)&#39;^&#39; )         // chr(ch) &lt;= 127
    {
      plaintext_1[i] = (ch - (unsigned __int8)*(&amp;v19 + v12 - 68) + 95) % 95 + 32;// &amp;v19 - 68 = &amp;table
      result = (v12 + 1) / v16;
      v12 = (v12 + 1) % v16;
    }
    else                                        // chr(ch) &gt; 127
    {
      plaintext_1[i] = ch;
    }
    ++i;
  }
  return result;
}
</code></pre>
<p>我先是通过动态调试来获取到了两个字符串的解密结果：</p>
<p><img src="/pics/2014-AliCTF-EvilAPK_3/5.png" srcset="/img/loading.gif" alt></p>
<p><img src="/pics/2014-AliCTF-EvilAPK_3/6.png" srcset="/img/loading.gif" alt></p>
<p>然后尝试自己实现一个解密函数进行验证：</p>
<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *table = &quot;ncA8DaUPelq*S7Y9q#hLl0T##@XTuXHQpFA&amp;65eaUaY33WigYMXO9y7JtCQU&quot;;

char *vigenere_decrypt(char *ciphertext) {
    int j = 0;
    int len = strlen(ciphertext);
    printf(&quot;%d\n&quot;, len);
    char plaintext[len];
    for (int i = 0; i &lt; len; i++) {
        char ch = ciphertext[i];
        if ((ch - 32) &lt;= 0x5E) {
            plaintext[i] = (ch - table[j] + 95) % 95 + 32;
            j = (j + 1) % 16;
        } else {
            plaintext[i] = ch;
        }
    }
    plaintext[len] = &#39;\x00&#39;;
    return plaintext;
}

int main() {
    char *ciphertext1 = &quot;dV.&quot;;
    char *plaintext1 = vigenere_decrypt(ciphertext1);
    printf(&quot;%s\n&quot;, plaintext1); // url
    char *ciphertext2 = &quot;BQ1$*[w6G_&quot;;
    char *plaintext2 = vigenere_decrypt(ciphertext2);
    printf(&quot;%s\n&quot;, plaintext2); // SmokeyBear
    return 0;
}
</code></pre>
<p>当然这里也可以 Hook 这个 so 文件，也可以直接编写代码调用 so 中的函数，条条大路通罗马。最后实现一个调用 Toast 的 html 页面：</p>
<pre><code class="html">&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      function alicrack() {
        SmokeyBear.showToast();
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Crack EvilAPK_3
    &lt;script type=&quot;text/javascript&quot;&gt;
      alicrack();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在软件中输入对应的地址，成功弹窗：</p>
<p><img src="/pics/2014-AliCTF-EvilAPK_3/7.png" srcset="/img/loading.gif" alt></p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://xz.aliyun.com/t/383" target="_blank" rel="noopener">https://xz.aliyun.com/t/383</a><br><a href="https://blog.csdn.net/AliMobileSecurity/article/details/53259788" target="_blank" rel="noopener">https://blog.csdn.net/AliMobileSecurity/article/details/53259788</a><br><a href="https://yq.aliyun.com/articles/64691" target="_blank" rel="noopener">https://yq.aliyun.com/articles/64691</a><br><a href="http://pwn4.fun/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/" target="_blank" rel="noopener">http://pwn4.fun/2017/04/04/Android%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3/</a></p>

            </div>
            <hr>
            <div>
              <p>
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/re/">re</a>
                    
                      <a class="hover-with-bg" href="/tags/android/">android</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-12 col-md-6">
                    
                      <a href="/2020/02/17/分组密码的工作模式/">
                        <i class="fa fa-chevron-left"></i>
                        <span>分组密码的工作模式</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-12 col-md-6">
                    
                      <a href="/2020/02/14/[TODO]Android逆向入门（四）/">
                        <span>Android逆向入门（四）</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="http://blog.b3ale.cn" target="_blank" rel="nofollow noopener"><b>Hard Work Pays Off.</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script>
<script src="/js/main.js"></script>


  <script src="/js/lazyload.js"></script>



  
  <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>







  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- Plugins -->



  <script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "2014-AliCTF-EvilAPK_3&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  










</body>
</html>
